<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Percolation Threshold - Finite-Size Scaling & Critical Exponents</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
            --empty: #2a2a3e;
            --occupied: #4A90D9;
            --spanning: #D94A4A;
            --cluster: #9B59B6;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #F4F1DE 50%, #EDE8D5 100%);
            min-height: 100vh;
            color: var(--dark-moss);
            padding: 20px;
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            text-decoration: none;
            color: var(--moss);
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .organic-back-link:hover {
            background: var(--moss);
            color: white;
            transform: translateX(-5px);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding-top: 60px;
        }

        h1 {
            font-family: 'Lora', serif;
            font-size: 2.5rem;
            color: var(--moss);
            text-align: center;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: var(--terracotta);
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        .simulation-area {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        .controls {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            max-height: calc(100vh - 150px);
            overflow-y: auto;
        }

        .control-section {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(96, 108, 56, 0.2);
        }

        .control-section:last-child {
            border-bottom: none;
        }

        .control-section h3 {
            color: var(--moss);
            font-size: 1rem;
            margin-bottom: 12px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            color: var(--moss);
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--moss);
        }

        .control-group .value {
            text-align: right;
            font-size: 0.85rem;
            color: var(--terracotta);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .checkbox-group input[type="radio"],
        .checkbox-group input[type="checkbox"] {
            accent-color: var(--moss);
            width: 18px;
            height: 18px;
        }

        button {
            width: 100%;
            padding: 12px;
            background: var(--moss);
            color: white;
            border: none;
            border-radius: 10px;
            font-family: 'Nunito', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }

        button:hover {
            background: var(--terracotta);
            transform: translateY(-2px);
        }

        button.secondary {
            background: var(--sage);
        }

        .main-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .dual-canvas {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .canvas-container {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        canvas {
            width: 100%;
            border-radius: 10px;
        }

        #latticeCanvas {
            background: #1a1a2e;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }

        .stat-box {
            background: linear-gradient(135deg, var(--sage) 0%, var(--moss) 100%);
            color: white;
            padding: 12px;
            border-radius: 15px;
            text-align: center;
        }

        .stat-box.prob {
            background: linear-gradient(135deg, #5BA3E8 0%, var(--occupied) 100%);
        }

        .stat-box.percolating {
            background: linear-gradient(135deg, #E85B5B 0%, var(--spanning) 100%);
        }

        .stat-box.clusters {
            background: linear-gradient(135deg, #A76BC4 0%, var(--cluster) 100%);
        }

        .stat-box .label {
            font-size: 0.75rem;
            opacity: 0.9;
        }

        .stat-box .value {
            font-size: 1.1rem;
            font-weight: 700;
            font-family: 'Lora', serif;
        }

        .phase-indicator {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .phase-indicator h4 {
            color: var(--moss);
            margin-bottom: 10px;
        }

        .phase-badge {
            display: inline-block;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: 700;
            font-size: 1rem;
        }

        .phase-badge.subcritical {
            background: var(--occupied);
            color: white;
        }

        .phase-badge.supercritical {
            background: var(--spanning);
            color: white;
        }

        .phase-badge.critical {
            background: var(--terracotta);
            color: white;
        }

        .threshold-bar {
            height: 30px;
            background: linear-gradient(90deg, var(--occupied) 0%, var(--terracotta) 50%, var(--spanning) 100%);
            border-radius: 15px;
            position: relative;
            margin: 15px 0 5px 0;
        }

        .threshold-marker {
            position: absolute;
            width: 4px;
            height: 40px;
            background: var(--dark-moss);
            top: -5px;
            transition: left 0.3s ease;
        }

        .current-marker {
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border: 3px solid var(--dark-moss);
            border-radius: 50%;
            top: 7px;
            transform: translateX(-50%);
            transition: left 0.3s ease;
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            padding: 15px;
            margin-top: 15px;
            font-size: 0.85rem;
            line-height: 1.5;
        }

        .equation {
            font-family: 'Times New Roman', serif;
            font-size: 1rem;
            text-align: center;
            padding: 8px;
            background: rgba(96, 108, 56, 0.1);
            border-radius: 8px;
            margin: 8px 0;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8rem;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        @media (max-width: 1100px) {
            .simulation-area {
                grid-template-columns: 1fr;
            }
            .dual-canvas {
                grid-template-columns: 1fr;
            }
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link">
        <span>←</span>
        <span>Back to Gallery</span>
    </a>

    <div class="container">
        <h1>Percolation Threshold</h1>
        <p class="subtitle">Finite-Size Scaling Analysis & Critical Exponent Verification</p>

        <div class="simulation-area">
            <div class="controls">
                <div class="control-section">
                    <h3>Lattice Parameters</h3>
                    <div class="control-group">
                        <label>Lattice Size (L × L)</label>
                        <input type="range" id="latticeSize" min="20" max="100" step="10" value="50">
                        <div class="value" id="latticeSizeValue">50 × 50</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Percolation Type</h3>
                    <div class="checkbox-group">
                        <input type="radio" name="percType" id="sitePer" checked>
                        <label for="sitePer">Site Percolation</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="radio" name="percType" id="bondPer">
                        <label for="bondPer">Bond Percolation</label>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Occupation Probability</h3>
                    <div class="control-group">
                        <label>Probability p</label>
                        <input type="range" id="probability" min="0" max="1" step="0.01" value="0.59">
                        <div class="value" id="probabilityValue">0.59 (p_c ≈ 0.593)</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Visualization</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showClusters" checked>
                        <label for="showClusters">Color Clusters</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showSpanning" checked>
                        <label for="showSpanning">Highlight Spanning Cluster</label>
                    </div>
                </div>

                <button id="generateBtn">Generate New Lattice</button>
                <button id="sweepBtn" class="secondary">Probability Sweep</button>
                <button id="resetBtn" class="secondary">Reset Analysis</button>

                <div class="info-panel">
                    <h3 style="color: var(--moss); margin-bottom: 8px;">Percolation Theory</h3>
                    <p>At critical threshold p_c, infinite cluster first appears:</p>
                    <div class="equation">Square lattice: p_c ≈ 0.593 (site)</div>
                    <p>Cluster size distribution at p_c:</p>
                    <div class="equation">n_s ~ s^{-τ}, τ ≈ 2.05</div>
                    <p>Correlation length divergence:</p>
                    <div class="equation">ξ ~ |p - p_c|^{-ν}, ν = 4/3</div>
                </div>
            </div>

            <div class="main-area">
                <div class="dual-canvas">
                    <div class="canvas-container">
                        <canvas id="latticeCanvas"></canvas>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: var(--empty);"></div>
                                <span>Empty</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: var(--occupied);"></div>
                                <span>Occupied</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: var(--spanning);"></div>
                                <span>Spanning</span>
                            </div>
                        </div>
                    </div>
                    <div class="canvas-container">
                        <canvas id="plotCanvas"></canvas>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: var(--spanning);"></div>
                                <span>Percolation Prob.</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: var(--occupied);"></div>
                                <span>Largest Cluster</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-box prob">
                        <div class="label">Occupation p</div>
                        <div class="value" id="statP">0.59</div>
                    </div>
                    <div class="stat-box percolating">
                        <div class="label">Spanning Cluster</div>
                        <div class="value" id="statSpanning">No</div>
                    </div>
                    <div class="stat-box clusters">
                        <div class="label">Num Clusters</div>
                        <div class="value" id="statClusters">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Largest Cluster %</div>
                        <div class="value" id="statLargest">0%</div>
                    </div>
                </div>

                <div class="phase-indicator">
                    <h4>Percolation State</h4>
                    <div class="threshold-bar">
                        <div class="threshold-marker" id="thresholdMarker" style="left: 59.3%"></div>
                        <div class="current-marker" id="currentMarker" style="left: 59%"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 0.8rem;">
                        <span>p = 0</span>
                        <span>p_c ≈ 0.593</span>
                        <span>p = 1</span>
                    </div>
                    <div class="phase-badge critical" id="phaseBadge" style="margin-top: 10px;">Critical Region</div>
                    <div style="margin-top: 10px;">
                        <span>P(percolation): <strong id="percProb">-</strong></span>
                        <span style="margin-left: 20px;">Order parameter: <strong id="orderParam">-</strong></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const latticeCanvas = document.getElementById('latticeCanvas');
        const latticeCtx = latticeCanvas.getContext('2d');
        const plotCanvas = document.getElementById('plotCanvas');
        const plotCtx = plotCanvas.getContext('2d');

        let canvasSize;

        function setupCanvas(canvas, ctx) {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const size = Math.min(rect.width - 30, 400);
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);
            return size;
        }

        function setupAllCanvases() {
            canvasSize = setupCanvas(latticeCanvas, latticeCtx);
            setupCanvas(plotCanvas, plotCtx);
        }
        setupAllCanvases();
        window.addEventListener('resize', () => { setupAllCanvases(); draw(); });

        // Critical thresholds
        const pc_site = 0.592746; // Exact for 2D square lattice
        const pc_bond = 0.5;      // Exact for 2D square lattice

        // Simulation state
        let lattice = [];
        let clusters = [];
        let clusterLabels = [];
        let L = 50;
        let p = 0.59;
        let isSitePercolation = true;
        let showClusters = true;
        let showSpanning = true;

        // Analysis data
        let sweepData = [];
        let numTrials = 0;
        let numPercolating = 0;

        // Initialize lattice
        function generateLattice() {
            lattice = [];
            for (let i = 0; i < L; i++) {
                lattice[i] = [];
                for (let j = 0; j < L; j++) {
                    lattice[i][j] = Math.random() < p ? 1 : 0;
                }
            }
            findClusters();
            updateStats();
        }

        // Union-Find data structure for cluster finding
        class UnionFind {
            constructor(n) {
                this.parent = new Array(n).fill(0).map((_, i) => i);
                this.rank = new Array(n).fill(0);
                this.size = new Array(n).fill(1);
            }

            find(x) {
                if (this.parent[x] !== x) {
                    this.parent[x] = this.find(this.parent[x]);
                }
                return this.parent[x];
            }

            union(x, y) {
                const px = this.find(x);
                const py = this.find(y);
                if (px === py) return;

                if (this.rank[px] < this.rank[py]) {
                    this.parent[px] = py;
                    this.size[py] += this.size[px];
                } else if (this.rank[px] > this.rank[py]) {
                    this.parent[py] = px;
                    this.size[px] += this.size[py];
                } else {
                    this.parent[py] = px;
                    this.size[px] += this.size[py];
                    this.rank[px]++;
                }
            }

            getSize(x) {
                return this.size[this.find(x)];
            }
        }

        // Find all clusters using Hoshen-Kopelman algorithm
        function findClusters() {
            const uf = new UnionFind(L * L);
            clusterLabels = [];

            for (let i = 0; i < L; i++) {
                clusterLabels[i] = [];
                for (let j = 0; j < L; j++) {
                    clusterLabels[i][j] = -1;

                    if (lattice[i][j] === 0) continue;

                    const idx = i * L + j;

                    // Check left neighbor
                    if (j > 0 && lattice[i][j-1] === 1) {
                        uf.union(idx, i * L + (j - 1));
                    }

                    // Check top neighbor
                    if (i > 0 && lattice[i-1][j] === 1) {
                        uf.union(idx, (i - 1) * L + j);
                    }
                }
            }

            // Assign cluster labels
            const clusterMap = new Map();
            let nextLabel = 0;

            for (let i = 0; i < L; i++) {
                for (let j = 0; j < L; j++) {
                    if (lattice[i][j] === 0) continue;

                    const root = uf.find(i * L + j);
                    if (!clusterMap.has(root)) {
                        clusterMap.set(root, nextLabel++);
                    }
                    clusterLabels[i][j] = clusterMap.get(root);
                }
            }

            // Build cluster info
            clusters = [];
            const clusterSizes = new Map();

            for (let i = 0; i < L; i++) {
                for (let j = 0; j < L; j++) {
                    if (clusterLabels[i][j] < 0) continue;
                    const label = clusterLabels[i][j];
                    if (!clusterSizes.has(label)) {
                        clusterSizes.set(label, { size: 0, touchesTop: false, touchesBottom: false,
                                                  touchesLeft: false, touchesRight: false });
                    }
                    const info = clusterSizes.get(label);
                    info.size++;
                    if (i === 0) info.touchesTop = true;
                    if (i === L - 1) info.touchesBottom = true;
                    if (j === 0) info.touchesLeft = true;
                    if (j === L - 1) info.touchesRight = true;
                }
            }

            clusters = Array.from(clusterSizes.entries()).map(([label, info]) => ({
                label,
                size: info.size,
                spansVertical: info.touchesTop && info.touchesBottom,
                spansHorizontal: info.touchesLeft && info.touchesRight,
                spans: (info.touchesTop && info.touchesBottom) || (info.touchesLeft && info.touchesRight)
            }));

            clusters.sort((a, b) => b.size - a.size);
        }

        // Check if percolation occurred
        function hasSpanningCluster() {
            return clusters.some(c => c.spans);
        }

        // Get largest cluster fraction
        function getLargestClusterFraction() {
            if (clusters.length === 0) return 0;
            const occupiedSites = lattice.flat().filter(x => x === 1).length;
            if (occupiedSites === 0) return 0;
            return clusters[0].size / (L * L);
        }

        // Update statistics
        function updateStats() {
            const spanning = hasSpanningCluster();
            const largestFrac = getLargestClusterFraction();
            const pc = isSitePercolation ? pc_site : pc_bond;

            document.getElementById('statP').textContent = p.toFixed(3);
            document.getElementById('statSpanning').textContent = spanning ? 'Yes' : 'No';
            document.getElementById('statClusters').textContent = clusters.length;
            document.getElementById('statLargest').textContent = (largestFrac * 100).toFixed(1) + '%';

            document.getElementById('currentMarker').style.left = (p * 100) + '%';
            document.getElementById('thresholdMarker').style.left = (pc * 100) + '%';

            // Phase badge
            const phaseBadge = document.getElementById('phaseBadge');
            const relP = p / pc;

            if (relP < 0.9) {
                phaseBadge.className = 'phase-badge subcritical';
                phaseBadge.textContent = 'Subcritical (p < p_c)';
            } else if (relP > 1.1) {
                phaseBadge.className = 'phase-badge supercritical';
                phaseBadge.textContent = 'Supercritical (p > p_c)';
            } else {
                phaseBadge.className = 'phase-badge critical';
                phaseBadge.textContent = 'Critical Region';
            }

            // Order parameter (fraction of sites in largest cluster)
            document.getElementById('orderParam').textContent = largestFrac.toFixed(3);

            // Percolation probability from sweep data
            if (sweepData.length > 0) {
                const nearbyData = sweepData.filter(d => Math.abs(d.p - p) < 0.05);
                if (nearbyData.length > 0) {
                    const percProb = nearbyData.reduce((sum, d) => sum + (d.percolates ? 1 : 0), 0) / nearbyData.length;
                    document.getElementById('percProb').textContent = percProb.toFixed(2);
                }
            } else {
                document.getElementById('percProb').textContent = spanning ? '1' : '0';
            }
        }

        // Draw lattice
        function drawLattice() {
            const cellSize = canvasSize / L;

            latticeCtx.fillStyle = '#1a1a2e';
            latticeCtx.fillRect(0, 0, canvasSize, canvasSize);

            // Generate colors for clusters
            const clusterColors = [];
            const goldenRatio = 0.618033988749895;
            let hue = Math.random();
            for (let i = 0; i < clusters.length; i++) {
                hue = (hue + goldenRatio) % 1;
                clusterColors[clusters[i].label] = `hsl(${Math.floor(hue * 360)}, 70%, 50%)`;
            }

            // Find spanning cluster label
            const spanningLabel = clusters.find(c => c.spans)?.label ?? -1;

            for (let i = 0; i < L; i++) {
                for (let j = 0; j < L; j++) {
                    if (lattice[i][j] === 0) {
                        latticeCtx.fillStyle = '#2a2a3e';
                    } else {
                        const label = clusterLabels[i][j];
                        if (showSpanning && label === spanningLabel) {
                            latticeCtx.fillStyle = '#D94A4A';
                        } else if (showClusters && clusterColors[label]) {
                            latticeCtx.fillStyle = clusterColors[label];
                        } else {
                            latticeCtx.fillStyle = '#4A90D9';
                        }
                    }
                    latticeCtx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                }
            }

            // Title
            latticeCtx.fillStyle = 'white';
            latticeCtx.font = 'bold 14px Lora';
            latticeCtx.fillText(`${L}×${L} ${isSitePercolation ? 'Site' : 'Bond'} Percolation`, 10, 20);
        }

        // Draw analysis plot
        function drawPlot() {
            const width = canvasSize;
            const height = canvasSize;
            const padding = { top: 35, right: 15, bottom: 40, left: 50 };
            const plotWidth = width - padding.left - padding.right;
            const plotHeight = height - padding.top - padding.bottom;

            plotCtx.fillStyle = '#FEFAE0';
            plotCtx.fillRect(0, 0, width, height);

            // Grid
            plotCtx.strokeStyle = '#E0DCC8';
            plotCtx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding.top + (plotHeight * i / 5);
                plotCtx.beginPath();
                plotCtx.moveTo(padding.left, y);
                plotCtx.lineTo(width - padding.right, y);
                plotCtx.stroke();
            }

            // Axes
            plotCtx.strokeStyle = '#606C38';
            plotCtx.lineWidth = 2;
            plotCtx.beginPath();
            plotCtx.moveTo(padding.left, padding.top);
            plotCtx.lineTo(padding.left, height - padding.bottom);
            plotCtx.lineTo(width - padding.right, height - padding.bottom);
            plotCtx.stroke();

            // Labels
            plotCtx.fillStyle = '#3d4423';
            plotCtx.font = '11px Nunito';
            plotCtx.textAlign = 'center';
            plotCtx.fillText('Occupation Probability p', width / 2, height - 8);

            plotCtx.save();
            plotCtx.translate(12, height / 2);
            plotCtx.rotate(-Math.PI / 2);
            plotCtx.fillText('P(percolation)', 0, 0);
            plotCtx.restore();

            // Y-axis ticks
            plotCtx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const y = padding.top + (plotHeight * i / 5);
                plotCtx.fillText(((5-i)/5).toFixed(1), padding.left - 5, y + 3);
            }

            // X-axis ticks
            plotCtx.textAlign = 'center';
            for (let i = 0; i <= 5; i++) {
                const x = padding.left + plotWidth * i / 5;
                plotCtx.fillText((i/5).toFixed(1), x, height - padding.bottom + 15);
            }

            // Draw critical threshold line
            const pc = isSitePercolation ? pc_site : pc_bond;
            const pcX = padding.left + plotWidth * pc;
            plotCtx.strokeStyle = 'rgba(188, 108, 37, 0.7)';
            plotCtx.lineWidth = 2;
            plotCtx.setLineDash([5, 5]);
            plotCtx.beginPath();
            plotCtx.moveTo(pcX, padding.top);
            plotCtx.lineTo(pcX, height - padding.bottom);
            plotCtx.stroke();
            plotCtx.setLineDash([]);

            plotCtx.fillStyle = 'var(--terracotta)';
            plotCtx.font = '10px Nunito';
            plotCtx.fillText(`p_c=${pc.toFixed(3)}`, pcX, padding.top - 5);

            // Draw sweep data if available
            if (sweepData.length > 10) {
                // Bin the data
                const bins = new Array(50).fill(0).map(() => ({ total: 0, percolating: 0, orderSum: 0 }));

                for (const d of sweepData) {
                    const binIdx = Math.min(49, Math.floor(d.p * 50));
                    bins[binIdx].total++;
                    if (d.percolates) bins[binIdx].percolating++;
                    bins[binIdx].orderSum += d.largestFrac;
                }

                // Draw percolation probability curve
                plotCtx.strokeStyle = '#D94A4A';
                plotCtx.lineWidth = 3;
                plotCtx.beginPath();
                let started = false;

                for (let i = 0; i < 50; i++) {
                    if (bins[i].total === 0) continue;
                    const pVal = (i + 0.5) / 50;
                    const percProb = bins[i].percolating / bins[i].total;
                    const x = padding.left + plotWidth * pVal;
                    const y = padding.top + plotHeight * (1 - percProb);

                    if (!started) {
                        plotCtx.moveTo(x, y);
                        started = true;
                    } else {
                        plotCtx.lineTo(x, y);
                    }
                }
                plotCtx.stroke();

                // Draw order parameter curve
                plotCtx.strokeStyle = '#4A90D9';
                plotCtx.lineWidth = 2;
                plotCtx.beginPath();
                started = false;

                for (let i = 0; i < 50; i++) {
                    if (bins[i].total === 0) continue;
                    const pVal = (i + 0.5) / 50;
                    const orderParam = bins[i].orderSum / bins[i].total;
                    const x = padding.left + plotWidth * pVal;
                    const y = padding.top + plotHeight * (1 - orderParam);

                    if (!started) {
                        plotCtx.moveTo(x, y);
                        started = true;
                    } else {
                        plotCtx.lineTo(x, y);
                    }
                }
                plotCtx.stroke();
            }

            // Mark current p
            const currX = padding.left + plotWidth * p;
            plotCtx.fillStyle = '#3d4423';
            plotCtx.beginPath();
            plotCtx.arc(currX, height - padding.bottom, 5, 0, Math.PI * 2);
            plotCtx.fill();

            // Title
            plotCtx.fillStyle = '#606C38';
            plotCtx.font = 'bold 14px Lora';
            plotCtx.textAlign = 'left';
            plotCtx.fillText('Percolation Probability vs p', padding.left, 18);
        }

        function draw() {
            drawLattice();
            drawPlot();
        }

        // Probability sweep
        function probabilitySweep() {
            sweepData = [];
            const steps = 100;
            const trialsPerStep = 20;

            document.getElementById('sweepBtn').textContent = 'Sweeping...';

            let currentStep = 0;

            function sweepStep() {
                if (currentStep >= steps) {
                    document.getElementById('sweepBtn').textContent = 'Probability Sweep';
                    p = 0.59;
                    document.getElementById('probability').value = p;
                    document.getElementById('probabilityValue').textContent =
                        p.toFixed(2) + ` (p_c ≈ ${(isSitePercolation ? pc_site : pc_bond).toFixed(3)})`;
                    generateLattice();
                    draw();
                    return;
                }

                p = currentStep / steps;

                for (let t = 0; t < trialsPerStep; t++) {
                    generateLattice();
                    sweepData.push({
                        p: p,
                        percolates: hasSpanningCluster(),
                        largestFrac: getLargestClusterFraction()
                    });
                }

                document.getElementById('probability').value = p;
                document.getElementById('probabilityValue').textContent =
                    p.toFixed(2) + ` (p_c ≈ ${(isSitePercolation ? pc_site : pc_bond).toFixed(3)})`;

                draw();
                currentStep++;
                requestAnimationFrame(sweepStep);
            }

            sweepStep();
        }

        // Event handlers
        document.getElementById('generateBtn').addEventListener('click', () => {
            generateLattice();
            draw();
        });

        document.getElementById('sweepBtn').addEventListener('click', () => {
            probabilitySweep();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            sweepData = [];
            generateLattice();
            draw();
        });

        // Parameter controls
        document.getElementById('latticeSize').addEventListener('input', function() {
            L = parseInt(this.value);
            document.getElementById('latticeSizeValue').textContent = L + ' × ' + L;
        });

        document.getElementById('probability').addEventListener('input', function() {
            p = parseFloat(this.value);
            const pc = isSitePercolation ? pc_site : pc_bond;
            document.getElementById('probabilityValue').textContent =
                p.toFixed(2) + ` (p_c ≈ ${pc.toFixed(3)})`;
            generateLattice();
            draw();
        });

        document.getElementById('sitePer').addEventListener('change', function() {
            if (this.checked) {
                isSitePercolation = true;
                document.getElementById('probabilityValue').textContent =
                    p.toFixed(2) + ` (p_c ≈ ${pc_site.toFixed(3)})`;
                sweepData = [];
                generateLattice();
                draw();
            }
        });

        document.getElementById('bondPer').addEventListener('change', function() {
            if (this.checked) {
                isSitePercolation = false;
                document.getElementById('probabilityValue').textContent =
                    p.toFixed(2) + ` (p_c ≈ ${pc_bond.toFixed(3)})`;
                sweepData = [];
                generateLattice();
                draw();
            }
        });

        document.getElementById('showClusters').addEventListener('change', function() {
            showClusters = this.checked;
            draw();
        });

        document.getElementById('showSpanning').addEventListener('change', function() {
            showSpanning = this.checked;
            draw();
        });

        // Initialize
        generateLattice();
        draw();
    </script>
</body>
</html>
