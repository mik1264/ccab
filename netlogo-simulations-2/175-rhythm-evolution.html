<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm Evolution - Interactive Genetic Algorithm - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; display: flex; flex-direction: column; }
        canvas { display: block; flex: 1; }
        #controls { width: 320px; background: rgba(0,0,0,0.85); padding: 20px; overflow-y: auto; }
        h1 { font-family: 'Lora', serif; font-size: 1.3rem; margin-bottom: 15px; color: #f97316; }
        .section-title { font-size: 0.9rem; color: #f97316; margin: 15px 0 10px; border-bottom: 1px solid rgba(249,115,22,0.3); padding-bottom: 5px; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 4px; color: #aaa; }
        input[type="range"] { width: 100%; accent-color: #f97316; }
        button { width: 100%; padding: 10px; margin-bottom: 8px; background: linear-gradient(135deg, #f97316 0%, #ea580c 100%); color: #fff; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; transition: all 0.2s; }
        button:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(249,115,22,0.3); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .btn-secondary { background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%); }
        .btn-success { background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); }
        .stats { background: rgba(255,255,255,0.08); padding: 12px; border-radius: 8px; font-size: 0.85rem; margin-top: 15px; }
        .stats div { margin: 5px 0; display: flex; justify-content: space-between; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #f97316; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .info-panel { background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%); padding: 15px; border-radius: 10px; margin-top: 15px; border: 1px solid rgba(249,115,22,0.2); }
        .info-panel h3 { font-family: 'Lora', serif; color: #f97316; margin-bottom: 10px; font-size: 1rem; }
        .info-panel p { font-size: 0.8rem; line-height: 1.5; color: #ccc; }
        #patterns { padding: 10px; }
        .pattern-row { display: flex; align-items: center; margin: 8px 0; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 8px; cursor: pointer; transition: all 0.2s; }
        .pattern-row:hover { background: rgba(249,115,22,0.2); }
        .pattern-row.selected { background: rgba(249,115,22,0.4); border: 2px solid #f97316; }
        .pattern-beats { display: flex; gap: 3px; flex: 1; }
        .beat { width: 20px; height: 30px; border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 10px; }
        .beat.on { background: linear-gradient(135deg, #f97316 0%, #fb923c 100%); color: #fff; }
        .beat.off { background: rgba(255,255,255,0.1); }
        .pattern-fitness { width: 40px; text-align: center; color: #f97316; font-weight: bold; }
        .pattern-play { width: 30px; height: 30px; border-radius: 50%; background: #6366f1; border: none; color: #fff; cursor: pointer; margin-left: 8px; font-size: 12px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <div id="patterns"></div>
        </div>
        <div id="controls">
            <h1>Rhythm Evolution</h1>

            <div class="section-title">Genetic Algorithm</div>
            <div class="control-group">
                <label>Population Size: <span id="popValue">8</span></label>
                <input type="range" id="popSize" min="4" max="16" step="2" value="8">
            </div>
            <div class="control-group">
                <label>Mutation Rate: <span id="mutValue">0.1</span></label>
                <input type="range" id="mutRate" min="0.05" max="0.5" step="0.05" value="0.1">
            </div>
            <div class="control-group">
                <label>Beats Per Pattern: <span id="beatsValue">16</span></label>
                <input type="range" id="beatsCount" min="8" max="32" step="4" value="16">
            </div>

            <div class="section-title">Playback</div>
            <div class="control-group">
                <label>Tempo: <span id="tempoValue">120</span> BPM</label>
                <input type="range" id="tempo" min="60" max="200" step="10" value="120">
            </div>

            <button id="newGen">New Random Population</button>
            <button id="evolve" class="btn-success" disabled>Evolve Selected (min 2)</button>
            <button id="playAll" class="btn-secondary">Play All Sequentially</button>

            <div class="stats">
                <div><span>Generation:</span><span id="generation">1</span></div>
                <div><span>Patterns Selected:</span><span id="selectedCount">0</span></div>
                <div><span>Avg Density:</span><span id="avgDensity">0%</span></div>
                <div><span>Best Fitness:</span><span id="bestFitness">0</span></div>
            </div>

            <div class="info-panel">
                <h3>How to Use</h3>
                <p>1. Click patterns you like (select at least 2)<br>
                   2. Click "Evolve Selected" to breed them<br>
                   3. Repeat to evolve towards rhythms you prefer<br>
                   4. Click ▶ to preview individual patterns</p>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const patternsContainer = document.getElementById('patterns');

        let params = { popSize: 8, mutRate: 0.1, beatsCount: 16, tempo: 120 };
        let population = [];
        let selectedIndices = new Set();
        let generation = 1;
        let isPlaying = false;
        let audioCtx = null;

        function resize() {
            const container = document.getElementById('canvas-container');
            canvas.width = container.clientWidth * dpr;
            canvas.height = 200 * dpr;
            canvas.style.width = container.clientWidth + 'px';
            canvas.style.height = '200px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        // Create a random rhythm pattern
        function createRandomPattern() {
            const beats = [];
            for (let i = 0; i < params.beatsCount; i++) {
                // More likely to have beats on strong positions (0, 4, 8, 12)
                const prob = (i % 4 === 0) ? 0.7 : (i % 2 === 0) ? 0.4 : 0.2;
                beats.push(Math.random() < prob ? 1 : 0);
            }
            return { beats, fitness: 0 };
        }

        // Crossover two patterns
        function crossover(parent1, parent2) {
            const child = { beats: [], fitness: 0 };
            const crossPoint = Math.floor(Math.random() * params.beatsCount);

            for (let i = 0; i < params.beatsCount; i++) {
                child.beats[i] = i < crossPoint ? parent1.beats[i] : parent2.beats[i];
            }

            return child;
        }

        // Mutate a pattern
        function mutate(pattern) {
            for (let i = 0; i < pattern.beats.length; i++) {
                if (Math.random() < params.mutRate) {
                    pattern.beats[i] = pattern.beats[i] === 1 ? 0 : 1;
                }
            }
        }

        // Calculate fitness based on musical properties
        function calculateFitness(pattern) {
            let fitness = 0;
            const beats = pattern.beats;

            // Reward having a beat on the first position
            if (beats[0] === 1) fitness += 10;

            // Reward beats on strong positions (every 4th beat)
            for (let i = 0; i < beats.length; i += 4) {
                if (beats[i] === 1) fitness += 5;
            }

            // Reward reasonable density (not too sparse, not too full)
            const density = beats.reduce((a, b) => a + b, 0) / beats.length;
            if (density >= 0.25 && density <= 0.6) fitness += 15;

            // Reward syncopation (off-beat hits)
            for (let i = 1; i < beats.length; i += 2) {
                if (beats[i] === 1 && beats[i - 1] === 0) fitness += 3;
            }

            // Slight penalty for too many consecutive beats
            let consecutive = 0;
            for (let i = 0; i < beats.length; i++) {
                if (beats[i] === 1) {
                    consecutive++;
                    if (consecutive > 4) fitness -= 2;
                } else {
                    consecutive = 0;
                }
            }

            pattern.fitness = Math.max(0, fitness);
        }

        // Generate initial population
        function generatePopulation() {
            population = [];
            selectedIndices.clear();
            generation = 1;

            for (let i = 0; i < params.popSize; i++) {
                const pattern = createRandomPattern();
                calculateFitness(pattern);
                population.push(pattern);
            }

            updateStats();
            renderPatterns();
            draw();
        }

        // Evolve to next generation
        function evolve() {
            if (selectedIndices.size < 2) return;

            const selected = Array.from(selectedIndices).map(i => population[i]);
            const newPopulation = [];

            // Keep the selected patterns (elitism)
            for (const pattern of selected) {
                newPopulation.push({ beats: [...pattern.beats], fitness: pattern.fitness });
            }

            // Fill remaining slots with offspring
            while (newPopulation.length < params.popSize) {
                // Tournament selection from selected patterns
                const parent1 = selected[Math.floor(Math.random() * selected.length)];
                const parent2 = selected[Math.floor(Math.random() * selected.length)];

                const child = crossover(parent1, parent2);
                mutate(child);
                calculateFitness(child);
                newPopulation.push(child);
            }

            population = newPopulation;
            selectedIndices.clear();
            generation++;

            updateStats();
            renderPatterns();
            draw();
            document.getElementById('evolve').disabled = true;
        }

        // Render pattern rows
        function renderPatterns() {
            patternsContainer.innerHTML = '';

            population.forEach((pattern, idx) => {
                const row = document.createElement('div');
                row.className = 'pattern-row' + (selectedIndices.has(idx) ? ' selected' : '');
                row.dataset.index = idx;

                const beatsDiv = document.createElement('div');
                beatsDiv.className = 'pattern-beats';

                pattern.beats.forEach((beat, i) => {
                    const beatDiv = document.createElement('div');
                    beatDiv.className = 'beat ' + (beat === 1 ? 'on' : 'off');
                    if (i % 4 === 0) beatDiv.style.borderLeft = '2px solid #666';
                    beatsDiv.appendChild(beatDiv);
                });

                const fitnessDiv = document.createElement('div');
                fitnessDiv.className = 'pattern-fitness';
                fitnessDiv.textContent = pattern.fitness;

                const playBtn = document.createElement('button');
                playBtn.className = 'pattern-play';
                playBtn.innerHTML = '▶';
                playBtn.onclick = (e) => {
                    e.stopPropagation();
                    playPattern(pattern);
                };

                row.appendChild(beatsDiv);
                row.appendChild(fitnessDiv);
                row.appendChild(playBtn);

                row.onclick = () => toggleSelection(idx);

                patternsContainer.appendChild(row);
            });
        }

        // Toggle pattern selection
        function toggleSelection(idx) {
            if (selectedIndices.has(idx)) {
                selectedIndices.delete(idx);
            } else {
                selectedIndices.add(idx);
            }

            document.getElementById('evolve').disabled = selectedIndices.size < 2;
            document.getElementById('selectedCount').textContent = selectedIndices.size;
            renderPatterns();
            draw();
        }

        // Play a rhythm pattern
        function playPattern(pattern) {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }

            const beatDuration = 60 / params.tempo / 4; // 16th notes
            let time = audioCtx.currentTime;

            pattern.beats.forEach((beat, i) => {
                if (beat === 1) {
                    playDrumHit(time + i * beatDuration, i % 4 === 0 ? 'kick' : 'hihat');
                }
            });
        }

        // Play drum hit sound
        function playDrumHit(time, type) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'kick') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(50, time + 0.1);
                gain.gain.setValueAtTime(0.5, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
                osc.start(time);
                osc.stop(time + 0.15);
            } else {
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, time);
                gain.gain.setValueAtTime(0.1, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
                osc.start(time);
                osc.stop(time + 0.05);
            }
        }

        // Play all patterns sequentially
        function playAllSequentially() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }

            const patternDuration = (params.beatsCount * 60) / (params.tempo * 4);
            let startTime = audioCtx.currentTime;

            population.forEach((pattern, idx) => {
                const beatDuration = 60 / params.tempo / 4;
                const offset = startTime + idx * patternDuration;

                pattern.beats.forEach((beat, i) => {
                    if (beat === 1) {
                        playDrumHit(offset + i * beatDuration, i % 4 === 0 ? 'kick' : 'hihat');
                    }
                });
            });
        }

        // Update stats display
        function updateStats() {
            document.getElementById('generation').textContent = generation;
            document.getElementById('selectedCount').textContent = selectedIndices.size;

            const avgDensity = population.reduce((sum, p) => {
                return sum + p.beats.reduce((a, b) => a + b, 0) / p.beats.length;
            }, 0) / population.length;
            document.getElementById('avgDensity').textContent = (avgDensity * 100).toFixed(0) + '%';

            const bestFitness = Math.max(...population.map(p => p.fitness));
            document.getElementById('bestFitness').textContent = bestFitness;
        }

        // Draw visualization
        function draw() {
            const w = canvas.width / dpr;
            const h = canvas.height / dpr;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, w, h);

            // Draw fitness landscape
            const barWidth = w / population.length;

            ctx.fillStyle = '#f97316';
            ctx.font = 'bold 14px Lora';
            ctx.textAlign = 'center';
            ctx.fillText(`Generation ${generation} - Rhythm Evolution`, w / 2, 25);

            population.forEach((pattern, idx) => {
                const barHeight = (pattern.fitness / 50) * (h - 60);
                const x = idx * barWidth + 10;
                const y = h - 30 - barHeight;

                // Bar
                const selected = selectedIndices.has(idx);
                const gradient = ctx.createLinearGradient(x, y, x, h - 30);
                gradient.addColorStop(0, selected ? '#fb923c' : '#f97316');
                gradient.addColorStop(1, selected ? '#f97316' : '#ea580c');

                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, barWidth - 20, barHeight);

                // Selection indicator
                if (selected) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x - 2, y - 2, barWidth - 16, barHeight + 4);
                }

                // Label
                ctx.fillStyle = '#aaa';
                ctx.font = '10px Nunito';
                ctx.fillText(`#${idx + 1}`, x + (barWidth - 20) / 2, h - 15);

                // Fitness value
                ctx.fillStyle = '#fff';
                ctx.fillText(pattern.fitness, x + (barWidth - 20) / 2, y - 5);
            });

            // Draw best pattern visualization
            const bestIdx = population.reduce((best, p, i, arr) => p.fitness > arr[best].fitness ? i : best, 0);
            const best = population[bestIdx];

            ctx.fillStyle = '#666';
            ctx.font = '11px Nunito';
            ctx.textAlign = 'left';
            ctx.fillText('Best pattern:', 10, 55);

            const beatW = 15;
            best.beats.forEach((beat, i) => {
                ctx.fillStyle = beat === 1 ? '#f97316' : 'rgba(255,255,255,0.1)';
                ctx.fillRect(100 + i * (beatW + 2), 45, beatW, 20);
                if (i % 4 === 0) {
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(100 + i * (beatW + 2), 45);
                    ctx.lineTo(100 + i * (beatW + 2), 65);
                    ctx.stroke();
                }
            });
        }

        // Event listeners
        document.getElementById('popSize').addEventListener('input', e => {
            params.popSize = parseInt(e.target.value);
            document.getElementById('popValue').textContent = params.popSize;
        });

        document.getElementById('mutRate').addEventListener('input', e => {
            params.mutRate = parseFloat(e.target.value);
            document.getElementById('mutValue').textContent = params.mutRate.toFixed(2);
        });

        document.getElementById('beatsCount').addEventListener('input', e => {
            params.beatsCount = parseInt(e.target.value);
            document.getElementById('beatsValue').textContent = params.beatsCount;
        });

        document.getElementById('tempo').addEventListener('input', e => {
            params.tempo = parseInt(e.target.value);
            document.getElementById('tempoValue').textContent = params.tempo;
        });

        document.getElementById('newGen').addEventListener('click', generatePopulation);
        document.getElementById('evolve').addEventListener('click', evolve);
        document.getElementById('playAll').addEventListener('click', playAllSequentially);

        window.addEventListener('resize', resize);

        // Initialize
        resize();
        generatePopulation();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
