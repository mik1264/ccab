<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lekking Behavior - NetLogo Simulation</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            color: var(--dark-moss);
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .subtitle {
            color: var(--moss);
            font-size: 1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .control-group {
            margin-bottom: 16px;
        }

        .control-group label {
            display: block;
            color: var(--dark-moss);
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 0.85rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            border: 2px solid var(--sage);
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .value-display {
            text-align: right;
            color: var(--moss);
            font-size: 0.8rem;
            margin-top: 3px;
        }

        .buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 80px;
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--sage);
            color: white;
        }

        .btn-primary:hover {
            background: var(--moss);
        }

        .btn-secondary {
            background: var(--earth);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--terracotta);
        }

        .visualization-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 15px;
        }

        .viz-panel {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .viz-panel h3 {
            color: var(--dark-moss);
            font-size: 0.9rem;
            margin-bottom: 10px;
            text-align: center;
        }

        canvas {
            width: 100%;
            height: 250px;
            border-radius: 8px;
            background: #1a1a2e;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 15px;
        }

        .stat-item {
            background: var(--cream);
            padding: 8px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--terracotta);
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--moss);
        }

        .info-box {
            background: linear-gradient(135deg, var(--cream) 0%, #fff 100%);
            border-left: 4px solid var(--sage);
            padding: 12px;
            margin-top: 15px;
            border-radius: 0 8px 8px 0;
            font-size: 0.8rem;
            color: var(--dark-moss);
        }

        .back-link {
            display: inline-block;
            margin-bottom: 15px;
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
        }

        .back-link:hover {
            color: var(--terracotta);
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Simulations</a>

        <header>
            <h1>Lekking Behavior</h1>
            <p class="subtitle">Male Display Aggregations, Female Choice, and Lek Formation Hypotheses</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-group">
                    <label>Number of Males</label>
                    <input type="range" id="numMales" min="10" max="50" value="25">
                    <div class="value-display" id="numMalesVal">25</div>
                </div>

                <div class="control-group">
                    <label>Number of Females</label>
                    <input type="range" id="numFemales" min="10" max="50" value="30">
                    <div class="value-display" id="numFemalesVal">30</div>
                </div>

                <div class="control-group">
                    <label>Male Quality Variance</label>
                    <input type="range" id="qualityVariance" min="5" max="50" value="25">
                    <div class="value-display" id="qualityVarianceVal">25</div>
                </div>

                <div class="control-group">
                    <label>Female Discrimination</label>
                    <input type="range" id="femaleDisc" min="10" max="100" value="60">
                    <div class="value-display" id="femaleDiscVal">60%</div>
                </div>

                <div class="control-group">
                    <label>Hotshot Attraction</label>
                    <input type="range" id="hotshotAttraction" min="0" max="100" value="50">
                    <div class="value-display" id="hotshotAttractionVal">50%</div>
                </div>

                <div class="control-group">
                    <label>Hotspot Strength</label>
                    <input type="range" id="hotspotStrength" min="0" max="100" value="30">
                    <div class="value-display" id="hotspotStrengthVal">30%</div>
                </div>

                <div class="control-group">
                    <label>Display Cost</label>
                    <input type="range" id="displayCost" min="1" max="30" value="10">
                    <div class="value-display" id="displayCostVal">10</div>
                </div>

                <div class="control-group">
                    <label>Lek Formation Model</label>
                    <select id="lekModel">
                        <option value="combined">Combined Model</option>
                        <option value="hotshot">Hotshot Only</option>
                        <option value="hotspot">Hotspot Only</option>
                        <option value="femaleChoice">Female Choice Only</option>
                    </select>
                </div>

                <div class="buttons">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="numLeks">0</div>
                        <div class="stat-label">Lek Clusters</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="matingSkew">0</div>
                        <div class="stat-label">Mating Skew</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="avgLekSize">0</div>
                        <div class="stat-label">Avg Lek Size</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalMatings">0</div>
                        <div class="stat-label">Total Matings</div>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Lek Hypotheses:</strong> Hotshots attract subordinates seeking females.
                    Hotspots form where female paths overlap. Female choice drives aggregation
                    for easier comparison. Strong mating skew creates the "lek paradox."
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-panel">
                    <h3>Lek Arena</h3>
                    <canvas id="arenaCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Mating Success Distribution</h3>
                    <canvas id="matingCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Male Quality vs Mating Success</h3>
                    <canvas id="qualityCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Lek Size Evolution</h3>
                    <canvas id="evolutionCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const arenaCanvas = document.getElementById('arenaCanvas');
        const matingCanvas = document.getElementById('matingCanvas');
        const qualityCanvas = document.getElementById('qualityCanvas');
        const evolutionCanvas = document.getElementById('evolutionCanvas');

        const arenaCtx = arenaCanvas.getContext('2d');
        const matingCtx = matingCanvas.getContext('2d');
        const qualityCtx = qualityCanvas.getContext('2d');
        const evolutionCtx = evolutionCanvas.getContext('2d');

        function resizeCanvases() {
            [arenaCanvas, matingCanvas, qualityCanvas, evolutionCanvas].forEach(canvas => {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                canvas.getContext('2d').scale(window.devicePixelRatio, window.devicePixelRatio);
            });
        }
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        // Simulation state
        let running = false;
        let tick = 0;
        let males = [];
        let females = [];
        let hotspots = [];
        let lekHistory = [];
        let totalMatings = 0;

        class Male {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.id = id;
                this.quality = Math.random(); // 0-1, higher = better
                this.displayIntensity = 0;
                this.energy = 100;
                this.matings = 0;
                this.territory = null;

                // Display animation
                this.displayPhase = Math.random() * Math.PI * 2;

                // Calculate derived properties
                this.attractiveness = this.quality;
            }

            display(cost) {
                if (this.energy > cost) {
                    this.displayIntensity = this.quality * 0.7 + 0.3;
                    this.energy -= cost * 0.1;
                    this.displayPhase += 0.1;
                } else {
                    this.displayIntensity *= 0.9;
                }

                // Energy recovery
                this.energy = Math.min(100, this.energy + 0.5);
            }

            moveTowardsHotshot(males, attraction) {
                if (attraction <= 0) return;

                // Find hotshot (highest quality male within view)
                let hotshot = null;
                let maxQuality = this.quality;

                males.forEach(other => {
                    if (other.id !== this.id) {
                        const dist = Math.hypot(other.x - this.x, other.y - this.y);
                        if (dist < 150 && other.quality > maxQuality) {
                            maxQuality = other.quality;
                            hotshot = other;
                        }
                    }
                });

                if (hotshot && maxQuality > this.quality * 1.2) {
                    // Move towards hotshot, but maintain some distance
                    const dx = hotshot.x - this.x;
                    const dy = hotshot.y - this.y;
                    const dist = Math.hypot(dx, dy);

                    if (dist > 20 && dist < 100) {
                        this.x += (dx / dist) * attraction * 0.3;
                        this.y += (dy / dist) * attraction * 0.3;
                    } else if (dist <= 20) {
                        // Maintain territory space
                        this.x -= (dx / dist) * 0.5;
                        this.y -= (dy / dist) * 0.5;
                    }
                }
            }

            moveTowardsHotspot(hotspots, strength) {
                if (strength <= 0 || hotspots.length === 0) return;

                // Find nearest hotspot
                let nearest = null;
                let minDist = Infinity;

                hotspots.forEach(hs => {
                    const dist = Math.hypot(hs.x - this.x, hs.y - this.y);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = hs;
                    }
                });

                if (nearest && minDist > 30) {
                    const dx = nearest.x - this.x;
                    const dy = nearest.y - this.y;
                    this.x += (dx / minDist) * strength * 0.2;
                    this.y += (dy / minDist) * strength * 0.2;
                }
            }

            avoidOverlap(males) {
                males.forEach(other => {
                    if (other.id !== this.id) {
                        const dx = this.x - other.x;
                        const dy = this.y - other.y;
                        const dist = Math.hypot(dx, dy);

                        if (dist < 15 && dist > 0) {
                            this.x += (dx / dist) * 2;
                            this.y += (dy / dist) * 2;
                        }
                    }
                });
            }

            boundToArena(w, h) {
                this.x = Math.max(20, Math.min(w - 20, this.x));
                this.y = Math.max(20, Math.min(h - 20, this.y));
            }
        }

        class Female {
            constructor() {
                const w = arenaCanvas.width / window.devicePixelRatio;
                const h = arenaCanvas.height / window.devicePixelRatio;

                this.x = Math.random() * w;
                this.y = Math.random() * h;
                this.state = 'searching'; // searching, evaluating, mated
                this.target = null;
                this.evaluationTime = 0;
                this.sampledMales = [];
                this.mated = false;
                this.mateQuality = 0;
            }

            update(males, params) {
                if (this.mated) return;

                const w = arenaCanvas.width / window.devicePixelRatio;
                const h = arenaCanvas.height / window.devicePixelRatio;

                if (this.state === 'searching') {
                    // Move around, looking for leks
                    this.x += (Math.random() - 0.5) * 4;
                    this.y += (Math.random() - 0.5) * 4;

                    // Attracted to male aggregations
                    let centerX = 0, centerY = 0, count = 0;
                    males.forEach(m => {
                        if (m.displayIntensity > 0.3) {
                            const dist = Math.hypot(m.x - this.x, m.y - this.y);
                            if (dist < 150) {
                                centerX += m.x;
                                centerY += m.y;
                                count++;
                            }
                        }
                    });

                    if (count > 2) {
                        centerX /= count;
                        centerY /= count;
                        const dx = centerX - this.x;
                        const dy = centerY - this.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist > 10) {
                            this.x += (dx / dist) * 2;
                            this.y += (dy / dist) * 2;
                        }
                    }

                    // Find displaying males to sample
                    males.forEach(m => {
                        const dist = Math.hypot(m.x - this.x, m.y - this.y);
                        if (dist < 50 && m.displayIntensity > 0.3 &&
                            !this.sampledMales.includes(m)) {
                            this.sampledMales.push(m);
                        }
                    });

                    // Start evaluation if enough males sampled
                    if (this.sampledMales.length >= 3) {
                        this.state = 'evaluating';
                        this.evaluationTime = 0;
                    }
                }

                else if (this.state === 'evaluating') {
                    this.evaluationTime++;

                    // Female discrimination affects how long she evaluates
                    const evalDuration = 30 + (params.femaleDisc / 100) * 50;

                    if (this.evaluationTime > evalDuration) {
                        // Choose mate based on quality and discrimination
                        this.sampledMales.sort((a, b) => b.quality - a.quality);

                        // Higher discrimination = more likely to choose best
                        const discriminationEffect = params.femaleDisc / 100;

                        for (let i = 0; i < this.sampledMales.length; i++) {
                            const chooseProbability = discriminationEffect /
                                Math.pow(i + 1, discriminationEffect * 2);

                            if (Math.random() < chooseProbability) {
                                this.target = this.sampledMales[i];
                                this.target.matings++;
                                this.mated = true;
                                this.mateQuality = this.target.quality;
                                totalMatings++;
                                break;
                            }
                        }

                        // If didn't choose, reset
                        if (!this.mated) {
                            this.sampledMales = [];
                            this.state = 'searching';
                        }
                    }
                }

                // Bounds
                this.x = Math.max(10, Math.min(w - 10, this.x));
                this.y = Math.max(10, Math.min(h - 10, this.y));
            }
        }

        function initSimulation() {
            const numMales = parseInt(document.getElementById('numMales').value);
            const numFemales = parseInt(document.getElementById('numFemales').value);
            const qualityVariance = parseInt(document.getElementById('qualityVariance').value) / 100;

            males = [];
            females = [];
            hotspots = [];
            lekHistory = [];
            tick = 0;
            totalMatings = 0;

            const w = arenaCanvas.width / window.devicePixelRatio;
            const h = arenaCanvas.height / window.devicePixelRatio;

            // Create hotspots (resource patches or female movement intersections)
            const numHotspots = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < numHotspots; i++) {
                hotspots.push({
                    x: 50 + Math.random() * (w - 100),
                    y: 50 + Math.random() * (h - 100),
                    strength: 0.5 + Math.random() * 0.5
                });
            }

            // Create males
            for (let i = 0; i < numMales; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const male = new Male(x, y, i);

                // Apply quality variance
                const baseQuality = Math.random();
                male.quality = Math.pow(baseQuality, 1 / (1 + qualityVariance));
                male.attractiveness = male.quality;

                males.push(male);
            }

            // Create females
            for (let i = 0; i < numFemales; i++) {
                females.push(new Female());
            }
        }

        function getParams() {
            return {
                qualityVariance: parseInt(document.getElementById('qualityVariance').value),
                femaleDisc: parseInt(document.getElementById('femaleDisc').value),
                hotshotAttraction: parseInt(document.getElementById('hotshotAttraction').value) / 100,
                hotspotStrength: parseInt(document.getElementById('hotspotStrength').value) / 100,
                displayCost: parseInt(document.getElementById('displayCost').value),
                lekModel: document.getElementById('lekModel').value
            };
        }

        function simulationStep() {
            const params = getParams();
            tick++;

            const w = arenaCanvas.width / window.devicePixelRatio;
            const h = arenaCanvas.height / window.devicePixelRatio;

            // Males display and move
            males.forEach(male => {
                male.display(params.displayCost);

                // Apply movement based on model
                if (params.lekModel === 'hotshot' || params.lekModel === 'combined') {
                    male.moveTowardsHotshot(males, params.hotshotAttraction);
                }
                if (params.lekModel === 'hotspot' || params.lekModel === 'combined') {
                    male.moveTowardsHotspot(hotspots, params.hotspotStrength);
                }

                male.avoidOverlap(males);
                male.boundToArena(w, h);
            });

            // Females search and choose
            females.forEach(female => {
                female.update(males, params);
            });

            // Record lek sizes
            if (tick % 10 === 0) {
                const leks = identifyLeks();
                lekHistory.push({
                    numLeks: leks.length,
                    avgSize: leks.length > 0 ?
                        leks.reduce((s, l) => s + l.size, 0) / leks.length : 0,
                    maxSize: leks.length > 0 ?
                        Math.max(...leks.map(l => l.size)) : 0
                });
                if (lekHistory.length > 200) lekHistory.shift();
            }

            // Reset females periodically for continuous dynamics
            if (tick % 200 === 0) {
                females = females.map(() => new Female());
            }

            updateStats();
        }

        function identifyLeks() {
            // Cluster males based on proximity
            const clusters = [];
            const visited = new Set();

            males.forEach(male => {
                if (visited.has(male.id)) return;

                const cluster = [male];
                visited.add(male.id);

                // Find all connected males
                let toCheck = [male];
                while (toCheck.length > 0) {
                    const current = toCheck.pop();

                    males.forEach(other => {
                        if (!visited.has(other.id)) {
                            const dist = Math.hypot(current.x - other.x, current.y - other.y);
                            if (dist < 40) {
                                cluster.push(other);
                                visited.add(other.id);
                                toCheck.push(other);
                            }
                        }
                    });
                }

                if (cluster.length >= 3) {
                    const centerX = cluster.reduce((s, m) => s + m.x, 0) / cluster.length;
                    const centerY = cluster.reduce((s, m) => s + m.y, 0) / cluster.length;
                    clusters.push({
                        x: centerX,
                        y: centerY,
                        size: cluster.length,
                        males: cluster
                    });
                }
            });

            return clusters;
        }

        function updateStats() {
            const leks = identifyLeks();

            document.getElementById('numLeks').textContent = leks.length;
            document.getElementById('avgLekSize').textContent =
                leks.length > 0 ?
                (leks.reduce((s, l) => s + l.size, 0) / leks.length).toFixed(1) : '0';
            document.getElementById('totalMatings').textContent = totalMatings;

            // Calculate mating skew (Gini coefficient)
            const matings = males.map(m => m.matings).sort((a, b) => a - b);
            let gini = 0;
            const n = matings.length;
            const sumMatings = matings.reduce((a, b) => a + b, 0) || 1;

            for (let i = 0; i < n; i++) {
                gini += (2 * (i + 1) - n - 1) * matings[i];
            }
            gini = gini / (n * sumMatings);

            document.getElementById('matingSkew').textContent = gini.toFixed(2);
        }

        function draw() {
            drawArena();
            drawMatingDistribution();
            drawQualityVsMating();
            drawEvolution();
        }

        function drawArena() {
            const w = arenaCanvas.width / window.devicePixelRatio;
            const h = arenaCanvas.height / window.devicePixelRatio;

            arenaCtx.fillStyle = '#1a1a2e';
            arenaCtx.fillRect(0, 0, w, h);

            // Draw hotspots
            hotspots.forEach(hs => {
                const gradient = arenaCtx.createRadialGradient(
                    hs.x, hs.y, 0, hs.x, hs.y, 60
                );
                gradient.addColorStop(0, 'rgba(139, 195, 74, 0.3)');
                gradient.addColorStop(1, 'rgba(139, 195, 74, 0)');
                arenaCtx.fillStyle = gradient;
                arenaCtx.beginPath();
                arenaCtx.arc(hs.x, hs.y, 60, 0, Math.PI * 2);
                arenaCtx.fill();
            });

            // Draw lek boundaries
            const leks = identifyLeks();
            leks.forEach(lek => {
                arenaCtx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
                arenaCtx.lineWidth = 2;
                arenaCtx.beginPath();
                arenaCtx.arc(lek.x, lek.y, 50, 0, Math.PI * 2);
                arenaCtx.stroke();
            });

            // Draw males
            males.forEach(male => {
                // Display animation
                const displayRadius = 5 + male.displayIntensity * 8;
                const pulseRadius = displayRadius + Math.sin(male.displayPhase) * 3;

                // Quality-based color (brighter = higher quality)
                const hue = 200 + male.quality * 40; // Blue to cyan
                const lightness = 30 + male.quality * 40;

                // Display aura
                if (male.displayIntensity > 0.3) {
                    arenaCtx.fillStyle = `hsla(${hue}, 80%, ${lightness}%, 0.3)`;
                    arenaCtx.beginPath();
                    arenaCtx.arc(male.x, male.y, pulseRadius + 10, 0, Math.PI * 2);
                    arenaCtx.fill();
                }

                // Male body
                arenaCtx.fillStyle = `hsl(${hue}, 80%, ${lightness}%)`;
                arenaCtx.beginPath();
                arenaCtx.arc(male.x, male.y, pulseRadius, 0, Math.PI * 2);
                arenaCtx.fill();

                // Mating indicator
                if (male.matings > 0) {
                    arenaCtx.fillStyle = '#ff4081';
                    arenaCtx.font = '10px sans-serif';
                    arenaCtx.fillText(male.matings, male.x + 10, male.y - 10);
                }
            });

            // Draw females
            females.forEach(female => {
                if (female.mated) {
                    arenaCtx.fillStyle = '#ff4081';
                } else if (female.state === 'evaluating') {
                    arenaCtx.fillStyle = '#ffeb3b';
                } else {
                    arenaCtx.fillStyle = '#e91e63';
                }

                arenaCtx.beginPath();
                arenaCtx.arc(female.x, female.y, 5, 0, Math.PI * 2);
                arenaCtx.fill();

                // Sampling radius
                if (female.state === 'evaluating') {
                    arenaCtx.strokeStyle = 'rgba(255, 235, 59, 0.3)';
                    arenaCtx.beginPath();
                    arenaCtx.arc(female.x, female.y, 50, 0, Math.PI * 2);
                    arenaCtx.stroke();
                }
            });

            // Legend
            arenaCtx.font = '10px sans-serif';
            arenaCtx.fillStyle = '#4fc3f7';
            arenaCtx.fillText('● High-quality Male', 10, h - 45);
            arenaCtx.fillStyle = '#1976d2';
            arenaCtx.fillText('● Low-quality Male', 10, h - 30);
            arenaCtx.fillStyle = '#e91e63';
            arenaCtx.fillText('● Female', 10, h - 15);
        }

        function drawMatingDistribution() {
            const w = matingCanvas.width / window.devicePixelRatio;
            const h = matingCanvas.height / window.devicePixelRatio;

            matingCtx.fillStyle = '#1a1a2e';
            matingCtx.fillRect(0, 0, w, h);

            const padding = 40;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Create histogram of matings
            const maxMatings = Math.max(...males.map(m => m.matings), 1);
            const bins = Math.min(maxMatings + 1, 15);
            const histogram = new Array(bins).fill(0);

            males.forEach(m => {
                const bin = Math.min(m.matings, bins - 1);
                histogram[bin]++;
            });

            const maxCount = Math.max(...histogram, 1);

            // Axes
            matingCtx.strokeStyle = '#666';
            matingCtx.beginPath();
            matingCtx.moveTo(padding, padding);
            matingCtx.lineTo(padding, h - padding);
            matingCtx.lineTo(w - padding, h - padding);
            matingCtx.stroke();

            // Labels
            matingCtx.fillStyle = '#aaa';
            matingCtx.font = '10px sans-serif';
            matingCtx.fillText('Males', 5, h / 2);
            matingCtx.fillText('Matings', w / 2 - 20, h - 5);

            // Draw bars
            const barWidth = plotW / bins * 0.8;
            histogram.forEach((count, i) => {
                const x = padding + (i / bins) * plotW + (plotW / bins * 0.1);
                const barH = (count / maxCount) * plotH;
                const y = h - padding - barH;

                // Gradient from blue to pink
                const hue = 200 + (i / bins) * 140;
                matingCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                matingCtx.fillRect(x, y, barWidth, barH);

                // Bin label
                matingCtx.fillStyle = '#888';
                matingCtx.font = '8px sans-serif';
                matingCtx.fillText(i, x + barWidth / 2 - 3, h - padding + 12);
            });
        }

        function drawQualityVsMating() {
            const w = qualityCanvas.width / window.devicePixelRatio;
            const h = qualityCanvas.height / window.devicePixelRatio;

            qualityCtx.fillStyle = '#1a1a2e';
            qualityCtx.fillRect(0, 0, w, h);

            const padding = 45;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Axes
            qualityCtx.strokeStyle = '#666';
            qualityCtx.beginPath();
            qualityCtx.moveTo(padding, padding);
            qualityCtx.lineTo(padding, h - padding);
            qualityCtx.lineTo(w - padding, h - padding);
            qualityCtx.stroke();

            // Labels
            qualityCtx.fillStyle = '#aaa';
            qualityCtx.font = '10px sans-serif';
            qualityCtx.fillText('Matings', 5, h / 2);
            qualityCtx.fillText('Quality', w / 2 - 15, h - 5);

            const maxMatings = Math.max(...males.map(m => m.matings), 1);

            // Plot males
            males.forEach(male => {
                const x = padding + male.quality * plotW;
                const y = h - padding - (male.matings / maxMatings) * plotH;

                const hue = 200 + male.quality * 40;
                qualityCtx.fillStyle = `hsl(${hue}, 80%, 50%)`;
                qualityCtx.beginPath();
                qualityCtx.arc(x, y, 6, 0, Math.PI * 2);
                qualityCtx.fill();
            });

            // Trend line (linear regression)
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
            const n = males.length;
            males.forEach(m => {
                sumX += m.quality;
                sumY += m.matings;
                sumXY += m.quality * m.matings;
                sumX2 += m.quality * m.quality;
            });

            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            qualityCtx.strokeStyle = '#ff9800';
            qualityCtx.lineWidth = 2;
            qualityCtx.setLineDash([5, 5]);
            qualityCtx.beginPath();
            qualityCtx.moveTo(padding, h - padding - (intercept / maxMatings) * plotH);
            qualityCtx.lineTo(
                w - padding,
                h - padding - ((intercept + slope) / maxMatings) * plotH
            );
            qualityCtx.stroke();
            qualityCtx.setLineDash([]);

            // Correlation label
            const correlation = (n * sumXY - sumX * sumY) /
                Math.sqrt((n * sumX2 - sumX * sumX) *
                (n * males.reduce((s, m) => s + m.matings * m.matings, 0) - sumY * sumY));
            qualityCtx.fillStyle = '#ff9800';
            qualityCtx.fillText(`r = ${(correlation || 0).toFixed(2)}`, w - 60, padding + 15);
        }

        function drawEvolution() {
            const w = evolutionCanvas.width / window.devicePixelRatio;
            const h = evolutionCanvas.height / window.devicePixelRatio;

            evolutionCtx.fillStyle = '#1a1a2e';
            evolutionCtx.fillRect(0, 0, w, h);

            if (lekHistory.length < 2) return;

            const padding = 40;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Axes
            evolutionCtx.strokeStyle = '#666';
            evolutionCtx.beginPath();
            evolutionCtx.moveTo(padding, padding);
            evolutionCtx.lineTo(padding, h - padding);
            evolutionCtx.lineTo(w - padding, h - padding);
            evolutionCtx.stroke();

            // Labels
            evolutionCtx.fillStyle = '#aaa';
            evolutionCtx.font = '10px sans-serif';
            evolutionCtx.fillText('Size', 5, h / 2);
            evolutionCtx.fillText('Time', w / 2 - 10, h - 5);

            const maxSize = Math.max(...lekHistory.map(d => d.maxSize), 10);

            // Draw average lek size
            evolutionCtx.strokeStyle = '#4CAF50';
            evolutionCtx.lineWidth = 2;
            evolutionCtx.beginPath();

            lekHistory.forEach((d, i) => {
                const x = padding + (i / (lekHistory.length - 1)) * plotW;
                const y = h - padding - (d.avgSize / maxSize) * plotH;
                if (i === 0) evolutionCtx.moveTo(x, y);
                else evolutionCtx.lineTo(x, y);
            });
            evolutionCtx.stroke();

            // Draw max lek size
            evolutionCtx.strokeStyle = '#2196F3';
            evolutionCtx.beginPath();

            lekHistory.forEach((d, i) => {
                const x = padding + (i / (lekHistory.length - 1)) * plotW;
                const y = h - padding - (d.maxSize / maxSize) * plotH;
                if (i === 0) evolutionCtx.moveTo(x, y);
                else evolutionCtx.lineTo(x, y);
            });
            evolutionCtx.stroke();

            // Draw number of leks
            evolutionCtx.strokeStyle = '#ff9800';
            evolutionCtx.setLineDash([5, 5]);
            evolutionCtx.beginPath();

            const maxLeks = Math.max(...lekHistory.map(d => d.numLeks), 1);
            lekHistory.forEach((d, i) => {
                const x = padding + (i / (lekHistory.length - 1)) * plotW;
                const y = h - padding - (d.numLeks / maxLeks) * plotH;
                if (i === 0) evolutionCtx.moveTo(x, y);
                else evolutionCtx.lineTo(x, y);
            });
            evolutionCtx.stroke();
            evolutionCtx.setLineDash([]);

            // Legend
            evolutionCtx.fillStyle = '#4CAF50';
            evolutionCtx.fillText('● Avg Size', w - 80, 20);
            evolutionCtx.fillStyle = '#2196F3';
            evolutionCtx.fillText('● Max Size', w - 80, 35);
            evolutionCtx.fillStyle = '#ff9800';
            evolutionCtx.fillText('- # Leks', w - 80, 50);
        }

        function animate() {
            if (running) {
                simulationStep();
            }
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            initSimulation();
        });

        // Slider value displays
        const sliders = [
            ['numMales', 'numMalesVal', v => v],
            ['numFemales', 'numFemalesVal', v => v],
            ['qualityVariance', 'qualityVarianceVal', v => v],
            ['femaleDisc', 'femaleDiscVal', v => v + '%'],
            ['hotshotAttraction', 'hotshotAttractionVal', v => v + '%'],
            ['hotspotStrength', 'hotspotStrengthVal', v => v + '%'],
            ['displayCost', 'displayCostVal', v => v]
        ];

        sliders.forEach(([id, displayId, formatter]) => {
            const input = document.getElementById(id);
            const display = document.getElementById(displayId);
            input.addEventListener('input', () => {
                display.textContent = formatter(parseInt(input.value));
            });
        });

        // Initialize
        initSimulation();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
