<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turbulent Flow - Lattice Boltzmann Simulation</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #F4F1DE 50%, #EDE8D5 100%);
            min-height: 100vh;
            color: var(--dark-moss);
            padding: 20px;
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            text-decoration: none;
            color: var(--moss);
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .organic-back-link:hover {
            background: var(--moss);
            color: white;
            transform: translateX(-5px);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding-top: 60px;
        }

        h1 {
            font-family: 'Lora', serif;
            font-size: 2.5rem;
            color: var(--moss);
            text-align: center;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: var(--terracotta);
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        .simulation-area {
            display: grid;
            grid-template-columns: 280px 1fr 280px;
            gap: 20px;
        }

        .controls, .stats-panel {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            max-height: calc(100vh - 150px);
            overflow-y: auto;
        }

        .control-section {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(96, 108, 56, 0.2);
        }

        .control-section:last-child {
            border-bottom: none;
        }

        .control-section h3 {
            color: var(--moss);
            font-size: 1rem;
            margin-bottom: 12px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            color: var(--moss);
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--moss);
        }

        .control-group .value {
            text-align: right;
            font-size: 0.85rem;
            color: var(--terracotta);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .checkbox-group input[type="checkbox"],
        .checkbox-group input[type="radio"] {
            accent-color: var(--moss);
            width: 18px;
            height: 18px;
        }

        button {
            width: 100%;
            padding: 12px;
            background: var(--moss);
            color: white;
            border: none;
            border-radius: 10px;
            font-family: 'Nunito', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }

        button:hover {
            background: var(--dark-moss);
            transform: translateY(-2px);
        }

        button.secondary {
            background: var(--terracotta);
        }

        button.secondary:hover {
            background: #a05a1f;
        }

        .canvas-container {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        canvas {
            display: block;
            width: 100%;
            border-radius: 10px;
            cursor: crosshair;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(96, 108, 56, 0.1);
        }

        .stat-label {
            font-weight: 600;
            color: var(--moss);
        }

        .stat-value {
            color: var(--terracotta);
            font-weight: 700;
        }

        .chart-container {
            height: 80px;
            margin-top: 15px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            padding: 10px;
        }

        .chart-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--moss);
            margin-bottom: 5px;
        }

        .mini-canvas {
            width: 100%;
            height: 50px;
            border-radius: 5px;
            background: white;
        }

        .legend {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
            font-size: 0.75rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .legend-color {
            width: 20px;
            height: 10px;
            border-radius: 2px;
        }

        .info-box {
            background: rgba(138, 154, 91, 0.1);
            border-left: 3px solid var(--sage);
            padding: 12px;
            border-radius: 0 10px 10px 0;
            margin-top: 15px;
            font-size: 0.85rem;
            line-height: 1.5;
        }

        @media (max-width: 1200px) {
            .simulation-area {
                grid-template-columns: 1fr;
            }
            .controls, .stats-panel {
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link">
        <span class="back-arrow">←</span>
        <span class="back-text">Gallery</span>
    </a>

    <div class="container">
        <h1>Turbulent Flow Simulation</h1>
        <p class="subtitle">Lattice Boltzmann Method with Eddy Formation & Energy Cascade</p>

        <div class="simulation-area">
            <div class="controls">
                <div class="control-section">
                    <h3>Simulation Controls</h3>
                    <button id="startBtn">Start Flow</button>
                    <button id="resetBtn" class="secondary">Reset</button>
                    <button id="clearObstacles">Clear Obstacles</button>
                </div>

                <div class="control-section">
                    <h3>Flow Parameters</h3>
                    <div class="control-group">
                        <label>Flow Speed: <span class="value" id="speedVal">0.12</span></label>
                        <input type="range" id="speed" min="0.02" max="0.25" value="0.12" step="0.01">
                    </div>
                    <div class="control-group">
                        <label>Viscosity: <span class="value" id="viscosityVal">0.02</span></label>
                        <input type="range" id="viscosity" min="0.005" max="0.1" value="0.02" step="0.005">
                    </div>
                    <div class="control-group">
                        <label>Reynolds Number: <span class="value" id="reynoldsVal">--</span></label>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Obstacles</h3>
                    <p style="font-size: 0.85rem; margin-bottom: 10px;">Click and drag to draw obstacles</p>
                    <div class="control-group">
                        <label>Brush Size: <span class="value" id="brushVal">10</span></label>
                        <input type="range" id="brush" min="3" max="30" value="10" step="1">
                    </div>
                    <button id="addCylinder" class="secondary">Add Cylinder</button>
                    <button id="addWing" class="secondary">Add Airfoil</button>
                </div>

                <div class="control-section">
                    <h3>Visualization</h3>
                    <div class="checkbox-group">
                        <input type="radio" name="display" id="displayCurl" checked>
                        <label for="displayCurl">Vorticity (Curl)</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="radio" name="display" id="displaySpeed">
                        <label for="displaySpeed">Speed</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="radio" name="display" id="displayPressure">
                        <label for="displayPressure">Pressure</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showStreamlines">
                        <label for="showStreamlines">Show Streamlines</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showVectors">
                        <label for="showVectors">Show Velocity Vectors</label>
                    </div>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="simCanvas" width="800" height="400"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #0000FF, #00FFFF, #00FF00, #FFFF00, #FF0000);"></div>
                        <span>Vorticity: CCW to CW</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #333;"></div>
                        <span>Obstacle</span>
                    </div>
                </div>
            </div>

            <div class="stats-panel">
                <div class="control-section">
                    <h3>Flow Statistics</h3>
                    <div class="stat-item">
                        <span class="stat-label">Avg. Velocity:</span>
                        <span class="stat-value" id="statVelocity">0.00</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Max Vorticity:</span>
                        <span class="stat-value" id="statVorticity">0.00</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Kinetic Energy:</span>
                        <span class="stat-value" id="statEnergy">0.00</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Enstrophy:</span>
                        <span class="stat-value" id="statEnstrophy">0.00</span>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Turbulence Metrics</h3>
                    <div class="stat-item">
                        <span class="stat-label">Num. Eddies:</span>
                        <span class="stat-value" id="statEddies">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Drag Force:</span>
                        <span class="stat-value" id="statDrag">0.00</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Lift Force:</span>
                        <span class="stat-value" id="statLift">0.00</span>
                    </div>
                </div>

                <div class="chart-container">
                    <div class="chart-title">Energy Spectrum</div>
                    <canvas id="spectrumChart" class="mini-canvas"></canvas>
                </div>

                <div class="info-box">
                    <strong>Physics:</strong> The Lattice Boltzmann Method simulates fluid flow by tracking particle distributions on a discrete lattice. Turbulence emerges at high Reynolds numbers (Re = UL/ν), creating eddies that transfer energy from large to small scales - the famous Kolmogorov energy cascade.
                </div>
            </div>
        </div>
    </div>

    <script>
        // Lattice Boltzmann Method Turbulent Flow Simulation
        // D2Q9 model implementation

        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const spectrumCanvas = document.getElementById('spectrumChart');
        const spectrumCtx = spectrumCanvas.getContext('2d');

        // Grid dimensions
        const scale = 2;
        const nx = Math.floor(canvas.width / scale);
        const ny = Math.floor(canvas.height / scale);

        // D2Q9 velocity directions
        // 6 2 5
        // 3 0 1
        // 7 4 8
        const cx = [0, 1, 0, -1, 0, 1, -1, -1, 1];
        const cy = [0, 0, 1, 0, -1, 1, 1, -1, -1];
        const w = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
        const opposite = [0, 3, 4, 1, 2, 7, 8, 5, 6];

        // Simulation arrays
        let f = [];      // Distribution functions
        let fNew = [];   // New distributions after streaming
        let rho = [];    // Density
        let ux = [];     // X velocity
        let uy = [];     // Y velocity
        let barrier = []; // Obstacle map
        let curl = [];   // Vorticity

        // Parameters
        let viscosity = 0.02;
        let flowSpeed = 0.12;
        let omega; // Relaxation parameter

        // State
        let running = false;
        let animationId = null;
        let step = 0;
        let energyHistory = [];

        // Mouse state for drawing
        let isDrawing = false;
        let brushSize = 10;

        // Display mode
        let displayMode = 'curl'; // 'curl', 'speed', 'pressure'
        let showStreamlines = false;
        let showVectors = false;

        // Initialize arrays
        function initArrays() {
            f = [];
            fNew = [];
            rho = [];
            ux = [];
            uy = [];
            barrier = [];
            curl = [];

            for (let i = 0; i < nx; i++) {
                f[i] = [];
                fNew[i] = [];
                rho[i] = [];
                ux[i] = [];
                uy[i] = [];
                barrier[i] = [];
                curl[i] = [];

                for (let j = 0; j < ny; j++) {
                    f[i][j] = [];
                    fNew[i][j] = [];
                    rho[i][j] = 1;
                    ux[i][j] = flowSpeed;
                    uy[i][j] = 0;
                    barrier[i][j] = false;
                    curl[i][j] = 0;

                    // Initialize equilibrium distribution
                    for (let k = 0; k < 9; k++) {
                        f[i][j][k] = equilibrium(k, 1, flowSpeed, 0);
                        fNew[i][j][k] = 0;
                    }
                }
            }

            // Calculate omega from viscosity
            omega = 1 / (3 * viscosity + 0.5);

            step = 0;
            energyHistory = [];
        }

        // Calculate equilibrium distribution
        function equilibrium(k, rhoVal, uxVal, uyVal) {
            const cu = cx[k] * uxVal + cy[k] * uyVal;
            const u2 = uxVal * uxVal + uyVal * uyVal;
            return w[k] * rhoVal * (1 + 3 * cu + 4.5 * cu * cu - 1.5 * u2);
        }

        // Collision step (BGK)
        function collide() {
            for (let i = 0; i < nx; i++) {
                for (let j = 0; j < ny; j++) {
                    if (barrier[i][j]) continue;

                    // Calculate macroscopic quantities
                    let rhoSum = 0;
                    let uxSum = 0;
                    let uySum = 0;

                    for (let k = 0; k < 9; k++) {
                        rhoSum += f[i][j][k];
                        uxSum += f[i][j][k] * cx[k];
                        uySum += f[i][j][k] * cy[k];
                    }

                    rho[i][j] = rhoSum;
                    ux[i][j] = uxSum / rhoSum;
                    uy[i][j] = uySum / rhoSum;

                    // Apply collision
                    for (let k = 0; k < 9; k++) {
                        const feq = equilibrium(k, rhoSum, ux[i][j], uy[i][j]);
                        f[i][j][k] = f[i][j][k] + omega * (feq - f[i][j][k]);
                    }
                }
            }
        }

        // Streaming step
        function stream() {
            for (let i = 0; i < nx; i++) {
                for (let j = 0; j < ny; j++) {
                    for (let k = 0; k < 9; k++) {
                        const ni = i - cx[k];
                        const nj = j - cy[k];

                        if (ni >= 0 && ni < nx && nj >= 0 && nj < ny) {
                            if (barrier[ni][nj]) {
                                // Bounce-back from obstacle
                                fNew[i][j][k] = f[i][j][opposite[k]];
                            } else {
                                fNew[i][j][k] = f[ni][nj][k];
                            }
                        } else {
                            // Boundary conditions
                            if (ni < 0) {
                                // Left boundary: inlet with fixed velocity
                                fNew[i][j][k] = equilibrium(k, 1, flowSpeed, 0);
                            } else if (ni >= nx) {
                                // Right boundary: outlet (copy from neighbor)
                                fNew[i][j][k] = f[nx-1][j][k];
                            } else {
                                // Top/bottom: periodic or bounce-back
                                const wrapJ = (nj + ny) % ny;
                                fNew[i][j][k] = f[i][wrapJ][k];
                            }
                        }
                    }
                }
            }

            // Swap arrays
            const temp = f;
            f = fNew;
            fNew = temp;
        }

        // Calculate vorticity (curl of velocity)
        function calculateCurl() {
            for (let i = 1; i < nx - 1; i++) {
                for (let j = 1; j < ny - 1; j++) {
                    if (!barrier[i][j]) {
                        // Central difference approximation
                        curl[i][j] = (uy[i+1][j] - uy[i-1][j] - ux[i][j+1] + ux[i][j-1]) * 0.5;
                    }
                }
            }
        }

        // Calculate statistics
        function calculateStats() {
            let totalVel = 0;
            let maxCurl = 0;
            let totalEnergy = 0;
            let totalEnstrophy = 0;
            let count = 0;
            let dragForce = 0;
            let liftForce = 0;

            for (let i = 0; i < nx; i++) {
                for (let j = 0; j < ny; j++) {
                    if (!barrier[i][j]) {
                        const speed = Math.sqrt(ux[i][j] * ux[i][j] + uy[i][j] * uy[i][j]);
                        totalVel += speed;
                        totalEnergy += 0.5 * rho[i][j] * speed * speed;
                        totalEnstrophy += curl[i][j] * curl[i][j];
                        if (Math.abs(curl[i][j]) > maxCurl) maxCurl = Math.abs(curl[i][j]);
                        count++;
                    }

                    // Calculate forces on obstacles
                    if (barrier[i][j]) {
                        for (let di = -1; di <= 1; di++) {
                            for (let dj = -1; dj <= 1; dj++) {
                                const ni = i + di;
                                const nj = j + dj;
                                if (ni >= 0 && ni < nx && nj >= 0 && nj < ny && !barrier[ni][nj]) {
                                    dragForce += (rho[ni][nj] - 1) * di;
                                    liftForce += (rho[ni][nj] - 1) * dj;
                                }
                            }
                        }
                    }
                }
            }

            // Track energy for spectrum
            energyHistory.push(totalEnergy);
            if (energyHistory.length > 200) energyHistory.shift();

            // Count eddies (local vorticity extrema)
            let eddyCount = 0;
            for (let i = 2; i < nx - 2; i++) {
                for (let j = 2; j < ny - 2; j++) {
                    if (!barrier[i][j] && Math.abs(curl[i][j]) > 0.01) {
                        const c = curl[i][j];
                        let isExtremum = true;
                        for (let di = -1; di <= 1; di++) {
                            for (let dj = -1; dj <= 1; dj++) {
                                if (di === 0 && dj === 0) continue;
                                if (c > 0 && curl[i+di][j+dj] > c) isExtremum = false;
                                if (c < 0 && curl[i+di][j+dj] < c) isExtremum = false;
                            }
                        }
                        if (isExtremum) eddyCount++;
                    }
                }
            }

            // Calculate Reynolds number
            const charLength = 50; // Characteristic length (obstacle size)
            const reynolds = flowSpeed * charLength / viscosity;

            return {
                avgVelocity: totalVel / count,
                maxVorticity: maxCurl,
                kineticEnergy: totalEnergy,
                enstrophy: totalEnstrophy,
                eddyCount,
                dragForce: dragForce * 100,
                liftForce: liftForce * 100,
                reynolds
            };
        }

        // Draw simulation
        function draw() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            calculateCurl();

            // Find range for normalization
            let minVal = Infinity, maxVal = -Infinity;

            for (let i = 0; i < nx; i++) {
                for (let j = 0; j < ny; j++) {
                    if (!barrier[i][j]) {
                        let val;
                        if (displayMode === 'curl') {
                            val = curl[i][j];
                        } else if (displayMode === 'speed') {
                            val = Math.sqrt(ux[i][j] * ux[i][j] + uy[i][j] * uy[i][j]);
                        } else {
                            val = rho[i][j] - 1; // Pressure deviation
                        }
                        if (val < minVal) minVal = val;
                        if (val > maxVal) maxVal = val;
                    }
                }
            }

            const range = Math.max(maxVal - minVal, 0.001);

            // Draw fluid
            for (let i = 0; i < nx; i++) {
                for (let j = 0; j < ny; j++) {
                    for (let sx = 0; sx < scale; sx++) {
                        for (let sy = 0; sy < scale; sy++) {
                            const px = i * scale + sx;
                            const py = j * scale + sy;
                            const idx = (py * canvas.width + px) * 4;

                            if (barrier[i][j]) {
                                data[idx] = 50;
                                data[idx + 1] = 50;
                                data[idx + 2] = 60;
                                data[idx + 3] = 255;
                            } else {
                                let val;
                                if (displayMode === 'curl') {
                                    val = curl[i][j];
                                } else if (displayMode === 'speed') {
                                    val = Math.sqrt(ux[i][j] * ux[i][j] + uy[i][j] * uy[i][j]);
                                } else {
                                    val = rho[i][j] - 1;
                                }

                                const normalized = (val - minVal) / range;
                                const color = getColor(normalized, displayMode === 'curl' ? val : 0);

                                data[idx] = color.r;
                                data[idx + 1] = color.g;
                                data[idx + 2] = color.b;
                                data[idx + 3] = 255;
                            }
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw streamlines
            if (showStreamlines) {
                drawStreamlines();
            }

            // Draw velocity vectors
            if (showVectors) {
                drawVectors();
            }

            // Update stats
            const stats = calculateStats();
            document.getElementById('statVelocity').textContent = stats.avgVelocity.toFixed(4);
            document.getElementById('statVorticity').textContent = stats.maxVorticity.toFixed(4);
            document.getElementById('statEnergy').textContent = stats.kineticEnergy.toFixed(2);
            document.getElementById('statEnstrophy').textContent = stats.enstrophy.toFixed(4);
            document.getElementById('statEddies').textContent = stats.eddyCount;
            document.getElementById('statDrag').textContent = stats.dragForce.toFixed(3);
            document.getElementById('statLift').textContent = stats.liftForce.toFixed(3);
            document.getElementById('reynoldsVal').textContent = stats.reynolds.toFixed(0);

            drawEnergySpectrum();
        }

        // Color mapping
        function getColor(normalized, curl) {
            if (displayMode === 'curl') {
                // Diverging colormap for vorticity
                if (curl < 0) {
                    // Counter-clockwise: blue to cyan
                    const t = Math.abs(curl) * 50;
                    return {
                        r: 0,
                        g: Math.floor(Math.min(255, 128 + t * 128)),
                        b: 255
                    };
                } else {
                    // Clockwise: yellow to red
                    const t = curl * 50;
                    return {
                        r: 255,
                        g: Math.floor(Math.max(0, 255 - t * 200)),
                        b: 0
                    };
                }
            } else {
                // Sequential colormap for speed/pressure
                if (normalized < 0.25) {
                    const t = normalized * 4;
                    return { r: 0, g: 0, b: Math.floor(128 + t * 127) };
                } else if (normalized < 0.5) {
                    const t = (normalized - 0.25) * 4;
                    return { r: 0, g: Math.floor(t * 255), b: 255 };
                } else if (normalized < 0.75) {
                    const t = (normalized - 0.5) * 4;
                    return { r: Math.floor(t * 255), g: 255, b: Math.floor(255 * (1 - t)) };
                } else {
                    const t = (normalized - 0.75) * 4;
                    return { r: 255, g: Math.floor(255 * (1 - t)), b: 0 };
                }
            }
        }

        // Draw streamlines
        function drawStreamlines() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;

            const spacing = 20;
            const steps = 100;
            const stepSize = 2;

            for (let startY = spacing; startY < ny * scale; startY += spacing) {
                ctx.beginPath();
                let x = 0;
                let y = startY;

                ctx.moveTo(x, y);

                for (let s = 0; s < steps; s++) {
                    const i = Math.floor(x / scale);
                    const j = Math.floor(y / scale);

                    if (i < 0 || i >= nx || j < 0 || j >= ny) break;
                    if (barrier[i][j]) break;

                    const vx = ux[i][j];
                    const vy = uy[i][j];
                    const speed = Math.sqrt(vx * vx + vy * vy);

                    if (speed < 0.001) break;

                    x += vx / speed * stepSize * scale;
                    y += vy / speed * stepSize * scale;

                    ctx.lineTo(x, y);
                }

                ctx.stroke();
            }
        }

        // Draw velocity vectors
        function drawVectors() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 1;

            const spacing = 15;

            for (let i = spacing; i < nx; i += spacing) {
                for (let j = spacing; j < ny; j += spacing) {
                    if (barrier[i][j]) continue;

                    const x = i * scale;
                    const y = j * scale;
                    const vx = ux[i][j];
                    const vy = uy[i][j];
                    const speed = Math.sqrt(vx * vx + vy * vy);

                    if (speed < 0.001) continue;

                    const arrowLength = speed * 80;
                    const dx = vx / speed * arrowLength;
                    const dy = vy / speed * arrowLength;

                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + dx, y + dy);
                    ctx.stroke();

                    // Arrowhead
                    const angle = Math.atan2(dy, dx);
                    ctx.beginPath();
                    ctx.moveTo(x + dx, y + dy);
                    ctx.lineTo(x + dx - 4 * Math.cos(angle - 0.5), y + dy - 4 * Math.sin(angle - 0.5));
                    ctx.lineTo(x + dx - 4 * Math.cos(angle + 0.5), y + dy - 4 * Math.sin(angle + 0.5));
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        // Draw energy spectrum
        function drawEnergySpectrum() {
            const w = spectrumCanvas.width = spectrumCanvas.offsetWidth;
            const h = spectrumCanvas.height = 50;

            spectrumCtx.clearRect(0, 0, w, h);
            spectrumCtx.fillStyle = '#f8f8f8';
            spectrumCtx.fillRect(0, 0, w, h);

            if (energyHistory.length < 10) {
                spectrumCtx.fillStyle = '#999';
                spectrumCtx.font = '10px Nunito';
                spectrumCtx.textAlign = 'center';
                spectrumCtx.fillText('Collecting energy data...', w/2, h/2);
                return;
            }

            // Simple FFT-like frequency analysis of energy fluctuations
            const n = Math.min(energyHistory.length, 64);
            const recent = energyHistory.slice(-n);
            const mean = recent.reduce((a, b) => a + b, 0) / n;
            const fluctuations = recent.map(e => e - mean);

            // Compute power at different frequencies
            const freqs = 16;
            const power = new Array(freqs).fill(0);

            for (let k = 0; k < freqs; k++) {
                let real = 0, imag = 0;
                for (let t = 0; t < n; t++) {
                    const angle = 2 * Math.PI * k * t / n;
                    real += fluctuations[t] * Math.cos(angle);
                    imag += fluctuations[t] * Math.sin(angle);
                }
                power[k] = Math.sqrt(real * real + imag * imag) / n;
            }

            const maxPower = Math.max(...power.slice(1)) || 1;
            const barWidth = (w - 20) / freqs;

            for (let k = 0; k < freqs; k++) {
                const barHeight = k === 0 ? 0 : (power[k] / maxPower) * (h - 10);
                const x = 10 + k * barWidth;
                const y = h - 5 - barHeight;

                spectrumCtx.fillStyle = `hsl(${200 + k * 10}, 70%, 50%)`;
                spectrumCtx.fillRect(x, y, barWidth - 2, barHeight);
            }
        }

        // Add cylinder obstacle
        function addCylinder() {
            const cx = nx * 0.25;
            const cy = ny * 0.5;
            const r = 15;

            for (let i = 0; i < nx; i++) {
                for (let j = 0; j < ny; j++) {
                    const dx = i - cx;
                    const dy = j - cy;
                    if (dx * dx + dy * dy < r * r) {
                        barrier[i][j] = true;
                    }
                }
            }
        }

        // Add airfoil obstacle
        function addWing() {
            const cx = nx * 0.3;
            const cy = ny * 0.5;
            const length = 60;
            const thickness = 10;
            const angle = 0.1; // Angle of attack

            for (let i = 0; i < nx; i++) {
                for (let j = 0; j < ny; j++) {
                    const dx = i - cx;
                    const dy = j - cy;

                    // Rotate coordinates
                    const rx = dx * Math.cos(angle) + dy * Math.sin(angle);
                    const ry = -dx * Math.sin(angle) + dy * Math.cos(angle);

                    // NACA-like shape
                    if (rx >= 0 && rx < length) {
                        const t = rx / length;
                        const yThickness = thickness * (1 - t) * Math.sqrt(t);
                        if (Math.abs(ry) < yThickness) {
                            barrier[i][j] = true;
                        }
                    }
                }
            }
        }

        // Mouse handlers for drawing obstacles
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            drawObstacle(e);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                drawObstacle(e);
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });

        function drawObstacle(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / scale);
            const y = Math.floor((e.clientY - rect.top) / scale);

            for (let di = -brushSize; di <= brushSize; di++) {
                for (let dj = -brushSize; dj <= brushSize; dj++) {
                    if (di * di + dj * dj <= brushSize * brushSize) {
                        const ni = x + di;
                        const nj = y + dj;
                        if (ni >= 0 && ni < nx && nj >= 0 && nj < ny) {
                            barrier[ni][nj] = true;
                        }
                    }
                }
            }

            if (!running) draw();
        }

        // Clear obstacles
        function clearObstacles() {
            for (let i = 0; i < nx; i++) {
                for (let j = 0; j < ny; j++) {
                    barrier[i][j] = false;
                }
            }
            if (!running) draw();
        }

        // Animation loop
        function simulate() {
            if (!running) return;

            // Multiple substeps for stability
            for (let s = 0; s < 5; s++) {
                collide();
                stream();
            }

            step++;
            draw();

            animationId = requestAnimationFrame(simulate);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start Flow';
            if (running) simulate();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start Flow';
            if (animationId) cancelAnimationFrame(animationId);
            initArrays();
            draw();
        });

        document.getElementById('clearObstacles').addEventListener('click', clearObstacles);
        document.getElementById('addCylinder').addEventListener('click', () => {
            addCylinder();
            if (!running) draw();
        });
        document.getElementById('addWing').addEventListener('click', () => {
            addWing();
            if (!running) draw();
        });

        document.getElementById('speed').addEventListener('input', function() {
            flowSpeed = parseFloat(this.value);
            document.getElementById('speedVal').textContent = this.value;
        });

        document.getElementById('viscosity').addEventListener('input', function() {
            viscosity = parseFloat(this.value);
            omega = 1 / (3 * viscosity + 0.5);
            document.getElementById('viscosityVal').textContent = this.value;
        });

        document.getElementById('brush').addEventListener('input', function() {
            brushSize = parseInt(this.value);
            document.getElementById('brushVal').textContent = this.value;
        });

        document.getElementById('displayCurl').addEventListener('change', () => {
            displayMode = 'curl';
            if (!running) draw();
        });
        document.getElementById('displaySpeed').addEventListener('change', () => {
            displayMode = 'speed';
            if (!running) draw();
        });
        document.getElementById('displayPressure').addEventListener('change', () => {
            displayMode = 'pressure';
            if (!running) draw();
        });

        document.getElementById('showStreamlines').addEventListener('change', function() {
            showStreamlines = this.checked;
            if (!running) draw();
        });
        document.getElementById('showVectors').addEventListener('change', function() {
            showVectors = this.checked;
            if (!running) draw();
        });

        // Initialize
        initArrays();
        addCylinder();
        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
