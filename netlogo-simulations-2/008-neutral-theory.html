<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neutral Theory of Molecular Evolution</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        .back-link {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: var(--terracotta);
        }

        h1 {
            color: var(--dark-moss);
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .subtitle {
            color: var(--moss);
            font-size: 1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: var(--moss);
            font-size: 0.95em;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid var(--sage);
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            color: var(--dark-moss);
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group .value {
            text-align: right;
            font-size: 0.8em;
            color: var(--moss);
        }

        .control-group select {
            width: 100%;
            padding: 6px;
            border: 1px solid var(--sage);
            border-radius: 6px;
            font-size: 0.9em;
        }

        .button-group {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.3s;
        }

        .btn-primary {
            background: var(--sage);
            color: white;
        }

        .btn-primary:hover {
            background: var(--moss);
        }

        .btn-secondary {
            background: var(--earth);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--terracotta);
        }

        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .viz-panel {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .viz-panel h3 {
            color: var(--moss);
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        canvas {
            width: 100%;
            border-radius: 8px;
            background: #1a1a2e;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .stat-box {
            background: linear-gradient(135deg, var(--cream) 0%, white 100%);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            border-left: 3px solid var(--sage);
        }

        .stat-box.highlight {
            border-left-color: var(--terracotta);
        }

        .stat-box .label {
            font-size: 0.75em;
            color: var(--moss);
            margin-bottom: 4px;
        }

        .stat-box .value {
            font-size: 1.3em;
            font-weight: bold;
            color: var(--dark-moss);
        }

        .theory-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 10px;
        }

        .theory-box {
            background: linear-gradient(135deg, #e8f5e9 0%, white 100%);
            border-radius: 8px;
            padding: 15px;
        }

        .theory-box.selectionist {
            background: linear-gradient(135deg, #fff3e0 0%, white 100%);
        }

        .theory-box h4 {
            color: var(--moss);
            font-size: 0.85em;
            margin-bottom: 8px;
        }

        .theory-box .prediction {
            font-size: 0.8em;
            color: var(--dark-moss);
            margin-bottom: 4px;
        }

        .info-box {
            background: linear-gradient(135deg, #e3f2fd 0%, white 100%);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            font-size: 0.8em;
            color: var(--dark-moss);
        }

        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
            font-size: 0.8em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">← Back to Simulations</a>
            <h1>Neutral Theory of Molecular Evolution</h1>
            <p class="subtitle">Kimura's Theory: Substitution Rate = Mutation Rate (K = u)</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-section">
                    <h3>Population Parameters</h3>
                    <div class="control-group">
                        <label>Population Size (N): <span id="popSizeVal">100</span></label>
                        <input type="range" id="popSize" min="20" max="500" value="100">
                    </div>
                    <div class="control-group">
                        <label>Mutation Rate (u): <span id="mutRateVal">0.001</span></label>
                        <input type="range" id="mutRate" min="1" max="20" value="10">
                        <div class="value">×10⁻⁴</div>
                    </div>
                    <div class="control-group">
                        <label>Number of Loci: <span id="numLociVal">50</span></label>
                        <input type="range" id="numLoci" min="10" max="200" value="50">
                    </div>
                </div>

                <div class="control-section">
                    <h3>Evolution Mode</h3>
                    <div class="control-group">
                        <label>Model Type:</label>
                        <select id="modelType">
                            <option value="neutral">Neutral (Kimura)</option>
                            <option value="nearlyNeutral">Nearly Neutral (Ohta)</option>
                            <option value="selection">Selection (contrast)</option>
                        </select>
                    </div>
                    <div class="control-group" id="selectionGroup" style="display: none;">
                        <label>Selection Coefficient (s): <span id="selCoefVal">0.01</span></label>
                        <input type="range" id="selCoef" min="1" max="100" value="10">
                        <div class="value">×10⁻³</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Molecular Clock</h3>
                    <div class="control-group">
                        <label>Time Scale: <span id="timeScaleVal">1</span></label>
                        <input type="range" id="timeScale" min="1" max="10" value="1">
                        <div class="value">generations per frame</div>
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="info-box">
                    <strong>Kimura's Neutral Theory (1968):</strong><br>
                    Most molecular variation is selectively neutral. The substitution rate K equals the mutation rate u, independent of population size. This creates a "molecular clock" for dating evolutionary events.
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-panel">
                    <h3>Substitution Accumulation (Molecular Clock)</h3>
                    <canvas id="clockCanvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4CAF50;"></div>
                            <span>Observed Substitutions</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FFC107;"></div>
                            <span>Expected (K=u)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #E91E63;"></div>
                            <span>Selection Prediction</span>
                        </div>
                    </div>
                </div>

                <div class="viz-panel">
                    <h3>Heterozygosity Over Time</h3>
                    <canvas id="hetCanvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #2196F3;"></div>
                            <span>Observed H</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #9C27B0;"></div>
                            <span>Expected H = 4Nu/(1+4Nu)</span>
                        </div>
                    </div>
                </div>

                <div class="viz-panel">
                    <h3>Allele Frequency Spectrum</h3>
                    <canvas id="spectrumCanvas"></canvas>
                </div>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="label">Generation</div>
                        <div class="value" id="genStat">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Total Substitutions</div>
                        <div class="value" id="subStat">0</div>
                    </div>
                    <div class="stat-box highlight">
                        <div class="label">Observed Rate (K)</div>
                        <div class="value" id="rateStat">0.000</div>
                    </div>
                    <div class="stat-box highlight">
                        <div class="label">Expected Rate (u)</div>
                        <div class="value" id="expRateStat">0.001</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Heterozygosity</div>
                        <div class="value" id="hetStat">0.000</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Variance/Mean Ratio</div>
                        <div class="value" id="dispStat">1.00</div>
                    </div>
                </div>

                <div class="theory-comparison">
                    <div class="theory-box">
                        <h4>Neutral Theory Predictions</h4>
                        <div class="prediction">• Substitution rate K = u (mutation rate)</div>
                        <div class="prediction">• Independent of population size N</div>
                        <div class="prediction">• Variance/Mean ratio ≈ 1 (Poisson)</div>
                        <div class="prediction">• Constant molecular clock</div>
                    </div>
                    <div class="theory-box selectionist">
                        <h4>Selectionist Predictions</h4>
                        <div class="prediction">• Substitution rate depends on s and N</div>
                        <div class="prediction">• K = 2Ns × u for beneficial mutations</div>
                        <div class="prediction">• Variance/Mean > 1 (overdispersed)</div>
                        <div class="prediction">• Variable molecular clock</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const clockCanvas = document.getElementById('clockCanvas');
        const hetCanvas = document.getElementById('hetCanvas');
        const spectrumCanvas = document.getElementById('spectrumCanvas');
        const clockCtx = clockCanvas.getContext('2d');
        const hetCtx = hetCanvas.getContext('2d');
        const spectrumCtx = spectrumCanvas.getContext('2d');

        // Parameters
        let N = 100;
        let u = 0.001;
        let numLoci = 50;
        let modelType = 'neutral';
        let selCoef = 0.01;
        let timeScale = 1;

        // State
        let population = [];
        let generation = 0;
        let substitutions = 0;
        let substitutionHistory = [];
        let heterozygosityHistory = [];
        let running = false;
        let animationId = null;

        // Track substitutions per time window for variance calculation
        let substitutionWindows = [];
        const windowSize = 100;

        function setupCanvas(canvas, ctx, height) {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = (rect.width - 30) * dpr;
            canvas.height = height * dpr;
            canvas.style.width = (rect.width - 30) + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(dpr, dpr);
        }

        function initPopulation() {
            // Each locus has alleles represented by integers
            // Start with all loci fixed for allele 0
            population = [];
            for (let i = 0; i < N; i++) {
                const genome = [];
                for (let j = 0; j < numLoci; j++) {
                    genome.push(0); // All start with allele 0
                }
                population.push(genome);
            }

            generation = 0;
            substitutions = 0;
            substitutionHistory = [];
            heterozygosityHistory = [];
            substitutionWindows = [];
        }

        function mutate(genome, nextAlleleId) {
            const newGenome = [...genome];
            let mutated = false;
            let newId = nextAlleleId;

            for (let i = 0; i < numLoci; i++) {
                if (Math.random() < u) {
                    newGenome[i] = newId++;
                    mutated = true;
                }
            }

            return { genome: newGenome, nextId: newId, mutated };
        }

        function calculateFitness(genome, ancestralAlleles) {
            if (modelType === 'neutral') return 1;

            let fitness = 1;
            for (let i = 0; i < numLoci; i++) {
                if (genome[i] !== ancestralAlleles[i]) {
                    if (modelType === 'selection') {
                        // Beneficial mutations
                        fitness *= (1 + selCoef);
                    } else if (modelType === 'nearlyNeutral') {
                        // Nearly neutral: small random effect
                        const effect = (Math.random() - 0.5) * selCoef * 2;
                        fitness *= (1 + effect);
                    }
                }
            }
            return Math.max(0, fitness);
        }

        function wrightFisherStep() {
            // Track allele at each locus before reproduction
            const prevFixed = getFixedAlleles();

            // Calculate fitness for each individual
            const fitnesses = population.map(g => calculateFitness(g, prevFixed));
            const totalFitness = fitnesses.reduce((a, b) => a + b, 0);

            // Create next generation via sampling with replacement
            const newPop = [];
            let nextAlleleId = Math.max(...population.flat()) + 1;

            for (let i = 0; i < N; i++) {
                // Select parent proportional to fitness
                let r = Math.random() * totalFitness;
                let parentIdx = 0;
                let cumFitness = fitnesses[0];

                while (cumFitness < r && parentIdx < N - 1) {
                    parentIdx++;
                    cumFitness += fitnesses[parentIdx];
                }

                // Copy parent genome and potentially mutate
                const result = mutate([...population[parentIdx]], nextAlleleId);
                newPop.push(result.genome);
                nextAlleleId = result.nextId;
            }

            population = newPop;
            generation++;

            // Check for new substitutions (fixation of new alleles)
            const currentFixed = getFixedAlleles();
            let newSubs = 0;
            for (let i = 0; i < numLoci; i++) {
                if (currentFixed[i] !== prevFixed[i]) {
                    newSubs++;
                }
            }
            substitutions += newSubs;

            // Track for variance calculation
            if (substitutionWindows.length >= windowSize) {
                substitutionWindows.shift();
            }
            substitutionWindows.push(newSubs);

            // Record history
            if (generation % 10 === 0) {
                substitutionHistory.push({
                    gen: generation,
                    subs: substitutions
                });

                heterozygosityHistory.push({
                    gen: generation,
                    het: calculateHeterozygosity()
                });

                // Keep history manageable
                if (substitutionHistory.length > 500) {
                    substitutionHistory = substitutionHistory.filter((_, i) => i % 2 === 0);
                    heterozygosityHistory = heterozygosityHistory.filter((_, i) => i % 2 === 0);
                }
            }
        }

        function getFixedAlleles() {
            const fixed = [];
            for (let i = 0; i < numLoci; i++) {
                const allele = population[0][i];
                let isFixed = true;
                for (let j = 1; j < N; j++) {
                    if (population[j][i] !== allele) {
                        isFixed = false;
                        break;
                    }
                }
                fixed.push(isFixed ? allele : -1);
            }
            return fixed;
        }

        function calculateHeterozygosity() {
            let totalH = 0;
            for (let locus = 0; locus < numLoci; locus++) {
                // Count allele frequencies at this locus
                const alleleCounts = {};
                for (let i = 0; i < N; i++) {
                    const allele = population[i][locus];
                    alleleCounts[allele] = (alleleCounts[allele] || 0) + 1;
                }

                // Calculate heterozygosity: 1 - sum(p_i^2)
                let sumPsq = 0;
                for (const count of Object.values(alleleCounts)) {
                    const p = count / N;
                    sumPsq += p * p;
                }
                totalH += (1 - sumPsq);
            }
            return totalH / numLoci;
        }

        function getAlleleFrequencySpectrum() {
            // Get the frequency spectrum across all loci
            const spectrum = new Array(10).fill(0);

            for (let locus = 0; locus < numLoci; locus++) {
                const alleleCounts = {};
                for (let i = 0; i < N; i++) {
                    const allele = population[i][locus];
                    alleleCounts[allele] = (alleleCounts[allele] || 0) + 1;
                }

                for (const count of Object.values(alleleCounts)) {
                    const freq = count / N;
                    if (freq > 0 && freq < 1) {
                        const bin = Math.min(9, Math.floor(freq * 10));
                        spectrum[bin]++;
                    }
                }
            }

            return spectrum;
        }

        function calculateDispersion() {
            if (substitutionWindows.length < 10) return 1;

            const mean = substitutionWindows.reduce((a, b) => a + b, 0) / substitutionWindows.length;
            if (mean === 0) return 1;

            const variance = substitutionWindows.reduce((sum, x) => sum + (x - mean) ** 2, 0) / substitutionWindows.length;
            return variance / mean;
        }

        function drawClock() {
            const width = clockCanvas.width / (window.devicePixelRatio || 1);
            const height = clockCanvas.height / (window.devicePixelRatio || 1);

            clockCtx.fillStyle = '#1a1a2e';
            clockCtx.fillRect(0, 0, width, height);

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Draw axes
            clockCtx.strokeStyle = '#ffffff44';
            clockCtx.lineWidth = 1;
            clockCtx.beginPath();
            clockCtx.moveTo(padding, padding);
            clockCtx.lineTo(padding, height - padding);
            clockCtx.lineTo(width - padding, height - padding);
            clockCtx.stroke();

            // Labels
            clockCtx.fillStyle = '#ffffffaa';
            clockCtx.font = '11px sans-serif';
            clockCtx.fillText('Substitutions', padding, padding - 10);
            clockCtx.fillText('Generation', width - padding - 50, height - 10);

            if (substitutionHistory.length < 2) return;

            const maxGen = substitutionHistory[substitutionHistory.length - 1].gen;
            const maxSubs = Math.max(substitutions, maxGen * u * numLoci) * 1.2;

            // Draw expected line (K = u × numLoci)
            clockCtx.strokeStyle = '#FFC107';
            clockCtx.lineWidth = 2;
            clockCtx.setLineDash([5, 5]);
            clockCtx.beginPath();
            clockCtx.moveTo(padding, height - padding);
            const expectedEnd = maxGen * u * numLoci;
            clockCtx.lineTo(
                padding + graphWidth,
                height - padding - (expectedEnd / maxSubs) * graphHeight
            );
            clockCtx.stroke();
            clockCtx.setLineDash([]);

            // Draw selectionist prediction (if in selection mode)
            if (modelType === 'selection') {
                clockCtx.strokeStyle = '#E91E63';
                clockCtx.lineWidth = 2;
                clockCtx.setLineDash([3, 3]);
                clockCtx.beginPath();
                clockCtx.moveTo(padding, height - padding);
                const selEnd = maxGen * u * numLoci * 2 * N * selCoef;
                clockCtx.lineTo(
                    padding + graphWidth,
                    height - padding - Math.min((selEnd / maxSubs) * graphHeight, graphHeight)
                );
                clockCtx.stroke();
                clockCtx.setLineDash([]);
            }

            // Draw observed substitutions
            clockCtx.strokeStyle = '#4CAF50';
            clockCtx.lineWidth = 2;
            clockCtx.beginPath();

            substitutionHistory.forEach((point, i) => {
                const x = padding + (point.gen / maxGen) * graphWidth;
                const y = height - padding - (point.subs / maxSubs) * graphHeight;

                if (i === 0) {
                    clockCtx.moveTo(x, y);
                } else {
                    clockCtx.lineTo(x, y);
                }
            });
            clockCtx.stroke();
        }

        function drawHeterozygosity() {
            const width = hetCanvas.width / (window.devicePixelRatio || 1);
            const height = hetCanvas.height / (window.devicePixelRatio || 1);

            hetCtx.fillStyle = '#1a1a2e';
            hetCtx.fillRect(0, 0, width, height);

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Draw axes
            hetCtx.strokeStyle = '#ffffff44';
            hetCtx.lineWidth = 1;
            hetCtx.beginPath();
            hetCtx.moveTo(padding, padding);
            hetCtx.lineTo(padding, height - padding);
            hetCtx.lineTo(width - padding, height - padding);
            hetCtx.stroke();

            // Labels
            hetCtx.fillStyle = '#ffffffaa';
            hetCtx.font = '11px sans-serif';
            hetCtx.fillText('Heterozygosity', padding, padding - 10);

            // Expected equilibrium heterozygosity line
            const theta = 4 * N * u;
            const expectedH = theta / (1 + theta);

            hetCtx.strokeStyle = '#9C27B0';
            hetCtx.lineWidth = 2;
            hetCtx.setLineDash([5, 5]);
            hetCtx.beginPath();
            hetCtx.moveTo(padding, height - padding - expectedH * graphHeight);
            hetCtx.lineTo(width - padding, height - padding - expectedH * graphHeight);
            hetCtx.stroke();
            hetCtx.setLineDash([]);

            // Label expected H
            hetCtx.fillStyle = '#9C27B0';
            hetCtx.fillText(`Expected H = ${expectedH.toFixed(3)}`, width - padding - 100, height - padding - expectedH * graphHeight - 5);

            if (heterozygosityHistory.length < 2) return;

            const maxGen = heterozygosityHistory[heterozygosityHistory.length - 1].gen;

            // Draw observed heterozygosity
            hetCtx.strokeStyle = '#2196F3';
            hetCtx.lineWidth = 2;
            hetCtx.beginPath();

            heterozygosityHistory.forEach((point, i) => {
                const x = padding + (point.gen / maxGen) * graphWidth;
                const y = height - padding - point.het * graphHeight;

                if (i === 0) {
                    hetCtx.moveTo(x, y);
                } else {
                    hetCtx.lineTo(x, y);
                }
            });
            hetCtx.stroke();
        }

        function drawSpectrum() {
            const width = spectrumCanvas.width / (window.devicePixelRatio || 1);
            const height = spectrumCanvas.height / (window.devicePixelRatio || 1);

            spectrumCtx.fillStyle = '#1a1a2e';
            spectrumCtx.fillRect(0, 0, width, height);

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            const spectrum = getAlleleFrequencySpectrum();
            const maxCount = Math.max(...spectrum, 1);

            const barWidth = graphWidth / 10;

            // Draw bars
            spectrum.forEach((count, i) => {
                const x = padding + i * barWidth;
                const barHeight = (count / maxCount) * graphHeight;

                const gradient = spectrumCtx.createLinearGradient(x, height - padding, x, height - padding - barHeight);
                gradient.addColorStop(0, '#4CAF50');
                gradient.addColorStop(1, '#81C784');

                spectrumCtx.fillStyle = gradient;
                spectrumCtx.fillRect(x + 2, height - padding - barHeight, barWidth - 4, barHeight);
            });

            // Labels
            spectrumCtx.fillStyle = '#ffffffaa';
            spectrumCtx.font = '10px sans-serif';
            spectrumCtx.textAlign = 'center';

            for (let i = 0; i < 10; i++) {
                const x = padding + i * barWidth + barWidth / 2;
                spectrumCtx.fillText(`${i * 10}-${(i + 1) * 10}%`, x, height - padding + 15);
            }

            spectrumCtx.textAlign = 'left';
            spectrumCtx.fillText('Allele Frequency Distribution', padding, padding - 10);
        }

        function updateStats() {
            document.getElementById('genStat').textContent = generation;
            document.getElementById('subStat').textContent = substitutions;

            const observedRate = generation > 0 ? (substitutions / generation / numLoci).toFixed(5) : '0.00000';
            document.getElementById('rateStat').textContent = observedRate;
            document.getElementById('expRateStat').textContent = u.toFixed(5);
            document.getElementById('hetStat').textContent = calculateHeterozygosity().toFixed(3);
            document.getElementById('dispStat').textContent = calculateDispersion().toFixed(2);
        }

        function animate() {
            for (let i = 0; i < timeScale; i++) {
                wrightFisherStep();
            }

            drawClock();
            drawHeterozygosity();
            drawSpectrum();
            updateStats();

            if (running) {
                animationId = requestAnimationFrame(animate);
            }
        }

        function start() {
            if (!running) {
                running = true;
                document.getElementById('startBtn').textContent = 'Pause';
                animate();
            } else {
                running = false;
                document.getElementById('startBtn').textContent = 'Start';
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
            }
        }

        function reset() {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            if (animationId) {
                cancelAnimationFrame(animationId);
            }

            N = parseInt(document.getElementById('popSize').value);
            u = parseInt(document.getElementById('mutRate').value) / 10000;
            numLoci = parseInt(document.getElementById('numLoci').value);
            modelType = document.getElementById('modelType').value;
            selCoef = parseInt(document.getElementById('selCoef').value) / 1000;
            timeScale = parseInt(document.getElementById('timeScale').value);

            initPopulation();
            drawClock();
            drawHeterozygosity();
            drawSpectrum();
            updateStats();
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', start);
        document.getElementById('resetBtn').addEventListener('click', reset);

        document.getElementById('popSize').addEventListener('input', (e) => {
            document.getElementById('popSizeVal').textContent = e.target.value;
        });

        document.getElementById('mutRate').addEventListener('input', (e) => {
            document.getElementById('mutRateVal').textContent = (e.target.value / 10000).toFixed(4);
        });

        document.getElementById('numLoci').addEventListener('input', (e) => {
            document.getElementById('numLociVal').textContent = e.target.value;
        });

        document.getElementById('modelType').addEventListener('change', (e) => {
            document.getElementById('selectionGroup').style.display =
                e.target.value === 'selection' ? 'block' : 'none';
        });

        document.getElementById('selCoef').addEventListener('input', (e) => {
            document.getElementById('selCoefVal').textContent = (e.target.value / 1000).toFixed(3);
        });

        document.getElementById('timeScale').addEventListener('input', (e) => {
            document.getElementById('timeScaleVal').textContent = e.target.value;
            timeScale = parseInt(e.target.value);
        });

        // Initialize
        function init() {
            setupCanvas(clockCanvas, clockCtx, 200);
            setupCanvas(hetCanvas, hetCtx, 180);
            setupCanvas(spectrumCanvas, spectrumCtx, 150);
            initPopulation();
            drawClock();
            drawHeterozygosity();
            drawSpectrum();
            updateStats();
        }

        window.addEventListener('resize', () => {
            setupCanvas(clockCanvas, clockCtx, 200);
            setupCanvas(hetCanvas, hetCtx, 180);
            setupCanvas(spectrumCanvas, spectrumCtx, 150);
            drawClock();
            drawHeterozygosity();
            drawSpectrum();
        });

        init();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
