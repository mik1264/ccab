<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Biological Invasions - Enemy Release & Spread Dynamics</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        h1 {
            color: var(--dark-moss);
            font-size: 1.8rem;
            margin-bottom: 8px;
        }

        .subtitle {
            color: var(--moss);
            font-size: 1rem;
        }

        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: var(--terracotta);
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            height: fit-content;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: var(--dark-moss);
            font-size: 0.95rem;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 2px solid var(--sage);
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            color: var(--moss);
            font-size: 0.8rem;
            margin-bottom: 4px;
            font-weight: 500;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 0.85rem;
            color: var(--dark-moss);
            background: white;
        }

        .value-display {
            text-align: right;
            font-size: 0.75rem;
            color: var(--terracotta);
            font-weight: 600;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 16px;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.85rem;
        }

        .btn-primary {
            background: var(--sage);
            color: white;
        }

        .btn-primary:hover {
            background: var(--moss);
        }

        .btn-secondary {
            background: var(--earth);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--terracotta);
        }

        .btn-full {
            grid-column: span 2;
        }

        .btn-event {
            background: var(--terracotta);
            color: white;
            grid-column: span 2;
            margin-top: 8px;
        }

        .btn-event:hover {
            background: #a55a1f;
        }

        .visualization-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 16px;
        }

        .viz-panel {
            background: white;
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        .viz-panel h4 {
            color: var(--dark-moss);
            font-size: 0.85rem;
            margin-bottom: 10px;
            text-align: center;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 280px;
        }

        canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            background: #1a1a1a;
        }

        .stats-panel {
            background: white;
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            margin-top: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 12px;
        }

        .stat-item {
            text-align: center;
            padding: 12px;
            background: var(--cream);
            border-radius: 10px;
        }

        .stat-value {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--terracotta);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--moss);
            margin-top: 4px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #eee;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.7rem;
            color: var(--dark-moss);
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .info-panel {
            grid-column: span 2;
            background: linear-gradient(135deg, var(--sage) 0%, var(--moss) 100%);
            color: white;
            padding: 16px;
            border-radius: 12px;
            margin-top: 12px;
        }

        .info-panel h4 {
            margin-bottom: 8px;
            font-size: 0.95rem;
        }

        .info-panel p {
            font-size: 0.8rem;
            opacity: 0.95;
            line-height: 1.5;
        }

        .phase-indicator {
            text-align: center;
            padding: 12px;
            background: var(--cream);
            border-radius: 10px;
            margin-top: 12px;
        }

        .phase-name {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--moss);
        }

        .phase-desc {
            font-size: 0.75rem;
            color: var(--terracotta);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Simulations</a>

    <div class="container">
        <header>
            <h1>Biological Invasions</h1>
            <p class="subtitle">Introduction, Establishment & Spread - Enemy Release & Competitive Displacement</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-section">
                    <h3>Invasive Species Traits</h3>
                    <div class="control-group">
                        <label>Propagule Pressure</label>
                        <input type="range" id="propagulePressure" min="1" max="20" step="1" value="5">
                        <div class="value-display" id="propagulePressureValue">5</div>
                    </div>
                    <div class="control-group">
                        <label>Competitive Ability</label>
                        <input type="range" id="competitiveAbility" min="1" max="2" step="0.1" value="1.3">
                        <div class="value-display" id="competitiveAbilityValue">1.30x</div>
                    </div>
                    <div class="control-group">
                        <label>Dispersal Rate</label>
                        <input type="range" id="dispersalRate" min="0.01" max="0.3" step="0.01" value="0.1">
                        <div class="value-display" id="dispersalRateValue">0.10</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Enemy Release Hypothesis</h3>
                    <div class="control-group">
                        <label>Native Enemy Pressure</label>
                        <input type="range" id="nativeEnemyPressure" min="0" max="0.5" step="0.05" value="0.2">
                        <div class="value-display" id="nativeEnemyPressureValue">0.20</div>
                    </div>
                    <div class="control-group">
                        <label>Enemy Release Strength</label>
                        <input type="range" id="enemyRelease" min="0" max="1" step="0.1" value="0.8">
                        <div class="value-display" id="enemyReleaseValue">0.80</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Environment</h3>
                    <div class="control-group">
                        <label>Habitat Disturbance</label>
                        <input type="range" id="disturbance" min="0" max="0.2" step="0.01" value="0.05">
                        <div class="value-display" id="disturbanceValue">0.05</div>
                    </div>
                    <div class="control-group">
                        <label>Native Species Richness</label>
                        <input type="range" id="nativeRichness" min="3" max="10" step="1" value="5">
                        <div class="value-display" id="nativeRichnessValue">5</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Management</h3>
                    <div class="control-group">
                        <label>Control Strategy</label>
                        <select id="controlStrategy">
                            <option value="none">None</option>
                            <option value="eradication">Eradication (early)</option>
                            <option value="containment">Containment (barrier)</option>
                            <option value="biocontrol">Biocontrol (enemy)</option>
                            <option value="reduction">Population Reduction</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Control Intensity</label>
                        <input type="range" id="controlIntensity" min="0" max="1" step="0.1" value="0.5">
                        <div class="value-display" id="controlIntensityValue">0.50</div>
                    </div>
                    <button class="btn-event" id="applyControl">Apply Control Measure</button>
                </div>

                <div class="button-group">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="pauseBtn">Pause</button>
                    <button class="btn-secondary" id="introduceBtn">Introduce</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="phase-indicator">
                    <div class="phase-name" id="invasionPhase">Pre-Introduction</div>
                    <div class="phase-desc" id="phaseDesc">Waiting for propagule arrival</div>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #228B22;"></div>
                        <span>Native Dominant</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF4444;"></div>
                        <span>Invasive Present</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #AA0000;"></div>
                        <span>Invasive Dominant</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #666;"></div>
                        <span>Bare/Disturbed</span>
                    </div>
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-panel">
                    <h4>Landscape Invasion Map</h4>
                    <div class="canvas-container">
                        <canvas id="mapCanvas"></canvas>
                    </div>
                </div>

                <div class="viz-panel">
                    <h4>Population Dynamics</h4>
                    <div class="canvas-container">
                        <canvas id="dynamicsCanvas"></canvas>
                    </div>
                </div>

                <div class="viz-panel">
                    <h4>Invasion Front Spread</h4>
                    <div class="canvas-container">
                        <canvas id="spreadCanvas"></canvas>
                    </div>
                </div>

                <div class="viz-panel">
                    <h4>Native Species Displacement</h4>
                    <div class="canvas-container">
                        <canvas id="displacementCanvas"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="invasiveArea">0%</div>
                    <div class="stat-label">Invasive Coverage</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="nativeArea">100%</div>
                    <div class="stat-label">Native Coverage</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="invasivePop">0</div>
                    <div class="stat-label">Invasive Abundance</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="spreadRate">0</div>
                    <div class="stat-label">Spread Rate (km/yr)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="nativeLoss">0</div>
                    <div class="stat-label">Native Extinctions</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="invasionYear">0</div>
                    <div class="stat-label">Years Since Intro</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="controlCost">$0</div>
                    <div class="stat-label">Control Cost</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="lagPhase">-</div>
                    <div class="stat-label">Lag Phase (yrs)</div>
                </div>
            </div>
            <div class="info-panel">
                <h4>Invasion Ecology Concepts</h4>
                <p><strong>Enemy Release:</strong> Invasive species escape natural enemies (predators, parasites, pathogens) from their native range, allowing rapid population growth.
                <strong>Lag Phase:</strong> Period between introduction and explosive spread while population builds.
                <strong>Propagule Pressure:</strong> Number and frequency of introduction events - key predictor of invasion success.</p>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const mapCanvas = document.getElementById('mapCanvas');
        const dynamicsCanvas = document.getElementById('dynamicsCanvas');
        const spreadCanvas = document.getElementById('spreadCanvas');
        const displacementCanvas = document.getElementById('displacementCanvas');

        const mCtx = mapCanvas.getContext('2d');
        const dCtx = dynamicsCanvas.getContext('2d');
        const sCtx = spreadCanvas.getContext('2d');
        const pCtx = displacementCanvas.getContext('2d');

        function resizeCanvas(canvas) {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        [mapCanvas, dynamicsCanvas, spreadCanvas, displacementCanvas].forEach(resizeCanvas);
        window.addEventListener('resize', () => {
            [mapCanvas, dynamicsCanvas, spreadCanvas, displacementCanvas].forEach(resizeCanvas);
        });

        // Model state
        let grid = [];
        let gridSize = 60;
        let params = {};
        let isRunning = false;
        let tick = 0;
        let introductionTick = -1;
        let invasionPhase = 'pre';
        let history = [];
        let nativeSpecies = [];
        let controlCost = 0;
        let spreadHistory = [];
        let nativeExtinctions = 0;

        function initGrid() {
            grid = [];
            history = [];
            spreadHistory = [];
            tick = 0;
            introductionTick = -1;
            invasionPhase = 'pre';
            controlCost = 0;
            nativeExtinctions = 0;

            // Initialize native species
            nativeSpecies = [];
            for (let i = 0; i < params.nativeRichness; i++) {
                nativeSpecies.push({
                    id: i,
                    abundance: 1 / params.nativeRichness,
                    competitive: 0.8 + Math.random() * 0.4,
                    name: 'Native ' + (i + 1)
                });
            }

            for (let x = 0; x < gridSize; x++) {
                grid[x] = [];
                for (let y = 0; y < gridSize; y++) {
                    grid[x][y] = {
                        invasive: 0,
                        native: 1,
                        nativeComposition: nativeSpecies.map(s => s.abundance),
                        disturbed: false,
                        controlZone: false
                    };
                }
            }
        }

        function updateParams() {
            params = {
                propagulePressure: parseInt(document.getElementById('propagulePressure').value),
                competitiveAbility: parseFloat(document.getElementById('competitiveAbility').value),
                dispersalRate: parseFloat(document.getElementById('dispersalRate').value),
                nativeEnemyPressure: parseFloat(document.getElementById('nativeEnemyPressure').value),
                enemyRelease: parseFloat(document.getElementById('enemyRelease').value),
                disturbance: parseFloat(document.getElementById('disturbance').value),
                nativeRichness: parseInt(document.getElementById('nativeRichness').value),
                controlStrategy: document.getElementById('controlStrategy').value,
                controlIntensity: parseFloat(document.getElementById('controlIntensity').value)
            };
        }

        function introduceInvasive() {
            if (introductionTick >= 0) return;

            introductionTick = tick;
            invasionPhase = 'introduction';

            // Multiple introduction points (propagule pressure)
            for (let i = 0; i < params.propagulePressure; i++) {
                const x = Math.floor(Math.random() * gridSize);
                const y = Math.floor(Math.random() * gridSize);
                grid[x][y].invasive = 0.1 + Math.random() * 0.2;
            }

            updatePhaseIndicator();
        }

        function updatePhaseIndicator() {
            const phaseEl = document.getElementById('invasionPhase');
            const descEl = document.getElementById('phaseDesc');

            switch (invasionPhase) {
                case 'pre':
                    phaseEl.textContent = 'Pre-Introduction';
                    descEl.textContent = 'Native community stable';
                    break;
                case 'introduction':
                    phaseEl.textContent = 'Introduction Phase';
                    descEl.textContent = 'Propagules arriving';
                    break;
                case 'establishment':
                    phaseEl.textContent = 'Establishment Phase';
                    descEl.textContent = 'Population building (lag phase)';
                    break;
                case 'spread':
                    phaseEl.textContent = 'Spread Phase';
                    descEl.textContent = 'Exponential range expansion';
                    break;
                case 'saturation':
                    phaseEl.textContent = 'Saturation Phase';
                    descEl.textContent = 'Approaching carrying capacity';
                    break;
            }
        }

        function applyDisturbance() {
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    if (Math.random() < params.disturbance) {
                        grid[x][y].disturbed = true;
                        grid[x][y].native *= 0.5;
                        // Disturbance creates invasion opportunities
                        if (grid[x][y].invasive > 0) {
                            grid[x][y].invasive = Math.min(1, grid[x][y].invasive * 1.5);
                        }
                    } else {
                        grid[x][y].disturbed = false;
                    }
                }
            }
        }

        function update() {
            tick++;

            // Apply natural disturbance
            applyDisturbance();

            // Calculate invasion metrics for phase detection
            let totalInvasive = 0;
            let invasiveCells = 0;

            // Process each cell
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    const cell = grid[x][y];

                    if (cell.invasive > 0) {
                        // Invasive population dynamics
                        // Enemy release effect - reduced mortality compared to native range
                        const enemyMortality = params.nativeEnemyPressure * (1 - params.enemyRelease);

                        // Growth rate (r) modified by enemy release
                        const baseGrowth = 0.1;
                        const growthRate = baseGrowth * (1 + params.enemyRelease * 0.5);

                        // Competition with natives
                        const competition = cell.native * 0.5;

                        // Invasive growth
                        const deltaInvasive = cell.invasive * (growthRate - enemyMortality - competition) -
                                             cell.invasive * cell.invasive * 0.5;

                        cell.invasive = Math.max(0, Math.min(1, cell.invasive + deltaInvasive));

                        // Spread to neighbors
                        if (cell.invasive > 0.2) {
                            const neighbors = [
                                [x-1, y], [x+1, y], [x, y-1], [x, y+1],
                                [x-1, y-1], [x+1, y-1], [x-1, y+1], [x+1, y+1]
                            ];

                            neighbors.forEach(([nx, ny]) => {
                                if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                                    if (grid[nx][ny].invasive < 0.1 && Math.random() < params.dispersalRate) {
                                        // Colonization
                                        grid[nx][ny].invasive = 0.05;
                                    }
                                }
                            });
                        }

                        totalInvasive += cell.invasive;
                        if (cell.invasive > 0.01) invasiveCells++;
                    }

                    // Native dynamics
                    if (cell.native > 0) {
                        const nativeGrowth = 0.05;
                        const invasiveCompetition = cell.invasive * params.competitiveAbility;
                        const nativeMortality = params.nativeEnemyPressure;

                        const deltaNative = cell.native * (nativeGrowth - nativeMortality - invasiveCompetition) -
                                           cell.native * cell.native * 0.3;

                        cell.native = Math.max(0, Math.min(1, cell.native + deltaNative));

                        // Update native composition
                        if (cell.native > 0 && cell.invasive > 0.3) {
                            // Weaker native species go extinct first
                            cell.nativeComposition = cell.nativeComposition.map((ab, i) => {
                                const survival = nativeSpecies[i].competitive / params.competitiveAbility;
                                return Math.max(0, ab * survival);
                            });
                        }
                    }
                }
            }

            // Apply control measures
            if (params.controlStrategy !== 'none') {
                applyControl();
            }

            // Update invasion phase
            const invasivePercent = (invasiveCells / (gridSize * gridSize)) * 100;

            if (introductionTick >= 0) {
                if (invasivePercent < 1) {
                    invasionPhase = 'introduction';
                } else if (invasivePercent < 10) {
                    invasionPhase = 'establishment';
                } else if (invasivePercent < 70) {
                    invasionPhase = 'spread';
                } else {
                    invasionPhase = 'saturation';
                }
                updatePhaseIndicator();
            }

            // Count native extinctions
            let extinctCount = 0;
            nativeSpecies.forEach((sp, i) => {
                let totalAbundance = 0;
                for (let x = 0; x < gridSize; x++) {
                    for (let y = 0; y < gridSize; y++) {
                        totalAbundance += grid[x][y].nativeComposition[i] * grid[x][y].native;
                    }
                }
                if (totalAbundance < 0.01 && sp.abundance > 0) {
                    extinctCount++;
                    sp.abundance = 0;
                }
            });
            nativeExtinctions = extinctCount;

            // Record history
            if (tick % 2 === 0) {
                let stats = calculateStats();
                history.push({
                    tick,
                    ...stats
                });

                spreadHistory.push({
                    tick,
                    area: stats.invasiveCells,
                    radius: Math.sqrt(stats.invasiveCells / Math.PI)
                });

                if (history.length > 200) {
                    history.shift();
                    spreadHistory.shift();
                }
            }
        }

        function applyControl() {
            const strategy = params.controlStrategy;
            const intensity = params.controlIntensity;

            switch (strategy) {
                case 'eradication':
                    // Only effective in early stages
                    if (invasionPhase === 'introduction' || invasionPhase === 'establishment') {
                        for (let x = 0; x < gridSize; x++) {
                            for (let y = 0; y < gridSize; y++) {
                                if (grid[x][y].invasive > 0 && Math.random() < intensity * 0.3) {
                                    grid[x][y].invasive *= 0.1;
                                    controlCost += 100;
                                }
                            }
                        }
                    }
                    break;

                case 'containment':
                    // Create barrier zones
                    const cx = gridSize / 2;
                    const cy = gridSize / 2;
                    for (let x = 0; x < gridSize; x++) {
                        for (let y = 0; y < gridSize; y++) {
                            const dist = Math.sqrt(Math.pow(x - cx, 2) + Math.pow(y - cy, 2));
                            if (dist > gridSize * 0.3 && dist < gridSize * 0.35) {
                                grid[x][y].controlZone = true;
                                grid[x][y].invasive *= (1 - intensity * 0.5);
                                controlCost += 10;
                            }
                        }
                    }
                    break;

                case 'biocontrol':
                    // Introduce natural enemies (reduces enemy release advantage)
                    params.enemyRelease *= (1 - intensity * 0.02);
                    controlCost += 50;
                    break;

                case 'reduction':
                    // General population reduction
                    for (let x = 0; x < gridSize; x++) {
                        for (let y = 0; y < gridSize; y++) {
                            if (grid[x][y].invasive > 0.3 && Math.random() < intensity * 0.1) {
                                grid[x][y].invasive *= 0.7;
                                controlCost += 20;
                            }
                        }
                    }
                    break;
            }
        }

        function calculateStats() {
            let invasiveTotal = 0;
            let nativeTotal = 0;
            let invasiveCells = 0;
            let nativeCells = 0;

            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    invasiveTotal += grid[x][y].invasive;
                    nativeTotal += grid[x][y].native;
                    if (grid[x][y].invasive > 0.1) invasiveCells++;
                    if (grid[x][y].native > 0.1) nativeCells++;
                }
            }

            const total = gridSize * gridSize;

            return {
                invasivePercent: (invasiveCells / total) * 100,
                nativePercent: (nativeCells / total) * 100,
                invasiveAbundance: invasiveTotal,
                nativeAbundance: nativeTotal,
                invasiveCells,
                nativeCells
            };
        }

        function drawMap() {
            const width = mapCanvas.width;
            const height = mapCanvas.height;
            const cellWidth = width / gridSize;
            const cellHeight = height / gridSize;

            mCtx.fillStyle = '#1a1a1a';
            mCtx.fillRect(0, 0, width, height);

            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    const cell = grid[x][y];

                    let r, g, b;

                    if (cell.invasive > 0.5) {
                        // Invasive dominant
                        r = 170;
                        g = 50 * (1 - cell.invasive);
                        b = 50 * (1 - cell.invasive);
                    } else if (cell.invasive > 0.01) {
                        // Invasive present but not dominant
                        r = 255 * cell.invasive + 34 * (1 - cell.invasive);
                        g = 68 * cell.invasive + 139 * (1 - cell.invasive);
                        b = 68 * cell.invasive + 34 * (1 - cell.invasive);
                    } else if (cell.native > 0.1) {
                        // Native dominant
                        r = 34;
                        g = 139;
                        b = 34;
                    } else {
                        // Bare/disturbed
                        r = 100;
                        g = 100;
                        b = 100;
                    }

                    if (cell.disturbed) {
                        r = Math.min(255, r + 40);
                        g = Math.min(255, g + 40);
                        b = Math.min(255, b + 40);
                    }

                    if (cell.controlZone) {
                        b = Math.min(255, b + 80);
                    }

                    mCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    mCtx.fillRect(x * cellWidth, y * cellHeight, cellWidth + 0.5, cellHeight + 0.5);
                }
            }

            // Introduction point markers
            if (introductionTick >= 0 && tick - introductionTick < 50) {
                mCtx.strokeStyle = 'rgba(255, 255, 0, ' + (1 - (tick - introductionTick) / 50) + ')';
                mCtx.lineWidth = 2;
                for (let x = 0; x < gridSize; x++) {
                    for (let y = 0; y < gridSize; y++) {
                        if (grid[x][y].invasive > 0.05 && tick - introductionTick < 10) {
                            mCtx.beginPath();
                            mCtx.arc((x + 0.5) * cellWidth, (y + 0.5) * cellHeight, 5, 0, Math.PI * 2);
                            mCtx.stroke();
                        }
                    }
                }
            }
        }

        function drawDynamics() {
            const width = dynamicsCanvas.width;
            const height = dynamicsCanvas.height;

            dCtx.fillStyle = '#1a1a1a';
            dCtx.fillRect(0, 0, width, height);

            if (history.length < 2) return;

            const margin = { top: 30, right: 80, bottom: 40, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            const xScale = plotWidth / Math.max(1, history.length - 1);

            // Draw invasive population
            dCtx.strokeStyle = '#FF4444';
            dCtx.lineWidth = 2;
            dCtx.beginPath();
            history.forEach((h, i) => {
                const x = margin.left + i * xScale;
                const y = margin.top + plotHeight - (h.invasiveAbundance / (gridSize * gridSize)) * plotHeight;
                if (i === 0) dCtx.moveTo(x, y);
                else dCtx.lineTo(x, y);
            });
            dCtx.stroke();

            // Draw native population
            dCtx.strokeStyle = '#228B22';
            dCtx.lineWidth = 2;
            dCtx.beginPath();
            history.forEach((h, i) => {
                const x = margin.left + i * xScale;
                const y = margin.top + plotHeight - (h.nativeAbundance / (gridSize * gridSize)) * plotHeight;
                if (i === 0) dCtx.moveTo(x, y);
                else dCtx.lineTo(x, y);
            });
            dCtx.stroke();

            // Legend
            dCtx.fillStyle = '#FF4444';
            dCtx.fillRect(width - 75, margin.top + 5, 12, 12);
            dCtx.fillStyle = '#aaa';
            dCtx.font = '10px sans-serif';
            dCtx.textAlign = 'left';
            dCtx.fillText('Invasive', width - 60, margin.top + 15);

            dCtx.fillStyle = '#228B22';
            dCtx.fillRect(width - 75, margin.top + 25, 12, 12);
            dCtx.fillStyle = '#aaa';
            dCtx.fillText('Native', width - 60, margin.top + 35);

            // Axes
            dCtx.strokeStyle = '#666';
            dCtx.lineWidth = 1;
            dCtx.beginPath();
            dCtx.moveTo(margin.left, margin.top);
            dCtx.lineTo(margin.left, margin.top + plotHeight);
            dCtx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
            dCtx.stroke();

            dCtx.fillStyle = '#fff';
            dCtx.font = 'bold 12px sans-serif';
            dCtx.textAlign = 'center';
            dCtx.fillText('Population Abundance Over Time', width / 2, 18);
        }

        function drawSpread() {
            const width = spreadCanvas.width;
            const height = spreadCanvas.height;

            sCtx.fillStyle = '#1a1a1a';
            sCtx.fillRect(0, 0, width, height);

            if (spreadHistory.length < 2) return;

            const margin = { top: 30, right: 20, bottom: 40, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            const maxArea = gridSize * gridSize;
            const xScale = plotWidth / Math.max(1, spreadHistory.length - 1);
            const yScale = plotHeight / maxArea;

            // Fill under curve
            sCtx.fillStyle = 'rgba(255, 100, 100, 0.3)';
            sCtx.beginPath();
            sCtx.moveTo(margin.left, margin.top + plotHeight);
            spreadHistory.forEach((h, i) => {
                const x = margin.left + i * xScale;
                const y = margin.top + plotHeight - h.area * yScale;
                sCtx.lineTo(x, y);
            });
            sCtx.lineTo(margin.left + (spreadHistory.length - 1) * xScale, margin.top + plotHeight);
            sCtx.closePath();
            sCtx.fill();

            // Draw line
            sCtx.strokeStyle = '#FF6666';
            sCtx.lineWidth = 2;
            sCtx.beginPath();
            spreadHistory.forEach((h, i) => {
                const x = margin.left + i * xScale;
                const y = margin.top + plotHeight - h.area * yScale;
                if (i === 0) sCtx.moveTo(x, y);
                else sCtx.lineTo(x, y);
            });
            sCtx.stroke();

            // Mark lag phase if detectable
            if (introductionTick >= 0) {
                const lagEnd = spreadHistory.findIndex(h => h.area > gridSize * gridSize * 0.05);
                if (lagEnd > 0) {
                    const lagX = margin.left + lagEnd * xScale;
                    sCtx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                    sCtx.setLineDash([5, 5]);
                    sCtx.beginPath();
                    sCtx.moveTo(lagX, margin.top);
                    sCtx.lineTo(lagX, margin.top + plotHeight);
                    sCtx.stroke();
                    sCtx.setLineDash([]);

                    sCtx.fillStyle = '#FFC107';
                    sCtx.font = '10px sans-serif';
                    sCtx.textAlign = 'left';
                    sCtx.fillText('Lag phase ends', lagX + 5, margin.top + 15);
                }
            }

            // Axes
            sCtx.strokeStyle = '#666';
            sCtx.lineWidth = 1;
            sCtx.beginPath();
            sCtx.moveTo(margin.left, margin.top);
            sCtx.lineTo(margin.left, margin.top + plotHeight);
            sCtx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
            sCtx.stroke();

            sCtx.fillStyle = '#fff';
            sCtx.font = 'bold 12px sans-serif';
            sCtx.textAlign = 'center';
            sCtx.fillText('Invaded Area Over Time', width / 2, 18);
        }

        function drawDisplacement() {
            const width = displacementCanvas.width;
            const height = displacementCanvas.height;

            pCtx.fillStyle = '#1a1a1a';
            pCtx.fillRect(0, 0, width, height);

            const margin = { top: 30, right: 20, bottom: 50, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            // Calculate current native species abundances
            const abundances = nativeSpecies.map((sp, i) => {
                let total = 0;
                for (let x = 0; x < gridSize; x++) {
                    for (let y = 0; y < gridSize; y++) {
                        total += grid[x][y].nativeComposition[i] * grid[x][y].native;
                    }
                }
                return { species: sp.name, abundance: total, competitive: sp.competitive };
            });

            const maxAbundance = Math.max(...abundances.map(a => a.abundance), 1);
            const barWidth = plotWidth / nativeSpecies.length - 10;

            abundances.forEach((ab, i) => {
                const x = margin.left + i * (barWidth + 10) + 5;
                const barHeight = (ab.abundance / maxAbundance) * plotHeight;
                const y = margin.top + plotHeight - barHeight;

                // Color by status
                if (ab.abundance < 0.01) {
                    pCtx.fillStyle = '#666'; // Extinct
                } else if (ab.abundance < maxAbundance * 0.3) {
                    pCtx.fillStyle = '#FFA500'; // Threatened
                } else {
                    pCtx.fillStyle = '#228B22'; // Stable
                }

                pCtx.fillRect(x, y, barWidth, barHeight);

                // Label
                pCtx.fillStyle = '#aaa';
                pCtx.font = '9px sans-serif';
                pCtx.textAlign = 'center';
                pCtx.save();
                pCtx.translate(x + barWidth / 2, margin.top + plotHeight + 10);
                pCtx.rotate(-Math.PI / 4);
                pCtx.fillText(ab.species, 0, 0);
                pCtx.restore();
            });

            // Extinct marker
            pCtx.fillStyle = '#666';
            pCtx.font = '10px sans-serif';
            pCtx.textAlign = 'left';
            pCtx.fillText('Extinct: ' + nativeExtinctions, margin.left + 5, margin.top + 15);

            pCtx.fillStyle = '#fff';
            pCtx.font = 'bold 12px sans-serif';
            pCtx.textAlign = 'center';
            pCtx.fillText('Native Species Status', width / 2, 18);
        }

        function updateStats() {
            const stats = calculateStats();
            const yearsSinceIntro = introductionTick >= 0 ? tick - introductionTick : 0;

            document.getElementById('invasiveArea').textContent = stats.invasivePercent.toFixed(1) + '%';
            document.getElementById('nativeArea').textContent = stats.nativePercent.toFixed(1) + '%';
            document.getElementById('invasivePop').textContent = Math.round(stats.invasiveAbundance);
            document.getElementById('nativeLoss').textContent = nativeExtinctions;
            document.getElementById('invasionYear').textContent = yearsSinceIntro;
            document.getElementById('controlCost').textContent = '$' + Math.round(controlCost).toLocaleString();

            // Calculate spread rate
            if (spreadHistory.length > 10) {
                const recent = spreadHistory.slice(-10);
                const areaChange = recent[recent.length - 1].area - recent[0].area;
                const spreadRate = areaChange / 10; // cells per tick
                document.getElementById('spreadRate').textContent = spreadRate.toFixed(1);
            }

            // Lag phase duration
            if (invasionPhase === 'spread' || invasionPhase === 'saturation') {
                const lagEnd = spreadHistory.findIndex(h => h.area > gridSize * gridSize * 0.05);
                if (lagEnd > 0) {
                    document.getElementById('lagPhase').textContent = lagEnd;
                }
            } else {
                document.getElementById('lagPhase').textContent = '-';
            }
        }

        function draw() {
            drawMap();
            drawDynamics();
            drawSpread();
            drawDisplacement();
            updateStats();
        }

        function animate() {
            if (!isRunning) return;

            update();
            draw();

            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            isRunning = true;
            animate();
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            isRunning = false;
        });

        document.getElementById('introduceBtn').addEventListener('click', () => {
            introduceInvasive();
            draw();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            isRunning = false;
            updateParams();
            initGrid();
            draw();
        });

        document.getElementById('applyControl').addEventListener('click', () => {
            applyControl();
            draw();
        });

        // Sliders
        const sliders = ['propagulePressure', 'competitiveAbility', 'dispersalRate', 'nativeEnemyPressure',
                        'enemyRelease', 'disturbance', 'nativeRichness', 'controlIntensity'];
        sliders.forEach(id => {
            const slider = document.getElementById(id);
            const display = document.getElementById(id + 'Value');

            slider.addEventListener('input', () => {
                let value = parseFloat(slider.value);
                if (id === 'propagulePressure' || id === 'nativeRichness') {
                    display.textContent = value;
                } else if (id === 'competitiveAbility') {
                    display.textContent = value.toFixed(2) + 'x';
                } else {
                    display.textContent = value.toFixed(2);
                }
                updateParams();
            });
        });

        document.getElementById('controlStrategy').addEventListener('change', updateParams);

        // Initialize
        updateParams();
        initGrid();
        draw();
    </script>
</body>
</html>
