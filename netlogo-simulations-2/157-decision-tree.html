<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decision Tree - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 300px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #a78bfa; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #a78bfa; color: #1a1a2e; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #a78bfa; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .explain-btn { background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); margin-top: 10px; }
        .modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 1000; }
        .modal-overlay.active { display: flex; align-items: center; justify-content: center; }
        .modal { background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%); border-radius: 16px; padding: 30px; max-width: 600px; max-height: 80vh; overflow-y: auto; border: 1px solid rgba(255,255,255,0.1); position: relative; }
        .modal-close { position: absolute; top: 15px; right: 20px; background: none; border: none; color: #888; font-size: 28px; cursor: pointer; width: auto; }
        .modal h2 { color: #a78bfa; margin-bottom: 20px; }
        .modal-body { color: #ccc; line-height: 1.8; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <div id="container">
        <div id="canvas-container"><canvas id="canvas"></canvas></div>
        <div id="controls">
            <h1>Decision Tree</h1>
            <div class="control-group">
                <label>Max Depth: <span id="depthValue">3</span></label>
                <input type="range" id="depth" min="1" max="5" step="1" value="3">
            </div>
            <div class="control-group">
                <label>Min Samples: <span id="samplesValue">5</span></label>
                <input type="range" id="samples" min="1" max="20" step="1" value="5">
            </div>
            <button id="reset">Reset</button>
            <button id="grow">Grow Tree</button>
            <button id="explainBtn" class="explain-btn">üìö Explain</button>
            <div class="stats">
                <div>Nodes: <span id="nodes">0</span></div>
                <div>Leaves: <span id="leaves">0</span></div>
                <div>Depth: <span id="treeDepth">0</span></div>
            </div>
        </div>
    </div>
    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>Decision Tree</h2>
            <div class="modal-body">
                <p><strong>Decision trees</strong> are interpretable models that make decisions through hierarchical splits.</p>
                <p>Key concepts:</p>
                <ul>
                    <li><strong>Splitting:</strong> Divide data based on feature thresholds</li>
                    <li><strong>Information gain:</strong> Choose splits that maximize purity</li>
                    <li><strong>Pruning:</strong> Prevent overfitting by limiting depth</li>
                    <li><strong>Leaf nodes:</strong> Terminal nodes with class predictions</li>
                </ul>
                <p>Each node shows the split condition, colored by majority class.</p>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let params = { depth: 3, samples: 5 };
        let tree = null, data = [];
        
        function resize() { canvas.width = document.getElementById('canvas-container').clientWidth; canvas.height = document.getElementById('canvas-container').clientHeight; }
        
        function init() {
            resize();
            // Generate sample data
            data = [];
            for (let i = 0; i < 100; i++) {
                const x = Math.random();
                const y = Math.random();
                const label = (x + y > 1) ? 1 : 0;
                data.push({ x, y, label });
            }
            tree = { feature: 'root', threshold: 0.5, left: null, right: null, label: null, depth: 0, samples: data.length };
        }
        
        function gini(samples) {
            if (samples.length === 0) return 0;
            const count0 = samples.filter(s => s.label === 0).length;
            const count1 = samples.length - count0;
            const p0 = count0 / samples.length;
            const p1 = count1 / samples.length;
            return 1 - p0*p0 - p1*p1;
        }
        
        function splitNode(node, samples, depth) {
            if (depth >= params.depth || samples.length < params.samples) {
                node.label = samples.filter(s => s.label === 1).length > samples.length / 2 ? 1 : 0;
                return;
            }
            
            let bestGain = 0, bestFeature = 'x', bestThreshold = 0.5;
            
            for (let feature of ['x', 'y']) {
                for (let t = 0.1; t <= 0.9; t += 0.1) {
                    const left = samples.filter(s => s[feature] <= t);
                    const right = samples.filter(s => s[feature] > t);
                    if (left.length === 0 || right.length === 0) continue;
                    
                    const gain = gini(samples) - (left.length/samples.length * gini(left) + right.length/samples.length * gini(right));
                    if (gain > bestGain) {
                        bestGain = gain;
                        bestFeature = feature;
                        bestThreshold = t;
                    }
                }
            }
            
            if (bestGain > 0.01) {
                node.feature = bestFeature;
                node.threshold = bestThreshold;
                const leftSamples = samples.filter(s => s[node.feature] <= node.threshold);
                const rightSamples = samples.filter(s => s[node.feature] > node.threshold);
                
                node.left = { left: null, right: null, label: null, depth: depth + 1, samples: leftSamples.length };
                node.right = { left: null, right: null, label: null, depth: depth + 1, samples: rightSamples.length };
                
                splitNode(node.left, leftSamples, depth + 1);
                splitNode(node.right, rightSamples, depth + 1);
            } else {
                node.label = samples.filter(s => s.label === 1).length > samples.length / 2 ? 1 : 0;
            }
        }
        
        function growTree() {
            tree = { feature: 'root', threshold: 0.5, left: null, right: null, label: null, depth: 0, samples: data.length };
            splitNode(tree, data, 0);
        }
        
        function countNodes(node) {
            if (!node) return 0;
            return 1 + countNodes(node.left) + countNodes(node.right);
        }
        
        function countLeaves(node) {
            if (!node) return 0;
            if (!node.left && !node.right) return 1;
            return countLeaves(node.left) + countLeaves(node.right);
        }
        
        function getDepth(node) {
            if (!node) return 0;
            return 1 + Math.max(getDepth(node.left), getDepth(node.right));
        }
        
        function drawNode(node, x, y, width, depth) {
            if (!node) return;
            
            const nodeWidth = 80, nodeHeight = 40;
            
            // Draw connections
            if (node.left) {
                ctx.strokeStyle = '#4ade80';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y + nodeHeight/2);
                ctx.lineTo(x - width/4, y + 80);
                ctx.stroke();
            }
            if (node.right) {
                ctx.strokeStyle = '#f472b6';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y + nodeHeight/2);
                ctx.lineTo(x + width/4, y + 80);
                ctx.stroke();
            }
            
            // Draw node
            ctx.fillStyle = node.label === 1 ? '#f472b6' : (node.label === 0 ? '#4ade80' : '#a78bfa');
            ctx.fillRect(x - nodeWidth/2, y - nodeHeight/2, nodeWidth, nodeHeight);
            ctx.strokeStyle = '#fff';
            ctx.strokeRect(x - nodeWidth/2, y - nodeHeight/2, nodeWidth, nodeHeight);
            
            ctx.fillStyle = '#fff';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'center';
            if (node.label !== null) {
                ctx.fillText(`Class ${node.label}`, x, y);
                ctx.fillText(`n=${node.samples}`, x, y + 12);
            } else {
                ctx.fillText(`${node.feature} <= ${node.threshold.toFixed(1)}`, x, y);
                ctx.fillText(`n=${node.samples}`, x, y + 12);
            }
            
            drawNode(node.left, x - width/4, y + 80, width/2, depth + 1);
            drawNode(node.right, x + width/4, y + 80, width/2, depth + 1);
        }
        
        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (tree) {
                drawNode(tree, (canvas.width - 300) / 2, 60, canvas.width - 400, 0);
            }
            
            document.getElementById('nodes').textContent = countNodes(tree);
            document.getElementById('leaves').textContent = countLeaves(tree);
            document.getElementById('treeDepth').textContent = getDepth(tree);
        }
        
        function animate() { draw(); requestAnimationFrame(animate); }
        
        document.getElementById('depth').addEventListener('input', e => { params.depth = parseInt(e.target.value); document.getElementById('depthValue').textContent = params.depth; });
        document.getElementById('samples').addEventListener('input', e => { params.samples = parseInt(e.target.value); document.getElementById('samplesValue').textContent = params.samples; });
        document.getElementById('reset').addEventListener('click', init);
        document.getElementById('grow').addEventListener('click', growTree);
        window.addEventListener('resize', resize);
        const modal = document.getElementById('explainModal');
        document.getElementById('explainBtn').addEventListener('click', () => modal.classList.add('active'));
        modal.querySelector('.modal-close').addEventListener('click', () => modal.classList.remove('active'));
        modal.addEventListener('click', e => { if (e.target === modal) modal.classList.remove('active'); });
        init(); animate();
    </script>
</body>
</html>
