<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Codon Usage Bias Simulation</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        .back-link {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: var(--terracotta);
        }

        h1 {
            color: var(--dark-moss);
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .subtitle {
            color: var(--moss);
            font-size: 1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: var(--moss);
            font-size: 0.95em;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid var(--sage);
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            color: var(--dark-moss);
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group .value {
            text-align: right;
            font-size: 0.8em;
            color: var(--moss);
        }

        .control-group select {
            width: 100%;
            padding: 6px;
            border: 1px solid var(--sage);
            border-radius: 6px;
            font-size: 0.9em;
        }

        .button-group {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.3s;
        }

        .btn-primary {
            background: var(--sage);
            color: white;
        }

        .btn-primary:hover {
            background: var(--moss);
        }

        .btn-secondary {
            background: var(--earth);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--terracotta);
        }

        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .viz-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .viz-panel {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .viz-panel.full-width {
            grid-column: 1 / -1;
        }

        .viz-panel h3 {
            color: var(--moss);
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        canvas {
            width: 100%;
            border-radius: 8px;
            background: #1a1a2e;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .stat-box {
            background: linear-gradient(135deg, var(--cream) 0%, white 100%);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            border-left: 3px solid var(--sage);
        }

        .stat-box.highlight {
            border-left-color: var(--terracotta);
        }

        .stat-box .label {
            font-size: 0.75em;
            color: var(--moss);
            margin-bottom: 4px;
        }

        .stat-box .value {
            font-size: 1.2em;
            font-weight: bold;
            color: var(--dark-moss);
        }

        .codon-table {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            font-size: 0.7em;
            margin-top: 10px;
        }

        .codon-cell {
            background: linear-gradient(135deg, var(--cream) 0%, white 100%);
            padding: 6px;
            border-radius: 4px;
            text-align: center;
        }

        .codon-cell.optimal {
            background: linear-gradient(135deg, #c8e6c9 0%, white 100%);
            border: 1px solid #4CAF50;
        }

        .codon-cell .codon {
            font-family: monospace;
            font-weight: bold;
            color: var(--dark-moss);
        }

        .codon-cell .freq {
            color: var(--moss);
            font-size: 0.9em;
        }

        .info-box {
            background: linear-gradient(135deg, #e3f2fd 0%, white 100%);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            font-size: 0.8em;
            color: var(--dark-moss);
        }

        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
            font-size: 0.8em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .amino-acid-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 10px;
        }

        .aa-btn {
            padding: 4px 8px;
            border: 1px solid var(--sage);
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 0.75em;
            transition: all 0.2s;
        }

        .aa-btn.active {
            background: var(--sage);
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">← Back to Simulations</a>
            <h1>Codon Usage Bias</h1>
            <p class="subtitle">Translational Selection, tRNA Availability, and Mutation-Selection Balance</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-section">
                    <h3>Population Parameters</h3>
                    <div class="control-group">
                        <label>Population Size (N): <span id="popSizeVal">200</span></label>
                        <input type="range" id="popSize" min="50" max="500" value="200">
                    </div>
                    <div class="control-group">
                        <label>Mutation Rate: <span id="mutRateVal">0.001</span></label>
                        <input type="range" id="mutRate" min="1" max="50" value="10">
                        <div class="value">×10⁻⁴</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Selection Parameters</h3>
                    <div class="control-group">
                        <label>Selection Strength: <span id="selStrengthVal">0.01</span></label>
                        <input type="range" id="selStrength" min="0" max="100" value="10">
                        <div class="value">×10⁻³</div>
                    </div>
                    <div class="control-group">
                        <label>Expression Level: <span id="exprLevelVal">High</span></label>
                        <input type="range" id="exprLevel" min="1" max="100" value="80">
                        <div class="value">Higher = stronger selection</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Mutation Bias</h3>
                    <div class="control-group">
                        <label>GC → AT Bias: <span id="gcBiasVal">1.0</span></label>
                        <input type="range" id="gcBias" min="5" max="30" value="10">
                        <div class="value">×0.1 (1.0 = no bias)</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>tRNA Pool</h3>
                    <div class="control-group">
                        <label>tRNA Abundance Variation: <span id="trnaVarVal">High</span></label>
                        <input type="range" id="trnaVar" min="1" max="100" value="70">
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="info-box">
                    <strong>Codon Usage Bias:</strong><br>
                    Synonymous codons aren't used equally. Optimal codons match abundant tRNAs, enabling faster and more accurate translation. Selection strength scales with gene expression level.
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-row">
                    <div class="viz-panel">
                        <h3>Codon Frequency Evolution</h3>
                        <canvas id="freqCanvas"></canvas>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #4CAF50;"></div>
                                <span>Optimal Codon</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FF9800;"></div>
                                <span>Sub-optimal Codons</span>
                            </div>
                        </div>
                    </div>
                    <div class="viz-panel">
                        <h3>tRNA Availability vs Codon Usage</h3>
                        <canvas id="trnaCanvas"></canvas>
                    </div>
                </div>

                <div class="viz-panel full-width">
                    <h3>Codon Adaptation Index (CAI) Over Time</h3>
                    <canvas id="caiCanvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #2196F3;"></div>
                            <span>Population Mean CAI</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #9C27B0;"></div>
                            <span>Equilibrium Prediction</span>
                        </div>
                    </div>
                </div>

                <div class="viz-row">
                    <div class="viz-panel">
                        <h3>Ribosome Speed Distribution</h3>
                        <canvas id="riboCanvas"></canvas>
                    </div>
                    <div class="viz-panel">
                        <h3>Fitness Landscape</h3>
                        <canvas id="fitnessCanvas"></canvas>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="label">Generation</div>
                        <div class="value" id="genStat">0</div>
                    </div>
                    <div class="stat-box highlight">
                        <div class="label">Mean CAI</div>
                        <div class="value" id="caiStat">0.500</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Optimal Codon %</div>
                        <div class="value" id="optStat">50.0%</div>
                    </div>
                    <div class="stat-box highlight">
                        <div class="label">Translation Speed</div>
                        <div class="value" id="speedStat">1.00x</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">GC Content</div>
                        <div class="value" id="gcStat">50.0%</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Effective N_e</div>
                        <div class="value" id="neStat">200</div>
                    </div>
                </div>

                <div class="viz-panel">
                    <h3>Leucine Codon Family (6 synonymous codons)</h3>
                    <div class="codon-table" id="leucineTable">
                        <!-- Filled by JS -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const freqCanvas = document.getElementById('freqCanvas');
        const trnaCanvas = document.getElementById('trnaCanvas');
        const caiCanvas = document.getElementById('caiCanvas');
        const riboCanvas = document.getElementById('riboCanvas');
        const fitnessCanvas = document.getElementById('fitnessCanvas');

        const freqCtx = freqCanvas.getContext('2d');
        const trnaCtx = trnaCanvas.getContext('2d');
        const caiCtx = caiCanvas.getContext('2d');
        const riboCtx = riboCanvas.getContext('2d');
        const fitnessCtx = fitnessCanvas.getContext('2d');

        // Leucine codons with their properties
        const leucineCodons = [
            { codon: 'UUA', tRNA: 0.3, gc: 0, optimal: false },
            { codon: 'UUG', tRNA: 0.5, gc: 1, optimal: false },
            { codon: 'CUU', tRNA: 0.4, gc: 1, optimal: false },
            { codon: 'CUC', tRNA: 0.6, gc: 2, optimal: false },
            { codon: 'CUA', tRNA: 0.2, gc: 1, optimal: false },
            { codon: 'CUG', tRNA: 1.0, gc: 2, optimal: true }  // Most common in E.coli
        ];

        // Parameters
        let N = 200;
        let mutRate = 0.001;
        let selStrength = 0.01;
        let exprLevel = 80;
        let gcBias = 1.0;
        let trnaVar = 70;

        // State
        let population = [];  // Array of genomes, each genome is array of codon indices
        let generation = 0;
        let caiHistory = [];
        let codonFreqHistory = [];
        let running = false;
        let animationId = null;

        const genesPerGenome = 10;
        const codonsPerGene = 20;

        function setupCanvas(canvas, ctx, height) {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = (rect.width - 30) * dpr;
            canvas.height = height * dpr;
            canvas.style.width = (rect.width - 30) + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(dpr, dpr);
        }

        function updateTRNAAvailability() {
            // Vary tRNA based on trnaVar parameter
            const variation = trnaVar / 100;
            leucineCodons.forEach((c, i) => {
                if (i === 5) { // CUG always most abundant
                    c.tRNA = 0.5 + 0.5 * variation;
                } else {
                    c.tRNA = Math.max(0.1, c.tRNA * (0.5 + 0.5 * (1 - variation) + Math.random() * variation * 0.5));
                }
            });

            // Normalize and mark optimal
            const maxTRNA = Math.max(...leucineCodons.map(c => c.tRNA));
            leucineCodons.forEach(c => {
                c.optimal = c.tRNA >= maxTRNA * 0.9;
            });
        }

        function initPopulation() {
            updateTRNAAvailability();

            population = [];
            for (let i = 0; i < N; i++) {
                const genome = [];
                for (let g = 0; g < genesPerGenome; g++) {
                    const gene = [];
                    for (let c = 0; c < codonsPerGene; c++) {
                        // Start with random codons
                        gene.push(Math.floor(Math.random() * 6));
                    }
                    genome.push(gene);
                }
                population.push(genome);
            }

            generation = 0;
            caiHistory = [];
            codonFreqHistory = [];
        }

        function getCodonFrequencies() {
            const counts = new Array(6).fill(0);
            let total = 0;

            population.forEach(genome => {
                genome.forEach(gene => {
                    gene.forEach(codonIdx => {
                        counts[codonIdx]++;
                        total++;
                    });
                });
            });

            return counts.map(c => c / total);
        }

        function calculateCAI(genome) {
            // CAI = geometric mean of relative adaptiveness
            const maxTRNA = Math.max(...leucineCodons.map(c => c.tRNA));
            let product = 1;
            let count = 0;

            genome.forEach(gene => {
                gene.forEach(codonIdx => {
                    const w = leucineCodons[codonIdx].tRNA / maxTRNA;
                    product *= w;
                    count++;
                });
            });

            return Math.pow(product, 1 / count);
        }

        function calculateTranslationSpeed(genome) {
            let totalSpeed = 0;
            let count = 0;

            genome.forEach(gene => {
                gene.forEach(codonIdx => {
                    totalSpeed += leucineCodons[codonIdx].tRNA;
                    count++;
                });
            });

            return totalSpeed / count;
        }

        function calculateFitness(genome) {
            const cai = calculateCAI(genome);
            // Selection strength scales with expression level
            const effectiveS = selStrength * (exprLevel / 50);
            return Math.exp(effectiveS * cai * genesPerGenome);
        }

        function mutate(genome) {
            const newGenome = genome.map(gene => [...gene]);

            newGenome.forEach(gene => {
                for (let c = 0; c < gene.length; c++) {
                    if (Math.random() < mutRate) {
                        const currentCodon = gene[c];
                        const currentGC = leucineCodons[currentCodon].gc;

                        // Apply mutation with GC bias
                        let candidates = [];
                        for (let i = 0; i < 6; i++) {
                            if (i !== currentCodon) {
                                const newGC = leucineCodons[i].gc;
                                let weight = 1;

                                // GC → AT bias means higher weight for lower GC
                                if (newGC < currentGC) {
                                    weight = gcBias;
                                } else if (newGC > currentGC) {
                                    weight = 1 / gcBias;
                                }

                                for (let w = 0; w < Math.round(weight * 10); w++) {
                                    candidates.push(i);
                                }
                            }
                        }

                        gene[c] = candidates[Math.floor(Math.random() * candidates.length)];
                    }
                }
            });

            return newGenome;
        }

        function reproduce() {
            const fitnesses = population.map(calculateFitness);
            const totalFitness = fitnesses.reduce((a, b) => a + b, 0);

            const newPop = [];
            for (let i = 0; i < N; i++) {
                // Select parent proportional to fitness
                let r = Math.random() * totalFitness;
                let parentIdx = 0;
                let cumFitness = fitnesses[0];

                while (cumFitness < r && parentIdx < N - 1) {
                    parentIdx++;
                    cumFitness += fitnesses[parentIdx];
                }

                newPop.push(mutate(population[parentIdx]));
            }

            population = newPop;
            generation++;

            // Record history
            if (generation % 5 === 0) {
                const meanCAI = population.reduce((sum, g) => sum + calculateCAI(g), 0) / N;
                caiHistory.push({ gen: generation, cai: meanCAI });

                const freqs = getCodonFrequencies();
                codonFreqHistory.push({ gen: generation, freqs: freqs });

                // Keep manageable
                if (caiHistory.length > 300) {
                    caiHistory = caiHistory.filter((_, i) => i % 2 === 0);
                    codonFreqHistory = codonFreqHistory.filter((_, i) => i % 2 === 0);
                }
            }
        }

        function drawFrequencyEvolution() {
            const width = freqCanvas.width / (window.devicePixelRatio || 1);
            const height = freqCanvas.height / (window.devicePixelRatio || 1);

            freqCtx.fillStyle = '#1a1a2e';
            freqCtx.fillRect(0, 0, width, height);

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Axes
            freqCtx.strokeStyle = '#ffffff44';
            freqCtx.beginPath();
            freqCtx.moveTo(padding, padding);
            freqCtx.lineTo(padding, height - padding);
            freqCtx.lineTo(width - padding, height - padding);
            freqCtx.stroke();

            freqCtx.fillStyle = '#ffffffaa';
            freqCtx.font = '10px sans-serif';
            freqCtx.fillText('Frequency', padding, padding - 10);
            freqCtx.fillText('Generation', width - padding - 50, height - 10);

            if (codonFreqHistory.length < 2) return;

            const maxGen = codonFreqHistory[codonFreqHistory.length - 1].gen;

            // Draw each codon's frequency line
            const colors = ['#FF5722', '#FF9800', '#FFC107', '#FFEB3B', '#CDDC39', '#4CAF50'];

            for (let codonIdx = 0; codonIdx < 6; codonIdx++) {
                freqCtx.strokeStyle = leucineCodons[codonIdx].optimal ? '#4CAF50' : colors[codonIdx];
                freqCtx.lineWidth = leucineCodons[codonIdx].optimal ? 2 : 1;
                freqCtx.beginPath();

                codonFreqHistory.forEach((point, i) => {
                    const x = padding + (point.gen / maxGen) * graphWidth;
                    const y = height - padding - point.freqs[codonIdx] * graphHeight;

                    if (i === 0) {
                        freqCtx.moveTo(x, y);
                    } else {
                        freqCtx.lineTo(x, y);
                    }
                });
                freqCtx.stroke();
            }
        }

        function drawTRNACorrelation() {
            const width = trnaCanvas.width / (window.devicePixelRatio || 1);
            const height = trnaCanvas.height / (window.devicePixelRatio || 1);

            trnaCtx.fillStyle = '#1a1a2e';
            trnaCtx.fillRect(0, 0, width, height);

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Axes
            trnaCtx.strokeStyle = '#ffffff44';
            trnaCtx.beginPath();
            trnaCtx.moveTo(padding, padding);
            trnaCtx.lineTo(padding, height - padding);
            trnaCtx.lineTo(width - padding, height - padding);
            trnaCtx.stroke();

            trnaCtx.fillStyle = '#ffffffaa';
            trnaCtx.font = '10px sans-serif';
            trnaCtx.fillText('Codon Usage', padding, padding - 10);
            trnaCtx.fillText('tRNA Abundance', width - padding - 70, height - 10);

            const freqs = getCodonFrequencies();
            const maxTRNA = Math.max(...leucineCodons.map(c => c.tRNA));
            const maxFreq = Math.max(...freqs, 0.3);

            // Draw points
            leucineCodons.forEach((codon, i) => {
                const x = padding + (codon.tRNA / maxTRNA) * graphWidth;
                const y = height - padding - (freqs[i] / maxFreq) * graphHeight;

                trnaCtx.beginPath();
                trnaCtx.arc(x, y, 8, 0, Math.PI * 2);
                trnaCtx.fillStyle = codon.optimal ? '#4CAF50' : '#FF9800';
                trnaCtx.fill();

                trnaCtx.fillStyle = 'white';
                trnaCtx.font = '8px monospace';
                trnaCtx.textAlign = 'center';
                trnaCtx.fillText(codon.codon, x, y + 3);
            });

            // Draw ideal correlation line
            trnaCtx.strokeStyle = '#ffffff44';
            trnaCtx.setLineDash([5, 5]);
            trnaCtx.beginPath();
            trnaCtx.moveTo(padding, height - padding);
            trnaCtx.lineTo(width - padding, padding);
            trnaCtx.stroke();
            trnaCtx.setLineDash([]);
        }

        function drawCAIHistory() {
            const width = caiCanvas.width / (window.devicePixelRatio || 1);
            const height = caiCanvas.height / (window.devicePixelRatio || 1);

            caiCtx.fillStyle = '#1a1a2e';
            caiCtx.fillRect(0, 0, width, height);

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Axes
            caiCtx.strokeStyle = '#ffffff44';
            caiCtx.beginPath();
            caiCtx.moveTo(padding, padding);
            caiCtx.lineTo(padding, height - padding);
            caiCtx.lineTo(width - padding, height - padding);
            caiCtx.stroke();

            caiCtx.fillStyle = '#ffffffaa';
            caiCtx.font = '10px sans-serif';
            caiCtx.fillText('CAI', padding, padding - 10);
            caiCtx.fillText('0', padding - 20, height - padding);
            caiCtx.fillText('1', padding - 20, padding + 10);

            // Expected equilibrium CAI (approximation)
            const effectiveS = selStrength * (exprLevel / 50);
            const Ns = N * effectiveS;
            const equilibriumCAI = Ns > 0.1 ? Math.min(0.95, 0.5 + 0.4 * (1 - Math.exp(-Ns))) : 0.5;

            caiCtx.strokeStyle = '#9C27B0';
            caiCtx.setLineDash([5, 5]);
            caiCtx.beginPath();
            const eqY = height - padding - equilibriumCAI * graphHeight;
            caiCtx.moveTo(padding, eqY);
            caiCtx.lineTo(width - padding, eqY);
            caiCtx.stroke();
            caiCtx.setLineDash([]);
            caiCtx.fillStyle = '#9C27B0';
            caiCtx.fillText(`Eq: ${equilibriumCAI.toFixed(2)}`, width - padding - 50, eqY - 5);

            if (caiHistory.length < 2) return;

            const maxGen = caiHistory[caiHistory.length - 1].gen;

            // Draw CAI line
            caiCtx.strokeStyle = '#2196F3';
            caiCtx.lineWidth = 2;
            caiCtx.beginPath();

            caiHistory.forEach((point, i) => {
                const x = padding + (point.gen / maxGen) * graphWidth;
                const y = height - padding - point.cai * graphHeight;

                if (i === 0) {
                    caiCtx.moveTo(x, y);
                } else {
                    caiCtx.lineTo(x, y);
                }
            });
            caiCtx.stroke();
        }

        function drawRibosomeSpeed() {
            const width = riboCanvas.width / (window.devicePixelRatio || 1);
            const height = riboCanvas.height / (window.devicePixelRatio || 1);

            riboCtx.fillStyle = '#1a1a2e';
            riboCtx.fillRect(0, 0, width, height);

            const padding = 30;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Calculate speed distribution
            const speeds = population.map(calculateTranslationSpeed);
            const minSpeed = Math.min(...speeds);
            const maxSpeed = Math.max(...speeds);
            const range = maxSpeed - minSpeed || 0.1;

            const bins = 20;
            const histogram = new Array(bins).fill(0);
            speeds.forEach(s => {
                const bin = Math.min(bins - 1, Math.floor((s - minSpeed) / range * bins));
                histogram[bin]++;
            });

            const maxCount = Math.max(...histogram);
            const barWidth = graphWidth / bins;

            histogram.forEach((count, i) => {
                const x = padding + i * barWidth;
                const barHeight = (count / maxCount) * graphHeight;

                const gradient = riboCtx.createLinearGradient(x, height - padding, x, height - padding - barHeight);
                gradient.addColorStop(0, '#00BCD4');
                gradient.addColorStop(1, '#4DD0E1');

                riboCtx.fillStyle = gradient;
                riboCtx.fillRect(x + 1, height - padding - barHeight, barWidth - 2, barHeight);
            });

            riboCtx.fillStyle = '#ffffffaa';
            riboCtx.font = '10px sans-serif';
            riboCtx.fillText('Translation Speed Distribution', padding, padding - 10);
        }

        function drawFitnessLandscape() {
            const width = fitnessCanvas.width / (window.devicePixelRatio || 1);
            const height = fitnessCanvas.height / (window.devicePixelRatio || 1);

            fitnessCtx.fillStyle = '#1a1a2e';
            fitnessCtx.fillRect(0, 0, width, height);

            const padding = 30;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Draw fitness as function of CAI
            fitnessCtx.strokeStyle = '#E91E63';
            fitnessCtx.lineWidth = 2;
            fitnessCtx.beginPath();

            const effectiveS = selStrength * (exprLevel / 50);

            for (let i = 0; i <= 50; i++) {
                const cai = i / 50;
                const fitness = Math.exp(effectiveS * cai * genesPerGenome);
                const maxFit = Math.exp(effectiveS * genesPerGenome);

                const x = padding + (cai) * graphWidth;
                const y = height - padding - (fitness / maxFit) * graphHeight;

                if (i === 0) {
                    fitnessCtx.moveTo(x, y);
                } else {
                    fitnessCtx.lineTo(x, y);
                }
            }
            fitnessCtx.stroke();

            // Mark current population mean
            const meanCAI = population.reduce((sum, g) => sum + calculateCAI(g), 0) / N;
            const meanX = padding + meanCAI * graphWidth;

            fitnessCtx.strokeStyle = '#4CAF50';
            fitnessCtx.setLineDash([3, 3]);
            fitnessCtx.beginPath();
            fitnessCtx.moveTo(meanX, height - padding);
            fitnessCtx.lineTo(meanX, padding);
            fitnessCtx.stroke();
            fitnessCtx.setLineDash([]);

            fitnessCtx.fillStyle = '#ffffffaa';
            fitnessCtx.font = '10px sans-serif';
            fitnessCtx.fillText('Fitness Landscape', padding, padding - 10);
            fitnessCtx.fillText('CAI', width - padding - 20, height - 5);
        }

        function updateLeucineTable() {
            const freqs = getCodonFrequencies();
            const table = document.getElementById('leucineTable');
            table.innerHTML = '';

            leucineCodons.forEach((codon, i) => {
                const cell = document.createElement('div');
                cell.className = 'codon-cell' + (codon.optimal ? ' optimal' : '');
                cell.innerHTML = `
                    <div class="codon">${codon.codon}</div>
                    <div class="freq">${(freqs[i] * 100).toFixed(1)}%</div>
                    <div class="freq">tRNA: ${codon.tRNA.toFixed(2)}</div>
                `;
                table.appendChild(cell);
            });
        }

        function updateStats() {
            const meanCAI = population.reduce((sum, g) => sum + calculateCAI(g), 0) / N;
            const meanSpeed = population.reduce((sum, g) => sum + calculateTranslationSpeed(g), 0) / N;
            const freqs = getCodonFrequencies();

            let optimalPct = 0;
            leucineCodons.forEach((c, i) => {
                if (c.optimal) optimalPct += freqs[i];
            });

            let gcContent = 0;
            freqs.forEach((f, i) => {
                gcContent += f * leucineCodons[i].gc / 3;
            });

            document.getElementById('genStat').textContent = generation;
            document.getElementById('caiStat').textContent = meanCAI.toFixed(3);
            document.getElementById('optStat').textContent = (optimalPct * 100).toFixed(1) + '%';
            document.getElementById('speedStat').textContent = meanSpeed.toFixed(2) + 'x';
            document.getElementById('gcStat').textContent = (gcContent * 100).toFixed(1) + '%';
            document.getElementById('neStat').textContent = N;
        }

        function animate() {
            reproduce();

            drawFrequencyEvolution();
            drawTRNACorrelation();
            drawCAIHistory();
            drawRibosomeSpeed();
            drawFitnessLandscape();
            updateLeucineTable();
            updateStats();

            if (running) {
                animationId = requestAnimationFrame(animate);
            }
        }

        function start() {
            if (!running) {
                running = true;
                document.getElementById('startBtn').textContent = 'Pause';
                animate();
            } else {
                running = false;
                document.getElementById('startBtn').textContent = 'Start';
                if (animationId) cancelAnimationFrame(animationId);
            }
        }

        function reset() {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            if (animationId) cancelAnimationFrame(animationId);

            N = parseInt(document.getElementById('popSize').value);
            mutRate = parseInt(document.getElementById('mutRate').value) / 10000;
            selStrength = parseInt(document.getElementById('selStrength').value) / 1000;
            exprLevel = parseInt(document.getElementById('exprLevel').value);
            gcBias = parseInt(document.getElementById('gcBias').value) / 10;
            trnaVar = parseInt(document.getElementById('trnaVar').value);

            initPopulation();
            drawFrequencyEvolution();
            drawTRNACorrelation();
            drawCAIHistory();
            drawRibosomeSpeed();
            drawFitnessLandscape();
            updateLeucineTable();
            updateStats();
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', start);
        document.getElementById('resetBtn').addEventListener('click', reset);

        document.getElementById('popSize').addEventListener('input', (e) => {
            document.getElementById('popSizeVal').textContent = e.target.value;
        });

        document.getElementById('mutRate').addEventListener('input', (e) => {
            document.getElementById('mutRateVal').textContent = (e.target.value / 10000).toFixed(4);
        });

        document.getElementById('selStrength').addEventListener('input', (e) => {
            document.getElementById('selStrengthVal').textContent = (e.target.value / 1000).toFixed(3);
        });

        document.getElementById('exprLevel').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            document.getElementById('exprLevelVal').textContent =
                val < 30 ? 'Low' : val < 70 ? 'Medium' : 'High';
        });

        document.getElementById('gcBias').addEventListener('input', (e) => {
            document.getElementById('gcBiasVal').textContent = (e.target.value / 10).toFixed(1);
        });

        document.getElementById('trnaVar').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            document.getElementById('trnaVarVal').textContent =
                val < 30 ? 'Low' : val < 70 ? 'Medium' : 'High';
        });

        // Initialize
        function init() {
            setupCanvas(freqCanvas, freqCtx, 180);
            setupCanvas(trnaCanvas, trnaCtx, 180);
            setupCanvas(caiCanvas, caiCtx, 150);
            setupCanvas(riboCanvas, riboCtx, 150);
            setupCanvas(fitnessCanvas, fitnessCtx, 150);

            initPopulation();
            drawFrequencyEvolution();
            drawTRNACorrelation();
            drawCAIHistory();
            drawRibosomeSpeed();
            drawFitnessLandscape();
            updateLeucineTable();
            updateStats();
        }

        window.addEventListener('resize', () => {
            setupCanvas(freqCanvas, freqCtx, 180);
            setupCanvas(trnaCanvas, trnaCtx, 180);
            setupCanvas(caiCanvas, caiCtx, 150);
            setupCanvas(riboCanvas, riboCtx, 150);
            setupCanvas(fitnessCanvas, fitnessCtx, 150);
            drawFrequencyEvolution();
            drawTRNACorrelation();
            drawCAIHistory();
            drawRibosomeSpeed();
            drawFitnessLandscape();
        });

        init();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
