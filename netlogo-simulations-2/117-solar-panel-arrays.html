<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar Panel Arrays - Photovoltaic Simulation</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { font-family: 'Lora', serif; color: #606C38; font-size: 2rem; margin-bottom: 8px; }
        .subtitle { color: #8A9A5B; font-size: 1rem; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #606C38; font-weight: 600; }
        .back-link:hover { color: #BC6C25; }
        .main-content { display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .canvas-container { background: white; border-radius: 12px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        canvas { width: 100%; border-radius: 8px; display: block; }
        .controls { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); height: fit-content; }
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; color: #606C38; font-weight: 600; margin-bottom: 5px; font-size: 0.9rem; }
        .control-group input[type="range"] { width: 100%; accent-color: #8A9A5B; }
        .control-value { text-align: right; color: #8A9A5B; font-size: 0.85rem; }
        button { width: 100%; padding: 10px; margin-top: 5px; border: none; border-radius: 8px; cursor: pointer; font-family: 'Nunito', sans-serif; font-weight: 600; font-size: 0.9rem; transition: all 0.3s; }
        .btn-primary { background: #8A9A5B; color: white; }
        .btn-primary:hover { background: #606C38; }
        .btn-secondary { background: #DDA15E; color: white; }
        .btn-secondary:hover { background: #BC6C25; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        .stat-box { background: linear-gradient(135deg, #FEFAE0, #F4F1DE); padding: 10px; border-radius: 8px; text-align: center; }
        .stat-value { font-family: 'Lora', serif; color: #606C38; font-size: 1.1rem; font-weight: 600; }
        .stat-label { color: #8A9A5B; font-size: 0.75rem; }
        .info-panel { margin-top: 15px; padding: 12px; background: #F4F1DE; border-radius: 8px; font-size: 0.8rem; color: #606C38; }
        select { width: 100%; padding: 8px; border: 1px solid #DDA15E; border-radius: 6px; font-family: 'Nunito', sans-serif; background: white; color: #606C38; }
        .scenario-btn { width: 100%; padding: 8px; margin-top: 5px; font-size: 0.8rem; }
        .sun-display { background: linear-gradient(to bottom, #87CEEB, #FFD700); padding: 10px; border-radius: 8px; text-align: center; color: #333; font-weight: 600; margin-bottom: 15px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Solar Panel Arrays</h1>
            <p class="subtitle">Photovoltaic simulation with sun tracking, shading, and grid integration</p>
        </header>
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="simCanvas"></canvas>
            </div>
            <div class="controls">
                <div class="sun-display" id="sunDisplay">☀️ Solar Noon | Altitude: 65°</div>
                <div class="control-group">
                    <label>Tracking System</label>
                    <select id="tracking">
                        <option value="fixed">Fixed Tilt</option>
                        <option value="single" selected>Single-Axis Tracking</option>
                        <option value="dual">Dual-Axis Tracking</option>
                        <option value="backtrack">Backtracking</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Panel Tilt (Fixed Mode)</label>
                    <input type="range" id="tilt" min="0" max="60" value="30">
                    <div class="control-value"><span id="tiltVal">30</span>°</div>
                </div>
                <div class="control-group">
                    <label>Array Spacing (m)</label>
                    <input type="range" id="spacing" min="2" max="8" step="0.5" value="4">
                    <div class="control-value"><span id="spacingVal">4</span>m</div>
                </div>
                <div class="control-group">
                    <label>Latitude</label>
                    <input type="range" id="latitude" min="0" max="60" value="35">
                    <div class="control-value"><span id="latitudeVal">35</span>°N</div>
                </div>
                <div class="control-group">
                    <label>Day of Year</label>
                    <input type="range" id="dayOfYear" min="1" max="365" value="172">
                    <div class="control-value">Day <span id="dayOfYearVal">172</span></div>
                </div>
                <button class="btn-primary" onclick="startSimulation()">Simulate Day</button>
                <button class="btn-secondary" onclick="resetSimulation()">Reset</button>
                <div class="stats-grid">
                    <div class="stat-box"><div class="stat-value" id="currentPower">0</div><div class="stat-label">Power (kW)</div></div>
                    <div class="stat-box"><div class="stat-value" id="dailyEnergy">0</div><div class="stat-label">Daily (kWh)</div></div>
                    <div class="stat-box"><div class="stat-value" id="shadingLoss">0%</div><div class="stat-label">Shading Loss</div></div>
                    <div class="stat-box"><div class="stat-value" id="capacityFactor">0%</div><div class="stat-label">Capacity Factor</div></div>
                </div>
                <div class="info-panel">
                    <strong>Model:</strong> Solar geometry with hourly irradiance, inter-row shading, and tracking optimization. Backtracking reduces shading at low sun angles.
                </div>
                <div class="control-group" style="margin-top:15px">
                    <label>Scenarios</label>
                    <button class="scenario-btn btn-secondary" onclick="loadPreset('summer')">Summer Solstice</button>
                    <button class="scenario-btn btn-secondary" onclick="loadPreset('winter')">Winter Solstice</button>
                    <button class="scenario-btn btn-secondary" onclick="loadPreset('equinox')">Equinox</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        function setupCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = (rect.width * 0.6) * dpr;
            canvas.style.height = (rect.width * 0.6) + 'px';
            ctx.scale(dpr, dpr);
            return { width: rect.width, height: rect.width * 0.6 };
        }
        let dims = setupCanvas();
        window.addEventListener('resize', () => { dims = setupCanvas(); draw(); });

        let state = { hour: 6, running: false, powerHistory: [], dailyEnergy: 0 };

        // Solar geometry calculations
        function getSolarDeclination(dayOfYear) {
            return 23.45 * Math.sin(2 * Math.PI * (284 + dayOfYear) / 365) * Math.PI / 180;
        }

        function getSunPosition(hour, latitude, dayOfYear) {
            const latRad = latitude * Math.PI / 180;
            const decl = getSolarDeclination(dayOfYear);
            const hourAngle = (hour - 12) * 15 * Math.PI / 180;

            const altitude = Math.asin(
                Math.sin(latRad) * Math.sin(decl) +
                Math.cos(latRad) * Math.cos(decl) * Math.cos(hourAngle)
            );

            const azimuth = Math.atan2(
                Math.sin(hourAngle),
                Math.cos(hourAngle) * Math.sin(latRad) - Math.tan(decl) * Math.cos(latRad)
            );

            return {
                altitude: altitude * 180 / Math.PI,
                azimuth: azimuth * 180 / Math.PI + 180
            };
        }

        function getIrradiance(altitude) {
            if (altitude <= 0) return 0;
            const AM = 1 / Math.sin(altitude * Math.PI / 180);
            const DNI = 1361 * Math.pow(0.7, Math.pow(AM, 0.678));
            return DNI * Math.sin(altitude * Math.PI / 180);
        }

        function getPanelAngle(tracking, hour, sunAlt, sunAz, fixedTilt, spacing) {
            let tilt = fixedTilt;
            let azimuth = 180; // South facing

            switch (tracking) {
                case 'fixed':
                    break;
                case 'single':
                    // Track east-west
                    tilt = Math.min(60, Math.max(0, 90 - sunAlt));
                    break;
                case 'dual':
                    // Track both axes
                    tilt = 90 - sunAlt;
                    azimuth = sunAz;
                    break;
                case 'backtrack':
                    // Single-axis with backtracking to avoid shading
                    const idealTilt = Math.min(60, Math.max(0, 90 - sunAlt));
                    const shadowLength = Math.tan((90 - sunAlt) * Math.PI / 180);
                    if (shadowLength * Math.sin(idealTilt * Math.PI / 180) > spacing * 0.8) {
                        tilt = idealTilt * 0.6; // Reduce tilt
                    } else {
                        tilt = idealTilt;
                    }
                    break;
            }

            return { tilt, azimuth };
        }

        function calculateShadingLoss(sunAlt, panelTilt, spacing) {
            if (sunAlt <= 5) return 1;
            const panelHeight = 2; // meters
            const shadowLength = panelHeight * Math.sin(panelTilt * Math.PI / 180) / Math.tan(sunAlt * Math.PI / 180);
            const shadedFraction = Math.max(0, (shadowLength - spacing * 0.5) / spacing);
            return Math.min(1, shadedFraction);
        }

        function calculatePower(hour) {
            const latitude = parseInt(document.getElementById('latitude').value);
            const dayOfYear = parseInt(document.getElementById('dayOfYear').value);
            const tracking = document.getElementById('tracking').value;
            const fixedTilt = parseInt(document.getElementById('tilt').value);
            const spacing = parseFloat(document.getElementById('spacing').value);

            const sun = getSunPosition(hour, latitude, dayOfYear);
            if (sun.altitude <= 0) return { power: 0, shading: 0, panelTilt: fixedTilt };

            const panel = getPanelAngle(tracking, hour, sun.altitude, sun.azimuth, fixedTilt, spacing);
            const irradiance = getIrradiance(sun.altitude);

            // Angle of incidence effect
            const cosIncidence = Math.cos((panel.tilt - (90 - sun.altitude)) * Math.PI / 180);
            const effectiveIrradiance = irradiance * Math.max(0, cosIncidence);

            // Shading loss
            const shadingLoss = calculateShadingLoss(sun.altitude, panel.tilt, spacing);

            // Power output (assuming 100m² array, 20% efficiency)
            const arrayArea = 100;
            const efficiency = 0.20;
            const power = effectiveIrradiance * arrayArea * efficiency * (1 - shadingLoss) / 1000;

            return { power: Math.max(0, power), shading: shadingLoss * 100, panelTilt: panel.tilt, sun };
        }

        function update() {
            if (!state.running || state.hour > 20) {
                state.running = false;
                return;
            }

            const result = calculatePower(state.hour);
            state.powerHistory.push(result.power);
            state.dailyEnergy += result.power; // kWh per hour step

            const sun = result.sun;
            const timeStr = `${Math.floor(state.hour)}:${String(Math.round((state.hour % 1) * 60)).padStart(2, '0')}`;
            document.getElementById('sunDisplay').textContent =
                `☀️ ${timeStr} | Altitude: ${sun.altitude.toFixed(0)}° | Azimuth: ${sun.azimuth.toFixed(0)}°`;
            document.getElementById('currentPower').textContent = result.power.toFixed(1);
            document.getElementById('dailyEnergy').textContent = state.dailyEnergy.toFixed(1);
            document.getElementById('shadingLoss').textContent = result.shading.toFixed(0) + '%';

            const peakPower = 20; // kW
            const capacityFactor = state.dailyEnergy / (state.powerHistory.length * peakPower) * 100;
            document.getElementById('capacityFactor').textContent = capacityFactor.toFixed(0) + '%';

            state.hour += 0.5;
            draw();
            setTimeout(update, 100);
        }

        function draw() {
            ctx.clearRect(0, 0, dims.width, dims.height);

            const latitude = parseInt(document.getElementById('latitude').value);
            const dayOfYear = parseInt(document.getElementById('dayOfYear').value);
            const result = calculatePower(state.hour);

            // Sky gradient based on sun altitude
            const skyGrad = ctx.createLinearGradient(0, 0, 0, dims.height * 0.6);
            if (result.sun && result.sun.altitude > 0) {
                const brightness = Math.min(1, result.sun.altitude / 45);
                skyGrad.addColorStop(0, `rgb(${100 + brightness * 35}, ${150 + brightness * 70}, ${200 + brightness * 55})`);
                skyGrad.addColorStop(1, `rgb(${180 + brightness * 50}, ${200 + brightness * 40}, ${220 + brightness * 35})`);
            } else {
                skyGrad.addColorStop(0, '#1a1a2e');
                skyGrad.addColorStop(1, '#16213e');
            }
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, dims.width, dims.height * 0.6);

            // Sun
            if (result.sun && result.sun.altitude > 0) {
                const sunX = dims.width * 0.3 + (result.sun.azimuth - 90) / 180 * dims.width * 0.4;
                const sunY = dims.height * 0.55 - (result.sun.altitude / 90) * dims.height * 0.45;

                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(sunX, sunY, 25, 0, Math.PI * 2);
                ctx.fill();

                // Sun rays
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 12; i++) {
                    const angle = i * Math.PI / 6;
                    ctx.beginPath();
                    ctx.moveTo(sunX + Math.cos(angle) * 30, sunY + Math.sin(angle) * 30);
                    ctx.lineTo(sunX + Math.cos(angle) * 40, sunY + Math.sin(angle) * 40);
                    ctx.stroke();
                }
            }

            // Ground
            ctx.fillStyle = '#8FBC8F';
            ctx.fillRect(0, dims.height * 0.6, dims.width, dims.height * 0.4);

            // Draw solar panel array
            const panelRows = 5;
            const panelCols = 6;
            const spacing = parseFloat(document.getElementById('spacing').value);
            const baseX = dims.width * 0.15;
            const baseY = dims.height * 0.65;
            const panelW = 40;
            const panelH = 20;
            const rowSpacing = spacing * 8;

            for (let row = 0; row < panelRows; row++) {
                for (let col = 0; col < panelCols; col++) {
                    const x = baseX + col * (panelW + 10);
                    const y = baseY + row * rowSpacing;

                    // Panel shadow
                    if (result.sun && result.sun.altitude > 0) {
                        const shadowLen = panelH * 0.8 / Math.tan(result.sun.altitude * Math.PI / 180);
                        ctx.fillStyle = 'rgba(0,0,0,0.2)';
                        ctx.beginPath();
                        ctx.moveTo(x, y + panelH);
                        ctx.lineTo(x + panelW, y + panelH);
                        ctx.lineTo(x + panelW + shadowLen * 0.3, y + panelH + shadowLen * 0.5);
                        ctx.lineTo(x + shadowLen * 0.3, y + panelH + shadowLen * 0.5);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Panel
                    const tiltOffset = result.panelTilt * 0.15;
                    ctx.fillStyle = '#1a237e';
                    ctx.beginPath();
                    ctx.moveTo(x, y + panelH);
                    ctx.lineTo(x + panelW, y + panelH);
                    ctx.lineTo(x + panelW, y + panelH - tiltOffset);
                    ctx.lineTo(x, y + panelH - tiltOffset - 3);
                    ctx.closePath();
                    ctx.fill();

                    // Panel cells
                    ctx.strokeStyle = '#303f9f';
                    for (let c = 1; c < 4; c++) {
                        ctx.beginPath();
                        ctx.moveTo(x + c * panelW / 4, y + panelH);
                        ctx.lineTo(x + c * panelW / 4, y + panelH - tiltOffset - 1);
                        ctx.stroke();
                    }
                }
            }

            // Power chart
            const chartX = dims.width * 0.62;
            const chartY = 40;
            const chartW = dims.width * 0.33;
            const chartH = dims.height * 0.35;

            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(chartX, chartY, chartW, chartH);
            ctx.strokeStyle = '#ddd';
            ctx.strokeRect(chartX, chartY, chartW, chartH);

            ctx.fillStyle = '#606C38';
            ctx.font = '11px Nunito';
            ctx.fillText('Power Output (kW)', chartX + 5, chartY - 5);

            if (state.powerHistory.length > 1) {
                const maxPower = Math.max(...state.powerHistory, 1);
                const step = chartW / 28; // 14 hours * 2 steps

                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.beginPath();
                ctx.moveTo(chartX, chartY + chartH);
                state.powerHistory.forEach((p, i) => {
                    ctx.lineTo(chartX + i * step, chartY + chartH - (p / maxPower) * chartH);
                });
                ctx.lineTo(chartX + (state.powerHistory.length - 1) * step, chartY + chartH);
                ctx.closePath();
                ctx.fill();

                ctx.beginPath();
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                state.powerHistory.forEach((p, i) => {
                    const px = chartX + i * step;
                    const py = chartY + chartH - (p / maxPower) * chartH;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                });
                ctx.stroke();
                ctx.lineWidth = 1;
            }

            // Time axis
            ctx.fillStyle = '#888';
            ctx.font = '9px Nunito';
            ctx.fillText('6am', chartX, chartY + chartH + 12);
            ctx.fillText('12pm', chartX + chartW / 2 - 10, chartY + chartH + 12);
            ctx.fillText('8pm', chartX + chartW - 20, chartY + chartH + 12);

            // Title
            ctx.fillStyle = '#606C38';
            ctx.font = '14px Lora';
            ctx.fillText(`Solar Array Simulation | Day ${parseInt(document.getElementById('dayOfYear').value)} | Lat ${parseInt(document.getElementById('latitude').value)}°N`, 20, 25);
        }

        function startSimulation() {
            state = { hour: 6, running: true, powerHistory: [], dailyEnergy: 0 };
            update();
        }

        function resetSimulation() {
            state = { hour: 6, running: false, powerHistory: [], dailyEnergy: 0 };
            document.getElementById('currentPower').textContent = '0';
            document.getElementById('dailyEnergy').textContent = '0';
            document.getElementById('shadingLoss').textContent = '0%';
            document.getElementById('capacityFactor').textContent = '0%';
            draw();
        }

        function loadPreset(name) {
            if (name === 'summer') {
                document.getElementById('dayOfYear').value = 172;
                document.getElementById('latitude').value = 35;
            } else if (name === 'winter') {
                document.getElementById('dayOfYear').value = 355;
                document.getElementById('latitude').value = 35;
            } else if (name === 'equinox') {
                document.getElementById('dayOfYear').value = 80;
                document.getElementById('latitude').value = 35;
            }
            updateSliderDisplays();
            resetSimulation();
        }

        function updateSliderDisplays() {
            document.getElementById('tiltVal').textContent = document.getElementById('tilt').value;
            document.getElementById('spacingVal').textContent = document.getElementById('spacing').value;
            document.getElementById('latitudeVal').textContent = document.getElementById('latitude').value;
            document.getElementById('dayOfYearVal').textContent = document.getElementById('dayOfYear').value;
        }

        document.querySelectorAll('input[type="range"]').forEach(s => s.addEventListener('input', () => { updateSliderDisplays(); draw(); }));
        draw();
    </script>
</body>
</html>
