<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alarm Calling Evolution - NetLogo Simulation</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            color: var(--dark-moss);
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .subtitle {
            color: var(--moss);
            font-size: 1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: var(--dark-moss);
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            border: 2px solid var(--sage);
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .value-display {
            text-align: right;
            color: var(--moss);
            font-size: 0.85rem;
            margin-top: 4px;
        }

        .buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 80px;
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--sage);
            color: white;
        }

        .btn-primary:hover {
            background: var(--moss);
        }

        .btn-secondary {
            background: var(--earth);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--terracotta);
        }

        .visualization-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 15px;
        }

        .viz-panel {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .viz-panel h3 {
            color: var(--dark-moss);
            font-size: 0.95rem;
            margin-bottom: 10px;
            text-align: center;
        }

        canvas {
            width: 100%;
            height: 250px;
            border-radius: 8px;
            background: #1a1a2e;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 15px;
        }

        .stat-item {
            background: var(--cream);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: var(--terracotta);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--moss);
        }

        .info-box {
            background: linear-gradient(135deg, var(--cream) 0%, #fff 100%);
            border-left: 4px solid var(--sage);
            padding: 15px;
            margin-top: 15px;
            border-radius: 0 8px 8px 0;
            font-size: 0.85rem;
            color: var(--dark-moss);
        }

        .back-link {
            display: inline-block;
            margin-bottom: 15px;
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
        }

        .back-link:hover {
            color: var(--terracotta);
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Simulations</a>

        <header>
            <h1>Alarm Calling Evolution</h1>
            <p class="subtitle">Kin Selection, Reciprocity, and Honest Signaling in Predator-Prey Systems</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-group">
                    <label>Population Size</label>
                    <input type="range" id="popSize" min="20" max="100" value="50">
                    <div class="value-display" id="popSizeVal">50</div>
                </div>

                <div class="control-group">
                    <label>Relatedness (r)</label>
                    <input type="range" id="relatedness" min="0" max="100" value="25" step="5">
                    <div class="value-display" id="relatednessVal">0.25</div>
                </div>

                <div class="control-group">
                    <label>Call Cost (Predator Attraction)</label>
                    <input type="range" id="callCost" min="0" max="50" value="10">
                    <div class="value-display" id="callCostVal">10%</div>
                </div>

                <div class="control-group">
                    <label>Benefit to Kin</label>
                    <input type="range" id="kinBenefit" min="10" max="80" value="40">
                    <div class="value-display" id="kinBenefitVal">40%</div>
                </div>

                <div class="control-group">
                    <label>Predator Attack Rate</label>
                    <input type="range" id="attackRate" min="1" max="20" value="5">
                    <div class="value-display" id="attackRateVal">5/100 ticks</div>
                </div>

                <div class="control-group">
                    <label>Reciprocity Strength</label>
                    <input type="range" id="reciprocity" min="0" max="100" value="30">
                    <div class="value-display" id="reciprocityVal">30%</div>
                </div>

                <div class="control-group">
                    <label>False Alarm Rate</label>
                    <input type="range" id="falseAlarmRate" min="0" max="50" value="5">
                    <div class="value-display" id="falseAlarmRateVal">5%</div>
                </div>

                <div class="control-group">
                    <label>Caller Strategy Evolution</label>
                    <select id="evolutionMode">
                        <option value="genetic">Genetic Inheritance</option>
                        <option value="learning">Individual Learning</option>
                        <option value="cultural">Cultural Transmission</option>
                    </select>
                </div>

                <div class="buttons">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="callerFreq">0%</div>
                        <div class="stat-label">Caller Frequency</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="silentFreq">0%</div>
                        <div class="stat-label">Silent Frequency</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="honestRate">0%</div>
                        <div class="stat-label">Honest Calls</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="avgFitness">0</div>
                        <div class="stat-label">Avg Fitness</div>
                    </div>
                </div>

                <div class="info-box">
                    <strong>The Watchful Babbler Game:</strong> Alarm calls evolve when rB > C (Hamilton's rule).
                    Callers risk attracting predators but benefit kin. Honest signals work when vigilance
                    correlates with escape probability (Bergstrom & Lachmann).
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-panel">
                    <h3>Foraging Arena (Predator Attacks)</h3>
                    <canvas id="arenaCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Strategy Frequency Over Time</h3>
                    <canvas id="frequencyCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Hamilton's Rule Analysis (rB vs C)</h3>
                    <canvas id="hamiltonCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Call Honesty & Manipulation</h3>
                    <canvas id="honestyCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const arenaCanvas = document.getElementById('arenaCanvas');
        const frequencyCanvas = document.getElementById('frequencyCanvas');
        const hamiltonCanvas = document.getElementById('hamiltonCanvas');
        const honestyCanvas = document.getElementById('honestyCanvas');

        const arenaCtx = arenaCanvas.getContext('2d');
        const frequencyCtx = frequencyCanvas.getContext('2d');
        const hamiltonCtx = hamiltonCanvas.getContext('2d');
        const honestyCtx = honestyCanvas.getContext('2d');

        function resizeCanvases() {
            [arenaCanvas, frequencyCanvas, hamiltonCanvas, honestyCanvas].forEach(canvas => {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                canvas.getContext('2d').scale(window.devicePixelRatio, window.devicePixelRatio);
            });
        }
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        // Simulation state
        let running = false;
        let tick = 0;
        let agents = [];
        let predator = null;
        let frequencyHistory = [];
        let honestyHistory = [];
        let hamiltonData = [];

        // Strategy types
        const CALLER = 'caller';
        const SILENT = 'silent';
        const MANIPULATOR = 'manipulator'; // Gives false alarms

        class Agent {
            constructor(x, y, strategy, relatedness = 0) {
                this.x = x;
                this.y = y;
                this.strategy = strategy;
                this.fitness = 100;
                this.kin = []; // Nearby kin
                this.vigilance = Math.random() * 0.5 + 0.3; // Detection probability
                this.calledThisAttack = false;
                this.receivedWarning = false;
                this.reciprocityScore = 0; // Track who warned this agent
                this.alive = true;
                this.age = 0;
                this.falseCaller = strategy === MANIPULATOR;
            }

            update() {
                if (!this.alive) return;

                this.age++;

                // Random movement
                this.x += (Math.random() - 0.5) * 3;
                this.y += (Math.random() - 0.5) * 3;

                // Bounds
                const w = arenaCanvas.width / window.devicePixelRatio;
                const h = arenaCanvas.height / window.devicePixelRatio;
                this.x = Math.max(10, Math.min(w - 10, this.x));
                this.y = Math.max(10, Math.min(h - 10, this.y));

                // Passive fitness gain from foraging
                this.fitness += 0.5;
            }

            detectPredator(predator, detectionBonus = 0) {
                if (!predator) return false;

                const dist = Math.hypot(this.x - predator.x, this.y - predator.y);
                const detectionRange = 150;

                if (dist > detectionRange) return false;

                // Detection probability based on vigilance and distance
                const baseProbability = this.vigilance * (1 - dist / detectionRange);
                return Math.random() < (baseProbability + detectionBonus);
            }

            giveAlarmCall(agents, predator, params) {
                if (!this.alive || this.strategy === SILENT) return { honest: false, given: false };

                const isFalseAlarm = !predator && this.strategy === MANIPULATOR &&
                                     Math.random() < params.falseAlarmRate / 100;

                if (!predator && !isFalseAlarm) return { honest: false, given: false };

                this.calledThisAttack = true;

                // Cost: attract predator attention
                if (predator && Math.random() < params.callCost / 100) {
                    predator.targetCaller = this;
                }

                // Benefit: warn nearby agents (especially kin)
                agents.forEach(other => {
                    if (other === this || !other.alive) return;

                    const dist = Math.hypot(this.x - other.x, this.y - other.y);
                    if (dist < 100) {
                        const isKin = this.kin.includes(other);
                        const benefitChance = isKin ?
                            params.kinBenefit / 100 :
                            (params.kinBenefit / 100) * (params.reciprocity / 100);

                        if (Math.random() < benefitChance) {
                            other.receivedWarning = true;
                            other.reciprocityScore += isKin ? 0.5 : 1;
                        }
                    }
                });

                return { honest: !!predator, given: true };
            }
        }

        class Predator {
            constructor() {
                const side = Math.floor(Math.random() * 4);
                const w = arenaCanvas.width / window.devicePixelRatio;
                const h = arenaCanvas.height / window.devicePixelRatio;

                switch(side) {
                    case 0: this.x = 0; this.y = Math.random() * h; break;
                    case 1: this.x = w; this.y = Math.random() * h; break;
                    case 2: this.x = Math.random() * w; this.y = 0; break;
                    case 3: this.x = Math.random() * w; this.y = h; break;
                }

                this.targetX = w / 2 + (Math.random() - 0.5) * 100;
                this.targetY = h / 2 + (Math.random() - 0.5) * 100;
                this.speed = 2;
                this.targetCaller = null;
                this.attackTimer = 0;
            }

            update(agents) {
                // Move toward target (or caller if attracted)
                const targetX = this.targetCaller ? this.targetCaller.x : this.targetX;
                const targetY = this.targetCaller ? this.targetCaller.y : this.targetY;

                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const dist = Math.hypot(dx, dy);

                if (dist > 5) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }

                this.attackTimer++;

                // Attack nearby prey
                if (this.attackTimer > 30) {
                    const victim = this.findVictim(agents);
                    if (victim) {
                        // Warned agents have higher escape chance
                        const escapeChance = victim.receivedWarning ? 0.7 : 0.3;
                        if (Math.random() > escapeChance) {
                            victim.alive = false;
                            return true; // Successful kill
                        }
                    }
                }

                return false;
            }

            findVictim(agents) {
                let closest = null;
                let minDist = 30;

                agents.forEach(agent => {
                    if (!agent.alive) return;
                    const dist = Math.hypot(this.x - agent.x, this.y - agent.y);
                    if (dist < minDist) {
                        minDist = dist;
                        closest = agent;
                    }
                });

                return closest;
            }
        }

        function initSimulation() {
            const popSize = parseInt(document.getElementById('popSize').value);
            const relatedness = parseInt(document.getElementById('relatedness').value) / 100;

            agents = [];
            predator = null;
            tick = 0;
            frequencyHistory = [];
            honestyHistory = [];
            hamiltonData = [];

            const w = arenaCanvas.width / window.devicePixelRatio;
            const h = arenaCanvas.height / window.devicePixelRatio;

            // Create agents with mixed strategies
            for (let i = 0; i < popSize; i++) {
                const x = Math.random() * (w - 40) + 20;
                const y = Math.random() * (h - 40) + 20;

                // Initial strategy distribution: 40% callers, 50% silent, 10% manipulators
                let strategy;
                const roll = Math.random();
                if (roll < 0.4) strategy = CALLER;
                else if (roll < 0.9) strategy = SILENT;
                else strategy = MANIPULATOR;

                agents.push(new Agent(x, y, strategy));
            }

            // Establish kin relationships based on relatedness
            agents.forEach(agent => {
                agents.forEach(other => {
                    if (agent !== other && Math.random() < relatedness) {
                        agent.kin.push(other);
                    }
                });
            });
        }

        function getParams() {
            return {
                callCost: parseInt(document.getElementById('callCost').value),
                kinBenefit: parseInt(document.getElementById('kinBenefit').value),
                attackRate: parseInt(document.getElementById('attackRate').value),
                reciprocity: parseInt(document.getElementById('reciprocity').value),
                falseAlarmRate: parseInt(document.getElementById('falseAlarmRate').value),
                relatedness: parseInt(document.getElementById('relatedness').value) / 100,
                evolutionMode: document.getElementById('evolutionMode').value
            };
        }

        function simulationStep() {
            const params = getParams();
            tick++;

            // Update agents
            agents.forEach(agent => agent.update());

            // Spawn predator based on attack rate
            if (!predator && Math.random() < params.attackRate / 1000) {
                predator = new Predator();

                // Reset warning states
                agents.forEach(a => {
                    a.calledThisAttack = false;
                    a.receivedWarning = false;
                });
            }

            // Agents detect predator and potentially give alarm calls
            let honestCalls = 0;
            let totalCalls = 0;

            if (predator) {
                agents.forEach(agent => {
                    if (agent.alive && agent.detectPredator(predator)) {
                        const result = agent.giveAlarmCall(agents, predator, params);
                        if (result.given) {
                            totalCalls++;
                            if (result.honest) honestCalls++;
                        }
                    }
                });

                // False alarm attempts (manipulators)
                agents.filter(a => a.alive && a.strategy === MANIPULATOR).forEach(agent => {
                    if (Math.random() < params.falseAlarmRate / 500) {
                        agent.giveAlarmCall(agents, null, params);
                        totalCalls++;
                    }
                });
            }

            // Predator behavior
            if (predator) {
                const killed = predator.update(agents);

                // Predator leaves after time or kill
                if (killed || predator.attackTimer > 100) {
                    predator = null;
                }
            }

            // Record honesty
            if (totalCalls > 0) {
                honestyHistory.push(honestCalls / totalCalls);
                if (honestyHistory.length > 200) honestyHistory.shift();
            }

            // Evolution/reproduction
            if (tick % 50 === 0) {
                evolvePopulation(params);
            }

            // Record frequency history
            if (tick % 5 === 0) {
                const alive = agents.filter(a => a.alive);
                const callers = alive.filter(a => a.strategy === CALLER).length;
                const silent = alive.filter(a => a.strategy === SILENT).length;
                const manipulators = alive.filter(a => a.strategy === MANIPULATOR).length;
                const total = alive.length || 1;

                frequencyHistory.push({
                    caller: callers / total,
                    silent: silent / total,
                    manipulator: manipulators / total
                });
                if (frequencyHistory.length > 200) frequencyHistory.shift();

                // Hamilton's rule data
                const r = params.relatedness;
                const B = params.kinBenefit / 100;
                const C = params.callCost / 100;
                hamiltonData.push({
                    rB: r * B,
                    C: C,
                    callerFreq: callers / total
                });
                if (hamiltonData.length > 100) hamiltonData.shift();
            }

            updateStats();
        }

        function evolvePopulation(params) {
            const alive = agents.filter(a => a.alive);
            if (alive.length < 10) {
                // Repopulate
                const popSize = parseInt(document.getElementById('popSize').value);
                while (agents.filter(a => a.alive).length < popSize) {
                    const parent = alive[Math.floor(Math.random() * alive.length)];
                    if (parent) {
                        const w = arenaCanvas.width / window.devicePixelRatio;
                        const h = arenaCanvas.height / window.devicePixelRatio;

                        let newStrategy = parent.strategy;

                        // Mutation
                        if (Math.random() < 0.05) {
                            const strategies = [CALLER, SILENT, MANIPULATOR];
                            newStrategy = strategies[Math.floor(Math.random() * strategies.length)];
                        }

                        const child = new Agent(
                            Math.random() * (w - 40) + 20,
                            Math.random() * (h - 40) + 20,
                            newStrategy
                        );
                        child.kin = [...parent.kin].filter(k => k.alive);
                        agents.push(child);
                    }
                }
            }

            // Fitness-based reproduction
            alive.sort((a, b) => b.fitness - a.fitness);
            const top = alive.slice(0, Math.floor(alive.length * 0.3));

            top.forEach(parent => {
                if (Math.random() < 0.3 && agents.filter(a => a.alive).length < 150) {
                    const w = arenaCanvas.width / window.devicePixelRatio;
                    const h = arenaCanvas.height / window.devicePixelRatio;

                    let newStrategy = parent.strategy;

                    if (params.evolutionMode === 'learning') {
                        // Individual learning: may switch based on own experience
                        if (parent.reciprocityScore > 3 && parent.strategy === SILENT) {
                            newStrategy = CALLER;
                        }
                    } else if (params.evolutionMode === 'cultural') {
                        // Copy most successful nearby strategy
                        const nearby = alive.filter(a =>
                            Math.hypot(a.x - parent.x, a.y - parent.y) < 50
                        );
                        if (nearby.length > 0) {
                            nearby.sort((a, b) => b.fitness - a.fitness);
                            newStrategy = nearby[0].strategy;
                        }
                    }

                    // Mutation
                    if (Math.random() < 0.03) {
                        const strategies = [CALLER, SILENT, MANIPULATOR];
                        newStrategy = strategies[Math.floor(Math.random() * strategies.length)];
                    }

                    const child = new Agent(
                        parent.x + (Math.random() - 0.5) * 30,
                        parent.y + (Math.random() - 0.5) * 30,
                        newStrategy
                    );
                    child.kin.push(parent);
                    parent.kin.push(child);
                    agents.push(child);
                }
            });

            // Remove old dead agents
            agents = agents.filter(a => a.alive || a.age < 100);
        }

        function updateStats() {
            const alive = agents.filter(a => a.alive);
            const total = alive.length || 1;

            const callers = alive.filter(a => a.strategy === CALLER).length;
            const silent = alive.filter(a => a.strategy === SILENT).length;

            document.getElementById('callerFreq').textContent =
                Math.round(callers / total * 100) + '%';
            document.getElementById('silentFreq').textContent =
                Math.round(silent / total * 100) + '%';

            const avgHonesty = honestyHistory.length > 0 ?
                honestyHistory.slice(-20).reduce((a, b) => a + b, 0) /
                Math.min(20, honestyHistory.length) : 1;
            document.getElementById('honestRate').textContent =
                Math.round(avgHonesty * 100) + '%';

            const avgFitness = alive.reduce((sum, a) => sum + a.fitness, 0) / total;
            document.getElementById('avgFitness').textContent = avgFitness.toFixed(0);
        }

        function draw() {
            const w = arenaCanvas.width / window.devicePixelRatio;
            const h = arenaCanvas.height / window.devicePixelRatio;

            // Arena
            arenaCtx.fillStyle = '#1a1a2e';
            arenaCtx.fillRect(0, 0, w, h);

            // Draw kin connections
            arenaCtx.strokeStyle = 'rgba(100, 150, 100, 0.2)';
            arenaCtx.lineWidth = 1;
            agents.filter(a => a.alive).forEach(agent => {
                agent.kin.filter(k => k.alive).forEach(kin => {
                    arenaCtx.beginPath();
                    arenaCtx.moveTo(agent.x, agent.y);
                    arenaCtx.lineTo(kin.x, kin.y);
                    arenaCtx.stroke();
                });
            });

            // Draw agents
            agents.filter(a => a.alive).forEach(agent => {
                // Color by strategy
                if (agent.strategy === CALLER) {
                    arenaCtx.fillStyle = agent.calledThisAttack ? '#ffff00' : '#4CAF50';
                } else if (agent.strategy === SILENT) {
                    arenaCtx.fillStyle = '#607D8B';
                } else {
                    arenaCtx.fillStyle = '#FF5722'; // Manipulator
                }

                // Warned agents get a glow
                if (agent.receivedWarning) {
                    arenaCtx.shadowColor = '#00ff00';
                    arenaCtx.shadowBlur = 10;
                }

                arenaCtx.beginPath();
                arenaCtx.arc(agent.x, agent.y, 6, 0, Math.PI * 2);
                arenaCtx.fill();

                arenaCtx.shadowBlur = 0;
            });

            // Draw predator
            if (predator) {
                arenaCtx.fillStyle = '#ff0000';
                arenaCtx.beginPath();
                arenaCtx.moveTo(predator.x, predator.y - 12);
                arenaCtx.lineTo(predator.x - 8, predator.y + 8);
                arenaCtx.lineTo(predator.x + 8, predator.y + 8);
                arenaCtx.closePath();
                arenaCtx.fill();

                // Attack radius
                arenaCtx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
                arenaCtx.beginPath();
                arenaCtx.arc(predator.x, predator.y, 30, 0, Math.PI * 2);
                arenaCtx.stroke();
            }

            // Legend
            arenaCtx.font = '11px sans-serif';
            arenaCtx.fillStyle = '#4CAF50';
            arenaCtx.fillRect(10, h - 50, 10, 10);
            arenaCtx.fillStyle = '#fff';
            arenaCtx.fillText('Caller', 25, h - 42);

            arenaCtx.fillStyle = '#607D8B';
            arenaCtx.fillRect(70, h - 50, 10, 10);
            arenaCtx.fillStyle = '#fff';
            arenaCtx.fillText('Silent', 85, h - 42);

            arenaCtx.fillStyle = '#FF5722';
            arenaCtx.fillRect(130, h - 50, 10, 10);
            arenaCtx.fillStyle = '#fff';
            arenaCtx.fillText('Manipulator', 145, h - 42);

            arenaCtx.fillStyle = '#ff0000';
            arenaCtx.fillText('▲ Predator', 10, h - 25);

            // Frequency plot
            drawFrequencyPlot();

            // Hamilton's rule plot
            drawHamiltonPlot();

            // Honesty plot
            drawHonestyPlot();
        }

        function drawFrequencyPlot() {
            const w = frequencyCanvas.width / window.devicePixelRatio;
            const h = frequencyCanvas.height / window.devicePixelRatio;

            frequencyCtx.fillStyle = '#1a1a2e';
            frequencyCtx.fillRect(0, 0, w, h);

            if (frequencyHistory.length < 2) return;

            const padding = 40;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Axes
            frequencyCtx.strokeStyle = '#666';
            frequencyCtx.beginPath();
            frequencyCtx.moveTo(padding, padding);
            frequencyCtx.lineTo(padding, h - padding);
            frequencyCtx.lineTo(w - padding, h - padding);
            frequencyCtx.stroke();

            // Labels
            frequencyCtx.fillStyle = '#aaa';
            frequencyCtx.font = '10px sans-serif';
            frequencyCtx.fillText('100%', 5, padding + 5);
            frequencyCtx.fillText('0%', 15, h - padding);
            frequencyCtx.fillText('Time', w / 2, h - 5);

            // Draw lines
            const drawLine = (data, color) => {
                frequencyCtx.strokeStyle = color;
                frequencyCtx.lineWidth = 2;
                frequencyCtx.beginPath();

                data.forEach((d, i) => {
                    const x = padding + (i / (data.length - 1)) * plotW;
                    const y = h - padding - d * plotH;

                    if (i === 0) frequencyCtx.moveTo(x, y);
                    else frequencyCtx.lineTo(x, y);
                });

                frequencyCtx.stroke();
            };

            drawLine(frequencyHistory.map(d => d.caller), '#4CAF50');
            drawLine(frequencyHistory.map(d => d.silent), '#607D8B');
            drawLine(frequencyHistory.map(d => d.manipulator), '#FF5722');

            // Legend
            frequencyCtx.font = '10px sans-serif';
            frequencyCtx.fillStyle = '#4CAF50';
            frequencyCtx.fillText('● Caller', w - 100, 20);
            frequencyCtx.fillStyle = '#607D8B';
            frequencyCtx.fillText('● Silent', w - 100, 35);
            frequencyCtx.fillStyle = '#FF5722';
            frequencyCtx.fillText('● Manipulator', w - 100, 50);
        }

        function drawHamiltonPlot() {
            const w = hamiltonCanvas.width / window.devicePixelRatio;
            const h = hamiltonCanvas.height / window.devicePixelRatio;

            hamiltonCtx.fillStyle = '#1a1a2e';
            hamiltonCtx.fillRect(0, 0, w, h);

            const padding = 45;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Axes
            hamiltonCtx.strokeStyle = '#666';
            hamiltonCtx.beginPath();
            hamiltonCtx.moveTo(padding, padding);
            hamiltonCtx.lineTo(padding, h - padding);
            hamiltonCtx.lineTo(w - padding, h - padding);
            hamiltonCtx.stroke();

            // Labels
            hamiltonCtx.fillStyle = '#aaa';
            hamiltonCtx.font = '10px sans-serif';
            hamiltonCtx.fillText('rB', 5, h / 2);
            hamiltonCtx.fillText('C (Cost)', w / 2, h - 5);

            // Draw Hamilton's rule threshold line (rB = C)
            hamiltonCtx.strokeStyle = '#ffff00';
            hamiltonCtx.setLineDash([5, 5]);
            hamiltonCtx.beginPath();
            hamiltonCtx.moveTo(padding, h - padding);
            hamiltonCtx.lineTo(w - padding, padding);
            hamiltonCtx.stroke();
            hamiltonCtx.setLineDash([]);

            hamiltonCtx.fillStyle = '#ffff00';
            hamiltonCtx.font = '9px sans-serif';
            hamiltonCtx.fillText('rB = C (threshold)', w - 90, padding + 15);

            // Current parameters point
            if (hamiltonData.length > 0) {
                const current = hamiltonData[hamiltonData.length - 1];
                const x = padding + current.C * plotW;
                const y = h - padding - current.rB * plotH;

                hamiltonCtx.fillStyle = current.rB > current.C ? '#4CAF50' : '#f44336';
                hamiltonCtx.beginPath();
                hamiltonCtx.arc(x, y, 8, 0, Math.PI * 2);
                hamiltonCtx.fill();

                hamiltonCtx.fillStyle = '#fff';
                hamiltonCtx.font = '10px sans-serif';
                hamiltonCtx.fillText(
                    current.rB > current.C ? 'Altruism favored' : 'Selfishness favored',
                    padding + 5, padding + 15
                );
            }

            // Zone labels
            hamiltonCtx.fillStyle = 'rgba(76, 175, 80, 0.3)';
            hamiltonCtx.beginPath();
            hamiltonCtx.moveTo(padding, h - padding);
            hamiltonCtx.lineTo(padding, padding);
            hamiltonCtx.lineTo(w - padding, padding);
            hamiltonCtx.closePath();
            hamiltonCtx.fill();

            hamiltonCtx.fillStyle = 'rgba(244, 67, 54, 0.2)';
            hamiltonCtx.beginPath();
            hamiltonCtx.moveTo(padding, h - padding);
            hamiltonCtx.lineTo(w - padding, h - padding);
            hamiltonCtx.lineTo(w - padding, padding);
            hamiltonCtx.closePath();
            hamiltonCtx.fill();
        }

        function drawHonestyPlot() {
            const w = honestyCanvas.width / window.devicePixelRatio;
            const h = honestyCanvas.height / window.devicePixelRatio;

            honestyCtx.fillStyle = '#1a1a2e';
            honestyCtx.fillRect(0, 0, w, h);

            if (honestyHistory.length < 2) {
                honestyCtx.fillStyle = '#666';
                honestyCtx.font = '12px sans-serif';
                honestyCtx.fillText('Waiting for alarm calls...', w / 2 - 70, h / 2);
                return;
            }

            const padding = 40;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Axes
            honestyCtx.strokeStyle = '#666';
            honestyCtx.beginPath();
            honestyCtx.moveTo(padding, padding);
            honestyCtx.lineTo(padding, h - padding);
            honestyCtx.lineTo(w - padding, h - padding);
            honestyCtx.stroke();

            // Labels
            honestyCtx.fillStyle = '#aaa';
            honestyCtx.font = '10px sans-serif';
            honestyCtx.fillText('100%', 5, padding + 5);
            honestyCtx.fillText('0%', 15, h - padding);
            honestyCtx.fillText('Honest', 5, h / 2 - 20);
            honestyCtx.fillText('Calls', 10, h / 2 - 5);

            // Draw honesty line
            honestyCtx.strokeStyle = '#00BCD4';
            honestyCtx.lineWidth = 2;
            honestyCtx.beginPath();

            honestyHistory.forEach((h_val, i) => {
                const x = padding + (i / (honestyHistory.length - 1)) * plotW;
                const y = h - padding - h_val * plotH;

                if (i === 0) honestyCtx.moveTo(x, y);
                else honestyCtx.lineTo(x, y);
            });

            honestyCtx.stroke();

            // Average line
            const avgHonesty = honestyHistory.reduce((a, b) => a + b, 0) / honestyHistory.length;
            honestyCtx.strokeStyle = '#ff9800';
            honestyCtx.setLineDash([5, 5]);
            honestyCtx.beginPath();
            honestyCtx.moveTo(padding, h - padding - avgHonesty * plotH);
            honestyCtx.lineTo(w - padding, h - padding - avgHonesty * plotH);
            honestyCtx.stroke();
            honestyCtx.setLineDash([]);

            honestyCtx.fillStyle = '#ff9800';
            honestyCtx.fillText(`Avg: ${Math.round(avgHonesty * 100)}%`, w - 70, h - padding - avgHonesty * plotH - 5);
        }

        function animate() {
            if (running) {
                simulationStep();
            }
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            initSimulation();
        });

        // Slider value displays
        const sliders = [
            ['popSize', 'popSizeVal', v => v],
            ['relatedness', 'relatednessVal', v => (v / 100).toFixed(2)],
            ['callCost', 'callCostVal', v => v + '%'],
            ['kinBenefit', 'kinBenefitVal', v => v + '%'],
            ['attackRate', 'attackRateVal', v => v + '/100 ticks'],
            ['reciprocity', 'reciprocityVal', v => v + '%'],
            ['falseAlarmRate', 'falseAlarmRateVal', v => v + '%']
        ];

        sliders.forEach(([id, displayId, formatter]) => {
            const input = document.getElementById(id);
            const display = document.getElementById(displayId);
            input.addEventListener('input', () => {
                display.textContent = formatter(parseInt(input.value));
            });
        });

        // Initialize
        initSimulation();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
