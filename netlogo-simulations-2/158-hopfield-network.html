<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hopfield Network - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 300px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #ec4899; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #ec4899; color: #fff; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { opacity: 0.9; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; margin-bottom: 10px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #ec4899; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .info { background: rgba(236,72,153,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; border-left: 3px solid #ec4899; }
        .patterns { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; }
        .pattern-btn { padding: 5px 10px; background: #444; border: none; color: #fff; border-radius: 3px; cursor: pointer; font-size: 0.7rem; }
        .pattern-btn:hover { background: #555; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <div id="canvas-container"><canvas id="canvas"></canvas></div>
        <div id="controls">
            <h1>Hopfield Network</h1>
            <div class="control-group">
                <label>Noise Level: <span id="noiseValue">30</span>%</label>
                <input type="range" id="noise" min="0" max="70" step="5" value="30">
            </div>
            <div class="control-group">
                <label>Update Mode:</label>
                <select id="mode" style="width:100%; padding:8px; background:#333; color:#fff; border:none; border-radius:5px;">
                    <option value="async">Asynchronous</option>
                    <option value="sync">Synchronous</option>
                </select>
            </div>
            <button id="store">Store Current as Pattern</button>
            <button id="corrupt">Add Noise to Current</button>
            <button id="recall">Recall (Run Network)</button>
            <button id="clear">Clear Network</button>
            <div class="stats">
                <div>Stored Patterns: <span id="numPatterns">0</span></div>
                <div>Network Size: <span id="netSize">64</span> neurons</div>
                <div>Energy: <span id="energy">-</span></div>
                <div>Stable: <span id="stable">-</span></div>
            </div>
            <div class="info">
                <strong>Hopfield Associative Memory</strong><br><br>
                • Click cells to toggle<br>
                • Store multiple patterns<br>
                • Add noise, then recall<br>
                • Network converges to nearest stored pattern<br><br>
                <strong>Load Pattern:</strong>
                <div class="patterns">
                    <button class="pattern-btn" data-pattern="A">A</button>
                    <button class="pattern-btn" data-pattern="B">B</button>
                    <button class="pattern-btn" data-pattern="X">X</button>
                    <button class="pattern-btn" data-pattern="O">O</button>
                    <button class="pattern-btn" data-pattern="T">T</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        const SIZE = 8; // 8x8 grid
        const N = SIZE * SIZE;
        
        let params = { noise: 30, mode: 'async' };
        let state = new Array(N).fill(-1);
        let weights = Array(N).fill(0).map(() => Array(N).fill(0));
        let storedPatterns = [];
        let isStable = false;
        let running = false;
        
        // Predefined letter patterns (8x8)
        const PATTERNS = {
            'A': [
                0,0,1,1,1,1,0,0,
                0,1,1,0,0,1,1,0,
                1,1,0,0,0,0,1,1,
                1,1,0,0,0,0,1,1,
                1,1,1,1,1,1,1,1,
                1,1,0,0,0,0,1,1,
                1,1,0,0,0,0,1,1,
                1,1,0,0,0,0,1,1
            ],
            'B': [
                1,1,1,1,1,1,0,0,
                1,1,0,0,0,1,1,0,
                1,1,0,0,0,1,1,0,
                1,1,1,1,1,1,0,0,
                1,1,0,0,0,1,1,0,
                1,1,0,0,0,0,1,1,
                1,1,0,0,0,1,1,0,
                1,1,1,1,1,1,0,0
            ],
            'X': [
                1,1,0,0,0,0,1,1,
                0,1,1,0,0,1,1,0,
                0,0,1,1,1,1,0,0,
                0,0,0,1,1,0,0,0,
                0,0,0,1,1,0,0,0,
                0,0,1,1,1,1,0,0,
                0,1,1,0,0,1,1,0,
                1,1,0,0,0,0,1,1
            ],
            'O': [
                0,0,1,1,1,1,0,0,
                0,1,1,0,0,1,1,0,
                1,1,0,0,0,0,1,1,
                1,1,0,0,0,0,1,1,
                1,1,0,0,0,0,1,1,
                1,1,0,0,0,0,1,1,
                0,1,1,0,0,1,1,0,
                0,0,1,1,1,1,0,0
            ],
            'T': [
                1,1,1,1,1,1,1,1,
                1,1,1,1,1,1,1,1,
                0,0,0,1,1,0,0,0,
                0,0,0,1,1,0,0,0,
                0,0,0,1,1,0,0,0,
                0,0,0,1,1,0,0,0,
                0,0,0,1,1,0,0,0,
                0,0,0,1,1,0,0,0
            ]
        };

        function resize() {
            canvas.width = document.getElementById('canvas-container').clientWidth;
            canvas.height = document.getElementById('canvas-container').clientHeight;
        }

        function loadPattern(name) {
            const pattern = PATTERNS[name];
            if (pattern) {
                state = pattern.map(v => v === 1 ? 1 : -1);
            }
        }

        function storePattern() {
            const pattern = [...state];
            storedPatterns.push(pattern);
            
            // Hebbian learning: update weights
            for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                    if (i !== j) {
                        weights[i][j] += pattern[i] * pattern[j] / N;
                    }
                }
            }
            
            document.getElementById('numPatterns').textContent = storedPatterns.length;
        }

        function addNoise() {
            const noiseLevel = params.noise / 100;
            for (let i = 0; i < N; i++) {
                if (Math.random() < noiseLevel) {
                    state[i] *= -1;
                }
            }
        }

        function calculateEnergy() {
            let energy = 0;
            for (let i = 0; i < N; i++) {
                for (let j = i + 1; j < N; j++) {
                    energy -= weights[i][j] * state[i] * state[j];
                }
            }
            return energy;
        }

        function updateNeuron(i) {
            let sum = 0;
            for (let j = 0; j < N; j++) {
                if (i !== j) {
                    sum += weights[i][j] * state[j];
                }
            }
            return sum >= 0 ? 1 : -1;
        }

        function asyncUpdate() {
            let changed = false;
            const order = [...Array(N).keys()].sort(() => Math.random() - 0.5);
            
            for (const i of order) {
                const newState = updateNeuron(i);
                if (newState !== state[i]) {
                    state[i] = newState;
                    changed = true;
                }
            }
            
            return !changed;
        }

        function syncUpdate() {
            const newState = state.map((_, i) => updateNeuron(i));
            let changed = false;
            
            for (let i = 0; i < N; i++) {
                if (newState[i] !== state[i]) changed = true;
            }
            
            state = newState;
            return !changed;
        }

        function recall() {
            running = true;
            isStable = false;
            
            function step() {
                if (!running) return;
                
                const stable = params.mode === 'async' ? asyncUpdate() : syncUpdate();
                
                document.getElementById('energy').textContent = calculateEnergy().toFixed(2);
                document.getElementById('stable').textContent = stable ? 'Yes!' : 'No';
                
                if (stable) {
                    running = false;
                    isStable = true;
                } else {
                    setTimeout(step, 100);
                }
            }
            
            step();
        }

        function clearNetwork() {
            state = new Array(N).fill(-1);
            weights = Array(N).fill(0).map(() => Array(N).fill(0));
            storedPatterns = [];
            document.getElementById('numPatterns').textContent = 0;
            document.getElementById('energy').textContent = '-';
            document.getElementById('stable').textContent = '-';
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const gridWidth = Math.min(canvas.width - 400, canvas.height - 100, 400);
            const cellSize = gridWidth / SIZE;
            const startX = (canvas.width - 300 - gridWidth) / 2;
            const startY = (canvas.height - gridWidth) / 2;
            
            // Draw current state
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    const i = r * SIZE + c;
                    const x = startX + c * cellSize;
                    const y = startY + r * cellSize;
                    
                    ctx.fillStyle = state[i] === 1 ? '#ec4899' : '#2a2a4e';
                    ctx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2);
                    
                    ctx.strokeStyle = '#444';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, cellSize, cellSize);
                }
            }
            
            // Draw stored patterns (small thumbnails)
            if (storedPatterns.length > 0) {
                ctx.fillStyle = '#888';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('Stored Patterns:', startX, startY + gridWidth + 30);
                
                const thumbSize = 40;
                const thumbCellSize = thumbSize / SIZE;
                
                storedPatterns.forEach((pattern, p) => {
                    const tx = startX + p * (thumbSize + 10);
                    const ty = startY + gridWidth + 45;
                    
                    for (let r = 0; r < SIZE; r++) {
                        for (let c = 0; c < SIZE; c++) {
                            const i = r * SIZE + c;
                            const x = tx + c * thumbCellSize;
                            const y = ty + r * thumbCellSize;
                            
                            ctx.fillStyle = pattern[i] === 1 ? '#ec4899' : '#2a2a4e';
                            ctx.fillRect(x, y, thumbCellSize, thumbCellSize);
                        }
                    }
                    
                    ctx.strokeStyle = '#666';
                    ctx.strokeRect(tx, ty, thumbSize, thumbSize);
                });
            }
            
            // Title
            ctx.fillStyle = '#ec4899';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Current Network State', startX + gridWidth / 2, startY - 15);
        }

        function handleClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const gridWidth = Math.min(canvas.width - 400, canvas.height - 100, 400);
            const cellSize = gridWidth / SIZE;
            const startX = (canvas.width - 300 - gridWidth) / 2;
            const startY = (canvas.height - gridWidth) / 2;
            
            const col = Math.floor((x - startX) / cellSize);
            const row = Math.floor((y - startY) / cellSize);
            
            if (row >= 0 && row < SIZE && col >= 0 && col < SIZE) {
                const i = row * SIZE + col;
                state[i] *= -1;
            }
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        document.getElementById('noise').addEventListener('input', e => {
            params.noise = parseInt(e.target.value);
            document.getElementById('noiseValue').textContent = params.noise;
        });

        document.getElementById('mode').addEventListener('change', e => {
            params.mode = e.target.value;
        });

        document.getElementById('store').addEventListener('click', storePattern);
        document.getElementById('corrupt').addEventListener('click', addNoise);
        document.getElementById('recall').addEventListener('click', recall);
        document.getElementById('clear').addEventListener('click', clearNetwork);

        document.querySelectorAll('.pattern-btn').forEach(btn => {
            btn.addEventListener('click', () => loadPattern(btn.dataset.pattern));
        });

        canvas.addEventListener('click', handleClick);
        window.addEventListener('resize', resize);

        resize();
        requestAnimationFrame(animate);
    </script>
</body>
</html>
