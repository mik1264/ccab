<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimal Foraging - Marginal Value Theorem</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        .back-link {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: var(--terracotta);
        }

        h1 {
            color: var(--dark-moss);
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .subtitle {
            color: var(--moss);
            font-size: 1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: var(--moss);
            font-size: 0.95em;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid var(--sage);
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            color: var(--dark-moss);
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group .value {
            text-align: right;
            font-size: 0.8em;
            color: var(--moss);
        }

        .control-group select {
            width: 100%;
            padding: 6px;
            border: 1px solid var(--sage);
            border-radius: 6px;
            font-size: 0.9em;
        }

        .button-group {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.3s;
        }

        .btn-primary {
            background: var(--sage);
            color: white;
        }

        .btn-primary:hover {
            background: var(--moss);
        }

        .btn-secondary {
            background: var(--earth);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--terracotta);
        }

        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .viz-panel {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .viz-panel h3 {
            color: var(--moss);
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        canvas {
            width: 100%;
            border-radius: 8px;
            background: #1a1a2e;
        }

        .viz-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .stat-box {
            background: linear-gradient(135deg, var(--cream) 0%, white 100%);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            border-left: 3px solid var(--sage);
        }

        .stat-box.highlight {
            border-left-color: var(--terracotta);
        }

        .stat-box.success {
            border-left-color: #4CAF50;
        }

        .stat-box .label {
            font-size: 0.75em;
            color: var(--moss);
            margin-bottom: 4px;
        }

        .stat-box .value {
            font-size: 1.2em;
            font-weight: bold;
            color: var(--dark-moss);
        }

        .info-box {
            background: linear-gradient(135deg, #e3f2fd 0%, white 100%);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            font-size: 0.8em;
            color: var(--dark-moss);
        }

        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
            font-size: 0.8em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .mvt-equation {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 8px;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            text-align: center;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">← Back to Simulations</a>
            <h1>Optimal Foraging</h1>
            <p class="subtitle">The Marginal Value Theorem (Charnov 1976)</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-section">
                    <h3>Environment</h3>
                    <div class="control-group">
                        <label>Number of Patches: <span id="numPatchesVal">5</span></label>
                        <input type="range" id="numPatches" min="2" max="12" value="5">
                    </div>
                    <div class="control-group">
                        <label>Patch Quality Variation: <span id="qualityVarVal">0.30</span></label>
                        <input type="range" id="qualityVar" min="0" max="80" value="30">
                        <div class="value">heterogeneity</div>
                    </div>
                    <div class="control-group">
                        <label>Mean Travel Time: <span id="travelTimeVal">10</span></label>
                        <input type="range" id="travelTime" min="2" max="50" value="10">
                        <div class="value">time units between patches</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Patch Dynamics</h3>
                    <div class="control-group">
                        <label>Initial Patch Value: <span id="initValueVal">100</span></label>
                        <input type="range" id="initValue" min="20" max="200" value="100" step="10">
                    </div>
                    <div class="control-group">
                        <label>Depletion Rate (λ): <span id="depletionVal">0.05</span></label>
                        <input type="range" id="depletion" min="1" max="20" value="5">
                        <div class="value">exponential decay</div>
                    </div>
                    <div class="control-group">
                        <label>Patch Type:</label>
                        <select id="patchType">
                            <option value="exponential">Exponential Depletion</option>
                            <option value="linear">Linear Depletion</option>
                            <option value="stepwise">Stepwise Depletion</option>
                        </select>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Forager Strategy</h3>
                    <div class="control-group">
                        <label>Strategy:</label>
                        <select id="strategy">
                            <option value="mvt">MVT Optimal</option>
                            <option value="fixed">Fixed Time</option>
                            <option value="threshold">Giving-Up Threshold</option>
                            <option value="random">Random</option>
                        </select>
                    </div>
                    <div class="control-group" id="fixedTimeGroup">
                        <label>Fixed Residence Time: <span id="fixedTimeVal">15</span></label>
                        <input type="range" id="fixedTime" min="5" max="50" value="15">
                    </div>
                    <div class="control-group" id="thresholdGroup" style="display:none;">
                        <label>Giving-Up Threshold: <span id="thresholdVal">2.0</span></label>
                        <input type="range" id="threshold" min="5" max="50" value="20">
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="info-box">
                    <strong>Marginal Value Theorem:</strong><br>
                    Leave a patch when the marginal rate of return equals the average rate for the environment.
                    <div class="mvt-equation">
                        dE/dt = E̅/T̅
                    </div>
                    <small>Optimal when: marginal gain = average gain rate</small>
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-panel">
                    <h3>Foraging Arena</h3>
                    <canvas id="arenaCanvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4CAF50;"></div>
                            <span>Rich Patch</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FFC107;"></div>
                            <span>Medium Patch</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FF5722;"></div>
                            <span>Depleted Patch</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #2196F3;"></div>
                            <span>Forager</span>
                        </div>
                    </div>
                </div>

                <div class="viz-row">
                    <div class="viz-panel">
                        <h3>Gain Curve & MVT Solution</h3>
                        <canvas id="gainCanvas"></canvas>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #4CAF50;"></div>
                                <span>Cumulative Gain</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #E91E63;"></div>
                                <span>Optimal Tangent</span>
                            </div>
                        </div>
                    </div>
                    <div class="viz-panel">
                        <h3>Marginal Rate of Return</h3>
                        <canvas id="marginalCanvas"></canvas>
                    </div>
                </div>

                <div class="viz-row">
                    <div class="viz-panel">
                        <h3>Patch Residence Times</h3>
                        <canvas id="residenceCanvas"></canvas>
                    </div>
                    <div class="viz-panel">
                        <h3>Foraging Efficiency Over Time</h3>
                        <canvas id="efficiencyCanvas"></canvas>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="label">Total Time</div>
                        <div class="value" id="timeStat">0</div>
                    </div>
                    <div class="stat-box highlight">
                        <div class="label">Total Gain</div>
                        <div class="value" id="gainStat">0.0</div>
                    </div>
                    <div class="stat-box success">
                        <div class="label">Avg Rate</div>
                        <div class="value" id="rateStat">0.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Patches Visited</div>
                        <div class="value" id="patchesStat">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Avg Residence</div>
                        <div class="value" id="residenceStat">0.0</div>
                    </div>
                    <div class="stat-box highlight">
                        <div class="label">MVT Optimal</div>
                        <div class="value" id="optimalStat">--</div>
                    </div>
                </div>

                <div class="viz-panel">
                    <h3>Strategy Comparison</h3>
                    <canvas id="comparisonCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const arenaCanvas = document.getElementById('arenaCanvas');
        const gainCanvas = document.getElementById('gainCanvas');
        const marginalCanvas = document.getElementById('marginalCanvas');
        const residenceCanvas = document.getElementById('residenceCanvas');
        const efficiencyCanvas = document.getElementById('efficiencyCanvas');
        const comparisonCanvas = document.getElementById('comparisonCanvas');

        const arenaCtx = arenaCanvas.getContext('2d');
        const gainCtx = gainCanvas.getContext('2d');
        const marginalCtx = marginalCanvas.getContext('2d');
        const residenceCtx = residenceCanvas.getContext('2d');
        const efficiencyCtx = efficiencyCanvas.getContext('2d');
        const comparisonCtx = comparisonCanvas.getContext('2d');

        // Parameters
        let numPatches = 5;
        let qualityVar = 0.30;
        let travelTime = 10;
        let initValue = 100;
        let depletion = 0.05;
        let patchType = 'exponential';
        let strategy = 'mvt';
        let fixedTime = 15;
        let threshold = 2.0;

        // State
        let patches = [];
        let forager = null;
        let time = 0;
        let totalGain = 0;
        let patchesVisited = 0;
        let residenceTimes = [];
        let efficiencyHistory = [];
        let currentPatchGain = 0;
        let currentPatchTime = 0;
        let currentGainCurve = [];
        let running = false;
        let animationId = null;
        let optimalResidence = 0;

        function setupCanvas(canvas, ctx, height) {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = (rect.width - 30) * dpr;
            canvas.height = height * dpr;
            canvas.style.width = (rect.width - 30) + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(dpr, dpr);
        }

        function getGainAtTime(t, patchQuality) {
            // Cumulative gain from foraging in a patch for time t
            const maxGain = initValue * patchQuality;

            if (patchType === 'exponential') {
                // G(t) = Gmax * (1 - e^(-λt))
                return maxGain * (1 - Math.exp(-depletion * t));
            } else if (patchType === 'linear') {
                // G(t) = min(Gmax, rate * t)
                const rate = maxGain * depletion;
                return Math.min(maxGain, rate * t);
            } else {
                // Stepwise - discrete items
                const itemValue = maxGain / 10;
                const itemsFound = Math.min(10, Math.floor(t * depletion * 2));
                return itemsFound * itemValue;
            }
        }

        function getMarginalRate(t, patchQuality) {
            // Instantaneous rate of gain dG/dt
            const maxGain = initValue * patchQuality;

            if (patchType === 'exponential') {
                return maxGain * depletion * Math.exp(-depletion * t);
            } else if (patchType === 'linear') {
                const rate = maxGain * depletion;
                return rate * t < maxGain ? rate : 0;
            } else {
                // Stepwise - average rate
                const dt = 0.5;
                return (getGainAtTime(t + dt, patchQuality) - getGainAtTime(t, patchQuality)) / dt;
            }
        }

        function calculateOptimalResidence() {
            // Calculate optimal residence time using MVT
            // Optimal: dG/dt = (total gain) / (total time including travel)
            // Solve: dG/dt = G(t*) / (T + t*)

            const avgQuality = patches.reduce((s, p) => s + p.quality, 0) / patches.length;

            // Numerical solution
            let bestT = 0;
            let bestRate = 0;

            for (let t = 1; t <= 100; t += 0.5) {
                const gain = getGainAtTime(t, avgQuality);
                const totalT = travelTime + t;
                const rate = gain / totalT;

                if (rate > bestRate) {
                    bestRate = rate;
                    bestT = t;
                }
            }

            optimalResidence = bestT;
            return bestT;
        }

        function shouldLeavePatch() {
            const avgQuality = patches.reduce((s, p) => s + p.quality, 0) / patches.length;
            const currentPatch = patches.find(p => p.id === forager.currentPatch);
            const quality = currentPatch ? currentPatch.quality : 1;

            if (strategy === 'mvt') {
                // Leave when marginal rate equals average rate
                const marginalRate = getMarginalRate(currentPatchTime, quality);
                const avgRate = (totalGain + currentPatchGain) / (time + 0.01);
                const expectedRate = getGainAtTime(optimalResidence, avgQuality) / (travelTime + optimalResidence);

                return marginalRate <= expectedRate * 0.9;
            } else if (strategy === 'fixed') {
                return currentPatchTime >= fixedTime;
            } else if (strategy === 'threshold') {
                const marginalRate = getMarginalRate(currentPatchTime, quality);
                return marginalRate <= threshold;
            } else {
                // Random - leave with increasing probability
                return Math.random() < currentPatchTime / 50;
            }
        }

        function initSimulation() {
            patches = [];
            time = 0;
            totalGain = 0;
            patchesVisited = 0;
            residenceTimes = [];
            efficiencyHistory = [];
            currentPatchGain = 0;
            currentPatchTime = 0;
            currentGainCurve = [];

            // Create patches with varying quality
            for (let i = 0; i < numPatches; i++) {
                const angle = (i / numPatches) * Math.PI * 2;
                const radius = 0.35;
                patches.push({
                    id: i,
                    x: 0.5 + Math.cos(angle) * radius,
                    y: 0.5 + Math.sin(angle) * radius,
                    quality: 1 + (Math.random() - 0.5) * 2 * qualityVar,
                    currentValue: initValue * (1 + (Math.random() - 0.5) * 2 * qualityVar),
                    depleted: 0
                });
            }

            // Create forager
            forager = {
                x: 0.5,
                y: 0.5,
                state: 'traveling',  // 'traveling', 'foraging'
                currentPatch: null,
                targetPatch: 0,
                travelProgress: 0
            };

            calculateOptimalResidence();
        }

        function findNearestUnvisitedPatch() {
            // Find best patch to visit next (least recently depleted)
            let bestPatch = null;
            let bestScore = -Infinity;

            for (const patch of patches) {
                const score = patch.currentValue - patch.depleted * 10;
                if (score > bestScore) {
                    bestScore = score;
                    bestPatch = patch;
                }
            }

            return bestPatch ? bestPatch.id : 0;
        }

        function step() {
            if (forager.state === 'traveling') {
                const targetPatch = patches[forager.targetPatch];
                forager.travelProgress += 1 / travelTime;

                // Interpolate position
                const startX = forager.currentPatch !== null ?
                    patches[forager.currentPatch].x : 0.5;
                const startY = forager.currentPatch !== null ?
                    patches[forager.currentPatch].y : 0.5;

                forager.x = startX + (targetPatch.x - startX) * forager.travelProgress;
                forager.y = startY + (targetPatch.y - startY) * forager.travelProgress;

                if (forager.travelProgress >= 1) {
                    // Arrived at patch
                    forager.state = 'foraging';
                    forager.currentPatch = forager.targetPatch;
                    forager.x = targetPatch.x;
                    forager.y = targetPatch.y;
                    currentPatchTime = 0;
                    currentPatchGain = 0;
                    currentGainCurve = [];
                    patchesVisited++;
                }
            } else {
                // Foraging in patch
                const patch = patches[forager.currentPatch];
                const prevGain = currentPatchGain;
                currentPatchTime += 1;

                // Calculate gain
                currentPatchGain = getGainAtTime(currentPatchTime, patch.quality);
                const gainThisStep = currentPatchGain - prevGain;
                totalGain += gainThisStep;

                // Update patch depletion visual
                patch.depleted = currentPatchGain / (initValue * patch.quality);

                // Record gain curve
                currentGainCurve.push({ t: currentPatchTime, g: currentPatchGain });

                // Check if should leave
                if (shouldLeavePatch() || currentPatchTime > 100) {
                    residenceTimes.push(currentPatchTime);

                    // Replenish patch (after some time would be more realistic)
                    patch.currentValue = initValue * patch.quality;
                    patch.depleted = 0;

                    // Find next patch
                    forager.targetPatch = findNearestUnvisitedPatch();
                    forager.state = 'traveling';
                    forager.travelProgress = 0;
                }
            }

            time++;

            // Record efficiency
            if (time % 10 === 0) {
                efficiencyHistory.push({
                    time: time,
                    rate: totalGain / time
                });
            }

            if (efficiencyHistory.length > 200) {
                efficiencyHistory = efficiencyHistory.filter((_, i) => i % 2 === 0);
            }
        }

        function drawArena() {
            const width = arenaCanvas.width / (window.devicePixelRatio || 1);
            const height = arenaCanvas.height / (window.devicePixelRatio || 1);

            arenaCtx.fillStyle = '#1a1a2e';
            arenaCtx.fillRect(0, 0, width, height);

            const size = Math.min(width, height);
            const offsetX = (width - size) / 2;
            const offsetY = (height - size) / 2;

            // Draw patches
            for (const patch of patches) {
                const x = offsetX + patch.x * size;
                const y = offsetY + patch.y * size;
                const radius = 30 + patch.quality * 15;

                // Patch color based on remaining value
                const remaining = 1 - patch.depleted;
                const hue = remaining * 120;  // Green to red
                arenaCtx.fillStyle = `hsl(${hue}, 70%, ${40 + remaining * 20}%)`;

                arenaCtx.beginPath();
                arenaCtx.arc(x, y, radius, 0, Math.PI * 2);
                arenaCtx.fill();

                // Patch quality indicator
                arenaCtx.fillStyle = '#fff';
                arenaCtx.font = 'bold 12px sans-serif';
                arenaCtx.textAlign = 'center';
                arenaCtx.fillText(`Q: ${patch.quality.toFixed(2)}`, x, y - 5);
                arenaCtx.font = '10px sans-serif';
                arenaCtx.fillText(`${Math.round((1-patch.depleted)*100)}%`, x, y + 10);
            }

            // Draw travel path
            if (forager.state === 'traveling' && forager.currentPatch !== null) {
                const startPatch = patches[forager.currentPatch];
                const endPatch = patches[forager.targetPatch];

                arenaCtx.strokeStyle = '#ffffff44';
                arenaCtx.lineWidth = 2;
                arenaCtx.setLineDash([5, 5]);
                arenaCtx.beginPath();
                arenaCtx.moveTo(offsetX + startPatch.x * size, offsetY + startPatch.y * size);
                arenaCtx.lineTo(offsetX + endPatch.x * size, offsetY + endPatch.y * size);
                arenaCtx.stroke();
                arenaCtx.setLineDash([]);
            }

            // Draw forager
            const fx = offsetX + forager.x * size;
            const fy = offsetY + forager.y * size;

            arenaCtx.fillStyle = '#2196F3';
            arenaCtx.beginPath();
            arenaCtx.arc(fx, fy, 12, 0, Math.PI * 2);
            arenaCtx.fill();

            arenaCtx.strokeStyle = '#fff';
            arenaCtx.lineWidth = 2;
            arenaCtx.beginPath();
            arenaCtx.arc(fx, fy, 12, 0, Math.PI * 2);
            arenaCtx.stroke();

            // Status
            arenaCtx.fillStyle = '#ffffffaa';
            arenaCtx.font = '11px sans-serif';
            arenaCtx.textAlign = 'left';
            arenaCtx.fillText(`State: ${forager.state}`, 10, height - 10);
            if (forager.state === 'foraging') {
                arenaCtx.fillText(`Time in patch: ${currentPatchTime}`, 120, height - 10);
            }
        }

        function drawGainCurve() {
            const width = gainCanvas.width / (window.devicePixelRatio || 1);
            const height = gainCanvas.height / (window.devicePixelRatio || 1);

            gainCtx.fillStyle = '#1a1a2e';
            gainCtx.fillRect(0, 0, width, height);

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Axes
            gainCtx.strokeStyle = '#ffffff44';
            gainCtx.beginPath();
            gainCtx.moveTo(padding, padding);
            gainCtx.lineTo(padding, height - padding);
            gainCtx.lineTo(width - padding, height - padding);
            gainCtx.stroke();

            // Draw theoretical gain curve
            const avgQuality = patches.reduce((s, p) => s + p.quality, 0) / patches.length;
            const maxT = 60;
            const maxG = initValue * avgQuality;

            gainCtx.strokeStyle = '#4CAF50';
            gainCtx.lineWidth = 2;
            gainCtx.beginPath();

            for (let t = 0; t <= maxT; t++) {
                const gain = getGainAtTime(t, avgQuality);
                const x = padding + (t / maxT) * graphWidth;
                const y = height - padding - (gain / maxG) * graphHeight;

                if (t === 0) {
                    gainCtx.moveTo(x, y);
                } else {
                    gainCtx.lineTo(x, y);
                }
            }
            gainCtx.stroke();

            // Draw MVT tangent line from (-travelTime, 0)
            const optGain = getGainAtTime(optimalResidence, avgQuality);
            const startX = padding + (-travelTime / maxT) * graphWidth;
            const startY = height - padding;
            const endX = padding + (optimalResidence / maxT) * graphWidth;
            const endY = height - padding - (optGain / maxG) * graphHeight;

            gainCtx.strokeStyle = '#E91E63';
            gainCtx.lineWidth = 2;
            gainCtx.setLineDash([5, 5]);
            gainCtx.beginPath();
            gainCtx.moveTo(padding, startY);  // Start from origin on graph
            gainCtx.lineTo(endX, endY);
            // Extend line further
            const slope = (startY - endY) / (endX - padding);
            gainCtx.lineTo(width - padding, endY - slope * (width - padding - endX));
            gainCtx.stroke();
            gainCtx.setLineDash([]);

            // Mark optimal point
            gainCtx.fillStyle = '#E91E63';
            gainCtx.beginPath();
            gainCtx.arc(endX, endY, 6, 0, Math.PI * 2);
            gainCtx.fill();

            // Draw current gain if foraging
            if (currentGainCurve.length > 0 && forager.state === 'foraging') {
                gainCtx.strokeStyle = '#FFC107';
                gainCtx.lineWidth = 3;
                gainCtx.beginPath();

                currentGainCurve.forEach((point, i) => {
                    const x = padding + (point.t / maxT) * graphWidth;
                    const y = height - padding - (point.g / maxG) * graphHeight;

                    if (i === 0) {
                        gainCtx.moveTo(x, y);
                    } else {
                        gainCtx.lineTo(x, y);
                    }
                });
                gainCtx.stroke();
            }

            // Labels
            gainCtx.fillStyle = '#ffffffaa';
            gainCtx.font = '10px sans-serif';
            gainCtx.fillText('Cumulative Gain', padding + 5, padding - 10);
            gainCtx.textAlign = 'center';
            gainCtx.fillText('Time in Patch', width / 2, height - 5);
            gainCtx.fillStyle = '#E91E63';
            gainCtx.fillText(`t* = ${optimalResidence.toFixed(1)}`, endX, endY - 15);
        }

        function drawMarginal() {
            const width = marginalCanvas.width / (window.devicePixelRatio || 1);
            const height = marginalCanvas.height / (window.devicePixelRatio || 1);

            marginalCtx.fillStyle = '#1a1a2e';
            marginalCtx.fillRect(0, 0, width, height);

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Axes
            marginalCtx.strokeStyle = '#ffffff44';
            marginalCtx.beginPath();
            marginalCtx.moveTo(padding, padding);
            marginalCtx.lineTo(padding, height - padding);
            marginalCtx.lineTo(width - padding, height - padding);
            marginalCtx.stroke();

            const avgQuality = patches.reduce((s, p) => s + p.quality, 0) / patches.length;
            const maxT = 60;
            const maxRate = getMarginalRate(0, avgQuality);

            // Draw marginal rate curve
            marginalCtx.strokeStyle = '#9C27B0';
            marginalCtx.lineWidth = 2;
            marginalCtx.beginPath();

            for (let t = 0; t <= maxT; t++) {
                const rate = getMarginalRate(t, avgQuality);
                const x = padding + (t / maxT) * graphWidth;
                const y = height - padding - (rate / maxRate) * graphHeight;

                if (t === 0) {
                    marginalCtx.moveTo(x, y);
                } else {
                    marginalCtx.lineTo(x, y);
                }
            }
            marginalCtx.stroke();

            // Draw average rate threshold
            const avgRate = getGainAtTime(optimalResidence, avgQuality) / (travelTime + optimalResidence);
            const threshY = height - padding - (avgRate / maxRate) * graphHeight;

            marginalCtx.strokeStyle = '#4CAF50';
            marginalCtx.setLineDash([5, 5]);
            marginalCtx.beginPath();
            marginalCtx.moveTo(padding, threshY);
            marginalCtx.lineTo(width - padding, threshY);
            marginalCtx.stroke();
            marginalCtx.setLineDash([]);

            // Mark current position if foraging
            if (forager.state === 'foraging') {
                const currentPatch = patches[forager.currentPatch];
                const currentRate = getMarginalRate(currentPatchTime, currentPatch.quality);
                const cx = padding + (currentPatchTime / maxT) * graphWidth;
                const cy = height - padding - (currentRate / maxRate) * graphHeight;

                marginalCtx.fillStyle = '#FFC107';
                marginalCtx.beginPath();
                marginalCtx.arc(cx, cy, 8, 0, Math.PI * 2);
                marginalCtx.fill();
            }

            // Labels
            marginalCtx.fillStyle = '#ffffffaa';
            marginalCtx.font = '10px sans-serif';
            marginalCtx.fillText('Marginal Rate (dG/dt)', padding + 5, padding - 10);
            marginalCtx.textAlign = 'center';
            marginalCtx.fillText('Time in Patch', width / 2, height - 5);

            marginalCtx.fillStyle = '#4CAF50';
            marginalCtx.textAlign = 'left';
            marginalCtx.fillText('Avg Rate (leave threshold)', padding + 5, threshY - 5);
        }

        function drawResidence() {
            const width = residenceCanvas.width / (window.devicePixelRatio || 1);
            const height = residenceCanvas.height / (window.devicePixelRatio || 1);

            residenceCtx.fillStyle = '#1a1a2e';
            residenceCtx.fillRect(0, 0, width, height);

            if (residenceTimes.length === 0) return;

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            const maxResidence = Math.max(...residenceTimes, optimalResidence);
            const barWidth = graphWidth / Math.max(residenceTimes.length, 10);

            // Draw bars
            residenceTimes.forEach((rt, i) => {
                const x = padding + i * barWidth;
                const barHeight = (rt / maxResidence) * graphHeight;

                residenceCtx.fillStyle = Math.abs(rt - optimalResidence) < 3 ? '#4CAF50' : '#2196F3';
                residenceCtx.fillRect(x, height - padding - barHeight, barWidth - 2, barHeight);
            });

            // Draw optimal line
            const optY = height - padding - (optimalResidence / maxResidence) * graphHeight;
            residenceCtx.strokeStyle = '#E91E63';
            residenceCtx.lineWidth = 2;
            residenceCtx.setLineDash([5, 5]);
            residenceCtx.beginPath();
            residenceCtx.moveTo(padding, optY);
            residenceCtx.lineTo(width - padding, optY);
            residenceCtx.stroke();
            residenceCtx.setLineDash([]);

            // Axes
            residenceCtx.strokeStyle = '#ffffff44';
            residenceCtx.beginPath();
            residenceCtx.moveTo(padding, height - padding);
            residenceCtx.lineTo(width - padding, height - padding);
            residenceCtx.stroke();

            residenceCtx.fillStyle = '#ffffffaa';
            residenceCtx.font = '10px sans-serif';
            residenceCtx.fillText('Residence Time', padding + 5, padding - 10);
            residenceCtx.fillStyle = '#E91E63';
            residenceCtx.fillText(`Optimal: ${optimalResidence.toFixed(1)}`, width - padding - 80, optY - 5);
        }

        function drawEfficiency() {
            const width = efficiencyCanvas.width / (window.devicePixelRatio || 1);
            const height = efficiencyCanvas.height / (window.devicePixelRatio || 1);

            efficiencyCtx.fillStyle = '#1a1a2e';
            efficiencyCtx.fillRect(0, 0, width, height);

            if (efficiencyHistory.length < 2) return;

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            const maxTime = efficiencyHistory[efficiencyHistory.length - 1].time;
            const maxRate = Math.max(...efficiencyHistory.map(e => e.rate));

            // Draw efficiency line
            efficiencyCtx.strokeStyle = '#4CAF50';
            efficiencyCtx.lineWidth = 2;
            efficiencyCtx.beginPath();

            efficiencyHistory.forEach((point, i) => {
                const x = padding + (point.time / maxTime) * graphWidth;
                const y = height - padding - (point.rate / maxRate) * graphHeight;

                if (i === 0) {
                    efficiencyCtx.moveTo(x, y);
                } else {
                    efficiencyCtx.lineTo(x, y);
                }
            });
            efficiencyCtx.stroke();

            // Draw optimal rate
            const avgQuality = patches.reduce((s, p) => s + p.quality, 0) / patches.length;
            const optRate = getGainAtTime(optimalResidence, avgQuality) / (travelTime + optimalResidence);
            const optY = height - padding - (optRate / maxRate) * graphHeight;

            efficiencyCtx.strokeStyle = '#E91E63';
            efficiencyCtx.setLineDash([5, 5]);
            efficiencyCtx.beginPath();
            efficiencyCtx.moveTo(padding, optY);
            efficiencyCtx.lineTo(width - padding, optY);
            efficiencyCtx.stroke();
            efficiencyCtx.setLineDash([]);

            // Axes
            efficiencyCtx.strokeStyle = '#ffffff44';
            efficiencyCtx.beginPath();
            efficiencyCtx.moveTo(padding, padding);
            efficiencyCtx.lineTo(padding, height - padding);
            efficiencyCtx.lineTo(width - padding, height - padding);
            efficiencyCtx.stroke();

            efficiencyCtx.fillStyle = '#ffffffaa';
            efficiencyCtx.font = '10px sans-serif';
            efficiencyCtx.fillText('Rate (gain/time)', padding + 5, padding - 10);
            efficiencyCtx.textAlign = 'center';
            efficiencyCtx.fillText('Total Time', width / 2, height - 5);
        }

        function drawComparison() {
            const width = comparisonCanvas.width / (window.devicePixelRatio || 1);
            const height = comparisonCanvas.height / (window.devicePixelRatio || 1);

            comparisonCtx.fillStyle = '#1a1a2e';
            comparisonCtx.fillRect(0, 0, width, height);

            const padding = 50;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            const avgQuality = patches.reduce((s, p) => s + p.quality, 0) / patches.length;

            // Calculate efficiency for different fixed times
            const strategies = [
                { name: 'MVT Optimal', time: optimalResidence, color: '#E91E63' },
                { name: 'Too Short', time: optimalResidence * 0.5, color: '#FF9800' },
                { name: 'Too Long', time: optimalResidence * 2, color: '#9C27B0' },
                { name: 'Current', time: residenceTimes.length > 0 ?
                    residenceTimes.reduce((a, b) => a + b) / residenceTimes.length : optimalResidence,
                    color: '#2196F3' }
            ];

            const barWidth = graphWidth / (strategies.length * 2);
            const maxRate = strategies.reduce((max, s) => {
                const rate = getGainAtTime(s.time, avgQuality) / (travelTime + s.time);
                return Math.max(max, rate);
            }, 0) * 1.2;

            strategies.forEach((strat, i) => {
                const rate = getGainAtTime(strat.time, avgQuality) / (travelTime + strat.time);
                const x = padding + (i * 2 + 0.5) * barWidth;
                const barHeight = (rate / maxRate) * graphHeight;

                comparisonCtx.fillStyle = strat.color;
                comparisonCtx.fillRect(x, height - padding - barHeight, barWidth, barHeight);

                // Label
                comparisonCtx.fillStyle = '#ffffffaa';
                comparisonCtx.font = '9px sans-serif';
                comparisonCtx.textAlign = 'center';
                comparisonCtx.fillText(strat.name, x + barWidth / 2, height - 10);
                comparisonCtx.fillText(`t=${strat.time.toFixed(1)}`, x + barWidth / 2, height - padding - barHeight - 15);
                comparisonCtx.fillText(rate.toFixed(2), x + barWidth / 2, height - padding - barHeight - 5);
            });

            comparisonCtx.fillStyle = '#ffffffaa';
            comparisonCtx.font = '10px sans-serif';
            comparisonCtx.textAlign = 'left';
            comparisonCtx.fillText('Rate Comparison', padding, padding - 10);
        }

        function updateStats() {
            const avgResidence = residenceTimes.length > 0 ?
                residenceTimes.reduce((a, b) => a + b) / residenceTimes.length : 0;

            document.getElementById('timeStat').textContent = time;
            document.getElementById('gainStat').textContent = totalGain.toFixed(1);
            document.getElementById('rateStat').textContent = time > 0 ? (totalGain / time).toFixed(3) : '0.00';
            document.getElementById('patchesStat').textContent = patchesVisited;
            document.getElementById('residenceStat').textContent = avgResidence.toFixed(1);
            document.getElementById('optimalStat').textContent = optimalResidence.toFixed(1);
        }

        function animate() {
            step();

            drawArena();
            drawGainCurve();
            drawMarginal();
            drawResidence();
            drawEfficiency();
            drawComparison();
            updateStats();

            if (running) {
                animationId = requestAnimationFrame(animate);
            }
        }

        function start() {
            if (!running) {
                running = true;
                document.getElementById('startBtn').textContent = 'Pause';
                animate();
            } else {
                running = false;
                document.getElementById('startBtn').textContent = 'Start';
                if (animationId) cancelAnimationFrame(animationId);
            }
        }

        function reset() {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            if (animationId) cancelAnimationFrame(animationId);

            numPatches = parseInt(document.getElementById('numPatches').value);
            qualityVar = parseInt(document.getElementById('qualityVar').value) / 100;
            travelTime = parseInt(document.getElementById('travelTime').value);
            initValue = parseInt(document.getElementById('initValue').value);
            depletion = parseInt(document.getElementById('depletion').value) / 100;
            patchType = document.getElementById('patchType').value;
            strategy = document.getElementById('strategy').value;
            fixedTime = parseInt(document.getElementById('fixedTime').value);
            threshold = parseInt(document.getElementById('threshold').value) / 10;

            initSimulation();
            drawArena();
            drawGainCurve();
            drawMarginal();
            drawResidence();
            drawEfficiency();
            drawComparison();
            updateStats();
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', start);
        document.getElementById('resetBtn').addEventListener('click', reset);

        document.getElementById('strategy').addEventListener('change', (e) => {
            document.getElementById('fixedTimeGroup').style.display =
                e.target.value === 'fixed' ? 'block' : 'none';
            document.getElementById('thresholdGroup').style.display =
                e.target.value === 'threshold' ? 'block' : 'none';
        });

        document.getElementById('numPatches').addEventListener('input', (e) => {
            document.getElementById('numPatchesVal').textContent = e.target.value;
        });

        document.getElementById('qualityVar').addEventListener('input', (e) => {
            document.getElementById('qualityVarVal').textContent = (e.target.value / 100).toFixed(2);
        });

        document.getElementById('travelTime').addEventListener('input', (e) => {
            document.getElementById('travelTimeVal').textContent = e.target.value;
        });

        document.getElementById('initValue').addEventListener('input', (e) => {
            document.getElementById('initValueVal').textContent = e.target.value;
        });

        document.getElementById('depletion').addEventListener('input', (e) => {
            document.getElementById('depletionVal').textContent = (e.target.value / 100).toFixed(2);
        });

        document.getElementById('fixedTime').addEventListener('input', (e) => {
            document.getElementById('fixedTimeVal').textContent = e.target.value;
        });

        document.getElementById('threshold').addEventListener('input', (e) => {
            document.getElementById('thresholdVal').textContent = (e.target.value / 10).toFixed(1);
        });

        // Initialize
        function init() {
            setupCanvas(arenaCanvas, arenaCtx, 300);
            setupCanvas(gainCanvas, gainCtx, 200);
            setupCanvas(marginalCanvas, marginalCtx, 200);
            setupCanvas(residenceCanvas, residenceCtx, 180);
            setupCanvas(efficiencyCanvas, efficiencyCtx, 180);
            setupCanvas(comparisonCanvas, comparisonCtx, 150);

            initSimulation();
            drawArena();
            drawGainCurve();
            drawMarginal();
            drawResidence();
            drawEfficiency();
            drawComparison();
            updateStats();
        }

        window.addEventListener('resize', () => {
            setupCanvas(arenaCanvas, arenaCtx, 300);
            setupCanvas(gainCanvas, gainCtx, 200);
            setupCanvas(marginalCanvas, marginalCtx, 200);
            setupCanvas(residenceCanvas, residenceCtx, 180);
            setupCanvas(efficiencyCanvas, efficiencyCtx, 180);
            setupCanvas(comparisonCanvas, comparisonCtx, 150);
            drawArena();
            drawGainCurve();
            drawMarginal();
            drawResidence();
            drawEfficiency();
            drawComparison();
        });

        init();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
