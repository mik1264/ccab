<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Acoustic Waves - Propagation, Reflection & Doppler Effect</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #F4F1DE 50%, #EDE8D5 100%);
            min-height: 100vh;
            color: var(--dark-moss);
            padding: 20px;
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            text-decoration: none;
            color: var(--moss);
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .organic-back-link:hover {
            background: var(--moss);
            color: white;
            transform: translateX(-5px);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding-top: 60px;
        }

        h1 {
            font-family: 'Lora', serif;
            font-size: 2.5rem;
            color: var(--moss);
            text-align: center;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: var(--terracotta);
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        .simulation-area {
            display: grid;
            grid-template-columns: 280px 1fr 280px;
            gap: 20px;
        }

        .controls, .stats-panel {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            max-height: calc(100vh - 150px);
            overflow-y: auto;
        }

        .control-section {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(96, 108, 56, 0.2);
        }

        .control-section:last-child {
            border-bottom: none;
        }

        .control-section h3 {
            color: var(--moss);
            font-size: 1rem;
            margin-bottom: 12px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            color: var(--moss);
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--moss);
        }

        .control-group .value {
            text-align: right;
            font-size: 0.85rem;
            color: var(--terracotta);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .checkbox-group input[type="checkbox"],
        .checkbox-group input[type="radio"] {
            accent-color: var(--moss);
            width: 18px;
            height: 18px;
        }

        button {
            width: 100%;
            padding: 12px;
            background: var(--moss);
            color: white;
            border: none;
            border-radius: 10px;
            font-family: 'Nunito', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }

        button:hover {
            background: var(--dark-moss);
            transform: translateY(-2px);
        }

        button.secondary {
            background: var(--terracotta);
        }

        button.secondary:hover {
            background: #a05a1f;
        }

        .preset-btn {
            padding: 8px;
            font-size: 0.85rem;
            margin-bottom: 5px;
        }

        .canvas-container {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        canvas {
            display: block;
            width: 100%;
            border-radius: 10px;
            cursor: crosshair;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(96, 108, 56, 0.1);
        }

        .stat-label {
            font-weight: 600;
            color: var(--moss);
        }

        .stat-value {
            color: var(--terracotta);
            font-weight: 700;
        }

        .legend {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
            font-size: 0.75rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .legend-color {
            width: 15px;
            height: 10px;
            border-radius: 2px;
        }

        .info-box {
            background: rgba(138, 154, 91, 0.1);
            border-left: 3px solid var(--sage);
            padding: 12px;
            border-radius: 0 10px 10px 0;
            margin-top: 15px;
            font-size: 0.85rem;
            line-height: 1.5;
        }

        @media (max-width: 1200px) {
            .simulation-area {
                grid-template-columns: 1fr;
            }
            .controls, .stats-panel {
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link">
        <span class="back-arrow">←</span>
        <span class="back-text">Gallery</span>
    </a>

    <div class="container">
        <h1>Acoustic Wave Simulation</h1>
        <p class="subtitle">Sound Propagation, Reflection, Refraction & Doppler Effect</p>

        <div class="simulation-area">
            <div class="controls">
                <div class="control-section">
                    <h3>Simulation Controls</h3>
                    <button id="startBtn">Start</button>
                    <button id="resetBtn" class="secondary">Reset</button>
                    <button id="clearBtn" class="secondary">Clear Obstacles</button>
                </div>

                <div class="control-section">
                    <h3>Source Type</h3>
                    <div class="checkbox-group">
                        <input type="radio" name="sourceType" id="typePoint" checked>
                        <label for="typePoint">Point Source</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="radio" name="sourceType" id="typePlane">
                        <label for="typePlane">Plane Wave</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="radio" name="sourceType" id="typeMoving">
                        <label for="typeMoving">Moving Source (Doppler)</label>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Wave Parameters</h3>
                    <div class="control-group">
                        <label>Frequency: <span class="value" id="freqVal">2.0</span> Hz</label>
                        <input type="range" id="freq" min="0.5" max="5" value="2" step="0.1">
                    </div>
                    <div class="control-group">
                        <label>Wave Speed: <span class="value" id="speedVal">2.0</span></label>
                        <input type="range" id="speed" min="0.5" max="5" value="2" step="0.1">
                    </div>
                    <div class="control-group">
                        <label>Amplitude: <span class="value" id="ampVal">1.0</span></label>
                        <input type="range" id="amp" min="0.1" max="2" value="1" step="0.1">
                    </div>
                    <div class="control-group">
                        <label>Damping: <span class="value" id="dampVal">0.002</span></label>
                        <input type="range" id="damp" min="0" max="0.01" value="0.002" step="0.001">
                    </div>
                </div>

                <div class="control-section">
                    <h3>Obstacles</h3>
                    <p style="font-size: 0.85rem; margin-bottom: 10px;">Click and drag to draw walls</p>
                    <div class="checkbox-group">
                        <input type="radio" name="obstacleType" id="obstWall" checked>
                        <label for="obstWall">Reflecting Wall</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="radio" name="obstacleType" id="obstAbsorb">
                        <label for="obstAbsorb">Absorbing Wall</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="radio" name="obstacleType" id="obstRefract">
                        <label for="obstRefract">Refracting Medium</label>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Presets</h3>
                    <button class="preset-btn" onclick="loadPreset('singleSlit')">Single Slit</button>
                    <button class="preset-btn secondary" onclick="loadPreset('doubleSlit')">Double Slit</button>
                    <button class="preset-btn secondary" onclick="loadPreset('reflection')">Reflection</button>
                    <button class="preset-btn secondary" onclick="loadPreset('refraction')">Refraction</button>
                    <button class="preset-btn secondary" onclick="loadPreset('standing')">Standing Wave</button>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="simCanvas" width="700" height="500"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #0000FF, #FFFFFF, #FF0000);"></div>
                        <span>Wave amplitude</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #333;"></div>
                        <span>Reflecting wall</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #8B4513;"></div>
                        <span>Absorbing wall</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: rgba(100, 200, 100, 0.5);"></div>
                        <span>Refracting medium</span>
                    </div>
                </div>
            </div>

            <div class="stats-panel">
                <div class="control-section">
                    <h3>Wave Properties</h3>
                    <div class="stat-item">
                        <span class="stat-label">Wavelength (λ):</span>
                        <span class="stat-value" id="statWavelength">1.00</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Period (T):</span>
                        <span class="stat-value" id="statPeriod">0.50 s</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Time:</span>
                        <span class="stat-value" id="statTime">0.00 s</span>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Source Position</h3>
                    <div class="stat-item">
                        <span class="stat-label">X:</span>
                        <span class="stat-value" id="statSourceX">350</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Y:</span>
                        <span class="stat-value" id="statSourceY">250</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Velocity:</span>
                        <span class="stat-value" id="statVelocity">0.0</span>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Doppler Effect</h3>
                    <div class="stat-item">
                        <span class="stat-label">Observed Freq (ahead):</span>
                        <span class="stat-value" id="statDopplerAhead">--</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Observed Freq (behind):</span>
                        <span class="stat-value" id="statDopplerBehind">--</span>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Physics:</strong> Sound waves propagate through a medium via compressions and rarefactions. When waves hit obstacles they reflect (bounce back) or diffract (bend around edges). The Doppler effect shifts apparent frequency when source or observer moves relative to the medium.
                </div>
            </div>
        </div>
    </div>

    <script>
        // Acoustic Wave Simulation
        // 2D wave equation solver using finite difference method

        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        // Grid parameters
        const scale = 3;
        const nx = Math.floor(canvas.width / scale);
        const ny = Math.floor(canvas.height / scale);

        // Wave field arrays
        let u = [];      // Current displacement
        let uPrev = [];  // Previous displacement
        let uNext = [];  // Next displacement
        let obstacle = []; // Obstacle types: 0=none, 1=reflect, 2=absorb, 3=refract

        // Parameters
        let params = {
            frequency: 2.0,
            waveSpeed: 2.0,
            amplitude: 1.0,
            damping: 0.002,
            sourceType: 'point',
            obstacleType: 'wall'
        };

        // Source state
        let source = {
            x: nx / 2,
            y: ny / 2,
            vx: 0,
            vy: 0,
            direction: 1
        };

        // Simulation state
        let running = false;
        let animationId = null;
        let time = 0;

        // Mouse state
        let isDrawing = false;
        let lastMousePos = null;

        // Initialize arrays
        function initArrays() {
            u = [];
            uPrev = [];
            uNext = [];
            obstacle = [];

            for (let i = 0; i < nx; i++) {
                u[i] = [];
                uPrev[i] = [];
                uNext[i] = [];
                obstacle[i] = [];
                for (let j = 0; j < ny; j++) {
                    u[i][j] = 0;
                    uPrev[i][j] = 0;
                    uNext[i][j] = 0;
                    obstacle[i][j] = 0;
                }
            }

            time = 0;
            source.x = nx / 2;
            source.y = ny / 2;
            source.vx = 0;
            source.vy = 0;
        }

        // Wave equation update using finite difference
        function updateWave() {
            const c = params.waveSpeed;
            const dt = 0.5;
            const dx = 1;
            const r = (c * dt / dx) ** 2;

            for (let i = 1; i < nx - 1; i++) {
                for (let j = 1; j < ny - 1; j++) {
                    if (obstacle[i][j] === 1) {
                        // Reflecting boundary (Neumann)
                        continue;
                    } else if (obstacle[i][j] === 2) {
                        // Absorbing boundary
                        uNext[i][j] = u[i][j] * 0.5;
                        continue;
                    }

                    // Speed modification for refracting medium
                    let localR = r;
                    if (obstacle[i][j] === 3) {
                        localR = r * 0.5; // Slower in refracting medium
                    }

                    // 2D wave equation discretization
                    const laplacian = u[i+1][j] + u[i-1][j] + u[i][j+1] + u[i][j-1] - 4 * u[i][j];
                    uNext[i][j] = 2 * u[i][j] - uPrev[i][j] + localR * laplacian;

                    // Apply damping
                    uNext[i][j] *= (1 - params.damping);
                }
            }

            // Handle boundaries (absorbing)
            for (let i = 0; i < nx; i++) {
                uNext[i][0] = uNext[i][1] * 0.5;
                uNext[i][ny-1] = uNext[i][ny-2] * 0.5;
            }
            for (let j = 0; j < ny; j++) {
                uNext[0][j] = uNext[1][j] * 0.5;
                uNext[nx-1][j] = uNext[nx-2][j] * 0.5;
            }

            // Swap arrays
            const temp = uPrev;
            uPrev = u;
            u = uNext;
            uNext = temp;

            time += 0.02;
        }

        // Add wave source
        function addSource() {
            const omega = 2 * Math.PI * params.frequency;
            const sourceValue = params.amplitude * Math.sin(omega * time);

            if (params.sourceType === 'point' || params.sourceType === 'moving') {
                // Update moving source position
                if (params.sourceType === 'moving') {
                    source.vx = params.waveSpeed * 0.6 * source.direction;
                    source.x += source.vx * 0.05;

                    // Bounce at boundaries
                    if (source.x > nx - 20 || source.x < 20) {
                        source.direction *= -1;
                    }
                }

                const sx = Math.floor(source.x);
                const sy = Math.floor(source.y);

                if (sx > 0 && sx < nx - 1 && sy > 0 && sy < ny - 1) {
                    // Point source with small radius
                    for (let di = -2; di <= 2; di++) {
                        for (let dj = -2; dj <= 2; dj++) {
                            if (di*di + dj*dj <= 4) {
                                const ni = sx + di;
                                const nj = sy + dj;
                                if (obstacle[ni][nj] === 0) {
                                    u[ni][nj] = sourceValue;
                                }
                            }
                        }
                    }
                }
            } else if (params.sourceType === 'plane') {
                // Plane wave from left
                for (let j = 10; j < ny - 10; j++) {
                    if (obstacle[10][j] === 0) {
                        u[10][j] = sourceValue;
                    }
                }
            }
        }

        // Draw simulation
        function draw() {
            // Create image data for wave visualization
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            // Find max amplitude for normalization
            let maxAmp = 0.1;
            for (let i = 0; i < nx; i++) {
                for (let j = 0; j < ny; j++) {
                    if (Math.abs(u[i][j]) > maxAmp) maxAmp = Math.abs(u[i][j]);
                }
            }

            // Draw wave field
            for (let i = 0; i < nx; i++) {
                for (let j = 0; j < ny; j++) {
                    for (let sx = 0; sx < scale; sx++) {
                        for (let sy = 0; sy < scale; sy++) {
                            const px = i * scale + sx;
                            const py = j * scale + sy;
                            const idx = (py * canvas.width + px) * 4;

                            if (obstacle[i][j] === 1) {
                                // Reflecting wall
                                data[idx] = 50;
                                data[idx + 1] = 50;
                                data[idx + 2] = 60;
                                data[idx + 3] = 255;
                            } else if (obstacle[i][j] === 2) {
                                // Absorbing wall
                                data[idx] = 139;
                                data[idx + 1] = 69;
                                data[idx + 2] = 19;
                                data[idx + 3] = 255;
                            } else if (obstacle[i][j] === 3) {
                                // Refracting medium
                                const val = u[i][j] / maxAmp;
                                const r = val > 0 ? Math.floor(100 + val * 100) : Math.floor(100);
                                const g = Math.floor(150 + val * 50);
                                const b = val < 0 ? Math.floor(100 - val * 100) : Math.floor(100);
                                data[idx] = r;
                                data[idx + 1] = g;
                                data[idx + 2] = b;
                                data[idx + 3] = 200;
                            } else {
                                // Wave field - blue to white to red colormap
                                const val = u[i][j] / maxAmp;

                                let r, g, b;
                                if (val < 0) {
                                    // Negative: blue to white
                                    const t = -val;
                                    r = Math.floor(255 * (1 - t));
                                    g = Math.floor(255 * (1 - t));
                                    b = 255;
                                } else {
                                    // Positive: white to red
                                    const t = val;
                                    r = 255;
                                    g = Math.floor(255 * (1 - t));
                                    b = Math.floor(255 * (1 - t));
                                }

                                data[idx] = r;
                                data[idx + 1] = g;
                                data[idx + 2] = b;
                                data[idx + 3] = 255;
                            }
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw source indicator
            if (params.sourceType === 'point' || params.sourceType === 'moving') {
                ctx.beginPath();
                ctx.arc(source.x * scale, source.y * scale, 8, 0, Math.PI * 2);
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(source.x * scale, source.y * scale, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#FFD700';
                ctx.fill();

                // Draw velocity vector for moving source
                if (params.sourceType === 'moving') {
                    ctx.beginPath();
                    ctx.moveTo(source.x * scale, source.y * scale);
                    ctx.lineTo((source.x + source.vx * 10) * scale, source.y * scale);
                    ctx.strokeStyle = '#FF6B6B';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            updateStats();
        }

        // Update statistics display
        function updateStats() {
            const wavelength = params.waveSpeed / params.frequency;
            const period = 1 / params.frequency;

            document.getElementById('statWavelength').textContent = wavelength.toFixed(2);
            document.getElementById('statPeriod').textContent = period.toFixed(2) + ' s';
            document.getElementById('statTime').textContent = time.toFixed(2) + ' s';

            document.getElementById('statSourceX').textContent = (source.x * scale).toFixed(0);
            document.getElementById('statSourceY').textContent = (source.y * scale).toFixed(0);
            document.getElementById('statVelocity').textContent = (source.vx * scale).toFixed(1);

            // Doppler effect calculation
            if (params.sourceType === 'moving' && Math.abs(source.vx) > 0.01) {
                const v = params.waveSpeed;
                const vs = Math.abs(source.vx);
                const f0 = params.frequency;

                const fAhead = f0 * v / (v - vs);
                const fBehind = f0 * v / (v + vs);

                document.getElementById('statDopplerAhead').textContent = fAhead.toFixed(2) + ' Hz';
                document.getElementById('statDopplerBehind').textContent = fBehind.toFixed(2) + ' Hz';
            } else {
                document.getElementById('statDopplerAhead').textContent = '--';
                document.getElementById('statDopplerBehind').textContent = '--';
            }
        }

        // Load preset configurations
        function loadPreset(preset) {
            initArrays();

            switch (preset) {
                case 'singleSlit':
                    params.sourceType = 'plane';
                    document.getElementById('typePlane').checked = true;

                    // Create wall with single slit
                    const slitX = Math.floor(nx * 0.4);
                    const slitWidth = 10;
                    const slitCenter = ny / 2;

                    for (let j = 0; j < ny; j++) {
                        if (Math.abs(j - slitCenter) > slitWidth) {
                            for (let di = -2; di <= 2; di++) {
                                obstacle[slitX + di][j] = 1;
                            }
                        }
                    }
                    break;

                case 'doubleSlit':
                    params.sourceType = 'plane';
                    document.getElementById('typePlane').checked = true;

                    const wallX = Math.floor(nx * 0.4);
                    const slitGap = 30;
                    const sWidth = 8;

                    for (let j = 0; j < ny; j++) {
                        const d1 = Math.abs(j - (ny / 2 - slitGap / 2));
                        const d2 = Math.abs(j - (ny / 2 + slitGap / 2));

                        if (d1 > sWidth && d2 > sWidth) {
                            for (let di = -2; di <= 2; di++) {
                                obstacle[wallX + di][j] = 1;
                            }
                        }
                    }
                    break;

                case 'reflection':
                    params.sourceType = 'point';
                    document.getElementById('typePoint').checked = true;

                    source.x = nx / 3;
                    source.y = ny / 2;

                    // Angled reflecting wall
                    for (let i = 0; i < 60; i++) {
                        const wx = Math.floor(nx * 0.65 + i * 0.3);
                        const wy = Math.floor(ny / 3 + i);
                        if (wx < nx && wy < ny) {
                            for (let di = -1; di <= 1; di++) {
                                for (let dj = -1; dj <= 1; dj++) {
                                    obstacle[wx + di][wy + dj] = 1;
                                }
                            }
                        }
                    }
                    break;

                case 'refraction':
                    params.sourceType = 'plane';
                    document.getElementById('typePlane').checked = true;

                    // Refracting medium on right half
                    for (let i = Math.floor(nx * 0.5); i < nx; i++) {
                        for (let j = 0; j < ny; j++) {
                            obstacle[i][j] = 3;
                        }
                    }
                    break;

                case 'standing':
                    params.sourceType = 'plane';
                    document.getElementById('typePlane').checked = true;

                    // Reflecting wall on right
                    for (let j = 0; j < ny; j++) {
                        for (let di = 0; di < 5; di++) {
                            obstacle[nx - 10 - di][j] = 1;
                        }
                    }
                    break;
            }

            if (!running) draw();
        }
        window.loadPreset = loadPreset;

        // Mouse handlers for drawing obstacles
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            lastMousePos = getMousePos(e);
            drawObstacle(lastMousePos);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                const pos = getMousePos(e);
                drawLine(lastMousePos, pos);
                lastMousePos = pos;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
            lastMousePos = null;
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
            lastMousePos = null;
        });

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: Math.floor((e.clientX - rect.left) / scale),
                y: Math.floor((e.clientY - rect.top) / scale)
            };
        }

        function drawObstacle(pos) {
            const obstType = document.querySelector('input[name="obstacleType"]:checked').id;
            const typeValue = obstType === 'obstWall' ? 1 :
                             obstType === 'obstAbsorb' ? 2 : 3;

            const radius = 3;
            for (let di = -radius; di <= radius; di++) {
                for (let dj = -radius; dj <= radius; dj++) {
                    if (di*di + dj*dj <= radius*radius) {
                        const ni = pos.x + di;
                        const nj = pos.y + dj;
                        if (ni >= 0 && ni < nx && nj >= 0 && nj < ny) {
                            obstacle[ni][nj] = typeValue;
                        }
                    }
                }
            }

            if (!running) draw();
        }

        function drawLine(from, to) {
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const steps = Math.max(Math.abs(dx), Math.abs(dy));

            for (let i = 0; i <= steps; i++) {
                const t = steps > 0 ? i / steps : 0;
                const x = Math.floor(from.x + dx * t);
                const y = Math.floor(from.y + dy * t);
                drawObstacle({ x, y });
            }
        }

        // Animation loop
        function animate() {
            if (!running) return;

            updateWave();
            addSource();
            draw();

            animationId = requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
            if (running) animate();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            if (animationId) cancelAnimationFrame(animationId);
            initArrays();
            draw();
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            for (let i = 0; i < nx; i++) {
                for (let j = 0; j < ny; j++) {
                    obstacle[i][j] = 0;
                }
            }
            if (!running) draw();
        });

        document.querySelectorAll('input[name="sourceType"]').forEach(input => {
            input.addEventListener('change', function() {
                if (this.id === 'typePoint') params.sourceType = 'point';
                else if (this.id === 'typePlane') params.sourceType = 'plane';
                else if (this.id === 'typeMoving') params.sourceType = 'moving';

                source.x = nx / 2;
                source.y = ny / 2;
                source.vx = 0;
            });
        });

        document.getElementById('freq').addEventListener('input', function() {
            params.frequency = parseFloat(this.value);
            document.getElementById('freqVal').textContent = this.value;
        });

        document.getElementById('speed').addEventListener('input', function() {
            params.waveSpeed = parseFloat(this.value);
            document.getElementById('speedVal').textContent = this.value;
        });

        document.getElementById('amp').addEventListener('input', function() {
            params.amplitude = parseFloat(this.value);
            document.getElementById('ampVal').textContent = this.value;
        });

        document.getElementById('damp').addEventListener('input', function() {
            params.damping = parseFloat(this.value);
            document.getElementById('dampVal').textContent = this.value;
        });

        // Initialize
        initArrays();
        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
