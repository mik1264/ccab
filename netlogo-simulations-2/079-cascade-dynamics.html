<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Social Cascade Dynamics - NetLogo-Style Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            padding: 20px;
            color: #e0e0e0;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #e74c3c, #9b59b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #aaa;
            font-size: 1.1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            gap: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .panel h3 {
            color: #e74c3c;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(231, 76, 60, 0.3);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
            font-size: 0.9em;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .control-group .value {
            text-align: right;
            font-size: 0.85em;
            color: #e74c3c;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 80px;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #e74c3c, #9b59b6);
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .btn-trigger {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .canvas-wrapper {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        .canvas-wrapper h4 {
            text-align: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            color: #e74c3c;
            font-size: 0.95em;
        }

        canvas {
            display: block;
            width: 100%;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-box .value {
            font-size: 1.4em;
            font-weight: bold;
            color: #e74c3c;
        }

        .stat-box .label {
            font-size: 0.75em;
            color: #aaa;
            margin-top: 3px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8em;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }

        .info-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .cascade-status {
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .cascade-dormant {
            background: rgba(52, 73, 94, 0.3);
            color: #7f8c8d;
        }

        .cascade-spreading {
            background: rgba(231, 76, 60, 0.3);
            color: #e74c3c;
        }

        .cascade-global {
            background: rgba(155, 89, 182, 0.3);
            color: #9b59b6;
        }

        .cascade-failed {
            background: rgba(127, 140, 141, 0.3);
            color: #95a5a6;
        }

        .scenario-list {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .scenario-item {
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .scenario-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .scenario-item.active {
            background: rgba(231, 76, 60, 0.3);
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #e74c3c;
            text-decoration: none;
            font-size: 1.1em;
            z-index: 1000;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        @media (max-width: 1400px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .canvas-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="container">
        <header>
            <h1>Social Cascade Dynamics</h1>
            <p class="subtitle">Threshold Models for Fads, Bank Runs, and Information Cascades</p>
        </header>

        <div class="main-content">
            <div class="panel">
                <h3>Network Parameters</h3>

                <div class="control-group">
                    <label>Network Size</label>
                    <input type="range" id="networkSize" min="50" max="500" value="200">
                    <div class="value"><span id="networkSizeVal">200</span> nodes</div>
                </div>

                <div class="control-group">
                    <label>Network Type</label>
                    <select id="networkType">
                        <option value="scaleFree">Scale-Free (Barabasi-Albert)</option>
                        <option value="smallWorld">Small World (Watts-Strogatz)</option>
                        <option value="random">Random (Erdos-Renyi)</option>
                        <option value="lattice">2D Lattice</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Average Degree</label>
                    <input type="range" id="avgDegree" min="2" max="20" value="6">
                    <div class="value"><span id="avgDegreeVal">6</span></div>
                </div>

                <h3>Threshold Model</h3>

                <div class="control-group">
                    <label>Threshold Distribution</label>
                    <select id="thresholdDist">
                        <option value="uniform">Uniform</option>
                        <option value="normal">Normal</option>
                        <option value="bimodal">Bimodal</option>
                        <option value="fixed">Fixed</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Mean Threshold</label>
                    <input type="range" id="meanThreshold" min="0" max="1" step="0.01" value="0.25">
                    <div class="value"><span id="meanThresholdVal">0.25</span></div>
                </div>

                <div class="control-group">
                    <label>Threshold Variance</label>
                    <input type="range" id="thresholdVar" min="0" max="0.3" step="0.01" value="0.1">
                    <div class="value"><span id="thresholdVarVal">0.10</span></div>
                </div>

                <h3>Cascade Trigger</h3>

                <div class="control-group">
                    <label>Initial Seeds</label>
                    <input type="range" id="initialSeeds" min="1" max="20" value="3">
                    <div class="value"><span id="initialSeedsVal">3</span></div>
                </div>

                <div class="control-group">
                    <label>Seed Placement</label>
                    <select id="seedPlacement">
                        <option value="random">Random</option>
                        <option value="hubs">High-Degree Hubs</option>
                        <option value="periphery">Low-Degree Periphery</option>
                        <option value="cluster">Clustered</option>
                    </select>
                </div>

                <div class="button-group">
                    <button class="btn-trigger" id="triggerBtn">Trigger Cascade</button>
                </div>

                <h3>Simulation Control</h3>

                <div class="button-group">
                    <button class="btn-primary" id="stepBtn">Step</button>
                    <button class="btn-secondary" id="runBtn">Run</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="control-group">
                    <label>Animation Speed</label>
                    <input type="range" id="speed" min="100" max="2000" value="500">
                    <div class="value"><span id="speedVal">500</span>ms</div>
                </div>
            </div>

            <div class="panel">
                <div class="canvas-container">
                    <div class="canvas-wrapper">
                        <h4>Network Cascade</h4>
                        <canvas id="networkCanvas" width="400" height="350"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <h4>Adoption Curve</h4>
                        <canvas id="adoptionCanvas" width="400" height="350"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <h4>Cascade Size Distribution</h4>
                        <canvas id="sizeDistCanvas" width="400" height="250"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <h4>Threshold Distribution</h4>
                        <canvas id="thresholdCanvas" width="400" height="250"></canvas>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Cascade Status</h3>

                <div class="cascade-status cascade-dormant" id="cascadeStatus">DORMANT</div>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="timeStep">0</div>
                        <div class="label">Time Step</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="activeNodes">0</div>
                        <div class="label">Active Nodes</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="cascadeSize">0.0</div>
                        <div class="label">Cascade Size (%)</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="cascadeSpeed">0</div>
                        <div class="label">New This Step</div>
                    </div>
                </div>

                <h3>Network Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="avgDegreeDisplay">0</div>
                        <div class="label">Avg Degree</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="clusteringCoef">0.00</div>
                        <div class="label">Clustering</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="numTrials">0</div>
                        <div class="label">Trials Run</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="globalCascadeProb">0.0</div>
                        <div class="label">Global Cascade %</div>
                    </div>
                </div>

                <h3>Scenarios</h3>
                <div class="scenario-list">
                    <div class="scenario-item" data-scenario="fad" onclick="setScenario('fad')">
                        <strong>Fashion Fad</strong><br>
                        <small>Low threshold, scale-free network</small>
                    </div>
                    <div class="scenario-item" data-scenario="bankrun" onclick="setScenario('bankrun')">
                        <strong>Bank Run</strong><br>
                        <small>Bimodal thresholds, high clustering</small>
                    </div>
                    <div class="scenario-item" data-scenario="revolution" onclick="setScenario('revolution')">
                        <strong>Political Revolution</strong><br>
                        <small>Normal thresholds, small-world</small>
                    </div>
                    <div class="scenario-item" data-scenario="innovation" onclick="setScenario('innovation')">
                        <strong>Innovation Adoption</strong><br>
                        <small>High threshold, targeted seeding</small>
                    </div>
                </div>

                <h3>Legend</h3>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db;"></div>
                        <span>Inactive</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>Active (Seed)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f39c12;"></div>
                        <span>Active (Cascade)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #9b59b6;"></div>
                        <span>Recently Activated</span>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Threshold Model:</strong><br>
                    Each node activates when the fraction of active neighbors exceeds its threshold.
                    Global cascades occur when the cascade reaches >50% of the network.
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const networkCanvas = document.getElementById('networkCanvas');
        const adoptionCanvas = document.getElementById('adoptionCanvas');
        const sizeDistCanvas = document.getElementById('sizeDistCanvas');
        const thresholdCanvas = document.getElementById('thresholdCanvas');

        const netCtx = networkCanvas.getContext('2d');
        const adoptCtx = adoptionCanvas.getContext('2d');
        const sizeCtx = sizeDistCanvas.getContext('2d');
        const threshCtx = thresholdCanvas.getContext('2d');

        // Simulation state
        let nodes = [];
        let edges = [];
        let timeStep = 0;
        let isRunning = false;
        let runTimeout = null;
        let adoptionHistory = [];
        let cascadeSizeHistory = [];
        let numTrials = 0;
        let globalCascades = 0;

        // Parameters
        let networkSize = 200;
        let networkType = 'scaleFree';
        let avgDegree = 6;
        let thresholdDist = 'uniform';
        let meanThreshold = 0.25;
        let thresholdVar = 0.1;
        let initialSeeds = 3;
        let seedPlacement = 'random';
        let animSpeed = 500;

        // UI Elements
        const elements = {
            networkSize: document.getElementById('networkSize'),
            networkSizeVal: document.getElementById('networkSizeVal'),
            networkType: document.getElementById('networkType'),
            avgDegree: document.getElementById('avgDegree'),
            avgDegreeVal: document.getElementById('avgDegreeVal'),
            thresholdDist: document.getElementById('thresholdDist'),
            meanThreshold: document.getElementById('meanThreshold'),
            meanThresholdVal: document.getElementById('meanThresholdVal'),
            thresholdVar: document.getElementById('thresholdVar'),
            thresholdVarVal: document.getElementById('thresholdVarVal'),
            initialSeeds: document.getElementById('initialSeeds'),
            initialSeedsVal: document.getElementById('initialSeedsVal'),
            seedPlacement: document.getElementById('seedPlacement'),
            speed: document.getElementById('speed'),
            speedVal: document.getElementById('speedVal'),
            triggerBtn: document.getElementById('triggerBtn'),
            stepBtn: document.getElementById('stepBtn'),
            runBtn: document.getElementById('runBtn'),
            resetBtn: document.getElementById('resetBtn'),
            timeStep: document.getElementById('timeStep'),
            activeNodes: document.getElementById('activeNodes'),
            cascadeSize: document.getElementById('cascadeSize'),
            cascadeSpeed: document.getElementById('cascadeSpeed'),
            avgDegreeDisplay: document.getElementById('avgDegreeDisplay'),
            clusteringCoef: document.getElementById('clusteringCoef'),
            numTrials: document.getElementById('numTrials'),
            globalCascadeProb: document.getElementById('globalCascadeProb'),
            cascadeStatus: document.getElementById('cascadeStatus')
        };

        // Generate threshold based on distribution
        function generateThreshold() {
            switch (thresholdDist) {
                case 'uniform':
                    const min = Math.max(0, meanThreshold - thresholdVar * 2);
                    const max = Math.min(1, meanThreshold + thresholdVar * 2);
                    return min + Math.random() * (max - min);

                case 'normal':
                    const u1 = Math.random();
                    const u2 = Math.random();
                    const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                    return Math.max(0, Math.min(1, meanThreshold + z * thresholdVar));

                case 'bimodal':
                    // Two peaks: one low, one high
                    if (Math.random() < 0.5) {
                        return Math.max(0, Math.min(1, 0.1 + (Math.random() - 0.5) * thresholdVar));
                    } else {
                        return Math.max(0, Math.min(1, 0.5 + (Math.random() - 0.5) * thresholdVar));
                    }

                case 'fixed':
                    return meanThreshold;

                default:
                    return meanThreshold;
            }
        }

        // Create network
        function createNetwork() {
            nodes = [];
            edges = [];
            timeStep = 0;
            adoptionHistory = [];

            const width = networkCanvas.width;
            const height = networkCanvas.height;

            // Create nodes
            for (let i = 0; i < networkSize; i++) {
                const angle = (i / networkSize) * Math.PI * 2;
                const radius = Math.min(width, height) * 0.35;

                nodes.push({
                    id: i,
                    x: width / 2 + radius * Math.cos(angle),
                    y: height / 2 + radius * Math.sin(angle),
                    active: false,
                    isSeed: false,
                    activatedAt: -1,
                    threshold: generateThreshold(),
                    neighbors: [],
                    degree: 0
                });
            }

            // Create edges based on network type
            switch (networkType) {
                case 'scaleFree':
                    createScaleFreeNetwork();
                    break;
                case 'smallWorld':
                    createSmallWorldNetwork();
                    break;
                case 'random':
                    createRandomNetwork();
                    break;
                case 'lattice':
                    createLatticeNetwork();
                    break;
            }

            // Update neighbor lists and degrees
            nodes.forEach(node => node.neighbors = []);
            edges.forEach(edge => {
                nodes[edge[0]].neighbors.push(edge[1]);
                nodes[edge[1]].neighbors.push(edge[0]);
            });
            nodes.forEach(node => node.degree = node.neighbors.length);

            // Apply force-directed layout (simplified)
            applyForceLayout();

            updateStats();
            draw();
        }

        function createScaleFreeNetwork() {
            const m = Math.floor(avgDegree / 2);
            const degree = new Array(networkSize).fill(0);

            // Start with fully connected core
            for (let i = 0; i < m + 1; i++) {
                for (let j = i + 1; j < m + 1; j++) {
                    edges.push([i, j]);
                    degree[i]++;
                    degree[j]++;
                }
            }

            // Preferential attachment
            for (let i = m + 1; i < networkSize; i++) {
                const totalDegree = degree.reduce((a, b) => a + b, 0);
                const connected = new Set();

                while (connected.size < m) {
                    let target = 0;
                    let cumulative = 0;
                    const r = Math.random() * totalDegree;

                    for (let j = 0; j < i; j++) {
                        cumulative += degree[j] + 1;
                        if (cumulative >= r) {
                            target = j;
                            break;
                        }
                    }

                    if (!connected.has(target)) {
                        connected.add(target);
                        edges.push([i, target]);
                        degree[i]++;
                        degree[target]++;
                    }
                }
            }
        }

        function createSmallWorldNetwork() {
            const k = Math.floor(avgDegree / 2);
            const rewiringProb = 0.1;

            // Ring lattice
            for (let i = 0; i < networkSize; i++) {
                for (let j = 1; j <= k; j++) {
                    const target = (i + j) % networkSize;
                    edges.push([i, target]);
                }
            }

            // Rewiring
            edges.forEach((edge, idx) => {
                if (Math.random() < rewiringProb) {
                    const newTarget = Math.floor(Math.random() * networkSize);
                    if (newTarget !== edge[0] && newTarget !== edge[1]) {
                        edges[idx] = [edge[0], newTarget];
                    }
                }
            });
        }

        function createRandomNetwork() {
            const edgeProb = avgDegree / networkSize;
            for (let i = 0; i < networkSize; i++) {
                for (let j = i + 1; j < networkSize; j++) {
                    if (Math.random() < edgeProb) {
                        edges.push([i, j]);
                    }
                }
            }
        }

        function createLatticeNetwork() {
            const width = networkCanvas.width;
            const height = networkCanvas.height;
            const cols = Math.ceil(Math.sqrt(networkSize));
            const cellWidth = width / cols;
            const cellHeight = height / cols;

            // Position nodes in grid
            nodes.forEach((node, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                node.x = cellWidth * (col + 0.5);
                node.y = cellHeight * (row + 0.5);
            });

            // Connect neighbors
            for (let i = 0; i < networkSize; i++) {
                const col = i % cols;
                if (col < cols - 1 && i + 1 < networkSize) {
                    edges.push([i, i + 1]);
                }
                if (i + cols < networkSize) {
                    edges.push([i, i + cols]);
                }
            }
        }

        // Apply simple force-directed layout
        function applyForceLayout() {
            if (networkType === 'lattice') return;

            const width = networkCanvas.width;
            const height = networkCanvas.height;

            for (let iter = 0; iter < 50; iter++) {
                // Repulsion between all nodes
                nodes.forEach(node => {
                    node.fx = 0;
                    node.fy = 0;
                });

                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const dx = nodes[j].x - nodes[i].x;
                        const dy = nodes[j].y - nodes[i].y;
                        const dist = Math.sqrt(dx * dx + dy * dy) + 1;
                        const force = 500 / (dist * dist);

                        nodes[i].fx -= force * dx / dist;
                        nodes[i].fy -= force * dy / dist;
                        nodes[j].fx += force * dx / dist;
                        nodes[j].fy += force * dy / dist;
                    }
                }

                // Attraction along edges
                edges.forEach(edge => {
                    const n1 = nodes[edge[0]];
                    const n2 = nodes[edge[1]];
                    const dx = n2.x - n1.x;
                    const dy = n2.y - n1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) + 1;
                    const force = dist * 0.01;

                    n1.fx += force * dx / dist;
                    n1.fy += force * dy / dist;
                    n2.fx -= force * dx / dist;
                    n2.fy -= force * dy / dist;
                });

                // Center attraction
                nodes.forEach(node => {
                    node.fx += (width / 2 - node.x) * 0.01;
                    node.fy += (height / 2 - node.y) * 0.01;
                });

                // Apply forces
                nodes.forEach(node => {
                    node.x += node.fx * 0.5;
                    node.y += node.fy * 0.5;
                    node.x = Math.max(20, Math.min(width - 20, node.x));
                    node.y = Math.max(20, Math.min(height - 20, node.y));
                });
            }
        }

        // Trigger cascade with seeds
        function triggerCascade() {
            // Reset all nodes
            nodes.forEach(node => {
                node.active = false;
                node.isSeed = false;
                node.activatedAt = -1;
            });
            timeStep = 0;
            adoptionHistory = [];

            // Select seeds based on placement strategy
            let seedIndices = [];

            switch (seedPlacement) {
                case 'random':
                    const shuffled = [...Array(networkSize).keys()].sort(() => Math.random() - 0.5);
                    seedIndices = shuffled.slice(0, initialSeeds);
                    break;

                case 'hubs':
                    const byDegree = [...nodes].sort((a, b) => b.degree - a.degree);
                    seedIndices = byDegree.slice(0, initialSeeds).map(n => n.id);
                    break;

                case 'periphery':
                    const byDegreeLow = [...nodes].sort((a, b) => a.degree - b.degree);
                    seedIndices = byDegreeLow.slice(0, initialSeeds).map(n => n.id);
                    break;

                case 'cluster':
                    // Start with one random, then add neighbors
                    const start = Math.floor(Math.random() * networkSize);
                    seedIndices = [start];
                    const candidates = [...nodes[start].neighbors];

                    while (seedIndices.length < initialSeeds && candidates.length > 0) {
                        const nextIdx = Math.floor(Math.random() * candidates.length);
                        const next = candidates.splice(nextIdx, 1)[0];
                        if (!seedIndices.includes(next)) {
                            seedIndices.push(next);
                            candidates.push(...nodes[next].neighbors);
                        }
                    }
                    break;
            }

            // Activate seeds
            seedIndices.forEach(idx => {
                nodes[idx].active = true;
                nodes[idx].isSeed = true;
                nodes[idx].activatedAt = 0;
            });

            adoptionHistory.push(seedIndices.length / networkSize);
            updateStats();
            draw();
        }

        // Single cascade step
        function cascadeStep() {
            timeStep++;
            let newlyActivated = 0;

            // Check each inactive node
            nodes.forEach(node => {
                if (node.active) return;

                // Count active neighbors
                const activeNeighbors = node.neighbors.filter(nIdx => nodes[nIdx].active).length;
                const fractionActive = node.neighbors.length > 0 ?
                    activeNeighbors / node.neighbors.length : 0;

                // Threshold check
                if (fractionActive >= node.threshold) {
                    node.active = true;
                    node.activatedAt = timeStep;
                    newlyActivated++;
                }
            });

            // Record adoption
            const activeCount = nodes.filter(n => n.active).length;
            adoptionHistory.push(activeCount / networkSize);

            updateStats();
            draw();

            return newlyActivated;
        }

        // Run cascade to completion
        function runCascade() {
            if (isRunning) {
                isRunning = false;
                elements.runBtn.textContent = 'Run';
                if (runTimeout) clearTimeout(runTimeout);
                return;
            }

            isRunning = true;
            elements.runBtn.textContent = 'Stop';

            function step() {
                if (!isRunning) return;

                const newlyActivated = cascadeStep();

                if (newlyActivated > 0) {
                    runTimeout = setTimeout(step, animSpeed);
                } else {
                    // Cascade complete
                    isRunning = false;
                    elements.runBtn.textContent = 'Run';
                    recordCascadeResult();
                }
            }

            step();
        }

        // Record cascade result for statistics
        function recordCascadeResult() {
            const cascadeSize = nodes.filter(n => n.active).length / networkSize;
            cascadeSizeHistory.push(cascadeSize);
            numTrials++;

            if (cascadeSize > 0.5) {
                globalCascades++;
            }

            // Limit history
            if (cascadeSizeHistory.length > 100) {
                cascadeSizeHistory.shift();
            }

            updateStats();
            draw();
        }

        // Update statistics
        function updateStats() {
            elements.timeStep.textContent = timeStep;

            const activeCount = nodes.filter(n => n.active).length;
            elements.activeNodes.textContent = activeCount;
            elements.cascadeSize.textContent = (activeCount / networkSize * 100).toFixed(1);

            // Calculate new activations this step
            const newThisStep = nodes.filter(n => n.activatedAt === timeStep).length;
            elements.cascadeSpeed.textContent = newThisStep;

            // Network stats
            const totalDegree = nodes.reduce((sum, n) => sum + n.degree, 0);
            elements.avgDegreeDisplay.textContent = (totalDegree / networkSize).toFixed(1);

            // Simplified clustering coefficient
            let triangles = 0;
            let triplets = 0;
            nodes.forEach(node => {
                const neighbors = node.neighbors;
                const k = neighbors.length;
                if (k < 2) return;

                triplets += k * (k - 1) / 2;
                for (let i = 0; i < neighbors.length; i++) {
                    for (let j = i + 1; j < neighbors.length; j++) {
                        if (nodes[neighbors[i]].neighbors.includes(neighbors[j])) {
                            triangles++;
                        }
                    }
                }
            });
            const clustering = triplets > 0 ? triangles / triplets : 0;
            elements.clusteringCoef.textContent = clustering.toFixed(2);

            elements.numTrials.textContent = numTrials;
            elements.globalCascadeProb.textContent = numTrials > 0 ?
                (globalCascades / numTrials * 100).toFixed(1) : '0.0';

            // Update cascade status
            const cascadeFraction = activeCount / networkSize;
            elements.cascadeStatus.className = 'cascade-status';

            if (timeStep === 0) {
                elements.cascadeStatus.classList.add('cascade-dormant');
                elements.cascadeStatus.textContent = 'DORMANT';
            } else if (newThisStep > 0) {
                elements.cascadeStatus.classList.add('cascade-spreading');
                elements.cascadeStatus.textContent = 'SPREADING';
            } else if (cascadeFraction > 0.5) {
                elements.cascadeStatus.classList.add('cascade-global');
                elements.cascadeStatus.textContent = 'GLOBAL CASCADE';
            } else {
                elements.cascadeStatus.classList.add('cascade-failed');
                elements.cascadeStatus.textContent = 'CASCADE STOPPED';
            }
        }

        // Draw network
        function drawNetwork() {
            const width = networkCanvas.width;
            const height = networkCanvas.height;

            netCtx.clearRect(0, 0, width, height);
            netCtx.fillStyle = '#1a1a2e';
            netCtx.fillRect(0, 0, width, height);

            // Draw edges
            netCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            netCtx.lineWidth = 0.5;

            edges.forEach(edge => {
                const n1 = nodes[edge[0]];
                const n2 = nodes[edge[1]];

                // Highlight edges between active nodes
                if (n1.active && n2.active) {
                    netCtx.strokeStyle = 'rgba(231, 76, 60, 0.3)';
                    netCtx.lineWidth = 1;
                } else {
                    netCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    netCtx.lineWidth = 0.5;
                }

                netCtx.beginPath();
                netCtx.moveTo(n1.x, n1.y);
                netCtx.lineTo(n2.x, n2.y);
                netCtx.stroke();
            });

            // Draw nodes
            nodes.forEach(node => {
                let color;
                let radius = 3 + Math.log(node.degree + 1) * 2;

                if (!node.active) {
                    color = '#3498db';
                } else if (node.isSeed) {
                    color = '#e74c3c';
                    radius += 2;
                } else if (node.activatedAt === timeStep) {
                    color = '#9b59b6';
                    radius += 1;
                } else {
                    color = '#f39c12';
                }

                netCtx.fillStyle = color;
                netCtx.beginPath();
                netCtx.arc(node.x, node.y, radius, 0, Math.PI * 2);
                netCtx.fill();
            });
        }

        // Draw adoption curve
        function drawAdoption() {
            const width = adoptionCanvas.width;
            const height = adoptionCanvas.height;
            const margin = { top: 30, right: 30, bottom: 40, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            adoptCtx.clearRect(0, 0, width, height);
            adoptCtx.fillStyle = '#1a1a2e';
            adoptCtx.fillRect(0, 0, width, height);

            // Axes
            adoptCtx.strokeStyle = '#666';
            adoptCtx.lineWidth = 1;
            adoptCtx.beginPath();
            adoptCtx.moveTo(margin.left, margin.top);
            adoptCtx.lineTo(margin.left, height - margin.bottom);
            adoptCtx.lineTo(width - margin.right, height - margin.bottom);
            adoptCtx.stroke();

            // Labels
            adoptCtx.fillStyle = '#aaa';
            adoptCtx.font = '11px sans-serif';
            adoptCtx.textAlign = 'center';
            adoptCtx.fillText('Time Step', width / 2, height - 5);

            adoptCtx.save();
            adoptCtx.translate(12, height / 2);
            adoptCtx.rotate(-Math.PI / 2);
            adoptCtx.fillText('Adoption Fraction', 0, 0);
            adoptCtx.restore();

            if (adoptionHistory.length < 2) return;

            // Draw S-curve
            adoptCtx.strokeStyle = '#e74c3c';
            adoptCtx.lineWidth = 2;
            adoptCtx.beginPath();

            adoptionHistory.forEach((adoption, i) => {
                const x = margin.left + (i / Math.max(adoptionHistory.length - 1, 1)) * chartWidth;
                const y = margin.top + (1 - adoption) * chartHeight;

                if (i === 0) {
                    adoptCtx.moveTo(x, y);
                } else {
                    adoptCtx.lineTo(x, y);
                }
            });
            adoptCtx.stroke();

            // Draw 50% threshold line
            adoptCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            adoptCtx.setLineDash([5, 5]);
            adoptCtx.beginPath();
            adoptCtx.moveTo(margin.left, margin.top + chartHeight * 0.5);
            adoptCtx.lineTo(width - margin.right, margin.top + chartHeight * 0.5);
            adoptCtx.stroke();
            adoptCtx.setLineDash([]);

            // Y-axis labels
            adoptCtx.fillStyle = '#aaa';
            adoptCtx.font = '10px sans-serif';
            adoptCtx.textAlign = 'right';

            for (let p = 0; p <= 1; p += 0.25) {
                const y = margin.top + (1 - p) * chartHeight;
                adoptCtx.fillText((p * 100).toFixed(0) + '%', margin.left - 5, y + 4);
            }
        }

        // Draw cascade size distribution
        function drawSizeDistribution() {
            const width = sizeDistCanvas.width;
            const height = sizeDistCanvas.height;
            const margin = { top: 20, right: 20, bottom: 35, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            sizeCtx.clearRect(0, 0, width, height);
            sizeCtx.fillStyle = '#1a1a2e';
            sizeCtx.fillRect(0, 0, width, height);

            // Axes
            sizeCtx.strokeStyle = '#666';
            sizeCtx.lineWidth = 1;
            sizeCtx.beginPath();
            sizeCtx.moveTo(margin.left, margin.top);
            sizeCtx.lineTo(margin.left, height - margin.bottom);
            sizeCtx.lineTo(width - margin.right, height - margin.bottom);
            sizeCtx.stroke();

            // Labels
            sizeCtx.fillStyle = '#aaa';
            sizeCtx.font = '10px sans-serif';
            sizeCtx.textAlign = 'center';
            sizeCtx.fillText('Cascade Size', width / 2, height - 5);

            sizeCtx.save();
            sizeCtx.translate(10, height / 2);
            sizeCtx.rotate(-Math.PI / 2);
            sizeCtx.fillText('Frequency', 0, 0);
            sizeCtx.restore();

            if (cascadeSizeHistory.length === 0) {
                sizeCtx.fillStyle = '#666';
                sizeCtx.font = '12px sans-serif';
                sizeCtx.textAlign = 'center';
                sizeCtx.fillText('Run trials to see distribution', width / 2, height / 2);
                return;
            }

            // Create histogram
            const numBins = 20;
            const bins = new Array(numBins).fill(0);

            cascadeSizeHistory.forEach(size => {
                const bin = Math.min(numBins - 1, Math.floor(size * numBins));
                bins[bin]++;
            });

            const maxCount = Math.max(...bins, 1);
            const barWidth = chartWidth / numBins;

            bins.forEach((count, i) => {
                const x = margin.left + i * barWidth;
                const barHeight = (count / maxCount) * chartHeight;
                const y = margin.top + chartHeight - barHeight;

                // Color based on size (small = blue, large = red)
                const hue = 0 + (240 - 0) * (1 - i / numBins);
                sizeCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                sizeCtx.fillRect(x, y, barWidth - 1, barHeight);
            });

            // Mark 50% threshold
            const threshX = margin.left + 0.5 * chartWidth;
            sizeCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            sizeCtx.setLineDash([5, 5]);
            sizeCtx.beginPath();
            sizeCtx.moveTo(threshX, margin.top);
            sizeCtx.lineTo(threshX, height - margin.bottom);
            sizeCtx.stroke();
            sizeCtx.setLineDash([]);

            sizeCtx.fillStyle = '#aaa';
            sizeCtx.fillText('Global', threshX, height - margin.bottom + 12);
        }

        // Draw threshold distribution
        function drawThresholdDistribution() {
            const width = thresholdCanvas.width;
            const height = thresholdCanvas.height;
            const margin = { top: 20, right: 20, bottom: 35, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            threshCtx.clearRect(0, 0, width, height);
            threshCtx.fillStyle = '#1a1a2e';
            threshCtx.fillRect(0, 0, width, height);

            // Axes
            threshCtx.strokeStyle = '#666';
            threshCtx.lineWidth = 1;
            threshCtx.beginPath();
            threshCtx.moveTo(margin.left, margin.top);
            threshCtx.lineTo(margin.left, height - margin.bottom);
            threshCtx.lineTo(width - margin.right, height - margin.bottom);
            threshCtx.stroke();

            // Labels
            threshCtx.fillStyle = '#aaa';
            threshCtx.font = '10px sans-serif';
            threshCtx.textAlign = 'center';
            threshCtx.fillText('Threshold', width / 2, height - 5);

            threshCtx.save();
            threshCtx.translate(10, height / 2);
            threshCtx.rotate(-Math.PI / 2);
            threshCtx.fillText('Count', 0, 0);
            threshCtx.restore();

            // Create histogram
            const numBins = 20;
            const bins = new Array(numBins).fill(0);

            nodes.forEach(node => {
                const bin = Math.min(numBins - 1, Math.floor(node.threshold * numBins));
                bins[bin]++;
            });

            const maxCount = Math.max(...bins, 1);
            const barWidth = chartWidth / numBins;

            bins.forEach((count, i) => {
                const x = margin.left + i * barWidth;
                const barHeight = (count / maxCount) * chartHeight;
                const y = margin.top + chartHeight - barHeight;

                threshCtx.fillStyle = '#9b59b6';
                threshCtx.fillRect(x, y, barWidth - 1, barHeight);
            });

            // Mark mean threshold
            const meanX = margin.left + meanThreshold * chartWidth;
            threshCtx.strokeStyle = 'rgba(243, 156, 18, 0.8)';
            threshCtx.lineWidth = 2;
            threshCtx.beginPath();
            threshCtx.moveTo(meanX, margin.top);
            threshCtx.lineTo(meanX, height - margin.bottom);
            threshCtx.stroke();

            threshCtx.fillStyle = '#f39c12';
            threshCtx.font = '10px sans-serif';
            threshCtx.fillText('Mean', meanX, margin.top - 5);
        }

        // Main draw function
        function draw() {
            drawNetwork();
            drawAdoption();
            drawSizeDistribution();
            drawThresholdDistribution();
        }

        // Set predefined scenario
        function setScenario(scenario) {
            // Remove active class from all
            document.querySelectorAll('.scenario-item').forEach(el => el.classList.remove('active'));
            document.querySelector(`[data-scenario="${scenario}"]`)?.classList.add('active');

            switch (scenario) {
                case 'fad':
                    elements.networkType.value = 'scaleFree';
                    elements.thresholdDist.value = 'uniform';
                    elements.meanThreshold.value = 0.15;
                    elements.thresholdVar.value = 0.1;
                    elements.seedPlacement.value = 'hubs';
                    break;

                case 'bankrun':
                    elements.networkType.value = 'smallWorld';
                    elements.thresholdDist.value = 'bimodal';
                    elements.meanThreshold.value = 0.3;
                    elements.thresholdVar.value = 0.15;
                    elements.seedPlacement.value = 'cluster';
                    break;

                case 'revolution':
                    elements.networkType.value = 'smallWorld';
                    elements.thresholdDist.value = 'normal';
                    elements.meanThreshold.value = 0.35;
                    elements.thresholdVar.value = 0.15;
                    elements.seedPlacement.value = 'random';
                    break;

                case 'innovation':
                    elements.networkType.value = 'scaleFree';
                    elements.thresholdDist.value = 'normal';
                    elements.meanThreshold.value = 0.4;
                    elements.thresholdVar.value = 0.1;
                    elements.seedPlacement.value = 'hubs';
                    break;
            }

            // Update parameters
            networkType = elements.networkType.value;
            thresholdDist = elements.thresholdDist.value;
            meanThreshold = parseFloat(elements.meanThreshold.value);
            thresholdVar = parseFloat(elements.thresholdVar.value);
            seedPlacement = elements.seedPlacement.value;

            // Update displays
            elements.meanThresholdVal.textContent = meanThreshold.toFixed(2);
            elements.thresholdVarVal.textContent = thresholdVar.toFixed(2);

            createNetwork();
        }

        // Make setScenario globally available
        window.setScenario = setScenario;

        // Event listeners
        elements.networkSize.addEventListener('input', (e) => {
            networkSize = parseInt(e.target.value);
            elements.networkSizeVal.textContent = networkSize;
        });

        elements.networkType.addEventListener('change', (e) => {
            networkType = e.target.value;
        });

        elements.avgDegree.addEventListener('input', (e) => {
            avgDegree = parseInt(e.target.value);
            elements.avgDegreeVal.textContent = avgDegree;
        });

        elements.thresholdDist.addEventListener('change', (e) => {
            thresholdDist = e.target.value;
        });

        elements.meanThreshold.addEventListener('input', (e) => {
            meanThreshold = parseFloat(e.target.value);
            elements.meanThresholdVal.textContent = meanThreshold.toFixed(2);
        });

        elements.thresholdVar.addEventListener('input', (e) => {
            thresholdVar = parseFloat(e.target.value);
            elements.thresholdVarVal.textContent = thresholdVar.toFixed(2);
        });

        elements.initialSeeds.addEventListener('input', (e) => {
            initialSeeds = parseInt(e.target.value);
            elements.initialSeedsVal.textContent = initialSeeds;
        });

        elements.seedPlacement.addEventListener('change', (e) => {
            seedPlacement = e.target.value;
        });

        elements.speed.addEventListener('input', (e) => {
            animSpeed = parseInt(e.target.value);
            elements.speedVal.textContent = animSpeed;
        });

        elements.triggerBtn.addEventListener('click', triggerCascade);
        elements.stepBtn.addEventListener('click', () => {
            const newlyActivated = cascadeStep();
            if (newlyActivated === 0 && timeStep > 0) {
                recordCascadeResult();
            }
        });
        elements.runBtn.addEventListener('click', runCascade);

        elements.resetBtn.addEventListener('click', () => {
            isRunning = false;
            elements.runBtn.textContent = 'Run';
            if (runTimeout) clearTimeout(runTimeout);
            createNetwork();
        });

        // Initialize
        createNetwork();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
