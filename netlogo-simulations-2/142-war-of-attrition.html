<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>War of Attrition - Timing Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { font-family: 'Lora', serif; color: #606C38; font-size: 2rem; margin-bottom: 8px; }
        .subtitle { color: #8A9A5B; font-size: 1rem; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #606C38; font-weight: 600; }
        .main-content { display: grid; grid-template-columns: 1fr 320px; gap: 20px; }
        .canvas-container { background: white; border-radius: 12px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        canvas { display: block; width: 100%; border-radius: 8px; }
        .controls { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; color: #606C38; font-weight: 600; margin-bottom: 5px; font-size: 0.9rem; }
        .control-group input[type="range"] { width: 100%; }
        .control-group .value { color: #8A9A5B; font-size: 0.85rem; }
        button { padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer; font-family: 'Nunito', sans-serif; font-weight: 600; margin-right: 8px; margin-bottom: 8px; }
        .btn-primary { background: #8A9A5B; color: white; }
        .btn-secondary { background: #DDA15E; color: white; }
        .stats-box { background: #FEFAE0; border-radius: 8px; padding: 12px; margin-top: 15px; }
        .stat { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #EDE8D5; }
        .stat:last-child { border-bottom: none; }
        .stat-label { color: #606C38; font-size: 0.85rem; }
        .stat-value { color: #BC6C25; font-weight: 600; font-size: 0.9rem; }
        .info-panel { margin-top: 20px; padding: 15px; background: white; border-radius: 12px; font-size: 0.85rem; color: #606C38; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        .contest-display { background: linear-gradient(135deg, #F0E6D3 0%, #E5D9C5 100%); border-radius: 12px; padding: 15px; margin-bottom: 15px; }
        .contestant { display: flex; justify-content: space-between; align-items: center; padding: 8px; background: white; border-radius: 8px; margin-bottom: 5px; }
        .contestant.active { border-left: 4px solid #8A9A5B; }
        .contestant.yielded { opacity: 0.5; border-left: 4px solid #E63946; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>War of Attrition</h1>
            <p class="subtitle">Asymmetric timing game with private valuations and bid distributions</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
            </div>

            <div class="controls">
                <div class="contest-display">
                    <div style="text-align: center; margin-bottom: 10px; font-weight: 600; color: #606C38;">
                        Current Contest - Time: <span id="timeDisplay">0</span>
                    </div>
                    <div class="contestant" id="player1">
                        <span>Player 1</span>
                        <span>Value: <span id="val1">?</span> | Cost: <span id="cost1">0</span></span>
                    </div>
                    <div class="contestant" id="player2">
                        <span>Player 2</span>
                        <span>Value: <span id="val2">?</span> | Cost: <span id="cost2">0</span></span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Max Resource Value: <span class="value" id="valueMax">100</span></label>
                    <input type="range" id="maxValue" min="50" max="500" value="100" step="10">
                </div>

                <div class="control-group">
                    <label>Cost per Time Unit: <span class="value" id="valueCost">1</span></label>
                    <input type="range" id="costPerTime" min="1" max="10" value="1">
                </div>

                <div class="control-group">
                    <label>Value Asymmetry: <span class="value" id="valueAsym">0.00</span></label>
                    <input type="range" id="asymmetry" min="0" max="100" value="0">
                </div>

                <div class="control-group">
                    <label>Population: <span class="value" id="valuePop">100</span></label>
                    <input type="range" id="population" min="20" max="200" value="100">
                </div>

                <button class="btn-primary" onclick="resetSimulation()">Reset</button>
                <button class="btn-secondary" onclick="togglePause()">Pause</button>
                <button class="btn-secondary" onclick="runContest()">New Contest</button>

                <div class="stats-box">
                    <div class="stat"><span class="stat-label">Contests Run:</span><span class="stat-value" id="contestsStat">0</span></div>
                    <div class="stat"><span class="stat-label">Avg Duration:</span><span class="stat-value" id="durationStat">0</span></div>
                    <div class="stat"><span class="stat-label">Avg Winner Value:</span><span class="stat-value" id="winnerValStat">0</span></div>
                    <div class="stat"><span class="stat-label">Higher Value Wins:</span><span class="stat-value" id="hiValWinStat">0%</span></div>
                    <div class="stat"><span class="stat-label">ESS (exponential λ):</span><span class="stat-value" id="essStat">-</span></div>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <strong>About this simulation:</strong> The War of Attrition (Maynard Smith, 1974) models contests where
            both players accumulate costs while waiting for the other to give up.
            The ESS is a <strong>mixed strategy</strong> with exponential bid distribution.
            With <strong>private information</strong> about valuations, players bid proportional to their value.
            Watch how asymmetric valuations affect contest outcomes and duration.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = 600 * dpr;
        canvas.style.height = '600px';
        ctx.scale(dpr, dpr);

        const width = rect.width;
        const height = 600;

        let maxValue = 100;
        let costPerTime = 1;
        let asymmetry = 0;
        let popSize = 100;

        let agents = [];
        let contestHistory = [];
        let currentContest = null;
        let paused = false;

        function initSimulation() {
            agents = [];
            contestHistory = [];

            for (let i = 0; i < popSize; i++) {
                agents.push({
                    // Strategy: multiplier for value-to-bid conversion
                    bidMultiplier: 0.5 + Math.random() * 1.5,
                    fitness: 0,
                    contestsWon: 0,
                    contestsLost: 0
                });
            }

            runContest();
        }

        function runContest() {
            // Select two random agents
            const idx1 = Math.floor(Math.random() * popSize);
            let idx2 = Math.floor(Math.random() * popSize);
            while (idx2 === idx1) idx2 = Math.floor(Math.random() * popSize);

            const agent1 = agents[idx1];
            const agent2 = agents[idx2];

            // Assign private valuations
            const baseValue1 = Math.random() * maxValue;
            const baseValue2 = Math.random() * maxValue;

            // Apply asymmetry (one player systematically values more)
            const value1 = baseValue1 * (1 + asymmetry);
            const value2 = baseValue2 * (1 - asymmetry);

            // Calculate bids based on strategy
            const bid1 = value1 * agent1.bidMultiplier;
            const bid2 = value2 * agent2.bidMultiplier;

            currentContest = {
                agent1, agent2,
                value1, value2,
                bid1, bid2,
                time: 0,
                cost1: 0,
                cost2: 0,
                winner: null,
                active: true
            };
        }

        function updateContest() {
            if (!currentContest || !currentContest.active) return;

            currentContest.time++;
            currentContest.cost1 = currentContest.time * costPerTime;
            currentContest.cost2 = currentContest.time * costPerTime;

            // Check if either player yields
            const yield1 = currentContest.time >= currentContest.bid1;
            const yield2 = currentContest.time >= currentContest.bid2;

            if (yield1 && yield2) {
                // Tie - random winner, both pay
                currentContest.winner = Math.random() < 0.5 ? 1 : 2;
                endContest();
            } else if (yield1) {
                currentContest.winner = 2;
                endContest();
            } else if (yield2) {
                currentContest.winner = 1;
                endContest();
            }
        }

        function endContest() {
            currentContest.active = false;

            const c = currentContest;
            const duration = c.time;

            // Winner gets value minus cost
            // Loser just pays cost
            if (c.winner === 1) {
                c.agent1.fitness += c.value1 - c.cost1;
                c.agent2.fitness -= c.cost2;
                c.agent1.contestsWon++;
                c.agent2.contestsLost++;
            } else {
                c.agent2.fitness += c.value2 - c.cost2;
                c.agent1.fitness -= c.cost1;
                c.agent2.contestsWon++;
                c.agent1.contestsLost++;
            }

            contestHistory.push({
                duration,
                value1: c.value1,
                value2: c.value2,
                winner: c.winner,
                higherValueWon: (c.winner === 1 && c.value1 > c.value2) ||
                               (c.winner === 2 && c.value2 > c.value1)
            });

            // Evolve strategies periodically
            if (contestHistory.length % 20 === 0) {
                evolveStrategies();
            }

            // Start new contest
            setTimeout(() => {
                if (!paused) runContest();
            }, 100);
        }

        function evolveStrategies() {
            const sortedAgents = [...agents].sort((a, b) => b.fitness - a.fitness);

            // Bottom performers learn from top performers
            const topHalf = sortedAgents.slice(0, popSize / 2);
            const bottomHalf = sortedAgents.slice(popSize / 2);

            bottomHalf.forEach(agent => {
                const model = topHalf[Math.floor(Math.random() * topHalf.length)];
                agent.bidMultiplier = model.bidMultiplier + (Math.random() - 0.5) * 0.2;
                agent.bidMultiplier = Math.max(0.1, Math.min(3, agent.bidMultiplier));
            });

            // Reset fitness
            agents.forEach(a => {
                a.fitness = 0;
                a.contestsWon = 0;
                a.contestsLost = 0;
            });
        }

        function getStats() {
            if (contestHistory.length === 0) {
                return { avgDuration: 0, avgWinnerVal: 0, hiValWinRate: 0 };
            }

            const recent = contestHistory.slice(-100);
            const avgDuration = recent.reduce((s, c) => s + c.duration, 0) / recent.length;
            const avgWinnerVal = recent.reduce((s, c) =>
                s + (c.winner === 1 ? c.value1 : c.value2), 0) / recent.length;
            const hiValWinRate = recent.filter(c => c.higherValueWon).length / recent.length;

            return { avgDuration, avgWinnerVal, hiValWinRate };
        }

        function draw() {
            ctx.fillStyle = '#FEFAE0';
            ctx.fillRect(0, 0, width, height);

            // Draw current contest visualization
            if (currentContest) {
                const c = currentContest;

                // Two bars showing remaining "endurance"
                const barY = 80;
                const barHeight = 40;
                const barWidth = (width - 100) / 2 - 20;

                // Player 1 bar
                const remain1 = Math.max(0, c.bid1 - c.time) / c.bid1;
                ctx.fillStyle = '#457B9D';
                ctx.fillRect(50, barY, barWidth * remain1, barHeight);
                ctx.strokeStyle = '#333';
                ctx.strokeRect(50, barY, barWidth, barHeight);

                ctx.fillStyle = '#606C38';
                ctx.font = '12px Nunito';
                ctx.fillText(`P1: Value=${c.value1.toFixed(0)}, Bid=${c.bid1.toFixed(0)}`, 50, barY - 10);

                // Player 2 bar
                const remain2 = Math.max(0, c.bid2 - c.time) / c.bid2;
                ctx.fillStyle = '#E9C46A';
                ctx.fillRect(width/2 + 10, barY, barWidth * remain2, barHeight);
                ctx.strokeStyle = '#333';
                ctx.strokeRect(width/2 + 10, barY, barWidth, barHeight);

                ctx.fillText(`P2: Value=${c.value2.toFixed(0)}, Bid=${c.bid2.toFixed(0)}`, width/2 + 10, barY - 10);

                // Time indicator
                ctx.fillStyle = '#BC6C25';
                ctx.font = 'bold 16px Nunito';
                ctx.textAlign = 'center';
                ctx.fillText(`Time: ${c.time}`, width/2, barY + barHeight + 30);

                if (!c.active) {
                    ctx.fillStyle = '#2A9D8F';
                    ctx.fillText(`Winner: Player ${c.winner}`, width/2, barY + barHeight + 55);
                }

                ctx.textAlign = 'left';
            }

            // Strategy distribution
            const stratY = 180;
            const stratHeight = 100;

            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(20, stratY, width - 40, stratHeight);
            ctx.strokeStyle = '#DDA15E';
            ctx.strokeRect(20, stratY, width - 40, stratHeight);

            // Histogram of bid multipliers
            const bins = new Array(20).fill(0);
            agents.forEach(a => {
                const bin = Math.min(19, Math.floor(a.bidMultiplier / 3 * 20));
                bins[bin]++;
            });

            const maxBin = Math.max(...bins, 1);
            const binWidth = (width - 80) / 20;

            bins.forEach((count, i) => {
                const h = (count / maxBin) * (stratHeight - 30);
                const x = 40 + i * binWidth;
                ctx.fillStyle = '#8A9A5B';
                ctx.fillRect(x, stratY + stratHeight - h - 10, binWidth - 2, h);
            });

            ctx.fillStyle = '#606C38';
            ctx.font = '11px Nunito';
            ctx.fillText('Strategy Distribution (bid multiplier)', 30, stratY + 15);

            // Duration distribution
            const durY = 300;
            const durHeight = 100;

            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(20, durY, width - 40, durHeight);
            ctx.strokeStyle = '#DDA15E';
            ctx.strokeRect(20, durY, width - 40, durHeight);

            if (contestHistory.length > 0) {
                const maxDur = Math.max(...contestHistory.map(c => c.duration), 10);
                const durBins = new Array(20).fill(0);

                contestHistory.slice(-200).forEach(c => {
                    const bin = Math.min(19, Math.floor(c.duration / maxDur * 20));
                    durBins[bin]++;
                });

                const maxDurBin = Math.max(...durBins, 1);

                durBins.forEach((count, i) => {
                    const h = (count / maxDurBin) * (durHeight - 30);
                    const x = 40 + i * binWidth;
                    ctx.fillStyle = '#BC6C25';
                    ctx.fillRect(x, durY + durHeight - h - 10, binWidth - 2, h);
                });
            }

            ctx.fillStyle = '#606C38';
            ctx.fillText('Contest Duration Distribution (ESS predicts exponential)', 30, durY + 15);

            // History chart
            const chartY = 420;
            const chartHeight = 160;

            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(20, chartY, width - 40, chartHeight);
            ctx.strokeStyle = '#DDA15E';
            ctx.strokeRect(20, chartY, width - 40, chartHeight);

            if (contestHistory.length > 1) {
                const maxPoints = 200;
                const recent = contestHistory.slice(-maxPoints);
                const step = (width - 60) / Math.max(1, recent.length - 1);

                // Moving average of higher-value win rate
                const windowSize = 20;
                const movingAvg = [];

                for (let i = windowSize; i < recent.length; i++) {
                    const window = recent.slice(i - windowSize, i);
                    const winRate = window.filter(c => c.higherValueWon).length / windowSize;
                    movingAvg.push(winRate);
                }

                if (movingAvg.length > 1) {
                    ctx.beginPath();
                    for (let i = 0; i < movingAvg.length; i++) {
                        const x = 30 + (i + windowSize) * step;
                        const y = chartY + chartHeight - 10 - movingAvg[i] * (chartHeight - 30);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.strokeStyle = '#8A9A5B';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // 50% line
                ctx.strokeStyle = '#E63946';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                const y50 = chartY + chartHeight - 10 - 0.5 * (chartHeight - 30);
                ctx.moveTo(30, y50);
                ctx.lineTo(width - 30, y50);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            ctx.fillStyle = '#606C38';
            ctx.font = '11px Nunito';
            ctx.fillText('Higher-Value Player Win Rate (red line = random at 50%)', 30, chartY + 15);
        }

        function updateStats() {
            const stats = getStats();

            document.getElementById('contestsStat').textContent = contestHistory.length;
            document.getElementById('durationStat').textContent = stats.avgDuration.toFixed(1);
            document.getElementById('winnerValStat').textContent = stats.avgWinnerVal.toFixed(1);
            document.getElementById('hiValWinStat').textContent = (stats.hiValWinRate * 100).toFixed(1) + '%';

            // ESS lambda = c/V for symmetric case
            const lambda = costPerTime / (maxValue / 2);
            document.getElementById('essStat').textContent = lambda.toFixed(3);

            if (currentContest) {
                document.getElementById('timeDisplay').textContent = currentContest.time;
                document.getElementById('val1').textContent = currentContest.value1.toFixed(0);
                document.getElementById('val2').textContent = currentContest.value2.toFixed(0);
                document.getElementById('cost1').textContent = currentContest.cost1.toFixed(0);
                document.getElementById('cost2').textContent = currentContest.cost2.toFixed(0);

                const p1El = document.getElementById('player1');
                const p2El = document.getElementById('player2');

                p1El.className = 'contestant';
                p2El.className = 'contestant';

                if (!currentContest.active) {
                    if (currentContest.winner === 1) {
                        p1El.classList.add('active');
                        p2El.classList.add('yielded');
                    } else {
                        p2El.classList.add('active');
                        p1El.classList.add('yielded');
                    }
                } else {
                    p1El.classList.add('active');
                    p2El.classList.add('active');
                }
            }
        }

        function updateControls() {
            maxValue = parseInt(document.getElementById('maxValue').value);
            costPerTime = parseInt(document.getElementById('costPerTime').value);
            asymmetry = parseInt(document.getElementById('asymmetry').value) / 100;
            popSize = parseInt(document.getElementById('population').value);

            document.getElementById('valueMax').textContent = maxValue;
            document.getElementById('valueCost').textContent = costPerTime;
            document.getElementById('valueAsym').textContent = asymmetry.toFixed(2);
            document.getElementById('valuePop').textContent = popSize;
        }

        function resetSimulation() {
            updateControls();
            initSimulation();
        }

        function togglePause() {
            paused = !paused;
        }

        let frameCount = 0;
        function animate() {
            if (!paused) {
                frameCount++;
                if (frameCount % 3 === 0) {
                    updateContest();
                }
            }

            updateStats();
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.querySelectorAll('input[type="range"]').forEach(input => {
            input.addEventListener('input', updateControls);
        });

        updateControls();
        initSimulation();
        animate();
    </script>
</body>
</html>
