<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decision Tree Growth - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 300px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #10b981; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #10b981; color: #fff; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { opacity: 0.9; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; margin-bottom: 10px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #10b981; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .info { background: rgba(16,185,129,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; border-left: 3px solid #10b981; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <div id="canvas-container"><canvas id="canvas"></canvas></div>
        <div id="controls">
            <h1>Decision Tree Growth</h1>
            <div class="control-group">
                <label>Max Depth: <span id="depthValue">4</span></label>
                <input type="range" id="depth" min="2" max="6" step="1" value="4">
            </div>
            <div class="control-group">
                <label>Min Samples Split: <span id="minSplitValue">5</span></label>
                <input type="range" id="minSplit" min="2" max="20" step="1" value="5">
            </div>
            <div class="control-group">
                <label>Data Points: <span id="pointsValue">100</span></label>
                <input type="range" id="points" min="50" max="300" step="25" value="100">
            </div>
            <button id="reset">Generate New Data</button>
            <button id="grow">Grow Tree Step</button>
            <button id="auto">Auto Grow</button>
            <div class="stats">
                <div>Nodes: <span id="nodes">1</span></div>
                <div>Tree Depth: <span id="currentDepth">0</span></div>
                <div>Accuracy: <span id="accuracy">-</span></div>
            </div>
            <div class="info">
                <strong>Decision Tree Algorithm</strong><br><br>
                • Recursively splits data on features<br>
                • Uses information gain/Gini impurity<br>
                • Creates axis-aligned decision boundaries<br>
                • Green = Class A, Orange = Class B<br><br>
                Watch splits propagate through the tree!
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let params = { maxDepth: 4, minSplit: 5, numPoints: 100 };
        let points = [];
        let tree = null;
        let autoGrowing = false;
        let growQueue = [];
        
        const classColors = { 0: '#10b981', 1: '#f59e0b' };

        function resize() {
            canvas.width = document.getElementById('canvas-container').clientWidth;
            canvas.height = document.getElementById('canvas-container').clientHeight;
        }

        function generateData() {
            points = [];
            const w = canvas.width - 350;
            const h = canvas.height - 50;
            
            // Generate two-class data with some overlap
            const patterns = [
                // Diagonal split
                () => {
                    for (let i = 0; i < params.numPoints; i++) {
                        const x = 50 + Math.random() * (w - 100);
                        const y = 50 + Math.random() * (h - 100);
                        const noise = (Math.random() - 0.5) * 100;
                        const classLabel = (x + noise > y + h/3) ? 0 : 1;
                        points.push({ x, y, class: classLabel, predicted: -1 });
                    }
                },
                // Quadrant split
                () => {
                    for (let i = 0; i < params.numPoints; i++) {
                        const x = 50 + Math.random() * (w - 100);
                        const y = 50 + Math.random() * (h - 100);
                        const cx = w / 2, cy = h / 2;
                        const classLabel = ((x > cx) === (y > cy)) ? 0 : 1;
                        if (Math.random() < 0.1) points.push({ x, y, class: 1 - classLabel, predicted: -1 });
                        else points.push({ x, y, class: classLabel, predicted: -1 });
                    }
                },
                // Clustered
                () => {
                    const centers = [
                        { x: w * 0.3, y: h * 0.3, c: 0 },
                        { x: w * 0.7, y: h * 0.7, c: 0 },
                        { x: w * 0.3, y: h * 0.7, c: 1 },
                        { x: w * 0.7, y: h * 0.3, c: 1 }
                    ];
                    for (let i = 0; i < params.numPoints; i++) {
                        const center = centers[Math.floor(Math.random() * centers.length)];
                        const x = center.x + (Math.random() - 0.5) * 150;
                        const y = center.y + (Math.random() - 0.5) * 150;
                        points.push({ x, y, class: center.c, predicted: -1 });
                    }
                }
            ];
            
            patterns[Math.floor(Math.random() * patterns.length)]();
            initTree();
        }

        function entropy(counts, total) {
            if (total === 0) return 0;
            let ent = 0;
            for (const c of counts) {
                if (c > 0) {
                    const p = c / total;
                    ent -= p * Math.log2(p);
                }
            }
            return ent;
        }

        function gini(counts, total) {
            if (total === 0) return 0;
            let sum = 0;
            for (const c of counts) {
                const p = c / total;
                sum += p * p;
            }
            return 1 - sum;
        }

        function findBestSplit(nodePoints, bounds) {
            if (nodePoints.length < params.minSplit) return null;
            
            const count0 = nodePoints.filter(p => p.class === 0).length;
            const count1 = nodePoints.length - count0;
            const parentGini = gini([count0, count1], nodePoints.length);
            
            let bestGain = 0;
            let bestSplit = null;
            
            // Try splits on X axis
            const xSorted = [...nodePoints].sort((a, b) => a.x - b.x);
            for (let i = 1; i < xSorted.length; i++) {
                const splitValue = (xSorted[i - 1].x + xSorted[i].x) / 2;
                const left = nodePoints.filter(p => p.x <= splitValue);
                const right = nodePoints.filter(p => p.x > splitValue);
                
                const leftGini = gini(
                    [left.filter(p => p.class === 0).length, left.filter(p => p.class === 1).length],
                    left.length
                );
                const rightGini = gini(
                    [right.filter(p => p.class === 0).length, right.filter(p => p.class === 1).length],
                    right.length
                );
                
                const weightedGini = (left.length * leftGini + right.length * rightGini) / nodePoints.length;
                const gain = parentGini - weightedGini;
                
                if (gain > bestGain) {
                    bestGain = gain;
                    bestSplit = { axis: 'x', value: splitValue, left, right };
                }
            }
            
            // Try splits on Y axis
            const ySorted = [...nodePoints].sort((a, b) => a.y - b.y);
            for (let i = 1; i < ySorted.length; i++) {
                const splitValue = (ySorted[i - 1].y + ySorted[i].y) / 2;
                const left = nodePoints.filter(p => p.y <= splitValue);
                const right = nodePoints.filter(p => p.y > splitValue);
                
                const leftGini = gini(
                    [left.filter(p => p.class === 0).length, left.filter(p => p.class === 1).length],
                    left.length
                );
                const rightGini = gini(
                    [right.filter(p => p.class === 0).length, right.filter(p => p.class === 1).length],
                    right.length
                );
                
                const weightedGini = (left.length * leftGini + right.length * rightGini) / nodePoints.length;
                const gain = parentGini - weightedGini;
                
                if (gain > bestGain) {
                    bestGain = gain;
                    bestSplit = { axis: 'y', value: splitValue, left, right };
                }
            }
            
            return bestGain > 0.01 ? bestSplit : null;
        }

        function initTree() {
            const w = canvas.width - 350;
            const h = canvas.height - 50;
            
            const count0 = points.filter(p => p.class === 0).length;
            const count1 = points.length - count0;
            
            tree = {
                points: [...points],
                bounds: { x1: 25, y1: 25, x2: w, y2: h },
                depth: 0,
                prediction: count0 > count1 ? 0 : 1,
                split: null,
                left: null,
                right: null
            };
            
            growQueue = [tree];
            updatePredictions();
        }

        function growStep() {
            if (growQueue.length === 0) return false;
            
            const node = growQueue.shift();
            
            if (node.depth >= params.maxDepth) return growQueue.length > 0;
            if (node.points.length < params.minSplit) return growQueue.length > 0;
            
            const split = findBestSplit(node.points, node.bounds);
            if (!split) return growQueue.length > 0;
            
            node.split = { axis: split.axis, value: split.value };
            
            const leftCount0 = split.left.filter(p => p.class === 0).length;
            const rightCount0 = split.right.filter(p => p.class === 0).length;
            
            if (split.axis === 'x') {
                node.left = {
                    points: split.left,
                    bounds: { x1: node.bounds.x1, y1: node.bounds.y1, x2: split.value, y2: node.bounds.y2 },
                    depth: node.depth + 1,
                    prediction: leftCount0 > split.left.length - leftCount0 ? 0 : 1,
                    split: null, left: null, right: null
                };
                node.right = {
                    points: split.right,
                    bounds: { x1: split.value, y1: node.bounds.y1, x2: node.bounds.x2, y2: node.bounds.y2 },
                    depth: node.depth + 1,
                    prediction: rightCount0 > split.right.length - rightCount0 ? 0 : 1,
                    split: null, left: null, right: null
                };
            } else {
                node.left = {
                    points: split.left,
                    bounds: { x1: node.bounds.x1, y1: node.bounds.y1, x2: node.bounds.x2, y2: split.value },
                    depth: node.depth + 1,
                    prediction: leftCount0 > split.left.length - leftCount0 ? 0 : 1,
                    split: null, left: null, right: null
                };
                node.right = {
                    points: split.right,
                    bounds: { x1: node.bounds.x1, y1: split.value, x2: node.bounds.x2, y2: node.bounds.y2 },
                    depth: node.depth + 1,
                    prediction: rightCount0 > split.right.length - rightCount0 ? 0 : 1,
                    split: null, left: null, right: null
                };
            }
            
            growQueue.push(node.left, node.right);
            updatePredictions();
            return true;
        }

        function updatePredictions() {
            function classify(node, point) {
                if (!node.split) return node.prediction;
                if (node.split.axis === 'x') {
                    return point.x <= node.split.value ? classify(node.left, point) : classify(node.right, point);
                } else {
                    return point.y <= node.split.value ? classify(node.left, point) : classify(node.right, point);
                }
            }
            
            for (const p of points) {
                p.predicted = classify(tree, p);
            }
            
            updateStats();
        }

        function countNodes(node) {
            if (!node) return 0;
            return 1 + countNodes(node.left) + countNodes(node.right);
        }

        function maxDepth(node) {
            if (!node) return 0;
            return Math.max(node.depth, maxDepth(node.left), maxDepth(node.right));
        }

        function updateStats() {
            document.getElementById('nodes').textContent = countNodes(tree);
            document.getElementById('currentDepth').textContent = maxDepth(tree);
            
            const correct = points.filter(p => p.class === p.predicted).length;
            document.getElementById('accuracy').textContent = (100 * correct / points.length).toFixed(1) + '%';
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw decision regions
            function drawRegion(node, alpha = 0.15) {
                if (!node) return;
                
                const b = node.bounds;
                ctx.fillStyle = classColors[node.prediction];
                ctx.globalAlpha = alpha;
                ctx.fillRect(b.x1, b.y1, b.x2 - b.x1, b.y2 - b.y1);
                ctx.globalAlpha = 1;
                
                if (node.split) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    
                    if (node.split.axis === 'x') {
                        ctx.moveTo(node.split.value, b.y1);
                        ctx.lineTo(node.split.value, b.y2);
                    } else {
                        ctx.moveTo(b.x1, node.split.value);
                        ctx.lineTo(b.x2, node.split.value);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    drawRegion(node.left, alpha + 0.05);
                    drawRegion(node.right, alpha + 0.05);
                }
            }
            
            drawRegion(tree);
            
            // Draw data points
            for (const p of points) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = classColors[p.class];
                ctx.fill();
                
                // Mark misclassified
                if (p.predicted !== -1 && p.predicted !== p.class) {
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }

        let lastAutoGrow = 0;
        function animate(timestamp) {
            if (autoGrowing && timestamp - lastAutoGrow > 800) {
                if (!growStep()) {
                    autoGrowing = false;
                    document.getElementById('auto').textContent = 'Auto Grow';
                }
                lastAutoGrow = timestamp;
            }
            draw();
            requestAnimationFrame(animate);
        }

        document.getElementById('depth').addEventListener('input', e => {
            params.maxDepth = parseInt(e.target.value);
            document.getElementById('depthValue').textContent = params.maxDepth;
        });

        document.getElementById('minSplit').addEventListener('input', e => {
            params.minSplit = parseInt(e.target.value);
            document.getElementById('minSplitValue').textContent = params.minSplit;
        });

        document.getElementById('points').addEventListener('input', e => {
            params.numPoints = parseInt(e.target.value);
            document.getElementById('pointsValue').textContent = params.numPoints;
        });

        document.getElementById('reset').addEventListener('click', () => {
            autoGrowing = false;
            document.getElementById('auto').textContent = 'Auto Grow';
            generateData();
        });

        document.getElementById('grow').addEventListener('click', growStep);

        document.getElementById('auto').addEventListener('click', () => {
            autoGrowing = !autoGrowing;
            document.getElementById('auto').textContent = autoGrowing ? 'Stop' : 'Auto Grow';
        });

        window.addEventListener('resize', () => {
            resize();
            generateData();
        });

        resize();
        generateData();
        requestAnimationFrame(animate);
    </script>
</body>
</html>
