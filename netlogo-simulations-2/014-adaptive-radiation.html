<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adaptive Radiation Simulation</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        .back-link {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: var(--terracotta);
        }

        h1 {
            color: var(--dark-moss);
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .subtitle {
            color: var(--moss);
            font-size: 1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: var(--moss);
            font-size: 0.95em;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid var(--sage);
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            color: var(--dark-moss);
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group .value {
            text-align: right;
            font-size: 0.8em;
            color: var(--moss);
        }

        .control-group select {
            width: 100%;
            padding: 6px;
            border: 1px solid var(--sage);
            border-radius: 6px;
            font-size: 0.9em;
        }

        .button-group {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.3s;
        }

        .btn-primary {
            background: var(--sage);
            color: white;
        }

        .btn-primary:hover {
            background: var(--moss);
        }

        .btn-secondary {
            background: var(--earth);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--terracotta);
        }

        .btn-accent {
            background: #2196F3;
            color: white;
        }

        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .viz-panel {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .viz-panel h3 {
            color: var(--moss);
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        canvas {
            width: 100%;
            border-radius: 8px;
            background: #1a1a2e;
        }

        .viz-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .stat-box {
            background: linear-gradient(135deg, var(--cream) 0%, white 100%);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            border-left: 3px solid var(--sage);
        }

        .stat-box.highlight {
            border-left-color: var(--terracotta);
        }

        .stat-box.success {
            border-left-color: #4CAF50;
        }

        .stat-box .label {
            font-size: 0.75em;
            color: var(--moss);
            margin-bottom: 4px;
        }

        .stat-box .value {
            font-size: 1.2em;
            font-weight: bold;
            color: var(--dark-moss);
        }

        .info-box {
            background: linear-gradient(135deg, #e3f2fd 0%, white 100%);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            font-size: 0.8em;
            color: var(--dark-moss);
        }

        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
            font-size: 0.8em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .species-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .species-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 500;
            color: white;
        }

        .niche-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 5px;
            margin-top: 10px;
        }

        .niche-cell {
            aspect-ratio: 1;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">← Back to Simulations</a>
            <h1>Adaptive Radiation</h1>
            <p class="subtitle">Rapid Diversification into Empty Ecological Niches</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-section">
                    <h3>Ecological Setting</h3>
                    <div class="control-group">
                        <label>Radiation Model:</label>
                        <select id="radiationModel">
                            <option value="finches">Darwin's Finches (Galápagos)</option>
                            <option value="cichlids">Cichlid Fish (African Lakes)</option>
                            <option value="anoles">Anole Lizards (Caribbean)</option>
                            <option value="custom">Custom Environment</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Number of Niches: <span id="numNichesVal">9</span></label>
                        <input type="range" id="numNiches" min="4" max="20" value="9">
                    </div>
                    <div class="control-group">
                        <label>Niche Width: <span id="nicheWidthVal">0.20</span></label>
                        <input type="range" id="nicheWidth" min="5" max="50" value="20">
                        <div class="value">trait range per niche</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Population Dynamics</h3>
                    <div class="control-group">
                        <label>Initial Population: <span id="initPopVal">50</span></label>
                        <input type="range" id="initPop" min="10" max="200" value="50" step="10">
                    </div>
                    <div class="control-group">
                        <label>Carrying Capacity per Niche: <span id="carryCapVal">100</span></label>
                        <input type="range" id="carryCap" min="20" max="500" value="100" step="20">
                    </div>
                    <div class="control-group">
                        <label>Growth Rate: <span id="growthRateVal">0.15</span></label>
                        <input type="range" id="growthRate" min="5" max="40" value="15">
                    </div>
                </div>

                <div class="control-section">
                    <h3>Evolution Parameters</h3>
                    <div class="control-group">
                        <label>Mutation Rate: <span id="mutRateVal">0.02</span></label>
                        <input type="range" id="mutRate" min="1" max="50" value="20">
                    </div>
                    <div class="control-group">
                        <label>Selection Strength: <span id="selStrengthVal">0.30</span></label>
                        <input type="range" id="selStrength" min="5" max="80" value="30">
                    </div>
                    <div class="control-group">
                        <label>Speciation Threshold: <span id="specThreshVal">0.40</span></label>
                        <input type="range" id="specThresh" min="20" max="80" value="40">
                        <div class="value">trait distance for speciation</div>
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="button-group">
                    <button class="btn-accent" id="colonizeBtn">Colonize New Island</button>
                </div>

                <div class="info-box">
                    <strong>Adaptive Radiation:</strong><br>
                    When a lineage encounters ecological opportunity (empty niches), it can rapidly diversify. Character displacement and niche partitioning allow multiple species to coexist by specializing on different resources.
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-panel">
                    <h3>Trait Space & Niche Landscape</h3>
                    <canvas id="traitCanvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(100, 200, 100, 0.3);"></div>
                            <span>Available Niches</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #f44336;"></div>
                            <span>Occupied Niches</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #2196F3;"></div>
                            <span>Individuals (colored by species)</span>
                        </div>
                    </div>
                </div>

                <div class="viz-row">
                    <div class="viz-panel">
                        <h3>Species Diversity Over Time</h3>
                        <canvas id="diversityCanvas"></canvas>
                    </div>
                    <div class="viz-panel">
                        <h3>Niche Occupancy</h3>
                        <canvas id="nicheCanvas"></canvas>
                        <div id="nicheGrid" class="niche-grid"></div>
                    </div>
                </div>

                <div class="viz-row">
                    <div class="viz-panel">
                        <h3>Phylogenetic Tree</h3>
                        <canvas id="phyloCanvas"></canvas>
                    </div>
                    <div class="viz-panel">
                        <h3>Character Displacement</h3>
                        <canvas id="displacementCanvas"></canvas>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="label">Generation</div>
                        <div class="value" id="genStat">0</div>
                    </div>
                    <div class="stat-box highlight">
                        <div class="label">Species Count</div>
                        <div class="value" id="speciesStat">1</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Total Population</div>
                        <div class="value" id="popStat">50</div>
                    </div>
                    <div class="stat-box success">
                        <div class="label">Niches Filled</div>
                        <div class="value" id="nichesStat">1/9</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Mean Fitness</div>
                        <div class="value" id="fitnessStat">0.50</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Trait Disparity</div>
                        <div class="value" id="disparityStat">0.00</div>
                    </div>
                </div>

                <div class="viz-panel">
                    <h3>Extant Species</h3>
                    <div id="speciesList" class="species-list"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const traitCanvas = document.getElementById('traitCanvas');
        const diversityCanvas = document.getElementById('diversityCanvas');
        const nicheCanvas = document.getElementById('nicheCanvas');
        const phyloCanvas = document.getElementById('phyloCanvas');
        const displacementCanvas = document.getElementById('displacementCanvas');

        const traitCtx = traitCanvas.getContext('2d');
        const diversityCtx = diversityCanvas.getContext('2d');
        const nicheCtx = nicheCanvas.getContext('2d');
        const phyloCtx = phyloCanvas.getContext('2d');
        const displacementCtx = displacementCanvas.getContext('2d');

        // Parameters
        let radiationModel = 'finches';
        let numNiches = 9;
        let nicheWidth = 0.20;
        let initPop = 50;
        let carryCap = 100;
        let growthRate = 0.15;
        let mutRate = 0.02;
        let selStrength = 0.30;
        let specThresh = 0.40;

        // State
        let individuals = [];
        let species = [];
        let niches = [];
        let generation = 0;
        let speciesIdCounter = 1;
        let diversityHistory = [];
        let phylogenyEvents = [];
        let running = false;
        let animationId = null;

        // Niche definitions based on model
        const nicheTemplates = {
            finches: [
                { name: 'Ground Seeds (Small)', trait: [0.2, 0.2] },
                { name: 'Ground Seeds (Large)', trait: [0.2, 0.8] },
                { name: 'Tree Seeds', trait: [0.5, 0.5] },
                { name: 'Insects (Bark)', trait: [0.8, 0.3] },
                { name: 'Insects (Foliage)', trait: [0.8, 0.7] },
                { name: 'Cactus', trait: [0.4, 0.2] },
                { name: 'Fruit', trait: [0.6, 0.6] },
                { name: 'Nectar', trait: [0.7, 0.9] },
                { name: 'Blood', trait: [0.9, 0.1] }
            ],
            cichlids: [
                { name: 'Algae Scraper', trait: [0.1, 0.5] },
                { name: 'Scale Eater', trait: [0.3, 0.2] },
                { name: 'Snail Crusher', trait: [0.3, 0.8] },
                { name: 'Fish Hunter', trait: [0.5, 0.3] },
                { name: 'Zooplankton', trait: [0.5, 0.7] },
                { name: 'Insect Larvae', trait: [0.7, 0.5] },
                { name: 'Detritus', trait: [0.2, 0.9] },
                { name: 'Eggs/Fry', trait: [0.8, 0.2] },
                { name: 'Generalist', trait: [0.5, 0.5] }
            ],
            anoles: [
                { name: 'Trunk-Ground', trait: [0.2, 0.3] },
                { name: 'Trunk-Crown', trait: [0.4, 0.7] },
                { name: 'Grass-Bush', trait: [0.3, 0.1] },
                { name: 'Crown Giant', trait: [0.8, 0.8] },
                { name: 'Twig', trait: [0.6, 0.4] },
                { name: 'Trunk', trait: [0.4, 0.5] },
                { name: 'Semi-Aquatic', trait: [0.1, 0.2] },
                { name: 'Canopy', trait: [0.7, 0.9] },
                { name: 'Ground', trait: [0.2, 0.1] }
            ],
            custom: []
        };

        function setupCanvas(canvas, ctx, height) {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = (rect.width - 30) * dpr;
            canvas.height = height * dpr;
            canvas.style.width = (rect.width - 30) + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(dpr, dpr);
        }

        function generateNiches() {
            niches = [];

            if (radiationModel !== 'custom' && nicheTemplates[radiationModel]) {
                const templates = nicheTemplates[radiationModel];
                for (let i = 0; i < Math.min(numNiches, templates.length); i++) {
                    niches.push({
                        ...templates[i],
                        id: i,
                        occupied: false,
                        population: 0
                    });
                }
                // Add random niches if needed
                while (niches.length < numNiches) {
                    niches.push({
                        name: `Niche ${niches.length + 1}`,
                        trait: [Math.random(), Math.random()],
                        id: niches.length,
                        occupied: false,
                        population: 0
                    });
                }
            } else {
                // Generate random niches in grid pattern
                const gridSize = Math.ceil(Math.sqrt(numNiches));
                for (let i = 0; i < numNiches; i++) {
                    const row = Math.floor(i / gridSize);
                    const col = i % gridSize;
                    niches.push({
                        name: `Niche ${i + 1}`,
                        trait: [
                            (col + 0.5) / gridSize,
                            (row + 0.5) / gridSize
                        ],
                        id: i,
                        occupied: false,
                        population: 0
                    });
                }
            }
        }

        function initPopulation() {
            individuals = [];
            species = [];
            generation = 0;
            speciesIdCounter = 1;
            diversityHistory = [];
            phylogenyEvents = [];

            generateNiches();

            // Create founding species
            const founderSpecies = {
                id: speciesIdCounter++,
                name: 'Founder',
                color: `hsl(${Math.random() * 360}, 70%, 50%)`,
                parentId: null,
                originGen: 0,
                meanTrait: [0.5, 0.5]
            };
            species.push(founderSpecies);

            // Create initial population as generalists
            for (let i = 0; i < initPop; i++) {
                individuals.push({
                    trait: [
                        0.5 + (Math.random() - 0.5) * 0.2,
                        0.5 + (Math.random() - 0.5) * 0.2
                    ],
                    fitness: 0,
                    speciesId: founderSpecies.id
                });
            }

            updateNicheOccupancy();
        }

        function getNearestNiche(trait) {
            let nearest = null;
            let minDist = Infinity;

            for (const niche of niches) {
                const dist = Math.sqrt(
                    Math.pow(trait[0] - niche.trait[0], 2) +
                    Math.pow(trait[1] - niche.trait[1], 2)
                );
                if (dist < minDist) {
                    minDist = dist;
                    nearest = niche;
                }
            }

            return { niche: nearest, distance: minDist };
        }

        function calculateFitness(individual) {
            const { niche, distance } = getNearestNiche(individual.trait);

            // Fitness based on niche match
            const nicheMatch = Math.exp(-Math.pow(distance / nicheWidth, 2));

            // Competition penalty - more individuals in niche = lower fitness
            const competitorCount = individuals.filter(ind =>
                getNearestNiche(ind.trait).niche.id === niche.id
            ).length;
            const competitionPenalty = Math.max(0, 1 - competitorCount / carryCap);

            return nicheMatch * (0.3 + 0.7 * competitionPenalty);
        }

        function updateNicheOccupancy() {
            // Reset niche occupancy
            for (const niche of niches) {
                niche.occupied = false;
                niche.population = 0;
                niche.dominantSpecies = null;
            }

            // Count individuals per niche
            const nicheSpecies = {};
            for (const ind of individuals) {
                const { niche } = getNearestNiche(ind.trait);
                niche.population++;

                if (!nicheSpecies[niche.id]) {
                    nicheSpecies[niche.id] = {};
                }
                nicheSpecies[niche.id][ind.speciesId] =
                    (nicheSpecies[niche.id][ind.speciesId] || 0) + 1;
            }

            // Determine dominant species per niche
            for (const niche of niches) {
                if (niche.population > 5) {
                    niche.occupied = true;
                    const speciesCounts = nicheSpecies[niche.id] || {};
                    let maxCount = 0;
                    for (const [spId, count] of Object.entries(speciesCounts)) {
                        if (count > maxCount) {
                            maxCount = count;
                            niche.dominantSpecies = parseInt(spId);
                        }
                    }
                }
            }
        }

        function mutate(individual) {
            if (Math.random() < mutRate) {
                individual.trait[0] += (Math.random() - 0.5) * 0.1;
                individual.trait[1] += (Math.random() - 0.5) * 0.1;
                individual.trait[0] = Math.max(0, Math.min(1, individual.trait[0]));
                individual.trait[1] = Math.max(0, Math.min(1, individual.trait[1]));
            }
        }

        function getTraitDistance(t1, t2) {
            return Math.sqrt(
                Math.pow(t1[0] - t2[0], 2) +
                Math.pow(t1[1] - t2[1], 2)
            );
        }

        function checkSpeciation() {
            // Group individuals by current species
            const speciesGroups = {};
            for (const ind of individuals) {
                if (!speciesGroups[ind.speciesId]) {
                    speciesGroups[ind.speciesId] = [];
                }
                speciesGroups[ind.speciesId].push(ind);
            }

            // Check each species for potential splits
            for (const [speciesId, members] of Object.entries(speciesGroups)) {
                if (members.length < 20) continue;  // Need minimum population

                // Calculate mean trait
                const meanTrait = [
                    members.reduce((s, m) => s + m.trait[0], 0) / members.length,
                    members.reduce((s, m) => s + m.trait[1], 0) / members.length
                ];

                // Find individuals that have diverged significantly
                const diverged = members.filter(m =>
                    getTraitDistance(m.trait, meanTrait) > specThresh
                );

                if (diverged.length > 10) {
                    // Calculate mean trait of diverged group
                    const divergedMean = [
                        diverged.reduce((s, m) => s + m.trait[0], 0) / diverged.length,
                        diverged.reduce((s, m) => s + m.trait[1], 0) / diverged.length
                    ];

                    // Check if diverged group is significantly different
                    if (getTraitDistance(divergedMean, meanTrait) > specThresh * 0.8) {
                        // Create new species
                        const parentSpecies = species.find(s => s.id === parseInt(speciesId));
                        const newSpecies = {
                            id: speciesIdCounter++,
                            name: `Species ${speciesIdCounter - 1}`,
                            color: `hsl(${Math.random() * 360}, 70%, 50%)`,
                            parentId: parseInt(speciesId),
                            originGen: generation,
                            meanTrait: divergedMean
                        };
                        species.push(newSpecies);

                        // Reassign diverged individuals
                        for (const ind of diverged) {
                            ind.speciesId = newSpecies.id;
                        }

                        // Record phylogeny event
                        phylogenyEvents.push({
                            gen: generation,
                            parentId: parseInt(speciesId),
                            childId: newSpecies.id
                        });
                    }
                }
            }

            // Remove extinct species
            const activeSpeciesIds = new Set(individuals.map(i => i.speciesId));
            for (const sp of species) {
                if (!activeSpeciesIds.has(sp.id)) {
                    sp.extinct = true;
                    sp.extinctGen = generation;
                }
            }
        }

        function reproduce() {
            // Calculate fitness for all individuals
            for (const ind of individuals) {
                ind.fitness = calculateFitness(ind);
            }

            const newPop = [];
            const totalFitness = individuals.reduce((s, i) => s + i.fitness, 0);

            if (totalFitness === 0) {
                individuals = [];
                return;
            }

            // Calculate expected offspring based on fitness
            for (const ind of individuals) {
                const expectedOffspring = (ind.fitness / totalFitness) * individuals.length * (1 + growthRate);
                const numOffspring = Math.floor(expectedOffspring) +
                    (Math.random() < (expectedOffspring % 1) ? 1 : 0);

                for (let i = 0; i < numOffspring; i++) {
                    const offspring = {
                        trait: [...ind.trait],
                        fitness: 0,
                        speciesId: ind.speciesId
                    };
                    mutate(offspring);
                    newPop.push(offspring);
                }
            }

            // Apply carrying capacity per niche
            const nichePopulations = {};
            for (const ind of newPop) {
                const { niche } = getNearestNiche(ind.trait);
                if (!nichePopulations[niche.id]) {
                    nichePopulations[niche.id] = [];
                }
                nichePopulations[niche.id].push(ind);
            }

            individuals = [];
            for (const [nicheId, pop] of Object.entries(nichePopulations)) {
                if (pop.length <= carryCap) {
                    individuals.push(...pop);
                } else {
                    // Random survival to carrying capacity
                    const survivors = pop.sort(() => Math.random() - 0.5).slice(0, carryCap);
                    individuals.push(...survivors);
                }
            }
        }

        function step() {
            reproduce();
            checkSpeciation();
            updateNicheOccupancy();
            generation++;

            // Record diversity
            const activeSpecies = species.filter(s => !s.extinct).length;
            diversityHistory.push({
                gen: generation,
                count: activeSpecies,
                population: individuals.length
            });

            if (diversityHistory.length > 500) {
                diversityHistory = diversityHistory.filter((_, i) => i % 2 === 0);
            }
        }

        function drawTraitSpace() {
            const width = traitCanvas.width / (window.devicePixelRatio || 1);
            const height = traitCanvas.height / (window.devicePixelRatio || 1);

            traitCtx.fillStyle = '#1a1a2e';
            traitCtx.fillRect(0, 0, width, height);

            const padding = 50;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Draw niche regions
            for (const niche of niches) {
                const x = padding + niche.trait[0] * graphWidth;
                const y = padding + (1 - niche.trait[1]) * graphHeight;
                const radius = nicheWidth * graphWidth;

                // Niche area
                const gradient = traitCtx.createRadialGradient(x, y, 0, x, y, radius);
                if (niche.occupied) {
                    const sp = species.find(s => s.id === niche.dominantSpecies);
                    const color = sp ? sp.color : '#4CAF50';
                    gradient.addColorStop(0, color.replace(')', ', 0.3)').replace('hsl', 'hsla'));
                    gradient.addColorStop(1, 'transparent');
                } else {
                    gradient.addColorStop(0, 'rgba(100, 200, 100, 0.2)');
                    gradient.addColorStop(1, 'transparent');
                }

                traitCtx.fillStyle = gradient;
                traitCtx.beginPath();
                traitCtx.arc(x, y, radius, 0, Math.PI * 2);
                traitCtx.fill();

                // Niche center marker
                traitCtx.fillStyle = niche.occupied ? '#fff' : '#666';
                traitCtx.beginPath();
                traitCtx.arc(x, y, 4, 0, Math.PI * 2);
                traitCtx.fill();

                // Niche label
                traitCtx.fillStyle = '#ffffffaa';
                traitCtx.font = '9px sans-serif';
                traitCtx.textAlign = 'center';
                traitCtx.fillText(niche.name.split(' ')[0], x, y + radius + 15);
            }

            // Draw individuals
            for (const ind of individuals) {
                const x = padding + ind.trait[0] * graphWidth;
                const y = padding + (1 - ind.trait[1]) * graphHeight;
                const sp = species.find(s => s.id === ind.speciesId);

                traitCtx.fillStyle = sp ? sp.color : '#2196F3';
                traitCtx.beginPath();
                traitCtx.arc(x, y, 3, 0, Math.PI * 2);
                traitCtx.fill();
            }

            // Axes labels
            traitCtx.fillStyle = '#ffffffaa';
            traitCtx.font = '11px sans-serif';
            traitCtx.textAlign = 'center';
            traitCtx.fillText('Trait 1 (e.g., Beak Size)', width / 2, height - 10);

            traitCtx.save();
            traitCtx.translate(15, height / 2);
            traitCtx.rotate(-Math.PI / 2);
            traitCtx.fillText('Trait 2 (e.g., Beak Depth)', 0, 0);
            traitCtx.restore();
        }

        function drawDiversity() {
            const width = diversityCanvas.width / (window.devicePixelRatio || 1);
            const height = diversityCanvas.height / (window.devicePixelRatio || 1);

            diversityCtx.fillStyle = '#1a1a2e';
            diversityCtx.fillRect(0, 0, width, height);

            if (diversityHistory.length < 2) return;

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Axes
            diversityCtx.strokeStyle = '#ffffff44';
            diversityCtx.beginPath();
            diversityCtx.moveTo(padding, padding);
            diversityCtx.lineTo(padding, height - padding);
            diversityCtx.lineTo(width - padding, height - padding);
            diversityCtx.stroke();

            const maxGen = diversityHistory[diversityHistory.length - 1].gen;
            const maxSpecies = Math.max(...diversityHistory.map(d => d.count), numNiches);

            // Draw species count
            diversityCtx.strokeStyle = '#4CAF50';
            diversityCtx.lineWidth = 2;
            diversityCtx.beginPath();

            diversityHistory.forEach((point, i) => {
                const x = padding + (point.gen / maxGen) * graphWidth;
                const y = height - padding - (point.count / maxSpecies) * graphHeight;

                if (i === 0) {
                    diversityCtx.moveTo(x, y);
                } else {
                    diversityCtx.lineTo(x, y);
                }
            });
            diversityCtx.stroke();

            // Draw theoretical maximum (number of niches)
            diversityCtx.strokeStyle = '#FFC10788';
            diversityCtx.setLineDash([5, 5]);
            const maxY = height - padding - (numNiches / maxSpecies) * graphHeight;
            diversityCtx.beginPath();
            diversityCtx.moveTo(padding, maxY);
            diversityCtx.lineTo(width - padding, maxY);
            diversityCtx.stroke();
            diversityCtx.setLineDash([]);

            diversityCtx.fillStyle = '#FFC107';
            diversityCtx.font = '9px sans-serif';
            diversityCtx.fillText('Max niches', width - padding - 50, maxY - 5);

            diversityCtx.fillStyle = '#ffffffaa';
            diversityCtx.fillText('# Species', padding + 5, padding - 10);
            diversityCtx.fillText('Generation', width - padding - 50, height - 10);
        }

        function drawNicheOccupancy() {
            const width = nicheCanvas.width / (window.devicePixelRatio || 1);
            const height = nicheCanvas.height / (window.devicePixelRatio || 1);

            nicheCtx.fillStyle = '#1a1a2e';
            nicheCtx.fillRect(0, 0, width, height);

            const barWidth = (width - 60) / niches.length;
            const maxPop = carryCap;

            for (let i = 0; i < niches.length; i++) {
                const niche = niches[i];
                const x = 30 + i * barWidth;
                const barHeight = (niche.population / maxPop) * (height - 60);

                // Bar
                const sp = species.find(s => s.id === niche.dominantSpecies);
                nicheCtx.fillStyle = sp ? sp.color : '#666';
                nicheCtx.fillRect(x, height - 30 - barHeight, barWidth - 2, barHeight);

                // Niche number
                nicheCtx.fillStyle = '#ffffffaa';
                nicheCtx.font = '9px sans-serif';
                nicheCtx.textAlign = 'center';
                nicheCtx.fillText(i + 1, x + barWidth / 2, height - 15);
            }

            // Update grid display
            const gridHtml = niches.map(n => {
                const sp = species.find(s => s.id === n.dominantSpecies);
                const color = sp ? sp.color : '#333';
                return `<div class="niche-cell" style="background: ${color};" title="${n.name}">${n.population}</div>`;
            }).join('');
            document.getElementById('nicheGrid').innerHTML = gridHtml;
        }

        function drawPhylogeny() {
            const width = phyloCanvas.width / (window.devicePixelRatio || 1);
            const height = phyloCanvas.height / (window.devicePixelRatio || 1);

            phyloCtx.fillStyle = '#1a1a2e';
            phyloCtx.fillRect(0, 0, width, height);

            const padding = 30;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            const activeSpecies = species.filter(s => !s.extinct);
            if (activeSpecies.length === 0) return;

            // Simple tree layout
            const tipSpacing = graphHeight / (activeSpecies.length + 1);

            // Draw branches for each speciation event
            phyloCtx.strokeStyle = '#4CAF50';
            phyloCtx.lineWidth = 2;

            const speciesYPositions = {};
            activeSpecies.forEach((sp, i) => {
                speciesYPositions[sp.id] = padding + (i + 1) * tipSpacing;
            });

            // Draw lineages
            for (const sp of activeSpecies) {
                const tipX = width - padding;
                const tipY = speciesYPositions[sp.id];
                const originX = padding + (sp.originGen / Math.max(generation, 1)) * graphWidth;

                phyloCtx.strokeStyle = sp.color;
                phyloCtx.beginPath();
                phyloCtx.moveTo(originX, tipY);
                phyloCtx.lineTo(tipX, tipY);
                phyloCtx.stroke();

                // Connect to parent
                if (sp.parentId !== null) {
                    const parentY = speciesYPositions[sp.parentId];
                    if (parentY !== undefined) {
                        phyloCtx.beginPath();
                        phyloCtx.moveTo(originX, tipY);
                        phyloCtx.lineTo(originX, parentY);
                        phyloCtx.stroke();
                    }
                }

                // Species tip
                phyloCtx.fillStyle = sp.color;
                phyloCtx.beginPath();
                phyloCtx.arc(tipX, tipY, 6, 0, Math.PI * 2);
                phyloCtx.fill();

                // Label
                phyloCtx.fillStyle = '#ffffffaa';
                phyloCtx.font = '9px sans-serif';
                phyloCtx.textAlign = 'right';
                phyloCtx.fillText(sp.name, tipX - 12, tipY + 3);
            }

            phyloCtx.fillStyle = '#ffffffaa';
            phyloCtx.textAlign = 'left';
            phyloCtx.fillText('Ancestor', padding, padding - 5);
            phyloCtx.textAlign = 'right';
            phyloCtx.fillText('Present', width - padding, padding - 5);
        }

        function drawDisplacement() {
            const width = displacementCanvas.width / (window.devicePixelRatio || 1);
            const height = displacementCanvas.height / (window.devicePixelRatio || 1);

            displacementCtx.fillStyle = '#1a1a2e';
            displacementCtx.fillRect(0, 0, width, height);

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Get trait distributions for each species
            const speciesTraits = {};
            for (const ind of individuals) {
                if (!speciesTraits[ind.speciesId]) {
                    speciesTraits[ind.speciesId] = [];
                }
                speciesTraits[ind.speciesId].push(ind.trait[0]);  // Use trait 1
            }

            // Draw histogram for each species
            const activeSpecies = species.filter(s => !s.extinct && speciesTraits[s.id]);
            const binCount = 20;

            for (const sp of activeSpecies) {
                const traits = speciesTraits[sp.id];
                if (!traits || traits.length === 0) continue;

                // Create histogram
                const histogram = new Array(binCount).fill(0);
                for (const t of traits) {
                    const bin = Math.min(binCount - 1, Math.floor(t * binCount));
                    histogram[bin]++;
                }

                const maxCount = Math.max(...histogram);
                const barWidth = graphWidth / binCount;

                displacementCtx.fillStyle = sp.color.replace(')', ', 0.5)').replace('hsl', 'hsla');

                for (let i = 0; i < binCount; i++) {
                    const barHeight = (histogram[i] / maxCount) * graphHeight * 0.3;
                    displacementCtx.fillRect(
                        padding + i * barWidth,
                        height - padding - barHeight,
                        barWidth - 1,
                        barHeight
                    );
                }
            }

            // Axes
            displacementCtx.strokeStyle = '#ffffff44';
            displacementCtx.beginPath();
            displacementCtx.moveTo(padding, height - padding);
            displacementCtx.lineTo(width - padding, height - padding);
            displacementCtx.stroke();

            displacementCtx.fillStyle = '#ffffffaa';
            displacementCtx.font = '10px sans-serif';
            displacementCtx.textAlign = 'center';
            displacementCtx.fillText('Trait 1 Distribution (Character Displacement)', width / 2, height - 10);
        }

        function updateStats() {
            const activeSpecies = species.filter(s => !s.extinct);
            const filledNiches = niches.filter(n => n.occupied).length;
            const meanFitness = individuals.length > 0 ?
                individuals.reduce((s, i) => s + i.fitness, 0) / individuals.length : 0;

            // Calculate trait disparity (variance in trait space)
            let disparity = 0;
            if (individuals.length > 1) {
                const meanT1 = individuals.reduce((s, i) => s + i.trait[0], 0) / individuals.length;
                const meanT2 = individuals.reduce((s, i) => s + i.trait[1], 0) / individuals.length;
                disparity = Math.sqrt(
                    individuals.reduce((s, i) =>
                        s + Math.pow(i.trait[0] - meanT1, 2) + Math.pow(i.trait[1] - meanT2, 2), 0
                    ) / individuals.length
                );
            }

            document.getElementById('genStat').textContent = generation;
            document.getElementById('speciesStat').textContent = activeSpecies.length;
            document.getElementById('popStat').textContent = individuals.length;
            document.getElementById('nichesStat').textContent = `${filledNiches}/${numNiches}`;
            document.getElementById('fitnessStat').textContent = meanFitness.toFixed(2);
            document.getElementById('disparityStat').textContent = disparity.toFixed(3);

            // Update species list
            const listHtml = activeSpecies.map(sp => {
                const count = individuals.filter(i => i.speciesId === sp.id).length;
                return `<span class="species-badge" style="background: ${sp.color};">${sp.name} (${count})</span>`;
            }).join('');
            document.getElementById('speciesList').innerHTML = listHtml;
        }

        function colonizeNewIsland() {
            // Simulate colonization of a new environment
            // Take a random subset of individuals and reset to a new trait space
            if (individuals.length < 10) return;

            const colonizers = individuals
                .sort(() => Math.random() - 0.5)
                .slice(0, Math.floor(individuals.length * 0.1));

            // Shift colonizers to new trait values
            for (const ind of colonizers) {
                ind.trait[0] = 0.5 + (Math.random() - 0.5) * 0.3;
                ind.trait[1] = 0.5 + (Math.random() - 0.5) * 0.3;
            }

            // Create new niches
            const oldNiches = niches.length;
            for (let i = 0; i < 3; i++) {
                niches.push({
                    name: `New Niche ${oldNiches + i + 1}`,
                    trait: [Math.random(), Math.random()],
                    id: oldNiches + i,
                    occupied: false,
                    population: 0
                });
            }
            numNiches = niches.length;
            document.getElementById('numNiches').value = numNiches;
            document.getElementById('numNichesVal').textContent = numNiches;
        }

        function animate() {
            step();

            drawTraitSpace();
            drawDiversity();
            drawNicheOccupancy();
            drawPhylogeny();
            drawDisplacement();
            updateStats();

            if (running) {
                animationId = requestAnimationFrame(animate);
            }
        }

        function start() {
            if (!running) {
                running = true;
                document.getElementById('startBtn').textContent = 'Pause';
                animate();
            } else {
                running = false;
                document.getElementById('startBtn').textContent = 'Start';
                if (animationId) cancelAnimationFrame(animationId);
            }
        }

        function reset() {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            if (animationId) cancelAnimationFrame(animationId);

            radiationModel = document.getElementById('radiationModel').value;
            numNiches = parseInt(document.getElementById('numNiches').value);
            nicheWidth = parseInt(document.getElementById('nicheWidth').value) / 100;
            initPop = parseInt(document.getElementById('initPop').value);
            carryCap = parseInt(document.getElementById('carryCap').value);
            growthRate = parseInt(document.getElementById('growthRate').value) / 100;
            mutRate = parseInt(document.getElementById('mutRate').value) / 1000;
            selStrength = parseInt(document.getElementById('selStrength').value) / 100;
            specThresh = parseInt(document.getElementById('specThresh').value) / 100;

            initPopulation();
            drawTraitSpace();
            drawDiversity();
            drawNicheOccupancy();
            drawPhylogeny();
            drawDisplacement();
            updateStats();
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', start);
        document.getElementById('resetBtn').addEventListener('click', reset);
        document.getElementById('colonizeBtn').addEventListener('click', colonizeNewIsland);

        document.getElementById('numNiches').addEventListener('input', (e) => {
            document.getElementById('numNichesVal').textContent = e.target.value;
        });

        document.getElementById('nicheWidth').addEventListener('input', (e) => {
            document.getElementById('nicheWidthVal').textContent = (e.target.value / 100).toFixed(2);
        });

        document.getElementById('initPop').addEventListener('input', (e) => {
            document.getElementById('initPopVal').textContent = e.target.value;
        });

        document.getElementById('carryCap').addEventListener('input', (e) => {
            document.getElementById('carryCapVal').textContent = e.target.value;
        });

        document.getElementById('growthRate').addEventListener('input', (e) => {
            document.getElementById('growthRateVal').textContent = (e.target.value / 100).toFixed(2);
        });

        document.getElementById('mutRate').addEventListener('input', (e) => {
            document.getElementById('mutRateVal').textContent = (e.target.value / 1000).toFixed(3);
        });

        document.getElementById('selStrength').addEventListener('input', (e) => {
            document.getElementById('selStrengthVal').textContent = (e.target.value / 100).toFixed(2);
        });

        document.getElementById('specThresh').addEventListener('input', (e) => {
            document.getElementById('specThreshVal').textContent = (e.target.value / 100).toFixed(2);
        });

        // Initialize
        function init() {
            setupCanvas(traitCanvas, traitCtx, 350);
            setupCanvas(diversityCanvas, diversityCtx, 180);
            setupCanvas(nicheCanvas, nicheCtx, 120);
            setupCanvas(phyloCanvas, phyloCtx, 180);
            setupCanvas(displacementCanvas, displacementCtx, 180);

            initPopulation();
            drawTraitSpace();
            drawDiversity();
            drawNicheOccupancy();
            drawPhylogeny();
            drawDisplacement();
            updateStats();
        }

        window.addEventListener('resize', () => {
            setupCanvas(traitCanvas, traitCtx, 350);
            setupCanvas(diversityCanvas, diversityCtx, 180);
            setupCanvas(nicheCanvas, nicheCtx, 120);
            setupCanvas(phyloCanvas, phyloCtx, 180);
            setupCanvas(displacementCanvas, displacementCtx, 180);
            drawTraitSpace();
            drawDiversity();
            drawNicheOccupancy();
            drawPhylogeny();
            drawDisplacement();
        });

        init();
    </script>
</body>
</html>
