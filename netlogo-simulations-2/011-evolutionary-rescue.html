<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolutionary Rescue Simulation</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        .back-link {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: var(--terracotta);
        }

        h1 {
            color: var(--dark-moss);
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .subtitle {
            color: var(--moss);
            font-size: 1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: var(--moss);
            font-size: 0.95em;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid var(--sage);
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            color: var(--dark-moss);
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group .value {
            text-align: right;
            font-size: 0.8em;
            color: var(--moss);
        }

        .control-group select {
            width: 100%;
            padding: 6px;
            border: 1px solid var(--sage);
            border-radius: 6px;
            font-size: 0.9em;
        }

        .button-group {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.3s;
        }

        .btn-primary {
            background: var(--sage);
            color: white;
        }

        .btn-primary:hover {
            background: var(--moss);
        }

        .btn-secondary {
            background: var(--earth);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--terracotta);
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .viz-panel {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .viz-panel h3 {
            color: var(--moss);
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        canvas {
            width: 100%;
            border-radius: 8px;
            background: #1a1a2e;
        }

        .viz-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .stat-box {
            background: linear-gradient(135deg, var(--cream) 0%, white 100%);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            border-left: 3px solid var(--sage);
        }

        .stat-box.highlight {
            border-left-color: var(--terracotta);
        }

        .stat-box.success {
            border-left-color: #4CAF50;
        }

        .stat-box.danger {
            border-left-color: #e74c3c;
        }

        .stat-box .label {
            font-size: 0.75em;
            color: var(--moss);
            margin-bottom: 4px;
        }

        .stat-box .value {
            font-size: 1.2em;
            font-weight: bold;
            color: var(--dark-moss);
        }

        .info-box {
            background: linear-gradient(135deg, #e3f2fd 0%, white 100%);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            font-size: 0.8em;
            color: var(--dark-moss);
        }

        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
            font-size: 0.8em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .outcome-badge {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .outcome-badge.rescued {
            background: #4CAF50;
            color: white;
        }

        .outcome-badge.extinct {
            background: #e74c3c;
            color: white;
        }

        .outcome-badge.ongoing {
            background: var(--earth);
            color: white;
        }

        .phase-indicator {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .phase {
            flex: 1;
            padding: 8px;
            text-align: center;
            border-radius: 6px;
            font-size: 0.75em;
            font-weight: 500;
        }

        .phase.before {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .phase.decline {
            background: #fff3e0;
            color: #e65100;
        }

        .phase.rescue {
            background: #e3f2fd;
            color: #1565c0;
        }

        .phase.recovery {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .phase.active {
            border: 2px solid currentColor;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">← Back to Simulations</a>
            <h1>Evolutionary Rescue</h1>
            <p class="subtitle">Can Evolution Outpace Environmental Change?</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-section">
                    <h3>Population Parameters</h3>
                    <div class="control-group">
                        <label>Initial Population (N₀): <span id="initPopVal">500</span></label>
                        <input type="range" id="initPop" min="100" max="2000" value="500" step="50">
                    </div>
                    <div class="control-group">
                        <label>Carrying Capacity (K): <span id="carryCapVal">1000</span></label>
                        <input type="range" id="carryCap" min="200" max="3000" value="1000" step="100">
                    </div>
                    <div class="control-group">
                        <label>Base Growth Rate (r): <span id="growthRateVal">0.10</span></label>
                        <input type="range" id="growthRate" min="1" max="30" value="10">
                        <div class="value">per generation</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Environmental Change</h3>
                    <div class="control-group">
                        <label>Change Type:</label>
                        <select id="changeType">
                            <option value="abrupt">Abrupt (sudden shift)</option>
                            <option value="gradual">Gradual (continuous)</option>
                            <option value="fluctuating">Fluctuating (periodic)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Change Severity: <span id="severityVal">0.80</span></label>
                        <input type="range" id="severity" min="20" max="99" value="80">
                        <div class="value">maladaptation penalty</div>
                    </div>
                    <div class="control-group" id="rateGroup">
                        <label>Rate of Change: <span id="changeRateVal">0.01</span></label>
                        <input type="range" id="changeRate" min="1" max="50" value="10">
                        <div class="value">optimum shift per gen</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Genetic Parameters</h3>
                    <div class="control-group">
                        <label>Mutation Rate: <span id="mutRateVal">0.001</span></label>
                        <input type="range" id="mutRate" min="1" max="50" value="10">
                        <div class="value">×10⁻⁴</div>
                    </div>
                    <div class="control-group">
                        <label>Standing Variation: <span id="standVarVal">0.10</span></label>
                        <input type="range" id="standVar" min="0" max="50" value="10">
                        <div class="value">initial genetic variance</div>
                    </div>
                    <div class="control-group">
                        <label>Mutation Effect Size: <span id="mutEffectVal">0.05</span></label>
                        <input type="range" id="mutEffect" min="1" max="30" value="5">
                        <div class="value">phenotypic change</div>
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="button-group">
                    <button class="btn-danger" id="triggerChange">Trigger Change</button>
                </div>

                <div class="info-box">
                    <strong>Evolutionary Rescue:</strong><br>
                    A U-shaped curve: population declines as environment changes, then recovers if beneficial mutations spread fast enough. The race is between extinction and adaptation.
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-panel">
                    <h3>Population Dynamics (U-Curve)</h3>
                    <canvas id="popCanvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4CAF50;"></div>
                            <span>Population Size</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FFC107;"></div>
                            <span>Carrying Capacity</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #f44336;"></div>
                            <span>Critical Threshold</span>
                        </div>
                    </div>
                    <div class="phase-indicator">
                        <div class="phase before" id="phaseBefore">Before Change</div>
                        <div class="phase decline" id="phaseDecline">Decline</div>
                        <div class="phase rescue" id="phaseRescue">Rescue</div>
                        <div class="phase recovery" id="phaseRecovery">Recovery</div>
                    </div>
                </div>

                <div class="viz-row">
                    <div class="viz-panel">
                        <h3>Phenotype Distribution vs Optimum</h3>
                        <canvas id="phenoCanvas"></canvas>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #2196F3;"></div>
                                <span>Population Phenotypes</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #E91E63;"></div>
                                <span>Environmental Optimum</span>
                            </div>
                        </div>
                    </div>
                    <div class="viz-panel">
                        <h3>Adaptation Over Time</h3>
                        <canvas id="adaptCanvas"></canvas>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #9C27B0;"></div>
                                <span>Mean Phenotype</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #E91E63;"></div>
                                <span>Optimum</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="viz-row">
                    <div class="viz-panel">
                        <h3>Fitness Distribution</h3>
                        <canvas id="fitnessCanvas"></canvas>
                    </div>
                    <div class="viz-panel">
                        <h3>Mutation Rescue Probability</h3>
                        <canvas id="rescueCanvas"></canvas>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="label">Generation</div>
                        <div class="value" id="genStat">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Population</div>
                        <div class="value" id="popStat">500</div>
                    </div>
                    <div class="stat-box highlight">
                        <div class="label">Mean Fitness</div>
                        <div class="value" id="fitStat">1.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Mean Phenotype</div>
                        <div class="value" id="phenoStat">0.00</div>
                    </div>
                    <div class="stat-box danger">
                        <div class="label">Maladaptation</div>
                        <div class="value" id="maladaptStat">0.00</div>
                    </div>
                    <div class="stat-box" id="outcomeStat">
                        <div class="label">Outcome</div>
                        <div class="value">Pending</div>
                    </div>
                </div>

                <div class="viz-panel">
                    <h3>Simulation Outcome</h3>
                    <div id="outcomeDisplay">
                        <span class="outcome-badge ongoing">Simulation Running</span>
                    </div>
                    <div id="outcomeDetails" style="margin-top: 10px; font-size: 0.85em;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const popCanvas = document.getElementById('popCanvas');
        const phenoCanvas = document.getElementById('phenoCanvas');
        const adaptCanvas = document.getElementById('adaptCanvas');
        const fitnessCanvas = document.getElementById('fitnessCanvas');
        const rescueCanvas = document.getElementById('rescueCanvas');

        const popCtx = popCanvas.getContext('2d');
        const phenoCtx = phenoCanvas.getContext('2d');
        const adaptCtx = adaptCanvas.getContext('2d');
        const fitnessCtx = fitnessCanvas.getContext('2d');
        const rescueCtx = rescueCanvas.getContext('2d');

        // Parameters
        let initPop = 500;
        let carryCap = 1000;
        let growthRate = 0.10;
        let changeType = 'abrupt';
        let severity = 0.80;
        let changeRate = 0.01;
        let mutRate = 0.001;
        let standVar = 0.10;
        let mutEffect = 0.05;

        // State
        let population = [];  // Array of phenotype values
        let generation = 0;
        let optimum = 0;  // Environmental optimum phenotype
        let originalOptimum = 0;
        let targetOptimum = 1;  // New optimum after change
        let changeTriggered = false;
        let changeGeneration = 0;
        let popHistory = [];
        let phenoHistory = [];
        let optimumHistory = [];
        let minPopulation = Infinity;
        let rescueGeneration = null;
        let running = false;
        let animationId = null;
        let outcome = 'ongoing';

        function setupCanvas(canvas, ctx, height) {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = (rect.width - 30) * dpr;
            canvas.height = height * dpr;
            canvas.style.width = (rect.width - 30) + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(dpr, dpr);
        }

        function initPopulation() {
            population = [];
            for (let i = 0; i < initPop; i++) {
                // Initial phenotype around optimum with standing variation
                const pheno = optimum + (Math.random() - 0.5) * 2 * standVar;
                population.push(pheno);
            }

            generation = 0;
            optimum = 0;
            originalOptimum = 0;
            targetOptimum = 1;
            changeTriggered = false;
            changeGeneration = 0;
            popHistory = [];
            phenoHistory = [];
            optimumHistory = [];
            minPopulation = Infinity;
            rescueGeneration = null;
            outcome = 'ongoing';

            updateOutcome();
        }

        function calculateFitness(phenotype) {
            // Gaussian fitness function centered on optimum
            const dist = phenotype - optimum;
            const width = 0.5;  // Width of fitness function
            let fitness = Math.exp(-(dist * dist) / (2 * width * width));

            // Apply severity penalty when away from optimum
            if (changeTriggered) {
                fitness *= (1 - severity * Math.min(1, Math.abs(dist)));
            }

            return Math.max(0, fitness);
        }

        function getMeanFitness() {
            if (population.length === 0) return 0;
            return population.reduce((sum, p) => sum + calculateFitness(p), 0) / population.length;
        }

        function getMeanPhenotype() {
            if (population.length === 0) return 0;
            return population.reduce((sum, p) => sum + p, 0) / population.length;
        }

        function reproduce() {
            if (population.length === 0) return;

            const fitnesses = population.map(calculateFitness);
            const totalFitness = fitnesses.reduce((a, b) => a + b, 0);

            if (totalFitness === 0) {
                population = [];
                return;
            }

            // Calculate expected population size with density dependence
            const meanFit = totalFitness / population.length;
            const r = growthRate * (1 - population.length / carryCap) * meanFit;
            let expectedN = Math.max(0, population.length * (1 + r));

            // Add stochasticity
            const actualN = Math.max(0, Math.round(expectedN + (Math.random() - 0.5) * Math.sqrt(expectedN)));

            const newPop = [];
            for (let i = 0; i < actualN && i < carryCap * 1.5; i++) {
                // Select parent proportional to fitness
                let r = Math.random() * totalFitness;
                let parentIdx = 0;
                let cumFitness = fitnesses[0];

                while (cumFitness < r && parentIdx < population.length - 1) {
                    parentIdx++;
                    cumFitness += fitnesses[parentIdx];
                }

                // Offspring phenotype with mutation
                let offspring = population[parentIdx];
                if (Math.random() < mutRate) {
                    // Mutation can be positive or negative
                    offspring += (Math.random() - 0.5) * 2 * mutEffect;
                }

                newPop.push(offspring);
            }

            population = newPop;
        }

        function updateEnvironment() {
            if (!changeTriggered) return;

            if (changeType === 'abrupt') {
                optimum = targetOptimum;
            } else if (changeType === 'gradual') {
                if (optimum < targetOptimum) {
                    optimum = Math.min(optimum + changeRate, targetOptimum);
                }
            } else if (changeType === 'fluctuating') {
                const period = 50;
                const amplitude = 0.3;
                optimum = targetOptimum + amplitude * Math.sin((generation - changeGeneration) * 2 * Math.PI / period);
            }
        }

        function checkOutcome() {
            if (population.length === 0) {
                outcome = 'extinct';
                return;
            }

            if (changeTriggered) {
                const meanPheno = getMeanPhenotype();
                const meanFit = getMeanFitness();

                // Track minimum population
                if (population.length < minPopulation) {
                    minPopulation = population.length;
                }

                // Check for rescue: population recovering after decline
                if (rescueGeneration === null && minPopulation < initPop * 0.5) {
                    if (population.length > minPopulation * 1.5 && meanFit > 0.5) {
                        rescueGeneration = generation;
                    }
                }

                // Check for successful rescue
                if (rescueGeneration !== null &&
                    population.length > initPop * 0.8 &&
                    Math.abs(meanPheno - optimum) < 0.2) {
                    outcome = 'rescued';
                }
            }
        }

        function step() {
            updateEnvironment();
            reproduce();
            generation++;

            checkOutcome();

            // Record history
            popHistory.push({ gen: generation, pop: population.length });
            phenoHistory.push({ gen: generation, mean: getMeanPhenotype() });
            optimumHistory.push({ gen: generation, opt: optimum });

            if (popHistory.length > 500) {
                popHistory = popHistory.filter((_, i) => i % 2 === 0);
                phenoHistory = phenoHistory.filter((_, i) => i % 2 === 0);
                optimumHistory = optimumHistory.filter((_, i) => i % 2 === 0);
            }
        }

        function drawPopulation() {
            const width = popCanvas.width / (window.devicePixelRatio || 1);
            const height = popCanvas.height / (window.devicePixelRatio || 1);

            popCtx.fillStyle = '#1a1a2e';
            popCtx.fillRect(0, 0, width, height);

            const padding = 50;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Axes
            popCtx.strokeStyle = '#ffffff44';
            popCtx.beginPath();
            popCtx.moveTo(padding, padding);
            popCtx.lineTo(padding, height - padding);
            popCtx.lineTo(width - padding, height - padding);
            popCtx.stroke();

            popCtx.fillStyle = '#ffffffaa';
            popCtx.font = '11px sans-serif';
            popCtx.fillText('Population', padding, padding - 10);
            popCtx.fillText('Generation', width - padding - 50, height - 10);

            if (popHistory.length < 2) return;

            const maxGen = popHistory[popHistory.length - 1].gen;
            const maxPop = Math.max(carryCap, ...popHistory.map(p => p.pop));

            // Draw carrying capacity line
            popCtx.strokeStyle = '#FFC107';
            popCtx.lineWidth = 1;
            popCtx.setLineDash([5, 5]);
            const kY = height - padding - (carryCap / maxPop) * graphHeight;
            popCtx.beginPath();
            popCtx.moveTo(padding, kY);
            popCtx.lineTo(width - padding, kY);
            popCtx.stroke();
            popCtx.setLineDash([]);

            // Draw critical threshold (5% of initial)
            popCtx.strokeStyle = '#f44336';
            const critY = height - padding - (initPop * 0.05 / maxPop) * graphHeight;
            popCtx.beginPath();
            popCtx.moveTo(padding, critY);
            popCtx.lineTo(width - padding, critY);
            popCtx.stroke();

            // Draw change event line
            if (changeTriggered && changeGeneration > 0) {
                const changeX = padding + (changeGeneration / maxGen) * graphWidth;
                popCtx.strokeStyle = '#E91E63';
                popCtx.lineWidth = 2;
                popCtx.setLineDash([3, 3]);
                popCtx.beginPath();
                popCtx.moveTo(changeX, padding);
                popCtx.lineTo(changeX, height - padding);
                popCtx.stroke();
                popCtx.setLineDash([]);
                popCtx.fillStyle = '#E91E63';
                popCtx.fillText('Change', changeX + 5, padding + 15);
            }

            // Draw rescue point
            if (rescueGeneration !== null) {
                const rescueX = padding + (rescueGeneration / maxGen) * graphWidth;
                popCtx.strokeStyle = '#4CAF50';
                popCtx.lineWidth = 2;
                popCtx.setLineDash([3, 3]);
                popCtx.beginPath();
                popCtx.moveTo(rescueX, padding);
                popCtx.lineTo(rescueX, height - padding);
                popCtx.stroke();
                popCtx.setLineDash([]);
                popCtx.fillStyle = '#4CAF50';
                popCtx.fillText('Rescue!', rescueX + 5, padding + 30);
            }

            // Draw population line
            popCtx.strokeStyle = '#4CAF50';
            popCtx.lineWidth = 2;
            popCtx.beginPath();

            popHistory.forEach((point, i) => {
                const x = padding + (point.gen / maxGen) * graphWidth;
                const y = height - padding - (point.pop / maxPop) * graphHeight;

                if (i === 0) {
                    popCtx.moveTo(x, y);
                } else {
                    popCtx.lineTo(x, y);
                }
            });
            popCtx.stroke();
        }

        function drawPhenotype() {
            const width = phenoCanvas.width / (window.devicePixelRatio || 1);
            const height = phenoCanvas.height / (window.devicePixelRatio || 1);

            phenoCtx.fillStyle = '#1a1a2e';
            phenoCtx.fillRect(0, 0, width, height);

            const padding = 30;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            if (population.length === 0) {
                phenoCtx.fillStyle = '#f44336';
                phenoCtx.font = 'bold 20px sans-serif';
                phenoCtx.textAlign = 'center';
                phenoCtx.fillText('EXTINCT', width / 2, height / 2);
                return;
            }

            // Create histogram of phenotypes
            const minP = Math.min(-0.5, ...population);
            const maxP = Math.max(1.5, ...population);
            const range = maxP - minP;
            const bins = 30;
            const histogram = new Array(bins).fill(0);

            population.forEach(p => {
                const bin = Math.min(bins - 1, Math.max(0, Math.floor((p - minP) / range * bins)));
                histogram[bin]++;
            });

            const maxCount = Math.max(...histogram);
            const barWidth = graphWidth / bins;

            // Draw histogram
            histogram.forEach((count, i) => {
                const x = padding + i * barWidth;
                const barHeight = (count / maxCount) * graphHeight * 0.8;

                phenoCtx.fillStyle = '#2196F3';
                phenoCtx.fillRect(x, height - padding - barHeight, barWidth - 1, barHeight);
            });

            // Draw optimum line
            const optX = padding + ((optimum - minP) / range) * graphWidth;
            phenoCtx.strokeStyle = '#E91E63';
            phenoCtx.lineWidth = 3;
            phenoCtx.beginPath();
            phenoCtx.moveTo(optX, padding);
            phenoCtx.lineTo(optX, height - padding);
            phenoCtx.stroke();

            phenoCtx.fillStyle = '#E91E63';
            phenoCtx.font = '10px sans-serif';
            phenoCtx.fillText('Optimum', optX + 5, padding + 15);

            phenoCtx.fillStyle = '#ffffffaa';
            phenoCtx.fillText('Phenotype Distribution', padding, padding - 10);
        }

        function drawAdaptation() {
            const width = adaptCanvas.width / (window.devicePixelRatio || 1);
            const height = adaptCanvas.height / (window.devicePixelRatio || 1);

            adaptCtx.fillStyle = '#1a1a2e';
            adaptCtx.fillRect(0, 0, width, height);

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Axes
            adaptCtx.strokeStyle = '#ffffff44';
            adaptCtx.beginPath();
            adaptCtx.moveTo(padding, padding);
            adaptCtx.lineTo(padding, height - padding);
            adaptCtx.lineTo(width - padding, height - padding);
            adaptCtx.stroke();

            if (phenoHistory.length < 2) return;

            const maxGen = phenoHistory[phenoHistory.length - 1].gen;
            const allPhenos = phenoHistory.map(p => p.mean).concat(optimumHistory.map(o => o.opt));
            const minP = Math.min(...allPhenos) - 0.1;
            const maxP = Math.max(...allPhenos) + 0.1;
            const rangeP = maxP - minP;

            // Draw optimum line
            adaptCtx.strokeStyle = '#E91E63';
            adaptCtx.lineWidth = 2;
            adaptCtx.beginPath();

            optimumHistory.forEach((point, i) => {
                const x = padding + (point.gen / maxGen) * graphWidth;
                const y = height - padding - ((point.opt - minP) / rangeP) * graphHeight;

                if (i === 0) {
                    adaptCtx.moveTo(x, y);
                } else {
                    adaptCtx.lineTo(x, y);
                }
            });
            adaptCtx.stroke();

            // Draw mean phenotype
            adaptCtx.strokeStyle = '#9C27B0';
            adaptCtx.lineWidth = 2;
            adaptCtx.beginPath();

            phenoHistory.forEach((point, i) => {
                const x = padding + (point.gen / maxGen) * graphWidth;
                const y = height - padding - ((point.mean - minP) / rangeP) * graphHeight;

                if (i === 0) {
                    adaptCtx.moveTo(x, y);
                } else {
                    adaptCtx.lineTo(x, y);
                }
            });
            adaptCtx.stroke();

            adaptCtx.fillStyle = '#ffffffaa';
            adaptCtx.font = '10px sans-serif';
            adaptCtx.fillText('Tracking Optimum', padding, padding - 10);
        }

        function drawFitness() {
            const width = fitnessCanvas.width / (window.devicePixelRatio || 1);
            const height = fitnessCanvas.height / (window.devicePixelRatio || 1);

            fitnessCtx.fillStyle = '#1a1a2e';
            fitnessCtx.fillRect(0, 0, width, height);

            const padding = 30;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            if (population.length === 0) return;

            // Fitness histogram
            const fitnesses = population.map(calculateFitness);
            const bins = 20;
            const histogram = new Array(bins).fill(0);

            fitnesses.forEach(f => {
                const bin = Math.min(bins - 1, Math.max(0, Math.floor(f * bins)));
                histogram[bin]++;
            });

            const maxCount = Math.max(...histogram);
            const barWidth = graphWidth / bins;

            histogram.forEach((count, i) => {
                const x = padding + i * barWidth;
                const barHeight = (count / maxCount) * graphHeight;

                const hue = (i / bins) * 120;  // Red to green
                fitnessCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                fitnessCtx.fillRect(x, height - padding - barHeight, barWidth - 1, barHeight);
            });

            fitnessCtx.fillStyle = '#ffffffaa';
            fitnessCtx.font = '10px sans-serif';
            fitnessCtx.fillText('Fitness Distribution', padding, padding - 10);
            fitnessCtx.fillText('0', padding, height - 10);
            fitnessCtx.fillText('1', width - padding - 10, height - 10);
        }

        function drawRescueProbability() {
            const width = rescueCanvas.width / (window.devicePixelRatio || 1);
            const height = rescueCanvas.height / (window.devicePixelRatio || 1);

            rescueCtx.fillStyle = '#1a1a2e';
            rescueCtx.fillRect(0, 0, width, height);

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Draw rescue probability curves for different mutation rates
            const mutRates = [0.0001, 0.001, 0.01];
            const colors = ['#f44336', '#FFC107', '#4CAF50'];

            mutRates.forEach((mu, idx) => {
                rescueCtx.strokeStyle = colors[idx];
                rescueCtx.lineWidth = 2;
                rescueCtx.beginPath();

                for (let n = 10; n <= 1000; n += 10) {
                    // Approximate rescue probability: P ≈ 1 - exp(-2*N*u*s)
                    const s = 0.1;  // Selection coefficient
                    const prob = 1 - Math.exp(-2 * n * mu * s);

                    const x = padding + (n / 1000) * graphWidth;
                    const y = height - padding - prob * graphHeight;

                    if (n === 10) {
                        rescueCtx.moveTo(x, y);
                    } else {
                        rescueCtx.lineTo(x, y);
                    }
                }
                rescueCtx.stroke();
            });

            // Mark current population
            const currentX = padding + (population.length / 1000) * graphWidth;
            rescueCtx.strokeStyle = 'white';
            rescueCtx.setLineDash([3, 3]);
            rescueCtx.beginPath();
            rescueCtx.moveTo(currentX, height - padding);
            rescueCtx.lineTo(currentX, padding);
            rescueCtx.stroke();
            rescueCtx.setLineDash([]);

            rescueCtx.fillStyle = '#ffffffaa';
            rescueCtx.font = '10px sans-serif';
            rescueCtx.fillText('P(rescue) vs N', padding, padding - 10);
            rescueCtx.fillText('N', width - padding - 10, height - 10);

            // Legend
            rescueCtx.font = '8px sans-serif';
            mutRates.forEach((mu, idx) => {
                rescueCtx.fillStyle = colors[idx];
                rescueCtx.fillText(`μ=${mu}`, width - padding - 40, padding + 15 + idx * 12);
            });
        }

        function updatePhases() {
            document.querySelectorAll('.phase').forEach(p => p.classList.remove('active'));

            if (!changeTriggered) {
                document.getElementById('phaseBefore').classList.add('active');
            } else if (population.length < minPopulation * 1.1) {
                document.getElementById('phaseDecline').classList.add('active');
            } else if (rescueGeneration === null) {
                document.getElementById('phaseRescue').classList.add('active');
            } else {
                document.getElementById('phaseRecovery').classList.add('active');
            }
        }

        function updateOutcome() {
            const display = document.getElementById('outcomeDisplay');
            const details = document.getElementById('outcomeDetails');

            if (outcome === 'extinct') {
                display.innerHTML = '<span class="outcome-badge extinct">EXTINCTION</span>';
                details.textContent = `Population went extinct at generation ${generation}. Adaptation was too slow to outpace environmental change.`;
            } else if (outcome === 'rescued') {
                display.innerHTML = '<span class="outcome-badge rescued">EVOLUTIONARY RESCUE</span>';
                details.textContent = `Population rescued at generation ${rescueGeneration}! Minimum population: ${minPopulation}. Adaptation outpaced extinction.`;
            } else {
                display.innerHTML = '<span class="outcome-badge ongoing">Simulation Running</span>';
                if (changeTriggered) {
                    details.textContent = `Change triggered at generation ${changeGeneration}. Minimum population so far: ${minPopulation === Infinity ? 'N/A' : minPopulation}`;
                } else {
                    details.textContent = 'Waiting for environmental change to be triggered...';
                }
            }
        }

        function updateStats() {
            document.getElementById('genStat').textContent = generation;
            document.getElementById('popStat').textContent = population.length;
            document.getElementById('fitStat').textContent = getMeanFitness().toFixed(3);
            document.getElementById('phenoStat').textContent = getMeanPhenotype().toFixed(3);
            document.getElementById('maladaptStat').textContent = Math.abs(getMeanPhenotype() - optimum).toFixed(3);

            const outcomeStat = document.getElementById('outcomeStat');
            outcomeStat.querySelector('.value').textContent =
                outcome === 'extinct' ? 'Extinct' :
                outcome === 'rescued' ? 'Rescued!' : 'Pending';

            outcomeStat.classList.remove('success', 'danger');
            if (outcome === 'rescued') outcomeStat.classList.add('success');
            if (outcome === 'extinct') outcomeStat.classList.add('danger');

            updatePhases();
            updateOutcome();
        }

        function animate() {
            step();

            drawPopulation();
            drawPhenotype();
            drawAdaptation();
            drawFitness();
            drawRescueProbability();
            updateStats();

            if (running && outcome === 'ongoing') {
                animationId = requestAnimationFrame(animate);
            } else if (outcome !== 'ongoing') {
                running = false;
                document.getElementById('startBtn').textContent = 'Start';
            }
        }

        function start() {
            if (!running) {
                running = true;
                document.getElementById('startBtn').textContent = 'Pause';
                animate();
            } else {
                running = false;
                document.getElementById('startBtn').textContent = 'Start';
                if (animationId) cancelAnimationFrame(animationId);
            }
        }

        function reset() {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            if (animationId) cancelAnimationFrame(animationId);

            initPop = parseInt(document.getElementById('initPop').value);
            carryCap = parseInt(document.getElementById('carryCap').value);
            growthRate = parseInt(document.getElementById('growthRate').value) / 100;
            changeType = document.getElementById('changeType').value;
            severity = parseInt(document.getElementById('severity').value) / 100;
            changeRate = parseInt(document.getElementById('changeRate').value) / 1000;
            mutRate = parseInt(document.getElementById('mutRate').value) / 10000;
            standVar = parseInt(document.getElementById('standVar').value) / 100;
            mutEffect = parseInt(document.getElementById('mutEffect').value) / 100;

            initPopulation();
            drawPopulation();
            drawPhenotype();
            drawAdaptation();
            drawFitness();
            drawRescueProbability();
            updateStats();
        }

        function triggerChange() {
            if (!changeTriggered) {
                changeTriggered = true;
                changeGeneration = generation;
                minPopulation = population.length;
            }
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', start);
        document.getElementById('resetBtn').addEventListener('click', reset);
        document.getElementById('triggerChange').addEventListener('click', triggerChange);

        document.getElementById('initPop').addEventListener('input', (e) => {
            document.getElementById('initPopVal').textContent = e.target.value;
        });

        document.getElementById('carryCap').addEventListener('input', (e) => {
            document.getElementById('carryCapVal').textContent = e.target.value;
        });

        document.getElementById('growthRate').addEventListener('input', (e) => {
            document.getElementById('growthRateVal').textContent = (e.target.value / 100).toFixed(2);
        });

        document.getElementById('changeType').addEventListener('change', (e) => {
            document.getElementById('rateGroup').style.display =
                e.target.value === 'abrupt' ? 'none' : 'block';
        });

        document.getElementById('severity').addEventListener('input', (e) => {
            document.getElementById('severityVal').textContent = (e.target.value / 100).toFixed(2);
        });

        document.getElementById('changeRate').addEventListener('input', (e) => {
            document.getElementById('changeRateVal').textContent = (e.target.value / 1000).toFixed(3);
        });

        document.getElementById('mutRate').addEventListener('input', (e) => {
            document.getElementById('mutRateVal').textContent = (e.target.value / 10000).toFixed(4);
        });

        document.getElementById('standVar').addEventListener('input', (e) => {
            document.getElementById('standVarVal').textContent = (e.target.value / 100).toFixed(2);
        });

        document.getElementById('mutEffect').addEventListener('input', (e) => {
            document.getElementById('mutEffectVal').textContent = (e.target.value / 100).toFixed(2);
        });

        // Initialize
        function init() {
            setupCanvas(popCanvas, popCtx, 220);
            setupCanvas(phenoCanvas, phenoCtx, 180);
            setupCanvas(adaptCanvas, adaptCtx, 180);
            setupCanvas(fitnessCanvas, fitnessCtx, 150);
            setupCanvas(rescueCanvas, rescueCtx, 150);

            document.getElementById('rateGroup').style.display = 'none';

            initPopulation();
            drawPopulation();
            drawPhenotype();
            drawAdaptation();
            drawFitness();
            drawRescueProbability();
            updateStats();
        }

        window.addEventListener('resize', () => {
            setupCanvas(popCanvas, popCtx, 220);
            setupCanvas(phenoCanvas, phenoCtx, 180);
            setupCanvas(adaptCanvas, adaptCtx, 180);
            setupCanvas(fitnessCanvas, fitnessCtx, 150);
            setupCanvas(rescueCanvas, rescueCtx, 150);
            drawPopulation();
            drawPhenotype();
            drawAdaptation();
            drawFitness();
            drawRescueProbability();
        });

        init();
    </script>
</body>
</html>
