<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Swarm Optimization - Function Optimization</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { font-family: 'Lora', serif; color: #606C38; font-size: 2rem; margin-bottom: 8px; }
        .subtitle { color: #8A9A5B; font-size: 1rem; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #606C38; font-weight: 600; }
        .main-content { display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .canvas-container { background: #1a1a2e; border-radius: 12px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        canvas { width: 100%; border-radius: 8px; display: block; }
        .controls { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); height: fit-content; }
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; color: #606C38; font-weight: 600; margin-bottom: 5px; font-size: 0.9rem; }
        .control-group input[type="range"] { width: 100%; accent-color: #8A9A5B; }
        .control-group select { width: 100%; padding: 8px; border: 1px solid #DDA15E; border-radius: 6px; font-family: inherit; }
        .control-value { text-align: right; color: #8A9A5B; font-size: 0.85rem; }
        button { width: 100%; padding: 10px; margin-top: 5px; border: none; border-radius: 8px; cursor: pointer; font-family: 'Nunito', sans-serif; font-weight: 600; font-size: 0.9rem; transition: all 0.3s; }
        .btn-primary { background: #8A9A5B; color: white; }
        .btn-secondary { background: #DDA15E; color: white; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        .stat-box { background: linear-gradient(135deg, #FEFAE0, #F4F1DE); padding: 10px; border-radius: 8px; text-align: center; }
        .stat-value { font-family: 'Lora', serif; color: #606C38; font-size: 1rem; font-weight: 600; }
        .stat-label { color: #8A9A5B; font-size: 0.75rem; }
        .info-panel { margin-top: 15px; padding: 12px; background: #F4F1DE; border-radius: 8px; font-size: 0.8rem; color: #606C38; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Particle Swarm Optimization</h1>
            <p class="subtitle">Swarm intelligence for continuous function optimization</p>
        </header>
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="simCanvas"></canvas>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>Function</label>
                    <select id="function">
                        <option value="rastrigin">Rastrigin (many local minima)</option>
                        <option value="rosenbrock">Rosenbrock (valley)</option>
                        <option value="ackley">Ackley (many local minima)</option>
                        <option value="sphere">Sphere (simple)</option>
                        <option value="himmelblau">Himmelblau (4 minima)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Swarm Size</label>
                    <input type="range" id="swarmSize" min="10" max="100" value="30">
                    <div class="control-value"><span id="swarmSizeVal">30</span> particles</div>
                </div>
                <div class="control-group">
                    <label>Inertia Weight (ω)</label>
                    <input type="range" id="inertia" min="0" max="100" value="70">
                    <div class="control-value"><span id="inertiaVal">0.70</span></div>
                </div>
                <div class="control-group">
                    <label>Cognitive Weight (c₁)</label>
                    <input type="range" id="cognitive" min="0" max="40" value="15">
                    <div class="control-value"><span id="cognitiveVal">1.5</span></div>
                </div>
                <div class="control-group">
                    <label>Social Weight (c₂)</label>
                    <input type="range" id="social" min="0" max="40" value="15">
                    <div class="control-value"><span id="socialVal">1.5</span></div>
                </div>
                <button class="btn-primary" onclick="toggleSimulation()">Start/Pause</button>
                <button class="btn-secondary" onclick="resetSimulation()">Reset Swarm</button>

                <div class="stats-grid">
                    <div class="stat-box"><div class="stat-value" id="iteration">0</div><div class="stat-label">Iteration</div></div>
                    <div class="stat-box"><div class="stat-value" id="bestValue">∞</div><div class="stat-label">Best Value</div></div>
                    <div class="stat-box"><div class="stat-value" id="bestX">-</div><div class="stat-label">Best X</div></div>
                    <div class="stat-box"><div class="stat-value" id="bestY">-</div><div class="stat-label">Best Y</div></div>
                </div>

                <div class="info-panel">
                    <strong>PSO (Kennedy & Eberhart 1995):</strong> Each particle remembers its personal best and shares information about the global best. Particles accelerate toward these attractors while maintaining momentum.
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        function setupCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.width * dpr;
            canvas.style.height = rect.width + 'px';
            ctx.scale(dpr, dpr);
            return { width: rect.width, height: rect.width };
        }

        let dims = setupCanvas();
        window.addEventListener('resize', () => { dims = setupCanvas(); });

        // Test functions (minimization problems)
        const functions = {
            rastrigin: {
                fn: (x, y) => 20 + (x*x - 10*Math.cos(2*Math.PI*x)) + (y*y - 10*Math.cos(2*Math.PI*y)),
                range: [-5.12, 5.12],
                optimum: { x: 0, y: 0, value: 0 }
            },
            rosenbrock: {
                fn: (x, y) => Math.pow(1 - x, 2) + 100 * Math.pow(y - x*x, 2),
                range: [-5, 5],
                optimum: { x: 1, y: 1, value: 0 }
            },
            ackley: {
                fn: (x, y) => -20*Math.exp(-0.2*Math.sqrt(0.5*(x*x + y*y))) -
                             Math.exp(0.5*(Math.cos(2*Math.PI*x) + Math.cos(2*Math.PI*y))) + Math.E + 20,
                range: [-5, 5],
                optimum: { x: 0, y: 0, value: 0 }
            },
            sphere: {
                fn: (x, y) => x*x + y*y,
                range: [-5, 5],
                optimum: { x: 0, y: 0, value: 0 }
            },
            himmelblau: {
                fn: (x, y) => Math.pow(x*x + y - 11, 2) + Math.pow(x + y*y - 7, 2),
                range: [-5, 5],
                optimum: { x: 3, y: 2, value: 0 }
            }
        };

        class Particle {
            constructor(range) {
                this.x = range[0] + Math.random() * (range[1] - range[0]);
                this.y = range[0] + Math.random() * (range[1] - range[0]);
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.pBestX = this.x;
                this.pBestY = this.y;
                this.pBestValue = Infinity;
            }

            update(gBestX, gBestY, w, c1, c2, range, fn) {
                // Update velocity
                const r1 = Math.random();
                const r2 = Math.random();

                this.vx = w * this.vx +
                          c1 * r1 * (this.pBestX - this.x) +
                          c2 * r2 * (gBestX - this.x);
                this.vy = w * this.vy +
                          c1 * r1 * (this.pBestY - this.y) +
                          c2 * r2 * (gBestY - this.y);

                // Clamp velocity
                const maxV = (range[1] - range[0]) * 0.1;
                this.vx = Math.max(-maxV, Math.min(maxV, this.vx));
                this.vy = Math.max(-maxV, Math.min(maxV, this.vy));

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Boundary handling (reflection)
                if (this.x < range[0]) { this.x = range[0]; this.vx *= -0.5; }
                if (this.x > range[1]) { this.x = range[1]; this.vx *= -0.5; }
                if (this.y < range[0]) { this.y = range[0]; this.vy *= -0.5; }
                if (this.y > range[1]) { this.y = range[1]; this.vy *= -0.5; }

                // Evaluate and update personal best
                const value = fn(this.x, this.y);
                if (value < this.pBestValue) {
                    this.pBestValue = value;
                    this.pBestX = this.x;
                    this.pBestY = this.y;
                }

                return value;
            }
        }

        let state = {
            running: false,
            particles: [],
            gBestX: 0,
            gBestY: 0,
            gBestValue: Infinity,
            iteration: 0,
            functionData: null,
            landscapeCache: null
        };

        function generateLandscape() {
            const funcName = document.getElementById('function').value;
            const func = functions[funcName];
            const resolution = 100;
            const data = [];

            let min = Infinity, max = -Infinity;

            for (let i = 0; i < resolution; i++) {
                data[i] = [];
                for (let j = 0; j < resolution; j++) {
                    const x = func.range[0] + (i / (resolution - 1)) * (func.range[1] - func.range[0]);
                    const y = func.range[0] + (j / (resolution - 1)) * (func.range[1] - func.range[0]);
                    const value = func.fn(x, y);
                    data[i][j] = value;
                    min = Math.min(min, value);
                    max = Math.max(max, value);
                }
            }

            state.functionData = { data, min, max, resolution };
            renderLandscapeToCache();
        }

        function renderLandscapeToCache() {
            const { data, min, max, resolution } = state.functionData;
            const cellW = dims.width / resolution;
            const cellH = dims.height / resolution;

            // Create offscreen canvas for landscape
            const offscreen = document.createElement('canvas');
            offscreen.width = dims.width;
            offscreen.height = dims.height;
            const offCtx = offscreen.getContext('2d');

            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const normalized = (data[i][j] - min) / (max - min + 0.001);
                    const hue = 240 - normalized * 240; // Blue (low) to Red (high)
                    offCtx.fillStyle = `hsl(${hue}, 70%, ${30 + normalized * 30}%)`;
                    offCtx.fillRect(i * cellW, j * cellH, cellW + 1, cellH + 1);
                }
            }

            state.landscapeCache = offscreen;
        }

        function initSwarm() {
            const size = parseInt(document.getElementById('swarmSize').value);
            const funcName = document.getElementById('function').value;
            const func = functions[funcName];

            state.particles = [];
            state.gBestValue = Infinity;
            state.iteration = 0;

            for (let i = 0; i < size; i++) {
                const p = new Particle(func.range);
                const value = func.fn(p.x, p.y);
                p.pBestValue = value;

                if (value < state.gBestValue) {
                    state.gBestValue = value;
                    state.gBestX = p.x;
                    state.gBestY = p.y;
                }

                state.particles.push(p);
            }

            generateLandscape();
        }

        function update() {
            if (!state.running) return;

            const funcName = document.getElementById('function').value;
            const func = functions[funcName];
            const w = parseInt(document.getElementById('inertia').value) / 100;
            const c1 = parseInt(document.getElementById('cognitive').value) / 10;
            const c2 = parseInt(document.getElementById('social').value) / 10;

            state.iteration++;

            for (const p of state.particles) {
                const value = p.update(state.gBestX, state.gBestY, w, c1, c2, func.range, func.fn);

                if (value < state.gBestValue) {
                    state.gBestValue = value;
                    state.gBestX = p.x;
                    state.gBestY = p.y;
                }
            }

            updateStats();
            draw();

            if (state.iteration < 500 && state.gBestValue > 0.0001) {
                setTimeout(() => requestAnimationFrame(update), 30);
            } else {
                state.running = false;
            }
        }

        function draw() {
            const funcName = document.getElementById('function').value;
            const func = functions[funcName];

            // Draw cached landscape
            if (state.landscapeCache) {
                ctx.drawImage(state.landscapeCache, 0, 0, dims.width, dims.height);
            }

            // Contour lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;

            // Convert coordinates
            function toScreen(x, y) {
                return {
                    sx: ((x - func.range[0]) / (func.range[1] - func.range[0])) * dims.width,
                    sy: ((y - func.range[0]) / (func.range[1] - func.range[0])) * dims.height
                };
            }

            // Draw velocity vectors and particles
            for (const p of state.particles) {
                const { sx, sy } = toScreen(p.x, p.y);
                const { sx: psx, sy: psy } = toScreen(p.pBestX, p.pBestY);

                // Trail to personal best
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(psx, psy);
                ctx.stroke();

                // Velocity vector
                ctx.strokeStyle = 'rgba(255, 200, 100, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(sx + p.vx * 20, sy + p.vy * 20);
                ctx.stroke();

                // Particle
                ctx.fillStyle = '#4fc3f7';
                ctx.beginPath();
                ctx.arc(sx, sy, 5, 0, Math.PI * 2);
                ctx.fill();

                // Personal best marker
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(psx, psy, 3, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Global best marker
            const { sx: gsx, sy: gsy } = toScreen(state.gBestX, state.gBestY);
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.arc(gsx, gsy, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();

            // True optimum marker
            const { sx: osx, sy: osy } = toScreen(func.optimum.x, func.optimum.y);
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(osx - 8, osy - 8);
            ctx.lineTo(osx + 8, osy + 8);
            ctx.moveTo(osx + 8, osy - 8);
            ctx.lineTo(osx - 8, osy + 8);
            ctx.stroke();

            // Legend
            ctx.fillStyle = 'white';
            ctx.font = '12px Nunito';
            ctx.fillText('× True Optimum', 10, dims.height - 30);
            ctx.fillText('● Global Best', 10, dims.height - 10);

            // Title
            ctx.font = '14px Lora';
            ctx.fillText(`PSO: ${funcName.charAt(0).toUpperCase() + funcName.slice(1)} Function`, 10, 25);
        }

        function updateStats() {
            document.getElementById('iteration').textContent = state.iteration;
            document.getElementById('bestValue').textContent = state.gBestValue.toExponential(2);
            document.getElementById('bestX').textContent = state.gBestX.toFixed(4);
            document.getElementById('bestY').textContent = state.gBestY.toFixed(4);
        }

        function toggleSimulation() {
            state.running = !state.running;
            if (state.running) update();
        }

        function resetSimulation() {
            state.running = false;
            initSwarm();
            draw();
        }

        // Slider displays
        function updateSliderDisplays() {
            document.getElementById('swarmSizeVal').textContent = document.getElementById('swarmSize').value;
            document.getElementById('inertiaVal').textContent = (parseInt(document.getElementById('inertia').value) / 100).toFixed(2);
            document.getElementById('cognitiveVal').textContent = (parseInt(document.getElementById('cognitive').value) / 10).toFixed(1);
            document.getElementById('socialVal').textContent = (parseInt(document.getElementById('social').value) / 10).toFixed(1);
        }

        document.querySelectorAll('input[type="range"]').forEach(s => s.addEventListener('input', updateSliderDisplays));
        document.getElementById('function').addEventListener('change', resetSimulation);

        initSwarm();
        draw();
    </script>
</body>
</html>
