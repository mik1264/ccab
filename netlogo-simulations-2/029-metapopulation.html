<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metapopulation Dynamics - NetLogo Simulation</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            color: var(--dark-moss);
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .subtitle {
            color: var(--moss);
            font-size: 1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .control-group {
            margin-bottom: 16px;
        }

        .control-group label {
            display: block;
            color: var(--dark-moss);
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 0.85rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            border: 2px solid var(--sage);
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .value-display {
            text-align: right;
            color: var(--moss);
            font-size: 0.8rem;
            margin-top: 3px;
        }

        .buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 80px;
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--sage);
            color: white;
        }

        .btn-primary:hover {
            background: var(--moss);
        }

        .btn-secondary {
            background: var(--earth);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--terracotta);
        }

        .visualization-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 15px;
        }

        .viz-panel {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .viz-panel h3 {
            color: var(--dark-moss);
            font-size: 0.9rem;
            margin-bottom: 10px;
            text-align: center;
        }

        canvas {
            width: 100%;
            height: 250px;
            border-radius: 8px;
            background: #1a1a2e;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 15px;
        }

        .stat-item {
            background: var(--cream);
            padding: 8px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--terracotta);
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--moss);
        }

        .info-box {
            background: linear-gradient(135deg, var(--cream) 0%, #fff 100%);
            border-left: 4px solid var(--sage);
            padding: 12px;
            margin-top: 15px;
            border-radius: 0 8px 8px 0;
            font-size: 0.8rem;
            color: var(--dark-moss);
        }

        .equilibrium-box {
            background: #e3f2fd;
            border: 2px solid #2196F3;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 15px;
            text-align: center;
        }

        .equilibrium-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #1565c0;
        }

        .equilibrium-label {
            font-size: 0.8rem;
            color: #1976d2;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 15px;
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
        }

        .back-link:hover {
            color: var(--terracotta);
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Simulations</a>

        <header>
            <h1>Metapopulation Dynamics</h1>
            <p class="subtitle">Levins Model, Source-Sink Dynamics & The Rescue Effect</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="equilibrium-box">
                    <div class="equilibrium-label">Predicted Equilibrium (P*)</div>
                    <div class="equilibrium-value" id="predictedEquilibrium">0%</div>
                    <div class="equilibrium-label">P* = 1 - e/c</div>
                </div>

                <div class="control-group">
                    <label>Number of Patches</label>
                    <input type="range" id="numPatches" min="10" max="50" value="25">
                    <div class="value-display" id="numPatchesVal">25</div>
                </div>

                <div class="control-group">
                    <label>Colonization Rate (c)</label>
                    <input type="range" id="colonizationRate" min="5" max="50" value="25">
                    <div class="value-display" id="colonizationRateVal">0.25</div>
                </div>

                <div class="control-group">
                    <label>Extinction Rate (e)</label>
                    <input type="range" id="extinctionRate" min="5" max="40" value="15">
                    <div class="value-display" id="extinctionRateVal">0.15</div>
                </div>

                <div class="control-group">
                    <label>Rescue Effect Strength</label>
                    <input type="range" id="rescueEffect" min="0" max="100" value="50">
                    <div class="value-display" id="rescueEffectVal">50%</div>
                </div>

                <div class="control-group">
                    <label>Patch Quality Variation</label>
                    <input type="range" id="qualityVariation" min="0" max="100" value="30">
                    <div class="value-display" id="qualityVariationVal">30%</div>
                </div>

                <div class="control-group">
                    <label>Dispersal Range</label>
                    <input type="range" id="dispersalRange" min="20" max="100" value="50">
                    <div class="value-display" id="dispersalRangeVal">50</div>
                </div>

                <div class="control-group">
                    <label>Model Type</label>
                    <select id="modelType">
                        <option value="levins">Classic Levins</option>
                        <option value="sourceSink">Source-Sink</option>
                        <option value="spatialExplicit">Spatially Explicit</option>
                    </select>
                </div>

                <div class="buttons">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="occupiedPatches">0</div>
                        <div class="stat-label">Occupied</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="occupancyRate">0%</div>
                        <div class="stat-label">Occupancy (P)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="colonizations">0</div>
                        <div class="stat-label">Colonizations</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="extinctions">0</div>
                        <div class="stat-label">Extinctions</div>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Levins Model:</strong> dP/dt = cP(1-P) - eP. Metapopulation persists
                    when c > e. Rescue effect reduces extinction in well-connected patches.
                    Source patches sustain sink patches through dispersal.
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-panel">
                    <h3>Patch Network</h3>
                    <canvas id="patchCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Occupancy Dynamics</h3>
                    <canvas id="dynamicsCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Source-Sink Classification</h3>
                    <canvas id="sourceSinkCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Colonization vs Extinction Events</h3>
                    <canvas id="eventsCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const patchCanvas = document.getElementById('patchCanvas');
        const dynamicsCanvas = document.getElementById('dynamicsCanvas');
        const sourceSinkCanvas = document.getElementById('sourceSinkCanvas');
        const eventsCanvas = document.getElementById('eventsCanvas');

        const patchCtx = patchCanvas.getContext('2d');
        const dynamicsCtx = dynamicsCanvas.getContext('2d');
        const sourceSinkCtx = sourceSinkCanvas.getContext('2d');
        const eventsCtx = eventsCanvas.getContext('2d');

        function resizeCanvases() {
            [patchCanvas, dynamicsCanvas, sourceSinkCanvas, eventsCanvas].forEach(canvas => {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                canvas.getContext('2d').scale(window.devicePixelRatio, window.devicePixelRatio);
            });
        }
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        // Simulation state
        let running = false;
        let tick = 0;
        let patches = [];
        let history = [];
        let eventHistory = [];
        let totalColonizations = 0;
        let totalExtinctions = 0;

        class Patch {
            constructor(x, y, quality) {
                this.x = x;
                this.y = y;
                this.quality = quality; // 0-1, affects carrying capacity and extinction risk
                this.occupied = false;
                this.population = 0;
                this.immigrationRate = 0;
                this.localExtinctionRate = 0;
                this.isSource = false;
                this.emigrants = 0;
                this.immigrants = 0;
            }

            distanceTo(other) {
                return Math.hypot(this.x - other.x, this.y - other.y);
            }
        }

        function initSimulation() {
            const numPatches = parseInt(document.getElementById('numPatches').value);
            const qualityVariation = parseInt(document.getElementById('qualityVariation').value) / 100;

            patches = [];
            history = [];
            eventHistory = [];
            tick = 0;
            totalColonizations = 0;
            totalExtinctions = 0;

            const w = patchCanvas.width / window.devicePixelRatio;
            const h = patchCanvas.height / window.devicePixelRatio;

            // Create patches with random positions and qualities
            for (let i = 0; i < numPatches; i++) {
                const x = 30 + Math.random() * (w - 60);
                const y = 30 + Math.random() * (h - 60);
                const baseQuality = 0.5;
                const quality = Math.max(0.1, Math.min(1,
                    baseQuality + (Math.random() - 0.5) * qualityVariation * 2));

                patches.push(new Patch(x, y, quality));
            }

            // Initially occupy some patches
            const initialOccupancy = 0.3;
            patches.forEach(p => {
                if (Math.random() < initialOccupancy) {
                    p.occupied = true;
                    p.population = p.quality * 100;
                }
            });

            updatePredictedEquilibrium();
        }

        function getParams() {
            return {
                colonizationRate: parseInt(document.getElementById('colonizationRate').value) / 100,
                extinctionRate: parseInt(document.getElementById('extinctionRate').value) / 100,
                rescueEffect: parseInt(document.getElementById('rescueEffect').value) / 100,
                qualityVariation: parseInt(document.getElementById('qualityVariation').value) / 100,
                dispersalRange: parseInt(document.getElementById('dispersalRange').value),
                modelType: document.getElementById('modelType').value
            };
        }

        function updatePredictedEquilibrium() {
            const params = getParams();
            const c = params.colonizationRate;
            const e = params.extinctionRate;

            let pStar = c > e ? (1 - e / c) : 0;
            pStar = Math.max(0, Math.min(1, pStar));

            document.getElementById('predictedEquilibrium').textContent =
                (pStar * 100).toFixed(0) + '%';
        }

        function simulationStep() {
            const params = getParams();
            tick++;

            const occupiedPatches = patches.filter(p => p.occupied);
            const emptyPatches = patches.filter(p => !p.occupied);
            const P = occupiedPatches.length / patches.length;

            let colonizationsThisTick = 0;
            let extinctionsThisTick = 0;

            if (params.modelType === 'levins') {
                // Classic Levins model - spatially implicit
                // Colonization: cP(1-P) per empty patch
                emptyPatches.forEach(patch => {
                    const colonizationProb = params.colonizationRate * P;
                    if (Math.random() < colonizationProb * 0.1) {
                        patch.occupied = true;
                        patch.population = patch.quality * 50;
                        colonizationsThisTick++;
                        totalColonizations++;
                    }
                });

                // Extinction: e per occupied patch
                occupiedPatches.forEach(patch => {
                    let extinctionProb = params.extinctionRate;

                    // Rescue effect: extinction decreases with connectivity
                    if (params.rescueEffect > 0) {
                        const rescueModifier = 1 - params.rescueEffect * P;
                        extinctionProb *= rescueModifier;
                    }

                    if (Math.random() < extinctionProb * 0.1) {
                        patch.occupied = false;
                        patch.population = 0;
                        extinctionsThisTick++;
                        totalExtinctions++;
                    }
                });

            } else if (params.modelType === 'sourceSink') {
                // Source-sink dynamics with patch quality
                patches.forEach(patch => {
                    patch.emigrants = 0;
                    patch.immigrants = 0;
                });

                // Calculate dispersal between patches
                occupiedPatches.forEach(source => {
                    // High quality patches produce more emigrants
                    const emigrantRate = source.quality * source.population * 0.01;

                    patches.forEach(target => {
                        if (target !== source) {
                            const dist = source.distanceTo(target);
                            if (dist < params.dispersalRange) {
                                const dispersalProb = (1 - dist / params.dispersalRange) * emigrantRate;
                                target.immigrants += dispersalProb;
                                source.emigrants += dispersalProb * 0.1;
                            }
                        }
                    });

                    // Determine source vs sink
                    source.isSource = source.emigrants > source.immigrants;
                });

                // Colonization of empty patches
                emptyPatches.forEach(patch => {
                    const colonizationProb = patch.immigrants * 0.05;
                    if (Math.random() < colonizationProb) {
                        patch.occupied = true;
                        patch.population = patch.quality * 30 + patch.immigrants;
                        colonizationsThisTick++;
                        totalColonizations++;
                    }
                });

                // Population dynamics and extinction
                occupiedPatches.forEach(patch => {
                    // Population growth based on quality
                    const growth = patch.quality * 5 - 3; // Sources grow, sinks decline
                    patch.population += growth + patch.immigrants - patch.emigrants;

                    // Rescue effect from immigrants
                    let extinctionProb = params.extinctionRate / patch.quality;
                    if (params.rescueEffect > 0 && patch.immigrants > 0) {
                        extinctionProb *= (1 - params.rescueEffect * 0.5);
                    }

                    // Extinction check
                    if (patch.population < 5 || Math.random() < extinctionProb * 0.05) {
                        patch.occupied = false;
                        patch.population = 0;
                        extinctionsThisTick++;
                        totalExtinctions++;
                    }

                    patch.population = Math.max(0, Math.min(patch.quality * 150, patch.population));
                });

            } else {
                // Spatially explicit model
                // Colonization depends on distance to occupied patches
                emptyPatches.forEach(patch => {
                    let colonizationPressure = 0;

                    occupiedPatches.forEach(source => {
                        const dist = patch.distanceTo(source);
                        if (dist < params.dispersalRange) {
                            colonizationPressure += (1 - dist / params.dispersalRange) *
                                source.population * 0.001;
                        }
                    });

                    patch.immigrationRate = colonizationPressure;
                    const colonizationProb = params.colonizationRate * colonizationPressure;

                    if (Math.random() < colonizationProb * 0.1) {
                        patch.occupied = true;
                        patch.population = patch.quality * 50;
                        colonizationsThisTick++;
                        totalColonizations++;
                    }
                });

                // Extinction depends on isolation and quality
                occupiedPatches.forEach(patch => {
                    // Count nearby occupied patches (connectivity)
                    let connectivity = 0;
                    occupiedPatches.forEach(other => {
                        if (other !== patch) {
                            const dist = patch.distanceTo(other);
                            if (dist < params.dispersalRange) {
                                connectivity += 1 - dist / params.dispersalRange;
                            }
                        }
                    });

                    patch.localExtinctionRate = params.extinctionRate / patch.quality;

                    // Rescue effect reduces extinction for connected patches
                    let extinctionProb = patch.localExtinctionRate;
                    if (params.rescueEffect > 0 && connectivity > 0) {
                        extinctionProb *= (1 - params.rescueEffect * connectivity / 5);
                    }

                    if (Math.random() < extinctionProb * 0.1) {
                        patch.occupied = false;
                        patch.population = 0;
                        extinctionsThisTick++;
                        totalExtinctions++;
                    }
                });
            }

            // Record history
            if (tick % 3 === 0) {
                const currentP = patches.filter(p => p.occupied).length / patches.length;
                history.push({
                    occupancy: currentP,
                    tick
                });
                if (history.length > 300) history.shift();

                eventHistory.push({
                    colonizations: colonizationsThisTick,
                    extinctions: extinctionsThisTick,
                    tick
                });
                if (eventHistory.length > 100) eventHistory.shift();
            }

            updateStats();
        }

        function updateStats() {
            const occupied = patches.filter(p => p.occupied).length;
            const total = patches.length;

            document.getElementById('occupiedPatches').textContent = occupied;
            document.getElementById('occupancyRate').textContent =
                ((occupied / total) * 100).toFixed(0) + '%';
            document.getElementById('colonizations').textContent = totalColonizations;
            document.getElementById('extinctions').textContent = totalExtinctions;
        }

        function draw() {
            drawPatches();
            drawDynamics();
            drawSourceSink();
            drawEvents();
        }

        function drawPatches() {
            const w = patchCanvas.width / window.devicePixelRatio;
            const h = patchCanvas.height / window.devicePixelRatio;
            const params = getParams();

            patchCtx.fillStyle = '#1a1a2e';
            patchCtx.fillRect(0, 0, w, h);

            // Draw dispersal connections
            const occupiedPatches = patches.filter(p => p.occupied);

            if (params.modelType !== 'levins') {
                occupiedPatches.forEach(p1 => {
                    patches.forEach(p2 => {
                        if (p1 !== p2) {
                            const dist = p1.distanceTo(p2);
                            if (dist < params.dispersalRange) {
                                const alpha = (1 - dist / params.dispersalRange) * 0.3;
                                patchCtx.strokeStyle = `rgba(100, 200, 100, ${alpha})`;
                                patchCtx.lineWidth = 1;
                                patchCtx.beginPath();
                                patchCtx.moveTo(p1.x, p1.y);
                                patchCtx.lineTo(p2.x, p2.y);
                                patchCtx.stroke();
                            }
                        }
                    });
                });
            }

            // Draw patches
            patches.forEach(patch => {
                const size = 8 + patch.quality * 12;

                if (patch.occupied) {
                    // Color by source/sink status
                    if (params.modelType === 'sourceSink') {
                        patchCtx.fillStyle = patch.isSource ? '#4CAF50' : '#FF9800';
                    } else {
                        // Color by population
                        const popIntensity = Math.min(1, patch.population / 100);
                        patchCtx.fillStyle = `hsl(120, 70%, ${30 + popIntensity * 40}%)`;
                    }
                } else {
                    patchCtx.fillStyle = '#555';
                }

                patchCtx.beginPath();
                patchCtx.arc(patch.x, patch.y, size, 0, Math.PI * 2);
                patchCtx.fill();

                // Quality indicator (border)
                patchCtx.strokeStyle = `rgba(255, 255, 255, ${patch.quality})`;
                patchCtx.lineWidth = 2;
                patchCtx.stroke();

                // Immigration indicator for empty patches
                if (!patch.occupied && patch.immigrationRate > 0.1) {
                    patchCtx.strokeStyle = '#4CAF50';
                    patchCtx.setLineDash([3, 3]);
                    patchCtx.beginPath();
                    patchCtx.arc(patch.x, patch.y, size + 4, 0, Math.PI * 2);
                    patchCtx.stroke();
                    patchCtx.setLineDash([]);
                }
            });

            // Legend
            patchCtx.font = '10px sans-serif';
            patchCtx.fillStyle = '#4CAF50';
            patchCtx.fillText('● Occupied', 10, h - 30);
            patchCtx.fillStyle = '#555';
            patchCtx.fillText('● Empty', 80, h - 30);
            patchCtx.fillStyle = '#aaa';
            patchCtx.fillText('Size = quality', 10, h - 15);
        }

        function drawDynamics() {
            const w = dynamicsCanvas.width / window.devicePixelRatio;
            const h = dynamicsCanvas.height / window.devicePixelRatio;
            const params = getParams();

            dynamicsCtx.fillStyle = '#1a1a2e';
            dynamicsCtx.fillRect(0, 0, w, h);

            const padding = 40;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Axes
            dynamicsCtx.strokeStyle = '#666';
            dynamicsCtx.beginPath();
            dynamicsCtx.moveTo(padding, padding);
            dynamicsCtx.lineTo(padding, h - padding);
            dynamicsCtx.lineTo(w - padding, h - padding);
            dynamicsCtx.stroke();

            // Labels
            dynamicsCtx.fillStyle = '#aaa';
            dynamicsCtx.font = '10px sans-serif';
            dynamicsCtx.fillText('P', 15, h / 2);
            dynamicsCtx.fillText('1.0', padding - 20, padding + 5);
            dynamicsCtx.fillText('0', padding - 10, h - padding + 5);
            dynamicsCtx.fillText('Time', w / 2 - 10, h - 5);

            // Draw equilibrium line
            const c = params.colonizationRate;
            const e = params.extinctionRate;
            const pStar = c > e ? (1 - e / c) : 0;

            dynamicsCtx.strokeStyle = '#ff9800';
            dynamicsCtx.setLineDash([5, 5]);
            dynamicsCtx.beginPath();
            const eqY = h - padding - pStar * plotH;
            dynamicsCtx.moveTo(padding, eqY);
            dynamicsCtx.lineTo(w - padding, eqY);
            dynamicsCtx.stroke();
            dynamicsCtx.setLineDash([]);

            dynamicsCtx.fillStyle = '#ff9800';
            dynamicsCtx.fillText(`P* = ${(pStar * 100).toFixed(0)}%`, w - 70, eqY - 5);

            // Draw occupancy over time
            if (history.length > 1) {
                dynamicsCtx.strokeStyle = '#4CAF50';
                dynamicsCtx.lineWidth = 2;
                dynamicsCtx.beginPath();

                history.forEach((d, i) => {
                    const x = padding + (i / (history.length - 1)) * plotW;
                    const y = h - padding - d.occupancy * plotH;
                    if (i === 0) dynamicsCtx.moveTo(x, y);
                    else dynamicsCtx.lineTo(x, y);
                });
                dynamicsCtx.stroke();
            }
        }

        function drawSourceSink() {
            const w = sourceSinkCanvas.width / window.devicePixelRatio;
            const h = sourceSinkCanvas.height / window.devicePixelRatio;
            const params = getParams();

            sourceSinkCtx.fillStyle = '#1a1a2e';
            sourceSinkCtx.fillRect(0, 0, w, h);

            const padding = 40;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Count source vs sink
            const sources = patches.filter(p => p.occupied && p.isSource).length;
            const sinks = patches.filter(p => p.occupied && !p.isSource).length;
            const empty = patches.filter(p => !p.occupied).length;
            const total = patches.length;

            // Draw pie chart
            const centerX = w / 2;
            const centerY = h / 2;
            const radius = Math.min(plotW, plotH) / 2.5;

            const categories = [
                { count: sources, color: '#4CAF50', label: 'Sources' },
                { count: sinks, color: '#FF9800', label: 'Sinks' },
                { count: empty, color: '#555', label: 'Empty' }
            ];

            let startAngle = -Math.PI / 2;
            categories.forEach(cat => {
                if (cat.count > 0) {
                    const angle = (cat.count / total) * Math.PI * 2;

                    sourceSinkCtx.fillStyle = cat.color;
                    sourceSinkCtx.beginPath();
                    sourceSinkCtx.moveTo(centerX, centerY);
                    sourceSinkCtx.arc(centerX, centerY, radius, startAngle, startAngle + angle);
                    sourceSinkCtx.closePath();
                    sourceSinkCtx.fill();

                    startAngle += angle;
                }
            });

            // Legend
            let legendY = h - 55;
            categories.forEach(cat => {
                sourceSinkCtx.fillStyle = cat.color;
                sourceSinkCtx.fillRect(10, legendY, 12, 12);
                sourceSinkCtx.fillStyle = '#aaa';
                sourceSinkCtx.font = '10px sans-serif';
                sourceSinkCtx.fillText(`${cat.label}: ${cat.count}`, 28, legendY + 10);
                legendY += 18;
            });

            // Quality distribution by source/sink
            if (params.modelType === 'sourceSink') {
                const sourceQualities = patches.filter(p => p.occupied && p.isSource).map(p => p.quality);
                const sinkQualities = patches.filter(p => p.occupied && !p.isSource).map(p => p.quality);

                const avgSourceQ = sourceQualities.length > 0 ?
                    sourceQualities.reduce((a, b) => a + b, 0) / sourceQualities.length : 0;
                const avgSinkQ = sinkQualities.length > 0 ?
                    sinkQualities.reduce((a, b) => a + b, 0) / sinkQualities.length : 0;

                sourceSinkCtx.fillStyle = '#aaa';
                sourceSinkCtx.font = '9px sans-serif';
                sourceSinkCtx.fillText(`Avg Source Q: ${(avgSourceQ * 100).toFixed(0)}%`, w - 110, 20);
                sourceSinkCtx.fillText(`Avg Sink Q: ${(avgSinkQ * 100).toFixed(0)}%`, w - 110, 35);
            }
        }

        function drawEvents() {
            const w = eventsCanvas.width / window.devicePixelRatio;
            const h = eventsCanvas.height / window.devicePixelRatio;

            eventsCtx.fillStyle = '#1a1a2e';
            eventsCtx.fillRect(0, 0, w, h);

            if (eventHistory.length < 2) return;

            const padding = 40;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Axes
            eventsCtx.strokeStyle = '#666';
            eventsCtx.beginPath();
            eventsCtx.moveTo(padding, padding);
            eventsCtx.lineTo(padding, h - padding);
            eventsCtx.lineTo(w - padding, h - padding);
            eventsCtx.stroke();

            // Labels
            eventsCtx.fillStyle = '#aaa';
            eventsCtx.font = '10px sans-serif';
            eventsCtx.fillText('Events', 5, h / 2);
            eventsCtx.fillText('Time', w / 2 - 10, h - 5);

            // Find max
            let maxEvents = 1;
            eventHistory.forEach(d => {
                maxEvents = Math.max(maxEvents, d.colonizations, d.extinctions);
            });

            // Draw colonizations
            eventsCtx.strokeStyle = '#4CAF50';
            eventsCtx.lineWidth = 2;
            eventsCtx.beginPath();
            eventHistory.forEach((d, i) => {
                const x = padding + (i / (eventHistory.length - 1)) * plotW;
                const y = h - padding - (d.colonizations / maxEvents) * plotH;
                if (i === 0) eventsCtx.moveTo(x, y);
                else eventsCtx.lineTo(x, y);
            });
            eventsCtx.stroke();

            // Draw extinctions
            eventsCtx.strokeStyle = '#f44336';
            eventsCtx.beginPath();
            eventHistory.forEach((d, i) => {
                const x = padding + (i / (eventHistory.length - 1)) * plotW;
                const y = h - padding - (d.extinctions / maxEvents) * plotH;
                if (i === 0) eventsCtx.moveTo(x, y);
                else eventsCtx.lineTo(x, y);
            });
            eventsCtx.stroke();

            // Legend
            eventsCtx.fillStyle = '#4CAF50';
            eventsCtx.fillText('● Colonizations', w - 100, 20);
            eventsCtx.fillStyle = '#f44336';
            eventsCtx.fillText('● Extinctions', w - 100, 35);

            // Net change
            const recentC = eventHistory.slice(-20).reduce((s, d) => s + d.colonizations, 0);
            const recentE = eventHistory.slice(-20).reduce((s, d) => s + d.extinctions, 0);
            const net = recentC - recentE;
            eventsCtx.fillStyle = net >= 0 ? '#4CAF50' : '#f44336';
            eventsCtx.fillText(`Net: ${net >= 0 ? '+' : ''}${net}`, w - 100, 50);
        }

        function animate() {
            if (running) {
                simulationStep();
            }
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            initSimulation();
        });

        // Slider value displays
        const sliders = [
            ['numPatches', 'numPatchesVal', v => v],
            ['colonizationRate', 'colonizationRateVal', v => (v / 100).toFixed(2)],
            ['extinctionRate', 'extinctionRateVal', v => (v / 100).toFixed(2)],
            ['rescueEffect', 'rescueEffectVal', v => v + '%'],
            ['qualityVariation', 'qualityVariationVal', v => v + '%'],
            ['dispersalRange', 'dispersalRangeVal', v => v]
        ];

        sliders.forEach(([id, displayId, formatter]) => {
            const input = document.getElementById(id);
            const display = document.getElementById(displayId);
            input.addEventListener('input', () => {
                display.textContent = formatter(parseInt(input.value));
                updatePredictedEquilibrium();
            });
        });

        // Initialize
        initSimulation();
        animate();
    </script>
</body>
</html>
