<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centipede Game - Backward Induction</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { font-family: 'Lora', serif; color: #606C38; font-size: 2rem; margin-bottom: 8px; }
        .subtitle { color: #8A9A5B; font-size: 1rem; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #606C38; font-weight: 600; }
        .main-content { display: grid; grid-template-columns: 1fr 320px; gap: 20px; }
        .canvas-container { background: white; border-radius: 12px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        canvas { display: block; width: 100%; border-radius: 8px; }
        .controls { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; color: #606C38; font-weight: 600; margin-bottom: 5px; font-size: 0.9rem; }
        .control-group input[type="range"] { width: 100%; }
        .control-group .value { color: #8A9A5B; font-size: 0.85rem; }
        button { padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer; font-family: 'Nunito', sans-serif; font-weight: 600; margin-right: 8px; margin-bottom: 8px; }
        .btn-primary { background: #8A9A5B; color: white; }
        .btn-secondary { background: #DDA15E; color: white; }
        .stats-box { background: #FEFAE0; border-radius: 8px; padding: 12px; margin-top: 15px; }
        .stat { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #EDE8D5; }
        .stat:last-child { border-bottom: none; }
        .stat-label { color: #606C38; font-size: 0.85rem; }
        .stat-value { color: #BC6C25; font-weight: 600; font-size: 0.9rem; }
        .info-panel { margin-top: 20px; padding: 15px; background: white; border-radius: 12px; font-size: 0.85rem; color: #606C38; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        .prediction { padding: 10px; background: #E9F5E9; border-radius: 8px; margin-bottom: 15px; text-align: center; }
        .prediction .label { font-size: 0.8rem; color: #606C38; }
        .prediction .value { font-size: 1.2rem; color: #BC6C25; font-weight: 600; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Centipede Game</h1>
            <p class="subtitle">Backward induction vs. cooperative behavior with learning agents</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
            </div>

            <div class="controls">
                <div class="prediction">
                    <div class="label">Game Theory Prediction</div>
                    <div class="value">Take at Node 1</div>
                    <div class="label" style="margin-top: 5px;">But experiments show cooperation!</div>
                </div>

                <div class="control-group">
                    <label>Game Length (nodes): <span class="value" id="valueNodes">6</span></label>
                    <input type="range" id="gameNodes" min="4" max="12" value="6">
                </div>

                <div class="control-group">
                    <label>Pot Multiplier: <span class="value" id="valueMult">2</span></label>
                    <input type="range" id="multiplier" min="1.5" max="4" value="2" step="0.1">
                </div>

                <div class="control-group">
                    <label>Population: <span class="value" id="valuePop">100</span></label>
                    <input type="range" id="population" min="20" max="200" value="100">
                </div>

                <div class="control-group">
                    <label>Belief Update Rate: <span class="value" id="valueLR">0.10</span></label>
                    <input type="range" id="learnRate" min="1" max="50" value="10">
                </div>

                <div class="control-group">
                    <label>Exploration (ε): <span class="value" id="valueEps">0.05</span></label>
                    <input type="range" id="epsilon" min="0" max="20" value="5">
                </div>

                <button class="btn-primary" onclick="resetSimulation()">Reset</button>
                <button class="btn-secondary" onclick="togglePause()">Pause</button>

                <div class="stats-box">
                    <div class="stat"><span class="stat-label">Games Played:</span><span class="stat-value" id="gamesStat">0</span></div>
                    <div class="stat"><span class="stat-label">Avg Stop Node:</span><span class="stat-value" id="avgStopStat">1.0</span></div>
                    <div class="stat"><span class="stat-label">Pass Rate Node 1:</span><span class="stat-value" id="pass1Stat">0%</span></div>
                    <div class="stat"><span class="stat-label">Full Cooperation:</span><span class="stat-value" id="fullCoopStat">0%</span></div>
                    <div class="stat"><span class="stat-label">Nash Plays:</span><span class="stat-value" id="nashStat">0%</span></div>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <strong>About this simulation:</strong> The Centipede Game (Rosenthal, 1981) tests backward induction.
            Players alternate choosing to "Take" (end game, take larger pot share) or "Pass" (continue, pot grows).
            <strong>Backward induction</strong> says: take immediately at node 1. But experiments show humans cooperate,
            often passing until later nodes. This simulation evolves agents with beliefs about opponent cooperation levels,
            demonstrating the tension between theory and behavior.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = 600 * dpr;
        canvas.style.height = '600px';
        ctx.scale(dpr, dpr);

        const width = rect.width;
        const height = 600;

        let gameNodes = 6;
        let multiplier = 2;
        let popSize = 100;
        let learnRate = 0.1;
        let epsilon = 0.05;

        let agents = [];
        let gameHistory = [];
        let stopDistribution = [];
        let gamesPlayed = 0;
        let paused = false;

        function initSimulation() {
            agents = [];
            gameHistory = [];
            stopDistribution = new Array(gameNodes + 1).fill(0);
            gamesPlayed = 0;

            for (let i = 0; i < popSize; i++) {
                // Each agent has beliefs about pass probability at each node
                const beliefs = [];
                for (let n = 0; n < gameNodes; n++) {
                    beliefs.push(0.5); // Initial belief: 50% pass rate
                }

                agents.push({
                    beliefs: beliefs,
                    // Own strategy: probability of passing at each node
                    strategy: beliefs.map(() => Math.random()),
                    fitness: 0,
                    gamesPlayed: 0
                });
            }
        }

        function calculatePots(n) {
            // Pot values at each node
            // If taken at node n: taker gets larger, other gets smaller
            const base = 4;
            const pots = [];

            for (let i = 0; i <= gameNodes; i++) {
                const pot = base * Math.pow(multiplier, i);
                const larger = Math.floor(pot * 0.6);
                const smaller = Math.floor(pot * 0.4);
                pots.push({ larger, smaller, total: pot });
            }

            return pots;
        }

        function playGame(agent1, agent2) {
            const pots = calculatePots();
            let currentPlayer = 0;  // 0 = agent1, 1 = agent2

            for (let node = 0; node < gameNodes; node++) {
                const agent = currentPlayer === 0 ? agent1 : agent2;

                // Decision: pass or take
                let passProb = agent.strategy[node];

                // Epsilon-greedy exploration
                if (Math.random() < epsilon) {
                    passProb = Math.random();
                }

                if (Math.random() < passProb) {
                    // Pass - continue to next node
                    currentPlayer = 1 - currentPlayer;
                } else {
                    // Take - game ends
                    const payoff1 = currentPlayer === 0 ? pots[node].larger : pots[node].smaller;
                    const payoff2 = currentPlayer === 0 ? pots[node].smaller : pots[node].larger;

                    agent1.fitness += payoff1;
                    agent2.fitness += payoff2;
                    agent1.gamesPlayed++;
                    agent2.gamesPlayed++;

                    return { stopNode: node + 1, payoffs: [payoff1, payoff2] };
                }
            }

            // Both passed all the way - maximum cooperation
            const finalNode = gameNodes;
            const payoff1 = pots[finalNode].larger;
            const payoff2 = pots[finalNode].smaller;

            agent1.fitness += payoff1;
            agent2.fitness += payoff2;
            agent1.gamesPlayed++;
            agent2.gamesPlayed++;

            return { stopNode: gameNodes + 1, payoffs: [payoff1, payoff2] };
        }

        function updateBeliefs(agent, opponent, gameResult) {
            // Update beliefs based on observed opponent behavior
            for (let n = 0; n < gameNodes; n++) {
                const observed = n < gameResult.stopNode - 1 ? 1 : 0;  // Did opponent pass at node n?
                agent.beliefs[n] += learnRate * (observed - agent.beliefs[n]);
            }

            // Update own strategy based on beliefs
            for (let n = 0; n < gameNodes; n++) {
                // If belief that opponent will pass is high, it pays to pass
                const expectedValue = calculateExpectedValue(agent, n);

                if (expectedValue > 0) {
                    agent.strategy[n] += learnRate * (1 - agent.strategy[n]) * 0.5;
                } else {
                    agent.strategy[n] -= learnRate * agent.strategy[n] * 0.5;
                }

                agent.strategy[n] = Math.max(0.01, Math.min(0.99, agent.strategy[n]));
            }
        }

        function calculateExpectedValue(agent, node) {
            const pots = calculatePots();

            // Value of taking now
            const takeValue = pots[node].larger;

            // Expected value of passing (depends on belief about opponent)
            const opponentPassProb = agent.beliefs[Math.min(node + 1, gameNodes - 1)];
            const passValue = opponentPassProb * pots[node + 2]?.larger || 0 +
                             (1 - opponentPassProb) * pots[node + 1].smaller;

            return passValue - takeValue;
        }

        function runGeneration() {
            // Random pairings
            const shuffled = [...agents].sort(() => Math.random() - 0.5);

            for (let i = 0; i < shuffled.length - 1; i += 2) {
                const result = playGame(shuffled[i], shuffled[i + 1]);

                stopDistribution[result.stopNode - 1]++;
                gameHistory.push(result.stopNode);
                gamesPlayed++;

                // Update beliefs
                updateBeliefs(shuffled[i], shuffled[i + 1], result);
                updateBeliefs(shuffled[i + 1], shuffled[i], result);
            }

            // Evolution: replicate successful strategies
            if (gamesPlayed % 100 === 0) {
                evolveStrategies();
            }
        }

        function evolveStrategies() {
            const avgFitness = agents.reduce((s, a) => s + (a.gamesPlayed > 0 ? a.fitness / a.gamesPlayed : 0), 0) / popSize;

            agents.forEach(a => {
                const myAvg = a.gamesPlayed > 0 ? a.fitness / a.gamesPlayed : 0;

                if (myAvg < avgFitness * 0.8) {
                    // Adopt strategy from random successful agent
                    const successful = agents.filter(b =>
                        b.gamesPlayed > 0 && b.fitness / b.gamesPlayed > avgFitness
                    );

                    if (successful.length > 0) {
                        const model = successful[Math.floor(Math.random() * successful.length)];
                        a.strategy = model.strategy.map(s => s + (Math.random() - 0.5) * 0.1);
                        a.strategy = a.strategy.map(s => Math.max(0.01, Math.min(0.99, s)));
                    }
                }
            });

            // Reset fitness for new round
            agents.forEach(a => {
                a.fitness = 0;
                a.gamesPlayed = 0;
            });
        }

        function getStats() {
            const recentHistory = gameHistory.slice(-500);
            const avgStop = recentHistory.length > 0 ?
                recentHistory.reduce((a, b) => a + b, 0) / recentHistory.length : 1;

            const pass1Rate = agents.reduce((s, a) => s + a.strategy[0], 0) / popSize;
            const fullCoop = recentHistory.filter(s => s === gameNodes + 1).length / Math.max(1, recentHistory.length);
            const nashPlay = recentHistory.filter(s => s === 1).length / Math.max(1, recentHistory.length);

            return { avgStop, pass1Rate, fullCoop, nashPlay };
        }

        function draw() {
            ctx.fillStyle = '#FEFAE0';
            ctx.fillRect(0, 0, width, height);

            const pots = calculatePots();

            // Draw the centipede game tree
            const treeY = 80;
            const nodeSpacing = (width - 100) / gameNodes;
            const nodeRadius = 20;

            // Draw edges first
            ctx.strokeStyle = '#DDA15E';
            ctx.lineWidth = 2;

            for (let i = 0; i < gameNodes; i++) {
                const x = 50 + i * nodeSpacing;
                const nextX = 50 + (i + 1) * nodeSpacing;

                // Horizontal edge (pass)
                if (i < gameNodes - 1) {
                    ctx.beginPath();
                    ctx.moveTo(x + nodeRadius, treeY);
                    ctx.lineTo(nextX - nodeRadius, treeY);
                    ctx.stroke();

                    ctx.fillStyle = '#8A9A5B';
                    ctx.font = '10px Nunito';
                    ctx.fillText('Pass', (x + nextX) / 2 - 15, treeY - 8);
                }

                // Downward edge (take)
                ctx.beginPath();
                ctx.moveTo(x, treeY + nodeRadius);
                ctx.lineTo(x, treeY + 70);
                ctx.stroke();

                ctx.fillStyle = '#E63946';
                ctx.font = '10px Nunito';
                ctx.fillText('Take', x - 15, treeY + 50);
            }

            // Draw nodes
            for (let i = 0; i < gameNodes; i++) {
                const x = 50 + i * nodeSpacing;

                // Node circle
                ctx.beginPath();
                ctx.arc(x, treeY, nodeRadius, 0, Math.PI * 2);

                // Color based on average pass rate at this node
                const avgPassRate = agents.reduce((s, a) => s + a.strategy[i], 0) / popSize;
                const hue = 120 * avgPassRate; // Green = high pass rate
                ctx.fillStyle = `hsl(${hue}, 60%, 50%)`;
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Node number
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Nunito';
                ctx.textAlign = 'center';
                ctx.fillText(i + 1, x, treeY + 4);

                // Payoff if taken here
                ctx.fillStyle = '#606C38';
                ctx.font = '10px Nunito';
                ctx.textAlign = 'center';
                ctx.fillText(`${pots[i].larger}/${pots[i].smaller}`, x, treeY + 90);
            }

            // Final node (full cooperation)
            const finalX = 50 + (gameNodes - 1) * nodeSpacing + nodeSpacing/2;
            ctx.beginPath();
            ctx.arc(finalX, treeY, nodeRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#2A9D8F';
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = 'white';
            ctx.font = 'bold 10px Nunito';
            ctx.fillText('END', finalX, treeY + 4);
            ctx.fillStyle = '#606C38';
            ctx.fillText(`${pots[gameNodes].larger}/${pots[gameNodes].smaller}`, finalX, treeY + 90);

            ctx.textAlign = 'left';

            // Draw stop distribution histogram
            const histY = 180;
            const histHeight = 120;
            const barWidth = (width - 100) / (gameNodes + 1);

            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(40, histY, width - 80, histHeight + 30);
            ctx.strokeStyle = '#DDA15E';
            ctx.strokeRect(40, histY, width - 80, histHeight + 30);

            const maxCount = Math.max(...stopDistribution, 1);

            for (let i = 0; i <= gameNodes; i++) {
                const h = (stopDistribution[i] / maxCount) * histHeight;
                const x = 50 + i * barWidth;

                ctx.fillStyle = i === 0 ? '#E63946' : i === gameNodes ? '#2A9D8F' : '#8A9A5B';
                ctx.fillRect(x, histY + histHeight - h + 10, barWidth - 5, h);

                ctx.fillStyle = '#606C38';
                ctx.font = '10px Nunito';
                ctx.textAlign = 'center';
                ctx.fillText(`N${i + 1}`, x + barWidth/2, histY + histHeight + 25);
            }

            ctx.textAlign = 'left';
            ctx.fillText('Stop Distribution (red=Nash, green=full cooperation)', 50, histY + 15);

            // Draw history chart
            const chartY = height - 250;
            const chartHeight = 120;

            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(20, chartY, width - 40, chartHeight);
            ctx.strokeStyle = '#DDA15E';
            ctx.strokeRect(20, chartY, width - 40, chartHeight);

            if (gameHistory.length > 1) {
                // Moving average of stop nodes
                const windowSize = 50;
                const movingAvg = [];

                for (let i = windowSize; i < gameHistory.length; i++) {
                    const window = gameHistory.slice(i - windowSize, i);
                    movingAvg.push(window.reduce((a, b) => a + b, 0) / windowSize);
                }

                if (movingAvg.length > 1) {
                    const maxPoints = 300;
                    const startIdx = Math.max(0, movingAvg.length - maxPoints);
                    const step = (width - 60) / Math.max(1, Math.min(movingAvg.length, maxPoints) - 1);

                    ctx.beginPath();
                    for (let i = startIdx; i < movingAvg.length; i++) {
                        const x = 30 + (i - startIdx) * step;
                        const y = chartY + chartHeight - 10 - ((movingAvg[i] - 1) / gameNodes) * (chartHeight - 30);
                        if (i === startIdx) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.strokeStyle = '#8A9A5B';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Nash prediction line (node 1)
                    ctx.beginPath();
                    ctx.moveTo(30, chartY + chartHeight - 10);
                    ctx.lineTo(width - 30, chartY + chartHeight - 10);
                    ctx.strokeStyle = '#E63946';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            ctx.fillStyle = '#606C38';
            ctx.font = '11px Nunito';
            ctx.fillText('Avg Stop Node over time (red line = Nash prediction at node 1)', 30, chartY + 15);

            // Draw belief distribution
            const beliefY = height - 110;
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(20, beliefY, width - 40, 90);
            ctx.strokeStyle = '#DDA15E';
            ctx.strokeRect(20, beliefY, width - 40, 90);

            ctx.fillStyle = '#606C38';
            ctx.fillText('Agent Pass Probabilities by Node:', 30, beliefY + 15);

            const nodeWidth = (width - 80) / gameNodes;
            for (let n = 0; n < gameNodes; n++) {
                const avgPass = agents.reduce((s, a) => s + a.strategy[n], 0) / popSize;
                const barHeight = avgPass * 50;

                ctx.fillStyle = `hsl(${120 * avgPass}, 60%, 50%)`;
                ctx.fillRect(40 + n * nodeWidth, beliefY + 75 - barHeight, nodeWidth - 10, barHeight);

                ctx.fillStyle = '#606C38';
                ctx.font = '10px Nunito';
                ctx.textAlign = 'center';
                ctx.fillText(`N${n + 1}`, 40 + n * nodeWidth + nodeWidth/2, beliefY + 85);
                ctx.fillText((avgPass * 100).toFixed(0) + '%', 40 + n * nodeWidth + nodeWidth/2, beliefY + 35);
            }
            ctx.textAlign = 'left';
        }

        function updateStats() {
            const stats = getStats();

            document.getElementById('gamesStat').textContent = gamesPlayed;
            document.getElementById('avgStopStat').textContent = stats.avgStop.toFixed(2);
            document.getElementById('pass1Stat').textContent = (stats.pass1Rate * 100).toFixed(1) + '%';
            document.getElementById('fullCoopStat').textContent = (stats.fullCoop * 100).toFixed(1) + '%';
            document.getElementById('nashStat').textContent = (stats.nashPlay * 100).toFixed(1) + '%';
        }

        function updateControls() {
            gameNodes = parseInt(document.getElementById('gameNodes').value);
            multiplier = parseFloat(document.getElementById('multiplier').value);
            popSize = parseInt(document.getElementById('population').value);
            learnRate = parseInt(document.getElementById('learnRate').value) / 100;
            epsilon = parseInt(document.getElementById('epsilon').value) / 100;

            document.getElementById('valueNodes').textContent = gameNodes;
            document.getElementById('valueMult').textContent = multiplier.toFixed(1);
            document.getElementById('valuePop').textContent = popSize;
            document.getElementById('valueLR').textContent = learnRate.toFixed(2);
            document.getElementById('valueEps').textContent = epsilon.toFixed(2);
        }

        function resetSimulation() {
            updateControls();
            initSimulation();
        }

        function togglePause() {
            paused = !paused;
        }

        function animate() {
            if (!paused) {
                runGeneration();
                updateStats();
            }

            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.querySelectorAll('input[type="range"]').forEach(input => {
            input.addEventListener('input', updateControls);
        });

        updateControls();
        initSimulation();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
