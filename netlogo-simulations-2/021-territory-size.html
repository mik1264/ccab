<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Territory Size Optimization - NetLogo Simulation</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            color: var(--dark-moss);
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .subtitle {
            color: var(--moss);
            font-size: 1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .control-group {
            margin-bottom: 18px;
        }

        .control-group label {
            display: block;
            color: var(--dark-moss);
            font-weight: 600;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            border: 2px solid var(--sage);
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .value-display {
            text-align: right;
            color: var(--moss);
            font-size: 0.8rem;
            margin-top: 3px;
        }

        .buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 80px;
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--sage);
            color: white;
        }

        .btn-primary:hover {
            background: var(--moss);
        }

        .btn-secondary {
            background: var(--earth);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--terracotta);
        }

        .visualization-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 15px;
        }

        .viz-panel {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .viz-panel h3 {
            color: var(--dark-moss);
            font-size: 0.9rem;
            margin-bottom: 10px;
            text-align: center;
        }

        canvas {
            width: 100%;
            height: 250px;
            border-radius: 8px;
            background: #1a1a2e;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 15px;
        }

        .stat-item {
            background: var(--cream);
            padding: 8px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--terracotta);
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--moss);
        }

        .info-box {
            background: linear-gradient(135deg, var(--cream) 0%, #fff 100%);
            border-left: 4px solid var(--sage);
            padding: 12px;
            margin-top: 15px;
            border-radius: 0 8px 8px 0;
            font-size: 0.8rem;
            color: var(--dark-moss);
        }

        .back-link {
            display: inline-block;
            margin-bottom: 15px;
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
        }

        .back-link:hover {
            color: var(--terracotta);
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Simulations</a>

        <header>
            <h1>Territory Size Optimization</h1>
            <p class="subtitle">Economic Defendability, Resource Density, and Intrusion Costs</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-group">
                    <label>Number of Owners</label>
                    <input type="range" id="numOwners" min="5" max="30" value="12">
                    <div class="value-display" id="numOwnersVal">12</div>
                </div>

                <div class="control-group">
                    <label>Resource Density</label>
                    <input type="range" id="resourceDensity" min="10" max="100" value="50">
                    <div class="value-display" id="resourceDensityVal">50</div>
                </div>

                <div class="control-group">
                    <label>Resource Clumping</label>
                    <input type="range" id="resourceClumping" min="0" max="100" value="30">
                    <div class="value-display" id="resourceClumpingVal">30%</div>
                </div>

                <div class="control-group">
                    <label>Defense Cost Factor</label>
                    <input type="range" id="defenseCost" min="1" max="50" value="15">
                    <div class="value-display" id="defenseCostVal">15</div>
                </div>

                <div class="control-group">
                    <label>Floater Density</label>
                    <input type="range" id="floaterDensity" min="0" max="50" value="20">
                    <div class="value-display" id="floaterDensityVal">20</div>
                </div>

                <div class="control-group">
                    <label>Intrusion Rate</label>
                    <input type="range" id="intrusionRate" min="1" max="30" value="10">
                    <div class="value-display" id="intrusionRateVal">10%</div>
                </div>

                <div class="control-group">
                    <label>Territory Adjustment Speed</label>
                    <input type="range" id="adjustSpeed" min="1" max="20" value="5">
                    <div class="value-display" id="adjustSpeedVal">5</div>
                </div>

                <div class="control-group">
                    <label>Defense Cost Model</label>
                    <select id="defenseModel">
                        <option value="area">Area-based (S)</option>
                        <option value="perimeter">Perimeter-based (√S)</option>
                        <option value="hybrid">Hybrid Model</option>
                    </select>
                </div>

                <div class="buttons">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="avgTerritorySize">0</div>
                        <div class="stat-label">Avg Territory</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalCoverage">0%</div>
                        <div class="stat-label">Area Covered</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="avgNetBenefit">0</div>
                        <div class="stat-label">Avg Net Benefit</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="intrusions">0</div>
                        <div class="stat-label">Intrusions/tick</div>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Economic Defendability:</strong> Optimal territory size maximizes
                    (Benefits - Costs). Higher resource density → smaller territories.
                    Defense costs scale with territory size S or perimeter √S.
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-panel">
                    <h3>Territory Map</h3>
                    <canvas id="mapCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Benefit-Cost Analysis</h3>
                    <canvas id="economicsCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Territory Size Distribution</h3>
                    <canvas id="distributionCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Size Evolution Over Time</h3>
                    <canvas id="evolutionCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const mapCanvas = document.getElementById('mapCanvas');
        const economicsCanvas = document.getElementById('economicsCanvas');
        const distributionCanvas = document.getElementById('distributionCanvas');
        const evolutionCanvas = document.getElementById('evolutionCanvas');

        const mapCtx = mapCanvas.getContext('2d');
        const economicsCtx = economicsCanvas.getContext('2d');
        const distributionCtx = distributionCanvas.getContext('2d');
        const evolutionCtx = evolutionCanvas.getContext('2d');

        function resizeCanvases() {
            [mapCanvas, economicsCanvas, distributionCanvas, evolutionCanvas].forEach(canvas => {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                canvas.getContext('2d').scale(window.devicePixelRatio, window.devicePixelRatio);
            });
        }
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        // Simulation state
        let running = false;
        let tick = 0;
        let owners = [];
        let floaters = [];
        let resources = [];
        let sizeHistory = [];
        let intrusionCount = 0;

        class TerritoryOwner {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.id = id;
                this.radius = 30 + Math.random() * 20; // Territory radius
                this.color = `hsl(${(id * 137) % 360}, 60%, 50%)`;

                this.resourcesGained = 0;
                this.defenseCosts = 0;
                this.netBenefit = 0;

                // Movement within territory
                this.patrolAngle = Math.random() * Math.PI * 2;
            }

            getArea() {
                return Math.PI * this.radius * this.radius;
            }

            getPerimeter() {
                return 2 * Math.PI * this.radius;
            }

            calculateBenefits(resources) {
                let benefit = 0;
                resources.forEach(r => {
                    const dist = Math.hypot(r.x - this.x, r.y - this.y);
                    if (dist < this.radius) {
                        benefit += r.value;
                    }
                });
                return benefit;
            }

            calculateDefenseCost(params, floaters) {
                const model = params.defenseModel;
                const baseCost = params.defenseCost / 10;

                let sizeFactor;
                if (model === 'area') {
                    sizeFactor = this.getArea() / 1000;
                } else if (model === 'perimeter') {
                    sizeFactor = Math.sqrt(this.getArea()) / 10;
                } else {
                    sizeFactor = (this.getArea() / 2000 + Math.sqrt(this.getArea()) / 20);
                }

                // Intruder pressure
                let intruderPressure = 0;
                floaters.forEach(f => {
                    const dist = Math.hypot(f.x - this.x, f.y - this.y);
                    if (dist < this.radius + 30) {
                        intruderPressure += 1 / (dist + 10);
                    }
                });

                return baseCost * sizeFactor * (1 + intruderPressure * 0.5);
            }

            adjustTerritory(params, others) {
                const speed = params.adjustSpeed / 100;

                // Calculate marginal benefit of expanding
                const currentBenefit = this.netBenefit;

                // Try expanding slightly
                const expandedRadius = this.radius * 1.05;
                const expandedArea = Math.PI * expandedRadius * expandedRadius;
                const contractedRadius = this.radius * 0.95;

                // Check for overlap with neighbors
                let canExpand = true;
                others.forEach(other => {
                    if (other.id !== this.id) {
                        const dist = Math.hypot(other.x - this.x, other.y - this.y);
                        if (dist < expandedRadius + other.radius * 0.5) {
                            canExpand = false;
                        }
                    }
                });

                // Adjust based on marginal analysis
                if (this.netBenefit > 0 && canExpand) {
                    // Positive benefit, try to expand
                    this.radius = Math.min(80, this.radius + speed * 5);
                } else if (this.netBenefit < -5) {
                    // Negative benefit, contract
                    this.radius = Math.max(15, this.radius - speed * 5);
                }

                // Also respond to resource density within territory
                const resourcesInTerritory = resources.filter(r =>
                    Math.hypot(r.x - this.x, r.y - this.y) < this.radius
                ).length;

                const resourceDensity = resourcesInTerritory / this.getArea() * 1000;
                const optimalDensity = params.resourceDensity / 30;

                if (resourceDensity > optimalDensity * 1.5) {
                    // High density, can afford smaller territory
                    this.radius = Math.max(15, this.radius - speed * 2);
                } else if (resourceDensity < optimalDensity * 0.5 && canExpand) {
                    // Low density, need larger territory
                    this.radius = Math.min(80, this.radius + speed * 2);
                }
            }

            patrol() {
                this.patrolAngle += 0.02;
                // Move around territory center
            }
        }

        class Floater {
            constructor() {
                const w = mapCanvas.width / window.devicePixelRatio;
                const h = mapCanvas.height / window.devicePixelRatio;
                this.x = Math.random() * w;
                this.y = Math.random() * h;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
            }

            update(owners, params) {
                // Move around, avoiding territory centers
                this.x += this.vx;
                this.y += this.vy;

                // Bounce off walls
                const w = mapCanvas.width / window.devicePixelRatio;
                const h = mapCanvas.height / window.devicePixelRatio;

                if (this.x < 0 || this.x > w) this.vx *= -1;
                if (this.y < 0 || this.y > h) this.vy *= -1;

                this.x = Math.max(0, Math.min(w, this.x));
                this.y = Math.max(0, Math.min(h, this.y));

                // Attempt intrusion
                if (Math.random() < params.intrusionRate / 1000) {
                    owners.forEach(owner => {
                        const dist = Math.hypot(this.x - owner.x, this.y - owner.y);
                        if (dist < owner.radius) {
                            intrusionCount++;
                            // Repelled
                            const angle = Math.atan2(this.y - owner.y, this.x - owner.x);
                            this.vx = Math.cos(angle) * 3;
                            this.vy = Math.sin(angle) * 3;
                        }
                    });
                }

                // Random direction changes
                if (Math.random() < 0.02) {
                    this.vx += (Math.random() - 0.5) * 0.5;
                    this.vy += (Math.random() - 0.5) * 0.5;
                }

                // Speed limit
                const speed = Math.hypot(this.vx, this.vy);
                if (speed > 2) {
                    this.vx = (this.vx / speed) * 2;
                    this.vy = (this.vy / speed) * 2;
                }
            }
        }

        function initSimulation() {
            const numOwners = parseInt(document.getElementById('numOwners').value);
            const resourceDensity = parseInt(document.getElementById('resourceDensity').value);
            const floaterDensity = parseInt(document.getElementById('floaterDensity').value);
            const clumping = parseInt(document.getElementById('resourceClumping').value) / 100;

            owners = [];
            floaters = [];
            resources = [];
            sizeHistory = [];
            tick = 0;
            intrusionCount = 0;

            const w = mapCanvas.width / window.devicePixelRatio;
            const h = mapCanvas.height / window.devicePixelRatio;

            // Create territory owners with good spacing
            for (let i = 0; i < numOwners; i++) {
                let x, y, valid;
                let attempts = 0;

                do {
                    x = 50 + Math.random() * (w - 100);
                    y = 50 + Math.random() * (h - 100);
                    valid = true;

                    for (const owner of owners) {
                        if (Math.hypot(owner.x - x, owner.y - y) < 60) {
                            valid = false;
                            break;
                        }
                    }
                    attempts++;
                } while (!valid && attempts < 100);

                owners.push(new TerritoryOwner(x, y, i));
            }

            // Create resources
            const numResources = resourceDensity * 2;

            if (clumping > 0.3) {
                // Clumped resources - create hotspots
                const numClusters = Math.floor(5 + clumping * 10);
                const clusterCenters = [];

                for (let i = 0; i < numClusters; i++) {
                    clusterCenters.push({
                        x: Math.random() * w,
                        y: Math.random() * h
                    });
                }

                for (let i = 0; i < numResources; i++) {
                    const cluster = clusterCenters[Math.floor(Math.random() * clusterCenters.length)];
                    const spread = (1 - clumping) * 100 + 20;
                    resources.push({
                        x: cluster.x + (Math.random() - 0.5) * spread,
                        y: cluster.y + (Math.random() - 0.5) * spread,
                        value: 0.5 + Math.random() * 0.5
                    });
                }
            } else {
                // Uniform resources
                for (let i = 0; i < numResources; i++) {
                    resources.push({
                        x: Math.random() * w,
                        y: Math.random() * h,
                        value: 0.5 + Math.random() * 0.5
                    });
                }
            }

            // Create floaters
            for (let i = 0; i < floaterDensity; i++) {
                floaters.push(new Floater());
            }
        }

        function getParams() {
            return {
                resourceDensity: parseInt(document.getElementById('resourceDensity').value),
                resourceClumping: parseInt(document.getElementById('resourceClumping').value),
                defenseCost: parseInt(document.getElementById('defenseCost').value),
                floaterDensity: parseInt(document.getElementById('floaterDensity').value),
                intrusionRate: parseInt(document.getElementById('intrusionRate').value),
                adjustSpeed: parseInt(document.getElementById('adjustSpeed').value),
                defenseModel: document.getElementById('defenseModel').value
            };
        }

        function simulationStep() {
            const params = getParams();
            tick++;
            intrusionCount = 0;

            // Update floaters
            floaters.forEach(f => f.update(owners, params));

            // Calculate owner economics
            owners.forEach(owner => {
                owner.resourcesGained = owner.calculateBenefits(resources);
                owner.defenseCosts = owner.calculateDefenseCost(params, floaters);
                owner.netBenefit = owner.resourcesGained - owner.defenseCosts;
                owner.patrol();
            });

            // Adjust territories
            if (tick % 10 === 0) {
                owners.forEach(owner => owner.adjustTerritory(params, owners));
            }

            // Record history
            if (tick % 5 === 0) {
                const avgSize = owners.reduce((sum, o) => sum + o.radius, 0) / owners.length;
                const sizes = owners.map(o => o.radius);
                sizeHistory.push({
                    avg: avgSize,
                    min: Math.min(...sizes),
                    max: Math.max(...sizes)
                });
                if (sizeHistory.length > 200) sizeHistory.shift();
            }

            updateStats();
        }

        function updateStats() {
            const avgSize = owners.reduce((sum, o) => sum + o.getArea(), 0) / owners.length;
            const totalArea = owners.reduce((sum, o) => sum + o.getArea(), 0);
            const w = mapCanvas.width / window.devicePixelRatio;
            const h = mapCanvas.height / window.devicePixelRatio;
            const coverage = (totalArea / (w * h)) * 100;
            const avgNetBenefit = owners.reduce((sum, o) => sum + o.netBenefit, 0) / owners.length;

            document.getElementById('avgTerritorySize').textContent = avgSize.toFixed(0);
            document.getElementById('totalCoverage').textContent = Math.min(100, coverage).toFixed(0) + '%';
            document.getElementById('avgNetBenefit').textContent = avgNetBenefit.toFixed(1);
            document.getElementById('intrusions').textContent = intrusionCount;
        }

        function draw() {
            drawMap();
            drawEconomics();
            drawDistribution();
            drawEvolution();
        }

        function drawMap() {
            const w = mapCanvas.width / window.devicePixelRatio;
            const h = mapCanvas.height / window.devicePixelRatio;

            mapCtx.fillStyle = '#1a1a2e';
            mapCtx.fillRect(0, 0, w, h);

            // Draw resources
            resources.forEach(r => {
                mapCtx.fillStyle = `rgba(139, 195, 74, ${r.value})`;
                mapCtx.beginPath();
                mapCtx.arc(r.x, r.y, 3, 0, Math.PI * 2);
                mapCtx.fill();
            });

            // Draw territories
            owners.forEach(owner => {
                // Territory area
                mapCtx.fillStyle = owner.color.replace('50%', '30%').replace(')', ', 0.3)').replace('hsl', 'hsla');
                mapCtx.beginPath();
                mapCtx.arc(owner.x, owner.y, owner.radius, 0, Math.PI * 2);
                mapCtx.fill();

                // Border
                mapCtx.strokeStyle = owner.color;
                mapCtx.lineWidth = 2;
                mapCtx.beginPath();
                mapCtx.arc(owner.x, owner.y, owner.radius, 0, Math.PI * 2);
                mapCtx.stroke();

                // Owner
                mapCtx.fillStyle = owner.color;
                const patrolX = owner.x + Math.cos(owner.patrolAngle) * owner.radius * 0.5;
                const patrolY = owner.y + Math.sin(owner.patrolAngle) * owner.radius * 0.5;
                mapCtx.beginPath();
                mapCtx.arc(patrolX, patrolY, 6, 0, Math.PI * 2);
                mapCtx.fill();

                // Net benefit indicator
                const benefitColor = owner.netBenefit > 0 ? '#4CAF50' : '#f44336';
                mapCtx.fillStyle = benefitColor;
                mapCtx.font = '10px sans-serif';
                mapCtx.fillText(owner.netBenefit.toFixed(1), owner.x - 10, owner.y - owner.radius - 5);
            });

            // Draw floaters
            floaters.forEach(f => {
                mapCtx.fillStyle = '#888';
                mapCtx.beginPath();
                mapCtx.arc(f.x, f.y, 4, 0, Math.PI * 2);
                mapCtx.fill();
            });

            // Legend
            mapCtx.font = '10px sans-serif';
            mapCtx.fillStyle = '#8BC34A';
            mapCtx.fillText('● Resources', 10, h - 30);
            mapCtx.fillStyle = '#888';
            mapCtx.fillText('● Floaters', 10, h - 15);
        }

        function drawEconomics() {
            const w = economicsCanvas.width / window.devicePixelRatio;
            const h = economicsCanvas.height / window.devicePixelRatio;

            economicsCtx.fillStyle = '#1a1a2e';
            economicsCtx.fillRect(0, 0, w, h);

            const padding = 45;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Axes
            economicsCtx.strokeStyle = '#666';
            economicsCtx.beginPath();
            economicsCtx.moveTo(padding, padding);
            economicsCtx.lineTo(padding, h - padding);
            economicsCtx.lineTo(w - padding, h - padding);
            economicsCtx.stroke();

            // Labels
            economicsCtx.fillStyle = '#aaa';
            economicsCtx.font = '10px sans-serif';
            economicsCtx.fillText('Value', 5, h / 2);
            economicsCtx.fillText('Territory Size', w / 2 - 30, h - 5);

            // Draw theoretical curves
            const params = getParams();
            const maxSize = 100;

            // Benefits curve (linear with resources)
            economicsCtx.strokeStyle = '#4CAF50';
            economicsCtx.lineWidth = 2;
            economicsCtx.beginPath();
            for (let s = 0; s <= maxSize; s++) {
                const area = Math.PI * s * s;
                const benefit = area * params.resourceDensity / 5000;
                const x = padding + (s / maxSize) * plotW;
                const y = h - padding - Math.min(benefit, plotH);
                if (s === 0) economicsCtx.moveTo(x, y);
                else economicsCtx.lineTo(x, y);
            }
            economicsCtx.stroke();

            // Cost curve
            economicsCtx.strokeStyle = '#f44336';
            economicsCtx.beginPath();
            for (let s = 0; s <= maxSize; s++) {
                const area = Math.PI * s * s;
                let cost;
                if (params.defenseModel === 'area') {
                    cost = area * params.defenseCost / 5000;
                } else if (params.defenseModel === 'perimeter') {
                    cost = Math.sqrt(area) * params.defenseCost / 50;
                } else {
                    cost = (area / 10000 + Math.sqrt(area) / 100) * params.defenseCost;
                }
                const x = padding + (s / maxSize) * plotW;
                const y = h - padding - Math.min(cost, plotH);
                if (s === 0) economicsCtx.moveTo(x, y);
                else economicsCtx.lineTo(x, y);
            }
            economicsCtx.stroke();

            // Net benefit curve
            economicsCtx.strokeStyle = '#ff9800';
            economicsCtx.setLineDash([5, 5]);
            economicsCtx.beginPath();
            for (let s = 0; s <= maxSize; s++) {
                const area = Math.PI * s * s;
                const benefit = area * params.resourceDensity / 5000;
                let cost;
                if (params.defenseModel === 'area') {
                    cost = area * params.defenseCost / 5000;
                } else if (params.defenseModel === 'perimeter') {
                    cost = Math.sqrt(area) * params.defenseCost / 50;
                } else {
                    cost = (area / 10000 + Math.sqrt(area) / 100) * params.defenseCost;
                }
                const net = benefit - cost;
                const x = padding + (s / maxSize) * plotW;
                const y = h - padding - (net * 0.5 + plotH / 2);
                if (s === 0) economicsCtx.moveTo(x, y);
                else economicsCtx.lineTo(x, y);
            }
            economicsCtx.stroke();
            economicsCtx.setLineDash([]);

            // Plot actual owner points
            owners.forEach(owner => {
                const x = padding + (owner.radius / maxSize) * plotW;
                const y = h - padding - (owner.netBenefit * 0.5 + plotH / 2);
                economicsCtx.fillStyle = owner.color;
                economicsCtx.beginPath();
                economicsCtx.arc(x, Math.max(padding, Math.min(h - padding, y)), 5, 0, Math.PI * 2);
                economicsCtx.fill();
            });

            // Legend
            economicsCtx.fillStyle = '#4CAF50';
            economicsCtx.fillText('Benefits', w - 80, 20);
            economicsCtx.fillStyle = '#f44336';
            economicsCtx.fillText('Costs', w - 80, 35);
            economicsCtx.fillStyle = '#ff9800';
            economicsCtx.fillText('Net (B-C)', w - 80, 50);
        }

        function drawDistribution() {
            const w = distributionCanvas.width / window.devicePixelRatio;
            const h = distributionCanvas.height / window.devicePixelRatio;

            distributionCtx.fillStyle = '#1a1a2e';
            distributionCtx.fillRect(0, 0, w, h);

            const padding = 40;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Create histogram
            const bins = 10;
            const minSize = 10;
            const maxSize = 90;
            const binWidth = (maxSize - minSize) / bins;
            const histogram = new Array(bins).fill(0);

            owners.forEach(owner => {
                const binIndex = Math.floor((owner.radius - minSize) / binWidth);
                if (binIndex >= 0 && binIndex < bins) {
                    histogram[binIndex]++;
                }
            });

            const maxCount = Math.max(...histogram, 1);

            // Axes
            distributionCtx.strokeStyle = '#666';
            distributionCtx.beginPath();
            distributionCtx.moveTo(padding, padding);
            distributionCtx.lineTo(padding, h - padding);
            distributionCtx.lineTo(w - padding, h - padding);
            distributionCtx.stroke();

            // Labels
            distributionCtx.fillStyle = '#aaa';
            distributionCtx.font = '10px sans-serif';
            distributionCtx.fillText('Count', 5, h / 2);
            distributionCtx.fillText('Radius', w / 2 - 15, h - 5);

            // Draw bars
            const barWidth = plotW / bins * 0.8;
            histogram.forEach((count, i) => {
                const x = padding + (i / bins) * plotW + (plotW / bins * 0.1);
                const barH = (count / maxCount) * plotH;
                const y = h - padding - barH;

                distributionCtx.fillStyle = '#4CAF50';
                distributionCtx.fillRect(x, y, barWidth, barH);

                // Bin label
                distributionCtx.fillStyle = '#888';
                distributionCtx.font = '8px sans-serif';
                const label = Math.round(minSize + i * binWidth);
                distributionCtx.fillText(label, x + barWidth / 2 - 5, h - padding + 12);
            });

            // Mean line
            const avgRadius = owners.reduce((sum, o) => sum + o.radius, 0) / owners.length;
            const meanX = padding + ((avgRadius - minSize) / (maxSize - minSize)) * plotW;
            distributionCtx.strokeStyle = '#ff9800';
            distributionCtx.setLineDash([5, 5]);
            distributionCtx.beginPath();
            distributionCtx.moveTo(meanX, padding);
            distributionCtx.lineTo(meanX, h - padding);
            distributionCtx.stroke();
            distributionCtx.setLineDash([]);

            distributionCtx.fillStyle = '#ff9800';
            distributionCtx.fillText(`Mean: ${avgRadius.toFixed(1)}`, meanX + 5, padding + 15);
        }

        function drawEvolution() {
            const w = evolutionCanvas.width / window.devicePixelRatio;
            const h = evolutionCanvas.height / window.devicePixelRatio;

            evolutionCtx.fillStyle = '#1a1a2e';
            evolutionCtx.fillRect(0, 0, w, h);

            if (sizeHistory.length < 2) return;

            const padding = 40;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Axes
            evolutionCtx.strokeStyle = '#666';
            evolutionCtx.beginPath();
            evolutionCtx.moveTo(padding, padding);
            evolutionCtx.lineTo(padding, h - padding);
            evolutionCtx.lineTo(w - padding, h - padding);
            evolutionCtx.stroke();

            // Labels
            evolutionCtx.fillStyle = '#aaa';
            evolutionCtx.font = '10px sans-serif';
            evolutionCtx.fillText('Radius', 5, h / 2);
            evolutionCtx.fillText('Time', w / 2 - 10, h - 5);

            // Draw range (min-max)
            evolutionCtx.fillStyle = 'rgba(76, 175, 80, 0.2)';
            evolutionCtx.beginPath();

            sizeHistory.forEach((d, i) => {
                const x = padding + (i / (sizeHistory.length - 1)) * plotW;
                const y = h - padding - ((d.max - 10) / 80) * plotH;
                if (i === 0) evolutionCtx.moveTo(x, y);
                else evolutionCtx.lineTo(x, y);
            });

            for (let i = sizeHistory.length - 1; i >= 0; i--) {
                const x = padding + (i / (sizeHistory.length - 1)) * plotW;
                const y = h - padding - ((sizeHistory[i].min - 10) / 80) * plotH;
                evolutionCtx.lineTo(x, y);
            }

            evolutionCtx.closePath();
            evolutionCtx.fill();

            // Draw average line
            evolutionCtx.strokeStyle = '#4CAF50';
            evolutionCtx.lineWidth = 2;
            evolutionCtx.beginPath();

            sizeHistory.forEach((d, i) => {
                const x = padding + (i / (sizeHistory.length - 1)) * plotW;
                const y = h - padding - ((d.avg - 10) / 80) * plotH;
                if (i === 0) evolutionCtx.moveTo(x, y);
                else evolutionCtx.lineTo(x, y);
            });

            evolutionCtx.stroke();

            // Legend
            evolutionCtx.fillStyle = '#4CAF50';
            evolutionCtx.fillText('● Average', w - 80, 20);
            evolutionCtx.fillStyle = 'rgba(76, 175, 80, 0.5)';
            evolutionCtx.fillRect(w - 90, 30, 15, 10);
            evolutionCtx.fillStyle = '#aaa';
            evolutionCtx.fillText('Range', w - 70, 39);
        }

        function animate() {
            if (running) {
                simulationStep();
            }
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            initSimulation();
        });

        // Slider value displays
        const sliders = [
            ['numOwners', 'numOwnersVal', v => v],
            ['resourceDensity', 'resourceDensityVal', v => v],
            ['resourceClumping', 'resourceClumpingVal', v => v + '%'],
            ['defenseCost', 'defenseCostVal', v => v],
            ['floaterDensity', 'floaterDensityVal', v => v],
            ['intrusionRate', 'intrusionRateVal', v => v + '%'],
            ['adjustSpeed', 'adjustSpeedVal', v => v]
        ];

        sliders.forEach(([id, displayId, formatter]) => {
            const input = document.getElementById(id);
            const display = document.getElementById(displayId);
            input.addEventListener('input', () => {
                display.textContent = formatter(parseInt(input.value));
            });
        });

        // Initialize
        initSimulation();
        animate();
    </script>
</body>
</html>
