<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battle of the Sexes - Asymmetric Coordination Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { font-family: 'Lora', serif; color: #606C38; font-size: 2rem; margin-bottom: 8px; }
        .subtitle { color: #8A9A5B; font-size: 1rem; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #606C38; font-weight: 600; }
        .main-content { display: grid; grid-template-columns: 1fr 320px; gap: 20px; }
        .canvas-container { background: white; border-radius: 12px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        canvas { display: block; width: 100%; border-radius: 8px; }
        .controls { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; color: #606C38; font-weight: 600; margin-bottom: 5px; font-size: 0.9rem; }
        .control-group input[type="range"] { width: 100%; }
        .control-group .value { color: #8A9A5B; font-size: 0.85rem; }
        button { padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer; font-family: 'Nunito', sans-serif; font-weight: 600; margin-right: 8px; margin-bottom: 8px; }
        .btn-primary { background: #8A9A5B; color: white; }
        .btn-secondary { background: #DDA15E; color: white; }
        .stats-box { background: #FEFAE0; border-radius: 8px; padding: 12px; margin-top: 15px; }
        .stat { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #EDE8D5; }
        .stat:last-child { border-bottom: none; }
        .stat-label { color: #606C38; font-size: 0.85rem; }
        .stat-value { color: #BC6C25; font-weight: 600; font-size: 0.9rem; }
        .payoff-matrix { margin-top: 15px; font-size: 0.75rem; }
        .payoff-matrix table { width: 100%; border-collapse: collapse; }
        .payoff-matrix th, .payoff-matrix td { border: 1px solid #DDA15E; padding: 5px; text-align: center; }
        .payoff-matrix th { background: #8A9A5B; color: white; }
        .info-panel { margin-top: 20px; padding: 15px; background: white; border-radius: 12px; font-size: 0.85rem; color: #606C38; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        .legend { display: flex; gap: 12px; flex-wrap: wrap; margin-top: 10px; }
        .legend-item { display: flex; align-items: center; gap: 5px; font-size: 0.75rem; }
        .legend-color { width: 15px; height: 15px; border-radius: 3px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Battle of the Sexes</h1>
            <p class="subtitle">Coordination with asymmetric payoffs and correlated equilibrium emergence</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Player 1 preferred payoff: <span class="value" id="valueP1">3</span></label>
                    <input type="range" id="p1Payoff" min="2" max="6" value="3">
                </div>

                <div class="control-group">
                    <label>Player 2 preferred payoff: <span class="value" id="valueP2">3</span></label>
                    <input type="range" id="p2Payoff" min="2" max="6" value="3">
                </div>

                <div class="control-group">
                    <label>Coordination bonus: <span class="value" id="valueCoord">2</span></label>
                    <input type="range" id="coordBonus" min="1" max="4" value="2">
                </div>

                <div class="control-group">
                    <label>Population: <span class="value" id="valuePop">100</span></label>
                    <input type="range" id="population" min="20" max="200" value="100">
                </div>

                <div class="control-group">
                    <label>Learning Rate: <span class="value" id="valueLR">0.10</span></label>
                    <input type="range" id="learnRate" min="1" max="50" value="10">
                </div>

                <div class="control-group">
                    <label>Signal Strength: <span class="value" id="valueSig">0.50</span></label>
                    <input type="range" id="signal" min="0" max="100" value="50">
                </div>

                <button class="btn-primary" onclick="resetSimulation()">Reset</button>
                <button class="btn-secondary" onclick="togglePause()">Pause</button>

                <div class="payoff-matrix">
                    <strong>Player 1 (rows) vs Player 2 (cols):</strong>
                    <table>
                        <tr><th></th><th>Option A</th><th>Option B</th></tr>
                        <tr><th>Option A</th><td id="payoffAA" style="background:#E9F5E9">P1:3, P2:2</td><td id="payoffAB">0, 0</td></tr>
                        <tr><th>Option B</th><td id="payoffBA">0, 0</td><td id="payoffBB" style="background:#E9F5E9">P1:2, P2:3</td></tr>
                    </table>
                </div>

                <div class="stats-box">
                    <div class="stat"><span class="stat-label">Round:</span><span class="stat-value" id="roundStat">0</span></div>
                    <div class="stat"><span class="stat-label">P1 choosing A:</span><span class="stat-value" id="p1AStat">0%</span></div>
                    <div class="stat"><span class="stat-label">P2 choosing A:</span><span class="stat-value" id="p2AStat">0%</span></div>
                    <div class="stat"><span class="stat-label">Coordination Rate:</span><span class="stat-value" id="coordStat">0%</span></div>
                    <div class="stat"><span class="stat-label">Current Equilibrium:</span><span class="stat-value" id="eqStat">None</span></div>
                </div>

                <div class="legend">
                    <div class="legend-item"><div class="legend-color" style="background: #457B9D;"></div>P1-A</div>
                    <div class="legend-item"><div class="legend-color" style="background: #E63946;"></div>P1-B</div>
                    <div class="legend-item"><div class="legend-color" style="background: #2A9D8F;"></div>P2-A</div>
                    <div class="legend-item"><div class="legend-color" style="background: #E9C46A;"></div>P2-B</div>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <strong>About this simulation:</strong> Two players with different preferences must coordinate.
            Both prefer coordination over miscoordination, but each prefers their own favored option.
            <strong>Two pure Nash equilibria</strong> exist (both A or both B), plus a <strong>mixed equilibrium</strong>.
            With signals (external cues), a <strong>correlated equilibrium</strong> can emerge where players take turns.
            Watch strategies evolve through reinforcement learning.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = 600 * dpr;
        canvas.style.height = '600px';
        ctx.scale(dpr, dpr);

        const width = rect.width;
        const height = 600;

        let p1Payoff = 3;  // P1's preferred payoff
        let p2Payoff = 3;  // P2's preferred payoff
        let coordBonus = 2; // Non-preferred coordination payoff
        let popSize = 100;
        let learnRate = 0.1;
        let signalStrength = 0.5;

        let p1Agents = [];  // Player 1 population
        let p2Agents = [];  // Player 2 population
        let history = { p1A: [], p2A: [], coord: [] };
        let round = 0;
        let paused = false;

        function initSimulation() {
            p1Agents = [];
            p2Agents = [];
            history = { p1A: [], p2A: [], coord: [] };
            round = 0;

            // Initialize agents with random probabilities of choosing A
            for (let i = 0; i < popSize; i++) {
                p1Agents.push({
                    probA: Math.random(),
                    x: Math.random() * (width/2 - 60) + 30,
                    y: Math.random() * (height - 250) + 30,
                    lastChoice: null,
                    lastPayoff: 0
                });

                p2Agents.push({
                    probA: Math.random(),
                    x: Math.random() * (width/2 - 60) + width/2 + 30,
                    y: Math.random() * (height - 250) + 30,
                    lastChoice: null,
                    lastPayoff: 0
                });
            }
        }

        function playRound() {
            const signal = Math.random(); // External signal for correlated equilibrium

            // Match agents randomly
            const shuffled1 = [...p1Agents].sort(() => Math.random() - 0.5);
            const shuffled2 = [...p2Agents].sort(() => Math.random() - 0.5);

            let coordinations = 0;

            for (let i = 0; i < popSize; i++) {
                const p1 = shuffled1[i];
                const p2 = shuffled2[i];

                // Choices influenced by signal and probability
                let p1Choice, p2Choice;

                if (Math.random() < signalStrength) {
                    // Follow correlated strategy based on signal
                    p1Choice = signal < 0.5 ? 'A' : 'B';
                    p2Choice = signal < 0.5 ? 'A' : 'B';
                } else {
                    // Mixed strategy
                    p1Choice = Math.random() < p1.probA ? 'A' : 'B';
                    p2Choice = Math.random() < p2.probA ? 'A' : 'B';
                }

                // Calculate payoffs
                let pay1 = 0, pay2 = 0;
                if (p1Choice === 'A' && p2Choice === 'A') {
                    pay1 = p1Payoff;
                    pay2 = coordBonus;
                    coordinations++;
                } else if (p1Choice === 'B' && p2Choice === 'B') {
                    pay1 = coordBonus;
                    pay2 = p2Payoff;
                    coordinations++;
                }
                // Miscoordination: both get 0

                // Update probabilities via reinforcement learning
                if (p1Choice === 'A') {
                    p1.probA += learnRate * (pay1 - p1.lastPayoff) * (1 - p1.probA);
                } else {
                    p1.probA -= learnRate * (pay1 - p1.lastPayoff) * p1.probA;
                }

                if (p2Choice === 'A') {
                    p2.probA += learnRate * (pay2 - p2.lastPayoff) * (1 - p2.probA);
                } else {
                    p2.probA -= learnRate * (pay2 - p2.lastPayoff) * p2.probA;
                }

                // Clamp probabilities
                p1.probA = Math.max(0.01, Math.min(0.99, p1.probA));
                p2.probA = Math.max(0.01, Math.min(0.99, p2.probA));

                p1.lastChoice = p1Choice;
                p2.lastChoice = p2Choice;
                p1.lastPayoff = pay1;
                p2.lastPayoff = pay2;
            }

            round++;
            return coordinations / popSize;
        }

        function getStats() {
            const p1ARate = p1Agents.reduce((sum, a) => sum + a.probA, 0) / popSize;
            const p2ARate = p2Agents.reduce((sum, a) => sum + a.probA, 0) / popSize;
            return { p1A: p1ARate, p2A: p2ARate };
        }

        function draw() {
            ctx.fillStyle = '#FEFAE0';
            ctx.fillRect(0, 0, width, height);

            // Draw divider
            ctx.strokeStyle = '#DDA15E';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2, 10);
            ctx.lineTo(width/2, height - 200);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#606C38';
            ctx.font = 'bold 14px Nunito';
            ctx.fillText('Player 1 Population', 20, 25);
            ctx.fillText('Player 2 Population', width/2 + 20, 25);

            // Draw P1 agents
            p1Agents.forEach(a => {
                const color = a.probA > 0.5 ? '#457B9D' : '#E63946';
                const intensity = Math.abs(a.probA - 0.5) * 2;
                ctx.globalAlpha = 0.3 + intensity * 0.7;
                ctx.beginPath();
                ctx.arc(a.x, a.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
            });

            // Draw P2 agents
            p2Agents.forEach(a => {
                const color = a.probA > 0.5 ? '#2A9D8F' : '#E9C46A';
                const intensity = Math.abs(a.probA - 0.5) * 2;
                ctx.globalAlpha = 0.3 + intensity * 0.7;
                ctx.beginPath();
                ctx.arc(a.x, a.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Draw history chart
            const chartY = height - 180;
            const chartHeight = 160;

            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(20, chartY, width - 40, chartHeight);
            ctx.strokeStyle = '#DDA15E';
            ctx.strokeRect(20, chartY, width - 40, chartHeight);

            if (history.p1A.length > 1) {
                const maxPoints = 300;
                const startIdx = Math.max(0, history.p1A.length - maxPoints);
                const step = (width - 60) / Math.max(1, Math.min(history.p1A.length, maxPoints) - 1);

                // P1 choosing A
                ctx.beginPath();
                for (let i = startIdx; i < history.p1A.length; i++) {
                    const x = 30 + (i - startIdx) * step;
                    const y = chartY + chartHeight - 10 - history.p1A[i] * (chartHeight - 30);
                    if (i === startIdx) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.strokeStyle = '#457B9D';
                ctx.lineWidth = 2;
                ctx.stroke();

                // P2 choosing A
                ctx.beginPath();
                for (let i = startIdx; i < history.p2A.length; i++) {
                    const x = 30 + (i - startIdx) * step;
                    const y = chartY + chartHeight - 10 - history.p2A[i] * (chartHeight - 30);
                    if (i === startIdx) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.strokeStyle = '#2A9D8F';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Coordination rate
                ctx.beginPath();
                for (let i = startIdx; i < history.coord.length; i++) {
                    const x = 30 + (i - startIdx) * step;
                    const y = chartY + chartHeight - 10 - history.coord[i] * (chartHeight - 30);
                    if (i === startIdx) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.strokeStyle = '#BC6C25';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            ctx.fillStyle = '#606C38';
            ctx.font = '11px Nunito';
            ctx.fillText('Blue: P1→A, Green: P2→A, Dashed: Coordination rate', 30, chartY + 15);
        }

        function updateStats() {
            const stats = getStats();
            const coordRate = history.coord.length > 0 ? history.coord[history.coord.length - 1] : 0;

            document.getElementById('roundStat').textContent = round;
            document.getElementById('p1AStat').textContent = (stats.p1A * 100).toFixed(1) + '%';
            document.getElementById('p2AStat').textContent = (stats.p2A * 100).toFixed(1) + '%';
            document.getElementById('coordStat').textContent = (coordRate * 100).toFixed(1) + '%';

            // Detect equilibrium
            let eq = 'Mixed';
            if (stats.p1A > 0.8 && stats.p2A > 0.8) {
                eq = 'Pure: Both A';
            } else if (stats.p1A < 0.2 && stats.p2A < 0.2) {
                eq = 'Pure: Both B';
            } else if (coordRate > 0.7 && Math.abs(stats.p1A - stats.p2A) < 0.2) {
                eq = 'Correlated';
            }
            document.getElementById('eqStat').textContent = eq;

            // Update payoff matrix
            document.getElementById('payoffAA').textContent = `P1:${p1Payoff}, P2:${coordBonus}`;
            document.getElementById('payoffBB').textContent = `P1:${coordBonus}, P2:${p2Payoff}`;
        }

        function updateControls() {
            p1Payoff = parseInt(document.getElementById('p1Payoff').value);
            p2Payoff = parseInt(document.getElementById('p2Payoff').value);
            coordBonus = parseInt(document.getElementById('coordBonus').value);
            popSize = parseInt(document.getElementById('population').value);
            learnRate = parseInt(document.getElementById('learnRate').value) / 100;
            signalStrength = parseInt(document.getElementById('signal').value) / 100;

            document.getElementById('valueP1').textContent = p1Payoff;
            document.getElementById('valueP2').textContent = p2Payoff;
            document.getElementById('valueCoord').textContent = coordBonus;
            document.getElementById('valuePop').textContent = popSize;
            document.getElementById('valueLR').textContent = learnRate.toFixed(2);
            document.getElementById('valueSig').textContent = signalStrength.toFixed(2);
        }

        function resetSimulation() {
            updateControls();
            initSimulation();
        }

        function togglePause() {
            paused = !paused;
        }

        function animate() {
            if (!paused) {
                const coordRate = playRound();
                const stats = getStats();

                history.p1A.push(stats.p1A);
                history.p2A.push(stats.p2A);
                history.coord.push(coordRate);

                if (history.p1A.length > 500) {
                    history.p1A.shift();
                    history.p2A.shift();
                    history.coord.shift();
                }

                updateStats();
            }

            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.querySelectorAll('input[type="range"]').forEach(input => {
            input.addEventListener('input', updateControls);
        });

        updateControls();
        initSimulation();
        animate();
    </script>
</body>
</html>
