<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ideal Free Distribution</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        .back-link {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: var(--terracotta);
        }

        h1 {
            color: var(--dark-moss);
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .subtitle {
            color: var(--moss);
            font-size: 1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: var(--moss);
            font-size: 0.95em;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid var(--sage);
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            color: var(--dark-moss);
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group .value {
            text-align: right;
            font-size: 0.8em;
            color: var(--moss);
        }

        .control-group select {
            width: 100%;
            padding: 6px;
            border: 1px solid var(--sage);
            border-radius: 6px;
            font-size: 0.9em;
        }

        .button-group {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.3s;
        }

        .btn-primary {
            background: var(--sage);
            color: white;
        }

        .btn-primary:hover {
            background: var(--moss);
        }

        .btn-secondary {
            background: var(--earth);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--terracotta);
        }

        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .viz-panel {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .viz-panel h3 {
            color: var(--moss);
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        canvas {
            width: 100%;
            border-radius: 8px;
            background: #1a1a2e;
        }

        .viz-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .stat-box {
            background: linear-gradient(135deg, var(--cream) 0%, white 100%);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            border-left: 3px solid var(--sage);
        }

        .stat-box.highlight {
            border-left-color: var(--terracotta);
        }

        .stat-box.success {
            border-left-color: #4CAF50;
        }

        .stat-box .label {
            font-size: 0.75em;
            color: var(--moss);
            margin-bottom: 4px;
        }

        .stat-box .value {
            font-size: 1.2em;
            font-weight: bold;
            color: var(--dark-moss);
        }

        .info-box {
            background: linear-gradient(135deg, #e3f2fd 0%, white 100%);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            font-size: 0.8em;
            color: var(--dark-moss);
        }

        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
            font-size: 0.8em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">← Back to Simulations</a>
            <h1>Ideal Free Distribution</h1>
            <p class="subtitle">Habitat Selection & Density-Dependent Resource Competition</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-section">
                    <h3>Habitat Configuration</h3>
                    <div class="control-group">
                        <label>Number of Habitats: <span id="numHabitatsVal">4</span></label>
                        <input type="range" id="numHabitats" min="2" max="8" value="4">
                    </div>
                    <div class="control-group">
                        <label>Quality Distribution:</label>
                        <select id="qualityDist">
                            <option value="uniform">Uniform (equal)</option>
                            <option value="gradient">Gradient (1:2:3:4)</option>
                            <option value="random">Random</option>
                            <option value="bimodal">Bimodal (high/low)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Resource Input Rate: <span id="inputRateVal">10</span></label>
                        <input type="range" id="inputRate" min="1" max="50" value="10">
                        <div class="value">per habitat per time</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Population</h3>
                    <div class="control-group">
                        <label>Total Foragers: <span id="numForagersVal">40</span></label>
                        <input type="range" id="numForagers" min="10" max="100" value="40" step="5">
                    </div>
                    <div class="control-group">
                        <label>Movement Rate: <span id="moveRateVal">0.10</span></label>
                        <input type="range" id="moveRate" min="1" max="50" value="10">
                        <div class="value">switching probability</div>
                    </div>
                    <div class="control-group">
                        <label>Perception Error: <span id="errorVal">0.05</span></label>
                        <input type="range" id="error" min="0" max="30" value="5">
                        <div class="value">assessment noise</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>IFD Model</h3>
                    <div class="control-group">
                        <label>Interference Coefficient (m): <span id="interferenceVal">1.00</span></label>
                        <input type="range" id="interference" min="50" max="200" value="100">
                        <div class="value">1.0 = equal share, >1 = interference</div>
                    </div>
                    <div class="control-group">
                        <label>Decision Rule:</label>
                        <select id="decisionRule">
                            <option value="optimal">IFD Optimal</option>
                            <option value="sampling">Sample & Compare</option>
                            <option value="imitation">Imitate Successful</option>
                            <option value="random">Random Movement</option>
                        </select>
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="info-box">
                    <strong>Ideal Free Distribution:</strong><br>
                    At equilibrium, all individuals should have equal fitness regardless of which habitat they occupy. Foragers distribute themselves proportionally to habitat quality.
                    <br><br>
                    <em>Suitability = Quality / Competitors<sup>m</sup></em>
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-panel">
                    <h3>Habitat Landscape</h3>
                    <canvas id="habitatCanvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4CAF50;"></div>
                            <span>High Quality</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FFC107;"></div>
                            <span>Medium Quality</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FF5722;"></div>
                            <span>Low Quality</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #2196F3;"></div>
                            <span>Foragers</span>
                        </div>
                    </div>
                </div>

                <div class="viz-row">
                    <div class="viz-panel">
                        <h3>Forager Distribution vs IFD Prediction</h3>
                        <canvas id="distributionCanvas"></canvas>
                    </div>
                    <div class="viz-panel">
                        <h3>Per-Capita Intake Rate by Habitat</h3>
                        <canvas id="intakeCanvas"></canvas>
                    </div>
                </div>

                <div class="viz-row">
                    <div class="viz-panel">
                        <h3>Distribution Dynamics Over Time</h3>
                        <canvas id="dynamicsCanvas"></canvas>
                    </div>
                    <div class="viz-panel">
                        <h3>Fitness Variance (IFD Convergence)</h3>
                        <canvas id="varianceCanvas"></canvas>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="label">Time Step</div>
                        <div class="value" id="timeStat">0</div>
                    </div>
                    <div class="stat-box highlight">
                        <div class="label">Fitness Variance</div>
                        <div class="value" id="varianceStat">0.00</div>
                    </div>
                    <div class="stat-box success">
                        <div class="label">Mean Fitness</div>
                        <div class="value" id="meanFitStat">0.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">IFD Match %</div>
                        <div class="value" id="matchStat">0%</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Movements</div>
                        <div class="value" id="moveStat">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Equilibrium</div>
                        <div class="value" id="eqStat">No</div>
                    </div>
                </div>

                <div class="viz-panel">
                    <h3>Habitat Details</h3>
                    <canvas id="detailCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const habitatCanvas = document.getElementById('habitatCanvas');
        const distributionCanvas = document.getElementById('distributionCanvas');
        const intakeCanvas = document.getElementById('intakeCanvas');
        const dynamicsCanvas = document.getElementById('dynamicsCanvas');
        const varianceCanvas = document.getElementById('varianceCanvas');
        const detailCanvas = document.getElementById('detailCanvas');

        const habitatCtx = habitatCanvas.getContext('2d');
        const distributionCtx = distributionCanvas.getContext('2d');
        const intakeCtx = intakeCanvas.getContext('2d');
        const dynamicsCtx = dynamicsCanvas.getContext('2d');
        const varianceCtx = varianceCanvas.getContext('2d');
        const detailCtx = detailCanvas.getContext('2d');

        // Parameters
        let numHabitats = 4;
        let qualityDist = 'gradient';
        let inputRate = 10;
        let numForagers = 40;
        let moveRate = 0.10;
        let perceptionError = 0.05;
        let interference = 1.0;
        let decisionRule = 'optimal';

        // State
        let habitats = [];
        let foragers = [];
        let time = 0;
        let totalMovements = 0;
        let distributionHistory = [];
        let varianceHistory = [];
        let running = false;
        let animationId = null;

        function setupCanvas(canvas, ctx, height) {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = (rect.width - 30) * dpr;
            canvas.height = height * dpr;
            canvas.style.width = (rect.width - 30) + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(dpr, dpr);
        }

        function generateHabitats() {
            habitats = [];

            let qualities = [];
            if (qualityDist === 'uniform') {
                qualities = new Array(numHabitats).fill(1);
            } else if (qualityDist === 'gradient') {
                for (let i = 0; i < numHabitats; i++) {
                    qualities.push(i + 1);
                }
            } else if (qualityDist === 'random') {
                for (let i = 0; i < numHabitats; i++) {
                    qualities.push(0.5 + Math.random() * 1.5);
                }
            } else {
                // Bimodal
                for (let i = 0; i < numHabitats; i++) {
                    qualities.push(i < numHabitats / 2 ? 0.5 : 2);
                }
            }

            // Normalize
            const total = qualities.reduce((a, b) => a + b, 0);

            for (let i = 0; i < numHabitats; i++) {
                const angle = (i / numHabitats) * Math.PI * 2 - Math.PI / 2;
                const radius = 0.3;
                habitats.push({
                    id: i,
                    x: 0.5 + Math.cos(angle) * radius,
                    y: 0.5 + Math.sin(angle) * radius,
                    quality: qualities[i],
                    normalizedQuality: qualities[i] / total,
                    resources: qualities[i] * inputRate,
                    foragerCount: 0
                });
            }
        }

        function getIFDPrediction() {
            // Calculate ideal free distribution prediction
            // n_i / N = Q_i / sum(Q)
            const totalQuality = habitats.reduce((s, h) => s + h.quality, 0);
            return habitats.map(h => ({
                habitatId: h.id,
                expectedProportion: h.quality / totalQuality,
                expectedCount: Math.round(numForagers * h.quality / totalQuality)
            }));
        }

        function getSuitability(habitat) {
            // Suitability = Q / n^m where m is interference coefficient
            const n = Math.max(1, habitat.foragerCount);
            return habitat.quality * inputRate / Math.pow(n, interference);
        }

        function getPerceivedSuitability(habitat) {
            // Add perception error
            const true_suit = getSuitability(habitat);
            return true_suit * (1 + (Math.random() - 0.5) * 2 * perceptionError);
        }

        function initSimulation() {
            time = 0;
            totalMovements = 0;
            distributionHistory = [];
            varianceHistory = [];

            generateHabitats();

            // Initialize foragers
            foragers = [];
            for (let i = 0; i < numForagers; i++) {
                const habitat = habitats[i % numHabitats];
                foragers.push({
                    id: i,
                    currentHabitat: habitat.id,
                    fitness: 0,
                    x: habitat.x + (Math.random() - 0.5) * 0.1,
                    y: habitat.y + (Math.random() - 0.5) * 0.1
                });
            }

            updateForagerCounts();
        }

        function updateForagerCounts() {
            // Reset counts
            for (const h of habitats) {
                h.foragerCount = 0;
            }
            // Count foragers per habitat
            for (const f of foragers) {
                habitats[f.currentHabitat].foragerCount++;
            }
        }

        function calculateFitness() {
            for (const f of foragers) {
                const habitat = habitats[f.currentHabitat];
                f.fitness = getSuitability(habitat);
            }
        }

        function moveForagers() {
            for (const f of foragers) {
                if (Math.random() > moveRate) continue;

                const currentHabitat = habitats[f.currentHabitat];
                let bestHabitat = currentHabitat;
                let bestSuitability = getPerceivedSuitability(currentHabitat);

                if (decisionRule === 'optimal') {
                    // Check all habitats
                    for (const h of habitats) {
                        const suit = getPerceivedSuitability(h);
                        if (suit > bestSuitability * 1.05) {  // Require 5% improvement
                            bestSuitability = suit;
                            bestHabitat = h;
                        }
                    }
                } else if (decisionRule === 'sampling') {
                    // Sample one other habitat
                    const otherHabitats = habitats.filter(h => h.id !== f.currentHabitat);
                    if (otherHabitats.length > 0) {
                        const sample = otherHabitats[Math.floor(Math.random() * otherHabitats.length)];
                        if (getPerceivedSuitability(sample) > bestSuitability) {
                            bestHabitat = sample;
                        }
                    }
                } else if (decisionRule === 'imitation') {
                    // Copy a random successful forager
                    const otherForagers = foragers.filter(o => o.id !== f.id);
                    if (otherForagers.length > 0) {
                        const other = otherForagers[Math.floor(Math.random() * otherForagers.length)];
                        if (other.fitness > f.fitness * 1.1) {
                            bestHabitat = habitats[other.currentHabitat];
                        }
                    }
                } else {
                    // Random
                    bestHabitat = habitats[Math.floor(Math.random() * habitats.length)];
                }

                if (bestHabitat.id !== f.currentHabitat) {
                    f.currentHabitat = bestHabitat.id;
                    f.x = bestHabitat.x + (Math.random() - 0.5) * 0.1;
                    f.y = bestHabitat.y + (Math.random() - 0.5) * 0.1;
                    totalMovements++;
                }
            }

            updateForagerCounts();
        }

        function step() {
            moveForagers();
            calculateFitness();
            time++;

            // Record distribution
            const distribution = habitats.map(h => ({
                id: h.id,
                count: h.foragerCount,
                proportion: h.foragerCount / numForagers
            }));
            distributionHistory.push({ time, distribution });

            // Record fitness variance
            const meanFit = foragers.reduce((s, f) => s + f.fitness, 0) / foragers.length;
            const variance = foragers.reduce((s, f) => s + Math.pow(f.fitness - meanFit, 2), 0) / foragers.length;
            varianceHistory.push({ time, variance, mean: meanFit });

            if (distributionHistory.length > 300) {
                distributionHistory = distributionHistory.filter((_, i) => i % 2 === 0);
                varianceHistory = varianceHistory.filter((_, i) => i % 2 === 0);
            }
        }

        function drawHabitats() {
            const width = habitatCanvas.width / (window.devicePixelRatio || 1);
            const height = habitatCanvas.height / (window.devicePixelRatio || 1);

            habitatCtx.fillStyle = '#1a1a2e';
            habitatCtx.fillRect(0, 0, width, height);

            const size = Math.min(width, height);
            const offsetX = (width - size) / 2;
            const offsetY = (height - size) / 2;

            // Draw habitats
            for (const h of habitats) {
                const x = offsetX + h.x * size;
                const y = offsetY + h.y * size;
                const radius = 50 + h.quality * 20;

                // Color based on quality
                const hue = h.quality * 40;  // Red to green based on quality
                habitatCtx.fillStyle = `hsla(${hue}, 60%, 40%, 0.5)`;
                habitatCtx.beginPath();
                habitatCtx.arc(x, y, radius, 0, Math.PI * 2);
                habitatCtx.fill();

                habitatCtx.strokeStyle = `hsl(${hue}, 60%, 50%)`;
                habitatCtx.lineWidth = 3;
                habitatCtx.stroke();

                // Habitat label
                habitatCtx.fillStyle = '#fff';
                habitatCtx.font = 'bold 14px sans-serif';
                habitatCtx.textAlign = 'center';
                habitatCtx.fillText(`H${h.id + 1}`, x, y - radius - 10);

                habitatCtx.font = '11px sans-serif';
                habitatCtx.fillText(`Q: ${h.quality.toFixed(2)}`, x, y - 5);
                habitatCtx.fillText(`n: ${h.foragerCount}`, x, y + 10);
            }

            // Draw foragers
            for (const f of foragers) {
                const x = offsetX + f.x * size;
                const y = offsetY + f.y * size;

                habitatCtx.fillStyle = '#2196F3';
                habitatCtx.beginPath();
                habitatCtx.arc(x, y, 5, 0, Math.PI * 2);
                habitatCtx.fill();
            }

            // Draw center
            habitatCtx.fillStyle = '#ffffffaa';
            habitatCtx.font = '10px sans-serif';
            habitatCtx.textAlign = 'center';
            habitatCtx.fillText(`t = ${time}`, width / 2, height - 10);
        }

        function drawDistribution() {
            const width = distributionCanvas.width / (window.devicePixelRatio || 1);
            const height = distributionCanvas.height / (window.devicePixelRatio || 1);

            distributionCtx.fillStyle = '#1a1a2e';
            distributionCtx.fillRect(0, 0, width, height);

            const padding = 50;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            const ifdPrediction = getIFDPrediction();
            const barWidth = graphWidth / (numHabitats * 3);

            for (let i = 0; i < numHabitats; i++) {
                const predicted = ifdPrediction[i].expectedCount;
                const actual = habitats[i].foragerCount;

                const baseX = padding + i * (graphWidth / numHabitats) + graphWidth / (numHabitats * 4);

                // Predicted bar
                const predHeight = (predicted / numForagers) * graphHeight;
                distributionCtx.fillStyle = '#4CAF5088';
                distributionCtx.fillRect(baseX, height - padding - predHeight, barWidth, predHeight);

                // Actual bar
                const actHeight = (actual / numForagers) * graphHeight;
                distributionCtx.fillStyle = '#2196F3';
                distributionCtx.fillRect(baseX + barWidth + 5, height - padding - actHeight, barWidth, actHeight);

                // Labels
                distributionCtx.fillStyle = '#ffffffaa';
                distributionCtx.font = '9px sans-serif';
                distributionCtx.textAlign = 'center';
                distributionCtx.fillText(`H${i + 1}`, baseX + barWidth, height - 10);
            }

            // Legend
            distributionCtx.fillStyle = '#4CAF5088';
            distributionCtx.fillRect(padding, padding - 15, 15, 10);
            distributionCtx.fillStyle = '#ffffffaa';
            distributionCtx.textAlign = 'left';
            distributionCtx.fillText('IFD Predicted', padding + 20, padding - 7);

            distributionCtx.fillStyle = '#2196F3';
            distributionCtx.fillRect(padding + 100, padding - 15, 15, 10);
            distributionCtx.fillText('Actual', padding + 120, padding - 7);

            // Axes
            distributionCtx.strokeStyle = '#ffffff44';
            distributionCtx.beginPath();
            distributionCtx.moveTo(padding, height - padding);
            distributionCtx.lineTo(width - padding, height - padding);
            distributionCtx.stroke();
        }

        function drawIntake() {
            const width = intakeCanvas.width / (window.devicePixelRatio || 1);
            const height = intakeCanvas.height / (window.devicePixelRatio || 1);

            intakeCtx.fillStyle = '#1a1a2e';
            intakeCtx.fillRect(0, 0, width, height);

            const padding = 50;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            const suitabilities = habitats.map(h => getSuitability(h));
            const maxSuit = Math.max(...suitabilities, 1);
            const barWidth = graphWidth / (numHabitats * 2);

            // Draw bars
            for (let i = 0; i < numHabitats; i++) {
                const suit = suitabilities[i];
                const x = padding + i * (graphWidth / numHabitats) + graphWidth / (numHabitats * 4);
                const barHeight = (suit / maxSuit) * graphHeight;

                // Color based on relative fitness
                const hue = (suit / maxSuit) * 120;
                intakeCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                intakeCtx.fillRect(x, height - padding - barHeight, barWidth, barHeight);

                // Value label
                intakeCtx.fillStyle = '#ffffffaa';
                intakeCtx.font = '9px sans-serif';
                intakeCtx.textAlign = 'center';
                intakeCtx.fillText(suit.toFixed(2), x + barWidth / 2, height - padding - barHeight - 5);
                intakeCtx.fillText(`H${i + 1}`, x + barWidth / 2, height - 10);
            }

            // Draw mean line
            const meanSuit = suitabilities.reduce((a, b) => a + b, 0) / numHabitats;
            const meanY = height - padding - (meanSuit / maxSuit) * graphHeight;

            intakeCtx.strokeStyle = '#E91E63';
            intakeCtx.lineWidth = 2;
            intakeCtx.setLineDash([5, 5]);
            intakeCtx.beginPath();
            intakeCtx.moveTo(padding, meanY);
            intakeCtx.lineTo(width - padding, meanY);
            intakeCtx.stroke();
            intakeCtx.setLineDash([]);

            intakeCtx.fillStyle = '#E91E63';
            intakeCtx.textAlign = 'left';
            intakeCtx.fillText(`Mean: ${meanSuit.toFixed(2)}`, padding + 5, meanY - 5);

            // Title
            intakeCtx.fillStyle = '#ffffffaa';
            intakeCtx.font = '10px sans-serif';
            intakeCtx.fillText('Per-Capita Fitness (should equalize at IFD)', padding, padding - 15);
        }

        function drawDynamics() {
            const width = dynamicsCanvas.width / (window.devicePixelRatio || 1);
            const height = dynamicsCanvas.height / (window.devicePixelRatio || 1);

            dynamicsCtx.fillStyle = '#1a1a2e';
            dynamicsCtx.fillRect(0, 0, width, height);

            if (distributionHistory.length < 2) return;

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            const maxTime = distributionHistory[distributionHistory.length - 1].time;
            const ifdPrediction = getIFDPrediction();

            // Draw line for each habitat
            const colors = ['#4CAF50', '#2196F3', '#FFC107', '#E91E63', '#9C27B0', '#00BCD4', '#FF5722', '#795548'];

            for (let h = 0; h < numHabitats; h++) {
                dynamicsCtx.strokeStyle = colors[h % colors.length];
                dynamicsCtx.lineWidth = 2;
                dynamicsCtx.beginPath();

                distributionHistory.forEach((point, i) => {
                    const x = padding + (point.time / maxTime) * graphWidth;
                    const y = height - padding - point.distribution[h].proportion * graphHeight;

                    if (i === 0) {
                        dynamicsCtx.moveTo(x, y);
                    } else {
                        dynamicsCtx.lineTo(x, y);
                    }
                });
                dynamicsCtx.stroke();

                // Draw IFD target
                const targetY = height - padding - ifdPrediction[h].expectedProportion * graphHeight;
                dynamicsCtx.setLineDash([3, 3]);
                dynamicsCtx.beginPath();
                dynamicsCtx.moveTo(width - padding - 20, targetY);
                dynamicsCtx.lineTo(width - padding, targetY);
                dynamicsCtx.stroke();
                dynamicsCtx.setLineDash([]);
            }

            // Axes
            dynamicsCtx.strokeStyle = '#ffffff44';
            dynamicsCtx.beginPath();
            dynamicsCtx.moveTo(padding, padding);
            dynamicsCtx.lineTo(padding, height - padding);
            dynamicsCtx.lineTo(width - padding, height - padding);
            dynamicsCtx.stroke();

            dynamicsCtx.fillStyle = '#ffffffaa';
            dynamicsCtx.font = '10px sans-serif';
            dynamicsCtx.fillText('Proportion', padding + 5, padding - 5);
            dynamicsCtx.textAlign = 'center';
            dynamicsCtx.fillText('Time', width / 2, height - 5);
        }

        function drawVariance() {
            const width = varianceCanvas.width / (window.devicePixelRatio || 1);
            const height = varianceCanvas.height / (window.devicePixelRatio || 1);

            varianceCtx.fillStyle = '#1a1a2e';
            varianceCtx.fillRect(0, 0, width, height);

            if (varianceHistory.length < 2) return;

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            const maxTime = varianceHistory[varianceHistory.length - 1].time;
            const maxVar = Math.max(...varianceHistory.map(v => v.variance), 0.1);

            // Draw variance line
            varianceCtx.strokeStyle = '#f44336';
            varianceCtx.lineWidth = 2;
            varianceCtx.beginPath();

            varianceHistory.forEach((point, i) => {
                const x = padding + (point.time / maxTime) * graphWidth;
                const y = height - padding - (point.variance / maxVar) * graphHeight;

                if (i === 0) {
                    varianceCtx.moveTo(x, y);
                } else {
                    varianceCtx.lineTo(x, y);
                }
            });
            varianceCtx.stroke();

            // Zero variance line (IFD equilibrium)
            varianceCtx.strokeStyle = '#4CAF50';
            varianceCtx.setLineDash([5, 5]);
            varianceCtx.beginPath();
            varianceCtx.moveTo(padding, height - padding);
            varianceCtx.lineTo(width - padding, height - padding);
            varianceCtx.stroke();
            varianceCtx.setLineDash([]);

            // Axes
            varianceCtx.strokeStyle = '#ffffff44';
            varianceCtx.beginPath();
            varianceCtx.moveTo(padding, padding);
            varianceCtx.lineTo(padding, height - padding);
            varianceCtx.lineTo(width - padding, height - padding);
            varianceCtx.stroke();

            varianceCtx.fillStyle = '#ffffffaa';
            varianceCtx.font = '10px sans-serif';
            varianceCtx.fillText('Fitness Variance', padding + 5, padding - 5);
            varianceCtx.fillStyle = '#4CAF50';
            varianceCtx.fillText('IFD = 0 variance', width - padding - 80, height - padding + 15);
        }

        function drawDetails() {
            const width = detailCanvas.width / (window.devicePixelRatio || 1);
            const height = detailCanvas.height / (window.devicePixelRatio || 1);

            detailCtx.fillStyle = '#1a1a2e';
            detailCtx.fillRect(0, 0, width, height);

            const colWidth = width / numHabitats;
            const padding = 20;

            const ifdPrediction = getIFDPrediction();

            for (let i = 0; i < numHabitats; i++) {
                const x = i * colWidth + padding;
                const h = habitats[i];
                const pred = ifdPrediction[i];

                // Header
                detailCtx.fillStyle = '#ffffffdd';
                detailCtx.font = 'bold 12px sans-serif';
                detailCtx.textAlign = 'left';
                detailCtx.fillText(`Habitat ${i + 1}`, x, 20);

                // Details
                detailCtx.font = '10px sans-serif';
                detailCtx.fillStyle = '#ffffffaa';

                detailCtx.fillText(`Quality: ${h.quality.toFixed(2)}`, x, 40);
                detailCtx.fillText(`Foragers: ${h.foragerCount}`, x, 55);
                detailCtx.fillText(`Predicted: ${pred.expectedCount}`, x, 70);

                const suit = getSuitability(h);
                detailCtx.fillText(`Suitability: ${suit.toFixed(2)}`, x, 85);

                // Match indicator
                const match = Math.abs(h.foragerCount - pred.expectedCount) <= 1;
                detailCtx.fillStyle = match ? '#4CAF50' : '#f44336';
                detailCtx.fillText(match ? '✓ At IFD' : '✗ Moving', x, 100);
            }
        }

        function updateStats() {
            const ifdPrediction = getIFDPrediction();

            // Calculate IFD match
            let matchCount = 0;
            for (let i = 0; i < numHabitats; i++) {
                if (Math.abs(habitats[i].foragerCount - ifdPrediction[i].expectedCount) <= 1) {
                    matchCount++;
                }
            }
            const matchPercent = Math.round((matchCount / numHabitats) * 100);

            // Fitness stats
            const meanFit = foragers.reduce((s, f) => s + f.fitness, 0) / foragers.length;
            const variance = foragers.reduce((s, f) => s + Math.pow(f.fitness - meanFit, 2), 0) / foragers.length;

            // Equilibrium check
            const isEquilibrium = variance < 0.01 && matchPercent >= 75;

            document.getElementById('timeStat').textContent = time;
            document.getElementById('varianceStat').textContent = variance.toFixed(3);
            document.getElementById('meanFitStat').textContent = meanFit.toFixed(2);
            document.getElementById('matchStat').textContent = matchPercent + '%';
            document.getElementById('moveStat').textContent = totalMovements;
            document.getElementById('eqStat').textContent = isEquilibrium ? 'Yes!' : 'No';
            document.getElementById('eqStat').style.color = isEquilibrium ? '#4CAF50' : 'inherit';
        }

        function animate() {
            step();

            drawHabitats();
            drawDistribution();
            drawIntake();
            drawDynamics();
            drawVariance();
            drawDetails();
            updateStats();

            if (running) {
                animationId = requestAnimationFrame(animate);
            }
        }

        function start() {
            if (!running) {
                running = true;
                document.getElementById('startBtn').textContent = 'Pause';
                animate();
            } else {
                running = false;
                document.getElementById('startBtn').textContent = 'Start';
                if (animationId) cancelAnimationFrame(animationId);
            }
        }

        function reset() {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            if (animationId) cancelAnimationFrame(animationId);

            numHabitats = parseInt(document.getElementById('numHabitats').value);
            qualityDist = document.getElementById('qualityDist').value;
            inputRate = parseInt(document.getElementById('inputRate').value);
            numForagers = parseInt(document.getElementById('numForagers').value);
            moveRate = parseInt(document.getElementById('moveRate').value) / 100;
            perceptionError = parseInt(document.getElementById('error').value) / 100;
            interference = parseInt(document.getElementById('interference').value) / 100;
            decisionRule = document.getElementById('decisionRule').value;

            initSimulation();
            drawHabitats();
            drawDistribution();
            drawIntake();
            drawDynamics();
            drawVariance();
            drawDetails();
            updateStats();
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', start);
        document.getElementById('resetBtn').addEventListener('click', reset);

        document.getElementById('numHabitats').addEventListener('input', (e) => {
            document.getElementById('numHabitatsVal').textContent = e.target.value;
        });

        document.getElementById('inputRate').addEventListener('input', (e) => {
            document.getElementById('inputRateVal').textContent = e.target.value;
        });

        document.getElementById('numForagers').addEventListener('input', (e) => {
            document.getElementById('numForagersVal').textContent = e.target.value;
        });

        document.getElementById('moveRate').addEventListener('input', (e) => {
            document.getElementById('moveRateVal').textContent = (e.target.value / 100).toFixed(2);
        });

        document.getElementById('error').addEventListener('input', (e) => {
            document.getElementById('errorVal').textContent = (e.target.value / 100).toFixed(2);
        });

        document.getElementById('interference').addEventListener('input', (e) => {
            document.getElementById('interferenceVal').textContent = (e.target.value / 100).toFixed(2);
        });

        // Initialize
        function init() {
            setupCanvas(habitatCanvas, habitatCtx, 300);
            setupCanvas(distributionCanvas, distributionCtx, 200);
            setupCanvas(intakeCanvas, intakeCtx, 200);
            setupCanvas(dynamicsCanvas, dynamicsCtx, 180);
            setupCanvas(varianceCanvas, varianceCtx, 180);
            setupCanvas(detailCanvas, detailCtx, 120);

            initSimulation();
            drawHabitats();
            drawDistribution();
            drawIntake();
            drawDynamics();
            drawVariance();
            drawDetails();
            updateStats();
        }

        window.addEventListener('resize', () => {
            setupCanvas(habitatCanvas, habitatCtx, 300);
            setupCanvas(distributionCanvas, distributionCtx, 200);
            setupCanvas(intakeCanvas, intakeCtx, 200);
            setupCanvas(dynamicsCanvas, dynamicsCtx, 180);
            setupCanvas(varianceCanvas, varianceCtx, 180);
            setupCanvas(detailCanvas, detailCtx, 120);
            drawHabitats();
            drawDistribution();
            drawIntake();
            drawDynamics();
            drawVariance();
            drawDetails();
        });

        init();
    </script>
</body>
</html>
