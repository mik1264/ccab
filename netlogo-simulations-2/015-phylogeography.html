<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phylogeography Simulation</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        .back-link {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: var(--terracotta);
        }

        h1 {
            color: var(--dark-moss);
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .subtitle {
            color: var(--moss);
            font-size: 1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: var(--moss);
            font-size: 0.95em;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid var(--sage);
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            color: var(--dark-moss);
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group .value {
            text-align: right;
            font-size: 0.8em;
            color: var(--moss);
        }

        .control-group select {
            width: 100%;
            padding: 6px;
            border: 1px solid var(--sage);
            border-radius: 6px;
            font-size: 0.9em;
        }

        .button-group {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.3s;
        }

        .btn-primary {
            background: var(--sage);
            color: white;
        }

        .btn-primary:hover {
            background: var(--moss);
        }

        .btn-secondary {
            background: var(--earth);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--terracotta);
        }

        .btn-ice {
            background: #64B5F6;
            color: white;
        }

        .btn-warm {
            background: #FF7043;
            color: white;
        }

        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .viz-panel {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .viz-panel h3 {
            color: var(--moss);
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        canvas {
            width: 100%;
            border-radius: 8px;
            background: #1a1a2e;
        }

        .viz-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .stat-box {
            background: linear-gradient(135deg, var(--cream) 0%, white 100%);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            border-left: 3px solid var(--sage);
        }

        .stat-box.highlight {
            border-left-color: var(--terracotta);
        }

        .stat-box.success {
            border-left-color: #4CAF50;
        }

        .stat-box .label {
            font-size: 0.75em;
            color: var(--moss);
            margin-bottom: 4px;
        }

        .stat-box .value {
            font-size: 1.2em;
            font-weight: bold;
            color: var(--dark-moss);
        }

        .info-box {
            background: linear-gradient(135deg, #e3f2fd 0%, white 100%);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            font-size: 0.8em;
            color: var(--dark-moss);
        }

        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
            font-size: 0.8em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .climate-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 8px;
        }

        .climate-bar {
            flex: 1;
            height: 20px;
            background: linear-gradient(90deg, #64B5F6, #4CAF50, #FF7043);
            border-radius: 4px;
            position: relative;
        }

        .climate-marker {
            position: absolute;
            top: -5px;
            width: 10px;
            height: 30px;
            background: white;
            border: 2px solid #333;
            border-radius: 3px;
            transform: translateX(-50%);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">‚Üê Back to Simulations</a>
            <h1>Phylogeography Simulation</h1>
            <p class="subtitle">Gene Genealogies Across Geographic Space</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-section">
                    <h3>Geographic Setting</h3>
                    <div class="control-group">
                        <label>Landscape Type:</label>
                        <select id="landscapeType">
                            <option value="europe">European Glacial Refugia</option>
                            <option value="northamerica">North American Range</option>
                            <option value="island">Island Archipelago</option>
                            <option value="mountain">Mountain Refugia</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Grid Size: <span id="gridSizeVal">20</span></label>
                        <input type="range" id="gridSize" min="10" max="40" value="20">
                    </div>
                    <div class="control-group">
                        <label>Number of Refugia: <span id="numRefugiaVal">3</span></label>
                        <input type="range" id="numRefugia" min="1" max="6" value="3">
                    </div>
                </div>

                <div class="control-section">
                    <h3>Population Genetics</h3>
                    <div class="control-group">
                        <label>Effective Population Size: <span id="neVal">100</span></label>
                        <input type="range" id="ne" min="20" max="500" value="100" step="20">
                    </div>
                    <div class="control-group">
                        <label>Dispersal Rate: <span id="dispersalVal">0.10</span></label>
                        <input type="range" id="dispersal" min="1" max="40" value="10">
                    </div>
                    <div class="control-group">
                        <label>Mutation Rate (Œº): <span id="mutRateVal">0.001</span></label>
                        <input type="range" id="mutRate" min="1" max="50" value="10">
                    </div>
                </div>

                <div class="control-section">
                    <h3>Climate Dynamics</h3>
                    <div class="control-group">
                        <label>Climate State:</label>
                        <div class="climate-indicator">
                            <span>‚ùÑÔ∏è Glacial</span>
                            <div class="climate-bar">
                                <div class="climate-marker" id="climateMarker" style="left: 50%;"></div>
                            </div>
                            <span>üå°Ô∏è Warm</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Climate Cycle Period: <span id="climatePeriodVal">200</span></label>
                        <input type="range" id="climatePeriod" min="50" max="500" value="200" step="50">
                        <div class="value">generations</div>
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="button-group">
                    <button class="btn-ice" id="glacialBtn">Force Glacial</button>
                    <button class="btn-warm" id="warmBtn">Force Warm</button>
                </div>

                <div class="info-box">
                    <strong>Phylogeography:</strong><br>
                    Studies how historical events (glaciations, range expansions) shaped the geographic distribution of genetic diversity. Coalescent theory traces gene genealogies backward to common ancestors.
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-panel">
                    <h3>Geographic Distribution & Genetic Diversity</h3>
                    <canvas id="mapCanvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #2196F3;"></div>
                            <span>Refugia</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: linear-gradient(90deg, #00ff00, #ff0000);"></div>
                            <span>Genetic Diversity (low ‚Üí high)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(255,255,255,0.5);"></div>
                            <span>Glaciated (uninhabitable)</span>
                        </div>
                    </div>
                </div>

                <div class="viz-row">
                    <div class="viz-panel">
                        <h3>Coalescent Gene Tree</h3>
                        <canvas id="treeCanvas"></canvas>
                    </div>
                    <div class="viz-panel">
                        <h3>Isolation by Distance</h3>
                        <canvas id="ibdCanvas"></canvas>
                    </div>
                </div>

                <div class="viz-row">
                    <div class="viz-panel">
                        <h3>Population Size History (Skyline)</h3>
                        <canvas id="skylineCanvas"></canvas>
                    </div>
                    <div class="viz-panel">
                        <h3>Haplotype Network</h3>
                        <canvas id="networkCanvas"></canvas>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="label">Generation</div>
                        <div class="value" id="genStat">0</div>
                    </div>
                    <div class="stat-box highlight">
                        <div class="label">Occupied Cells</div>
                        <div class="value" id="occupiedStat">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Total Population</div>
                        <div class="value" id="popStat">0</div>
                    </div>
                    <div class="stat-box success">
                        <div class="label">Haplotypes</div>
                        <div class="value" id="haploStat">1</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Mean Diversity (œÄ)</div>
                        <div class="value" id="piStat">0.000</div>
                    </div>
                    <div class="stat-box">
                        <div class="label">Fst</div>
                        <div class="value" id="fstStat">0.000</div>
                    </div>
                </div>

                <div class="viz-panel">
                    <h3>Range Expansion History</h3>
                    <canvas id="historyCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const mapCanvas = document.getElementById('mapCanvas');
        const treeCanvas = document.getElementById('treeCanvas');
        const ibdCanvas = document.getElementById('ibdCanvas');
        const skylineCanvas = document.getElementById('skylineCanvas');
        const networkCanvas = document.getElementById('networkCanvas');
        const historyCanvas = document.getElementById('historyCanvas');

        const mapCtx = mapCanvas.getContext('2d');
        const treeCtx = treeCanvas.getContext('2d');
        const ibdCtx = ibdCanvas.getContext('2d');
        const skylineCtx = skylineCanvas.getContext('2d');
        const networkCtx = networkCanvas.getContext('2d');
        const historyCtx = historyCanvas.getContext('2d');

        // Parameters
        let landscapeType = 'europe';
        let gridSize = 20;
        let numRefugia = 3;
        let ne = 100;
        let dispersal = 0.10;
        let mutRate = 0.001;
        let climatePeriod = 200;

        // State
        let grid = [];  // 2D array of cells, each with population and genetics
        let refugia = [];
        let generation = 0;
        let climate = 0.5;  // 0 = full glacial, 1 = full warm
        let forcedClimate = null;
        let haplotypeIdCounter = 1;
        let haplotypes = new Map();  // id -> { sequence, count, positions }
        let popHistory = [];
        let diversityHistory = [];
        let running = false;
        let animationId = null;

        function setupCanvas(canvas, ctx, height) {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = (rect.width - 30) * dpr;
            canvas.height = height * dpr;
            canvas.style.width = (rect.width - 30) + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(dpr, dpr);
        }

        function generateRefugia() {
            refugia = [];

            if (landscapeType === 'europe') {
                // Iberian, Italian, Balkan peninsulas
                const peninsulas = [
                    { x: 0.1, y: 0.8, name: 'Iberia' },
                    { x: 0.4, y: 0.85, name: 'Italy' },
                    { x: 0.7, y: 0.75, name: 'Balkans' }
                ];
                for (let i = 0; i < Math.min(numRefugia, peninsulas.length); i++) {
                    refugia.push({
                        x: Math.floor(peninsulas[i].x * gridSize),
                        y: Math.floor(peninsulas[i].y * gridSize),
                        name: peninsulas[i].name
                    });
                }
            } else if (landscapeType === 'northamerica') {
                // Southern refugia
                const positions = [
                    { x: 0.2, y: 0.8 },
                    { x: 0.5, y: 0.9 },
                    { x: 0.8, y: 0.85 }
                ];
                for (let i = 0; i < numRefugia; i++) {
                    const pos = positions[i % positions.length];
                    refugia.push({
                        x: Math.floor(pos.x * gridSize),
                        y: Math.floor(pos.y * gridSize),
                        name: `Refugium ${i + 1}`
                    });
                }
            } else if (landscapeType === 'island') {
                // Random islands
                for (let i = 0; i < numRefugia; i++) {
                    refugia.push({
                        x: Math.floor((0.2 + Math.random() * 0.6) * gridSize),
                        y: Math.floor((0.2 + Math.random() * 0.6) * gridSize),
                        name: `Island ${i + 1}`
                    });
                }
            } else {
                // Mountain refugia - high elevation areas
                for (let i = 0; i < numRefugia; i++) {
                    refugia.push({
                        x: Math.floor((0.3 + Math.random() * 0.4) * gridSize),
                        y: Math.floor((0.3 + Math.random() * 0.4) * gridSize),
                        name: `Mountain ${i + 1}`
                    });
                }
            }
        }

        function isHabitable(x, y) {
            // Check if cell is habitable given current climate
            // During glacial periods, only refugia are habitable
            // During warm periods, all cells are habitable

            // Check if in refugium
            const inRefugium = refugia.some(r =>
                Math.abs(r.x - x) <= 2 && Math.abs(r.y - y) <= 2
            );

            if (inRefugium) return true;

            // Distance from refugia - expansion allowed in warm periods
            const minDistToRefugium = Math.min(...refugia.map(r =>
                Math.sqrt(Math.pow(r.x - x, 2) + Math.pow(r.y - y, 2))
            ));

            // Expansion front based on climate
            const expansionRadius = climate * gridSize * 0.7;
            return minDistToRefugium <= expansionRadius;
        }

        function initGrid() {
            grid = [];
            haplotypes.clear();
            haplotypeIdCounter = 1;
            generation = 0;
            climate = 0.5;
            popHistory = [];
            diversityHistory = [];

            generateRefugia();

            // Create founding haplotype
            const foundingHaplotype = {
                id: haplotypeIdCounter++,
                sequence: new Array(10).fill(0),
                mutations: []
            };
            haplotypes.set(foundingHaplotype.id, foundingHaplotype);

            // Initialize grid
            for (let y = 0; y < gridSize; y++) {
                grid[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    const inRefugium = refugia.some(r =>
                        Math.abs(r.x - x) <= 1 && Math.abs(r.y - y) <= 1
                    );

                    grid[y][x] = {
                        population: inRefugium ? ne : 0,
                        haplotypeCounts: inRefugium ? { [foundingHaplotype.id]: ne } : {},
                        diversity: 0
                    };
                }
            }
        }

        function mutate(haplotypeId) {
            const parent = haplotypes.get(haplotypeId);
            if (!parent) return haplotypeId;

            if (Math.random() < mutRate) {
                // Create new haplotype
                const newSequence = [...parent.sequence];
                const mutPos = Math.floor(Math.random() * newSequence.length);
                newSequence[mutPos] = (newSequence[mutPos] + 1) % 4;

                const newHaplotype = {
                    id: haplotypeIdCounter++,
                    sequence: newSequence,
                    parentId: haplotypeId,
                    originGen: generation,
                    mutations: [...parent.mutations, { pos: mutPos, gen: generation }]
                };
                haplotypes.set(newHaplotype.id, newHaplotype);
                return newHaplotype.id;
            }

            return haplotypeId;
        }

        function getHaplotypeDistance(h1Id, h2Id) {
            const h1 = haplotypes.get(h1Id);
            const h2 = haplotypes.get(h2Id);
            if (!h1 || !h2) return 0;

            let dist = 0;
            for (let i = 0; i < h1.sequence.length; i++) {
                if (h1.sequence[i] !== h2.sequence[i]) dist++;
            }
            return dist;
        }

        function updateClimate() {
            if (forcedClimate !== null) {
                climate = forcedClimate;
                return;
            }

            // Sinusoidal climate oscillation
            climate = 0.5 + 0.4 * Math.sin(generation * 2 * Math.PI / climatePeriod);
            climate = Math.max(0.1, Math.min(0.9, climate));

            // Update climate indicator
            const marker = document.getElementById('climateMarker');
            marker.style.left = (climate * 100) + '%';
        }

        function reproduce() {
            const newGrid = grid.map(row => row.map(cell => ({
                population: 0,
                haplotypeCounts: {},
                diversity: 0
            })));

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const cell = grid[y][x];
                    if (cell.population === 0) continue;

                    // Get habitable neighbors
                    const neighbors = [];
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                                if (isHabitable(nx, ny)) {
                                    neighbors.push({ x: nx, y: ny, isSelf: dx === 0 && dy === 0 });
                                }
                            }
                        }
                    }

                    if (neighbors.length === 0) continue;

                    // Reproduce and disperse
                    for (const [hapId, count] of Object.entries(cell.haplotypeCounts)) {
                        const numHapId = parseInt(hapId);
                        for (let i = 0; i < count; i++) {
                            // Determine destination
                            let destX = x, destY = y;
                            if (Math.random() < dispersal) {
                                const dest = neighbors[Math.floor(Math.random() * neighbors.length)];
                                destX = dest.x;
                                destY = dest.y;
                            }

                            // Check if destination is habitable and has room
                            if (!isHabitable(destX, destY)) continue;
                            if (newGrid[destY][destX].population >= ne * 1.5) continue;

                            // Reproduce with possible mutation
                            const offspringHap = mutate(numHapId);
                            newGrid[destY][destX].population++;
                            newGrid[destY][destX].haplotypeCounts[offspringHap] =
                                (newGrid[destY][destX].haplotypeCounts[offspringHap] || 0) + 1;
                        }
                    }
                }
            }

            // Apply carrying capacity
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (newGrid[y][x].population > ne) {
                        const excess = newGrid[y][x].population - ne;
                        const hapIds = Object.keys(newGrid[y][x].haplotypeCounts);

                        for (let i = 0; i < excess && hapIds.length > 0; i++) {
                            const hapId = hapIds[Math.floor(Math.random() * hapIds.length)];
                            newGrid[y][x].haplotypeCounts[hapId]--;
                            newGrid[y][x].population--;
                            if (newGrid[y][x].haplotypeCounts[hapId] <= 0) {
                                delete newGrid[y][x].haplotypeCounts[hapId];
                                hapIds.splice(hapIds.indexOf(hapId), 1);
                            }
                        }
                    }
                }
            }

            // Contract during glacial periods
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (!isHabitable(x, y)) {
                        newGrid[y][x].population = 0;
                        newGrid[y][x].haplotypeCounts = {};
                    }
                }
            }

            grid = newGrid;
        }

        function calculateDiversity() {
            // Calculate within-cell diversity
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const cell = grid[y][x];
                    if (cell.population < 2) {
                        cell.diversity = 0;
                        continue;
                    }

                    // Calculate average pairwise differences
                    const hapIds = Object.keys(cell.haplotypeCounts).map(Number);
                    let totalDiff = 0;
                    let pairs = 0;

                    for (let i = 0; i < hapIds.length; i++) {
                        for (let j = i + 1; j < hapIds.length; j++) {
                            const dist = getHaplotypeDistance(hapIds[i], hapIds[j]);
                            const count = cell.haplotypeCounts[hapIds[i]] * cell.haplotypeCounts[hapIds[j]];
                            totalDiff += dist * count;
                            pairs += count;
                        }
                    }

                    cell.diversity = pairs > 0 ? totalDiff / pairs : 0;
                }
            }
        }

        function step() {
            updateClimate();
            reproduce();
            calculateDiversity();
            generation++;

            // Record history
            let totalPop = 0;
            let totalDiversity = 0;
            let occupiedCells = 0;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    totalPop += grid[y][x].population;
                    if (grid[y][x].population > 0) {
                        occupiedCells++;
                        totalDiversity += grid[y][x].diversity;
                    }
                }
            }

            popHistory.push({ gen: generation, pop: totalPop, occupied: occupiedCells });
            diversityHistory.push({
                gen: generation,
                diversity: occupiedCells > 0 ? totalDiversity / occupiedCells : 0
            });

            if (popHistory.length > 500) {
                popHistory = popHistory.filter((_, i) => i % 2 === 0);
                diversityHistory = diversityHistory.filter((_, i) => i % 2 === 0);
            }
        }

        function drawMap() {
            const width = mapCanvas.width / (window.devicePixelRatio || 1);
            const height = mapCanvas.height / (window.devicePixelRatio || 1);

            mapCtx.fillStyle = '#1a1a2e';
            mapCtx.fillRect(0, 0, width, height);

            const cellWidth = (width - 40) / gridSize;
            const cellHeight = (height - 40) / gridSize;
            const padding = 20;

            // Find max population and diversity for scaling
            let maxPop = ne;
            let maxDiv = 1;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    maxPop = Math.max(maxPop, grid[y][x].population);
                    maxDiv = Math.max(maxDiv, grid[y][x].diversity);
                }
            }

            // Draw cells
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const cell = grid[y][x];
                    const cx = padding + x * cellWidth;
                    const cy = padding + y * cellHeight;

                    // Check habitability
                    const habitable = isHabitable(x, y);

                    if (!habitable) {
                        // Glaciated/uninhabitable
                        mapCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    } else if (cell.population === 0) {
                        // Empty but habitable
                        mapCtx.fillStyle = 'rgba(100, 100, 100, 0.3)';
                    } else {
                        // Color by diversity
                        const divRatio = cell.diversity / maxDiv;
                        const hue = (1 - divRatio) * 120;  // Green (low) to red (high)
                        const saturation = 70;
                        const lightness = 30 + (cell.population / maxPop) * 30;
                        mapCtx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    }

                    mapCtx.fillRect(cx, cy, cellWidth - 1, cellHeight - 1);
                }
            }

            // Draw refugia markers
            for (const ref of refugia) {
                const cx = padding + ref.x * cellWidth + cellWidth / 2;
                const cy = padding + ref.y * cellHeight + cellHeight / 2;

                mapCtx.strokeStyle = '#2196F3';
                mapCtx.lineWidth = 2;
                mapCtx.beginPath();
                mapCtx.arc(cx, cy, Math.min(cellWidth, cellHeight) * 1.5, 0, Math.PI * 2);
                mapCtx.stroke();

                mapCtx.fillStyle = '#2196F3';
                mapCtx.font = '10px sans-serif';
                mapCtx.textAlign = 'center';
                mapCtx.fillText(ref.name, cx, cy - Math.min(cellWidth, cellHeight) * 2);
            }

            // Climate indicator
            mapCtx.fillStyle = '#ffffffaa';
            mapCtx.font = '11px sans-serif';
            mapCtx.textAlign = 'left';
            const climateText = climate < 0.3 ? '‚ùÑÔ∏è Glacial Maximum' :
                               climate > 0.7 ? 'üå°Ô∏è Interglacial' : 'üå§Ô∏è Transitional';
            mapCtx.fillText(climateText, padding, height - 5);
        }

        function drawTree() {
            const width = treeCanvas.width / (window.devicePixelRatio || 1);
            const height = treeCanvas.height / (window.devicePixelRatio || 1);

            treeCtx.fillStyle = '#1a1a2e';
            treeCtx.fillRect(0, 0, width, height);

            const padding = 30;

            // Get extant haplotypes
            const extantHaps = new Set();
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    for (const hapId of Object.keys(grid[y][x].haplotypeCounts)) {
                        extantHaps.add(parseInt(hapId));
                    }
                }
            }

            if (extantHaps.size === 0) return;

            const extantArray = Array.from(extantHaps);
            const tipSpacing = (height - 2 * padding) / (extantArray.length + 1);

            // Simple coalescent visualization - connect tips to ancestors
            treeCtx.strokeStyle = '#4CAF50';
            treeCtx.lineWidth = 1;

            extantArray.forEach((hapId, i) => {
                const tipY = padding + (i + 1) * tipSpacing;
                const tipX = width - padding;

                const hap = haplotypes.get(hapId);
                if (!hap) return;

                // Draw lineage back to origin
                let currentHap = hap;
                let currentX = tipX;

                while (currentHap) {
                    const originX = padding + ((currentHap.originGen || 0) / Math.max(generation, 1)) * (width - 2 * padding);

                    treeCtx.beginPath();
                    treeCtx.moveTo(currentX, tipY);
                    treeCtx.lineTo(originX, tipY);
                    treeCtx.stroke();

                    // Mark mutations
                    if (currentHap.mutations) {
                        for (const mut of currentHap.mutations) {
                            const mutX = padding + (mut.gen / Math.max(generation, 1)) * (width - 2 * padding);
                            treeCtx.fillStyle = '#FFC107';
                            treeCtx.beginPath();
                            treeCtx.arc(mutX, tipY, 3, 0, Math.PI * 2);
                            treeCtx.fill();
                        }
                    }

                    currentX = originX;
                    currentHap = currentHap.parentId ? haplotypes.get(currentHap.parentId) : null;
                }

                // Tip marker
                treeCtx.fillStyle = '#4CAF50';
                treeCtx.beginPath();
                treeCtx.arc(tipX, tipY, 4, 0, Math.PI * 2);
                treeCtx.fill();
            });

            treeCtx.fillStyle = '#ffffffaa';
            treeCtx.font = '10px sans-serif';
            treeCtx.fillText('Past', padding, padding - 10);
            treeCtx.textAlign = 'right';
            treeCtx.fillText('Present', width - padding, padding - 10);
        }

        function drawIBD() {
            const width = ibdCanvas.width / (window.devicePixelRatio || 1);
            const height = ibdCanvas.height / (window.devicePixelRatio || 1);

            ibdCtx.fillStyle = '#1a1a2e';
            ibdCtx.fillRect(0, 0, width, height);

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            // Collect data points
            const points = [];
            const occupiedCells = [];

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x].population > 0) {
                        occupiedCells.push({ x, y, cell: grid[y][x] });
                    }
                }
            }

            // Sample pairwise comparisons
            const maxPairs = 100;
            for (let i = 0; i < Math.min(occupiedCells.length, maxPairs); i++) {
                const c1 = occupiedCells[i];
                for (let j = i + 1; j < Math.min(occupiedCells.length, maxPairs); j++) {
                    const c2 = occupiedCells[j];

                    const geoDist = Math.sqrt(Math.pow(c1.x - c2.x, 2) + Math.pow(c1.y - c2.y, 2));

                    // Calculate average genetic distance
                    let totalGenDist = 0;
                    let pairs = 0;
                    for (const h1 of Object.keys(c1.cell.haplotypeCounts)) {
                        for (const h2 of Object.keys(c2.cell.haplotypeCounts)) {
                            totalGenDist += getHaplotypeDistance(parseInt(h1), parseInt(h2));
                            pairs++;
                        }
                    }
                    const genDist = pairs > 0 ? totalGenDist / pairs : 0;

                    points.push({ geo: geoDist, gen: genDist });
                }
            }

            if (points.length === 0) return;

            const maxGeo = Math.max(...points.map(p => p.geo));
            const maxGen = Math.max(...points.map(p => p.gen), 1);

            // Draw points
            ibdCtx.fillStyle = '#4CAF5088';
            for (const point of points) {
                const x = padding + (point.geo / maxGeo) * graphWidth;
                const y = height - padding - (point.gen / maxGen) * graphHeight;

                ibdCtx.beginPath();
                ibdCtx.arc(x, y, 2, 0, Math.PI * 2);
                ibdCtx.fill();
            }

            // Axes
            ibdCtx.strokeStyle = '#ffffff44';
            ibdCtx.beginPath();
            ibdCtx.moveTo(padding, padding);
            ibdCtx.lineTo(padding, height - padding);
            ibdCtx.lineTo(width - padding, height - padding);
            ibdCtx.stroke();

            ibdCtx.fillStyle = '#ffffffaa';
            ibdCtx.font = '10px sans-serif';
            ibdCtx.fillText('Genetic Distance', 5, height / 2);
            ibdCtx.textAlign = 'center';
            ibdCtx.fillText('Geographic Distance', width / 2, height - 5);
        }

        function drawSkyline() {
            const width = skylineCanvas.width / (window.devicePixelRatio || 1);
            const height = skylineCanvas.height / (window.devicePixelRatio || 1);

            skylineCtx.fillStyle = '#1a1a2e';
            skylineCtx.fillRect(0, 0, width, height);

            if (popHistory.length < 2) return;

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            const maxGen = popHistory[popHistory.length - 1].gen;
            const maxPop = Math.max(...popHistory.map(p => p.pop));

            // Draw population size
            skylineCtx.strokeStyle = '#4CAF50';
            skylineCtx.lineWidth = 2;
            skylineCtx.beginPath();

            popHistory.forEach((point, i) => {
                const x = padding + (point.gen / maxGen) * graphWidth;
                const y = height - padding - (point.pop / maxPop) * graphHeight;

                if (i === 0) {
                    skylineCtx.moveTo(x, y);
                } else {
                    skylineCtx.lineTo(x, y);
                }
            });
            skylineCtx.stroke();

            // Axes
            skylineCtx.strokeStyle = '#ffffff44';
            skylineCtx.beginPath();
            skylineCtx.moveTo(padding, padding);
            skylineCtx.lineTo(padding, height - padding);
            skylineCtx.lineTo(width - padding, height - padding);
            skylineCtx.stroke();

            skylineCtx.fillStyle = '#ffffffaa';
            skylineCtx.font = '10px sans-serif';
            skylineCtx.fillText('Ne', padding - 15, padding + 10);
            skylineCtx.textAlign = 'center';
            skylineCtx.fillText('Time (generations)', width / 2, height - 5);
        }

        function drawNetwork() {
            const width = networkCanvas.width / (window.devicePixelRatio || 1);
            const height = networkCanvas.height / (window.devicePixelRatio || 1);

            networkCtx.fillStyle = '#1a1a2e';
            networkCtx.fillRect(0, 0, width, height);

            const padding = 30;

            // Get extant haplotypes
            const hapCounts = new Map();
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    for (const [hapId, count] of Object.entries(grid[y][x].haplotypeCounts)) {
                        hapCounts.set(parseInt(hapId), (hapCounts.get(parseInt(hapId)) || 0) + count);
                    }
                }
            }

            if (hapCounts.size === 0) return;

            // Position haplotypes in a circle
            const hapArray = Array.from(hapCounts.keys());
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 2 - padding - 20;

            const positions = new Map();
            hapArray.forEach((hapId, i) => {
                const angle = (i / hapArray.length) * Math.PI * 2;
                positions.set(hapId, {
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius
                });
            });

            // Draw connections
            networkCtx.strokeStyle = '#ffffff44';
            networkCtx.lineWidth = 1;

            for (let i = 0; i < hapArray.length; i++) {
                for (let j = i + 1; j < hapArray.length; j++) {
                    const dist = getHaplotypeDistance(hapArray[i], hapArray[j]);
                    if (dist <= 2) {  // Only connect close haplotypes
                        const p1 = positions.get(hapArray[i]);
                        const p2 = positions.get(hapArray[j]);

                        networkCtx.beginPath();
                        networkCtx.moveTo(p1.x, p1.y);
                        networkCtx.lineTo(p2.x, p2.y);
                        networkCtx.stroke();
                    }
                }
            }

            // Draw haplotypes
            const maxCount = Math.max(...hapCounts.values());

            for (const [hapId, count] of hapCounts) {
                const pos = positions.get(hapId);
                const size = 5 + (count / maxCount) * 15;

                // Color by sequence
                const hap = haplotypes.get(hapId);
                const hue = hap ? (hap.sequence.reduce((a, b) => a + b, 0) * 30) % 360 : 0;

                networkCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                networkCtx.beginPath();
                networkCtx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
                networkCtx.fill();
            }

            networkCtx.fillStyle = '#ffffffaa';
            networkCtx.font = '10px sans-serif';
            networkCtx.textAlign = 'center';
            networkCtx.fillText('Haplotype Network', width / 2, height - 5);
        }

        function drawHistory() {
            const width = historyCanvas.width / (window.devicePixelRatio || 1);
            const height = historyCanvas.height / (window.devicePixelRatio || 1);

            historyCtx.fillStyle = '#1a1a2e';
            historyCtx.fillRect(0, 0, width, height);

            if (popHistory.length < 2) return;

            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;

            const maxGen = popHistory[popHistory.length - 1].gen;
            const maxOccupied = gridSize * gridSize;

            // Draw occupied cells over time
            historyCtx.strokeStyle = '#2196F3';
            historyCtx.lineWidth = 2;
            historyCtx.beginPath();

            popHistory.forEach((point, i) => {
                const x = padding + (point.gen / maxGen) * graphWidth;
                const y = height - padding - (point.occupied / maxOccupied) * graphHeight;

                if (i === 0) {
                    historyCtx.moveTo(x, y);
                } else {
                    historyCtx.lineTo(x, y);
                }
            });
            historyCtx.stroke();

            // Draw diversity
            if (diversityHistory.length > 1) {
                const maxDiv = Math.max(...diversityHistory.map(d => d.diversity), 1);

                historyCtx.strokeStyle = '#FF7043';
                historyCtx.lineWidth = 2;
                historyCtx.beginPath();

                diversityHistory.forEach((point, i) => {
                    const x = padding + (point.gen / maxGen) * graphWidth;
                    const y = height - padding - (point.diversity / maxDiv) * graphHeight * 0.5;

                    if (i === 0) {
                        historyCtx.moveTo(x, y);
                    } else {
                        historyCtx.lineTo(x, y);
                    }
                });
                historyCtx.stroke();
            }

            // Axes
            historyCtx.strokeStyle = '#ffffff44';
            historyCtx.beginPath();
            historyCtx.moveTo(padding, padding);
            historyCtx.lineTo(padding, height - padding);
            historyCtx.lineTo(width - padding, height - padding);
            historyCtx.stroke();

            historyCtx.fillStyle = '#ffffffaa';
            historyCtx.font = '10px sans-serif';
            historyCtx.textAlign = 'left';
            historyCtx.fillStyle = '#2196F3';
            historyCtx.fillText('Range Size', padding + 5, padding + 15);
            historyCtx.fillStyle = '#FF7043';
            historyCtx.fillText('Diversity', padding + 5, padding + 30);
        }

        function updateStats() {
            let totalPop = 0;
            let occupiedCells = 0;
            let totalDiversity = 0;
            const allHaps = new Set();

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    totalPop += grid[y][x].population;
                    if (grid[y][x].population > 0) {
                        occupiedCells++;
                        totalDiversity += grid[y][x].diversity;
                        for (const hapId of Object.keys(grid[y][x].haplotypeCounts)) {
                            allHaps.add(parseInt(hapId));
                        }
                    }
                }
            }

            document.getElementById('genStat').textContent = generation;
            document.getElementById('occupiedStat').textContent = occupiedCells;
            document.getElementById('popStat').textContent = totalPop;
            document.getElementById('haploStat').textContent = allHaps.size;
            document.getElementById('piStat').textContent =
                occupiedCells > 0 ? (totalDiversity / occupiedCells).toFixed(3) : '0.000';

            // Calculate Fst (simplified)
            const fst = occupiedCells > 1 ? Math.min(1, allHaps.size / occupiedCells / 5) : 0;
            document.getElementById('fstStat').textContent = fst.toFixed(3);
        }

        function animate() {
            step();

            drawMap();
            drawTree();
            drawIBD();
            drawSkyline();
            drawNetwork();
            drawHistory();
            updateStats();

            if (running) {
                animationId = requestAnimationFrame(animate);
            }
        }

        function start() {
            if (!running) {
                running = true;
                document.getElementById('startBtn').textContent = 'Pause';
                animate();
            } else {
                running = false;
                document.getElementById('startBtn').textContent = 'Start';
                if (animationId) cancelAnimationFrame(animationId);
            }
        }

        function reset() {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            if (animationId) cancelAnimationFrame(animationId);
            forcedClimate = null;

            landscapeType = document.getElementById('landscapeType').value;
            gridSize = parseInt(document.getElementById('gridSize').value);
            numRefugia = parseInt(document.getElementById('numRefugia').value);
            ne = parseInt(document.getElementById('ne').value);
            dispersal = parseInt(document.getElementById('dispersal').value) / 100;
            mutRate = parseInt(document.getElementById('mutRate').value) / 10000;
            climatePeriod = parseInt(document.getElementById('climatePeriod').value);

            initGrid();
            drawMap();
            drawTree();
            drawIBD();
            drawSkyline();
            drawNetwork();
            drawHistory();
            updateStats();
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', start);
        document.getElementById('resetBtn').addEventListener('click', reset);

        document.getElementById('glacialBtn').addEventListener('click', () => {
            forcedClimate = 0.1;
        });

        document.getElementById('warmBtn').addEventListener('click', () => {
            forcedClimate = 0.9;
        });

        document.getElementById('gridSize').addEventListener('input', (e) => {
            document.getElementById('gridSizeVal').textContent = e.target.value;
        });

        document.getElementById('numRefugia').addEventListener('input', (e) => {
            document.getElementById('numRefugiaVal').textContent = e.target.value;
        });

        document.getElementById('ne').addEventListener('input', (e) => {
            document.getElementById('neVal').textContent = e.target.value;
        });

        document.getElementById('dispersal').addEventListener('input', (e) => {
            document.getElementById('dispersalVal').textContent = (e.target.value / 100).toFixed(2);
        });

        document.getElementById('mutRate').addEventListener('input', (e) => {
            document.getElementById('mutRateVal').textContent = (e.target.value / 10000).toFixed(4);
        });

        document.getElementById('climatePeriod').addEventListener('input', (e) => {
            document.getElementById('climatePeriodVal').textContent = e.target.value;
        });

        // Initialize
        function init() {
            setupCanvas(mapCanvas, mapCtx, 350);
            setupCanvas(treeCanvas, treeCtx, 180);
            setupCanvas(ibdCanvas, ibdCtx, 180);
            setupCanvas(skylineCanvas, skylineCtx, 180);
            setupCanvas(networkCanvas, networkCtx, 180);
            setupCanvas(historyCanvas, historyCtx, 150);

            initGrid();
            drawMap();
            drawTree();
            drawIBD();
            drawSkyline();
            drawNetwork();
            drawHistory();
            updateStats();
        }

        window.addEventListener('resize', () => {
            setupCanvas(mapCanvas, mapCtx, 350);
            setupCanvas(treeCanvas, treeCtx, 180);
            setupCanvas(ibdCanvas, ibdCtx, 180);
            setupCanvas(skylineCanvas, skylineCtx, 180);
            setupCanvas(networkCanvas, networkCtx, 180);
            setupCanvas(historyCanvas, historyCtx, 150);
            drawMap();
            drawTree();
            drawIBD();
            drawSkyline();
            drawNetwork();
            drawHistory();
        });

        init();
    </script>
</body>
</html>
