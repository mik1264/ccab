<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backpropagation Visualization - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 300px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #8b5cf6; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #8b5cf6; color: #fff; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { opacity: 0.9; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; margin-bottom: 10px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #8b5cf6; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .info { background: rgba(139,92,246,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; border-left: 3px solid #8b5cf6; }
        .legend { display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 5px; font-size: 0.7rem; }
        .legend-color { width: 12px; height: 12px; border-radius: 3px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <div id="canvas-container"><canvas id="canvas"></canvas></div>
        <div id="controls">
            <h1>Backpropagation</h1>
            <div class="control-group">
                <label>Learning Rate: <span id="lrValue">0.5</span></label>
                <input type="range" id="lr" min="0.01" max="2" step="0.01" value="0.5">
            </div>
            <div class="control-group">
                <label>Hidden Neurons: <span id="hiddenValue">4</span></label>
                <input type="range" id="hidden" min="2" max="8" step="1" value="4">
            </div>
            <button id="reset">Reset Network</button>
            <button id="step">Forward + Backward Step</button>
            <button id="train">Train (100 epochs)</button>
            <div class="stats">
                <div>Epoch: <span id="epoch">0</span></div>
                <div>Loss: <span id="loss">-</span></div>
                <div>Pattern: <span id="pattern">XOR</span></div>
            </div>
            <div class="info">
                <strong>Neural Network Training</strong><br><br>
                • Forward pass: compute activations<br>
                • Backward pass: compute gradients<br>
                • Update: adjust weights by gradients<br><br>
                <div class="legend">
                    <div class="legend-item"><div class="legend-color" style="background:#10b981"></div>Positive</div>
                    <div class="legend-item"><div class="legend-color" style="background:#ef4444"></div>Negative</div>
                    <div class="legend-item"><div class="legend-color" style="background:#8b5cf6"></div>Gradient flow</div>
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let params = { lr: 0.5, hiddenSize: 4 };
        let network = null;
        let epoch = 0;
        let currentSample = 0;
        let showGradients = false;
        
        // XOR training data
        const trainingData = [
            { inputs: [0, 0], target: [0] },
            { inputs: [0, 1], target: [1] },
            { inputs: [1, 0], target: [1] },
            { inputs: [1, 1], target: [0] }
        ];

        function resize() {
            canvas.width = document.getElementById('canvas-container').clientWidth;
            canvas.height = document.getElementById('canvas-container').clientHeight;
        }

        function sigmoid(x) {
            return 1 / (1 + Math.exp(-x));
        }

        function sigmoidDerivative(x) {
            return x * (1 - x);
        }

        function initNetwork() {
            const inputSize = 2;
            const hiddenSize = params.hiddenSize;
            const outputSize = 1;
            
            network = {
                layers: [
                    { size: inputSize, activations: new Array(inputSize).fill(0), gradients: new Array(inputSize).fill(0) },
                    { size: hiddenSize, activations: new Array(hiddenSize).fill(0), gradients: new Array(hiddenSize).fill(0) },
                    { size: outputSize, activations: new Array(outputSize).fill(0), gradients: new Array(outputSize).fill(0) }
                ],
                weights: [
                    // Input to hidden
                    Array(inputSize).fill(0).map(() => 
                        Array(hiddenSize).fill(0).map(() => (Math.random() - 0.5) * 2)
                    ),
                    // Hidden to output
                    Array(hiddenSize).fill(0).map(() => 
                        Array(outputSize).fill(0).map(() => (Math.random() - 0.5) * 2)
                    )
                ],
                biases: [
                    Array(hiddenSize).fill(0).map(() => (Math.random() - 0.5) * 0.5),
                    Array(outputSize).fill(0).map(() => (Math.random() - 0.5) * 0.5)
                ],
                weightGradients: [
                    Array(inputSize).fill(0).map(() => Array(hiddenSize).fill(0)),
                    Array(hiddenSize).fill(0).map(() => Array(outputSize).fill(0))
                ]
            };
            
            epoch = 0;
            currentSample = 0;
            showGradients = false;
        }

        function forward(inputs) {
            // Input layer
            for (let i = 0; i < inputs.length; i++) {
                network.layers[0].activations[i] = inputs[i];
            }
            
            // Hidden layer
            for (let j = 0; j < network.layers[1].size; j++) {
                let sum = network.biases[0][j];
                for (let i = 0; i < network.layers[0].size; i++) {
                    sum += network.layers[0].activations[i] * network.weights[0][i][j];
                }
                network.layers[1].activations[j] = sigmoid(sum);
            }
            
            // Output layer
            for (let k = 0; k < network.layers[2].size; k++) {
                let sum = network.biases[1][k];
                for (let j = 0; j < network.layers[1].size; j++) {
                    sum += network.layers[1].activations[j] * network.weights[1][j][k];
                }
                network.layers[2].activations[k] = sigmoid(sum);
            }
            
            return network.layers[2].activations;
        }

        function backward(target) {
            // Output layer error
            for (let k = 0; k < network.layers[2].size; k++) {
                const output = network.layers[2].activations[k];
                const error = target[k] - output;
                network.layers[2].gradients[k] = error * sigmoidDerivative(output);
            }
            
            // Hidden layer error (backpropagate)
            for (let j = 0; j < network.layers[1].size; j++) {
                let error = 0;
                for (let k = 0; k < network.layers[2].size; k++) {
                    error += network.layers[2].gradients[k] * network.weights[1][j][k];
                }
                network.layers[1].gradients[j] = error * sigmoidDerivative(network.layers[1].activations[j]);
            }
            
            // Compute weight gradients
            for (let i = 0; i < network.layers[0].size; i++) {
                for (let j = 0; j < network.layers[1].size; j++) {
                    network.weightGradients[0][i][j] = network.layers[0].activations[i] * network.layers[1].gradients[j];
                }
            }
            
            for (let j = 0; j < network.layers[1].size; j++) {
                for (let k = 0; k < network.layers[2].size; k++) {
                    network.weightGradients[1][j][k] = network.layers[1].activations[j] * network.layers[2].gradients[k];
                }
            }
        }

        function updateWeights() {
            // Update input-hidden weights
            for (let i = 0; i < network.layers[0].size; i++) {
                for (let j = 0; j < network.layers[1].size; j++) {
                    network.weights[0][i][j] += params.lr * network.weightGradients[0][i][j];
                }
            }
            
            // Update hidden biases
            for (let j = 0; j < network.layers[1].size; j++) {
                network.biases[0][j] += params.lr * network.layers[1].gradients[j];
            }
            
            // Update hidden-output weights
            for (let j = 0; j < network.layers[1].size; j++) {
                for (let k = 0; k < network.layers[2].size; k++) {
                    network.weights[1][j][k] += params.lr * network.weightGradients[1][j][k];
                }
            }
            
            // Update output biases
            for (let k = 0; k < network.layers[2].size; k++) {
                network.biases[1][k] += params.lr * network.layers[2].gradients[k];
            }
        }

        function trainStep() {
            const sample = trainingData[currentSample];
            forward(sample.inputs);
            backward(sample.target);
            showGradients = true;
            updateWeights();
            
            currentSample = (currentSample + 1) % trainingData.length;
            if (currentSample === 0) epoch++;
            
            updateStats();
        }

        function trainEpochs(n) {
            for (let e = 0; e < n; e++) {
                for (const sample of trainingData) {
                    forward(sample.inputs);
                    backward(sample.target);
                    updateWeights();
                }
                epoch++;
            }
            showGradients = false;
            
            // Show last sample
            forward(trainingData[0].inputs);
            updateStats();
        }

        function calculateLoss() {
            let totalLoss = 0;
            for (const sample of trainingData) {
                const output = forward(sample.inputs);
                for (let k = 0; k < sample.target.length; k++) {
                    totalLoss += Math.pow(sample.target[k] - output[k], 2);
                }
            }
            return totalLoss / trainingData.length;
        }

        function updateStats() {
            document.getElementById('epoch').textContent = epoch;
            document.getElementById('loss').textContent = calculateLoss().toFixed(4);
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const w = canvas.width - 350;
            const h = canvas.height;
            const layerSpacing = w / 4;
            const startX = 100;
            
            // Calculate neuron positions
            const positions = network.layers.map((layer, l) => {
                const x = startX + l * layerSpacing;
                const neuronSpacing = Math.min(80, (h - 100) / (layer.size + 1));
                const startY = (h - neuronSpacing * (layer.size - 1)) / 2;
                
                return Array(layer.size).fill(0).map((_, i) => ({
                    x, y: startY + i * neuronSpacing
                }));
            });
            
            // Draw connections with weights
            for (let l = 0; l < network.weights.length; l++) {
                for (let i = 0; i < network.weights[l].length; i++) {
                    for (let j = 0; j < network.weights[l][i].length; j++) {
                        const weight = network.weights[l][i][j];
                        const gradient = network.weightGradients[l][i][j];
                        
                        const from = positions[l][i];
                        const to = positions[l + 1][j];
                        
                        // Draw weight connection
                        ctx.beginPath();
                        ctx.moveTo(from.x + 20, from.y);
                        ctx.lineTo(to.x - 20, to.y);
                        
                        const weightColor = weight > 0 ? '#10b981' : '#ef4444';
                        ctx.strokeStyle = weightColor;
                        ctx.lineWidth = Math.min(5, Math.abs(weight) * 2);
                        ctx.globalAlpha = 0.4 + Math.min(0.6, Math.abs(weight) * 0.3);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                        
                        // Draw gradient flow
                        if (showGradients && Math.abs(gradient) > 0.001) {
                            const midX = (from.x + to.x) / 2;
                            const midY = (from.y + to.y) / 2;
                            
                            ctx.beginPath();
                            ctx.arc(midX, midY, Math.min(10, Math.abs(gradient) * 50), 0, Math.PI * 2);
                            ctx.fillStyle = '#8b5cf6';
                            ctx.globalAlpha = 0.7;
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                    }
                }
            }
            
            // Draw neurons
            for (let l = 0; l < network.layers.length; l++) {
                for (let i = 0; i < network.layers[l].size; i++) {
                    const pos = positions[l][i];
                    const activation = network.layers[l].activations[i];
                    const gradient = network.layers[l].gradients[i];
                    
                    // Neuron circle
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 20, 0, Math.PI * 2);
                    
                    // Fill based on activation
                    const intensity = Math.floor(activation * 255);
                    ctx.fillStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
                    ctx.fill();
                    
                    ctx.strokeStyle = '#8b5cf6';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Show activation value
                    ctx.fillStyle = activation > 0.5 ? '#000' : '#fff';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(activation.toFixed(2), pos.x, pos.y);
                    
                    // Show gradient
                    if (showGradients && l > 0 && Math.abs(gradient) > 0.001) {
                        ctx.fillStyle = gradient > 0 ? '#10b981' : '#ef4444';
                        ctx.font = '9px sans-serif';
                        ctx.fillText((gradient > 0 ? '+' : '') + gradient.toFixed(3), pos.x, pos.y + 30);
                    }
                }
            }
            
            // Layer labels
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Input', positions[0][0].x, 30);
            ctx.fillText('Hidden', positions[1][0].x, 30);
            ctx.fillText('Output', positions[2][0].x, 30);
            
            // Draw XOR truth table
            ctx.fillStyle = '#666';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            let tableY = h - 120;
            ctx.fillText('XOR Truth Table:', 20, tableY);
            tableY += 20;
            
            for (const sample of trainingData) {
                const output = forward(sample.inputs);
                const correct = Math.abs(output[0] - sample.target[0]) < 0.3;
                ctx.fillStyle = correct ? '#10b981' : '#ef4444';
                ctx.fillText(
                    `${sample.inputs[0]} XOR ${sample.inputs[1]} = ${sample.target[0]} (pred: ${output[0].toFixed(2)})`,
                    20, tableY
                );
                tableY += 18;
            }
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        document.getElementById('lr').addEventListener('input', e => {
            params.lr = parseFloat(e.target.value);
            document.getElementById('lrValue').textContent = params.lr;
        });

        document.getElementById('hidden').addEventListener('input', e => {
            params.hiddenSize = parseInt(e.target.value);
            document.getElementById('hiddenValue').textContent = params.hiddenSize;
            initNetwork();
        });

        document.getElementById('reset').addEventListener('click', initNetwork);
        document.getElementById('step').addEventListener('click', trainStep);
        document.getElementById('train').addEventListener('click', () => trainEpochs(100));

        window.addEventListener('resize', resize);

        resize();
        initNetwork();
        forward(trainingData[0].inputs);
        requestAnimationFrame(animate);
    </script>
</body>
</html>
