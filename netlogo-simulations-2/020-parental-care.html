<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parental Care Evolution - NetLogo Simulation</title>
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #f5f5dc 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            color: var(--dark-moss);
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .subtitle {
            color: var(--moss);
            font-size: 1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .control-group {
            margin-bottom: 18px;
        }

        .control-group label {
            display: block;
            color: var(--dark-moss);
            font-weight: 600;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--sage);
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            border: 2px solid var(--sage);
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .value-display {
            text-align: right;
            color: var(--moss);
            font-size: 0.8rem;
            margin-top: 3px;
        }

        .buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 80px;
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--sage);
            color: white;
        }

        .btn-primary:hover {
            background: var(--moss);
        }

        .btn-secondary {
            background: var(--earth);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--terracotta);
        }

        .visualization-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 15px;
        }

        .viz-panel {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .viz-panel h3 {
            color: var(--dark-moss);
            font-size: 0.9rem;
            margin-bottom: 10px;
            text-align: center;
        }

        canvas {
            width: 100%;
            height: 250px;
            border-radius: 8px;
            background: #1a1a2e;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 15px;
        }

        .stat-item {
            background: var(--cream);
            padding: 8px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--terracotta);
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--moss);
        }

        .info-box {
            background: linear-gradient(135deg, var(--cream) 0%, #fff 100%);
            border-left: 4px solid var(--sage);
            padding: 12px;
            margin-top: 15px;
            border-radius: 0 8px 8px 0;
            font-size: 0.8rem;
            color: var(--dark-moss);
        }

        .back-link {
            display: inline-block;
            margin-bottom: 15px;
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
        }

        .back-link:hover {
            color: var(--terracotta);
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Simulations</a>

        <header>
            <h1>Parental Care Evolution</h1>
            <p class="subtitle">Sexual Conflict, Negotiation, and ESS Care Patterns</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-group">
                    <label>Population Size (Pairs)</label>
                    <input type="range" id="popSize" min="20" max="80" value="40">
                    <div class="value-display" id="popSizeVal">40 pairs</div>
                </div>

                <div class="control-group">
                    <label>Offspring Survival Benefit</label>
                    <input type="range" id="careBenefit" min="10" max="90" value="60">
                    <div class="value-display" id="careBenefitVal">60%</div>
                </div>

                <div class="control-group">
                    <label>Care Cost to Parent</label>
                    <input type="range" id="careCost" min="5" max="50" value="20">
                    <div class="value-display" id="careCostVal">20%</div>
                </div>

                <div class="control-group">
                    <label>Remating Opportunity</label>
                    <input type="range" id="rematingOpp" min="0" max="100" value="50">
                    <div class="value-display" id="rematingOppVal">50%</div>
                </div>

                <div class="control-group">
                    <label>Paternity Certainty</label>
                    <input type="range" id="paternity" min="50" max="100" value="80">
                    <div class="value-display" id="paternityVal">80%</div>
                </div>

                <div class="control-group">
                    <label>Negotiation Responsiveness</label>
                    <input type="range" id="negotiation" min="0" max="100" value="50">
                    <div class="value-display" id="negotiationVal">50%</div>
                </div>

                <div class="control-group">
                    <label>Initial Male Care</label>
                    <input type="range" id="initMaleCare" min="0" max="100" value="50">
                    <div class="value-display" id="initMaleCareVal">50%</div>
                </div>

                <div class="control-group">
                    <label>Care Pattern Model</label>
                    <select id="careModel">
                        <option value="negotiation">Negotiation Model</option>
                        <option value="sealed_bid">Sealed Bid (Houston-Davies)</option>
                        <option value="response">Response to Partner</option>
                    </select>
                </div>

                <div class="buttons">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="biparentalFreq">0%</div>
                        <div class="stat-label">Biparental</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="femaleOnlyFreq">0%</div>
                        <div class="stat-label">Female Only</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="maleOnlyFreq">0%</div>
                        <div class="stat-label">Male Only</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="desertionFreq">0%</div>
                        <div class="stat-label">Desertion</div>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Sexual Conflict:</strong> Parents negotiate care levels. ESS depends on
                    care benefits vs. remating costs. Partial compensation when partner reduces effort
                    stabilizes biparental care.
                </div>
            </div>

            <div class="visualization-area">
                <div class="viz-panel">
                    <h3>Pair Interactions</h3>
                    <canvas id="arenaCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Care Strategy Evolution</h3>
                    <canvas id="strategyCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>Offspring Survival vs Total Care</h3>
                    <canvas id="survivalCanvas"></canvas>
                </div>

                <div class="viz-panel">
                    <h3>ESS Landscape (Male vs Female Care)</h3>
                    <canvas id="essCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const arenaCanvas = document.getElementById('arenaCanvas');
        const strategyCanvas = document.getElementById('strategyCanvas');
        const survivalCanvas = document.getElementById('survivalCanvas');
        const essCanvas = document.getElementById('essCanvas');

        const arenaCtx = arenaCanvas.getContext('2d');
        const strategyCtx = strategyCanvas.getContext('2d');
        const survivalCtx = survivalCanvas.getContext('2d');
        const essCtx = essCanvas.getContext('2d');

        function resizeCanvases() {
            [arenaCanvas, strategyCanvas, survivalCanvas, essCanvas].forEach(canvas => {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                canvas.getContext('2d').scale(window.devicePixelRatio, window.devicePixelRatio);
            });
        }
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        // Simulation state
        let running = false;
        let tick = 0;
        let pairs = [];
        let strategyHistory = [];
        let survivalData = [];

        // Care patterns
        const BIPARENTAL = 'biparental';
        const FEMALE_ONLY = 'female_only';
        const MALE_ONLY = 'male_only';
        const NO_CARE = 'no_care';

        class BreedingPair {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.maleX = x - 15;
                this.maleY = y;
                this.femaleX = x + 15;
                this.femaleY = y;

                // Care effort (0-1)
                this.maleCare = parseFloat(document.getElementById('initMaleCare').value) / 100;
                this.femaleCare = 0.7 + Math.random() * 0.2;

                // Strategy tendencies (genetic)
                this.maleCareTendency = this.maleCare;
                this.femaleCareTendency = this.femaleCare;

                // Offspring
                this.numOffspring = Math.floor(Math.random() * 3) + 2;
                this.offspringSurvived = 0;

                // Fitness
                this.maleFitness = 0;
                this.femaleFitness = 0;

                // State
                this.breeding = true;
                this.carePhase = 0; // Care bout
                this.deserted = { male: false, female: false };
            }

            getPattern() {
                const mThresh = 0.2;
                const fThresh = 0.2;

                if (this.maleCare > mThresh && this.femaleCare > fThresh) return BIPARENTAL;
                if (this.maleCare <= mThresh && this.femaleCare > fThresh) return FEMALE_ONLY;
                if (this.maleCare > mThresh && this.femaleCare <= mThresh) return MALE_ONLY;
                return NO_CARE;
            }

            negotiate(params) {
                const model = params.careModel;

                if (model === 'sealed_bid') {
                    // Houston-Davies: each parent commits care based on own cost-benefit
                    // No response to partner
                    return;
                }

                if (model === 'response') {
                    // Simple response: partial compensation
                    const compensation = params.negotiation / 100;

                    // If partner reduces, slightly increase own effort
                    const maleDeficit = this.maleCareTendency - this.maleCare;
                    const femaleDeficit = this.femaleCareTendency - this.femaleCare;

                    // Female responds to male
                    if (maleDeficit > 0.1) {
                        this.femaleCare = Math.min(1, this.femaleCare + maleDeficit * compensation * 0.5);
                    }
                    // Male responds to female
                    if (femaleDeficit > 0.1) {
                        this.maleCare = Math.min(1, this.maleCare + femaleDeficit * compensation * 0.5);
                    }
                }

                if (model === 'negotiation') {
                    // Iterative negotiation
                    const responsiveness = params.negotiation / 100;

                    // Each parent adjusts based on offspring need and partner effort
                    const totalCare = this.maleCare + this.femaleCare;
                    const optimalCare = 1.2; // Optimal total care

                    if (totalCare < optimalCare) {
                        // Need more care - who increases?
                        // Weighted by current effort (who's slacking more relative to tendency)
                        const maleSlack = this.maleCareTendency - this.maleCare;
                        const femaleSlack = this.femaleCareTendency - this.femaleCare;

                        if (maleSlack > femaleSlack * 1.2) {
                            this.femaleCare = Math.min(1, this.femaleCare + 0.1 * responsiveness);
                        } else if (femaleSlack > maleSlack * 1.2) {
                            this.maleCare = Math.min(1, this.maleCare + 0.1 * responsiveness);
                        }
                    }
                }
            }

            evaluateDesertion(params) {
                // Male desertion decision
                const maleRematingGain = params.rematingOpp / 100;
                const paternityValue = params.paternity / 100;
                const careBenefit = params.careBenefit / 100;
                const careCost = params.careCost / 100;

                // Expected fitness from staying vs leaving
                const stayMaleFitness = this.numOffspring * careBenefit * paternityValue *
                    (this.maleCare + this.femaleCare * 0.5) - this.maleCare * careCost;
                const leaveMaleFitness = maleRematingGain * 0.5 +
                    this.numOffspring * careBenefit * paternityValue * this.femaleCare * 0.3;

                if (leaveMaleFitness > stayMaleFitness && Math.random() < 0.3) {
                    this.deserted.male = true;
                    this.maleCare = 0;
                }

                // Female desertion (rarer, depends on male care)
                const stayFemaleFitness = this.numOffspring * careBenefit *
                    (this.femaleCare + this.maleCare * 0.5) - this.femaleCare * careCost;
                const leaveFemaleFitness = maleRematingGain * 0.3 +
                    this.numOffspring * careBenefit * this.maleCare * 0.3;

                if (leaveFemaleFitness > stayFemaleFitness && this.maleCare > 0.5 && Math.random() < 0.1) {
                    this.deserted.female = true;
                    this.femaleCare = 0;
                }
            }

            update(params) {
                if (!this.breeding) return;

                this.carePhase++;

                // Negotiation phase
                if (this.carePhase < 20) {
                    this.negotiate(params);
                }

                // Desertion decisions
                if (this.carePhase === 10) {
                    this.evaluateDesertion(params);
                }

                // Calculate offspring survival
                if (this.carePhase === 30) {
                    const totalCare = this.maleCare + this.femaleCare;
                    const survivalProb = Math.min(0.95, totalCare * params.careBenefit / 100);

                    this.offspringSurvived = 0;
                    for (let i = 0; i < this.numOffspring; i++) {
                        if (Math.random() < survivalProb) {
                            this.offspringSurvived++;
                        }
                    }

                    // Calculate fitness
                    const careCost = params.careCost / 100;
                    this.maleFitness = this.offspringSurvived * (params.paternity / 100) -
                        this.maleCare * careCost * 10;
                    this.femaleFitness = this.offspringSurvived - this.femaleCare * careCost * 10;

                    // Remating bonus for deserters
                    if (this.deserted.male) {
                        this.maleFitness += params.rematingOpp / 100 * 3;
                    }
                    if (this.deserted.female) {
                        this.femaleFitness += params.rematingOpp / 100 * 2;
                    }

                    this.breeding = false;

                    // Record for plot
                    survivalData.push({
                        totalCare: totalCare,
                        survival: this.offspringSurvived / this.numOffspring
                    });
                    if (survivalData.length > 200) survivalData.shift();
                }

                // Animate positions (hovering near nest)
                this.maleX = this.x - 15 + Math.sin(tick * 0.1) * 5;
                this.maleY = this.y + Math.cos(tick * 0.15) * 3;
                this.femaleX = this.x + 15 + Math.sin(tick * 0.12 + 1) * 5;
                this.femaleY = this.y + Math.cos(tick * 0.1 + 2) * 3;

                if (this.deserted.male) {
                    this.maleX = this.x - 40 - tick * 0.2;
                }
                if (this.deserted.female) {
                    this.femaleX = this.x + 40 + tick * 0.2;
                }
            }
        }

        function initSimulation() {
            const popSize = parseInt(document.getElementById('popSize').value);
            pairs = [];
            tick = 0;
            strategyHistory = [];
            survivalData = [];

            const w = arenaCanvas.width / window.devicePixelRatio;
            const h = arenaCanvas.height / window.devicePixelRatio;

            // Create breeding pairs
            const cols = Math.ceil(Math.sqrt(popSize));
            const rows = Math.ceil(popSize / cols);
            const cellW = (w - 40) / cols;
            const cellH = (h - 40) / rows;

            for (let i = 0; i < popSize; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);
                const x = 20 + col * cellW + cellW / 2;
                const y = 20 + row * cellH + cellH / 2;

                pairs.push(new BreedingPair(x, y));
            }
        }

        function getParams() {
            return {
                careBenefit: parseInt(document.getElementById('careBenefit').value),
                careCost: parseInt(document.getElementById('careCost').value),
                rematingOpp: parseInt(document.getElementById('rematingOpp').value),
                paternity: parseInt(document.getElementById('paternity').value),
                negotiation: parseInt(document.getElementById('negotiation').value),
                careModel: document.getElementById('careModel').value
            };
        }

        function simulationStep() {
            const params = getParams();
            tick++;

            pairs.forEach(pair => pair.update(params));

            // New breeding season
            if (tick % 60 === 0) {
                evolvePopulation(params);
            }

            // Record strategy history
            if (tick % 5 === 0) {
                const patterns = pairs.map(p => p.getPattern());
                const biparental = patterns.filter(p => p === BIPARENTAL).length / pairs.length;
                const femaleOnly = patterns.filter(p => p === FEMALE_ONLY).length / pairs.length;
                const maleOnly = patterns.filter(p => p === MALE_ONLY).length / pairs.length;
                const noCare = patterns.filter(p => p === NO_CARE).length / pairs.length;

                strategyHistory.push({ biparental, femaleOnly, maleOnly, noCare });
                if (strategyHistory.length > 200) strategyHistory.shift();
            }

            updateStats();
        }

        function evolvePopulation(params) {
            // Sort by fitness
            const males = pairs.map(p => ({
                care: p.maleCareTendency,
                fitness: p.maleFitness
            })).sort((a, b) => b.fitness - a.fitness);

            const females = pairs.map(p => ({
                care: p.femaleCareTendency,
                fitness: p.femaleFitness
            })).sort((a, b) => b.fitness - a.fitness);

            // Create new generation
            const popSize = pairs.length;
            const w = arenaCanvas.width / window.devicePixelRatio;
            const h = arenaCanvas.height / window.devicePixelRatio;

            pairs = [];

            const cols = Math.ceil(Math.sqrt(popSize));
            const rows = Math.ceil(popSize / cols);
            const cellW = (w - 40) / cols;
            const cellH = (h - 40) / rows;

            for (let i = 0; i < popSize; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);
                const x = 20 + col * cellW + cellW / 2;
                const y = 20 + row * cellH + cellH / 2;

                const pair = new BreedingPair(x, y);

                // Select parents (fitness-weighted)
                const maleParent = selectParent(males);
                const femaleParent = selectParent(females);

                // Inherit care tendencies with mutation
                pair.maleCareTendency = Math.max(0, Math.min(1,
                    maleParent.care + (Math.random() - 0.5) * 0.1));
                pair.femaleCareTendency = Math.max(0, Math.min(1,
                    femaleParent.care + (Math.random() - 0.5) * 0.1));

                pair.maleCare = pair.maleCareTendency;
                pair.femaleCare = pair.femaleCareTendency;

                pairs.push(pair);
            }
        }

        function selectParent(sortedParents) {
            // Tournament selection
            const i1 = Math.floor(Math.random() * sortedParents.length);
            const i2 = Math.floor(Math.random() * sortedParents.length);
            return sortedParents[Math.min(i1, i2)];
        }

        function updateStats() {
            const patterns = pairs.map(p => p.getPattern());
            const total = pairs.length;

            document.getElementById('biparentalFreq').textContent =
                Math.round(patterns.filter(p => p === BIPARENTAL).length / total * 100) + '%';
            document.getElementById('femaleOnlyFreq').textContent =
                Math.round(patterns.filter(p => p === FEMALE_ONLY).length / total * 100) + '%';
            document.getElementById('maleOnlyFreq').textContent =
                Math.round(patterns.filter(p => p === MALE_ONLY).length / total * 100) + '%';
            document.getElementById('desertionFreq').textContent =
                Math.round(patterns.filter(p => p === NO_CARE).length / total * 100) + '%';
        }

        function draw() {
            drawArena();
            drawStrategyPlot();
            drawSurvivalPlot();
            drawESSLandscape();
        }

        function drawArena() {
            const w = arenaCanvas.width / window.devicePixelRatio;
            const h = arenaCanvas.height / window.devicePixelRatio;

            arenaCtx.fillStyle = '#1a1a2e';
            arenaCtx.fillRect(0, 0, w, h);

            pairs.forEach(pair => {
                // Draw nest
                arenaCtx.fillStyle = '#8B4513';
                arenaCtx.beginPath();
                arenaCtx.ellipse(pair.x, pair.y, 12, 8, 0, 0, Math.PI * 2);
                arenaCtx.fill();

                // Draw offspring
                const offspringColor = pair.breeding ?
                    `rgba(255, 255, 200, ${0.3 + pair.carePhase / 60})` :
                    pair.offspringSurvived > 0 ? '#90EE90' : '#666';
                arenaCtx.fillStyle = offspringColor;
                for (let i = 0; i < (pair.breeding ? pair.numOffspring : pair.offspringSurvived); i++) {
                    const ox = pair.x + (i - pair.numOffspring / 2) * 5;
                    const oy = pair.y;
                    arenaCtx.beginPath();
                    arenaCtx.arc(ox, oy, 3, 0, Math.PI * 2);
                    arenaCtx.fill();
                }

                // Draw male (blue, size = care level)
                if (!pair.deserted.male || pair.maleX > 0) {
                    const maleSize = 4 + pair.maleCare * 6;
                    arenaCtx.fillStyle = pair.deserted.male ? '#333' : '#4169E1';
                    arenaCtx.beginPath();
                    arenaCtx.arc(pair.maleX, pair.maleY, maleSize, 0, Math.PI * 2);
                    arenaCtx.fill();

                    // Care indicator
                    if (!pair.deserted.male && pair.maleCare > 0.2) {
                        arenaCtx.strokeStyle = '#90EE90';
                        arenaCtx.lineWidth = pair.maleCare * 2;
                        arenaCtx.beginPath();
                        arenaCtx.moveTo(pair.maleX, pair.maleY);
                        arenaCtx.lineTo(pair.x, pair.y);
                        arenaCtx.stroke();
                    }
                }

                // Draw female (pink, size = care level)
                if (!pair.deserted.female || pair.femaleX < w) {
                    const femaleSize = 4 + pair.femaleCare * 6;
                    arenaCtx.fillStyle = pair.deserted.female ? '#333' : '#FF69B4';
                    arenaCtx.beginPath();
                    arenaCtx.arc(pair.femaleX, pair.femaleY, femaleSize, 0, Math.PI * 2);
                    arenaCtx.fill();

                    // Care indicator
                    if (!pair.deserted.female && pair.femaleCare > 0.2) {
                        arenaCtx.strokeStyle = '#90EE90';
                        arenaCtx.lineWidth = pair.femaleCare * 2;
                        arenaCtx.beginPath();
                        arenaCtx.moveTo(pair.femaleX, pair.femaleY);
                        arenaCtx.lineTo(pair.x, pair.y);
                        arenaCtx.stroke();
                    }
                }
            });

            // Legend
            arenaCtx.font = '10px sans-serif';
            arenaCtx.fillStyle = '#4169E1';
            arenaCtx.fillRect(10, h - 45, 10, 10);
            arenaCtx.fillStyle = '#fff';
            arenaCtx.fillText('Male', 25, h - 37);

            arenaCtx.fillStyle = '#FF69B4';
            arenaCtx.fillRect(60, h - 45, 10, 10);
            arenaCtx.fillStyle = '#fff';
            arenaCtx.fillText('Female', 75, h - 37);

            arenaCtx.fillStyle = '#8B4513';
            arenaCtx.fillRect(120, h - 45, 10, 10);
            arenaCtx.fillStyle = '#fff';
            arenaCtx.fillText('Nest', 135, h - 37);
        }

        function drawStrategyPlot() {
            const w = strategyCanvas.width / window.devicePixelRatio;
            const h = strategyCanvas.height / window.devicePixelRatio;

            strategyCtx.fillStyle = '#1a1a2e';
            strategyCtx.fillRect(0, 0, w, h);

            if (strategyHistory.length < 2) return;

            const padding = 40;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Axes
            strategyCtx.strokeStyle = '#666';
            strategyCtx.beginPath();
            strategyCtx.moveTo(padding, padding);
            strategyCtx.lineTo(padding, h - padding);
            strategyCtx.lineTo(w - padding, h - padding);
            strategyCtx.stroke();

            // Labels
            strategyCtx.fillStyle = '#aaa';
            strategyCtx.font = '10px sans-serif';
            strategyCtx.fillText('100%', 5, padding + 5);
            strategyCtx.fillText('0%', 15, h - padding);
            strategyCtx.fillText('Generations', w / 2 - 30, h - 5);

            // Stacked area chart
            const colors = {
                biparental: '#4CAF50',
                femaleOnly: '#FF69B4',
                maleOnly: '#4169E1',
                noCare: '#666'
            };

            // Draw stacked areas
            Object.keys(colors).reverse().forEach(key => {
                strategyCtx.fillStyle = colors[key];
                strategyCtx.beginPath();
                strategyCtx.moveTo(padding, h - padding);

                let cumulative = 0;
                strategyHistory.forEach((d, i) => {
                    let sum = 0;
                    for (const k of Object.keys(colors)) {
                        sum += d[k];
                        if (k === key) break;
                    }
                    const x = padding + (i / (strategyHistory.length - 1)) * plotW;
                    const y = h - padding - sum * plotH;
                    strategyCtx.lineTo(x, y);
                });

                // Close path
                for (let i = strategyHistory.length - 1; i >= 0; i--) {
                    let sum = 0;
                    const d = strategyHistory[i];
                    for (const k of Object.keys(colors)) {
                        if (k === key) break;
                        sum += d[k];
                    }
                    const x = padding + (i / (strategyHistory.length - 1)) * plotW;
                    const y = h - padding - sum * plotH;
                    strategyCtx.lineTo(x, y);
                }

                strategyCtx.closePath();
                strategyCtx.fill();
            });

            // Legend
            let legendY = 15;
            Object.entries(colors).forEach(([key, color]) => {
                strategyCtx.fillStyle = color;
                strategyCtx.fillRect(w - 90, legendY, 10, 10);
                strategyCtx.fillStyle = '#fff';
                strategyCtx.font = '9px sans-serif';
                const label = key === 'biparental' ? 'Both' :
                              key === 'femaleOnly' ? 'Female' :
                              key === 'maleOnly' ? 'Male' : 'None';
                strategyCtx.fillText(label, w - 75, legendY + 9);
                legendY += 15;
            });
        }

        function drawSurvivalPlot() {
            const w = survivalCanvas.width / window.devicePixelRatio;
            const h = survivalCanvas.height / window.devicePixelRatio;

            survivalCtx.fillStyle = '#1a1a2e';
            survivalCtx.fillRect(0, 0, w, h);

            const padding = 40;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Axes
            survivalCtx.strokeStyle = '#666';
            survivalCtx.beginPath();
            survivalCtx.moveTo(padding, padding);
            survivalCtx.lineTo(padding, h - padding);
            survivalCtx.lineTo(w - padding, h - padding);
            survivalCtx.stroke();

            // Labels
            survivalCtx.fillStyle = '#aaa';
            survivalCtx.font = '10px sans-serif';
            survivalCtx.fillText('100%', 5, padding + 5);
            survivalCtx.fillText('Survival', 5, h / 2);
            survivalCtx.fillText('0%', 15, h - padding);
            survivalCtx.fillText('Total Care', w / 2 - 20, h - 5);
            survivalCtx.fillText('0', padding - 5, h - padding + 15);
            survivalCtx.fillText('2', w - padding - 5, h - padding + 15);

            // Expected curve
            survivalCtx.strokeStyle = '#ff9800';
            survivalCtx.lineWidth = 2;
            survivalCtx.beginPath();
            for (let i = 0; i <= 100; i++) {
                const totalCare = i / 50; // 0 to 2
                const survival = Math.min(0.95, totalCare * 0.5);
                const x = padding + (totalCare / 2) * plotW;
                const y = h - padding - survival * plotH;
                if (i === 0) survivalCtx.moveTo(x, y);
                else survivalCtx.lineTo(x, y);
            }
            survivalCtx.stroke();

            // Data points
            survivalData.forEach(d => {
                const x = padding + (d.totalCare / 2) * plotW;
                const y = h - padding - d.survival * plotH;

                survivalCtx.fillStyle = 'rgba(76, 175, 80, 0.5)';
                survivalCtx.beginPath();
                survivalCtx.arc(x, y, 4, 0, Math.PI * 2);
                survivalCtx.fill();
            });

            // Legend
            survivalCtx.fillStyle = '#ff9800';
            survivalCtx.fillText('Expected', w - 80, 20);
            survivalCtx.fillStyle = '#4CAF50';
            survivalCtx.fillText('● Observed', w - 80, 35);
        }

        function drawESSLandscape() {
            const w = essCanvas.width / window.devicePixelRatio;
            const h = essCanvas.height / window.devicePixelRatio;

            essCtx.fillStyle = '#1a1a2e';
            essCtx.fillRect(0, 0, w, h);

            const padding = 45;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // Axes
            essCtx.strokeStyle = '#666';
            essCtx.beginPath();
            essCtx.moveTo(padding, padding);
            essCtx.lineTo(padding, h - padding);
            essCtx.lineTo(w - padding, h - padding);
            essCtx.stroke();

            // Labels
            essCtx.fillStyle = '#aaa';
            essCtx.font = '10px sans-serif';
            essCtx.fillText('Female Care', 5, h / 2);
            essCtx.fillText('1.0', padding - 15, padding + 5);
            essCtx.fillText('0', padding - 10, h - padding + 5);
            essCtx.fillText('Male Care', w / 2 - 20, h - 5);
            essCtx.fillText('0', padding - 5, h - padding + 15);
            essCtx.fillText('1.0', w - padding - 10, h - padding + 15);

            // Draw current population as points
            pairs.forEach(pair => {
                const x = padding + pair.maleCare * plotW;
                const y = h - padding - pair.femaleCare * plotH;

                const pattern = pair.getPattern();
                const colors = {
                    [BIPARENTAL]: '#4CAF50',
                    [FEMALE_ONLY]: '#FF69B4',
                    [MALE_ONLY]: '#4169E1',
                    [NO_CARE]: '#666'
                };

                essCtx.fillStyle = colors[pattern];
                essCtx.beginPath();
                essCtx.arc(x, y, 5, 0, Math.PI * 2);
                essCtx.fill();
            });

            // Draw ESS regions
            essCtx.globalAlpha = 0.1;

            // Biparental region (both high)
            essCtx.fillStyle = '#4CAF50';
            essCtx.fillRect(
                padding + plotW * 0.3,
                padding,
                plotW * 0.7,
                plotH * 0.7
            );

            // Female only region
            essCtx.fillStyle = '#FF69B4';
            essCtx.fillRect(
                padding,
                padding,
                plotW * 0.3,
                plotH * 0.7
            );

            // Male only region
            essCtx.fillStyle = '#4169E1';
            essCtx.fillRect(
                padding + plotW * 0.3,
                padding + plotH * 0.7,
                plotW * 0.7,
                plotH * 0.3
            );

            essCtx.globalAlpha = 1.0;

            // Population mean
            const avgMale = pairs.reduce((s, p) => s + p.maleCare, 0) / pairs.length;
            const avgFemale = pairs.reduce((s, p) => s + p.femaleCare, 0) / pairs.length;

            essCtx.strokeStyle = '#fff';
            essCtx.lineWidth = 2;
            essCtx.beginPath();
            essCtx.arc(
                padding + avgMale * plotW,
                h - padding - avgFemale * plotH,
                10, 0, Math.PI * 2
            );
            essCtx.stroke();

            essCtx.fillStyle = '#fff';
            essCtx.font = '9px sans-serif';
            essCtx.fillText('Pop. Mean', padding + avgMale * plotW + 12, h - padding - avgFemale * plotH);
        }

        function animate() {
            if (running) {
                simulationStep();
            }
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            initSimulation();
        });

        // Slider value displays
        const sliders = [
            ['popSize', 'popSizeVal', v => v + ' pairs'],
            ['careBenefit', 'careBenefitVal', v => v + '%'],
            ['careCost', 'careCostVal', v => v + '%'],
            ['rematingOpp', 'rematingOppVal', v => v + '%'],
            ['paternity', 'paternityVal', v => v + '%'],
            ['negotiation', 'negotiationVal', v => v + '%'],
            ['initMaleCare', 'initMaleCareVal', v => v + '%']
        ];

        sliders.forEach(([id, displayId, formatter]) => {
            const input = document.getElementById(id);
            const display = document.getElementById(displayId);
            input.addEventListener('input', () => {
                display.textContent = formatter(parseInt(input.value));
            });
        });

        // Initialize
        initSimulation();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
