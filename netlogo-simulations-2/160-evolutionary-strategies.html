<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolutionary Strategies - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 300px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #14b8a6; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        select { width: 100%; padding: 8px; background: #333; color: #fff; border: none; border-radius: 5px; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #14b8a6; color: #000; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button:hover { opacity: 0.9; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; margin-bottom: 10px; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #14b8a6; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .info { background: rgba(20,184,166,0.1); padding: 10px; border-radius: 5px; font-size: 0.75rem; border-left: 3px solid #14b8a6; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div id="container">
        <div id="canvas-container"><canvas id="canvas"></canvas></div>
        <div id="controls">
            <h1>Evolutionary Strategies</h1>
            <div class="control-group">
                <label>Test Function:</label>
                <select id="function">
                    <option value="rastrigin">Rastrigin</option>
                    <option value="rosenbrock">Rosenbrock</option>
                    <option value="ackley">Ackley</option>
                    <option value="sphere">Sphere</option>
                </select>
            </div>
            <div class="control-group">
                <label>Strategy:</label>
                <select id="strategy">
                    <option value="comma">(μ,λ) - Comma</option>
                    <option value="plus">(μ+λ) - Plus</option>
                </select>
            </div>
            <div class="control-group">
                <label>μ (Parents): <span id="muValue">5</span></label>
                <input type="range" id="mu" min="2" max="20" step="1" value="5">
            </div>
            <div class="control-group">
                <label>λ (Offspring): <span id="lambdaValue">30</span></label>
                <input type="range" id="lambda" min="10" max="100" step="5" value="30">
            </div>
            <div class="control-group">
                <label>σ (Mutation): <span id="sigmaValue">0.5</span></label>
                <input type="range" id="sigma" min="0.1" max="2" step="0.1" value="0.5">
            </div>
            <button id="reset">Reset</button>
            <button id="step">Generation Step</button>
            <button id="run">Run/Pause</button>
            <div class="stats">
                <div>Generation: <span id="generation">0</span></div>
                <div>Best Fitness: <span id="bestFitness">-</span></div>
                <div>Best Position: (<span id="bestX">-</span>, <span id="bestY">-</span>)</div>
            </div>
            <div class="info">
                <strong>Evolution Strategies</strong><br><br>
                • (μ,λ): Only offspring survive<br>
                • (μ+λ): Parents + offspring compete<br>
                • Self-adaptive mutation (σ)<br><br>
                Contour shows fitness landscape.<br>
                Dots show population.
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let params = { mu: 5, lambda: 30, sigma: 0.5, strategy: 'comma', func: 'rastrigin' };
        let population = [];
        let generation = 0;
        let running = false;
        let best = { x: 0, y: 0, fitness: -Infinity };
        let fitnessCache = null;
        
        const BOUNDS = { min: -5, max: 5 };

        function resize() {
            canvas.width = document.getElementById('canvas-container').clientWidth;
            canvas.height = document.getElementById('canvas-container').clientHeight;
            fitnessCache = null;
        }

        // Test functions (we minimize, so negate for maximization)
        const functions = {
            rastrigin: (x, y) => {
                const A = 10;
                return -(A * 2 + x*x - A*Math.cos(2*Math.PI*x) + y*y - A*Math.cos(2*Math.PI*y));
            },
            rosenbrock: (x, y) => {
                return -(Math.pow(1-x, 2) + 100*Math.pow(y-x*x, 2));
            },
            ackley: (x, y) => {
                const a = 20, b = 0.2, c = 2*Math.PI;
                return -(-a * Math.exp(-b * Math.sqrt(0.5*(x*x + y*y))) 
                       - Math.exp(0.5*(Math.cos(c*x) + Math.cos(c*y))) + a + Math.E);
            },
            sphere: (x, y) => {
                return -(x*x + y*y);
            }
        };

        function fitness(x, y) {
            return functions[params.func](x, y);
        }

        function initPopulation() {
            population = [];
            for (let i = 0; i < params.lambda; i++) {
                const x = BOUNDS.min + Math.random() * (BOUNDS.max - BOUNDS.min);
                const y = BOUNDS.min + Math.random() * (BOUNDS.max - BOUNDS.min);
                const sigma = params.sigma;
                population.push({ x, y, sigma, fitness: fitness(x, y) });
            }
            
            generation = 0;
            best = { ...population[0], fitness: -Infinity };
            updateBest();
            fitnessCache = null;
        }

        function updateBest() {
            for (const ind of population) {
                if (ind.fitness > best.fitness) {
                    best = { ...ind };
                }
            }
        }

        function mutate(parent) {
            // Self-adaptive mutation
            const tau = 1 / Math.sqrt(2 * 2); // 2D
            const newSigma = parent.sigma * Math.exp(tau * randn());
            
            const newX = parent.x + newSigma * randn();
            const newY = parent.y + newSigma * randn();
            
            // Bound checking
            const x = Math.max(BOUNDS.min, Math.min(BOUNDS.max, newX));
            const y = Math.max(BOUNDS.min, Math.min(BOUNDS.max, newY));
            
            return {
                x, y,
                sigma: newSigma,
                fitness: fitness(x, y)
            };
        }

        function randn() {
            // Box-Muller transform
            const u1 = Math.random();
            const u2 = Math.random();
            return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        }

        function step() {
            // Select parents (truncation selection)
            population.sort((a, b) => b.fitness - a.fitness);
            const parents = population.slice(0, params.mu);
            
            // Create offspring
            const offspring = [];
            for (let i = 0; i < params.lambda; i++) {
                const parent = parents[i % params.mu];
                offspring.push(mutate(parent));
            }
            
            // Selection
            if (params.strategy === 'comma') {
                // (μ,λ): Only offspring
                population = offspring;
            } else {
                // (μ+λ): Parents + offspring
                population = [...parents, ...offspring];
            }
            
            // Sort and trim
            population.sort((a, b) => b.fitness - a.fitness);
            population = population.slice(0, params.lambda);
            
            generation++;
            updateBest();
            updateStats();
        }

        function updateStats() {
            document.getElementById('generation').textContent = generation;
            document.getElementById('bestFitness').textContent = best.fitness.toFixed(4);
            document.getElementById('bestX').textContent = best.x.toFixed(3);
            document.getElementById('bestY').textContent = best.y.toFixed(3);
        }

        function generateFitnessCache() {
            const w = canvas.width - 350;
            const h = canvas.height - 50;
            const res = 2; // Resolution
            
            fitnessCache = [];
            let minF = Infinity, maxF = -Infinity;
            
            for (let py = 0; py < h; py += res) {
                for (let px = 0; px < w; px += res) {
                    const x = BOUNDS.min + (px / w) * (BOUNDS.max - BOUNDS.min);
                    const y = BOUNDS.min + (py / h) * (BOUNDS.max - BOUNDS.min);
                    const f = fitness(x, y);
                    fitnessCache.push({ px, py, f });
                    minF = Math.min(minF, f);
                    maxF = Math.max(maxF, f);
                }
            }
            
            fitnessCache.minF = minF;
            fitnessCache.maxF = maxF;
            fitnessCache.res = res;
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const w = canvas.width - 350;
            const h = canvas.height - 50;
            const startX = 25;
            const startY = 25;
            
            // Draw fitness landscape
            if (!fitnessCache) generateFitnessCache();
            
            const { minF, maxF, res } = fitnessCache;
            const range = maxF - minF;
            
            for (const { px, py, f } of fitnessCache) {
                const t = range > 0 ? (f - minF) / range : 0.5;
                
                // Cool colormap
                const r = Math.floor(t * 50);
                const g = Math.floor(50 + t * 150);
                const b = Math.floor(100 + t * 100);
                
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(startX + px, startY + py, res, res);
            }
            
            // Draw population
            for (const ind of population) {
                const px = startX + ((ind.x - BOUNDS.min) / (BOUNDS.max - BOUNDS.min)) * w;
                const py = startY + ((ind.y - BOUNDS.min) / (BOUNDS.max - BOUNDS.min)) * h;
                
                ctx.beginPath();
                ctx.arc(px, py, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.globalAlpha = 0.7;
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            // Draw best
            const bx = startX + ((best.x - BOUNDS.min) / (BOUNDS.max - BOUNDS.min)) * w;
            const by = startY + ((best.y - BOUNDS.min) / (BOUNDS.max - BOUNDS.min)) * h;
            
            ctx.beginPath();
            ctx.arc(bx, by, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#14b8a6';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw global optimum marker (at 0,0 for most functions)
            const ox = startX + ((0 - BOUNDS.min) / (BOUNDS.max - BOUNDS.min)) * w;
            const oy = startY + ((0 - BOUNDS.min) / (BOUNDS.max - BOUNDS.min)) * h;
            
            ctx.beginPath();
            ctx.moveTo(ox - 8, oy);
            ctx.lineTo(ox + 8, oy);
            ctx.moveTo(ox, oy - 8);
            ctx.lineTo(ox, oy + 8);
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        let lastStep = 0;
        function animate(timestamp) {
            if (running && timestamp - lastStep > 100) {
                step();
                lastStep = timestamp;
            }
            draw();
            requestAnimationFrame(animate);
        }

        document.getElementById('function').addEventListener('change', e => {
            params.func = e.target.value;
            fitnessCache = null;
            initPopulation();
        });

        document.getElementById('strategy').addEventListener('change', e => {
            params.strategy = e.target.value;
        });

        document.getElementById('mu').addEventListener('input', e => {
            params.mu = parseInt(e.target.value);
            document.getElementById('muValue').textContent = params.mu;
        });

        document.getElementById('lambda').addEventListener('input', e => {
            params.lambda = parseInt(e.target.value);
            document.getElementById('lambdaValue').textContent = params.lambda;
        });

        document.getElementById('sigma').addEventListener('input', e => {
            params.sigma = parseFloat(e.target.value);
            document.getElementById('sigmaValue').textContent = params.sigma;
        });

        document.getElementById('reset').addEventListener('click', () => {
            running = false;
            document.getElementById('run').textContent = 'Run';
            initPopulation();
        });

        document.getElementById('step').addEventListener('click', step);

        document.getElementById('run').addEventListener('click', () => {
            running = !running;
            document.getElementById('run').textContent = running ? 'Pause' : 'Run';
        });

        window.addEventListener('resize', resize);

        resize();
        initPopulation();
        requestAnimationFrame(animate);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
