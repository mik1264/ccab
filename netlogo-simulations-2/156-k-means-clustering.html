<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Means Clustering - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #1a1a2e; color: #e8e6e1; overflow: hidden; }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls { width: 300px; background: rgba(0,0,0,0.8); padding: 20px; overflow-y: auto; }
        h1 { font-size: 1.2rem; margin-bottom: 15px; color: #34d399; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; }
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #34d399; color: #1a1a2e; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .stats { background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; font-size: 0.8rem; }
        .back-link { position: fixed; top: 10px; left: 10px; padding: 8px 16px; background: rgba(0,0,0,0.7); color: #34d399; text-decoration: none; border-radius: 6px; font-size: 14px; z-index: 999; }
        .explain-btn { background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); margin-top: 10px; }
        .modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 1000; }
        .modal-overlay.active { display: flex; align-items: center; justify-content: center; }
        .modal { background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%); border-radius: 16px; padding: 30px; max-width: 600px; max-height: 80vh; overflow-y: auto; border: 1px solid rgba(255,255,255,0.1); position: relative; }
        .modal-close { position: absolute; top: 15px; right: 20px; background: none; border: none; color: #888; font-size: 28px; cursor: pointer; width: auto; }
        .modal h2 { color: #34d399; margin-bottom: 20px; }
        .modal-body { color: #ccc; line-height: 1.8; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <div id="container">
        <div id="canvas-container"><canvas id="canvas"></canvas></div>
        <div id="controls">
            <h1>K-Means Clustering</h1>
            <div class="control-group">
                <label>K (Clusters): <span id="kValue">3</span></label>
                <input type="range" id="k" min="2" max="8" step="1" value="3">
            </div>
            <div class="control-group">
                <label>Data Points: <span id="pointsValue">150</span></label>
                <input type="range" id="points" min="50" max="300" step="25" value="150">
            </div>
            <button id="reset">Reset</button>
            <button id="step">Step</button>
            <button id="explainBtn" class="explain-btn">üìö Explain</button>
            <div class="stats">
                <div>Iteration: <span id="iteration">0</span></div>
                <div>Inertia: <span id="inertia">0</span></div>
                <div>Converged: <span id="converged">No</span></div>
            </div>
        </div>
    </div>
    <div id="explainModal" class="modal-overlay">
        <div class="modal">
            <button class="modal-close">&times;</button>
            <h2>K-Means Clustering</h2>
            <div class="modal-body">
                <p><strong>K-Means</strong> is an unsupervised learning algorithm that partitions data into K clusters.</p>
                <p>Algorithm steps:</p>
                <ul>
                    <li><strong>Initialize:</strong> Place K centroids randomly</li>
                    <li><strong>Assign:</strong> Each point to nearest centroid</li>
                    <li><strong>Update:</strong> Move centroids to cluster means</li>
                    <li><strong>Repeat:</strong> Until convergence</li>
                </ul>
                <p>Large circles are centroids, small circles are data points colored by cluster.</p>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let params = { k: 3, points: 150 };
        let points = [], centroids = [], iteration = 0, converged = false;
        const colors = ['#34d399', '#f472b6', '#22d3ee', '#f59e0b', '#a855f7', '#ef4444', '#14b8a6', '#eab308'];
        
        function resize() { canvas.width = document.getElementById('canvas-container').clientWidth; canvas.height = document.getElementById('canvas-container').clientHeight; }
        
        function init() {
            resize(); iteration = 0; converged = false;
            const w = canvas.width - 350, h = canvas.height - 50;
            
            points = [];
            // Generate clustered data
            for (let c = 0; c < params.k; c++) {
                const cx = 100 + Math.random() * (w - 100);
                const cy = 50 + Math.random() * (h - 50);
                const n = Math.floor(params.points / params.k);
                for (let i = 0; i < n; i++) {
                    points.push({
                        x: cx + (Math.random() - 0.5) * 150,
                        y: cy + (Math.random() - 0.5) * 150,
                        cluster: -1
                    });
                }
            }
            
            // Random centroids
            centroids = [];
            for (let i = 0; i < params.k; i++) {
                centroids.push({
                    x: 100 + Math.random() * (w - 100),
                    y: 50 + Math.random() * (h - 50)
                });
            }
        }
        
        function step() {
            if (converged) return;
            iteration++;
            
            // Assign points to nearest centroid
            for (let p of points) {
                let minDist = Infinity;
                for (let i = 0; i < centroids.length; i++) {
                    const d = Math.hypot(p.x - centroids[i].x, p.y - centroids[i].y);
                    if (d < minDist) {
                        minDist = d;
                        p.cluster = i;
                    }
                }
            }
            
            // Update centroids
            let moved = false;
            for (let i = 0; i < centroids.length; i++) {
                const clusterPoints = points.filter(p => p.cluster === i);
                if (clusterPoints.length > 0) {
                    const newX = clusterPoints.reduce((s, p) => s + p.x, 0) / clusterPoints.length;
                    const newY = clusterPoints.reduce((s, p) => s + p.y, 0) / clusterPoints.length;
                    if (Math.abs(newX - centroids[i].x) > 0.1 || Math.abs(newY - centroids[i].y) > 0.1) {
                        moved = true;
                    }
                    centroids[i].x = newX;
                    centroids[i].y = newY;
                }
            }
            
            if (!moved) converged = true;
        }
        
        function calculateInertia() {
            let inertia = 0;
            for (let p of points) {
                if (p.cluster >= 0) {
                    const c = centroids[p.cluster];
                    inertia += Math.hypot(p.x - c.x, p.y - c.y);
                }
            }
            return inertia;
        }
        
        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw points
            for (let p of points) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = p.cluster >= 0 ? colors[p.cluster % colors.length] : '#666';
                ctx.fill();
            }
            
            // Draw centroids
            for (let i = 0; i < centroids.length; i++) {
                ctx.beginPath();
                ctx.arc(centroids[i].x, centroids[i].y, 15, 0, Math.PI * 2);
                ctx.fillStyle = colors[i % colors.length];
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            
            document.getElementById('iteration').textContent = iteration;
            document.getElementById('inertia').textContent = calculateInertia().toFixed(1);
            document.getElementById('converged').textContent = converged ? 'Yes' : 'No';
        }
        
        function animate() { draw(); requestAnimationFrame(animate); }
        
        document.getElementById('k').addEventListener('input', e => { params.k = parseInt(e.target.value); document.getElementById('kValue').textContent = params.k; });
        document.getElementById('points').addEventListener('input', e => { params.points = parseInt(e.target.value); document.getElementById('pointsValue').textContent = params.points; });
        document.getElementById('reset').addEventListener('click', init);
        document.getElementById('step').addEventListener('click', step);
        window.addEventListener('resize', resize);
        const modal = document.getElementById('explainModal');
        document.getElementById('explainBtn').addEventListener('click', () => modal.classList.add('active'));
        modal.querySelector('.modal-close').addEventListener('click', () => modal.classList.remove('active'));
        modal.addEventListener('click', e => { if (e.target === modal) modal.classList.remove('active'); });
        init(); animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
