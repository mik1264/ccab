<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coalition Formation - Cooperative Game Theory</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { font-family: 'Lora', serif; color: #606C38; font-size: 2rem; margin-bottom: 8px; }
        .subtitle { color: #8A9A5B; font-size: 1rem; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #606C38; font-weight: 600; }
        .main-content { display: grid; grid-template-columns: 1fr 320px; gap: 20px; }
        .canvas-container { background: white; border-radius: 12px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        canvas { display: block; width: 100%; border-radius: 8px; }
        .controls { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        .control-group { margin-bottom: 18px; }
        .control-group label { display: block; color: #606C38; font-weight: 600; margin-bottom: 5px; font-size: 0.9rem; }
        .control-group input[type="range"] { width: 100%; }
        .control-group select { width: 100%; padding: 8px; border: 1px solid #DDA15E; border-radius: 6px; }
        .control-group .value { color: #8A9A5B; font-size: 0.85rem; }
        button { padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer; font-family: 'Nunito', sans-serif; font-weight: 600; margin-right: 8px; margin-bottom: 8px; }
        .btn-primary { background: #8A9A5B; color: white; }
        .btn-secondary { background: #DDA15E; color: white; }
        .stats-box { background: #FEFAE0; border-radius: 8px; padding: 12px; margin-top: 15px; }
        .stat { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #EDE8D5; }
        .stat:last-child { border-bottom: none; }
        .stat-label { color: #606C38; font-size: 0.85rem; }
        .stat-value { color: #BC6C25; font-weight: 600; font-size: 0.9rem; }
        .info-panel { margin-top: 20px; padding: 15px; background: white; border-radius: 12px; font-size: 0.85rem; color: #606C38; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        .allocation-table { margin-top: 10px; font-size: 0.8rem; }
        .allocation-table table { width: 100%; border-collapse: collapse; }
        .allocation-table th, .allocation-table td { border: 1px solid #DDA15E; padding: 4px; text-align: center; }
        .allocation-table th { background: #8A9A5B; color: white; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Coalition Formation</h1>
            <p class="subtitle">Shapley value, nucleolus, core, and power indices</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Number of Players: <span class="value" id="valuePlayers">4</span></label>
                    <input type="range" id="numPlayers" min="3" max="6" value="4">
                </div>

                <div class="control-group">
                    <label>Game Type:</label>
                    <select id="gameType">
                        <option value="voting">Voting Game</option>
                        <option value="production">Production Game</option>
                        <option value="cost">Cost Sharing</option>
                        <option value="random">Random Superadditive</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Solution Concept:</label>
                    <select id="solution">
                        <option value="shapley">Shapley Value</option>
                        <option value="nucleolus">Nucleolus</option>
                        <option value="equal">Equal Split</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Synergy Strength: <span class="value" id="valueSynergy">1.50</span></label>
                    <input type="range" id="synergy" min="100" max="300" value="150">
                </div>

                <button class="btn-primary" onclick="generateGame()">New Game</button>
                <button class="btn-secondary" onclick="togglePause()">Pause</button>

                <div class="allocation-table" id="allocationTable">
                    <strong>Current Allocation:</strong>
                    <table>
                        <tr><th>Player</th><th>Shapley</th><th>Power</th></tr>
                    </table>
                </div>

                <div class="stats-box">
                    <div class="stat"><span class="stat-label">Grand Coalition:</span><span class="stat-value" id="grandStat">0</span></div>
                    <div class="stat"><span class="stat-label">Core Empty:</span><span class="stat-value" id="coreStat">?</span></div>
                    <div class="stat"><span class="stat-label">Stability:</span><span class="stat-value" id="stabilityStat">-</span></div>
                    <div class="stat"><span class="stat-label">Iterations:</span><span class="stat-value" id="iterStat">0</span></div>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <strong>About this simulation:</strong> Coalition games model how players can cooperate and share rewards.
            The <strong>Shapley value</strong> allocates based on marginal contributions.
            The <strong>nucleolus</strong> minimizes the maximum dissatisfaction of any coalition.
            The <strong>core</strong> is the set of allocations where no coalition can do better alone.
            Players dynamically form and break coalitions seeking better payoffs.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = 600 * dpr;
        canvas.style.height = '600px';
        ctx.scale(dpr, dpr);

        const width = rect.width;
        const height = 600;

        let numPlayers = 4;
        let gameType = 'voting';
        let solutionConcept = 'shapley';
        let synergyStrength = 1.5;

        let charFunction = {}; // Characteristic function v(S)
        let players = [];
        let coalitions = [];
        let shapleyValues = [];
        let iteration = 0;
        let paused = false;

        const COLORS = ['#E63946', '#457B9D', '#2A9D8F', '#E9C46A', '#9B59B6', '#3498DB'];

        function generateGame() {
            charFunction = {};
            players = [];
            coalitions = [];
            shapleyValues = [];
            iteration = 0;

            // Generate characteristic function based on game type
            const n = numPlayers;

            // Empty coalition
            charFunction[''] = 0;

            // Generate all coalitions
            for (let i = 1; i < Math.pow(2, n); i++) {
                const coalition = [];
                for (let j = 0; j < n; j++) {
                    if (i & (1 << j)) {
                        coalition.push(j);
                    }
                }

                const key = coalition.join(',');
                charFunction[key] = calculateValue(coalition);
            }

            // Initialize players
            for (let i = 0; i < n; i++) {
                const angle = (2 * Math.PI * i) / n - Math.PI / 2;
                const radius = 150;
                players.push({
                    id: i,
                    x: width / 2 + radius * Math.cos(angle),
                    y: 200 + radius * Math.sin(angle),
                    coalition: i, // Initially each in own coalition
                    payoff: 0
                });
            }

            // Calculate Shapley values
            calculateShapley();

            // Initialize coalition structure
            updateCoalitions();
        }

        function calculateValue(coalition) {
            const n = coalition.length;
            if (n === 0) return 0;

            switch (gameType) {
                case 'voting':
                    // Simple voting game: majority wins
                    const weights = [35, 20, 15, 15, 10, 5].slice(0, numPlayers);
                    const totalWeight = coalition.reduce((s, i) => s + weights[i], 0);
                    const quota = weights.reduce((a, b) => a + b, 0) / 2;
                    return totalWeight > quota ? 100 : 0;

                case 'production':
                    // Production with complementarities
                    const baseValue = n * 20;
                    const synergy = Math.pow(n, synergyStrength) * 10;
                    return baseValue + synergy;

                case 'cost':
                    // Cost sharing (negative value = cost)
                    const fixedCost = 50;
                    const variableCost = n * 10;
                    return -(fixedCost + variableCost) / n * n;

                case 'random':
                    // Random superadditive game
                    let v = 0;
                    coalition.forEach(i => v += 10 + Math.random() * 20);
                    v *= Math.pow(synergyStrength, n - 1);
                    return v;

                default:
                    return n * 10;
            }
        }

        function calculateShapley() {
            shapleyValues = new Array(numPlayers).fill(0);

            // For each player, calculate Shapley value
            for (let i = 0; i < numPlayers; i++) {
                let shapley = 0;

                // Iterate over all coalitions not containing i
                for (let mask = 0; mask < Math.pow(2, numPlayers); mask++) {
                    if (mask & (1 << i)) continue; // Skip if i is in coalition

                    const coalitionWithout = [];
                    for (let j = 0; j < numPlayers; j++) {
                        if (mask & (1 << j)) coalitionWithout.push(j);
                    }

                    const coalitionWith = [...coalitionWithout, i];
                    const s = coalitionWithout.length;

                    const vWith = charFunction[coalitionWith.sort().join(',') || ''] || 0;
                    const vWithout = charFunction[coalitionWithout.sort().join(',') || ''] || 0;
                    const marginal = vWith - vWithout;

                    // Shapley weight
                    const weight = factorial(s) * factorial(numPlayers - s - 1) / factorial(numPlayers);
                    shapley += weight * marginal;
                }

                shapleyValues[i] = shapley;
            }
        }

        function factorial(n) {
            if (n <= 1) return 1;
            return n * factorial(n - 1);
        }

        function updateCoalitions() {
            // Group players by their coalition ID
            coalitions = [];
            const coalitionMap = {};

            players.forEach(p => {
                if (!coalitionMap[p.coalition]) {
                    coalitionMap[p.coalition] = [];
                }
                coalitionMap[p.coalition].push(p.id);
            });

            for (const [id, members] of Object.entries(coalitionMap)) {
                const key = members.sort().join(',');
                const value = charFunction[key] || 0;

                // Allocate based on solution concept
                let allocation;
                if (solutionConcept === 'shapley') {
                    // Proportional to Shapley values
                    const totalShapley = members.reduce((s, i) => s + shapleyValues[i], 0);
                    allocation = members.map(i =>
                        totalShapley > 0 ? (shapleyValues[i] / totalShapley) * value : value / members.length
                    );
                } else if (solutionConcept === 'nucleolus') {
                    // Simplified nucleolus (equal split in this demo)
                    allocation = members.map(() => value / members.length);
                } else {
                    allocation = members.map(() => value / members.length);
                }

                coalitions.push({ members, value, allocation });

                members.forEach((id, idx) => {
                    players[id].payoff = allocation[idx];
                });
            }
        }

        function simulate() {
            // Randomly try coalition changes
            if (Math.random() < 0.3) {
                const player = players[Math.floor(Math.random() * numPlayers)];

                // Find a better coalition to join
                const currentPayoff = player.payoff;

                // Try joining another coalition
                const otherPlayer = players[Math.floor(Math.random() * numPlayers)];
                if (otherPlayer.id !== player.id) {
                    // Tentatively join
                    const oldCoalition = player.coalition;
                    player.coalition = otherPlayer.coalition;
                    updateCoalitions();

                    // Check if beneficial for all involved
                    const newPayoff = player.payoff;
                    const otherNewPayoff = otherPlayer.payoff;

                    // Simple stability check
                    if (newPayoff <= currentPayoff * 0.95) {
                        // Revert
                        player.coalition = oldCoalition;
                        updateCoalitions();
                    }
                }
            }

            // Animate positions
            coalitions.forEach(c => {
                if (c.members.length > 1) {
                    // Move coalition members toward each other
                    const centerX = c.members.reduce((s, i) => s + players[i].x, 0) / c.members.length;
                    const centerY = c.members.reduce((s, i) => s + players[i].y, 0) / c.members.length;

                    c.members.forEach(i => {
                        players[i].x += (centerX - players[i].x) * 0.02;
                        players[i].y += (centerY - players[i].y) * 0.02;
                    });
                }
            });

            iteration++;
        }

        function checkCore() {
            // Check if current allocation is in the core
            const grandKey = Array.from({length: numPlayers}, (_, i) => i).join(',');
            const grandValue = charFunction[grandKey];

            // Check all subcoalitions
            for (const key of Object.keys(charFunction)) {
                if (key === '' || key === grandKey) continue;

                const members = key.split(',').map(Number);
                const coalitionValue = charFunction[key];
                const currentPayoff = members.reduce((s, i) => s + players[i].payoff, 0);

                if (coalitionValue > currentPayoff + 0.01) {
                    return false; // Not in core
                }
            }
            return true;
        }

        function draw() {
            ctx.fillStyle = '#FEFAE0';
            ctx.fillRect(0, 0, width, height);

            // Draw coalition connections
            coalitions.forEach(c => {
                if (c.members.length > 1) {
                    ctx.fillStyle = 'rgba(138, 154, 91, 0.2)';
                    ctx.beginPath();

                    const points = c.members.map(i => ({ x: players[i].x, y: players[i].y }));
                    const centerX = points.reduce((s, p) => s + p.x, 0) / points.length;
                    const centerY = points.reduce((s, p) => s + p.y, 0) / points.length;

                    // Draw convex hull-ish shape
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 60, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Draw players
            players.forEach(p => {
                // Player circle
                ctx.beginPath();
                ctx.arc(p.x, p.y, 30, 0, Math.PI * 2);
                ctx.fillStyle = COLORS[p.id];
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Player label
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Nunito';
                ctx.textAlign = 'center';
                ctx.fillText(`P${p.id + 1}`, p.x, p.y + 5);

                // Payoff
                ctx.fillStyle = '#606C38';
                ctx.font = '11px Nunito';
                ctx.fillText(`$${p.payoff.toFixed(1)}`, p.x, p.y + 50);
            });

            ctx.textAlign = 'left';

            // Draw Shapley value comparison
            const chartX = 40;
            const chartY = 400;
            const chartWidth = width - 80;
            const chartHeight = 80;

            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(chartX, chartY, chartWidth, chartHeight);
            ctx.strokeStyle = '#DDA15E';
            ctx.strokeRect(chartX, chartY, chartWidth, chartHeight);

            ctx.fillStyle = '#606C38';
            ctx.font = 'bold 11px Nunito';
            ctx.fillText('Shapley Values (fair allocation based on marginal contributions)', chartX + 10, chartY + 15);

            const barWidth = chartWidth / (numPlayers + 1);
            const maxShapley = Math.max(...shapleyValues.map(Math.abs), 1);

            shapleyValues.forEach((v, i) => {
                const barHeight = Math.abs(v) / maxShapley * (chartHeight - 40);
                const x = chartX + 30 + i * barWidth;
                const y = v >= 0 ? chartY + chartHeight - barHeight - 10 : chartY + chartHeight - 10;

                ctx.fillStyle = COLORS[i];
                ctx.fillRect(x, y, barWidth - 20, barHeight);

                ctx.fillStyle = '#333';
                ctx.font = '10px Nunito';
                ctx.textAlign = 'center';
                ctx.fillText(`P${i + 1}`, x + (barWidth - 20)/2, chartY + chartHeight - 2);
                ctx.fillText(v.toFixed(1), x + (barWidth - 20)/2, y - 5);
            });
            ctx.textAlign = 'left';

            // Coalition value visualization
            const coalY = 500;
            const coalHeight = 80;

            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(chartX, coalY, chartWidth, coalHeight);
            ctx.strokeStyle = '#DDA15E';
            ctx.strokeRect(chartX, coalY, chartWidth, coalHeight);

            ctx.fillStyle = '#606C38';
            ctx.font = 'bold 11px Nunito';
            ctx.fillText('Current Coalition Structure and Values', chartX + 10, coalY + 15);

            let xOffset = chartX + 20;
            coalitions.forEach(c => {
                const coalWidth = 60 + c.members.length * 30;

                ctx.fillStyle = '#E9F5E9';
                ctx.fillRect(xOffset, coalY + 25, coalWidth, 45);
                ctx.strokeStyle = '#8A9A5B';
                ctx.strokeRect(xOffset, coalY + 25, coalWidth, 45);

                // Member colors
                c.members.forEach((m, i) => {
                    ctx.beginPath();
                    ctx.arc(xOffset + 20 + i * 25, coalY + 47, 10, 0, Math.PI * 2);
                    ctx.fillStyle = COLORS[m];
                    ctx.fill();
                });

                ctx.fillStyle = '#606C38';
                ctx.font = '10px Nunito';
                ctx.fillText(`v=${c.value.toFixed(0)}`, xOffset + 10, coalY + 65);

                xOffset += coalWidth + 15;
            });
        }

        function updateStats() {
            const grandKey = Array.from({length: numPlayers}, (_, i) => i).join(',');
            document.getElementById('grandStat').textContent = (charFunction[grandKey] || 0).toFixed(1);
            document.getElementById('coreStat').textContent = checkCore() ? '✓ In Core' : '✗ Not in Core';
            document.getElementById('iterStat').textContent = iteration;

            // Stability measure
            const totalPayoff = players.reduce((s, p) => s + p.payoff, 0);
            document.getElementById('stabilityStat').textContent = totalPayoff.toFixed(1);

            // Update allocation table
            let tableHTML = '<strong>Payoff Allocation:</strong><table><tr><th>Player</th><th>Shapley</th><th>Current</th></tr>';
            players.forEach(p => {
                tableHTML += `<tr><td style="color:${COLORS[p.id]}">P${p.id + 1}</td><td>${shapleyValues[p.id].toFixed(1)}</td><td>${p.payoff.toFixed(1)}</td></tr>`;
            });
            tableHTML += '</table>';
            document.getElementById('allocationTable').innerHTML = tableHTML;
        }

        function updateControls() {
            numPlayers = parseInt(document.getElementById('numPlayers').value);
            gameType = document.getElementById('gameType').value;
            solutionConcept = document.getElementById('solution').value;
            synergyStrength = parseInt(document.getElementById('synergy').value) / 100;

            document.getElementById('valuePlayers').textContent = numPlayers;
            document.getElementById('valueSynergy').textContent = synergyStrength.toFixed(2);
        }

        function togglePause() {
            paused = !paused;
        }

        let frameCount = 0;
        function animate() {
            if (!paused) {
                frameCount++;
                if (frameCount % 10 === 0) {
                    simulate();
                }
            }

            updateStats();
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.querySelectorAll('input[type="range"]').forEach(input => {
            input.addEventListener('input', () => {
                updateControls();
                generateGame();
            });
        });
        document.getElementById('gameType').addEventListener('change', () => {
            updateControls();
            generateGame();
        });
        document.getElementById('solution').addEventListener('change', () => {
            updateControls();
            updateCoalitions();
        });

        updateControls();
        generateGame();
        animate();
    </script>
</body>
</html>
