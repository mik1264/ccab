<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Larger than Life - Extended Cellular Automata - CCAB</title>
    <meta name="description" content="Interactive Larger than Life cellular automata visualization. Explore extended neighborhood rules discovered by Kellie Evans including Bugs, Bosco, and self-organizing patterns.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.6);
            color: #ff5722;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 87, 34, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(255, 87, 34, 0.2);
            transform: translateX(-4px);
        }

        #info {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            color: #ff5722;
            font-size: 13px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 87, 34, 0.2);
            z-index: 1000;
            max-width: 280px;
        }

        #info h3 {
            margin-bottom: 10px;
            color: #ff8a65;
        }

        #info .stat {
            margin: 5px 0;
        }

        #info .stat-label {
            color: #888;
            font-size: 11px;
        }

        #info .stat-value {
            color: #ff5722;
            font-weight: bold;
        }

        #info p {
            font-size: 11px;
            opacity: 0.8;
            line-height: 1.5;
            margin-top: 10px;
            color: #aaa;
        }

        .rule-display {
            background: rgba(255, 87, 34, 0.1);
            padding: 8px;
            border-radius: 6px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 11px;
            color: #ff8a65;
            word-break: break-all;
        }

        #presets {
            position: fixed;
            top: 280px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 1000;
            max-height: 45vh;
            overflow-y: auto;
        }

        button {
            background: rgba(255, 87, 34, 0.15);
            border: 1px solid rgba(255, 87, 34, 0.4);
            color: #ff5722;
            padding: 8px 14px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s;
            text-align: left;
        }

        button:hover {
            background: rgba(255, 87, 34, 0.3);
        }

        button.active {
            background: rgba(255, 87, 34, 0.4);
            border-color: #ff5722;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 16px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 87, 34, 0.2);
        }

        .control-group label {
            color: #ff5722;
            font-size: 11px;
            display: block;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 80px;
            accent-color: #ff5722;
        }

        .control-group span {
            color: #fff;
            font-size: 10px;
            margin-left: 6px;
        }

        .control-btn {
            padding: 10px 16px;
        }

        #fps-display {
            position: fixed;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 6px;
            color: #ff5722;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div id="info">
        <h3>Larger than Life</h3>
        <div class="stat">
            <span class="stat-label">Radius (r)</span>
            <span class="stat-value" id="radius">5</span>
        </div>
        <div class="stat">
            <span class="stat-label">Birth Range</span>
            <span class="stat-value" id="birth-range">34-45</span>
        </div>
        <div class="stat">
            <span class="stat-label">Survival Range</span>
            <span class="stat-value" id="survival-range">34-58</span>
        </div>
        <div class="stat">
            <span class="stat-label">Generation</span>
            <span class="stat-value" id="generation">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Population</span>
            <span class="stat-value" id="population">0</span>
        </div>
        <div class="rule-display" id="rule-string">R5,C2,S34-58,B34-45,NM</div>
        <p>Larger than Life extends Conway's Game of Life to larger neighborhoods. Discovered by David Griffeath and studied by Kellie Evans, these rules produce bugs, blobs, and self-organizing structures.</p>
    </div>

    <div id="presets">
        <button class="active" data-preset="bugs">Bugs (Evans)</button>
        <button data-preset="bosco">Bosco</button>
        <button data-preset="bugsMod">Bugs Modified</button>
        <button data-preset="majorityVote">Majority Vote</button>
        <button data-preset="globe">Globe</button>
        <button data-preset="maze">Self-Org Maze</button>
        <button data-preset="gnarl">Gnarl</button>
        <button data-preset="life">Life (r=1)</button>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>Speed: <span id="speed-val">5</span></label>
            <input type="range" id="speed" min="1" max="20" value="5">
        </div>
        <div class="control-group">
            <label>Cell Size: <span id="size-val">2</span>px</label>
            <input type="range" id="size" min="1" max="4" value="2">
        </div>
        <div class="control-group">
            <label>Density: <span id="density-val">30</span>%</label>
            <input type="range" id="density" min="5" max="70" value="30">
        </div>
        <button class="control-btn" id="reset-btn">Randomize</button>
        <button class="control-btn" id="clear-btn">Clear</button>
        <button class="control-btn" id="pause-btn">Pause</button>
    </div>

    <div id="fps-display">FPS: <span id="fps">0</span></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let cellSize = 2;
        let gridWidth, gridHeight;
        let grid, nextGrid;
        let generation = 0;
        let running = true;
        let speed = 5;
        let initialDensity = 30;

        // LtL parameters
        let radius = 5;
        let birthMin = 34, birthMax = 45;
        let survivalMin = 34, survivalMax = 58;
        let includeMiddle = true;  // NM = neighborhood includes middle

        // Presets based on research
        const presets = {
            bugs: {
                name: "Bugs (Evans)",
                r: 5, birthMin: 34, birthMax: 45, survivalMin: 34, survivalMax: 58, middle: true,
                desc: "Classic Bugs rule discovered by Kellie Evans"
            },
            bosco: {
                name: "Bosco",
                r: 5, birthMin: 33, birthMax: 57, survivalMin: 34, survivalMax: 58, middle: true,
                desc: "Creates period-166 oscillators"
            },
            bugsMod: {
                name: "Bugs Modified",
                r: 10, birthMin: 123, birthMax: 170, survivalMin: 123, survivalMax: 212, middle: true,
                desc: "Larger radius bugs"
            },
            majorityVote: {
                name: "Majority Vote",
                r: 4, birthMin: 41, birthMax: 81, survivalMin: 41, survivalMax: 81, middle: true,
                desc: "Simple majority rule"
            },
            globe: {
                name: "Globe",
                r: 8, birthMin: 163, birthMax: 223, survivalMin: 163, survivalMax: 223, middle: true,
                desc: "Creates circular structures"
            },
            maze: {
                name: "Self-Org Maze",
                r: 3, birthMin: 10, birthMax: 21, survivalMin: 10, survivalMax: 30, middle: true,
                desc: "Self-organizing maze patterns"
            },
            gnarl: {
                name: "Gnarl",
                r: 1, birthMin: 1, birthMax: 1, survivalMin: 1, survivalMax: 1, middle: false,
                desc: "Fractal growth pattern"
            },
            life: {
                name: "Life (r=1)",
                r: 1, birthMin: 3, birthMax: 3, survivalMin: 2, survivalMax: 3, middle: false,
                desc: "Conway's Game of Life"
            }
        };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initGrid();
        }

        function initGrid() {
            gridWidth = Math.floor(canvas.width / cellSize);
            gridHeight = Math.floor(canvas.height / cellSize);
            grid = new Uint8Array(gridWidth * gridHeight);
            nextGrid = new Uint8Array(gridWidth * gridHeight);
            randomize();
        }

        function randomize() {
            for (let i = 0; i < grid.length; i++) {
                grid[i] = Math.random() * 100 < initialDensity ? 1 : 0;
            }
            generation = 0;
        }

        function clear() {
            grid.fill(0);
            nextGrid.fill(0);
            generation = 0;
        }

        function getCell(x, y) {
            // Wrap around (toroidal)
            x = (x + gridWidth) % gridWidth;
            y = (y + gridHeight) % gridHeight;
            return grid[y * gridWidth + x];
        }

        function countNeighbors(x, y) {
            let count = 0;
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (!includeMiddle && dx === 0 && dy === 0) continue;
                    count += getCell(x + dx, y + dy);
                }
            }
            return count;
        }

        function update() {
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const idx = y * gridWidth + x;
                    const neighbors = countNeighbors(x, y);
                    const alive = grid[idx];

                    if (alive) {
                        // Survival
                        nextGrid[idx] = (neighbors >= survivalMin && neighbors <= survivalMax) ? 1 : 0;
                    } else {
                        // Birth
                        nextGrid[idx] = (neighbors >= birthMin && neighbors <= birthMax) ? 1 : 0;
                    }
                }
            }

            // Swap buffers
            [grid, nextGrid] = [nextGrid, grid];
            generation++;
        }

        function render() {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let population = 0;
            ctx.fillStyle = '#ff5722';

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (grid[y * gridWidth + x]) {
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        population++;
                    }
                }
            }

            return population;
        }

        function updateStats(population) {
            document.getElementById('radius').textContent = radius;
            document.getElementById('birth-range').textContent = `${birthMin}-${birthMax}`;
            document.getElementById('survival-range').textContent = `${survivalMin}-${survivalMax}`;
            document.getElementById('generation').textContent = generation.toLocaleString();
            document.getElementById('population').textContent = population.toLocaleString();

            const middleStr = includeMiddle ? 'NM' : 'N';
            document.getElementById('rule-string').textContent =
                `R${radius},C2,S${survivalMin}-${survivalMax},B${birthMin}-${birthMax},${middleStr}`;
        }

        function applyPreset(presetName) {
            const preset = presets[presetName];
            radius = preset.r;
            birthMin = preset.birthMin;
            birthMax = preset.birthMax;
            survivalMin = preset.survivalMin;
            survivalMax = preset.survivalMax;
            includeMiddle = preset.middle;
            randomize();
        }

        // FPS tracking
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;
        let lastUpdateTime = 0;

        function animate(currentTime) {
            requestAnimationFrame(animate);

            // FPS calculation
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                document.getElementById('fps').textContent = fps;
            }

            // Limit updates based on speed
            if (running && currentTime - lastUpdateTime >= 1000 / speed) {
                update();
                lastUpdateTime = currentTime;
            }

            const population = render();
            updateStats(population);
        }

        // Event listeners
        document.getElementById('speed').addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            document.getElementById('speed-val').textContent = speed;
        });

        document.getElementById('size').addEventListener('input', (e) => {
            cellSize = parseInt(e.target.value);
            document.getElementById('size-val').textContent = cellSize;
            initGrid();
        });

        document.getElementById('density').addEventListener('input', (e) => {
            initialDensity = parseInt(e.target.value);
            document.getElementById('density-val').textContent = initialDensity;
        });

        document.getElementById('reset-btn').addEventListener('click', randomize);
        document.getElementById('clear-btn').addEventListener('click', clear);

        document.getElementById('pause-btn').addEventListener('click', () => {
            running = !running;
            document.getElementById('pause-btn').textContent = running ? 'Pause' : 'Resume';
        });

        // Preset buttons
        document.querySelectorAll('#presets button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('#presets button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                applyPreset(btn.dataset.preset);
            });
        });

        // Mouse drawing
        let isDrawing = false;
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            draw(e);
        });
        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) draw(e);
        });
        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseleave', () => isDrawing = false);

        function draw(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / cellSize);
            const y = Math.floor((e.clientY - rect.top) / cellSize);

            // Draw a small blob
            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    const nx = (x + dx + gridWidth) % gridWidth;
                    const ny = (y + dy + gridHeight) % gridHeight;
                    grid[ny * gridWidth + nx] = 1;
                }
            }
        }

        // Expose for enhance.js
        window.reset = randomize;

        // Initialize
        window.addEventListener('resize', resize);
        resize();
        animate(0);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
