<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess960 Interactive Play - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #18181b 0%, #27272a 100%);
            color: #e8e6e1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            color: #ec4899;
            text-decoration: none;
            border-radius: 30px;
            font-size: 14px;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .back-link:hover {
            background: rgba(236, 72, 153, 0.2);
            transform: translateX(-4px);
        }

        header {
            text-align: center;
            margin-bottom: 25px;
            margin-top: 40px;
        }

        h1 {
            font-family: 'Lora', serif;
            font-size: 2.5rem;
            color: #ec4899;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #a0a0a0;
            font-size: 1rem;
        }

        .main-container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
            max-width: 1200px;
        }

        .board-area {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            margin-bottom: 10px;
            width: 100%;
            max-width: 520px;
        }

        .player-info.bottom {
            margin-bottom: 0;
            margin-top: 10px;
        }

        .player-piece {
            font-size: 30px;
        }

        .player-details {
            flex: 1;
        }

        .player-name {
            font-weight: 600;
            font-size: 16px;
        }

        .player-captured {
            font-size: 18px;
            letter-spacing: 2px;
            min-height: 24px;
        }

        .turn-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #333;
            transition: all 0.3s ease;
        }

        .turn-indicator.active {
            background: #10b981;
            box-shadow: 0 0 10px #10b981;
        }

        .board-container {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 15px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            border: 4px solid #ec4899;
            border-radius: 8px;
            overflow: hidden;
        }

        .square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 44px;
            position: relative;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .square.light {
            background: linear-gradient(135deg, #fdf2f8 0%, #fce7f3 100%);
        }

        .square.dark {
            background: linear-gradient(135deg, #be185d 0%, #9d174d 100%);
        }

        .square:hover {
            filter: brightness(1.1);
        }

        .square.selected {
            box-shadow: inset 0 0 0 4px #fbbf24;
        }

        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(16, 185, 129, 0.6);
            border-radius: 50%;
        }

        .square.valid-capture::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border: 4px solid rgba(239, 68, 68, 0.7);
            border-radius: 4px;
            box-sizing: border-box;
        }

        .square.last-move {
            background: rgba(251, 191, 36, 0.4) !important;
        }

        .square.in-check {
            background: rgba(239, 68, 68, 0.5) !important;
        }

        .square .piece {
            filter: drop-shadow(2px 2px 3px rgba(0, 0, 0, 0.4));
            transition: transform 0.15s ease;
            user-select: none;
        }

        .square:hover .piece {
            transform: scale(1.05);
        }

        .file-labels, .rank-labels-container {
            display: flex;
        }

        .file-labels {
            justify-content: space-around;
            padding: 5px 0;
            font-size: 12px;
            color: #888;
        }

        .side-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            min-width: 280px;
            max-width: 320px;
        }

        .panel-section {
            margin-bottom: 25px;
        }

        .section-title {
            font-family: 'Lora', serif;
            color: #ec4899;
            font-size: 1.1rem;
            margin-bottom: 15px;
        }

        .position-info {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: #888;
        }

        .info-value {
            font-family: 'Courier New', monospace;
            color: #ec4899;
        }

        .move-list {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.8;
        }

        .move-list::-webkit-scrollbar {
            width: 6px;
        }

        .move-list::-webkit-scrollbar-thumb {
            background: #ec4899;
            border-radius: 3px;
        }

        .move-pair {
            display: flex;
            gap: 15px;
        }

        .move-number {
            color: #666;
            min-width: 30px;
        }

        .move {
            color: #e8e6e1;
            cursor: pointer;
            padding: 2px 5px;
            border-radius: 4px;
        }

        .move:hover {
            background: rgba(236, 72, 153, 0.2);
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        button {
            padding: 12px 20px;
            font-size: 14px;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #ec4899 0%, #be185d 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(236, 72, 153, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e8e6e1;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .btn-row {
            display: flex;
            gap: 10px;
        }

        .btn-row button {
            flex: 1;
        }

        .status-bar {
            text-align: center;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            font-size: 14px;
            color: #fbbf24;
        }

        .promotion-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .promotion-modal.show {
            display: flex;
        }

        .promotion-choices {
            display: flex;
            gap: 15px;
            background: rgba(39, 39, 42, 0.95);
            padding: 25px;
            border-radius: 20px;
            border: 2px solid #ec4899;
        }

        .promotion-piece {
            font-size: 50px;
            padding: 15px;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.2s ease;
        }

        .promotion-piece:hover {
            background: rgba(236, 72, 153, 0.3);
            transform: scale(1.1);
        }

        @media (max-width: 900px) {
            .main-container {
                flex-direction: column;
                align-items: center;
            }

            .side-panel {
                min-width: unset;
                width: 100%;
                max-width: 520px;
            }

            .square {
                width: 45px;
                height: 45px;
                font-size: 32px;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Chess960</a>

    <header>
        <h1>Interactive Play</h1>
        <p class="subtitle">Play Chess960 - move pieces and explore positions</p>
    </header>

    <div class="main-container">
        <div class="board-area">
            <div class="player-info">
                <span class="player-piece">‚ôö</span>
                <div class="player-details">
                    <div class="player-name">Black</div>
                    <div class="player-captured" id="whiteCaptured"></div>
                </div>
                <div class="turn-indicator" id="blackTurn"></div>
            </div>

            <div class="board-container">
                <div class="board" id="board"></div>
                <div class="file-labels">
                    <span>a</span><span>b</span><span>c</span><span>d</span>
                    <span>e</span><span>f</span><span>g</span><span>h</span>
                </div>
            </div>

            <div class="player-info bottom">
                <span class="player-piece">‚ôî</span>
                <div class="player-details">
                    <div class="player-name">White</div>
                    <div class="player-captured" id="blackCaptured"></div>
                </div>
                <div class="turn-indicator active" id="whiteTurn"></div>
            </div>
        </div>

        <div class="side-panel">
            <div class="panel-section">
                <h3 class="section-title">Position</h3>
                <div class="position-info">
                    <div class="info-row">
                        <span class="info-label">Position #</span>
                        <span class="info-value" id="posNum">---</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Setup</span>
                        <span class="info-value" id="setup">--------</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">To Move</span>
                        <span class="info-value" id="toMove">White</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Move #</span>
                        <span class="info-value" id="moveNum">1</span>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h3 class="section-title">Move History</h3>
                <div class="move-list" id="moveList">
                    <em style="color: #666;">No moves yet</em>
                </div>
            </div>

            <div class="panel-section">
                <div class="status-bar" id="statusBar">White to move</div>
            </div>

            <div class="controls">
                <button class="btn-primary" onclick="newGame()">
                    üé≤ New Random Position
                </button>
                <div class="btn-row">
                    <button class="btn-secondary" onclick="undoMove()">‚Ü© Undo</button>
                    <button class="btn-secondary" onclick="resetGame()">‚Ü∫ Reset</button>
                </div>
                <button class="btn-secondary" onclick="flipBoard()">
                    üîÑ Flip Board
                </button>
            </div>
        </div>
    </div>

    <div class="promotion-modal" id="promotionModal">
        <div class="promotion-choices" id="promotionChoices"></div>
    </div>

    <script>
        const PIECES = {
            K: '‚ôî', Q: '‚ôï', R: '‚ôñ', B: '‚ôó', N: '‚ôò', P: '‚ôô',
            k: '‚ôö', q: '‚ôõ', r: '‚ôú', b: '‚ôù', n: '‚ôû', p: '‚ôü'
        };

        const FILES = 'abcdefgh';

        let board = [];
        let selectedSquare = null;
        let validMoves = [];
        let isWhiteTurn = true;
        let moveHistory = [];
        let initialPosition = [];
        let positionNumber = 0;
        let lastMove = null;
        let capturedWhite = [];
        let capturedBlack = [];
        let flipped = false;
        let castlingRights = { K: true, Q: true, k: true, q: true };
        let promotionCallback = null;

        function generateFromNumber(n) {
            const pieces = new Array(8).fill(null);

            const lightBishop = (n % 4) * 2 + 1;
            n = Math.floor(n / 4);
            const darkBishop = (n % 4) * 2;
            n = Math.floor(n / 4);

            pieces[lightBishop] = 'B';
            pieces[darkBishop] = 'B';

            const queenIndex = n % 6;
            n = Math.floor(n / 6);
            let count = 0;
            for (let i = 0; i < 8; i++) {
                if (pieces[i] === null) {
                    if (count === queenIndex) {
                        pieces[i] = 'Q';
                        break;
                    }
                    count++;
                }
            }

            const knightTable = [
                [0, 1], [0, 2], [0, 3], [0, 4],
                [1, 2], [1, 3], [1, 4],
                [2, 3], [2, 4], [3, 4]
            ];

            const knights = knightTable[n];
            let emptySquares = [];
            for (let i = 0; i < 8; i++) {
                if (pieces[i] === null) emptySquares.push(i);
            }

            pieces[emptySquares[knights[0]]] = 'N';
            pieces[emptySquares[knights[1]]] = 'N';

            emptySquares = [];
            for (let i = 0; i < 8; i++) {
                if (pieces[i] === null) emptySquares.push(i);
            }

            pieces[emptySquares[0]] = 'R';
            pieces[emptySquares[1]] = 'K';
            pieces[emptySquares[2]] = 'R';

            return pieces;
        }

        function initBoard(whitePieces) {
            board = [];
            for (let rank = 0; rank < 8; rank++) {
                const row = [];
                for (let file = 0; file < 8; file++) {
                    if (rank === 0) row.push(whitePieces[file]);
                    else if (rank === 1) row.push('P');
                    else if (rank === 6) row.push('p');
                    else if (rank === 7) row.push(whitePieces[file].toLowerCase());
                    else row.push(null);
                }
                board.push(row);
            }
        }

        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';

            const ranks = flipped ? [0,1,2,3,4,5,6,7] : [7,6,5,4,3,2,1,0];
            const files = flipped ? [7,6,5,4,3,2,1,0] : [0,1,2,3,4,5,6,7];

            ranks.forEach(rank => {
                files.forEach(file => {
                    const square = document.createElement('div');
                    const isLight = (rank + file) % 2 === 1;
                    square.className = `square ${isLight ? 'light' : 'dark'}`;
                    square.dataset.rank = rank;
                    square.dataset.file = file;

                    // Highlight last move
                    if (lastMove) {
                        if ((rank === lastMove.fromRank && file === lastMove.fromFile) ||
                            (rank === lastMove.toRank && file === lastMove.toFile)) {
                            square.classList.add('last-move');
                        }
                    }

                    // Selected square
                    if (selectedSquare && selectedSquare.rank === rank && selectedSquare.file === file) {
                        square.classList.add('selected');
                    }

                    // Valid moves
                    const isValidMove = validMoves.some(m => m.toRank === rank && m.toFile === file);
                    if (isValidMove) {
                        const targetPiece = board[rank][file];
                        if (targetPiece) {
                            square.classList.add('valid-capture');
                        } else {
                            square.classList.add('valid-move');
                        }
                    }

                    // Check
                    const piece = board[rank][file];
                    if (piece === 'K' && isInCheck(true)) {
                        square.classList.add('in-check');
                    }
                    if (piece === 'k' && isInCheck(false)) {
                        square.classList.add('in-check');
                    }

                    if (piece) {
                        const pieceSpan = document.createElement('span');
                        pieceSpan.className = 'piece';
                        pieceSpan.textContent = PIECES[piece];
                        square.appendChild(pieceSpan);
                    }

                    square.onclick = () => handleSquareClick(rank, file);
                    boardEl.appendChild(square);
                }
            )});
        }

        function isWhitePiece(piece) {
            return piece && piece === piece.toUpperCase();
        }

        function handleSquareClick(rank, file) {
            const piece = board[rank][file];

            // If there's a piece of the current player's color, select it
            if (piece && isWhitePiece(piece) === isWhiteTurn) {
                selectedSquare = { rank, file };
                validMoves = getValidMoves(rank, file);
                renderBoard();
                return;
            }

            // If a square is selected, try to move
            if (selectedSquare) {
                const move = validMoves.find(m => m.toRank === rank && m.toFile === file);
                if (move) {
                    executeMove(move);
                } else {
                    selectedSquare = null;
                    validMoves = [];
                }
                renderBoard();
            }
        }

        function getValidMoves(rank, file) {
            const piece = board[rank][file];
            if (!piece) return [];

            const moves = [];
            const type = piece.toUpperCase();
            const isWhite = isWhitePiece(piece);

            switch (type) {
                case 'P':
                    addPawnMoves(moves, rank, file, isWhite);
                    break;
                case 'N':
                    addKnightMoves(moves, rank, file, isWhite);
                    break;
                case 'B':
                    addBishopMoves(moves, rank, file, isWhite);
                    break;
                case 'R':
                    addRookMoves(moves, rank, file, isWhite);
                    break;
                case 'Q':
                    addBishopMoves(moves, rank, file, isWhite);
                    addRookMoves(moves, rank, file, isWhite);
                    break;
                case 'K':
                    addKingMoves(moves, rank, file, isWhite);
                    break;
            }

            // Filter out moves that leave king in check
            return moves.filter(move => !wouldBeInCheck(move, isWhite));
        }

        function addPawnMoves(moves, rank, file, isWhite) {
            const dir = isWhite ? 1 : -1;
            const startRank = isWhite ? 1 : 6;
            const promoteRank = isWhite ? 7 : 0;

            // Forward move
            if (board[rank + dir] && board[rank + dir][file] === null) {
                if (rank + dir === promoteRank) {
                    moves.push({ fromRank: rank, fromFile: file, toRank: rank + dir, toFile: file, promotion: true });
                } else {
                    moves.push({ fromRank: rank, fromFile: file, toRank: rank + dir, toFile: file });
                }

                // Double move from start
                if (rank === startRank && board[rank + 2*dir][file] === null) {
                    moves.push({ fromRank: rank, fromFile: file, toRank: rank + 2*dir, toFile: file });
                }
            }

            // Captures
            [-1, 1].forEach(df => {
                const newFile = file + df;
                if (newFile >= 0 && newFile < 8 && board[rank + dir]) {
                    const target = board[rank + dir][newFile];
                    if (target && isWhitePiece(target) !== isWhite) {
                        if (rank + dir === promoteRank) {
                            moves.push({ fromRank: rank, fromFile: file, toRank: rank + dir, toFile: newFile, promotion: true });
                        } else {
                            moves.push({ fromRank: rank, fromFile: file, toRank: rank + dir, toFile: newFile });
                        }
                    }
                }
            });
        }

        function addKnightMoves(moves, rank, file, isWhite) {
            const offsets = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
            offsets.forEach(([dr, df]) => {
                const nr = rank + dr, nf = file + df;
                if (nr >= 0 && nr < 8 && nf >= 0 && nf < 8) {
                    const target = board[nr][nf];
                    if (!target || isWhitePiece(target) !== isWhite) {
                        moves.push({ fromRank: rank, fromFile: file, toRank: nr, toFile: nf });
                    }
                }
            });
        }

        function addBishopMoves(moves, rank, file, isWhite) {
            [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr, df]) => {
                addSlidingMoves(moves, rank, file, dr, df, isWhite);
            });
        }

        function addRookMoves(moves, rank, file, isWhite) {
            [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr, df]) => {
                addSlidingMoves(moves, rank, file, dr, df, isWhite);
            });
        }

        function addSlidingMoves(moves, rank, file, dr, df, isWhite) {
            let nr = rank + dr, nf = file + df;
            while (nr >= 0 && nr < 8 && nf >= 0 && nf < 8) {
                const target = board[nr][nf];
                if (!target) {
                    moves.push({ fromRank: rank, fromFile: file, toRank: nr, toFile: nf });
                } else {
                    if (isWhitePiece(target) !== isWhite) {
                        moves.push({ fromRank: rank, fromFile: file, toRank: nr, toFile: nf });
                    }
                    break;
                }
                nr += dr;
                nf += df;
            }
        }

        function addKingMoves(moves, rank, file, isWhite) {
            for (let dr = -1; dr <= 1; dr++) {
                for (let df = -1; df <= 1; df++) {
                    if (dr === 0 && df === 0) continue;
                    const nr = rank + dr, nf = file + df;
                    if (nr >= 0 && nr < 8 && nf >= 0 && nf < 8) {
                        const target = board[nr][nf];
                        if (!target || isWhitePiece(target) !== isWhite) {
                            moves.push({ fromRank: rank, fromFile: file, toRank: nr, toFile: nf });
                        }
                    }
                }
            }
            // Note: Simplified - no castling in this demo for simplicity
        }

        function wouldBeInCheck(move, isWhite) {
            // Make move temporarily
            const piece = board[move.fromRank][move.fromFile];
            const captured = board[move.toRank][move.toFile];
            board[move.toRank][move.toFile] = piece;
            board[move.fromRank][move.fromFile] = null;

            const inCheck = isInCheck(isWhite);

            // Undo
            board[move.fromRank][move.fromFile] = piece;
            board[move.toRank][move.toFile] = captured;

            return inCheck;
        }

        function isInCheck(isWhite) {
            // Find king
            let kingRank, kingFile;
            const kingPiece = isWhite ? 'K' : 'k';
            for (let r = 0; r < 8; r++) {
                for (let f = 0; f < 8; f++) {
                    if (board[r][f] === kingPiece) {
                        kingRank = r;
                        kingFile = f;
                        break;
                    }
                }
            }

            // Check if any enemy piece attacks king
            for (let r = 0; r < 8; r++) {
                for (let f = 0; f < 8; f++) {
                    const piece = board[r][f];
                    if (piece && isWhitePiece(piece) !== isWhite) {
                        if (canAttack(r, f, kingRank, kingFile)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function canAttack(fromR, fromF, toR, toF) {
            const piece = board[fromR][fromF];
            const type = piece.toUpperCase();
            const dr = toR - fromR, df = toF - fromF;

            switch (type) {
                case 'P':
                    const dir = isWhitePiece(piece) ? 1 : -1;
                    return dr === dir && Math.abs(df) === 1;
                case 'N':
                    return (Math.abs(dr) === 2 && Math.abs(df) === 1) ||
                           (Math.abs(dr) === 1 && Math.abs(df) === 2);
                case 'B':
                    if (Math.abs(dr) !== Math.abs(df)) return false;
                    return isPathClear(fromR, fromF, toR, toF);
                case 'R':
                    if (dr !== 0 && df !== 0) return false;
                    return isPathClear(fromR, fromF, toR, toF);
                case 'Q':
                    if (dr !== 0 && df !== 0 && Math.abs(dr) !== Math.abs(df)) return false;
                    return isPathClear(fromR, fromF, toR, toF);
                case 'K':
                    return Math.abs(dr) <= 1 && Math.abs(df) <= 1;
            }
            return false;
        }

        function isPathClear(fromR, fromF, toR, toF) {
            const dr = Math.sign(toR - fromR);
            const df = Math.sign(toF - fromF);
            let r = fromR + dr, f = fromF + df;
            while (r !== toR || f !== toF) {
                if (board[r][f]) return false;
                r += dr;
                f += df;
            }
            return true;
        }

        function executeMove(move) {
            const piece = board[move.fromRank][move.fromFile];
            const captured = board[move.toRank][move.toFile];

            if (captured) {
                if (isWhiteTurn) {
                    capturedBlack.push(captured);
                } else {
                    capturedWhite.push(captured);
                }
            }

            // Handle promotion
            if (move.promotion) {
                showPromotionDialog(move, piece);
                return;
            }

            completeMove(move, piece, captured);
        }

        function showPromotionDialog(move, piece) {
            const modal = document.getElementById('promotionModal');
            const choices = document.getElementById('promotionChoices');
            const pieces = isWhiteTurn ? ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];

            choices.innerHTML = '';
            pieces.forEach(p => {
                const div = document.createElement('div');
                div.className = 'promotion-piece';
                div.textContent = PIECES[p];
                div.onclick = () => {
                    modal.classList.remove('show');
                    const captured = board[move.toRank][move.toFile];
                    board[move.toRank][move.toFile] = p;
                    board[move.fromRank][move.fromFile] = null;
                    completeMove(move, piece, captured, p);
                };
                choices.appendChild(div);
            });

            modal.classList.add('show');
        }

        function completeMove(move, piece, captured, promotedTo = null) {
            if (!promotedTo) {
                board[move.toRank][move.toFile] = piece;
                board[move.fromRank][move.fromFile] = null;
            }

            lastMove = move;
            moveHistory.push({
                move: move,
                piece: piece,
                captured: captured,
                promotedTo: promotedTo
            });

            isWhiteTurn = !isWhiteTurn;
            selectedSquare = null;
            validMoves = [];

            updateUI();
            renderBoard();
        }

        function updateUI() {
            document.getElementById('toMove').textContent = isWhiteTurn ? 'White' : 'Black';
            document.getElementById('moveNum').textContent = Math.floor(moveHistory.length / 2) + 1;
            document.getElementById('whiteTurn').classList.toggle('active', isWhiteTurn);
            document.getElementById('blackTurn').classList.toggle('active', !isWhiteTurn);

            document.getElementById('whiteCaptured').textContent =
                capturedWhite.map(p => PIECES[p]).join('');
            document.getElementById('blackCaptured').textContent =
                capturedBlack.map(p => PIECES[p]).join('');

            // Update move list
            const moveListEl = document.getElementById('moveList');
            if (moveHistory.length === 0) {
                moveListEl.innerHTML = '<em style="color: #666;">No moves yet</em>';
            } else {
                moveListEl.innerHTML = '';
                for (let i = 0; i < moveHistory.length; i += 2) {
                    const moveNum = Math.floor(i / 2) + 1;
                    const whiteMove = moveHistory[i];
                    const blackMove = moveHistory[i + 1];

                    const pair = document.createElement('div');
                    pair.className = 'move-pair';

                    pair.innerHTML = `
                        <span class="move-number">${moveNum}.</span>
                        <span class="move">${formatMove(whiteMove)}</span>
                        ${blackMove ? `<span class="move">${formatMove(blackMove)}</span>` : ''}
                    `;
                    moveListEl.appendChild(pair);
                }
                moveListEl.scrollTop = moveListEl.scrollHeight;
            }

            // Status
            let status = isWhiteTurn ? 'White to move' : 'Black to move';
            if (isInCheck(isWhiteTurn)) {
                status = (isWhiteTurn ? 'White' : 'Black') + ' is in CHECK!';
            }
            document.getElementById('statusBar').textContent = status;
        }

        function formatMove(moveData) {
            const m = moveData.move;
            const piece = moveData.piece.toUpperCase();
            const from = FILES[m.fromFile] + (m.fromRank + 1);
            const to = FILES[m.toFile] + (m.toRank + 1);
            const capture = moveData.captured ? 'x' : '';
            const promo = moveData.promotedTo ? '=' + moveData.promotedTo.toUpperCase() : '';

            if (piece === 'P') {
                return (capture ? FILES[m.fromFile] + 'x' : '') + to + promo;
            }
            return piece + capture + to;
        }

        function undoMove() {
            if (moveHistory.length === 0) return;

            const lastMoveData = moveHistory.pop();
            const m = lastMoveData.move;

            board[m.fromRank][m.fromFile] = lastMoveData.piece;
            board[m.toRank][m.toFile] = lastMoveData.captured;

            if (lastMoveData.captured) {
                if (!isWhiteTurn) {
                    capturedBlack.pop();
                } else {
                    capturedWhite.pop();
                }
            }

            isWhiteTurn = !isWhiteTurn;
            lastMove = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1].move : null;
            selectedSquare = null;
            validMoves = [];

            updateUI();
            renderBoard();
        }

        function resetGame() {
            initBoard(initialPosition);
            moveHistory = [];
            isWhiteTurn = true;
            lastMove = null;
            capturedWhite = [];
            capturedBlack = [];
            selectedSquare = null;
            validMoves = [];
            updateUI();
            renderBoard();
        }

        function newGame() {
            positionNumber = Math.floor(Math.random() * 960);
            initialPosition = generateFromNumber(positionNumber);
            document.getElementById('posNum').textContent = positionNumber;
            document.getElementById('setup').textContent = initialPosition.join('');
            resetGame();
        }

        function flipBoard() {
            flipped = !flipped;
            renderBoard();
        }

        // Initialize
        newGame();
    </script>
</body>
</html>
