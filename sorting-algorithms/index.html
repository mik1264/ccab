<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithms - Interactive Visualization - CCAB</title>
    <meta name="description" content="Interactive visualization of sorting algorithms: Bubble Sort, Selection Sort, Insertion Sort, Merge Sort, Quick Sort, and Heap Sort. Watch step-by-step animated comparisons and swaps.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0a1628 0%, #1a2840 100%);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.6);
            color: #00bcd4;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 188, 212, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(0, 188, 212, 0.2);
            transform: translateX(-4px);
        }

        #canvas {
            display: block;
        }

        #info {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            color: #00bcd4;
            font-size: 13px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 188, 212, 0.2);
            z-index: 1000;
            max-width: 280px;
        }

        #info h3 {
            margin-bottom: 10px;
            color: #4dd0e1;
        }

        #info .stat {
            margin: 5px 0;
        }

        #info .stat-label {
            color: #888;
            font-size: 11px;
        }

        #info .stat-value {
            color: #00bcd4;
            font-weight: bold;
        }

        #info p {
            font-size: 11px;
            opacity: 0.8;
            line-height: 1.5;
            margin-top: 10px;
            color: #aaa;
        }

        .complexity-info {
            background: rgba(0, 188, 212, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 11px;
            font-family: monospace;
        }

        .complexity-info div {
            margin: 3px 0;
            color: #80deea;
        }

        .step-display {
            background: rgba(0, 188, 212, 0.15);
            padding: 8px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 12px;
            color: #b2ebf2;
            min-height: 35px;
        }

        #algorithms {
            position: fixed;
            top: 380px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 1000;
        }

        button {
            background: rgba(0, 188, 212, 0.15);
            border: 1px solid rgba(0, 188, 212, 0.4);
            color: #00bcd4;
            padding: 10px 14px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s;
            text-align: left;
        }

        button:hover {
            background: rgba(0, 188, 212, 0.3);
        }

        button.active {
            background: rgba(0, 188, 212, 0.4);
            border-color: #00bcd4;
        }

        .algo-complexity {
            font-size: 9px;
            color: #888;
            margin-top: 2px;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 16px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 188, 212, 0.2);
        }

        .control-group label {
            color: #00bcd4;
            font-size: 11px;
            display: block;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 80px;
            accent-color: #00bcd4;
        }

        .control-group span {
            color: #fff;
            font-size: 10px;
            margin-left: 6px;
        }

        .control-btn {
            padding: 10px 16px;
        }

        .legend {
            position: fixed;
            bottom: 80px;
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border-radius: 10px;
            font-size: 11px;
            color: #aaa;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 188, 212, 0.2);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">← Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div id="info">
        <h3>Sorting Algorithms</h3>
        <div class="stat">
            <span class="stat-label">Algorithm</span>
            <span class="stat-value" id="algo-name">Bubble Sort</span>
        </div>
        <div class="stat">
            <span class="stat-label">Array Size</span>
            <span class="stat-value" id="array-size">50</span>
        </div>
        <div class="stat">
            <span class="stat-label">Comparisons</span>
            <span class="stat-value" id="comparisons">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Swaps</span>
            <span class="stat-value" id="swaps">0</span>
        </div>
        <div class="step-display" id="step-info">Click 'Start' to begin sorting</div>
        <div class="complexity-info" id="complexity">
            <div>Best: O(n)</div>
            <div>Average: O(n²)</div>
            <div>Worst: O(n²)</div>
        </div>
        <p>Visualizes classic sorting algorithms with animated comparisons and swaps. Compare efficiency across different input sizes and initial orderings.</p>
    </div>

    <div id="algorithms">
        <button class="active" data-algo="bubble">
            Bubble Sort
            <div class="algo-complexity">O(n²)</div>
        </button>
        <button data-algo="selection">
            Selection Sort
            <div class="algo-complexity">O(n²)</div>
        </button>
        <button data-algo="insertion">
            Insertion Sort
            <div class="algo-complexity">O(n²)</div>
        </button>
        <button data-algo="merge">
            Merge Sort
            <div class="algo-complexity">O(n log n)</div>
        </button>
        <button data-algo="quick">
            Quick Sort
            <div class="algo-complexity">O(n log n) avg</div>
        </button>
        <button data-algo="heap">
            Heap Sort
            <div class="algo-complexity">O(n log n)</div>
        </button>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>Size: <span id="size-val">50</span></label>
            <input type="range" id="size" min="10" max="200" value="50">
        </div>
        <div class="control-group">
            <label>Speed: <span id="speed-val">20</span>ms</label>
            <input type="range" id="speed" min="1" max="100" value="20">
        </div>
        <button class="control-btn" id="start-btn">Start</button>
        <button class="control-btn" id="step-btn">Step</button>
        <button class="control-btn" id="shuffle-btn">Shuffle</button>
        <button class="control-btn" id="reverse-btn">Reverse</button>
    </div>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #00bcd4;"></div>
            <span>Unsorted</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff5722;"></div>
            <span>Comparing</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ffeb3b;"></div>
            <span>Swapping</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #4caf50;"></div>
            <span>Sorted</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #9c27b0;"></div>
            <span>Pivot (Quick Sort)</span>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let arraySize = 50;
        let speed = 20;
        let algorithm = 'bubble';
        let isRunning = false;
        let isStepping = false;

        let array = [];
        let colors = [];
        let comparisons = 0;
        let swaps = 0;
        let stepInfo = "Click 'Start' to begin sorting";

        const complexities = {
            bubble: { best: 'O(n)', avg: 'O(n²)', worst: 'O(n²)' },
            selection: { best: 'O(n²)', avg: 'O(n²)', worst: 'O(n²)' },
            insertion: { best: 'O(n)', avg: 'O(n²)', worst: 'O(n²)' },
            merge: { best: 'O(n log n)', avg: 'O(n log n)', worst: 'O(n log n)' },
            quick: { best: 'O(n log n)', avg: 'O(n log n)', worst: 'O(n²)' },
            heap: { best: 'O(n log n)', avg: 'O(n log n)', worst: 'O(n log n)' }
        };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            render();
        }

        function generateArray() {
            array = [];
            colors = [];
            for (let i = 0; i < arraySize; i++) {
                array.push(i + 1);
                colors.push('unsorted');
            }
            shuffle();
        }

        function shuffle() {
            comparisons = 0;
            swaps = 0;
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
                colors[i] = 'unsorted';
                colors[j] = 'unsorted';
            }
            colors.fill('unsorted');
            stepInfo = "Array shuffled. Click 'Start' to sort.";
            render();
            updateStats();
        }

        function reverseArray() {
            array.sort((a, b) => b - a);
            colors.fill('unsorted');
            comparisons = 0;
            swaps = 0;
            stepInfo = "Array reversed. Worst case for many algorithms.";
            render();
            updateStats();
        }

        function render() {
            ctx.fillStyle = '#0a1628';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const padding = 100;
            const barWidth = (canvas.width - 2 * padding) / array.length;
            const maxHeight = canvas.height - 200;

            for (let i = 0; i < array.length; i++) {
                const barHeight = (array[i] / arraySize) * maxHeight;
                const x = padding + i * barWidth;
                const y = canvas.height - 100 - barHeight;

                let color;
                switch (colors[i]) {
                    case 'comparing':
                        color = '#ff5722';
                        break;
                    case 'swapping':
                        color = '#ffeb3b';
                        break;
                    case 'sorted':
                        color = '#4caf50';
                        break;
                    case 'pivot':
                        color = '#9c27b0';
                        break;
                    case 'current':
                        color = '#ff9800';
                        break;
                    default:
                        // Gradient based on value
                        const hue = 180 + (array[i] / arraySize) * 30;
                        color = `hsl(${hue}, 70%, 50%)`;
                }

                ctx.fillStyle = color;
                ctx.fillRect(x, y, barWidth - 1, barHeight);
            }
        }

        function updateStats() {
            document.getElementById('array-size').textContent = arraySize;
            document.getElementById('comparisons').textContent = comparisons.toLocaleString();
            document.getElementById('swaps').textContent = swaps.toLocaleString();
            document.getElementById('step-info').textContent = stepInfo;

            const c = complexities[algorithm];
            document.getElementById('complexity').innerHTML = `
                <div>Best: ${c.best}</div>
                <div>Average: ${c.avg}</div>
                <div>Worst: ${c.worst}</div>
            `;
        }

        function delay() {
            return new Promise(resolve => setTimeout(resolve, speed));
        }

        // ============ SORTING ALGORITHMS ============

        async function bubbleSort() {
            for (let i = 0; i < array.length - 1 && isRunning; i++) {
                let swapped = false;

                for (let j = 0; j < array.length - i - 1 && isRunning; j++) {
                    colors[j] = 'comparing';
                    colors[j + 1] = 'comparing';
                    comparisons++;
                    stepInfo = `Comparing indices ${j} and ${j + 1}`;
                    render();
                    updateStats();
                    await delay();

                    if (array[j] > array[j + 1]) {
                        colors[j] = 'swapping';
                        colors[j + 1] = 'swapping';
                        [array[j], array[j + 1]] = [array[j + 1], array[j]];
                        swaps++;
                        stepInfo = `Swapping ${array[j + 1]} and ${array[j]}`;
                        render();
                        updateStats();
                        await delay();
                        swapped = true;
                    }

                    colors[j] = 'unsorted';
                    colors[j + 1] = 'unsorted';
                }

                colors[array.length - i - 1] = 'sorted';

                if (!swapped) {
                    // Array is sorted
                    for (let k = 0; k < array.length - i - 1; k++) {
                        colors[k] = 'sorted';
                    }
                    break;
                }
            }
            colors[0] = 'sorted';
        }

        async function selectionSort() {
            for (let i = 0; i < array.length - 1 && isRunning; i++) {
                let minIdx = i;
                colors[i] = 'current';

                for (let j = i + 1; j < array.length && isRunning; j++) {
                    colors[j] = 'comparing';
                    comparisons++;
                    stepInfo = `Finding minimum: comparing with index ${j}`;
                    render();
                    updateStats();
                    await delay();

                    if (array[j] < array[minIdx]) {
                        if (minIdx !== i) colors[minIdx] = 'unsorted';
                        minIdx = j;
                        colors[minIdx] = 'pivot';
                    } else {
                        colors[j] = 'unsorted';
                    }
                }

                if (minIdx !== i) {
                    colors[i] = 'swapping';
                    colors[minIdx] = 'swapping';
                    [array[i], array[minIdx]] = [array[minIdx], array[i]];
                    swaps++;
                    stepInfo = `Swapping minimum to position ${i}`;
                    render();
                    updateStats();
                    await delay();
                    colors[minIdx] = 'unsorted';
                }

                colors[i] = 'sorted';
            }
            colors[array.length - 1] = 'sorted';
        }

        async function insertionSort() {
            colors[0] = 'sorted';

            for (let i = 1; i < array.length && isRunning; i++) {
                const key = array[i];
                let j = i - 1;

                colors[i] = 'current';
                stepInfo = `Inserting element ${key}`;
                render();
                updateStats();
                await delay();

                while (j >= 0 && isRunning) {
                    colors[j] = 'comparing';
                    comparisons++;
                    render();
                    updateStats();
                    await delay();

                    if (array[j] > key) {
                        colors[j] = 'swapping';
                        colors[j + 1] = 'swapping';
                        array[j + 1] = array[j];
                        swaps++;
                        render();
                        await delay();
                        colors[j + 1] = 'sorted';
                        j--;
                    } else {
                        colors[j] = 'sorted';
                        break;
                    }
                }

                array[j + 1] = key;
                colors[j + 1] = 'sorted';
                stepInfo = `Inserted ${key} at position ${j + 1}`;
                render();
                updateStats();
            }
        }

        async function mergeSort() {
            await mergeSortHelper(0, array.length - 1);
            colors.fill('sorted');
            render();
        }

        async function mergeSortHelper(left, right) {
            if (left >= right || !isRunning) return;

            const mid = Math.floor((left + right) / 2);
            stepInfo = `Dividing: [${left}...${mid}] and [${mid + 1}...${right}]`;
            render();
            updateStats();
            await delay();

            await mergeSortHelper(left, mid);
            await mergeSortHelper(mid + 1, right);
            await merge(left, mid, right);
        }

        async function merge(left, mid, right) {
            const leftArr = array.slice(left, mid + 1);
            const rightArr = array.slice(mid + 1, right + 1);

            let i = 0, j = 0, k = left;

            stepInfo = `Merging: [${left}...${mid}] with [${mid + 1}...${right}]`;

            while (i < leftArr.length && j < rightArr.length && isRunning) {
                colors[left + i] = 'comparing';
                colors[mid + 1 + j] = 'comparing';
                comparisons++;
                render();
                updateStats();
                await delay();

                if (leftArr[i] <= rightArr[j]) {
                    array[k] = leftArr[i];
                    colors[k] = 'swapping';
                    i++;
                } else {
                    array[k] = rightArr[j];
                    colors[k] = 'swapping';
                    j++;
                    swaps++;
                }
                render();
                await delay();
                colors[k] = 'sorted';
                k++;
            }

            while (i < leftArr.length && isRunning) {
                array[k] = leftArr[i];
                colors[k] = 'sorted';
                i++;
                k++;
                render();
                await delay();
            }

            while (j < rightArr.length && isRunning) {
                array[k] = rightArr[j];
                colors[k] = 'sorted';
                j++;
                k++;
                render();
                await delay();
            }
        }

        async function quickSort() {
            await quickSortHelper(0, array.length - 1);
            colors.fill('sorted');
            render();
        }

        async function quickSortHelper(low, high) {
            if (low >= high || !isRunning) return;

            const pivotIdx = await partition(low, high);
            await quickSortHelper(low, pivotIdx - 1);
            await quickSortHelper(pivotIdx + 1, high);
        }

        async function partition(low, high) {
            const pivot = array[high];
            colors[high] = 'pivot';
            stepInfo = `Pivot: ${pivot} at index ${high}`;
            render();
            updateStats();
            await delay();

            let i = low - 1;

            for (let j = low; j < high && isRunning; j++) {
                colors[j] = 'comparing';
                comparisons++;
                render();
                updateStats();
                await delay();

                if (array[j] < pivot) {
                    i++;
                    if (i !== j) {
                        colors[i] = 'swapping';
                        colors[j] = 'swapping';
                        [array[i], array[j]] = [array[j], array[i]];
                        swaps++;
                        render();
                        await delay();
                    }
                    colors[i] = 'unsorted';
                }
                colors[j] = 'unsorted';
            }

            colors[high] = 'swapping';
            colors[i + 1] = 'swapping';
            [array[i + 1], array[high]] = [array[high], array[i + 1]];
            swaps++;
            render();
            await delay();

            colors[i + 1] = 'sorted';
            colors[high] = 'unsorted';

            return i + 1;
        }

        async function heapSort() {
            // Build max heap
            stepInfo = 'Building max heap...';
            render();
            updateStats();

            for (let i = Math.floor(array.length / 2) - 1; i >= 0 && isRunning; i--) {
                await heapify(array.length, i);
            }

            // Extract elements from heap
            for (let i = array.length - 1; i > 0 && isRunning; i--) {
                colors[0] = 'swapping';
                colors[i] = 'swapping';
                [array[0], array[i]] = [array[i], array[0]];
                swaps++;
                stepInfo = `Moving max ${array[i]} to position ${i}`;
                render();
                updateStats();
                await delay();

                colors[i] = 'sorted';
                await heapify(i, 0);
            }
            colors[0] = 'sorted';
        }

        async function heapify(n, i) {
            let largest = i;
            const left = 2 * i + 1;
            const right = 2 * i + 2;

            if (left < n) {
                colors[left] = 'comparing';
                comparisons++;
                if (array[left] > array[largest]) {
                    largest = left;
                }
            }

            if (right < n) {
                colors[right] = 'comparing';
                comparisons++;
                if (array[right] > array[largest]) {
                    largest = right;
                }
            }

            render();
            updateStats();
            await delay();

            if (left < n) colors[left] = 'unsorted';
            if (right < n) colors[right] = 'unsorted';

            if (largest !== i && isRunning) {
                colors[i] = 'swapping';
                colors[largest] = 'swapping';
                [array[i], array[largest]] = [array[largest], array[i]];
                swaps++;
                render();
                await delay();
                colors[i] = 'unsorted';
                colors[largest] = 'unsorted';

                await heapify(n, largest);
            }
        }

        async function runSort() {
            isRunning = true;
            comparisons = 0;
            swaps = 0;
            colors.fill('unsorted');
            document.getElementById('start-btn').textContent = 'Stop';

            switch (algorithm) {
                case 'bubble':
                    await bubbleSort();
                    break;
                case 'selection':
                    await selectionSort();
                    break;
                case 'insertion':
                    await insertionSort();
                    break;
                case 'merge':
                    await mergeSort();
                    break;
                case 'quick':
                    await quickSort();
                    break;
                case 'heap':
                    await heapSort();
                    break;
            }

            if (isRunning) {
                stepInfo = `Sorting complete! ${comparisons.toLocaleString()} comparisons, ${swaps.toLocaleString()} swaps`;
                colors.fill('sorted');
                render();
                updateStats();
            }

            isRunning = false;
            document.getElementById('start-btn').textContent = 'Start';
        }

        // Event listeners
        document.getElementById('size').addEventListener('input', (e) => {
            arraySize = parseInt(e.target.value);
            document.getElementById('size-val').textContent = arraySize;
            generateArray();
            updateStats();
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            document.getElementById('speed-val').textContent = speed;
        });

        document.getElementById('start-btn').addEventListener('click', () => {
            if (isRunning) {
                isRunning = false;
                document.getElementById('start-btn').textContent = 'Start';
            } else {
                runSort();
            }
        });

        document.getElementById('shuffle-btn').addEventListener('click', () => {
            if (!isRunning) shuffle();
        });

        document.getElementById('reverse-btn').addEventListener('click', () => {
            if (!isRunning) reverseArray();
        });

        // Algorithm selection
        document.querySelectorAll('#algorithms button').forEach(btn => {
            btn.addEventListener('click', () => {
                if (isRunning) return;
                document.querySelectorAll('#algorithms button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                algorithm = btn.dataset.algo;

                const names = {
                    bubble: 'Bubble Sort',
                    selection: 'Selection Sort',
                    insertion: 'Insertion Sort',
                    merge: 'Merge Sort',
                    quick: 'Quick Sort',
                    heap: 'Heap Sort'
                };
                document.getElementById('algo-name').textContent = names[algorithm];

                colors.fill('unsorted');
                comparisons = 0;
                swaps = 0;
                stepInfo = "Click 'Start' to begin sorting";
                render();
                updateStats();
            });
        });

        // Initialize
        window.addEventListener('resize', resize);
        generateArray();
        resize();
    </script>
</body>
</html>
