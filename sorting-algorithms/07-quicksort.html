<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Quicksort - Sorting Algorithm Theater</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; }
canvas { display: block; }
a.back-link { position: fixed; top: 15px; left: 15px; color: #8ab4f8; text-decoration: none; z-index: 100; font-size: 14px; opacity: 0.8; }
a.back-link:hover { opacity: 1; }

.controls {
    position: fixed; top: 15px; right: 15px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 16px; min-width: 240px;
    border: 1px solid rgba(255,255,255,0.1);
}
.controls h3 { font-size: 14px; margin-bottom: 10px; color: #8ab4f8; }
.controls label { display: block; font-size: 12px; margin: 8px 0 4px; color: #aaa; }
.controls input[type="range"] { width: 100%; accent-color: #8ab4f8; }
.controls .value { float: right; color: #8ab4f8; font-size: 12px; }
.btn { background: rgba(138,180,248,0.2); color: #8ab4f8; border: 1px solid rgba(138,180,248,0.3); padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; margin: 3px 2px; transition: all 0.2s; }
.btn:hover { background: rgba(138,180,248,0.35); }
.btn.active { background: rgba(138,180,248,0.5); }
.btn-row { display: flex; gap: 4px; flex-wrap: wrap; margin-top: 8px; }
.pivot-group { margin-top: 8px; }
.pivot-group span { font-size: 11px; color: #aaa; display: block; margin-bottom: 4px; }

.stats {
    position: fixed; bottom: 15px; left: 15px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px;
    border: 1px solid rgba(255,255,255,0.1);
    font-size: 13px;
}
.stats div { margin: 3px 0; }
.stats span { color: #8ab4f8; font-weight: 600; }

.info {
    position: fixed; bottom: 15px; right: 15px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px; max-width: 300px;
    border: 1px solid rgba(255,255,255,0.1);
    font-size: 12px; line-height: 1.5;
}
.info h4 { color: #8ab4f8; margin-bottom: 6px; font-size: 14px; }
.info .complexity { color: #ffd700; font-family: monospace; }
</style>
</head>
<body>
<a href="index.html" class="back-link">&larr; Back to Sorting Algorithms</a>

<canvas id="canvas"></canvas>

<div class="controls">
    <h3>Quicksort</h3>
    <label>Speed <span class="value" id="speedVal">50</span></label>
    <input type="range" id="speed" min="1" max="200" value="50">
    <label>Array Size <span class="value" id="sizeVal">60</span></label>
    <input type="range" id="size" min="10" max="200" value="60">
    <div class="pivot-group">
        <span>Pivot Strategy:</span>
        <div class="btn-row">
            <button class="btn active" data-pivot="last">Last</button>
            <button class="btn" data-pivot="first">First</button>
            <button class="btn" data-pivot="median">Median-3</button>
            <button class="btn" data-pivot="random">Random</button>
        </div>
    </div>
    <div class="btn-row">
        <button class="btn" id="newArr">New Array</button>
        <button class="btn" id="startBtn">Start</button>
        <button class="btn" id="pauseBtn">Pause</button>
    </div>
</div>

<div class="stats">
    <div>Comparisons: <span id="comparisons">0</span></div>
    <div>Swaps: <span id="swaps">0</span></div>
    <div>Array Accesses: <span id="accesses">0</span></div>
    <div>Recursion Depth: <span id="depth">0</span></div>
    <div>Status: <span id="status">Ready</span></div>
</div>

<div class="info">
    <h4>Quicksort</h4>
    <p>Choose a pivot, partition around it (smaller left, larger right), recurse on both sides. The most widely used sorting algorithm in practice.</p>
    <p style="margin-top:6px;">Average: <span class="complexity">O(n log n)</span><br>
    Worst: <span class="complexity">O(n&sup2;)</span> (bad pivots)<br>
    Space: <span class="complexity">O(log n)</span> stack<br>
    Stable: No</p>
    <p style="margin-top:6px; color:#aaa;">Magenta = pivot. Regions colored by recursion depth. Watch partitioning in action.</p>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

const speedSlider = document.getElementById('speed');
const sizeSlider = document.getElementById('size');
const speedVal = document.getElementById('speedVal');
const sizeVal = document.getElementById('sizeVal');
const compEl = document.getElementById('comparisons');
const swapEl = document.getElementById('swaps');
const accEl = document.getElementById('accesses');
const depthEl = document.getElementById('depth');
const statusEl = document.getElementById('status');

let arr = [], n = 60;
let comparisons = 0, swaps = 0, accesses = 0;
let currentDepth = 0, maxDepth = 0;
let sorting = false, paused = false;
let operations = [], opIndex = 0;
let pivotStrategy = 'last';

let barStates = [];
let barDepths = [];
let pivotIdx = -1;
let partitionRanges = []; // stack of active partition ranges

const depthColors = [
    '#ff6b6b', '#ffa06b', '#ffd93d', '#6bff6b', '#6bd4ff',
    '#a06bff', '#ff6bda', '#ff9e9e', '#9effa0', '#9ed4ff',
    '#d4a0ff', '#ffcf6b', '#6bffd9', '#ff6ba0', '#c8ff6b'
];

function generateArray() {
    n = parseInt(sizeSlider.value);
    arr = [];
    for (let i = 0; i < n; i++) arr.push(Math.random() * 0.85 + 0.1);
    barStates = new Array(n).fill('default');
    barDepths = new Array(n).fill(0);
    comparisons = 0; swaps = 0; accesses = 0;
    currentDepth = 0; maxDepth = 0;
    operations = []; opIndex = 0;
    sorting = false; paused = false;
    pivotIdx = -1;
    partitionRanges = [];
    updateStats();
    statusEl.textContent = 'Ready';
}

function updateStats() {
    compEl.textContent = comparisons;
    swapEl.textContent = swaps;
    accEl.textContent = accesses;
    depthEl.textContent = currentDepth + ' (max: ' + maxDepth + ')';
}

function buildQuicksortOps(a) {
    const ops = [];
    function choosePivot(lo, hi) {
        if (pivotStrategy === 'first') {
            ops.push({ type: 'swap', i: lo, j: hi });
            const t = a[lo]; a[lo] = a[hi]; a[hi] = t;
            return;
        }
        if (pivotStrategy === 'random') {
            const r = lo + Math.floor(Math.random() * (hi - lo + 1));
            ops.push({ type: 'swap', i: r, j: hi });
            const t = a[r]; a[r] = a[hi]; a[hi] = t;
            return;
        }
        if (pivotStrategy === 'median') {
            const mid = Math.floor((lo + hi) / 2);
            // Median of three: a[lo], a[mid], a[hi]
            if (a[lo] > a[mid]) { const t = a[lo]; a[lo] = a[mid]; a[mid] = t; ops.push({ type: 'swap', i: lo, j: mid }); }
            if (a[lo] > a[hi]) { const t = a[lo]; a[lo] = a[hi]; a[hi] = t; ops.push({ type: 'swap', i: lo, j: hi }); }
            if (a[mid] > a[hi]) { const t = a[mid]; a[mid] = a[hi]; a[hi] = t; ops.push({ type: 'swap', i: mid, j: hi }); }
            // Median is at mid, move to hi-1 as pivot position... but for Lomuto put at hi
            ops.push({ type: 'swap', i: mid, j: hi });
            const t = a[mid]; a[mid] = a[hi]; a[hi] = t;
            return;
        }
        // 'last' - pivot is already at hi
    }

    function quicksort(lo, hi, depth) {
        if (lo >= hi) {
            if (lo === hi) ops.push({ type: 'sorted-single', idx: lo, depth });
            return;
        }
        if (depth > maxDepth) maxDepth = depth;
        ops.push({ type: 'partition-start', lo, hi, depth });
        choosePivot(lo, hi);
        ops.push({ type: 'pivot', idx: hi, depth });
        const pivot = a[hi];
        let i = lo;
        for (let j = lo; j < hi; j++) {
            ops.push({ type: 'compare', i: j, pivot: hi, depth });
            if (a[j] < pivot) {
                if (i !== j) {
                    ops.push({ type: 'swap', i, j, depth });
                    const t = a[i]; a[i] = a[j]; a[j] = t;
                }
                i++;
            }
        }
        ops.push({ type: 'swap', i, j: hi, depth });
        const t = a[i]; a[i] = a[hi]; a[hi] = t;
        ops.push({ type: 'pivot-placed', idx: i, depth });
        ops.push({ type: 'partition-end', lo, hi, pivotPos: i, depth });

        quicksort(lo, i - 1, depth + 1);
        quicksort(i + 1, hi, depth + 1);
    }

    quicksort(0, a.length - 1, 0);
    ops.push({ type: 'done' });
    return ops;
}

function startSort() {
    if (sorting && !paused) return;
    if (paused) { paused = false; statusEl.textContent = 'Sorting...'; return; }
    const arrCopy = arr.slice();
    maxDepth = 0;
    operations = buildQuicksortOps(arrCopy);
    opIndex = 0;
    comparisons = 0; swaps = 0; accesses = 0;
    currentDepth = 0;
    sorting = true; paused = false;
    barStates = new Array(n).fill('default');
    barDepths = new Array(n).fill(0);
    pivotIdx = -1;
    statusEl.textContent = 'Sorting...';
}

function processOps() {
    if (!sorting || paused) return;
    const speed = parseInt(speedSlider.value);
    const opsPerFrame = Math.max(1, Math.floor(speed / 5));

    for (let s = 0; s < opsPerFrame && opIndex < operations.length; s++) {
        const op = operations[opIndex++];
        switch (op.type) {
            case 'partition-start':
                currentDepth = op.depth;
                for (let k = op.lo; k <= op.hi; k++) barDepths[k] = op.depth;
                break;
            case 'pivot':
                pivotIdx = op.idx;
                barStates[op.idx] = 'pivot';
                break;
            case 'compare':
                comparisons++; accesses += 2;
                // Reset non-pivot states in current range
                for (let k = 0; k < n; k++) {
                    if (barStates[k] === 'comparing') barStates[k] = 'default';
                }
                barStates[op.i] = 'comparing';
                break;
            case 'swap':
                if (op.i !== undefined && op.j !== undefined && op.i !== op.j) {
                    swaps++; accesses += 4;
                    const t = arr[op.i]; arr[op.i] = arr[op.j]; arr[op.j] = t;
                    // Swap depths too
                    const td = barDepths[op.i]; barDepths[op.i] = barDepths[op.j]; barDepths[op.j] = td;
                    barStates[op.i] = 'swapping';
                    barStates[op.j] = 'swapping';
                }
                break;
            case 'pivot-placed':
                barStates[op.idx] = 'sorted';
                pivotIdx = -1;
                break;
            case 'sorted-single':
                barStates[op.idx] = 'sorted';
                break;
            case 'partition-end':
                for (let k = 0; k < n; k++) {
                    if (barStates[k] === 'comparing' || barStates[k] === 'swapping') barStates[k] = 'default';
                }
                break;
            case 'done':
                sorting = false;
                for (let k = 0; k < n; k++) barStates[k] = 'sorted';
                pivotIdx = -1;
                statusEl.textContent = 'Complete!';
                break;
        }
        updateStats();
    }
}

function getBarColor(i) {
    const state = barStates[i];
    if (state === 'sorted') return '#4ade80';
    if (state === 'pivot') return '#ff44ff';
    if (state === 'comparing') return '#ffffff';
    if (state === 'swapping') return '#ffd93d';
    // Color by depth
    if (sorting && barDepths[i] > 0) {
        const d = barDepths[i] % depthColors.length;
        const c = depthColors[d];
        return c + 'cc'; // slightly transparent
    }
    const hue = arr[i] * 270;
    return `hsl(${hue}, 80%, 55%)`;
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    const topPad = 60, bottomPad = 40;
    const barAreaH = H - topPad - bottomPad;
    const gap = Math.max(1, Math.floor(W * 0.002));
    const totalBarW = W - 40;
    const barW = Math.max(2, (totalBarW - (n - 1) * gap) / n);
    const startX = (W - (barW * n + gap * (n - 1))) / 2;

    for (let i = 0; i < n; i++) {
        const x = startX + i * (barW + gap);
        const bh = arr[i] * barAreaH;
        const y = topPad + barAreaH - bh;
        ctx.fillStyle = getBarColor(i);
        ctx.fillRect(x, y, barW, bh);

        // Pivot marker
        if (i === pivotIdx) {
            ctx.fillStyle = '#ff44ff';
            ctx.font = 'bold 10px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('P', x + barW / 2, y - 5);
            ctx.textAlign = 'left';
        }
    }

    // Title
    ctx.fillStyle = '#8ab4f8';
    ctx.font = 'bold 16px system-ui';
    ctx.fillText('Quicksort', startX, 30);
    ctx.font = '12px system-ui';
    ctx.fillStyle = '#666';
    ctx.fillText('Partition around pivot, recurse on halves', startX + 100, 30);

    // Legend
    const ly = H - 20;
    ctx.font = '11px system-ui';
    ctx.fillStyle = '#ff44ff'; ctx.fillRect(startX, ly - 8, 10, 10);
    ctx.fillStyle = '#aaa'; ctx.fillText('Pivot', startX + 14, ly);
    ctx.fillStyle = '#fff'; ctx.fillRect(startX + 60, ly - 8, 10, 10);
    ctx.fillStyle = '#aaa'; ctx.fillText('Compare', startX + 74, ly);
    ctx.fillStyle = '#ffd93d'; ctx.fillRect(startX + 140, ly - 8, 10, 10);
    ctx.fillStyle = '#aaa'; ctx.fillText('Swap', startX + 154, ly);
    ctx.fillStyle = '#4ade80'; ctx.fillRect(startX + 200, ly - 8, 10, 10);
    ctx.fillStyle = '#aaa'; ctx.fillText('Sorted', startX + 214, ly);

    processOps();
    requestAnimationFrame(draw);
}

// Pivot strategy buttons
document.querySelectorAll('[data-pivot]').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('[data-pivot]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        pivotStrategy = btn.dataset.pivot;
    });
});

speedSlider.addEventListener('input', () => { speedVal.textContent = speedSlider.value; });
sizeSlider.addEventListener('input', () => { sizeVal.textContent = sizeSlider.value; if (!sorting) generateArray(); });
document.getElementById('newArr').addEventListener('click', () => { sorting = false; generateArray(); });
document.getElementById('startBtn').addEventListener('click', startSort);
document.getElementById('pauseBtn').addEventListener('click', () => {
    if (sorting) { paused = !paused; statusEl.textContent = paused ? 'Paused' : 'Sorting...'; }
});

window.reset = function() { sorting = false; generateArray(); };

generateArray();
draw();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
