<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Merge Sort - Sorting Algorithm Theater</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; }
canvas { display: block; }
a.back-link { position: fixed; top: 15px; left: 15px; color: #8ab4f8; text-decoration: none; z-index: 100; font-size: 14px; opacity: 0.8; }
a.back-link:hover { opacity: 1; }

.controls {
    position: fixed; top: 15px; right: 15px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 16px; min-width: 220px;
    border: 1px solid rgba(255,255,255,0.1);
}
.controls h3 { font-size: 14px; margin-bottom: 10px; color: #8ab4f8; }
.controls label { display: block; font-size: 12px; margin: 8px 0 4px; color: #aaa; }
.controls input[type="range"] { width: 100%; accent-color: #8ab4f8; }
.controls .value { float: right; color: #8ab4f8; font-size: 12px; }
.btn { background: rgba(138,180,248,0.2); color: #8ab4f8; border: 1px solid rgba(138,180,248,0.3); padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 13px; margin: 4px 2px; transition: all 0.2s; }
.btn:hover { background: rgba(138,180,248,0.35); }
.btn.active { background: rgba(138,180,248,0.5); }
.btn-row { display: flex; gap: 4px; flex-wrap: wrap; margin-top: 8px; }

.stats {
    position: fixed; bottom: 15px; left: 15px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px;
    border: 1px solid rgba(255,255,255,0.1);
    font-size: 13px;
}
.stats div { margin: 3px 0; }
.stats span { color: #8ab4f8; font-weight: 600; }

.info {
    position: fixed; bottom: 15px; right: 15px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px; max-width: 300px;
    border: 1px solid rgba(255,255,255,0.1);
    font-size: 12px; line-height: 1.5;
}
.info h4 { color: #8ab4f8; margin-bottom: 6px; font-size: 14px; }
.info .complexity { color: #ffd700; font-family: monospace; }
</style>
</head>
<body>
<a href="index.html" class="back-link">&larr; Back to Sorting Algorithms</a>

<canvas id="canvas"></canvas>

<div class="controls">
    <h3>Merge Sort</h3>
    <label>Speed <span class="value" id="speedVal">50</span></label>
    <input type="range" id="speed" min="1" max="200" value="50">
    <label>Array Size <span class="value" id="sizeVal">60</span></label>
    <input type="range" id="size" min="10" max="200" value="60">
    <div class="btn-row">
        <button class="btn" id="newArr">New Array</button>
        <button class="btn" id="startBtn">Start</button>
        <button class="btn" id="pauseBtn">Pause</button>
    </div>
</div>

<div class="stats">
    <div>Comparisons: <span id="comparisons">0</span></div>
    <div>Array Accesses: <span id="accesses">0</span></div>
    <div>Recursion Depth: <span id="depth">0</span></div>
    <div>Status: <span id="status">Ready</span></div>
</div>

<div class="info">
    <h4>Merge Sort</h4>
    <p>A divide-and-conquer algorithm that splits the array into halves, recursively sorts them, then merges the sorted halves.</p>
    <p style="margin-top:6px;">Time: <span class="complexity">O(n log n)</span> guaranteed<br>
    Space: <span class="complexity">O(n)</span> auxiliary<br>
    Stable: Yes</p>
    <p style="margin-top:6px; color:#aaa;">Colors show recursion depth levels. The auxiliary array is shown below during merges.</p>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

const speedSlider = document.getElementById('speed');
const sizeSlider = document.getElementById('size');
const speedVal = document.getElementById('speedVal');
const sizeVal = document.getElementById('sizeVal');
const compEl = document.getElementById('comparisons');
const accEl = document.getElementById('accesses');
const depthEl = document.getElementById('depth');
const statusEl = document.getElementById('status');

let arr = [];
let auxArr = [];
let n = 60;
let comparisons = 0;
let accesses = 0;
let currentDepth = 0;
let maxDepth = 0;
let sorting = false;
let paused = false;
let sortGen = null;
let operations = [];
let opIndex = 0;

// State per bar
let barStates = []; // 'default', 'comparing', 'merging', 'sorted', 'aux'
let barDepths = [];
let auxDisplay = []; // auxiliary array visual
let activeRange = null;
let mergeLeft = -1, mergeRight = -1, mergeMid = -1;

const depthColors = [
    '#ff6b6b', '#ffa06b', '#ffd93d', '#6bff6b', '#6bd4ff',
    '#a06bff', '#ff6bda', '#ff9e9e', '#9effa0', '#9ed4ff',
    '#d4a0ff', '#ffcf6b', '#6bffd9', '#ff6ba0', '#c8ff6b'
];

function generateArray() {
    n = parseInt(sizeSlider.value);
    arr = [];
    for (let i = 0; i < n; i++) {
        arr.push(Math.random() * 0.85 + 0.1);
    }
    barStates = new Array(n).fill('default');
    barDepths = new Array(n).fill(0);
    auxDisplay = [];
    comparisons = 0;
    accesses = 0;
    currentDepth = 0;
    maxDepth = 0;
    operations = [];
    opIndex = 0;
    sorting = false;
    paused = false;
    sortGen = null;
    activeRange = null;
    updateStats();
}

function updateStats() {
    compEl.textContent = comparisons;
    accEl.textContent = accesses;
    depthEl.textContent = currentDepth + ' (max: ' + maxDepth + ')';
}

// Generate merge sort operations (non-recursive generator for step-by-step)
function buildMergeSortOps(a) {
    const ops = [];
    function mergeSort(lo, hi, depth) {
        if (lo >= hi) return;
        if (depth > maxDepth) maxDepth = depth;
        const mid = Math.floor((lo + hi) / 2);
        ops.push({ type: 'divide', lo, hi, mid, depth });
        mergeSort(lo, mid, depth + 1);
        mergeSort(mid + 1, hi, depth + 1);
        // Merge
        ops.push({ type: 'merge-start', lo, hi, mid, depth });
        const temp = [];
        let i = lo, j = mid + 1;
        while (i <= mid && j <= hi) {
            ops.push({ type: 'compare', i, j, depth });
            if (a[i] <= a[j]) {
                temp.push(a[i]);
                ops.push({ type: 'copy-left', idx: i, auxPos: temp.length - 1, depth });
                i++;
            } else {
                temp.push(a[j]);
                ops.push({ type: 'copy-right', idx: j, auxPos: temp.length - 1, depth });
                j++;
            }
        }
        while (i <= mid) {
            temp.push(a[i]);
            ops.push({ type: 'copy-left', idx: i, auxPos: temp.length - 1, depth });
            i++;
        }
        while (j <= hi) {
            temp.push(a[j]);
            ops.push({ type: 'copy-right', idx: j, auxPos: temp.length - 1, depth });
            j++;
        }
        for (let k = 0; k < temp.length; k++) {
            a[lo + k] = temp[k];
            ops.push({ type: 'write-back', idx: lo + k, val: temp[k], depth, lo, hi });
        }
        ops.push({ type: 'merge-end', lo, hi, depth });
    }
    mergeSort(0, a.length - 1, 0);
    ops.push({ type: 'done' });
    return ops;
}

function startSort() {
    if (sorting && !paused) return;
    if (paused) {
        paused = false;
        statusEl.textContent = 'Sorting...';
        return;
    }
    const arrCopy = arr.slice();
    maxDepth = 0;
    operations = buildMergeSortOps(arrCopy);
    opIndex = 0;
    comparisons = 0;
    accesses = 0;
    currentDepth = 0;
    sorting = true;
    paused = false;
    barStates = new Array(n).fill('default');
    barDepths = new Array(n).fill(0);
    auxDisplay = [];
    statusEl.textContent = 'Sorting...';
}

function processOps() {
    if (!sorting || paused) return;
    const speed = parseInt(speedSlider.value);
    const opsPerFrame = Math.max(1, Math.floor(speed / 5));

    for (let s = 0; s < opsPerFrame && opIndex < operations.length; s++) {
        const op = operations[opIndex++];
        switch (op.type) {
            case 'divide':
                currentDepth = op.depth;
                for (let k = op.lo; k <= op.hi; k++) {
                    barDepths[k] = op.depth;
                }
                activeRange = { lo: op.lo, hi: op.hi, mid: op.mid };
                break;
            case 'merge-start':
                currentDepth = op.depth;
                activeRange = { lo: op.lo, hi: op.hi, mid: op.mid };
                auxDisplay = [];
                for (let k = op.lo; k <= op.hi; k++) {
                    barStates[k] = 'merging';
                }
                break;
            case 'compare':
                comparisons++;
                accesses += 2;
                barStates.fill('default');
                if (activeRange) {
                    for (let k = activeRange.lo; k <= activeRange.hi; k++) {
                        barStates[k] = 'merging';
                    }
                }
                barStates[op.i] = 'comparing';
                barStates[op.j] = 'comparing';
                currentDepth = op.depth;
                break;
            case 'copy-left':
            case 'copy-right':
                accesses++;
                auxDisplay.push({ val: arr[op.idx], depth: op.depth });
                break;
            case 'write-back':
                arr[op.idx] = op.val;
                accesses += 2;
                barStates[op.idx] = 'merging';
                barDepths[op.idx] = op.depth;
                break;
            case 'merge-end':
                for (let k = 0; k < n; k++) {
                    barStates[k] = 'default';
                }
                auxDisplay = [];
                activeRange = null;
                break;
            case 'done':
                sorting = false;
                for (let k = 0; k < n; k++) {
                    barStates[k] = 'sorted';
                }
                auxDisplay = [];
                statusEl.textContent = 'Complete!';
                break;
        }
        updateStats();
    }
}

function getBarColor(i) {
    const state = barStates[i];
    if (state === 'sorted') return '#4ade80';
    if (state === 'comparing') return '#ffffff';
    if (state === 'merging') {
        const d = barDepths[i] % depthColors.length;
        return depthColors[d];
    }
    // Default: rainbow based on value
    const hue = arr[i] * 270;
    return `hsl(${hue}, 80%, 55%)`;
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    const mainH = auxDisplay.length > 0 ? H * 0.6 : H * 0.85;
    const topPad = 60;
    const bottomPad = 20;
    const barAreaH = mainH - topPad - bottomPad;
    const gap = Math.max(1, Math.floor(W * 0.002));
    const totalBarW = W - 40;
    const barW = Math.max(2, (totalBarW - (n - 1) * gap) / n);
    const startX = (W - (barW * n + gap * (n - 1))) / 2;

    // Draw active range indicator
    if (activeRange) {
        const rx = startX + activeRange.lo * (barW + gap) - 2;
        const rw = (activeRange.hi - activeRange.lo + 1) * (barW + gap) - gap + 4;
        ctx.strokeStyle = 'rgba(138,180,248,0.3)';
        ctx.lineWidth = 1;
        ctx.strokeRect(rx, topPad - 5, rw, barAreaH + 10);

        // Division line
        if (activeRange.mid !== undefined) {
            const mx = startX + (activeRange.mid + 0.5) * (barW + gap) + barW / 2;
            ctx.setLineDash([4, 4]);
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.beginPath();
            ctx.moveTo(mx, topPad);
            ctx.lineTo(mx, topPad + barAreaH);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }

    // Draw bars
    for (let i = 0; i < n; i++) {
        const x = startX + i * (barW + gap);
        const bh = arr[i] * barAreaH;
        const y = topPad + barAreaH - bh;

        ctx.fillStyle = getBarColor(i);
        ctx.fillRect(x, y, barW, bh);

        // Depth indicator at bottom
        if (sorting && barDepths[i] > 0) {
            const d = barDepths[i] % depthColors.length;
            ctx.fillStyle = depthColors[d];
            ctx.globalAlpha = 0.4;
            ctx.fillRect(x, topPad + barAreaH + 2, barW, 3);
            ctx.globalAlpha = 1;
        }
    }

    // Draw auxiliary array
    if (auxDisplay.length > 0) {
        const auxTop = mainH + 20;
        const auxH = H - auxTop - 60;
        const auxBarW = Math.max(2, (totalBarW - (auxDisplay.length - 1) * gap) / Math.max(auxDisplay.length, 1));
        const auxStartX = (W - (auxBarW * auxDisplay.length + gap * (auxDisplay.length - 1))) / 2;

        ctx.fillStyle = 'rgba(138,180,248,0.15)';
        ctx.fillRect(20, auxTop - 10, W - 40, auxH + 30);
        ctx.fillStyle = '#8ab4f8';
        ctx.font = '12px monospace';
        ctx.fillText('Auxiliary Array (merge buffer)', 30, auxTop + 2);

        for (let i = 0; i < auxDisplay.length; i++) {
            const x = auxStartX + i * (auxBarW + gap);
            const bh = auxDisplay[i].val * (auxH - 20);
            const y = auxTop + 15 + (auxH - 20) - bh;
            const d = auxDisplay[i].depth % depthColors.length;
            ctx.fillStyle = depthColors[d];
            ctx.globalAlpha = 0.7;
            ctx.fillRect(x, y, auxBarW, bh);
            ctx.globalAlpha = 1;
        }
    }

    // Title
    ctx.fillStyle = '#8ab4f8';
    ctx.font = 'bold 16px system-ui';
    ctx.fillText('Merge Sort', startX, 30);
    ctx.font = '12px system-ui';
    ctx.fillStyle = '#666';
    ctx.fillText('Divide and conquer - split, sort halves, merge', startX + 110, 30);

    processOps();
    requestAnimationFrame(draw);
}

speedSlider.addEventListener('input', () => { speedVal.textContent = speedSlider.value; });
sizeSlider.addEventListener('input', () => {
    sizeVal.textContent = sizeSlider.value;
    if (!sorting) generateArray();
});
document.getElementById('newArr').addEventListener('click', () => { sorting = false; generateArray(); });
document.getElementById('startBtn').addEventListener('click', startSort);
document.getElementById('pauseBtn').addEventListener('click', () => {
    if (sorting) { paused = !paused; statusEl.textContent = paused ? 'Paused' : 'Sorting...'; }
});

window.reset = function() { sorting = false; generateArray(); };

generateArray();
draw();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
