<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Heap Sort - Sorting Algorithm Theater</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; }
canvas { display: block; }
a.back-link { position: fixed; top: 15px; left: 15px; color: #8ab4f8; text-decoration: none; z-index: 100; font-size: 14px; opacity: 0.8; }
a.back-link:hover { opacity: 1; }

.controls {
    position: fixed; top: 15px; right: 15px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 16px; min-width: 220px;
    border: 1px solid rgba(255,255,255,0.1);
}
.controls h3 { font-size: 14px; margin-bottom: 10px; color: #8ab4f8; }
.controls label { display: block; font-size: 12px; margin: 8px 0 4px; color: #aaa; }
.controls input[type="range"] { width: 100%; accent-color: #8ab4f8; }
.controls .value { float: right; color: #8ab4f8; font-size: 12px; }
.btn { background: rgba(138,180,248,0.2); color: #8ab4f8; border: 1px solid rgba(138,180,248,0.3); padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 13px; margin: 4px 2px; transition: all 0.2s; }
.btn:hover { background: rgba(138,180,248,0.35); }
.btn.active { background: rgba(138,180,248,0.5); }
.btn-row { display: flex; gap: 4px; flex-wrap: wrap; margin-top: 8px; }

.stats {
    position: fixed; bottom: 15px; left: 15px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px;
    border: 1px solid rgba(255,255,255,0.1);
    font-size: 13px;
}
.stats div { margin: 3px 0; }
.stats span { color: #8ab4f8; font-weight: 600; }

.info {
    position: fixed; bottom: 15px; right: 15px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px; max-width: 300px;
    border: 1px solid rgba(255,255,255,0.1);
    font-size: 12px; line-height: 1.5;
}
.info h4 { color: #8ab4f8; margin-bottom: 6px; font-size: 14px; }
.info .complexity { color: #ffd700; font-family: monospace; }
</style>
</head>
<body>
<a href="index.html" class="back-link">&larr; Back to Sorting Algorithms</a>

<canvas id="canvas"></canvas>

<div class="controls">
    <h3>Heap Sort</h3>
    <label>Speed <span class="value" id="speedVal">50</span></label>
    <input type="range" id="speed" min="1" max="200" value="50">
    <label>Array Size <span class="value" id="sizeVal">40</span></label>
    <input type="range" id="size" min="8" max="80" value="40">
    <div class="btn-row">
        <button class="btn" id="newArr">New Array</button>
        <button class="btn" id="startBtn">Start</button>
        <button class="btn" id="pauseBtn">Pause</button>
    </div>
</div>

<div class="stats">
    <div>Comparisons: <span id="comparisons">0</span></div>
    <div>Swaps: <span id="swaps">0</span></div>
    <div>Array Accesses: <span id="accesses">0</span></div>
    <div>Phase: <span id="phase">Ready</span></div>
    <div>Status: <span id="status">Ready</span></div>
</div>

<div class="info">
    <h4>Heap Sort</h4>
    <p>Build a max-heap from the array, then repeatedly extract the maximum to the end. Two phases: heapify, then extract.</p>
    <p style="margin-top:6px;">Time: <span class="complexity">O(n log n)</span> guaranteed<br>
    Space: <span class="complexity">O(1)</span> in-place<br>
    Stable: No</p>
    <p style="margin-top:6px; color:#aaa;">Top: bar chart. Bottom: binary tree view showing heap structure and sift-down paths.</p>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

const speedSlider = document.getElementById('speed');
const sizeSlider = document.getElementById('size');
const speedVal = document.getElementById('speedVal');
const sizeVal = document.getElementById('sizeVal');
const compEl = document.getElementById('comparisons');
const swapEl = document.getElementById('swaps');
const accEl = document.getElementById('accesses');
const phaseEl = document.getElementById('phase');
const statusEl = document.getElementById('status');

let arr = [], n = 40;
let comparisons = 0, swaps = 0, accesses = 0;
let sorting = false, paused = false;
let operations = [], opIndex = 0;
let barStates = [];
let heapSize = 0;
let siftPath = [];
let activeNodes = [];

function generateArray() {
    n = parseInt(sizeSlider.value);
    arr = [];
    for (let i = 0; i < n; i++) arr.push(Math.random() * 0.85 + 0.1);
    barStates = new Array(n).fill('default');
    comparisons = 0; swaps = 0; accesses = 0;
    operations = []; opIndex = 0;
    sorting = false; paused = false;
    heapSize = n;
    siftPath = [];
    activeNodes = [];
    updateStats();
    phaseEl.textContent = 'Ready';
    statusEl.textContent = 'Ready';
}

function updateStats() {
    compEl.textContent = comparisons;
    swapEl.textContent = swaps;
    accEl.textContent = accesses;
}

function buildHeapSortOps(a) {
    const ops = [];
    const len = a.length;

    // Build max heap
    ops.push({ type: 'phase', phase: 'Building Max-Heap' });
    for (let i = Math.floor(len / 2) - 1; i >= 0; i--) {
        siftDown(a, i, len, ops, 'build');
    }

    // Extract
    ops.push({ type: 'phase', phase: 'Extracting Max' });
    for (let end = len - 1; end > 0; end--) {
        ops.push({ type: 'swap', i: 0, j: end });
        const t = a[0]; a[0] = a[end]; a[end] = t;
        ops.push({ type: 'sorted', idx: end, heapSize: end });
        siftDown(a, 0, end, ops, 'extract');
    }
    ops.push({ type: 'sorted', idx: 0, heapSize: 0 });
    ops.push({ type: 'done' });
    return ops;
}

function siftDown(a, root, size, ops, phase) {
    ops.push({ type: 'sift-start', root, size });
    let largest = root;
    const path = [root];

    while (true) {
        const left = 2 * largest + 1;
        const right = 2 * largest + 2;
        let next = largest;

        if (left < size) {
            ops.push({ type: 'compare', i: left, j: next, parent: largest });
            if (a[left] > a[next]) next = left;
        }
        if (right < size) {
            ops.push({ type: 'compare', i: right, j: next, parent: largest });
            if (a[right] > a[next]) next = right;
        }

        if (next !== largest) {
            ops.push({ type: 'swap', i: largest, j: next });
            const t = a[largest]; a[largest] = a[next]; a[next] = t;
            path.push(next);
            largest = next;
        } else {
            break;
        }
    }
    ops.push({ type: 'sift-end', path });
}

function startSort() {
    if (sorting && !paused) return;
    if (paused) { paused = false; statusEl.textContent = 'Sorting...'; return; }
    const arrCopy = arr.slice();
    operations = buildHeapSortOps(arrCopy);
    opIndex = 0;
    comparisons = 0; swaps = 0; accesses = 0;
    sorting = true; paused = false;
    barStates = new Array(n).fill('default');
    heapSize = n;
    siftPath = [];
    activeNodes = [];
    statusEl.textContent = 'Sorting...';
}

function processOps() {
    if (!sorting || paused) return;
    const speed = parseInt(speedSlider.value);
    const opsPerFrame = Math.max(1, Math.floor(speed / 5));

    for (let s = 0; s < opsPerFrame && opIndex < operations.length; s++) {
        const op = operations[opIndex++];
        switch (op.type) {
            case 'phase':
                phaseEl.textContent = op.phase;
                break;
            case 'sift-start':
                heapSize = op.size;
                activeNodes = [op.root];
                for (let k = 0; k < n; k++) {
                    if (barStates[k] !== 'sorted') barStates[k] = 'default';
                }
                barStates[op.root] = 'sifting';
                break;
            case 'compare':
                comparisons++; accesses += 2;
                activeNodes = [op.i, op.j];
                if (barStates[op.i] !== 'sorted') barStates[op.i] = 'comparing';
                if (barStates[op.j] !== 'sorted') barStates[op.j] = 'comparing';
                break;
            case 'swap':
                swaps++; accesses += 4;
                const t = arr[op.i]; arr[op.i] = arr[op.j]; arr[op.j] = t;
                if (barStates[op.i] !== 'sorted') barStates[op.i] = 'swapping';
                if (barStates[op.j] !== 'sorted') barStates[op.j] = 'swapping';
                break;
            case 'sift-end':
                siftPath = op.path;
                for (let k = 0; k < n; k++) {
                    if (barStates[k] !== 'sorted') barStates[k] = 'default';
                }
                activeNodes = [];
                break;
            case 'sorted':
                barStates[op.idx] = 'sorted';
                heapSize = op.heapSize;
                break;
            case 'done':
                sorting = false;
                for (let k = 0; k < n; k++) barStates[k] = 'sorted';
                statusEl.textContent = 'Complete!';
                phaseEl.textContent = 'Done';
                break;
        }
        updateStats();
    }
}

function getBarColor(i) {
    const s = barStates[i];
    if (s === 'sorted') return '#4ade80';
    if (s === 'comparing') return '#ffffff';
    if (s === 'swapping') return '#ffd93d';
    if (s === 'sifting') return '#ff6b6b';
    if (i < heapSize) {
        const hue = arr[i] * 270;
        return `hsl(${hue}, 80%, 55%)`;
    }
    return '#4ade80';
}

function getTreeNodePos(idx, totalLevels, cx, cy, treeW, treeH) {
    if (idx >= n) return null;
    const level = Math.floor(Math.log2(idx + 1));
    const posInLevel = idx - (Math.pow(2, level) - 1);
    const nodesInLevel = Math.pow(2, level);
    const levelY = cy + (level / totalLevels) * treeH;
    const spacing = treeW / (nodesInLevel + 1);
    const levelX = cx - treeW / 2 + spacing * (posInLevel + 1);
    return { x: levelX, y: levelY };
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    // Split: top half bars, bottom half tree
    const barAreaH = H * 0.45;
    const treeAreaTop = H * 0.50;
    const treeAreaH = H * 0.45;
    const topPad = 50;
    const gap = Math.max(1, Math.floor(W * 0.002));
    const totalBarW = W - 40;
    const barW = Math.max(2, (totalBarW - (n - 1) * gap) / n);
    const startX = (W - (barW * n + gap * (n - 1))) / 2;

    // Draw bars
    for (let i = 0; i < n; i++) {
        const x = startX + i * (barW + gap);
        const bh = arr[i] * (barAreaH - topPad - 10);
        const y = topPad + (barAreaH - topPad - 10) - bh;
        ctx.fillStyle = getBarColor(i);
        ctx.fillRect(x, y, barW, bh);
    }

    // Divider line
    ctx.strokeStyle = 'rgba(138,180,248,0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(20, H * 0.48);
    ctx.lineTo(W - 20, H * 0.48);
    ctx.stroke();

    // Draw binary tree
    const totalLevels = Math.ceil(Math.log2(n + 1));
    const treeW = Math.min(W - 60, n * 20);
    const treeCx = W / 2;
    const treeCy = treeAreaTop + 10;
    const nodeR = Math.max(4, Math.min(14, 200 / n));

    // Draw edges first
    for (let i = 0; i < Math.min(n, heapSize); i++) {
        const parent = getTreeNodePos(i, totalLevels, treeCx, treeCy, treeW, treeAreaH - 30);
        if (!parent) continue;
        const left = 2 * i + 1;
        const right = 2 * i + 2;
        if (left < Math.min(n, heapSize)) {
            const lp = getTreeNodePos(left, totalLevels, treeCx, treeCy, treeW, treeAreaH - 30);
            if (lp) {
                const isSiftEdge = siftPath.includes(i) && siftPath.includes(left);
                ctx.strokeStyle = isSiftEdge ? 'rgba(255,107,107,0.7)' : 'rgba(255,255,255,0.15)';
                ctx.lineWidth = isSiftEdge ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(parent.x, parent.y);
                ctx.lineTo(lp.x, lp.y);
                ctx.stroke();
            }
        }
        if (right < Math.min(n, heapSize)) {
            const rp = getTreeNodePos(right, totalLevels, treeCx, treeCy, treeW, treeAreaH - 30);
            if (rp) {
                const isSiftEdge = siftPath.includes(i) && siftPath.includes(right);
                ctx.strokeStyle = isSiftEdge ? 'rgba(255,107,107,0.7)' : 'rgba(255,255,255,0.15)';
                ctx.lineWidth = isSiftEdge ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(parent.x, parent.y);
                ctx.lineTo(rp.x, rp.y);
                ctx.stroke();
            }
        }
    }

    // Draw nodes
    for (let i = 0; i < Math.min(n, heapSize); i++) {
        const pos = getTreeNodePos(i, totalLevels, treeCx, treeCy, treeW, treeAreaH - 30);
        if (!pos) continue;

        let color = getBarColor(i);
        if (activeNodes.includes(i)) color = barStates[i] === 'swapping' ? '#ffd93d' : '#ffffff';

        ctx.beginPath();
        ctx.arc(pos.x, pos.y, nodeR, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();

        if (activeNodes.includes(i)) {
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }

    // Labels
    ctx.fillStyle = '#8ab4f8';
    ctx.font = 'bold 16px system-ui';
    ctx.fillText('Heap Sort', startX, 30);
    ctx.font = '12px system-ui';
    ctx.fillStyle = '#666';
    ctx.fillText('Build max-heap, extract maximum repeatedly', startX + 100, 30);

    ctx.fillStyle = '#8ab4f8';
    ctx.font = '12px system-ui';
    ctx.fillText('Binary Heap Tree View', 30, treeAreaTop);
    ctx.fillStyle = '#555';
    ctx.fillText('Heap size: ' + heapSize, 200, treeAreaTop);

    processOps();
    requestAnimationFrame(draw);
}

speedSlider.addEventListener('input', () => { speedVal.textContent = speedSlider.value; });
sizeSlider.addEventListener('input', () => { sizeVal.textContent = sizeSlider.value; if (!sorting) generateArray(); });
document.getElementById('newArr').addEventListener('click', () => { sorting = false; generateArray(); });
document.getElementById('startBtn').addEventListener('click', startSort);
document.getElementById('pauseBtn').addEventListener('click', () => {
    if (sorting) { paused = !paused; statusEl.textContent = paused ? 'Paused' : 'Sorting...'; }
});

window.reset = function() { sorting = false; generateArray(); };

generateArray();
draw();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
