<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Shell Sort - Sorting Algorithm Theater</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; }
canvas { display: block; }
a.back-link { position: fixed; top: 15px; left: 15px; color: #8ab4f8; text-decoration: none; z-index: 100; font-size: 14px; opacity: 0.8; }
a.back-link:hover { opacity: 1; }

.controls {
    position: fixed; top: 15px; right: 15px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 16px; min-width: 240px;
    border: 1px solid rgba(255,255,255,0.1);
}
.controls h3 { font-size: 14px; margin-bottom: 10px; color: #8ab4f8; }
.controls label { display: block; font-size: 12px; margin: 8px 0 4px; color: #aaa; }
.controls input[type="range"] { width: 100%; accent-color: #8ab4f8; }
.controls .value { float: right; color: #8ab4f8; font-size: 12px; }
.btn { background: rgba(138,180,248,0.2); color: #8ab4f8; border: 1px solid rgba(138,180,248,0.3); padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; margin: 3px 2px; transition: all 0.2s; }
.btn:hover { background: rgba(138,180,248,0.35); }
.btn.active { background: rgba(138,180,248,0.5); }
.btn-row { display: flex; gap: 4px; flex-wrap: wrap; margin-top: 8px; }
.gap-group { margin-top: 8px; }
.gap-group span { font-size: 11px; color: #aaa; display: block; margin-bottom: 4px; }

.stats {
    position: fixed; bottom: 15px; left: 15px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px;
    border: 1px solid rgba(255,255,255,0.1);
    font-size: 13px;
}
.stats div { margin: 3px 0; }
.stats span { color: #8ab4f8; font-weight: 600; }

.info {
    position: fixed; bottom: 15px; right: 15px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px; max-width: 300px;
    border: 1px solid rgba(255,255,255,0.1);
    font-size: 12px; line-height: 1.5;
}
.info h4 { color: #8ab4f8; margin-bottom: 6px; font-size: 14px; }
.info .complexity { color: #ffd700; font-family: monospace; }
</style>
</head>
<body>
<a href="index.html" class="back-link">&larr; Back to Sorting Algorithms</a>

<canvas id="canvas"></canvas>

<div class="controls">
    <h3>Shell Sort</h3>
    <label>Speed <span class="value" id="speedVal">50</span></label>
    <input type="range" id="speed" min="1" max="200" value="50">
    <label>Array Size <span class="value" id="sizeVal">60</span></label>
    <input type="range" id="size" min="10" max="200" value="60">
    <div class="gap-group">
        <span>Gap Sequence:</span>
        <div class="btn-row">
            <button class="btn active" data-gap="shell">Shell</button>
            <button class="btn" data-gap="knuth">Knuth</button>
            <button class="btn" data-gap="sedgewick">Sedgewick</button>
            <button class="btn" data-gap="ciura">Ciura</button>
        </div>
    </div>
    <div class="btn-row">
        <button class="btn" id="newArr">New Array</button>
        <button class="btn" id="startBtn">Start</button>
        <button class="btn" id="pauseBtn">Pause</button>
    </div>
</div>

<div class="stats">
    <div>Comparisons: <span id="comparisons">0</span></div>
    <div>Swaps: <span id="swaps">0</span></div>
    <div>Array Accesses: <span id="accesses">0</span></div>
    <div>Current Gap: <span id="gapVal">-</span></div>
    <div>Gap Sequence: <span id="gapSeq">-</span></div>
    <div>Status: <span id="status">Ready</span></div>
</div>

<div class="info">
    <h4>Shell Sort</h4>
    <p>Insertion sort with decreasing gaps. Large gaps quickly move elements close to their final position, then small gaps finish the job efficiently.</p>
    <p style="margin-top:6px;">Time: <span class="complexity">O(n log&sup2; n)</span> to <span class="complexity">O(n^{4/3})</span><br>
    Depends on gap sequence<br>
    Space: <span class="complexity">O(1)</span> in-place<br>
    Stable: No</p>
    <p style="margin-top:6px; color:#aaa;">Arcs connect elements being compared at gap distance. Colors group elements by gap offset.</p>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

const speedSlider = document.getElementById('speed');
const sizeSlider = document.getElementById('size');
const speedVal = document.getElementById('speedVal');
const sizeVal = document.getElementById('sizeVal');
const compEl = document.getElementById('comparisons');
const swapEl = document.getElementById('swaps');
const accEl = document.getElementById('accesses');
const gapValEl = document.getElementById('gapVal');
const gapSeqEl = document.getElementById('gapSeq');
const statusEl = document.getElementById('status');

let arr = [], n = 60;
let comparisons = 0, swaps = 0, accesses = 0;
let sorting = false, paused = false;
let operations = [], opIndex = 0;
let barStates = [];
let currentGap = 0;
let gapStrategy = 'shell';
let gapGroups = []; // color group per element
let arcPairs = []; // pairs being compared
let currentGapSeq = [];

const groupColors = [
    '#ff6b6b', '#ffa06b', '#ffd93d', '#6bff6b', '#6bd4ff',
    '#a06bff', '#ff6bda', '#ff9e9e', '#9effa0', '#9ed4ff',
    '#d4a0ff', '#ffcf6b', '#6bffd9', '#ff6ba0', '#c8ff6b',
    '#e06bff', '#6bffe0', '#ff8c6b', '#6baeff', '#d9ff6b'
];

function getGapSequence(n, strategy) {
    const gaps = [];
    switch (strategy) {
        case 'shell':
            for (let g = Math.floor(n / 2); g > 0; g = Math.floor(g / 2)) gaps.push(g);
            break;
        case 'knuth': {
            let g = 1;
            while (g < Math.floor(n / 3)) g = g * 3 + 1;
            while (g > 0) { gaps.push(g); g = Math.floor((g - 1) / 3); }
            break;
        }
        case 'sedgewick': {
            const se = [1];
            let i = 1;
            while (true) {
                let val;
                if (i % 2 === 0) val = 9 * Math.pow(2, i) - 9 * Math.pow(2, i / 2) + 1;
                else val = 8 * Math.pow(2, i) - 6 * Math.pow(2, (i + 1) / 2) + 1;
                val = Math.floor(val);
                if (val >= n) break;
                se.push(val);
                i++;
            }
            se.reverse();
            for (const g of se) gaps.push(g);
            break;
        }
        case 'ciura': {
            const ciuraGaps = [1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941];
            for (let i = ciuraGaps.length - 1; i >= 0; i--) {
                if (ciuraGaps[i] < n) gaps.push(ciuraGaps[i]);
            }
            if (gaps.length === 0) gaps.push(1);
            break;
        }
    }
    return gaps;
}

function generateArray() {
    n = parseInt(sizeSlider.value);
    arr = [];
    for (let i = 0; i < n; i++) arr.push(Math.random() * 0.85 + 0.1);
    barStates = new Array(n).fill('default');
    gapGroups = new Array(n).fill(0);
    comparisons = 0; swaps = 0; accesses = 0;
    operations = []; opIndex = 0;
    sorting = false; paused = false;
    currentGap = 0;
    arcPairs = [];
    currentGapSeq = [];
    updateStats();
    gapValEl.textContent = '-';
    gapSeqEl.textContent = '-';
    statusEl.textContent = 'Ready';
}

function updateStats() {
    compEl.textContent = comparisons;
    swapEl.textContent = swaps;
    accEl.textContent = accesses;
}

function buildShellSortOps(a) {
    const ops = [];
    const gaps = getGapSequence(a.length, gapStrategy);
    currentGapSeq = gaps;

    for (const gap of gaps) {
        ops.push({ type: 'new-gap', gap, gaps });

        for (let i = gap; i < a.length; i++) {
            // Color group
            ops.push({ type: 'group', idx: i, group: i % gap });
            let j = i;
            while (j >= gap) {
                ops.push({ type: 'compare', i: j - gap, j, gap });
                if (a[j - gap] > a[j]) {
                    ops.push({ type: 'swap', i: j - gap, j });
                    const t = a[j - gap]; a[j - gap] = a[j]; a[j] = t;
                    j -= gap;
                } else {
                    break;
                }
            }
            ops.push({ type: 'insert-done', idx: j });
        }
    }
    ops.push({ type: 'done' });
    return ops;
}

function startSort() {
    if (sorting && !paused) return;
    if (paused) { paused = false; statusEl.textContent = 'Sorting...'; return; }
    const arrCopy = arr.slice();
    operations = buildShellSortOps(arrCopy);
    opIndex = 0;
    comparisons = 0; swaps = 0; accesses = 0;
    sorting = true; paused = false;
    barStates = new Array(n).fill('default');
    gapGroups = new Array(n).fill(0);
    arcPairs = [];
    statusEl.textContent = 'Sorting...';
}

function processOps() {
    if (!sorting || paused) return;
    const speed = parseInt(speedSlider.value);
    const opsPerFrame = Math.max(1, Math.floor(speed / 5));

    for (let s = 0; s < opsPerFrame && opIndex < operations.length; s++) {
        const op = operations[opIndex++];
        switch (op.type) {
            case 'new-gap':
                currentGap = op.gap;
                gapValEl.textContent = op.gap;
                gapSeqEl.textContent = op.gaps.join(', ');
                // Reset colors, assign gap groups
                for (let k = 0; k < n; k++) {
                    barStates[k] = 'default';
                    gapGroups[k] = k % op.gap;
                }
                arcPairs = [];
                break;
            case 'group':
                gapGroups[op.idx] = op.group;
                break;
            case 'compare':
                comparisons++; accesses += 2;
                for (let k = 0; k < n; k++) {
                    if (barStates[k] !== 'sorted') barStates[k] = 'default';
                }
                barStates[op.i] = 'comparing';
                barStates[op.j] = 'comparing';
                arcPairs = [{ i: op.i, j: op.j, gap: op.gap }];
                break;
            case 'swap':
                swaps++; accesses += 4;
                const t = arr[op.i]; arr[op.i] = arr[op.j]; arr[op.j] = t;
                const tg = gapGroups[op.i]; gapGroups[op.i] = gapGroups[op.j]; gapGroups[op.j] = tg;
                barStates[op.i] = 'swapping';
                barStates[op.j] = 'swapping';
                break;
            case 'insert-done':
                for (let k = 0; k < n; k++) {
                    if (barStates[k] !== 'sorted') barStates[k] = 'default';
                }
                arcPairs = [];
                break;
            case 'done':
                sorting = false;
                for (let k = 0; k < n; k++) barStates[k] = 'sorted';
                arcPairs = [];
                statusEl.textContent = 'Complete!';
                break;
        }
        updateStats();
    }
}

function getBarColor(i) {
    const s = barStates[i];
    if (s === 'sorted') return '#4ade80';
    if (s === 'comparing') return '#ffffff';
    if (s === 'swapping') return '#ffd93d';
    // Color by gap group
    if (sorting && currentGap > 1) {
        const g = gapGroups[i] % groupColors.length;
        return groupColors[g];
    }
    const hue = arr[i] * 270;
    return `hsl(${hue}, 80%, 55%)`;
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    const topPad = 60, bottomPad = 50;
    const barAreaH = H - topPad - bottomPad;
    const gap = Math.max(1, Math.floor(W * 0.002));
    const totalBarW = W - 40;
    const barW = Math.max(2, (totalBarW - (n - 1) * gap) / n);
    const startX = (W - (barW * n + gap * (n - 1))) / 2;

    // Draw gap group indicators at bottom
    if (sorting && currentGap > 1) {
        for (let i = 0; i < n; i++) {
            const x = startX + i * (barW + gap);
            const g = gapGroups[i] % groupColors.length;
            ctx.fillStyle = groupColors[g];
            ctx.globalAlpha = 0.3;
            ctx.fillRect(x, topPad + barAreaH + 5, barW, 4);
            ctx.globalAlpha = 1;
        }
    }

    // Draw arcs connecting compared elements
    for (const pair of arcPairs) {
        const x1 = startX + pair.i * (barW + gap) + barW / 2;
        const x2 = startX + pair.j * (barW + gap) + barW / 2;
        const midX = (x1 + x2) / 2;
        const arcH = Math.min(80, Math.abs(x2 - x1) * 0.4);

        ctx.strokeStyle = 'rgba(138,180,248,0.6)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x1, topPad + barAreaH + 15);
        ctx.quadraticCurveTo(midX, topPad + barAreaH + 15 + arcH, x2, topPad + barAreaH + 15);
        ctx.stroke();

        // Arc endpoints
        ctx.fillStyle = '#8ab4f8';
        ctx.beginPath(); ctx.arc(x1, topPad + barAreaH + 15, 3, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(x2, topPad + barAreaH + 15, 3, 0, Math.PI * 2); ctx.fill();
    }

    // Draw all gap-distance connections faintly
    if (sorting && currentGap > 1 && arcPairs.length > 0) {
        ctx.strokeStyle = 'rgba(255,255,255,0.04)';
        ctx.lineWidth = 1;
        for (let i = 0; i + currentGap < n; i += currentGap) {
            const x1 = startX + i * (barW + gap) + barW / 2;
            const x2 = startX + (i + currentGap) * (barW + gap) + barW / 2;
            ctx.beginPath();
            ctx.moveTo(x1, topPad - 5);
            ctx.lineTo(x2, topPad - 5);
            ctx.stroke();
        }
    }

    // Draw bars
    for (let i = 0; i < n; i++) {
        const x = startX + i * (barW + gap);
        const bh = arr[i] * barAreaH;
        const y = topPad + barAreaH - bh;
        ctx.fillStyle = getBarColor(i);
        ctx.fillRect(x, y, barW, bh);
    }

    // Title
    ctx.fillStyle = '#8ab4f8';
    ctx.font = 'bold 16px system-ui';
    ctx.fillText('Shell Sort', startX, 30);
    ctx.font = '12px system-ui';
    ctx.fillStyle = '#666';
    ctx.fillText('Insertion sort with decreasing gaps', startX + 100, 30);

    // Current gap display
    if (sorting && currentGap > 0) {
        ctx.fillStyle = '#8ab4f8';
        ctx.font = 'bold 24px monospace';
        ctx.textAlign = 'right';
        ctx.fillText('gap = ' + currentGap, W - 270, 40);
        ctx.textAlign = 'left';
    }

    processOps();
    requestAnimationFrame(draw);
}

// Gap strategy buttons
document.querySelectorAll('[data-gap]').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('[data-gap]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        gapStrategy = btn.dataset.gap;
    });
});

speedSlider.addEventListener('input', () => { speedVal.textContent = speedSlider.value; });
sizeSlider.addEventListener('input', () => { sizeVal.textContent = sizeSlider.value; if (!sorting) generateArray(); });
document.getElementById('newArr').addEventListener('click', () => { sorting = false; generateArray(); });
document.getElementById('startBtn').addEventListener('click', startSort);
document.getElementById('pauseBtn').addEventListener('click', () => {
    if (sorting) { paused = !paused; statusEl.textContent = paused ? 'Paused' : 'Sorting...'; }
});

window.reset = function() { sorting = false; generateArray(); };

generateArray();
draw();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
