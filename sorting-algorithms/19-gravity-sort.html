<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gravity (Bead) Sort - Sorting Algorithms</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; }
canvas { display: block; }
a.back-link {
    position: fixed; top: 16px; left: 16px; color: #8ab4f8; text-decoration: none;
    font-size: 14px; z-index: 100; opacity: 0.8; transition: opacity 0.2s;
}
a.back-link:hover { opacity: 1; }

.controls {
    position: fixed; top: 16px; right: 16px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 16px; min-width: 220px;
    border: 1px solid rgba(255,255,255,0.08);
}
.controls h3 { font-size: 14px; color: #8ab4f8; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
.controls label { display: block; font-size: 12px; color: #aaa; margin-top: 8px; }
.controls input[type=range] { width: 100%; margin: 4px 0; accent-color: #8ab4f8; }
.btn {
    display: inline-block; margin: 4px 2px; padding: 6px 14px; border: none; border-radius: 6px;
    background: #1a3a5c; color: #8ab4f8; font-size: 12px; cursor: pointer; transition: background 0.2s;
}
.btn:hover { background: #244a6c; }
.btn.active { background: #2e6b3e; color: #8f8; }
.btn-row { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 4px; }

.stats {
    position: fixed; bottom: 16px; left: 16px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px;
    border: 1px solid rgba(255,255,255,0.08); font-size: 13px;
}
.stats .stat-row { display: flex; justify-content: space-between; gap: 20px; margin: 3px 0; }
.stats .stat-label { color: #888; }
.stats .stat-value { color: #8ab4f8; font-family: 'Courier New', monospace; }

.info-panel {
    position: fixed; bottom: 16px; right: 16px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px; max-width: 320px;
    border: 1px solid rgba(255,255,255,0.08); font-size: 12px; line-height: 1.6;
}
.info-panel h4 { color: #8ab4f8; margin-bottom: 6px; }
.info-panel .complexity { color: #f8d868; font-family: 'Courier New', monospace; font-size: 11px; }

.view-toggle {
    position: fixed; top: 16px; left: 50%; transform: translateX(-50%); z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 8px 16px; display: flex; gap: 8px;
    border: 1px solid rgba(255,255,255,0.08);
}
</style>
</head>
<body>
<a href="index.html" class="back-link">&#8592; Back to Gallery</a>
<canvas id="canvas"></canvas>

<div class="view-toggle">
    <button class="btn active" id="btnAbacus">Abacus View</button>
    <button class="btn" id="btnBars">Bar Chart View</button>
    <button class="btn" id="btnSplit">Split View</button>
</div>

<div class="controls">
    <h3>Gravity Sort</h3>
    <label>Array Size: <span id="sizeVal">15</span></label>
    <input type="range" id="sizeSlider" min="5" max="30" value="15">
    <label>Max Value: <span id="maxVal">20</span></label>
    <input type="range" id="maxSlider" min="5" max="40" value="20">
    <label>Speed: <span id="speedVal">50</span></label>
    <input type="range" id="speedSlider" min="1" max="100" value="50">
    <div class="btn-row">
        <button class="btn" id="btnStart">Drop Beads</button>
        <button class="btn" id="btnStep">Step</button>
        <button class="btn" id="btnNew">New Array</button>
    </div>
    <label style="margin-top:10px;font-size:11px;color:#666;">Gravity Pass: <span id="passInfo" style="color:#8ab4f8;">--</span></label>
</div>

<div class="stats">
    <div class="stat-row"><span class="stat-label">Gravity Passes:</span><span class="stat-value" id="passCount">0</span></div>
    <div class="stat-row"><span class="stat-label">Beads Moved:</span><span class="stat-value" id="beadsMoved">0</span></div>
    <div class="stat-row"><span class="stat-label">Total Beads:</span><span class="stat-value" id="totalBeads">0</span></div>
    <div class="stat-row"><span class="stat-label">Status:</span><span class="stat-value" id="statusText">Ready</span></div>
</div>

<div class="info-panel">
    <h4>Gravity (Bead) Sort</h4>
    <p>Represent each number as a row of beads on an abacus. Let gravity pull beads down. After settling, reading rows bottom-to-top gives the sorted array. Like a physical sorting machine!</p>
    <p class="complexity">
        Worst:&nbsp;&nbsp;&nbsp;O(n &times; max_val)<br>
        Average: O(S) where S = sum<br>
        Best:&nbsp;&nbsp;&nbsp;&nbsp;O(1) with hardware<br>
        Space:&nbsp;&nbsp;&nbsp;O(n &times; max_val)
    </p>
    <p style="margin-top:6px;color:#888;">Only works for positive integers. Beautiful but impractical without hardware.</p>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let arr = [];
let n = 15;
let maxV = 20;
let speed = 50;
let running = false;
let sorted = false;

let grid = []; // n rows, maxV cols - the abacus
let targetGrid = []; // where beads should end up
let beadPositions = []; // animated Y positions for each bead
let gravityPass = 0;
let beadsMoved = 0;
let totalBeads = 0;
let viewMode = 'abacus'; // abacus, bars, split

let animating = false;
let animProgress = 0;

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

function generateArray() {
    arr = [];
    for (let k = 0; k < n; k++) {
        arr.push(Math.floor(Math.random() * maxV) + 1);
    }
    totalBeads = arr.reduce(function(a, b) { return a + b; }, 0);
    gravityPass = 0;
    beadsMoved = 0;
    sorted = false;
    running = false;
    animating = false;
    animProgress = 0;

    // Build initial grid
    buildGrid();
    // Target is also current at start
    targetGrid = grid.map(function(row) { return row.slice(); });
    // Init bead positions (row = actual position)
    beadPositions = [];
    for (let r = 0; r < n; r++) {
        beadPositions[r] = [];
        for (let c = 0; c < maxV; c++) {
            beadPositions[r][c] = r;
        }
    }

    updateStats();
    document.getElementById('btnStart').textContent = 'Drop Beads';
    document.getElementById('statusText').textContent = 'Ready';
    document.getElementById('passInfo').textContent = '--';
}

function buildGrid() {
    grid = [];
    for (let r = 0; r < n; r++) {
        grid[r] = [];
        for (let c = 0; c < maxV; c++) {
            grid[r][c] = c < arr[r] ? 1 : 0;
        }
    }
}

function applyGravity() {
    // For each column, count beads and let them fall to bottom
    let newGrid = [];
    for (let r = 0; r < n; r++) {
        newGrid[r] = new Array(maxV).fill(0);
    }

    let moved = 0;
    for (let c = 0; c < maxV; c++) {
        let count = 0;
        for (let r = 0; r < n; r++) {
            count += grid[r][c];
        }
        // Place beads at bottom of column
        for (let r = n - 1; r >= n - count; r--) {
            newGrid[r][c] = 1;
        }
        // Check how many moved
        for (let r = 0; r < n; r++) {
            if (grid[r][c] !== newGrid[r][c]) moved++;
        }
    }

    targetGrid = newGrid;
    beadsMoved += moved / 2;
    return moved > 0;
}

function readResult() {
    let result = [];
    for (let r = 0; r < n; r++) {
        let count = 0;
        for (let c = 0; c < maxV; c++) {
            count += targetGrid[r][c];
        }
        result.push(count);
    }
    return result;
}

function valueToColor(val) {
    return 'hsl(' + (val / maxV * 200 + 20) + ', 80%, 55%)';
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (viewMode === 'abacus' || viewMode === 'split') {
        drawAbacus(viewMode === 'split' ? 0 : 0, viewMode === 'split' ? canvas.width / 2 : canvas.width);
    }
    if (viewMode === 'bars' || viewMode === 'split') {
        drawBars(viewMode === 'split' ? canvas.width / 2 : 0, viewMode === 'split' ? canvas.width / 2 : canvas.width);
    }
    if (viewMode === 'split') {
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(canvas.width / 2, 0);
        ctx.lineTo(canvas.width / 2, canvas.height);
        ctx.stroke();
    }

    requestAnimationFrame(draw);
}

function drawAbacus(offsetX, width) {
    let padding = 40;
    let topPad = 70;
    let bottomPad = 50;
    let drawW = width - padding * 2;
    let drawH = canvas.height - topPad - bottomPad;

    let cellW = drawW / maxV;
    let cellH = drawH / n;
    let beadR = Math.min(cellW, cellH) * 0.35;

    // Title
    ctx.font = '12px monospace';
    ctx.fillStyle = '#8ab4f8';
    ctx.textAlign = 'center';
    ctx.fillText('ABACUS VIEW', offsetX + width / 2, topPad - 16);

    // Draw rods (vertical lines)
    for (let c = 0; c < maxV; c++) {
        let x = offsetX + padding + c * cellW + cellW / 2;
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, topPad);
        ctx.lineTo(x, topPad + drawH);
        ctx.stroke();
    }

    // Draw row labels
    ctx.font = '10px monospace';
    ctx.textAlign = 'right';
    for (let r = 0; r < n; r++) {
        let y = topPad + r * cellH + cellH / 2;
        ctx.fillStyle = '#666';
        ctx.fillText(r, offsetX + padding - 6, y + 3);
    }

    // Draw beads
    for (let r = 0; r < n; r++) {
        for (let c = 0; c < maxV; c++) {
            let x = offsetX + padding + c * cellW + cellW / 2;

            if (grid[r][c]) {
                // Determine animated position
                let drawRow = r;
                if (animating) {
                    // Find where this bead is going in target
                    let targetRow = r;
                    // Simple: interpolate toward target
                    for (let tr = n - 1; tr >= 0; tr--) {
                        if (targetGrid[tr][c] && tr >= r) {
                            targetRow = tr;
                            break;
                        }
                    }
                    drawRow = r + (targetRow - r) * animProgress;
                }

                let y = topPad + drawRow * cellH + cellH / 2;

                // Bead shadow
                ctx.beginPath();
                ctx.arc(x, y + 2, beadR, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fill();

                // Bead
                ctx.beginPath();
                ctx.arc(x, y, beadR, 0, Math.PI * 2);
                let hue = (c / maxV) * 200 + 20;
                ctx.fillStyle = sorted ? '#2ecc71' : 'hsl(' + hue + ', 75%, 55%)';
                ctx.fill();

                // Bead highlight
                ctx.beginPath();
                ctx.arc(x - beadR * 0.25, y - beadR * 0.25, beadR * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.25)';
                ctx.fill();
            } else {
                // Empty slot marker
                let y = topPad + r * cellH + cellH / 2;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.04)';
                ctx.fill();
            }
        }
    }

    // Column numbers at bottom
    ctx.font = '9px monospace';
    ctx.textAlign = 'center';
    for (let c = 0; c < maxV; c++) {
        let x = offsetX + padding + c * cellW + cellW / 2;
        ctx.fillStyle = '#555';
        ctx.fillText(c + 1, x, topPad + drawH + 16);
    }
}

function drawBars(offsetX, width) {
    let padding = 40;
    let topPad = 70;
    let bottomPad = 50;
    let drawW = width - padding * 2;
    let drawH = canvas.height - topPad - bottomPad;
    let barWidth = drawW / n;
    let gapPx = Math.max(1, barWidth * 0.1);

    ctx.font = '12px monospace';
    ctx.fillStyle = '#8ab4f8';
    ctx.textAlign = 'center';
    ctx.fillText('BAR CHART VIEW', offsetX + width / 2, topPad - 16);

    // Read current values from grid
    let vals = [];
    for (let r = 0; r < n; r++) {
        let count = 0;
        let source = animating ? grid : (sorted ? targetGrid : grid);
        for (let c = 0; c < maxV; c++) {
            count += source[r][c];
        }
        vals.push(count);
    }

    for (let k = 0; k < n; k++) {
        let barH = (vals[k] / maxV) * drawH;
        let x = offsetX + padding + k * barWidth;
        let y = topPad + drawH - barH;

        ctx.fillStyle = sorted ? '#2ecc71' : valueToColor(vals[k]);
        ctx.fillRect(x + gapPx / 2, y, barWidth - gapPx, barH);

        if (barWidth > 8) {
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(x + gapPx / 2, y, 1, barH);

            ctx.font = '10px monospace';
            ctx.fillStyle = '#ccc';
            ctx.textAlign = 'center';
            ctx.fillText(vals[k], x + barWidth / 2, y - 6);
        }
    }
}

function updateStats() {
    document.getElementById('passCount').textContent = gravityPass;
    document.getElementById('beadsMoved').textContent = Math.floor(beadsMoved);
    document.getElementById('totalBeads').textContent = totalBeads;
}

function gravityStep() {
    if (sorted) return;

    let didMove = applyGravity();
    gravityPass++;
    document.getElementById('passInfo').textContent = gravityPass;

    if (!didMove) {
        // Already settled
        grid = targetGrid.map(function(row) { return row.slice(); });
        arr = readResult();
        sorted = true;
        running = false;
        document.getElementById('btnStart').textContent = 'Drop Beads';
        document.getElementById('statusText').textContent = 'Sorted!';
        updateStats();
        return;
    }

    // Animate beads falling
    animating = true;
    animProgress = 0;

    function animStep() {
        animProgress += 0.08 * (speed / 50);
        if (animProgress >= 1) {
            animProgress = 1;
            animating = false;
            grid = targetGrid.map(function(row) { return row.slice(); });
            arr = readResult();

            // Check if fully sorted
            let isSorted = true;
            for (let i = 0; i < arr.length - 1; i++) {
                if (arr[i] < arr[i + 1]) { isSorted = false; break; }
            }
            // Gravity sort produces descending; we want ascending, so reverse check
            let isAsc = true;
            for (let i = 0; i < arr.length - 1; i++) {
                if (arr[i] > arr[i + 1]) { isAsc = false; break; }
            }

            updateStats();

            if (isAsc || isSorted) {
                // Reverse to ascending if descending
                if (!isAsc && isSorted) {
                    arr.reverse();
                    buildGrid();
                    targetGrid = grid.map(function(row) { return row.slice(); });
                }
                sorted = true;
                running = false;
                document.getElementById('btnStart').textContent = 'Drop Beads';
                document.getElementById('statusText').textContent = 'Sorted!';
            } else if (running) {
                setTimeout(function() {
                    if (running && !sorted) gravityStep();
                }, Math.max(10, 200 - speed * 2));
            }
            return;
        }
        requestAnimationFrame(animStep);
    }
    requestAnimationFrame(animStep);
    updateStats();
}

function startSort() {
    if (sorted) { generateArray(); return; }
    running = !running;
    document.getElementById('btnStart').textContent = running ? 'Pause' : 'Resume';
    document.getElementById('statusText').textContent = running ? 'Gravity falling...' : 'Paused';
    if (running && !animating) {
        gravityStep();
    }
}

function doStep() {
    if (sorted) { generateArray(); return; }
    running = false;
    document.getElementById('btnStart').textContent = 'Resume';
    document.getElementById('statusText').textContent = 'Step mode';
    if (!animating) gravityStep();
}

document.getElementById('sizeSlider').addEventListener('input', function() {
    n = parseInt(this.value);
    document.getElementById('sizeVal').textContent = n;
    generateArray();
});
document.getElementById('maxSlider').addEventListener('input', function() {
    maxV = parseInt(this.value);
    document.getElementById('maxVal').textContent = maxV;
    generateArray();
});
document.getElementById('speedSlider').addEventListener('input', function() {
    speed = parseInt(this.value);
    document.getElementById('speedVal').textContent = speed;
});
document.getElementById('btnStart').addEventListener('click', startSort);
document.getElementById('btnStep').addEventListener('click', doStep);
document.getElementById('btnNew').addEventListener('click', generateArray);

document.getElementById('btnAbacus').addEventListener('click', function() {
    viewMode = 'abacus';
    document.getElementById('btnAbacus').classList.add('active');
    document.getElementById('btnBars').classList.remove('active');
    document.getElementById('btnSplit').classList.remove('active');
});
document.getElementById('btnBars').addEventListener('click', function() {
    viewMode = 'bars';
    document.getElementById('btnBars').classList.add('active');
    document.getElementById('btnAbacus').classList.remove('active');
    document.getElementById('btnSplit').classList.remove('active');
});
document.getElementById('btnSplit').addEventListener('click', function() {
    viewMode = 'split';
    document.getElementById('btnSplit').classList.add('active');
    document.getElementById('btnAbacus').classList.remove('active');
    document.getElementById('btnBars').classList.remove('active');
});

window.reset = function() {
    generateArray();
};

generateArray();
requestAnimationFrame(draw);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
