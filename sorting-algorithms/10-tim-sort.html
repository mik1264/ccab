<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TimSort - Sorting Algorithm Theater</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; }
canvas { display: block; }
a.back-link { position: fixed; top: 15px; left: 15px; color: #8ab4f8; text-decoration: none; z-index: 100; font-size: 14px; opacity: 0.8; }
a.back-link:hover { opacity: 1; }

.controls {
    position: fixed; top: 15px; right: 15px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 16px; min-width: 240px;
    border: 1px solid rgba(255,255,255,0.1);
}
.controls h3 { font-size: 14px; margin-bottom: 10px; color: #8ab4f8; }
.controls label { display: block; font-size: 12px; margin: 8px 0 4px; color: #aaa; }
.controls input[type="range"] { width: 100%; accent-color: #8ab4f8; }
.controls .value { float: right; color: #8ab4f8; font-size: 12px; }
.btn { background: rgba(138,180,248,0.2); color: #8ab4f8; border: 1px solid rgba(138,180,248,0.3); padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; margin: 3px 2px; transition: all 0.2s; }
.btn:hover { background: rgba(138,180,248,0.35); }
.btn.active { background: rgba(138,180,248,0.5); }
.btn-row { display: flex; gap: 4px; flex-wrap: wrap; margin-top: 8px; }
.pattern-group { margin-top: 8px; }
.pattern-group span { font-size: 11px; color: #aaa; display: block; margin-bottom: 4px; }

.stats {
    position: fixed; bottom: 15px; left: 15px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px;
    border: 1px solid rgba(255,255,255,0.1);
    font-size: 13px;
}
.stats div { margin: 3px 0; }
.stats span { color: #8ab4f8; font-weight: 600; }

.info {
    position: fixed; bottom: 15px; right: 15px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px; max-width: 320px;
    border: 1px solid rgba(255,255,255,0.1);
    font-size: 12px; line-height: 1.5;
}
.info h4 { color: #8ab4f8; margin-bottom: 6px; font-size: 14px; }
.info .complexity { color: #ffd700; font-family: monospace; }

.run-stack {
    position: fixed; top: 50%; left: 15px; transform: translateY(-50%); z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px; min-width: 140px;
    border: 1px solid rgba(255,255,255,0.1);
    font-size: 11px;
}
.run-stack h4 { color: #8ab4f8; margin-bottom: 8px; font-size: 12px; }
.run-entry { padding: 3px 6px; margin: 2px 0; border-radius: 4px; font-family: monospace; }
</style>
</head>
<body>
<a href="index.html" class="back-link">&larr; Back to Sorting Algorithms</a>

<canvas id="canvas"></canvas>

<div class="controls">
    <h3>TimSort</h3>
    <label>Speed <span class="value" id="speedVal">50</span></label>
    <input type="range" id="speed" min="1" max="200" value="50">
    <label>Array Size <span class="value" id="sizeVal">80</span></label>
    <input type="range" id="size" min="16" max="200" value="80">
    <div class="pattern-group">
        <span>Data Pattern:</span>
        <div class="btn-row">
            <button class="btn active" data-pattern="random">Random</button>
            <button class="btn" data-pattern="nearly-sorted">Nearly Sorted</button>
            <button class="btn" data-pattern="reversed">Reversed</button>
            <button class="btn" data-pattern="few-unique">Few Unique</button>
        </div>
    </div>
    <div class="btn-row">
        <button class="btn" id="newArr">New Array</button>
        <button class="btn" id="startBtn">Start</button>
        <button class="btn" id="pauseBtn">Pause</button>
    </div>
</div>

<div class="stats">
    <div>Comparisons: <span id="comparisons">0</span></div>
    <div>Swaps/Moves: <span id="swaps">0</span></div>
    <div>Array Accesses: <span id="accesses">0</span></div>
    <div>Runs Found: <span id="runs">0</span></div>
    <div>Phase: <span id="phase">Ready</span></div>
    <div>Status: <span id="status">Ready</span></div>
</div>

<div class="run-stack" id="runStackPanel">
    <h4>Run Stack</h4>
    <div id="runStackContent">Empty</div>
</div>

<div class="info">
    <h4>TimSort</h4>
    <p>Python's and Java's default sort. Finds natural runs (already sorted subsequences), extends short ones with insertion sort, then merges using a stack-based strategy.</p>
    <p style="margin-top:6px;">Worst: <span class="complexity">O(n log n)</span><br>
    Best: <span class="complexity">O(n)</span> (pre-sorted)<br>
    Space: <span class="complexity">O(n)</span><br>
    Stable: Yes</p>
    <p style="margin-top:6px; color:#aaa;">Each color = a detected run. Watch runs get extended, then merged pairwise.</p>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

const speedSlider = document.getElementById('speed');
const sizeSlider = document.getElementById('size');
const speedVal = document.getElementById('speedVal');
const sizeVal = document.getElementById('sizeVal');
const compEl = document.getElementById('comparisons');
const swapEl = document.getElementById('swaps');
const accEl = document.getElementById('accesses');
const runsEl = document.getElementById('runs');
const phaseEl = document.getElementById('phase');
const statusEl = document.getElementById('status');
const runStackContent = document.getElementById('runStackContent');

let arr = [], n = 80;
let comparisons = 0, swaps = 0, accesses = 0;
let sorting = false, paused = false;
let operations = [], opIndex = 0;
let barStates = [];
let barRunId = [];
let runStack = [];
let dataPattern = 'random';

const MIN_RUN = 16;

const runColors = [
    '#ff6b6b', '#ffa06b', '#ffd93d', '#6bff6b', '#6bd4ff',
    '#a06bff', '#ff6bda', '#ff9e9e', '#9effa0', '#9ed4ff',
    '#d4a0ff', '#ffcf6b', '#6bffd9', '#ff6ba0', '#c8ff6b',
    '#e06bff', '#6bffe0', '#ff8c6b', '#6baeff', '#d9ff6b'
];

function generateArray() {
    n = parseInt(sizeSlider.value);
    arr = [];
    switch (dataPattern) {
        case 'random':
            for (let i = 0; i < n; i++) arr.push(Math.random() * 0.85 + 0.1);
            break;
        case 'nearly-sorted':
            for (let i = 0; i < n; i++) arr.push((i / n) * 0.8 + 0.1);
            // Small perturbations
            for (let i = 0; i < Math.floor(n * 0.1); i++) {
                const a = Math.floor(Math.random() * n);
                const b = Math.floor(Math.random() * n);
                const t = arr[a]; arr[a] = arr[b]; arr[b] = t;
            }
            break;
        case 'reversed':
            for (let i = 0; i < n; i++) arr.push(((n - i) / n) * 0.8 + 0.1);
            break;
        case 'few-unique':
            const vals = [0.15, 0.35, 0.55, 0.75, 0.9];
            for (let i = 0; i < n; i++) arr.push(vals[Math.floor(Math.random() * vals.length)]);
            break;
    }
    barStates = new Array(n).fill('default');
    barRunId = new Array(n).fill(-1);
    comparisons = 0; swaps = 0; accesses = 0;
    operations = []; opIndex = 0;
    sorting = false; paused = false;
    runStack = [];
    updateStats();
    phaseEl.textContent = 'Ready';
    statusEl.textContent = 'Ready';
    updateRunStackUI();
}

function updateStats() {
    compEl.textContent = comparisons;
    swapEl.textContent = swaps;
    accEl.textContent = accesses;
}

function updateRunStackUI() {
    if (runStack.length === 0) {
        runStackContent.innerHTML = '<div style="color:#666;">Empty</div>';
        return;
    }
    runStackContent.innerHTML = runStack.map((r, i) => {
        const c = runColors[i % runColors.length];
        return `<div class="run-entry" style="background:${c}22; border-left:3px solid ${c};">[${r.start}..${r.start + r.len - 1}] len=${r.len}</div>`;
    }).join('');
}

function computeMinRun(n) {
    let r = 0;
    while (n >= MIN_RUN) {
        r |= (n & 1);
        n >>= 1;
    }
    return n + r;
}

function buildTimSortOps(a) {
    const ops = [];
    const len = a.length;
    const minRun = computeMinRun(len);
    let runId = 0;
    const stack = [];

    ops.push({ type: 'phase', phase: 'Finding Natural Runs' });

    // Phase 1: Find runs
    let i = 0;
    while (i < len) {
        let runStart = i;
        if (i + 1 < len) {
            ops.push({ type: 'compare', i, j: i + 1 });
            if (a[i] > a[i + 1]) {
                // Descending run
                while (i + 1 < len && a[i] > a[i + 1]) {
                    ops.push({ type: 'compare', i, j: i + 1 });
                    i++;
                }
                i++;
                // Reverse the descending run
                let lo = runStart, hi = i - 1;
                while (lo < hi) {
                    ops.push({ type: 'swap', i: lo, j: hi });
                    const t = a[lo]; a[lo] = a[hi]; a[hi] = t;
                    lo++; hi--;
                }
            } else {
                // Ascending run
                while (i + 1 < len && a[i] <= a[i + 1]) {
                    ops.push({ type: 'compare', i, j: i + 1 });
                    i++;
                }
                i++;
            }
        } else {
            i++;
        }

        let runLen = i - runStart;
        ops.push({ type: 'run-found', start: runStart, len: runLen, id: runId });

        // Extend with insertion sort if too short
        if (runLen < minRun) {
            const targetEnd = Math.min(runStart + minRun, len);
            ops.push({ type: 'phase', phase: 'Extending Run (Insertion Sort)' });
            while (i < targetEnd) {
                let j = i;
                while (j > runStart) {
                    ops.push({ type: 'compare', i: j - 1, j });
                    if (a[j - 1] > a[j]) {
                        ops.push({ type: 'swap', i: j - 1, j });
                        const t = a[j - 1]; a[j - 1] = a[j]; a[j] = t;
                        j--;
                    } else {
                        break;
                    }
                }
                i++;
            }
            runLen = i - runStart;
            ops.push({ type: 'run-extended', start: runStart, len: runLen, id: runId });
        }

        stack.push({ start: runStart, len: runLen, id: runId });
        ops.push({ type: 'stack-push', stack: stack.map(s => ({ ...s })) });
        runId++;

        // Merge collapse
        ops.push({ type: 'phase', phase: 'Checking Merge Rules' });
        while (stack.length > 1) {
            let n2 = stack.length;
            let merged = false;

            if (n2 >= 3 && stack[n2 - 3].len <= stack[n2 - 2].len + stack[n2 - 1].len) {
                if (stack[n2 - 3].len < stack[n2 - 1].len) {
                    mergeRuns(a, stack, n2 - 3, n2 - 2, ops);
                } else {
                    mergeRuns(a, stack, n2 - 2, n2 - 1, ops);
                }
                merged = true;
            } else if (stack[n2 - 2].len <= stack[n2 - 1].len) {
                mergeRuns(a, stack, n2 - 2, n2 - 1, ops);
                merged = true;
            }

            if (!merged) break;
        }
    }

    // Force merge remaining
    ops.push({ type: 'phase', phase: 'Final Merges' });
    while (stack.length > 1) {
        let n2 = stack.length;
        if (n2 >= 3 && stack[n2 - 3].len < stack[n2 - 1].len) {
            mergeRuns(a, stack, n2 - 3, n2 - 2, ops);
        } else {
            mergeRuns(a, stack, n2 - 2, n2 - 1, ops);
        }
    }

    ops.push({ type: 'done' });
    return ops;
}

function mergeRuns(a, stack, idx1, idx2, ops) {
    const run1 = stack[idx1];
    const run2 = stack[idx2];
    ops.push({ type: 'merge-start', run1: { ...run1 }, run2: { ...run2 } });

    const start = run1.start;
    const len1 = run1.len;
    const len2 = run2.len;
    const temp = a.slice(start, start + len1);

    let i = 0, j = run2.start, k = start;
    while (i < len1 && j < run2.start + len2) {
        ops.push({ type: 'merge-compare', k, src1: start + i, src2: j });
        if (temp[i] <= a[j]) {
            a[k] = temp[i];
            ops.push({ type: 'merge-write', idx: k, val: a[k] });
            i++;
        } else {
            a[k] = a[j];
            ops.push({ type: 'merge-write', idx: k, val: a[k] });
            j++;
        }
        k++;
    }
    while (i < len1) {
        a[k] = temp[i];
        ops.push({ type: 'merge-write', idx: k, val: a[k] });
        i++; k++;
    }
    while (j < run2.start + len2) {
        a[k] = a[j];
        ops.push({ type: 'merge-write', idx: k, val: a[k] });
        j++; k++;
    }

    // Update stack
    stack[idx1] = { start, len: len1 + len2, id: run1.id };
    stack.splice(idx2, 1);
    ops.push({ type: 'merge-end', mergedRun: { ...stack[idx1] }, stack: stack.map(s => ({ ...s })) });
}

function startSort() {
    if (sorting && !paused) return;
    if (paused) { paused = false; statusEl.textContent = 'Sorting...'; return; }
    const arrCopy = arr.slice();
    operations = buildTimSortOps(arrCopy);
    opIndex = 0;
    comparisons = 0; swaps = 0; accesses = 0;
    sorting = true; paused = false;
    barStates = new Array(n).fill('default');
    barRunId = new Array(n).fill(-1);
    runStack = [];
    statusEl.textContent = 'Sorting...';
    runsEl.textContent = '0';
    updateRunStackUI();
}

function processOps() {
    if (!sorting || paused) return;
    const speed = parseInt(speedSlider.value);
    const opsPerFrame = Math.max(1, Math.floor(speed / 5));

    for (let s = 0; s < opsPerFrame && opIndex < operations.length; s++) {
        const op = operations[opIndex++];
        switch (op.type) {
            case 'phase':
                phaseEl.textContent = op.phase;
                break;
            case 'compare':
                comparisons++; accesses += 2;
                for (let k = 0; k < n; k++) {
                    if (barStates[k] === 'comparing' || barStates[k] === 'swapping') barStates[k] = barRunId[k] >= 0 ? 'run' : 'default';
                }
                barStates[op.i] = 'comparing';
                barStates[op.j] = 'comparing';
                break;
            case 'swap':
                swaps++; accesses += 4;
                const t = arr[op.i]; arr[op.i] = arr[op.j]; arr[op.j] = t;
                const tr = barRunId[op.i]; barRunId[op.i] = barRunId[op.j]; barRunId[op.j] = tr;
                barStates[op.i] = 'swapping';
                barStates[op.j] = 'swapping';
                break;
            case 'run-found':
                for (let k = op.start; k < op.start + op.len; k++) {
                    barRunId[k] = op.id;
                    barStates[k] = 'run';
                }
                runsEl.textContent = op.id + 1;
                break;
            case 'run-extended':
                for (let k = op.start; k < op.start + op.len; k++) {
                    barRunId[k] = op.id;
                    barStates[k] = 'run';
                }
                break;
            case 'stack-push':
                runStack = op.stack;
                updateRunStackUI();
                break;
            case 'merge-start':
                for (let k = op.run1.start; k < op.run1.start + op.run1.len; k++) barStates[k] = 'merging';
                for (let k = op.run2.start; k < op.run2.start + op.run2.len; k++) barStates[k] = 'merging';
                break;
            case 'merge-compare':
                comparisons++; accesses += 2;
                for (let k = 0; k < n; k++) {
                    if (barStates[k] === 'comparing') barStates[k] = 'merging';
                }
                if (op.src1 < n) barStates[op.src1] = 'comparing';
                if (op.src2 < n) barStates[op.src2] = 'comparing';
                break;
            case 'merge-write':
                swaps++; accesses += 2;
                arr[op.idx] = op.val;
                barStates[op.idx] = 'swapping';
                break;
            case 'merge-end':
                for (let k = op.mergedRun.start; k < op.mergedRun.start + op.mergedRun.len; k++) {
                    barRunId[k] = op.mergedRun.id;
                    barStates[k] = 'run';
                }
                runStack = op.stack;
                updateRunStackUI();
                break;
            case 'done':
                sorting = false;
                for (let k = 0; k < n; k++) barStates[k] = 'sorted';
                statusEl.textContent = 'Complete!';
                phaseEl.textContent = 'Done';
                break;
        }
        updateStats();
    }
}

function getBarColor(i) {
    const s = barStates[i];
    if (s === 'sorted') return '#4ade80';
    if (s === 'comparing') return '#ffffff';
    if (s === 'swapping') return '#ffd93d';
    if (s === 'merging') return '#ff9e6b';
    if (s === 'run' && barRunId[i] >= 0) {
        return runColors[barRunId[i] % runColors.length];
    }
    const hue = arr[i] * 270;
    return `hsl(${hue}, 80%, 55%)`;
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    const topPad = 60, bottomPad = 40;
    const barAreaH = H - topPad - bottomPad;
    const gap = Math.max(1, Math.floor(W * 0.002));
    const totalBarW = W - 200;
    const barW = Math.max(2, (totalBarW - (n - 1) * gap) / n);
    const startX = 160 + (totalBarW - (barW * n + gap * (n - 1))) / 2;

    // Draw run boundaries
    if (sorting) {
        let prevRun = barRunId[0];
        for (let i = 1; i < n; i++) {
            if (barRunId[i] !== prevRun && barRunId[i] >= 0 && prevRun >= 0) {
                const x = startX + i * (barW + gap) - gap / 2;
                ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(x, topPad);
                ctx.lineTo(x, topPad + barAreaH);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            prevRun = barRunId[i];
        }
    }

    // Draw bars
    for (let i = 0; i < n; i++) {
        const x = startX + i * (barW + gap);
        const bh = arr[i] * barAreaH;
        const y = topPad + barAreaH - bh;
        ctx.fillStyle = getBarColor(i);
        ctx.fillRect(x, y, barW, bh);

        // Run ID at bottom
        if (barRunId[i] >= 0 && sorting) {
            const c = runColors[barRunId[i] % runColors.length];
            ctx.fillStyle = c;
            ctx.globalAlpha = 0.4;
            ctx.fillRect(x, topPad + barAreaH + 3, barW, 3);
            ctx.globalAlpha = 1;
        }
    }

    // Title
    ctx.fillStyle = '#8ab4f8';
    ctx.font = 'bold 16px system-ui';
    ctx.fillText('TimSort', startX, 30);
    ctx.font = '12px system-ui';
    ctx.fillStyle = '#666';
    ctx.fillText('Find runs, extend with insertion sort, merge with stack rules', startX + 80, 30);

    // Legend
    const ly = H - 18;
    ctx.font = '11px system-ui';
    ctx.fillStyle = '#fff'; ctx.fillRect(startX, ly - 8, 10, 10);
    ctx.fillStyle = '#aaa'; ctx.fillText('Compare', startX + 14, ly);
    ctx.fillStyle = '#ffd93d'; ctx.fillRect(startX + 75, ly - 8, 10, 10);
    ctx.fillStyle = '#aaa'; ctx.fillText('Move', startX + 89, ly);
    ctx.fillStyle = '#ff9e6b'; ctx.fillRect(startX + 130, ly - 8, 10, 10);
    ctx.fillStyle = '#aaa'; ctx.fillText('Merging', startX + 144, ly);
    ctx.fillStyle = '#4ade80'; ctx.fillRect(startX + 205, ly - 8, 10, 10);
    ctx.fillStyle = '#aaa'; ctx.fillText('Sorted', startX + 219, ly);

    processOps();
    requestAnimationFrame(draw);
}

// Pattern buttons
document.querySelectorAll('[data-pattern]').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('[data-pattern]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        dataPattern = btn.dataset.pattern;
        if (!sorting) generateArray();
    });
});

speedSlider.addEventListener('input', () => { speedVal.textContent = speedSlider.value; });
sizeSlider.addEventListener('input', () => { sizeVal.textContent = sizeSlider.value; if (!sorting) generateArray(); });
document.getElementById('newArr').addEventListener('click', () => { sorting = false; generateArray(); });
document.getElementById('startBtn').addEventListener('click', startSort);
document.getElementById('pauseBtn').addEventListener('click', () => {
    if (sorting) { paused = !paused; statusEl.textContent = paused ? 'Paused' : 'Sorting...'; }
});

window.reset = function() { sorting = false; generateArray(); };

generateArray();
draw();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
