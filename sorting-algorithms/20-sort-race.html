<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sort Racing - Sorting Algorithms</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; }
a.back-link {
    position: fixed; top: 16px; left: 16px; color: #8ab4f8; text-decoration: none;
    font-size: 14px; z-index: 100; opacity: 0.8; transition: opacity 0.2s;
}
a.back-link:hover { opacity: 1; }

.controls {
    position: fixed; top: 16px; right: 16px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 16px; width: 260px;
    border: 1px solid rgba(255,255,255,0.08);
    max-height: calc(100vh - 32px); overflow-y: auto;
}
.controls h3 { font-size: 14px; color: #8ab4f8; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
.controls label { display: block; font-size: 12px; color: #aaa; margin-top: 6px; }
.controls input[type=range] { width: 100%; margin: 4px 0; accent-color: #8ab4f8; }
.controls select {
    width: 100%; margin: 4px 0; padding: 4px 8px; border-radius: 6px;
    background: #1a1a3a; color: #e0e0e0; border: 1px solid rgba(255,255,255,0.1); font-size: 12px;
}
.btn {
    display: inline-block; margin: 4px 2px; padding: 6px 14px; border: none; border-radius: 6px;
    background: #1a3a5c; color: #8ab4f8; font-size: 12px; cursor: pointer; transition: background 0.2s;
}
.btn:hover { background: #244a6c; }
.btn.active { background: #2e6b3e; color: #8f8; }
.btn.race-btn {
    display: block; width: 100%; padding: 10px; font-size: 14px; font-weight: bold;
    background: linear-gradient(135deg, #1a5c3a, #2e6b4e); color: #8f8; margin-top: 12px;
}
.btn.race-btn:hover { background: linear-gradient(135deg, #2e6b4e, #3e7b5e); }
.btn-row { margin-top: 8px; display: flex; flex-wrap: wrap; gap: 4px; }

.algo-check {
    display: flex; align-items: center; gap: 6px; padding: 3px 0;
}
.algo-check input { accent-color: #8ab4f8; }
.algo-check label { margin: 0; font-size: 12px; color: #ccc; cursor: pointer; }
.algo-list { margin-top: 8px; max-height: 200px; overflow-y: auto; }

.leaderboard {
    position: fixed; bottom: 16px; left: 16px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px; min-width: 280px;
    border: 1px solid rgba(255,255,255,0.08); font-size: 13px;
}
.leaderboard h4 { color: #ffd700; margin-bottom: 8px; font-size: 13px; text-transform: uppercase; letter-spacing: 1px; }
.lb-entry { display: flex; align-items: center; gap: 10px; padding: 3px 0; font-size: 12px; }
.lb-rank { color: #ffd700; font-weight: bold; width: 24px; text-align: center; font-family: monospace; }
.lb-name { color: #ccc; flex: 1; }
.lb-time { color: #8ab4f8; font-family: monospace; }
.lb-entry.gold .lb-rank { color: #ffd700; font-size: 16px; }
.lb-entry.silver .lb-rank { color: #c0c0c0; }
.lb-entry.bronze .lb-rank { color: #cd7f32; }

.countdown {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    font-size: 120px; font-weight: bold; color: #ffd700;
    text-shadow: 0 0 40px rgba(255,215,0,0.5);
    z-index: 200; pointer-events: none; opacity: 0;
    transition: opacity 0.2s;
}
.countdown.show { opacity: 1; }

.info-panel {
    position: fixed; bottom: 16px; right: 16px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px; max-width: 260px;
    border: 1px solid rgba(255,255,255,0.08); font-size: 12px; line-height: 1.6;
}
.info-panel h4 { color: #8ab4f8; margin-bottom: 6px; }
</style>
</head>
<body>
<a href="index.html" class="back-link">&#8592; Back to Gallery</a>
<canvas id="canvas"></canvas>
<div id="countdown" class="countdown"></div>

<div class="controls">
    <h3>Sort Racing</h3>
    <label>Array Size: <span id="sizeVal">80</span></label>
    <input type="range" id="sizeSlider" min="20" max="200" value="80">
    <label>Data Pattern:</label>
    <select id="patternSelect">
        <option value="random">Random</option>
        <option value="nearly">Nearly Sorted</option>
        <option value="reversed">Reversed</option>
        <option value="fewunique">Few Unique Values</option>
    </select>
    <label style="margin-top:10px;">Select Racers:</label>
    <div class="algo-list" id="algoList"></div>
    <button class="btn race-btn" id="btnRace">START RACE</button>
    <button class="btn" id="btnNew" style="width:100%;margin-top:6px;">New Array</button>
</div>

<div class="leaderboard" id="leaderboard">
    <h4>Leaderboard</h4>
    <div id="lbEntries"><span style="color:#666;font-size:11px;">Race not started</span></div>
</div>

<div class="info-panel">
    <h4>Sort Racing</h4>
    <p>Head-to-head comparison! All algorithms sort the same shuffled array. Watch as different strategies unfold simultaneously. Who will finish first?</p>
    <p style="margin-top:6px;color:#888;">Try different data patterns - some algorithms excel on nearly-sorted data while others dominate random input.</p>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// Algorithm definitions
var ALGOS = [
    { id: 'bubble', name: 'Bubble Sort', color: '#ff6b6b' },
    { id: 'selection', name: 'Selection Sort', color: '#ffa07a' },
    { id: 'insertion', name: 'Insertion Sort', color: '#ffd700' },
    { id: 'merge', name: 'Merge Sort', color: '#4fc3f7' },
    { id: 'quick', name: 'Quick Sort', color: '#81c784' },
    { id: 'heap', name: 'Heap Sort', color: '#ce93d8' },
    { id: 'shell', name: 'Shell Sort', color: '#ff8a65' },
    { id: 'comb', name: 'Comb Sort', color: '#a5d6a7' }
];

var selectedAlgos = ['bubble', 'insertion', 'merge', 'quick', 'heap', 'shell'];
var arraySize = 80;
var baseArray = [];
var racers = [];
var racing = false;
var raceStartTime = 0;
var leaderboard = [];
var countdownActive = false;

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// Build algorithm checkbox list
(function buildAlgoList() {
    var list = document.getElementById('algoList');
    var html = '';
    for (var i = 0; i < ALGOS.length; i++) {
        var a = ALGOS[i];
        var checked = selectedAlgos.indexOf(a.id) >= 0 ? 'checked' : '';
        html += '<div class="algo-check">' +
            '<input type="checkbox" id="chk_' + a.id + '" ' + checked + ' data-algo="' + a.id + '">' +
            '<label for="chk_' + a.id + '" style="color:' + a.color + ';">' + a.name + '</label></div>';
    }
    list.innerHTML = html;
    var inputs = list.querySelectorAll('input');
    for (var i = 0; i < inputs.length; i++) {
        inputs[i].addEventListener('change', function() {
            selectedAlgos = [];
            var boxes = list.querySelectorAll('input');
            for (var j = 0; j < boxes.length; j++) {
                if (boxes[j].checked) selectedAlgos.push(boxes[j].dataset.algo);
            }
        });
    }
})();

function generateBaseArray() {
    var pattern = document.getElementById('patternSelect').value;
    baseArray = [];
    for (var i = 0; i < arraySize; i++) {
        baseArray.push((i + 1) / (arraySize + 1));
    }

    if (pattern === 'random') {
        for (var i = baseArray.length - 1; i > 0; i--) {
            var j = Math.floor(Math.random() * (i + 1));
            var tmp = baseArray[i]; baseArray[i] = baseArray[j]; baseArray[j] = tmp;
        }
    } else if (pattern === 'nearly') {
        // Slight perturbation
        for (var i = 0; i < Math.floor(arraySize * 0.1); i++) {
            var a = Math.floor(Math.random() * arraySize);
            var b = Math.floor(Math.random() * arraySize);
            var tmp = baseArray[a]; baseArray[a] = baseArray[b]; baseArray[b] = tmp;
        }
    } else if (pattern === 'reversed') {
        baseArray.reverse();
    } else if (pattern === 'fewunique') {
        var vals = [0.2, 0.4, 0.6, 0.8];
        for (var i = 0; i < arraySize; i++) {
            baseArray[i] = vals[Math.floor(Math.random() * vals.length)];
        }
    }
}

// Each racer has its own array copy and sorting state
function Racer(algo) {
    this.algo = algo;
    this.arr = baseArray.slice();
    this.comparisons = 0;
    this.swaps = 0;
    this.done = false;
    this.finishTime = 0;
    this.highlightA = -1;
    this.highlightB = -1;
    this.name = '';
    this.color = '#fff';

    for (var i = 0; i < ALGOS.length; i++) {
        if (ALGOS[i].id === algo) {
            this.name = ALGOS[i].name;
            this.color = ALGOS[i].color;
            break;
        }
    }

    // Sort state
    this.stateInit = false;
    this.state = {};
}

// Sort step functions for each algorithm
function bubbleStep(r) {
    if (!r.stateInit) { r.state = { i: 0, end: r.arr.length }; r.stateInit = true; }
    var s = r.state;
    if (s.i >= s.end - 1) { s.i = 0; s.end--; }
    if (s.end <= 1) { r.done = true; return; }
    r.highlightA = s.i; r.highlightB = s.i + 1;
    r.comparisons++;
    if (r.arr[s.i] > r.arr[s.i + 1]) {
        var tmp = r.arr[s.i]; r.arr[s.i] = r.arr[s.i + 1]; r.arr[s.i + 1] = tmp;
        r.swaps++;
    }
    s.i++;
}

function selectionStep(r) {
    if (!r.stateInit) { r.state = { i: 0, j: 1, minIdx: 0 }; r.stateInit = true; }
    var s = r.state;
    if (s.i >= r.arr.length - 1) { r.done = true; return; }
    if (s.j < r.arr.length) {
        r.highlightA = s.minIdx; r.highlightB = s.j;
        r.comparisons++;
        if (r.arr[s.j] < r.arr[s.minIdx]) s.minIdx = s.j;
        s.j++;
    } else {
        if (s.minIdx !== s.i) {
            var tmp = r.arr[s.i]; r.arr[s.i] = r.arr[s.minIdx]; r.arr[s.minIdx] = tmp;
            r.swaps++;
        }
        s.i++;
        s.j = s.i + 1;
        s.minIdx = s.i;
    }
}

function insertionStep(r) {
    if (!r.stateInit) { r.state = { i: 1, j: 1, key: 0, placing: false }; r.stateInit = true; }
    var s = r.state;
    if (s.i >= r.arr.length) { r.done = true; return; }
    if (!s.placing) {
        s.key = r.arr[s.i];
        s.j = s.i - 1;
        s.placing = true;
    }
    r.highlightA = s.j + 1; r.highlightB = s.j;
    if (s.j >= 0) {
        r.comparisons++;
        if (r.arr[s.j] > s.key) {
            r.arr[s.j + 1] = r.arr[s.j];
            r.swaps++;
            s.j--;
        } else {
            r.arr[s.j + 1] = s.key;
            s.i++;
            s.placing = false;
        }
    } else {
        r.arr[s.j + 1] = s.key;
        s.i++;
        s.placing = false;
    }
}

function mergeStep(r) {
    if (!r.stateInit) {
        // Pre-build merge operations
        r.state = { ops: [], idx: 0 };
        buildMergeOps(r.state.ops, 0, r.arr.length - 1);
        r.stateInit = true;
    }
    var s = r.state;
    if (s.idx >= s.ops.length) { r.done = true; return; }
    var op = s.ops[s.idx];
    // Execute one merge comparison
    if (op.phase === 'merge') {
        var left = op.left, mid = op.mid, right = op.right;
        if (!op.started) {
            op.temp = r.arr.slice(left, right + 1);
            op.li = 0; op.ri = mid - left + 1; op.ki = left;
            op.leftLen = mid - left + 1; op.rightLen = right - mid;
            op.started = true;
        }
        if (op.li < op.leftLen && op.ri < op.temp.length) {
            r.comparisons++;
            r.highlightA = left + op.li; r.highlightB = mid + 1 + (op.ri - op.leftLen);
            if (op.temp[op.li] <= op.temp[op.ri]) {
                r.arr[op.ki] = op.temp[op.li]; op.li++;
            } else {
                r.arr[op.ki] = op.temp[op.ri]; op.ri++;
            }
            r.swaps++;
            op.ki++;
        } else if (op.li < op.leftLen) {
            r.arr[op.ki] = op.temp[op.li]; op.li++; op.ki++; r.swaps++;
        } else if (op.ri < op.temp.length) {
            r.arr[op.ki] = op.temp[op.ri]; op.ri++; op.ki++; r.swaps++;
        } else {
            s.idx++;
        }
    }
}

function buildMergeOps(ops, left, right) {
    if (left >= right) return;
    var mid = Math.floor((left + right) / 2);
    buildMergeOps(ops, left, mid);
    buildMergeOps(ops, mid + 1, right);
    ops.push({ phase: 'merge', left: left, mid: mid, right: right, started: false });
}

function quickStep(r) {
    if (!r.stateInit) {
        r.state = { stack: [[0, r.arr.length - 1]], partState: null };
        r.stateInit = true;
    }
    var s = r.state;
    if (!s.partState) {
        if (s.stack.length === 0) { r.done = true; return; }
        var range = s.stack.pop();
        if (range[0] >= range[1]) { return; }
        s.partState = { lo: range[0], hi: range[1], pivot: r.arr[range[1]], i: range[0], j: range[0] };
    }
    var p = s.partState;
    r.highlightA = p.j; r.highlightB = p.hi;
    if (p.j < p.hi) {
        r.comparisons++;
        if (r.arr[p.j] < p.pivot) {
            var tmp = r.arr[p.i]; r.arr[p.i] = r.arr[p.j]; r.arr[p.j] = tmp;
            r.swaps++;
            p.i++;
        }
        p.j++;
    } else {
        var tmp = r.arr[p.i]; r.arr[p.i] = r.arr[p.hi]; r.arr[p.hi] = tmp;
        r.swaps++;
        var pi = p.i;
        s.stack.push([pi + 1, p.hi]);
        s.stack.push([p.lo, pi - 1]);
        s.partState = null;
    }
}

function heapStep(r) {
    if (!r.stateInit) {
        r.state = { phase: 'build', i: Math.floor(r.arr.length / 2) - 1, end: r.arr.length, heapifying: false, hi: 0, hsize: 0 };
        r.stateInit = true;
    }
    var s = r.state;
    if (s.phase === 'build') {
        if (!s.heapifying) {
            if (s.i < 0) { s.phase = 'extract'; s.end = r.arr.length - 1; return; }
            s.hi = s.i; s.hsize = r.arr.length; s.heapifying = true;
        }
        // One step of heapify
        var largest = s.hi;
        var l = 2 * s.hi + 1, rc = 2 * s.hi + 2;
        if (l < s.hsize) { r.comparisons++; if (r.arr[l] > r.arr[largest]) largest = l; }
        if (rc < s.hsize) { r.comparisons++; if (r.arr[rc] > r.arr[largest]) largest = rc; }
        r.highlightA = s.hi; r.highlightB = largest;
        if (largest !== s.hi) {
            var tmp = r.arr[s.hi]; r.arr[s.hi] = r.arr[largest]; r.arr[largest] = tmp;
            r.swaps++;
            s.hi = largest;
        } else {
            s.heapifying = false;
            s.i--;
        }
    } else {
        if (s.end <= 0) { r.done = true; return; }
        if (!s.heapifying) {
            var tmp = r.arr[0]; r.arr[0] = r.arr[s.end]; r.arr[s.end] = tmp;
            r.swaps++;
            s.hsize = s.end;
            s.hi = 0;
            s.heapifying = true;
            s.end--;
        } else {
            var largest = s.hi;
            var l = 2 * s.hi + 1, rc = 2 * s.hi + 2;
            if (l < s.hsize) { r.comparisons++; if (r.arr[l] > r.arr[largest]) largest = l; }
            if (rc < s.hsize) { r.comparisons++; if (r.arr[rc] > r.arr[largest]) largest = rc; }
            r.highlightA = s.hi; r.highlightB = largest;
            if (largest !== s.hi) {
                var tmp = r.arr[s.hi]; r.arr[s.hi] = r.arr[largest]; r.arr[largest] = tmp;
                r.swaps++;
                s.hi = largest;
            } else {
                s.heapifying = false;
            }
        }
    }
}

function shellStep(r) {
    if (!r.stateInit) {
        // Compute gap sequence
        var gaps = [];
        var g = Math.floor(r.arr.length / 2);
        while (g > 0) { gaps.push(g); g = Math.floor(g / 2); }
        r.state = { gaps: gaps, gi: 0, i: 0, j: 0, key: 0, placing: false };
        r.stateInit = true;
    }
    var s = r.state;
    if (s.gi >= s.gaps.length) { r.done = true; return; }
    var gap = s.gaps[s.gi];
    if (!s.placing) {
        if (s.i === 0) s.i = gap;
        if (s.i >= r.arr.length) { s.gi++; s.i = 0; return; }
        s.key = r.arr[s.i];
        s.j = s.i - gap;
        s.placing = true;
    }
    r.highlightA = s.j + gap; r.highlightB = s.j >= 0 ? s.j : 0;
    if (s.j >= 0) {
        r.comparisons++;
        if (r.arr[s.j] > s.key) {
            r.arr[s.j + gap] = r.arr[s.j];
            r.swaps++;
            s.j -= gap;
        } else {
            r.arr[s.j + gap] = s.key;
            s.i++;
            s.placing = false;
        }
    } else {
        r.arr[s.j + gap] = s.key;
        s.i++;
        s.placing = false;
    }
}

function combStep(r) {
    if (!r.stateInit) {
        r.state = { gap: r.arr.length, pos: 0, swapped: false };
        r.stateInit = true;
    }
    var s = r.state;
    if (s.pos + s.gap < r.arr.length) {
        r.highlightA = s.pos; r.highlightB = s.pos + s.gap;
        r.comparisons++;
        if (r.arr[s.pos] > r.arr[s.pos + s.gap]) {
            var tmp = r.arr[s.pos]; r.arr[s.pos] = r.arr[s.pos + s.gap]; r.arr[s.pos + s.gap] = tmp;
            r.swaps++;
            s.swapped = true;
        }
        s.pos++;
    } else {
        s.gap = Math.floor(s.gap / 1.3);
        if (s.gap < 1) s.gap = 1;
        if (s.gap === 1 && !s.swapped) { r.done = true; return; }
        s.pos = 0;
        s.swapped = false;
    }
}

var stepFns = {
    bubble: bubbleStep,
    selection: selectionStep,
    insertion: insertionStep,
    merge: mergeStep,
    quick: quickStep,
    heap: heapStep,
    shell: shellStep,
    comb: combStep
};

function initRace() {
    generateBaseArray();
    racers = [];
    leaderboard = [];
    for (var i = 0; i < selectedAlgos.length; i++) {
        racers.push(new Racer(selectedAlgos[i]));
    }
    updateLeaderboard();
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (racers.length === 0) {
        ctx.font = '20px sans-serif';
        ctx.fillStyle = '#666';
        ctx.textAlign = 'center';
        ctx.fillText('Select algorithms and press START RACE', canvas.width / 2, canvas.height / 2);
        requestAnimationFrame(draw);
        return;
    }

    var cols = racers.length <= 4 ? 2 : (racers.length <= 6 ? 3 : 4);
    var rows = Math.ceil(racers.length / cols);
    var cellW = canvas.width / cols;
    var cellH = canvas.height / rows;
    var barPad = 8;

    for (var idx = 0; idx < racers.length; idx++) {
        var r = racers[idx];
        var col = idx % cols;
        var row = Math.floor(idx / cols);
        var ox = col * cellW;
        var oy = row * cellH;

        // Cell border
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 1;
        ctx.strokeRect(ox, oy, cellW, cellH);

        // Title bar
        var titleH = 28;
        ctx.fillStyle = r.done ? 'rgba(46,204,113,0.15)' : 'rgba(20,20,40,0.6)';
        ctx.fillRect(ox, oy, cellW, titleH);

        ctx.font = 'bold 12px sans-serif';
        ctx.fillStyle = r.color;
        ctx.textAlign = 'left';
        ctx.fillText(r.name, ox + 8, oy + 18);

        // Finish position
        if (r.done) {
            var pos = 0;
            for (var li = 0; li < leaderboard.length; li++) {
                if (leaderboard[li].id === r.algo) { pos = li + 1; break; }
            }
            if (pos > 0) {
                ctx.textAlign = 'right';
                ctx.fillStyle = pos === 1 ? '#ffd700' : (pos === 2 ? '#c0c0c0' : (pos === 3 ? '#cd7f32' : '#888'));
                ctx.fillText('#' + pos + (pos === 1 ? ' WINNER' : ''), ox + cellW - 8, oy + 18);
            }
        }

        // Stats line
        ctx.font = '10px monospace';
        ctx.fillStyle = '#666';
        ctx.textAlign = 'right';
        ctx.fillText('C:' + r.comparisons + ' S:' + r.swaps, ox + cellW - 8, oy + titleH + 14);

        // Bars
        var drawX = ox + barPad;
        var drawY = oy + titleH + 20;
        var drawW = cellW - barPad * 2;
        var drawH = cellH - titleH - 28;
        var barW = drawW / r.arr.length;
        var gapPx = Math.max(0.5, barW * 0.1);

        for (var k = 0; k < r.arr.length; k++) {
            var barH = r.arr[k] * drawH;
            var bx = drawX + k * barW;
            var by = drawY + drawH - barH;

            var bcolor;
            if (r.done) {
                bcolor = '#2ecc71';
            } else if (k === r.highlightA || k === r.highlightB) {
                bcolor = '#ffd700';
            } else {
                bcolor = 'hsl(' + ((1 - r.arr[k]) * 240) + ', 75%, 50%)';
            }

            ctx.fillStyle = bcolor;
            ctx.fillRect(bx + gapPx / 2, by, barW - gapPx, barH);
        }
    }

    requestAnimationFrame(draw);
}

function updateLeaderboard() {
    var html = '';
    if (leaderboard.length === 0 && !racing) {
        html = '<span style="color:#666;font-size:11px;">Race not started</span>';
    } else if (leaderboard.length === 0) {
        html = '<span style="color:#666;font-size:11px;">Racing...</span>';
    }
    for (var i = 0; i < leaderboard.length; i++) {
        var e = leaderboard[i];
        var cls = i === 0 ? 'gold' : (i === 1 ? 'silver' : (i === 2 ? 'bronze' : ''));
        var medal = i === 0 ? '\u{1F947}' : (i === 1 ? '\u{1F948}' : (i === 2 ? '\u{1F949}' : ''));
        html += '<div class="lb-entry ' + cls + '">' +
            '<span class="lb-rank">' + (i + 1) + '</span>' +
            '<span class="lb-name" style="color:' + e.color + ';">' + e.name + '</span>' +
            '<span class="lb-time">' + e.comparisons + ' comps</span></div>';
    }
    document.getElementById('lbEntries').innerHTML = html;
}

var stepsPerTick = 5;

function raceLoop() {
    if (!racing) return;

    var allDone = true;
    for (var i = 0; i < racers.length; i++) {
        var r = racers[i];
        if (!r.done) {
            allDone = false;
            var fn = stepFns[r.algo];
            if (fn) {
                for (var s = 0; s < stepsPerTick; s++) {
                    if (r.done) break;
                    fn(r);
                }
                if (r.done) {
                    r.finishTime = performance.now() - raceStartTime;
                    leaderboard.push({ id: r.algo, name: r.name, color: r.color, comparisons: r.comparisons, time: r.finishTime });
                    updateLeaderboard();
                }
            }
        }
    }

    if (allDone) {
        racing = false;
        document.getElementById('btnRace').textContent = 'START RACE';
        return;
    }

    requestAnimationFrame(raceLoop);
}

function startRace() {
    if (racing) {
        racing = false;
        document.getElementById('btnRace').textContent = 'START RACE';
        return;
    }
    if (selectedAlgos.length < 2) {
        alert('Select at least 2 algorithms to race!');
        return;
    }

    initRace();

    // Countdown
    countdownActive = true;
    var cdEl = document.getElementById('countdown');
    var count = 3;
    cdEl.classList.add('show');
    cdEl.textContent = count;

    var cdInterval = setInterval(function() {
        count--;
        if (count > 0) {
            cdEl.textContent = count;
        } else if (count === 0) {
            cdEl.textContent = 'GO!';
            cdEl.style.color = '#2ecc71';
        } else {
            clearInterval(cdInterval);
            cdEl.classList.remove('show');
            cdEl.style.color = '#ffd700';
            countdownActive = false;

            // Start the race
            racing = true;
            raceStartTime = performance.now();
            stepsPerTick = Math.max(1, Math.floor(arraySize / 15));
            document.getElementById('btnRace').textContent = 'STOP RACE';
            requestAnimationFrame(raceLoop);
        }
    }, 700);
}

document.getElementById('sizeSlider').addEventListener('input', function() {
    arraySize = parseInt(this.value);
    document.getElementById('sizeVal').textContent = arraySize;
});
document.getElementById('btnRace').addEventListener('click', startRace);
document.getElementById('btnNew').addEventListener('click', function() {
    racing = false;
    racers = [];
    leaderboard = [];
    updateLeaderboard();
    document.getElementById('btnRace').textContent = 'START RACE';
});

window.reset = function() {
    racing = false;
    racers = [];
    leaderboard = [];
    updateLeaderboard();
    document.getElementById('btnRace').textContent = 'START RACE';
};

initRace();
requestAnimationFrame(draw);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
