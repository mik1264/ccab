<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bitonic Sort - Sorting Algorithms</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; }
canvas { display: block; }
a.back-link {
    position: fixed; top: 16px; left: 16px; color: #8ab4f8; text-decoration: none;
    font-size: 14px; z-index: 100; opacity: 0.8; transition: opacity 0.2s;
}
a.back-link:hover { opacity: 1; }

.controls {
    position: fixed; top: 16px; right: 16px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 16px; min-width: 220px;
    border: 1px solid rgba(255,255,255,0.08);
}
.controls h3 { font-size: 14px; color: #8ab4f8; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
.controls label { display: block; font-size: 12px; color: #aaa; margin-top: 8px; }
.controls input[type=range] { width: 100%; margin: 4px 0; accent-color: #8ab4f8; }
.controls select {
    width: 100%; margin: 4px 0; padding: 4px 8px; border-radius: 6px;
    background: #1a1a3a; color: #e0e0e0; border: 1px solid rgba(255,255,255,0.1); font-size: 12px;
}
.btn {
    display: inline-block; margin: 4px 2px; padding: 6px 14px; border: none; border-radius: 6px;
    background: #1a3a5c; color: #8ab4f8; font-size: 12px; cursor: pointer; transition: background 0.2s;
}
.btn:hover { background: #244a6c; }
.btn-row { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 4px; }

.stats {
    position: fixed; bottom: 16px; left: 16px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px;
    border: 1px solid rgba(255,255,255,0.08); font-size: 13px;
}
.stats .stat-row { display: flex; justify-content: space-between; gap: 20px; margin: 3px 0; }
.stats .stat-label { color: #888; }
.stats .stat-value { color: #8ab4f8; font-family: 'Courier New', monospace; }

.info-panel {
    position: fixed; bottom: 16px; right: 16px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px; max-width: 320px;
    border: 1px solid rgba(255,255,255,0.08); font-size: 12px; line-height: 1.6;
}
.info-panel h4 { color: #8ab4f8; margin-bottom: 6px; }
.info-panel .complexity { color: #f8d868; font-family: 'Courier New', monospace; font-size: 11px; }

.legend {
    position: fixed; top: 16px; left: 50%; transform: translateX(-50%); z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 8px 16px; display: flex; gap: 16px;
    border: 1px solid rgba(255,255,255,0.08); font-size: 11px;
}
.legend-item { display: flex; align-items: center; gap: 6px; }
.legend-dot { width: 10px; height: 10px; border-radius: 2px; }
</style>
</head>
<body>
<a href="index.html" class="back-link">&#8592; Back to Gallery</a>
<canvas id="canvas"></canvas>

<div class="legend">
    <div class="legend-item"><div class="legend-dot" style="background:#4fc3f7;"></div> Ascending pair</div>
    <div class="legend-item"><div class="legend-dot" style="background:#ff7043;"></div> Descending pair</div>
    <div class="legend-item"><div class="legend-dot" style="background:#ffd700;"></div> Comparing</div>
    <div class="legend-item"><div class="legend-dot" style="background:#2ecc71;"></div> Sorted</div>
</div>

<div class="controls">
    <h3>Bitonic Sort</h3>
    <label>Array Size (power of 2):</label>
    <select id="sizeSelect">
        <option value="8">8</option>
        <option value="16">16</option>
        <option value="32" selected>32</option>
        <option value="64">64</option>
        <option value="128">128</option>
    </select>
    <label>Speed: <span id="speedVal">50</span></label>
    <input type="range" id="speedSlider" min="1" max="100" value="50">
    <div class="btn-row">
        <button class="btn" id="btnStart">Start</button>
        <button class="btn" id="btnStep">Step</button>
        <button class="btn" id="btnNew">New Array</button>
    </div>
    <label style="margin-top:10px;font-size:11px;color:#666;">Stage: <span id="stageInfo" style="color:#8ab4f8;">--</span></label>
</div>

<div class="stats">
    <div class="stat-row"><span class="stat-label">Comparisons:</span><span class="stat-value" id="compCount">0</span></div>
    <div class="stat-row"><span class="stat-label">Swaps:</span><span class="stat-value" id="swapCount">0</span></div>
    <div class="stat-row"><span class="stat-label">Parallel Steps:</span><span class="stat-value" id="parallelCount">0</span></div>
    <div class="stat-row"><span class="stat-label">Status:</span><span class="stat-value" id="statusText">Ready</span></div>
</div>

<div class="info-panel">
    <h4>Bitonic Sort</h4>
    <p>A sorting network that first creates bitonic sequences (ascending then descending), then merges them. All comparators at the same depth can run in parallel on hardware.</p>
    <p class="complexity">
        Worst:&nbsp;&nbsp;&nbsp;O(n log&sup2;n)<br>
        Average: O(n log&sup2;n)<br>
        Best:&nbsp;&nbsp;&nbsp;&nbsp;O(n log&sup2;n)<br>
        Space:&nbsp;&nbsp;&nbsp;O(n log&sup2;n)<br>
        Parallel: O(log&sup2;n)
    </p>
    <p style="margin-top:6px;color:#888;">Ideal for GPU sorting: fixed comparison pattern regardless of data.</p>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let arr = [];
let n = 32;
let speed = 50;
let running = false;
let sorting = false;
let sorted = false;

let comparisons = 0, swapCount = 0, parallelSteps = 0;

// Pre-compute all comparison steps
let steps = [];
let stepIndex = 0;
let currentPairs = [];
let pairDirections = [];

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

function generateArray() {
    arr = [];
    for (let k = 0; k < n; k++) {
        arr.push(Math.random() * 0.9 + 0.05);
    }
    comparisons = 0; swapCount = 0; parallelSteps = 0;
    currentPairs = [];
    pairDirections = [];
    sorting = false;
    sorted = false;
    running = false;
    stepIndex = 0;
    precomputeSteps();
    updateStats();
    document.getElementById('btnStart').textContent = 'Start';
    document.getElementById('statusText').textContent = 'Ready';
    document.getElementById('stageInfo').textContent = '--';
}

function precomputeSteps() {
    steps = [];
    // Generate bitonic sort network
    for (let blockSize = 2; blockSize <= n; blockSize *= 2) {
        for (let subBlock = blockSize / 2; subBlock >= 1; subBlock /= 2) {
            let step = [];
            for (let i = 0; i < n; i++) {
                let partner = i ^ subBlock;
                if (partner > i && partner < n) {
                    // Direction: ascending if (i & blockSize) === 0
                    let ascending = (i & blockSize) === 0;
                    step.push({ a: i, b: partner, asc: ascending });
                }
            }
            if (step.length > 0) {
                steps.push(step);
            }
        }
    }
}

function valueToColor(val) {
    return 'hsl(' + ((1 - val) * 240) + ', 85%, 55%)';
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    let padding = 60;
    let topPad = 80;
    let bottomPad = 80;
    let drawWidth = canvas.width - padding * 2;
    let drawHeight = canvas.height - topPad - bottomPad;
    let barWidth = drawWidth / n;
    let gapPx = Math.max(1, barWidth * 0.1);

    // Draw network connections for current parallel step
    if (currentPairs.length > 0) {
        for (let p = 0; p < currentPairs.length; p++) {
            let pair = currentPairs[p];
            let dir = pairDirections[p];
            let xA = padding + pair.a * barWidth + barWidth / 2;
            let xB = padding + pair.b * barWidth + barWidth / 2;
            let midX = (xA + xB) / 2;
            let arcH = Math.min(50, Math.abs(xB - xA) * 0.2);

            ctx.beginPath();
            ctx.moveTo(xA, topPad + drawHeight + 8);
            ctx.quadraticCurveTo(midX, topPad + drawHeight + 8 + arcH, xB, topPad + drawHeight + 8);
            ctx.strokeStyle = dir ? 'rgba(79,195,247,0.4)' : 'rgba(255,112,67,0.4)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }
    }

    // Find which indices are being compared
    let activeSet = new Set();
    let pairMap = {};
    for (let p = 0; p < currentPairs.length; p++) {
        activeSet.add(currentPairs[p].a);
        activeSet.add(currentPairs[p].b);
        pairMap[currentPairs[p].a] = pairDirections[p];
        pairMap[currentPairs[p].b] = pairDirections[p];
    }

    for (let k = 0; k < n; k++) {
        let barH = arr[k] * drawHeight;
        let x = padding + k * barWidth;
        let y = topPad + drawHeight - barH;

        let color;
        if (sorted) {
            color = '#2ecc71';
        } else if (activeSet.has(k)) {
            color = '#ffd700';
        } else {
            color = valueToColor(arr[k]);
        }

        ctx.fillStyle = color;
        ctx.fillRect(x + gapPx / 2, y, barWidth - gapPx, barH);

        if (barWidth > 6) {
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(x + gapPx / 2, y, 1, barH);
        }
    }

    // Draw small arrows to show direction within bitonic blocks
    if (sorting && !sorted && stepIndex < steps.length) {
        let blockSize = 2;
        let sIdx = 0;
        for (let bs = 2; bs <= n; bs *= 2) {
            for (let sb = bs / 2; sb >= 1; sb /= 2) {
                if (sIdx === stepIndex) { blockSize = bs; break; }
                sIdx++;
            }
            if (sIdx === stepIndex) break;
        }
        // Show block groupings at top
        ctx.font = '9px monospace';
        ctx.textAlign = 'center';
        for (let i = 0; i < n; i += blockSize) {
            let xStart = padding + i * barWidth;
            let xEnd = padding + Math.min(i + blockSize, n) * barWidth;
            let asc = (i & blockSize) === 0;
            ctx.fillStyle = asc ? 'rgba(79,195,247,0.4)' : 'rgba(255,112,67,0.4)';
            ctx.fillRect(xStart, topPad - 20, xEnd - xStart, 3);
            ctx.fillStyle = asc ? '#4fc3f7' : '#ff7043';
            ctx.fillText(asc ? 'ASC' : 'DESC', (xStart + xEnd) / 2, topPad - 8);
        }
    }

    requestAnimationFrame(draw);
}

function updateStats() {
    document.getElementById('compCount').textContent = comparisons;
    document.getElementById('swapCount').textContent = swapCount;
    document.getElementById('parallelCount').textContent = parallelSteps;
}

function sortStep() {
    if (sorted || !sorting || stepIndex >= steps.length) {
        if (sorting && stepIndex >= steps.length) {
            sorted = true;
            running = false;
            sorting = false;
            currentPairs = [];
            pairDirections = [];
            document.getElementById('btnStart').textContent = 'Start';
            document.getElementById('statusText').textContent = 'Sorted!';
            document.getElementById('stageInfo').textContent = 'Complete';
            updateStats();
        }
        return;
    }

    let step = steps[stepIndex];
    currentPairs = step;
    pairDirections = step.map(function(p) { return p.asc; });

    // All pairs in this step can be done in parallel
    parallelSteps++;
    for (let p = 0; p < step.length; p++) {
        let pair = step[p];
        comparisons++;
        if (pair.asc ? (arr[pair.a] > arr[pair.b]) : (arr[pair.a] < arr[pair.b])) {
            let tmp = arr[pair.a];
            arr[pair.a] = arr[pair.b];
            arr[pair.b] = tmp;
            swapCount++;
        }
    }

    document.getElementById('stageInfo').textContent = 'Step ' + (stepIndex + 1) + '/' + steps.length + ' (' + step.length + ' parallel ops)';
    stepIndex++;
    updateStats();
}

let lastTime = 0;
function sortLoop(timestamp) {
    if (!running) return;
    if (!lastTime) lastTime = timestamp;

    let delay = Math.max(5, 300 - speed * 3);
    if (timestamp - lastTime >= delay) {
        lastTime = timestamp;
        let stepsPerFrame = speed > 80 ? Math.floor((speed - 80) * 0.5) + 1 : 1;
        for (let s = 0; s < stepsPerFrame && !sorted; s++) {
            sortStep();
        }
    }
    if (running) requestAnimationFrame(sortLoop);
}

function startSort() {
    if (sorted) { generateArray(); return; }
    if (!sorting) {
        sorting = true;
        stepIndex = 0;
    }
    running = !running;
    document.getElementById('btnStart').textContent = running ? 'Pause' : 'Resume';
    document.getElementById('statusText').textContent = running ? 'Sorting...' : 'Paused';
    if (running) {
        lastTime = 0;
        requestAnimationFrame(sortLoop);
    }
}

function doStep() {
    if (sorted) { generateArray(); return; }
    if (!sorting) {
        sorting = true;
        stepIndex = 0;
    }
    running = false;
    document.getElementById('btnStart').textContent = 'Resume';
    document.getElementById('statusText').textContent = 'Step mode';
    sortStep();
}

document.getElementById('sizeSelect').addEventListener('change', function() {
    n = parseInt(this.value);
    generateArray();
});
document.getElementById('speedSlider').addEventListener('input', function() {
    speed = parseInt(this.value);
    document.getElementById('speedVal').textContent = speed;
});
document.getElementById('btnStart').addEventListener('click', startSort);
document.getElementById('btnStep').addEventListener('click', doStep);
document.getElementById('btnNew').addEventListener('click', generateArray);

window.reset = function() {
    generateArray();
};

generateArray();
requestAnimationFrame(draw);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
