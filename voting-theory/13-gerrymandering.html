<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gerrymandering Lab - Voting Theory</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; }
canvas { display: block; cursor: crosshair; }
a.back-link {
    position: fixed; top: 16px; left: 16px; color: #8ab4f8; text-decoration: none;
    font-size: 14px; z-index: 100; opacity: 0.8; transition: opacity 0.2s;
}
a.back-link:hover { opacity: 1; }

.controls {
    position: fixed; top: 16px; right: 16px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 16px; min-width: 240px;
    border: 1px solid rgba(255,255,255,0.08);
}
.controls h3 { font-size: 14px; color: #8ab4f8; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
.controls label { display: block; font-size: 12px; color: #aaa; margin-top: 8px; }
.controls select, .controls input[type=range] {
    width: 100%; margin: 4px 0; accent-color: #8ab4f8;
}
.controls select {
    padding: 5px 8px; border-radius: 6px;
    background: #1a1a2e; color: #e0e0e0; border: 1px solid rgba(255,255,255,0.1); font-size: 12px;
}
.controls .value { font-size: 11px; color: #666; text-align: right; }
.btn {
    display: inline-block; margin: 4px 2px; padding: 6px 14px; border: none; border-radius: 6px;
    background: #1a3a5c; color: #8ab4f8; font-size: 12px; cursor: pointer; transition: background 0.2s;
}
.btn:hover { background: #244a6c; }
.btn.active { background: #2e6b3e; color: #8f8; }
.btn-row { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 4px; }

.district-btn {
    width: 28px; height: 28px; border: 2px solid rgba(255,255,255,0.2);
    border-radius: 6px; cursor: pointer; font-size: 11px; font-weight: bold;
    color: #fff; transition: all 0.2s;
}
.district-btn.active { border-color: #fff; transform: scale(1.1); }

.stats {
    position: fixed; bottom: 16px; left: 16px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px;
    border: 1px solid rgba(255,255,255,0.08); font-size: 13px; min-width: 260px;
}
.stats .stat-row { display: flex; justify-content: space-between; gap: 20px; margin: 3px 0; }
.stats .stat-label { color: #888; }
.stats .stat-value { color: #8ab4f8; font-family: 'Courier New', monospace; }

.info-panel {
    position: fixed; bottom: 16px; right: 16px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px; max-width: 310px;
    border: 1px solid rgba(255,255,255,0.08); font-size: 12px; line-height: 1.6;
}
.info-panel h4 { color: #8ab4f8; margin-bottom: 6px; }
.info-panel p { color: #aaa; }
</style>
</head>
<body>
<a href="index.html" class="back-link">&#8592; Back to Gallery</a>
<canvas id="canvas"></canvas>

<div class="controls">
    <h3>Gerrymandering Lab</h3>
    <label>Paint District:</label>
    <div class="btn-row" id="districtBtns"></div>
    <label>Grid Size: <span id="gridVal">10</span></label>
    <input type="range" id="gridSize" min="6" max="16" value="10">
    <label>Blue Voters: <span id="blueVal">50</span>%</label>
    <input type="range" id="bluePct" min="30" max="70" value="50">
    <label>Preset Layouts</label>
    <select id="preset">
        <option value="random">Random</option>
        <option value="clustered">Clustered (realistic)</option>
        <option value="packed">Packed gerrymander</option>
        <option value="cracked">Cracked gerrymander</option>
        <option value="fair">Fair districts</option>
    </select>
    <div class="btn-row">
        <button class="btn" id="randomizeBtn">Randomize Voters</button>
        <button class="btn" id="resetBtn">Reset</button>
    </div>
</div>

<div class="stats">
    <div class="stat-row"><span class="stat-label">Total Blue</span><span class="stat-value" id="totalBlue">0</span></div>
    <div class="stat-row"><span class="stat-label">Total Red</span><span class="stat-value" id="totalRed">0</span></div>
    <div style="height:1px;background:#333;margin:6px 0"></div>
    <div id="districtResults"></div>
    <div style="height:1px;background:#333;margin:6px 0"></div>
    <div class="stat-row"><span class="stat-label">Blue Seats</span><span class="stat-value" id="blueSeats" style="color:#4488ff">0</span></div>
    <div class="stat-row"><span class="stat-label">Red Seats</span><span class="stat-value" id="redSeats" style="color:#ff4444">0</span></div>
    <div class="stat-row"><span class="stat-label">Efficiency Gap</span><span class="stat-value" id="effGap">0%</span></div>
</div>

<div class="info-panel">
    <h4>Gerrymandering</h4>
    <p>Click cells to assign them to districts. Try to win 4+ seats with only 50% of voters! Packing wastes opponent votes in one district. Cracking splits their voters across many districts.</p>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

const NUM_DISTRICTS = 5;
const districtColors = [
    '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231'
];

let gridSize = 10;
let grid = []; // grid[r][c] = { party: 'blue'|'red', district: 0-4 or -1 }
let currentDistrict = 0;
let painting = false;

function createDistrictButtons() {
    const container = document.getElementById('districtBtns');
    container.innerHTML = '';
    for (let i = 0; i < NUM_DISTRICTS; i++) {
        const btn = document.createElement('button');
        btn.className = 'district-btn' + (i === currentDistrict ? ' active' : '');
        btn.style.background = districtColors[i];
        btn.textContent = (i + 1);
        btn.addEventListener('click', () => {
            currentDistrict = i;
            document.querySelectorAll('.district-btn').forEach((b, j) => b.classList.toggle('active', j === i));
        });
        container.appendChild(btn);
    }
}
createDistrictButtons();

function initGrid() {
    gridSize = parseInt(document.getElementById('gridSize').value);
    const bluePct = parseInt(document.getElementById('bluePct').value) / 100;
    grid = [];
    for (let r = 0; r < gridSize; r++) {
        grid[r] = [];
        for (let c = 0; c < gridSize; c++) {
            grid[r][c] = {
                party: Math.random() < bluePct ? 'blue' : 'red',
                district: -1
            };
        }
    }
}

function applyPreset(type) {
    gridSize = parseInt(document.getElementById('gridSize').value);
    const bluePct = parseInt(document.getElementById('bluePct').value) / 100;

    if (type === 'random') {
        initGrid();
        return;
    }

    if (type === 'clustered') {
        // Blue in top-left quadrant, red in bottom-right
        for (let r = 0; r < gridSize; r++) {
            for (let c = 0; c < gridSize; c++) {
                const distToTopLeft = (r + c) / (2 * gridSize);
                const prob = bluePct + (0.5 - distToTopLeft) * 0.5;
                grid[r][c] = { party: Math.random() < prob ? 'blue' : 'red', district: -1 };
            }
        }
        return;
    }

    // For packed/cracked/fair, create grid then assign districts
    initGrid();
    const cellsPerDistrict = Math.floor((gridSize * gridSize) / NUM_DISTRICTS);

    if (type === 'packed') {
        // Pack blue voters into 1 district, spread rest
        let idx = 0;
        for (let r = 0; r < gridSize; r++) {
            for (let c = 0; c < gridSize; c++) {
                const d = Math.min(NUM_DISTRICTS - 1, Math.floor(idx / cellsPerDistrict));
                grid[r][c].district = d;
                idx++;
            }
        }
    } else if (type === 'cracked') {
        // Vertical stripes
        for (let r = 0; r < gridSize; r++) {
            for (let c = 0; c < gridSize; c++) {
                grid[r][c].district = Math.min(NUM_DISTRICTS - 1, Math.floor(c / (gridSize / NUM_DISTRICTS)));
            }
        }
    } else if (type === 'fair') {
        // Horizontal stripes
        for (let r = 0; r < gridSize; r++) {
            for (let c = 0; c < gridSize; c++) {
                grid[r][c].district = Math.min(NUM_DISTRICTS - 1, Math.floor(r / (gridSize / NUM_DISTRICTS)));
            }
        }
    }
}

initGrid();

function getGridLayout() {
    const size = Math.min(W * 0.55, H * 0.8);
    const cellSize = size / gridSize;
    const ox = (W - size) / 2 - 40;
    const oy = (H - size) / 2;
    return { size, cellSize, ox, oy };
}

function getCellFromMouse(mx, my) {
    const { cellSize, ox, oy } = getGridLayout();
    const c = Math.floor((mx - ox) / cellSize);
    const r = Math.floor((my - oy) / cellSize);
    if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) return { r, c };
    return null;
}

canvas.addEventListener('mousedown', function(e) {
    painting = true;
    const cell = getCellFromMouse(e.clientX, e.clientY);
    if (cell) grid[cell.r][cell.c].district = currentDistrict;
});
canvas.addEventListener('mousemove', function(e) {
    if (painting) {
        const cell = getCellFromMouse(e.clientX, e.clientY);
        if (cell) grid[cell.r][cell.c].district = currentDistrict;
    }
});
canvas.addEventListener('mouseup', function() { painting = false; });

canvas.addEventListener('touchstart', function(e) {
    painting = true;
    const t = e.touches[0];
    const cell = getCellFromMouse(t.clientX, t.clientY);
    if (cell) { grid[cell.r][cell.c].district = currentDistrict; e.preventDefault(); }
}, { passive: false });
canvas.addEventListener('touchmove', function(e) {
    if (painting) {
        const t = e.touches[0];
        const cell = getCellFromMouse(t.clientX, t.clientY);
        if (cell) { grid[cell.r][cell.c].district = currentDistrict; e.preventDefault(); }
    }
}, { passive: false });
canvas.addEventListener('touchend', function() { painting = false; });

document.getElementById('gridSize').addEventListener('input', function() {
    document.getElementById('gridVal').textContent = this.value;
    initGrid();
});
document.getElementById('bluePct').addEventListener('input', function() {
    document.getElementById('blueVal').textContent = this.value;
    initGrid();
});
document.getElementById('preset').addEventListener('change', function() {
    applyPreset(this.value);
});
document.getElementById('randomizeBtn').addEventListener('click', () => initGrid());
document.getElementById('resetBtn').addEventListener('click', () => window.reset());

function computeResults() {
    let totalBlue = 0, totalRed = 0;
    const districtBlue = new Array(NUM_DISTRICTS).fill(0);
    const districtRed = new Array(NUM_DISTRICTS).fill(0);
    const districtTotal = new Array(NUM_DISTRICTS).fill(0);

    for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
            const cell = grid[r][c];
            if (cell.party === 'blue') totalBlue++;
            else totalRed++;
            if (cell.district >= 0) {
                districtTotal[cell.district]++;
                if (cell.party === 'blue') districtBlue[cell.district]++;
                else districtRed[cell.district]++;
            }
        }
    }

    let blueSeats = 0, redSeats = 0;
    let blueWasted = 0, redWasted = 0;
    const results = [];

    for (let i = 0; i < NUM_DISTRICTS; i++) {
        const winner = districtBlue[i] > districtRed[i] ? 'blue' : districtRed[i] > districtBlue[i] ? 'red' : 'tie';
        if (winner === 'blue') {
            blueSeats++;
            blueWasted += districtBlue[i] - Math.floor(districtTotal[i] / 2 + 1);
            redWasted += districtRed[i];
        } else if (winner === 'red') {
            redSeats++;
            redWasted += districtRed[i] - Math.floor(districtTotal[i] / 2 + 1);
            blueWasted += districtBlue[i];
        }
        results.push({ blue: districtBlue[i], red: districtRed[i], total: districtTotal[i], winner });
    }

    const totalVotes = totalBlue + totalRed;
    const effGap = totalVotes > 0 ? ((blueWasted - redWasted) / totalVotes * 100) : 0;

    return { totalBlue, totalRed, blueSeats, redSeats, effGap, results };
}

function updateStats() {
    const r = computeResults();
    document.getElementById('totalBlue').textContent = r.totalBlue;
    document.getElementById('totalRed').textContent = r.totalRed;
    document.getElementById('blueSeats').textContent = r.blueSeats;
    document.getElementById('redSeats').textContent = r.redSeats;
    document.getElementById('effGap').textContent = r.effGap.toFixed(1) + '%';

    const container = document.getElementById('districtResults');
    container.innerHTML = '';
    r.results.forEach((d, i) => {
        const row = document.createElement('div');
        row.className = 'stat-row';
        const winColor = d.winner === 'blue' ? '#4488ff' : d.winner === 'red' ? '#ff4444' : '#888';
        row.innerHTML = `<span class="stat-label" style="color:${districtColors[i]}">Dist ${i+1}</span>
            <span class="stat-value" style="color:${winColor}">B:${d.blue} R:${d.red} ${d.total > 0 ? (d.winner === 'tie' ? 'TIE' : d.winner.toUpperCase()) : '-'}</span>`;
        container.appendChild(row);
    });
}

function draw() {
    ctx.clearRect(0, 0, W, H);
    const { cellSize, ox, oy } = getGridLayout();

    // Title
    ctx.fillStyle = '#8ab4f8';
    ctx.font = 'bold 20px Segoe UI, system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Gerrymandering Lab', W / 2 - 40, 30);
    ctx.fillStyle = '#666';
    ctx.font = '13px Segoe UI, system-ui';
    ctx.fillText('Click cells to assign districts. Try to win 4 seats with 50% voters!', W / 2 - 40, 52);

    for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
            const cell = grid[r][c];
            const x = ox + c * cellSize;
            const y = oy + r * cellSize;

            // District background
            if (cell.district >= 0) {
                ctx.fillStyle = districtColors[cell.district] + '30';
                ctx.fillRect(x, y, cellSize, cellSize);
            }

            // Voter dot
            const dotR = cellSize * 0.3;
            ctx.beginPath();
            ctx.arc(x + cellSize / 2, y + cellSize / 2, dotR, 0, Math.PI * 2);
            ctx.fillStyle = cell.party === 'blue' ? '#4488ff' : '#ff4444';
            ctx.fill();

            // Cell border
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, cellSize, cellSize);
        }
    }

    // Draw thick district borders
    ctx.lineWidth = 3;
    for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
            const cell = grid[r][c];
            if (cell.district < 0) continue;
            const x = ox + c * cellSize;
            const y = oy + r * cellSize;
            ctx.strokeStyle = districtColors[cell.district];

            // Right border
            if (c === gridSize - 1 || grid[r][c + 1].district !== cell.district) {
                ctx.beginPath();
                ctx.moveTo(x + cellSize, y);
                ctx.lineTo(x + cellSize, y + cellSize);
                ctx.stroke();
            }
            // Bottom border
            if (r === gridSize - 1 || grid[r + 1][c].district !== cell.district) {
                ctx.beginPath();
                ctx.moveTo(x, y + cellSize);
                ctx.lineTo(x + cellSize, y + cellSize);
                ctx.stroke();
            }
            // Left border
            if (c === 0 || grid[r][c - 1].district !== cell.district) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y + cellSize);
                ctx.stroke();
            }
            // Top border
            if (r === 0 || grid[r - 1][c].district !== cell.district) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + cellSize, y);
                ctx.stroke();
            }
        }
    }

    // Seat visualization
    const seatY = oy + gridSize * cellSize + 30;
    const seatR = 10;
    const seatSpacing = 28;
    const seatStartX = ox + (gridSize * cellSize - NUM_DISTRICTS * seatSpacing) / 2;
    const results = computeResults();

    ctx.fillStyle = '#666';
    ctx.font = '12px Segoe UI, system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('SEATS WON', ox + (gridSize * cellSize) / 2, seatY - 8);

    results.results.forEach((d, i) => {
        const sx = seatStartX + i * seatSpacing + seatSpacing / 2;
        ctx.beginPath();
        ctx.arc(sx, seatY + 16, seatR, 0, Math.PI * 2);
        if (d.total === 0) {
            ctx.fillStyle = '#333';
        } else {
            ctx.fillStyle = d.winner === 'blue' ? '#4488ff' : d.winner === 'red' ? '#ff4444' : '#666';
        }
        ctx.fill();
        ctx.strokeStyle = districtColors[i];
        ctx.lineWidth = 2;
        ctx.stroke();
    });

    updateStats();
    requestAnimationFrame(draw);
}

window.reset = function() {
    currentDistrict = 0;
    document.getElementById('gridSize').value = 10;
    document.getElementById('gridVal').textContent = '10';
    document.getElementById('bluePct').value = 50;
    document.getElementById('blueVal').textContent = '50';
    document.getElementById('preset').value = 'random';
    createDistrictButtons();
    initGrid();
};

draw();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
