<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Spoiler Effect</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        a.back-link {
            position: fixed;
            top: 16px;
            left: 16px;
            color: #7eb8da;
            text-decoration: none;
            z-index: 100;
            font-size: 14px;
            opacity: 0.8;
        }
        a.back-link:hover { opacity: 1; }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #controls {
            position: fixed;
            top: 16px;
            right: 16px;
            background: rgba(20,20,40,0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
            z-index: 50;
            width: 290px;
        }
        #controls h2 {
            font-size: 16px;
            margin-bottom: 6px;
            color: #7eb8da;
        }
        #controls p.sub {
            font-size: 11px;
            color: #666;
            margin-bottom: 14px;
        }
        #controls h3 {
            font-size: 12px;
            color: #888;
            margin: 14px 0 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }
        .slider-row label {
            font-size: 12px;
            min-width: 110px;
            color: #ccc;
        }
        .slider-row input[type="range"] {
            flex: 1;
            accent-color: #7eb8da;
        }
        .slider-row .val {
            font-size: 12px;
            min-width: 28px;
            text-align: right;
            color: #fff;
            font-weight: bold;
        }
        .scenario-btn {
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin-bottom: 6px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            color: #ccc;
            cursor: pointer;
            font-size: 12px;
            text-align: left;
            transition: all 0.2s;
        }
        .scenario-btn:hover { background: rgba(126,184,218,0.15); }
        .scenario-btn.active {
            background: rgba(126,184,218,0.2);
            border-color: rgba(126,184,218,0.5);
            color: #7eb8da;
        }
        .method-toggle {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }
        .method-toggle button {
            flex: 1;
            padding: 6px 4px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            color: #999;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        .method-toggle button:hover { background: rgba(126,184,218,0.15); }
        .method-toggle button.active {
            background: rgba(126,184,218,0.2);
            border-color: rgba(126,184,218,0.5);
            color: #7eb8da;
        }
        button.reset-btn {
            display: block;
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            background: rgba(126,184,218,0.2);
            color: #7eb8da;
            border: 1px solid rgba(126,184,218,0.3);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
        }
        button.reset-btn:hover { background: rgba(126,184,218,0.35); }
        #info-panel {
            position: fixed;
            bottom: 16px;
            left: 16px;
            background: rgba(20,20,40,0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 16px 20px;
            z-index: 50;
            max-width: 420px;
            font-size: 13px;
            line-height: 1.5;
            color: #bbb;
        }
        #info-panel strong { color: #e0e0e0; }
        #info-panel em { color: #ff6b6b; font-style: normal; font-weight: bold; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Back to Voting Theory</a>
    <canvas id="canvas"></canvas>

    <div id="controls">
        <h2>The Spoiler Effect</h2>
        <p class="sub">Adding a losing candidate changes who wins.</p>

        <h3>Spoiler Position</h3>
        <div class="slider-row">
            <label>Spoiler ideology:</label>
            <input type="range" id="spoiler-pos" min="0" max="100" value="35">
            <span class="val" id="spoiler-pos-val">35</span>
        </div>
        <div class="slider-row">
            <label>Spoiler appeal:</label>
            <input type="range" id="spoiler-appeal" min="5" max="40" value="20">
            <span class="val" id="spoiler-appeal-val">20</span>
        </div>

        <h3>Scenarios</h3>
        <button class="scenario-btn active" data-scenario="generic">Generic: A vs B + Spoiler C</button>
        <button class="scenario-btn" data-scenario="nader">Nader 2000 (Florida)</button>
        <button class="scenario-btn" data-scenario="perot">Perot 1992</button>

        <h3>Voting Method</h3>
        <div class="method-toggle">
            <button class="active" data-method="plurality">Plurality</button>
            <button data-method="rcv">Ranked Choice</button>
            <button data-method="approval">Approval</button>
        </div>

        <button class="reset-btn" id="btn-reset">Reset</button>
    </div>

    <div id="info-panel">
        <strong>The Spoiler Effect:</strong> In plurality voting, a new candidate who cannot win can still change
        which of the frontrunners wins by splitting votes from one side. This is why third-party candidates are
        often called "spoilers." Alternative voting methods like <em>ranked choice</em> reduce (but don't eliminate)
        this problem, and <em>approval voting</em> eliminates it entirely.
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let animT = 0;

        // Political spectrum: 0 = far left, 100 = far right
        let candidateA = { name: 'A', pos: 30, color: '#4ecdc4', votes: 0 };
        let candidateB = { name: 'B', pos: 70, color: '#ff6b6b', votes: 0 };
        let spoiler = { name: 'C', pos: 35, color: '#ffe66d', votes: 0, active: true };

        let spoilerPos = 35;
        let spoilerAppeal = 20;
        let currentMethod = 'plurality';
        let currentScenario = 'generic';
        let showSpoiler = true;
        let spoilerAnimProgress = 1;

        // 100 voters distributed across the spectrum
        const numVoters = 200;
        let voters = [];

        function generateVoters() {
            voters = [];
            // Bimodal distribution (two clusters)
            for (let i = 0; i < numVoters; i++) {
                let pos;
                if (Math.random() < 0.5) {
                    pos = 30 + (Math.random() - 0.5) * 40; // Left cluster
                } else {
                    pos = 70 + (Math.random() - 0.5) * 40; // Right cluster
                }
                pos = Math.max(0, Math.min(100, pos));
                voters.push({ pos, vx: 0, vy: 0 });
            }
        }
        generateVoters();

        const scenarios = {
            generic: { aPos: 30, bPos: 70, spoilerPos: 35, appeal: 20, aName: 'A', bName: 'B', cName: 'C' },
            nader: { aPos: 40, bPos: 60, spoilerPos: 35, appeal: 15, aName: 'Gore', bName: 'Bush', cName: 'Nader' },
            perot: { aPos: 45, bPos: 55, spoilerPos: 50, appeal: 25, aName: 'Clinton', bName: 'Bush Sr.', cName: 'Perot' }
        };

        // Controls
        const spoilerPosSlider = document.getElementById('spoiler-pos');
        const spoilerAppealSlider = document.getElementById('spoiler-appeal');

        spoilerPosSlider.addEventListener('input', () => {
            spoilerPos = parseInt(spoilerPosSlider.value);
            document.getElementById('spoiler-pos-val').textContent = spoilerPos;
            spoiler.pos = spoilerPos;
        });

        spoilerAppealSlider.addEventListener('input', () => {
            spoilerAppeal = parseInt(spoilerAppealSlider.value);
            document.getElementById('spoiler-appeal-val').textContent = spoilerAppeal;
        });

        document.querySelectorAll('.scenario-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.scenario-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentScenario = btn.dataset.scenario;
                applyScenario();
            });
        });

        document.querySelectorAll('.method-toggle button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.method-toggle button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMethod = btn.dataset.method;
            });
        });

        document.getElementById('btn-reset').addEventListener('click', () => {
            window.reset();
        });

        function applyScenario() {
            const sc = scenarios[currentScenario];
            candidateA.pos = sc.aPos;
            candidateA.name = sc.aName;
            candidateB.pos = sc.bPos;
            candidateB.name = sc.bName;
            spoiler.pos = sc.spoilerPos;
            spoiler.name = sc.cName;
            spoilerPos = sc.spoilerPos;
            spoilerAppeal = sc.appeal;
            spoilerPosSlider.value = sc.spoilerPos;
            spoilerAppealSlider.value = sc.appeal;
            document.getElementById('spoiler-pos-val').textContent = sc.spoilerPos;
            document.getElementById('spoiler-appeal-val').textContent = sc.appeal;
            generateVoters();
        }

        function computeVotes(includeC) {
            const results = { A: 0, B: 0, C: 0 };
            const candList = includeC ? [candidateA, candidateB, spoiler] : [candidateA, candidateB];

            if (currentMethod === 'plurality') {
                voters.forEach(v => {
                    let closest = null;
                    let minDist = Infinity;
                    for (const c of candList) {
                        const dist = Math.abs(v.pos - c.pos);
                        // Spoiler has appeal modifier
                        const effective = c === spoiler ? dist * (100 / (spoilerAppeal + 50)) : dist;
                        if (effective < minDist) {
                            minDist = effective;
                            closest = c;
                        }
                    }
                    if (closest === candidateA) results.A++;
                    else if (closest === candidateB) results.B++;
                    else results.C++;
                });
            } else if (currentMethod === 'rcv') {
                // Simulate IRV
                const prefs = voters.map(v => {
                    const dists = candList.map(c => {
                        const d = Math.abs(v.pos - c.pos);
                        return { cand: c, dist: c === spoiler ? d * (100 / (spoilerAppeal + 50)) : d };
                    });
                    dists.sort((a, b) => a.dist - b.dist);
                    return dists.map(d => d.cand);
                });

                let remaining = [...candList];
                while (remaining.length > 1) {
                    const counts = {};
                    remaining.forEach(c => counts[c.name] = 0);
                    prefs.forEach(p => {
                        for (const c of p) {
                            if (remaining.includes(c)) {
                                counts[c.name]++;
                                break;
                            }
                        }
                    });
                    let minC = remaining[0];
                    let minV = counts[minC.name];
                    for (const c of remaining) {
                        if (counts[c.name] < minV) {
                            minV = counts[c.name];
                            minC = c;
                        }
                    }
                    remaining = remaining.filter(c => c !== minC);
                }
                // Final winner gets all, losers get their first-round counts for display
                const finalCounts = {};
                candList.forEach(c => finalCounts[c.name] = 0);
                prefs.forEach(p => {
                    for (const c of p) {
                        if (candList.includes(c)) {
                            finalCounts[c.name]++;
                            break;
                        }
                    }
                });
                results.A = finalCounts[candidateA.name];
                results.B = finalCounts[candidateB.name];
                if (includeC) results.C = finalCounts[spoiler.name];
                // Mark winner
                results.winner = remaining[0] === candidateA ? 'A' : remaining[0] === candidateB ? 'B' : 'C';
                return results;
            } else if (currentMethod === 'approval') {
                // Approval: voters approve of candidates within a threshold
                const threshold = 25;
                voters.forEach(v => {
                    for (const c of candList) {
                        const dist = Math.abs(v.pos - c.pos);
                        const effective = c === spoiler ? dist * (100 / (spoilerAppeal + 50)) : dist;
                        if (effective < threshold) {
                            if (c === candidateA) results.A++;
                            else if (c === candidateB) results.B++;
                            else results.C++;
                        }
                    }
                });
            }

            // Determine winner
            const entries = includeC ? [['A', results.A], ['B', results.B], ['C', results.C]] : [['A', results.A], ['B', results.B]];
            results.winner = entries.reduce((a, b) => a[1] >= b[1] ? a : b)[0];
            return results;
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        function drawSpectrum(x, y, w, h, label) {
            // Gradient bar
            const grad = ctx.createLinearGradient(x, y, x + w, y);
            grad.addColorStop(0, '#4ecdc4');
            grad.addColorStop(0.5, '#888');
            grad.addColorStop(1, '#ff6b6b');
            ctx.fillStyle = grad;
            ctx.fillRect(x, y, w, h);

            ctx.fillStyle = '#666';
            ctx.font = '11px Segoe UI, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(label, x + w / 2, y - 8);
            ctx.textAlign = 'left';
            ctx.fillText('Left', x, y + h + 14);
            ctx.textAlign = 'right';
            ctx.fillText('Right', x + w, y + h + 14);
        }

        function drawCandidateMarker(x, y, name, color, isWinner, label) {
            ctx.save();
            if (isWinner) {
                ctx.shadowColor = '#50c878';
                ctx.shadowBlur = 15;
            }
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - 8, y - 14);
            ctx.lineTo(x + 8, y - 14);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            ctx.fillStyle = color;
            ctx.font = 'bold 13px Segoe UI, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(label || name, x, y - 20);

            if (isWinner) {
                ctx.fillStyle = '#50c878';
                ctx.font = 'bold 11px Segoe UI, sans-serif';
                ctx.fillText('WINNER', x, y - 34);
            }
        }

        function animate() {
            animT += 0.016;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background grid
            ctx.strokeStyle = 'rgba(126,184,218,0.03)';
            ctx.lineWidth = 1;
            for (let gx = 0; gx < canvas.width; gx += 40) {
                ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, canvas.height); ctx.stroke();
            }
            for (let gy = 0; gy < canvas.height; gy += 40) {
                ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(canvas.width, gy); ctx.stroke();
            }

            // Title
            ctx.fillStyle = 'rgba(255,255,255,0.07)';
            ctx.font = 'bold 36px Segoe UI, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('THE SPOILER EFFECT', canvas.width / 2 - 80, 50);

            const specX = 60;
            const specW = canvas.width - 450;
            const midX = specX + specW / 2;

            // === WITHOUT spoiler ===
            const noSpoilerY = 120;
            ctx.fillStyle = '#7eb8da';
            ctx.font = 'bold 14px Segoe UI, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('WITHOUT Spoiler Candidate', specX, noSpoilerY - 20);

            drawSpectrum(specX, noSpoilerY, specW, 8, 'Political Spectrum');

            const resultNoC = computeVotes(false);
            drawCandidateMarker(specX + (candidateA.pos / 100) * specW, noSpoilerY, 'A', candidateA.color, resultNoC.winner === 'A', candidateA.name);
            drawCandidateMarker(specX + (candidateB.pos / 100) * specW, noSpoilerY, 'B', candidateB.color, resultNoC.winner === 'B', candidateB.name);

            // Vote bars (no spoiler)
            const barY1 = noSpoilerY + 40;
            const barMaxW = specW * 0.6;
            ctx.fillStyle = candidateA.color + '44';
            ctx.fillRect(specX, barY1, (resultNoC.A / numVoters) * barMaxW, 22);
            ctx.strokeStyle = candidateA.color;
            ctx.lineWidth = 1;
            ctx.strokeRect(specX, barY1, (resultNoC.A / numVoters) * barMaxW, 22);
            ctx.fillStyle = candidateA.color;
            ctx.font = '13px Segoe UI, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(candidateA.name + ': ' + resultNoC.A + ' (' + Math.round(resultNoC.A / numVoters * 100) + '%)', specX + 6, barY1 + 16);

            ctx.fillStyle = candidateB.color + '44';
            ctx.fillRect(specX, barY1 + 28, (resultNoC.B / numVoters) * barMaxW, 22);
            ctx.strokeStyle = candidateB.color;
            ctx.strokeRect(specX, barY1 + 28, (resultNoC.B / numVoters) * barMaxW, 22);
            ctx.fillStyle = candidateB.color;
            ctx.fillText(candidateB.name + ': ' + resultNoC.B + ' (' + Math.round(resultNoC.B / numVoters * 100) + '%)', specX + 6, barY1 + 44);

            // === WITH spoiler ===
            const withSpoilerY = barY1 + 100;
            ctx.fillStyle = '#ffa050';
            ctx.font = 'bold 14px Segoe UI, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('WITH Spoiler Candidate', specX, withSpoilerY - 20);

            drawSpectrum(specX, withSpoilerY, specW, 8, '');

            const resultWithC = computeVotes(true);
            drawCandidateMarker(specX + (candidateA.pos / 100) * specW, withSpoilerY, 'A', candidateA.color, resultWithC.winner === 'A', candidateA.name);
            drawCandidateMarker(specX + (candidateB.pos / 100) * specW, withSpoilerY, 'B', candidateB.color, resultWithC.winner === 'B', candidateB.name);

            // Spoiler with pulsing
            const sp = spoiler;
            const spX = specX + (sp.pos / 100) * specW;
            ctx.save();
            ctx.shadowColor = sp.color;
            ctx.shadowBlur = 10 + Math.sin(animT * 3) * 5;
            drawCandidateMarker(spX, withSpoilerY, 'C', sp.color, resultWithC.winner === 'C', sp.name);
            ctx.restore();

            // Spoiler zone visualization
            const appealRadius = (spoilerAppeal / 100) * specW;
            ctx.fillStyle = 'rgba(255,230,100,0.06)';
            ctx.fillRect(spX - appealRadius, withSpoilerY - 50, appealRadius * 2, 70);
            ctx.strokeStyle = 'rgba(255,230,100,0.2)';
            ctx.setLineDash([4, 4]);
            ctx.strokeRect(spX - appealRadius, withSpoilerY - 50, appealRadius * 2, 70);
            ctx.setLineDash([]);

            ctx.fillStyle = 'rgba(255,230,100,0.4)';
            ctx.font = '10px Segoe UI, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Spoiler Zone', spX, withSpoilerY + 18);

            // Vote bars (with spoiler)
            const barY2 = withSpoilerY + 36;
            ctx.fillStyle = candidateA.color + '44';
            ctx.fillRect(specX, barY2, (resultWithC.A / numVoters) * barMaxW, 22);
            ctx.strokeStyle = candidateA.color;
            ctx.lineWidth = 1;
            ctx.strokeRect(specX, barY2, (resultWithC.A / numVoters) * barMaxW, 22);
            ctx.fillStyle = candidateA.color;
            ctx.font = '13px Segoe UI, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(candidateA.name + ': ' + resultWithC.A + ' (' + Math.round(resultWithC.A / numVoters * 100) + '%)', specX + 6, barY2 + 16);

            ctx.fillStyle = candidateB.color + '44';
            ctx.fillRect(specX, barY2 + 28, (resultWithC.B / numVoters) * barMaxW, 22);
            ctx.strokeStyle = candidateB.color;
            ctx.strokeRect(specX, barY2 + 28, (resultWithC.B / numVoters) * barMaxW, 22);
            ctx.fillStyle = candidateB.color;
            ctx.fillText(candidateB.name + ': ' + resultWithC.B + ' (' + Math.round(resultWithC.B / numVoters * 100) + '%)', specX + 6, barY2 + 44);

            ctx.fillStyle = spoiler.color + '44';
            ctx.fillRect(specX, barY2 + 56, (resultWithC.C / numVoters) * barMaxW, 22);
            ctx.strokeStyle = spoiler.color;
            ctx.strokeRect(specX, barY2 + 56, (resultWithC.C / numVoters) * barMaxW, 22);
            ctx.fillStyle = spoiler.color;
            ctx.fillText(sp.name + ': ' + resultWithC.C + ' (' + Math.round(resultWithC.C / numVoters * 100) + '%)', specX + 6, barY2 + 72);

            // Spoiler effect verdict
            const verdictY = barY2 + 100;
            const winnerChanged = resultNoC.winner !== resultWithC.winner;

            if (winnerChanged) {
                const pulse = 0.6 + Math.sin(animT * 3) * 0.4;
                ctx.save();
                ctx.fillStyle = `rgba(255,80,80,${0.08 * pulse})`;
                ctx.strokeStyle = `rgba(255,80,80,${0.4 * pulse})`;
                ctx.lineWidth = 2;
                const vw = specW * 0.7;
                const vx = specX + (specW - vw) / 2;
                ctx.fillRect(vx, verdictY, vw, 50);
                ctx.strokeRect(vx, verdictY, vw, 50);
                ctx.restore();

                ctx.fillStyle = '#ff6b6b';
                ctx.font = 'bold 16px Segoe UI, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('SPOILER EFFECT!', specX + specW / 2, verdictY + 22);
                ctx.font = '13px Segoe UI, sans-serif';
                ctx.fillStyle = '#ccc';
                const oldWName = resultNoC.winner === 'A' ? candidateA.name : candidateB.name;
                const newWName = resultWithC.winner === 'A' ? candidateA.name : resultWithC.winner === 'B' ? candidateB.name : sp.name;
                ctx.fillText(oldWName + ' would have won, but ' + sp.name + ' split the vote. ' + newWName + ' wins instead.', specX + specW / 2, verdictY + 42);
            } else {
                ctx.fillStyle = 'rgba(80,200,120,0.08)';
                ctx.strokeStyle = 'rgba(80,200,120,0.3)';
                ctx.lineWidth = 1;
                const vw = specW * 0.5;
                const vx = specX + (specW - vw) / 2;
                ctx.fillRect(vx, verdictY, vw, 40);
                ctx.strokeRect(vx, verdictY, vw, 40);

                ctx.fillStyle = '#50c878';
                ctx.font = 'bold 14px Segoe UI, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No spoiler effect -- same winner', specX + specW / 2, verdictY + 24);
            }

            // Voter dots visualization
            const dotsY = verdictY + 80;
            const dotsH = canvas.height - dotsY - 100;
            if (dotsH > 40) {
                ctx.fillStyle = '#555';
                ctx.font = '11px Segoe UI, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('Voters on ideological spectrum:', specX, dotsY);

                voters.forEach(v => {
                    const vx = specX + (v.pos / 100) * specW;
                    const vy = dotsY + 15 + Math.random() * Math.min(dotsH - 20, 60);

                    // Color by who they vote for with spoiler
                    let closest = null;
                    let minDist = Infinity;
                    const candList = [candidateA, candidateB, spoiler];
                    for (const c of candList) {
                        const dist = Math.abs(v.pos - c.pos);
                        const effective = c === spoiler ? dist * (100 / (spoilerAppeal + 50)) : dist;
                        if (effective < minDist) {
                            minDist = effective;
                            closest = c;
                        }
                    }

                    ctx.fillStyle = closest.color + '88';
                    ctx.beginPath();
                    ctx.arc(vx, vy, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            // Method comparison (bottom-right)
            const compX = canvas.width - 340;
            const compY = canvas.height - 200;
            if (compY > 200) {
                ctx.fillStyle = 'rgba(255,255,255,0.04)';
                ctx.fillRect(compX, compY, 240, 140);
                ctx.strokeStyle = 'rgba(255,255,255,0.08)';
                ctx.strokeRect(compX, compY, 240, 140);

                ctx.fillStyle = '#7eb8da';
                ctx.font = 'bold 12px Segoe UI, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('Spoiler Vulnerability by Method', compX + 10, compY + 20);

                const methodNames = ['Plurality', 'Ranked Choice', 'Approval'];
                const vulns = ['HIGH', 'LOW', 'NONE'];
                const vulnColors = ['#ff6b6b', '#ffa050', '#50c878'];

                methodNames.forEach((m, i) => {
                    const my = compY + 40 + i * 30;
                    const isActive = (i === 0 && currentMethod === 'plurality') || (i === 1 && currentMethod === 'rcv') || (i === 2 && currentMethod === 'approval');
                    ctx.fillStyle = isActive ? '#fff' : '#888';
                    ctx.font = (isActive ? 'bold ' : '') + '12px Segoe UI, sans-serif';
                    ctx.fillText(m, compX + 14, my + 5);
                    ctx.fillStyle = vulnColors[i];
                    ctx.font = 'bold 12px Segoe UI, sans-serif';
                    ctx.textAlign = 'right';
                    ctx.fillText(vulns[i], compX + 230, my + 5);
                    ctx.textAlign = 'left';

                    // Bar
                    const barW = [180, 80, 0][i];
                    ctx.fillStyle = vulnColors[i] + '33';
                    ctx.fillRect(compX + 14, my + 10, barW, 4);
                });
            }

            requestAnimationFrame(animate);
        }

        window.reset = function() {
            currentScenario = 'generic';
            currentMethod = 'plurality';
            document.querySelectorAll('.scenario-btn').forEach(b => b.classList.remove('active'));
            document.querySelector('[data-scenario="generic"]').classList.add('active');
            document.querySelectorAll('.method-toggle button').forEach(b => b.classList.remove('active'));
            document.querySelector('[data-method="plurality"]').classList.add('active');
            applyScenario();
        };

        animate();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
