<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arrow's Impossibility Theorem</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        a.back-link {
            position: fixed;
            top: 16px;
            left: 16px;
            color: #7eb8da;
            text-decoration: none;
            z-index: 100;
            font-size: 14px;
            opacity: 0.8;
            transition: opacity 0.3s;
        }
        a.back-link:hover { opacity: 1; }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #controls {
            position: fixed;
            top: 16px;
            right: 16px;
            background: rgba(20,20,40,0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
            z-index: 50;
            width: 280px;
        }
        #controls h2 {
            font-size: 16px;
            margin-bottom: 12px;
            color: #7eb8da;
        }
        #controls h3 {
            font-size: 12px;
            color: #888;
            margin: 14px 0 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .criterion-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .criterion-toggle:hover { background: rgba(255,255,255,0.05); }
        .criterion-toggle input {
            accent-color: #7eb8da;
            width: 16px;
            height: 16px;
        }
        .criterion-toggle label {
            font-size: 13px;
            cursor: pointer;
            flex: 1;
        }
        .criterion-toggle .status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }
        .status-on { background: rgba(80,200,120,0.2); color: #50c878; }
        .status-off { background: rgba(255,80,80,0.2); color: #ff6b6b; }
        #info-panel {
            position: fixed;
            bottom: 16px;
            left: 16px;
            background: rgba(20,20,40,0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 16px 20px;
            z-index: 50;
            max-width: 420px;
            font-size: 13px;
            line-height: 1.5;
            color: #bbb;
        }
        #info-panel strong { color: #e0e0e0; }
        #info-panel em { color: #ff6b6b; font-style: normal; font-weight: bold; }
        #result-msg {
            margin-top: 14px;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.5;
        }
        button {
            background: rgba(126,184,218,0.2);
            color: #7eb8da;
            border: 1px solid rgba(126,184,218,0.3);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            margin-top: 10px;
            transition: background 0.2s;
            width: 100%;
        }
        button:hover { background: rgba(126,184,218,0.35); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Back to Voting Theory</a>
    <canvas id="canvas"></canvas>

    <div id="controls">
        <h2>Arrow's Theorem</h2>
        <h3>Fairness Criteria</h3>
        <p style="font-size:11px;color:#666;margin-bottom:10px;">Toggle criteria to see which methods satisfy them. Try to find a method that satisfies all five!</p>
        <div id="criteria-list"></div>
        <button id="btn-all">Require All 5 Criteria</button>
        <button id="btn-reset">Reset</button>
    </div>

    <div id="info-panel">
        <strong>Arrow's Impossibility Theorem (1951)</strong> proves that no ranked voting system with 3+ candidates
        can simultaneously satisfy all five fairness criteria. The only system satisfying criteria 1, 3, 4, and 5
        is a <em>dictatorship</em> -- where one voter's preference always determines the outcome. Democracy is,
        mathematically, impossible to make perfectly fair.
        <div id="result-msg"></div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let animT = 0;

        const criteria = [
            { id: 'UD', name: 'Unrestricted Domain', short: 'UD', desc: 'Any possible preference ordering is allowed', active: false, color: '#ff6b6b' },
            { id: 'ND', name: 'Non-Dictatorship', short: 'ND', desc: 'No single voter always decides the outcome', active: false, color: '#4ecdc4' },
            { id: 'PE', name: 'Pareto Efficiency', short: 'PE', desc: 'If everyone prefers A to B, society must too', active: false, color: '#ffe66d' },
            { id: 'IIA', name: 'Independence of Irrelevant Alternatives', short: 'IIA', desc: 'Ranking of A vs B depends only on A vs B preferences', active: false, color: '#c084fc' },
            { id: 'TR', name: 'Transitivity', short: 'TR', desc: 'If society prefers A>B and B>C then A>C', active: false, color: '#f97316' }
        ];

        const methods = [
            { name: 'Plurality', satisfies: ['UD', 'ND', 'PE', 'TR'] },
            { name: 'Borda Count', satisfies: ['UD', 'ND', 'PE', 'TR'] },
            { name: 'Ranked Choice (IRV)', satisfies: ['UD', 'ND', 'PE'] },
            { name: 'Copeland', satisfies: ['UD', 'ND', 'PE', 'IIA'] },
            { name: 'Pairwise Majority', satisfies: ['UD', 'ND', 'PE', 'IIA'] },
            { name: 'Approval Voting', satisfies: ['ND', 'PE', 'TR'] },
            { name: 'Dictatorship', satisfies: ['UD', 'PE', 'IIA', 'TR'] },
            { name: 'Random Ballot', satisfies: ['UD', 'ND', 'PE', 'IIA'] },
            { name: 'Kemeny-Young', satisfies: ['UD', 'ND', 'PE', 'TR'] }
        ];

        // Build criteria toggles
        const criteriaList = document.getElementById('criteria-list');
        criteria.forEach((c, i) => {
            const div = document.createElement('div');
            div.className = 'criterion-toggle';
            div.innerHTML = `
                <input type="checkbox" id="cr${i}" ${c.active ? 'checked' : ''}>
                <label for="cr${i}">${c.name}</label>
                <span class="status ${c.active ? 'status-on' : 'status-off'}">${c.active ? 'ON' : 'OFF'}</span>
            `;
            div.querySelector('input').addEventListener('change', (e) => {
                c.active = e.target.checked;
                div.querySelector('.status').className = 'status ' + (c.active ? 'status-on' : 'status-off');
                div.querySelector('.status').textContent = c.active ? 'ON' : 'OFF';
                updateResult();
            });
            div.addEventListener('click', (e) => {
                if (e.target.tagName !== 'INPUT') {
                    const cb = div.querySelector('input');
                    cb.checked = !cb.checked;
                    cb.dispatchEvent(new Event('change'));
                }
            });
            criteriaList.appendChild(div);
        });

        document.getElementById('btn-all').addEventListener('click', () => {
            criteria.forEach((c, i) => {
                c.active = true;
                const div = criteriaList.children[i];
                div.querySelector('input').checked = true;
                div.querySelector('.status').className = 'status status-on';
                div.querySelector('.status').textContent = 'ON';
            });
            updateResult();
        });

        document.getElementById('btn-reset').addEventListener('click', () => {
            window.reset();
        });

        function getMatchingMethods() {
            const required = criteria.filter(c => c.active).map(c => c.id);
            return methods.filter(m => required.every(r => m.satisfies.includes(r)));
        }

        function updateResult() {
            const active = criteria.filter(c => c.active);
            const matching = getMatchingMethods();
            const resultMsg = document.getElementById('result-msg');

            if (active.length === 0) {
                resultMsg.style.background = 'rgba(126,184,218,0.1)';
                resultMsg.style.border = '1px solid rgba(126,184,218,0.3)';
                resultMsg.style.color = '#7eb8da';
                resultMsg.textContent = 'Toggle criteria above to filter voting methods.';
            } else if (active.length === 5) {
                resultMsg.style.background = 'rgba(255,80,80,0.15)';
                resultMsg.style.border = '1px solid rgba(255,80,80,0.4)';
                resultMsg.style.color = '#ff6b6b';
                resultMsg.innerHTML = 'NO METHOD satisfies all 5 criteria! This is Arrow\'s Impossibility Theorem. The closest is Dictatorship, which satisfies all except Non-Dictatorship.';
            } else if (matching.length === 0) {
                resultMsg.style.background = 'rgba(255,160,80,0.15)';
                resultMsg.style.border = '1px solid rgba(255,160,80,0.4)';
                resultMsg.style.color = '#ffa050';
                resultMsg.textContent = 'No known voting method satisfies this combination.';
            } else {
                resultMsg.style.background = 'rgba(80,200,120,0.1)';
                resultMsg.style.border = '1px solid rgba(80,200,120,0.3)';
                resultMsg.style.color = '#50c878';
                resultMsg.textContent = matching.length + ' method(s) found: ' + matching.map(m => m.name).join(', ');
            }
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        function animate() {
            animT += 0.016;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background grid
            ctx.strokeStyle = 'rgba(126,184,218,0.03)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 40) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 40) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }

            const active = criteria.filter(c => c.active).map(c => c.id);
            const matching = getMatchingMethods();

            // Draw methods vs criteria matrix
            const startX = 80;
            const startY = 90;
            const colW = Math.min(120, (canvas.width - 350) / (criteria.length + 1));
            const rowH = 42;
            const nameColW = Math.min(180, canvas.width * 0.18);

            // Title
            ctx.fillStyle = 'rgba(255,255,255,0.07)';
            ctx.font = 'bold 36px Segoe UI, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText("ARROW'S IMPOSSIBILITY THEOREM", canvas.width / 2 - 60, 55);

            // Column headers (criteria)
            ctx.textAlign = 'center';
            for (let i = 0; i < criteria.length; i++) {
                const c = criteria[i];
                const x = startX + nameColW + i * colW + colW / 2;
                const isActive = c.active;

                ctx.fillStyle = isActive ? c.color : 'rgba(255,255,255,0.3)';
                ctx.font = 'bold 13px Segoe UI, sans-serif';
                ctx.fillText(c.short, x, startY);

                ctx.fillStyle = isActive ? c.color + '88' : 'rgba(255,255,255,0.15)';
                ctx.font = '10px Segoe UI, sans-serif';

                // Wrap long names
                const words = c.name.split(' ');
                let line = '';
                let ly = startY + 14;
                for (const w of words) {
                    if ((line + ' ' + w).length > 14 && line.length > 0) {
                        ctx.fillText(line, x, ly);
                        ly += 12;
                        line = w;
                    } else {
                        line = line ? line + ' ' + w : w;
                    }
                }
                if (line) ctx.fillText(line, x, ly);
            }

            // Rows (methods)
            for (let r = 0; r < methods.length; r++) {
                const m = methods[r];
                const y = startY + 50 + r * rowH;
                const isMatch = active.length > 0 && active.every(a => m.satisfies.includes(a));
                const isAll5 = active.length === 5;

                // Row background
                if (isMatch && !isAll5) {
                    ctx.fillStyle = 'rgba(80,200,120,0.06)';
                    ctx.fillRect(startX, y - rowH / 2 + 5, nameColW + criteria.length * colW, rowH - 2);
                }

                // Method name
                ctx.textAlign = 'left';
                ctx.fillStyle = isMatch && !isAll5 ? '#50c878' : '#aaa';
                ctx.font = (isMatch && !isAll5 ? 'bold ' : '') + '14px Segoe UI, sans-serif';
                ctx.fillText(m.name, startX + 10, y + 5);

                // Criteria cells
                for (let i = 0; i < criteria.length; i++) {
                    const c = criteria[i];
                    const x = startX + nameColW + i * colW + colW / 2;
                    const has = m.satisfies.includes(c.id);
                    const isRequired = c.active;

                    if (has) {
                        ctx.fillStyle = isRequired ? '#50c878' : 'rgba(80,200,120,0.3)';
                        ctx.font = 'bold 18px Segoe UI, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText('\u2713', x, y + 6);
                    } else {
                        ctx.fillStyle = isRequired ? '#ff6b6b' : 'rgba(255,80,80,0.2)';
                        ctx.font = 'bold 18px Segoe UI, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText('\u2717', x, y + 6);

                        if (isRequired) {
                            // Highlight missing criterion
                            ctx.save();
                            ctx.strokeStyle = 'rgba(255,80,80,0.3)';
                            ctx.lineWidth = 1;
                            ctx.setLineDash([3, 3]);
                            ctx.strokeRect(x - colW/2 + 5, y - 12, colW - 10, rowH - 8);
                            ctx.setLineDash([]);
                            ctx.restore();
                        }
                    }
                }
            }

            // Grid lines
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 1;
            for (let r = 0; r <= methods.length; r++) {
                const y = startY + 42 + r * rowH;
                ctx.beginPath();
                ctx.moveTo(startX, y);
                ctx.lineTo(startX + nameColW + criteria.length * colW, y);
                ctx.stroke();
            }

            // Pentagon visualization of active criteria
            if (active.length > 0) {
                const pentCx = canvas.width - 180;
                const pentCy = canvas.height - 200;
                const pentR = 80;

                ctx.fillStyle = 'rgba(255,255,255,0.04)';
                ctx.font = '11px Segoe UI, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Criteria Coverage', pentCx, pentCy - pentR - 20);

                // Pentagon outline
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const a = (i / 5) * Math.PI * 2 - Math.PI / 2;
                    const x = pentCx + Math.cos(a) * pentR;
                    const y = pentCy + Math.sin(a) * pentR;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Active fill
                ctx.beginPath();
                let hasPoints = false;
                for (let i = 0; i < 5; i++) {
                    if (criteria[i].active) {
                        const a = (i / 5) * Math.PI * 2 - Math.PI / 2;
                        const x = pentCx + Math.cos(a) * pentR;
                        const y = pentCy + Math.sin(a) * pentR;
                        if (!hasPoints) { ctx.moveTo(x, y); hasPoints = true; }
                        else ctx.lineTo(x, y);
                    }
                }
                if (hasPoints) {
                    ctx.closePath();
                    ctx.fillStyle = active.length === 5 ? 'rgba(255,80,80,0.15)' : 'rgba(126,184,218,0.15)';
                    ctx.fill();
                    ctx.strokeStyle = active.length === 5 ? 'rgba(255,80,80,0.5)' : 'rgba(126,184,218,0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Vertex labels
                for (let i = 0; i < 5; i++) {
                    const c = criteria[i];
                    const a = (i / 5) * Math.PI * 2 - Math.PI / 2;
                    const lx = pentCx + Math.cos(a) * (pentR + 20);
                    const ly = pentCy + Math.sin(a) * (pentR + 20);

                    // Dot
                    ctx.fillStyle = c.active ? c.color : 'rgba(255,255,255,0.2)';
                    ctx.beginPath();
                    ctx.arc(pentCx + Math.cos(a) * pentR, pentCy + Math.sin(a) * pentR, c.active ? 6 : 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Label
                    ctx.fillStyle = c.active ? c.color : 'rgba(255,255,255,0.3)';
                    ctx.font = (c.active ? 'bold ' : '') + '12px Segoe UI, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(c.short, lx, ly);
                }

                // Impossible warning
                if (active.length === 5) {
                    const pulse = 0.6 + Math.sin(animT * 3) * 0.4;
                    ctx.fillStyle = `rgba(255,80,80,${pulse * 0.8})`;
                    ctx.font = 'bold 16px Segoe UI, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('IMPOSSIBLE', pentCx, pentCy + pentR + 45);
                    ctx.fillStyle = `rgba(255,80,80,${pulse * 0.5})`;
                    ctx.font = '11px Segoe UI, sans-serif';
                    ctx.fillText('No method exists', pentCx, pentCy + pentR + 62);
                }
            }

            requestAnimationFrame(animate);
        }

        window.reset = function() {
            criteria.forEach((c, i) => {
                c.active = false;
                const div = criteriaList.children[i];
                div.querySelector('input').checked = false;
                div.querySelector('.status').className = 'status status-off';
                div.querySelector('.status').textContent = 'OFF';
            });
            updateResult();
        };

        updateResult();
        animate();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
