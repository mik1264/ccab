<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Apportionment Paradoxes</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; }
canvas { display: block; }
#controls {
    position: fixed; top: 10px; right: 10px; width: 340px;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 16px; z-index: 10;
    border: 1px solid rgba(100,140,200,0.3);
    max-height: 92vh; overflow-y: auto;
}
#info {
    position: fixed; bottom: 10px; left: 10px; max-width: 380px;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 16px; z-index: 10;
    border: 1px solid rgba(100,140,200,0.3); font-size: 13px; line-height: 1.5;
}
h3 { color: #7eb8f0; margin-bottom: 8px; font-size: 15px; }
label { display: block; margin: 6px 0 3px; font-size: 12px; color: #a0b4d0; }
input[type="range"], input[type="number"] {
    background: rgba(50,60,90,0.5); border: 1px solid rgba(100,140,200,0.3);
    border-radius: 4px; color: #e0e0e0; padding: 4px 8px; font-size: 13px;
}
input[type="range"] { width: 100%; }
input[type="number"] { width: 80px; }
button {
    background: rgba(60,80,140,0.6); color: #c0d4f0; border: 1px solid rgba(100,140,200,0.4);
    border-radius: 6px; padding: 6px 14px; cursor: pointer; font-size: 12px; margin: 3px 2px;
    transition: background 0.2s;
}
button:hover { background: rgba(80,110,180,0.7); }
.state-row { display: flex; align-items: center; gap: 6px; margin: 4px 0; font-size: 12px; }
.state-row span { min-width: 50px; }
.state-row input { width: 70px; }
.paradox-alert { color: #f06070; font-weight: bold; font-size: 12px; margin: 6px 0; padding: 6px; background: rgba(240,96,112,0.1); border-radius: 6px; }
select {
    background: rgba(50,60,90,0.5); border: 1px solid rgba(100,140,200,0.3);
    border-radius: 4px; color: #e0e0e0; padding: 4px 8px; font-size: 13px;
}
a { color: #7eb8f0; text-decoration: none; }
a:hover { text-decoration: underline; }
#backLink { position: fixed; top: 10px; left: 10px; z-index: 20; font-size: 13px; }
.tab { display: inline-block; padding: 4px 10px; cursor: pointer; border-radius: 4px 4px 0 0; font-size: 11px; }
.tab.active { background: rgba(80,110,180,0.5); color: #fff; }
.tab:not(.active) { background: rgba(40,50,70,0.5); color: #8090b0; }
</style>
</head>
<body>
<a id="backLink" href="index.html">&#8592; Back</a>
<canvas id="canvas"></canvas>

<div id="controls">
    <h3>Apportionment</h3>
    <label>Total Seats:</label>
    <input type="number" id="totalSeats" value="10" min="1" max="200">
    <label>Method:</label>
    <select id="method">
        <option value="hamilton">Hamilton (Largest Remainders)</option>
        <option value="jefferson">Jefferson (D'Hondt)</option>
        <option value="adams">Adams</option>
        <option value="webster">Webster</option>
    </select>
    <div id="stateList"></div>
    <div style="margin-top:8px;">
        <button id="addState">+ Add State</button>
        <button id="showAlabama">Show Alabama Paradox</button>
    </div>
    <div id="paradoxMsg"></div>
</div>

<div id="info">
    <h3>Apportionment Paradoxes</h3>
    <p><strong>Alabama Paradox:</strong> Increase total seats and a state LOSES a seat!</p>
    <p style="margin-top:4px;"><strong>Population Paradox:</strong> A faster-growing state loses a seat to a slower-growing one.</p>
    <p style="margin-top:4px;"><strong>New States Paradox:</strong> Adding a new state with its fair share changes existing allocations.</p>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

const stateColors = ['#4e9af0','#f0c040','#50d890','#f06070','#b070f0','#f09040','#40d0d0','#d070a0','#80b040','#c0c0c0','#e07070','#70c0f0'];

let states = [
    { name: 'Alpha', pop: 1500 },
    { name: 'Beta', pop: 3200 },
    { name: 'Gamma', pop: 2800 },
    { name: 'Delta', pop: 1000 },
    { name: 'Epsilon', pop: 1500 }
];
let totalSeats = 10;
let allocations = [];
let animProgress = 0;
let alabamaMode = false;
let alabamaData = null;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function hamilton(states, seats) {
    const totalPop = states.reduce((s, st) => s + st.pop, 0);
    const quotas = states.map(st => (st.pop / totalPop) * seats);
    const lower = quotas.map(q => Math.floor(q));
    let remaining = seats - lower.reduce((a, b) => a + b, 0);
    const remainders = quotas.map((q, i) => ({ i, r: q - lower[i] }));
    remainders.sort((a, b) => b.r - a.r);
    const result = [...lower];
    for (let j = 0; j < remaining; j++) {
        result[remainders[j].i]++;
    }
    return result;
}

function jefferson(states, seats) {
    const result = states.map(() => 0);
    for (let s = 0; s < seats; s++) {
        let bestIdx = 0, bestVal = -1;
        for (let i = 0; i < states.length; i++) {
            const val = states[i].pop / (result[i] + 1);
            if (val > bestVal) { bestVal = val; bestIdx = i; }
        }
        result[bestIdx]++;
    }
    return result;
}

function adams(states, seats) {
    const result = states.map(() => 1);
    let assigned = states.length;
    while (assigned < seats) {
        let bestIdx = 0, bestVal = Infinity;
        for (let i = 0; i < states.length; i++) {
            const val = states[i].pop / result[i];
            if (val < bestVal) { bestVal = val; bestIdx = i; }
        }
        result[bestIdx]++;
        assigned++;
    }
    if (assigned > seats) {
        return states.map((_, i) => Math.max(1, Math.round((states[i].pop / states.reduce((s, st) => s + st.pop, 0)) * seats)));
    }
    return result;
}

function webster(states, seats) {
    const result = states.map(() => 0);
    for (let s = 0; s < seats; s++) {
        let bestIdx = 0, bestVal = -1;
        for (let i = 0; i < states.length; i++) {
            const val = states[i].pop / (2 * result[i] + 1);
            if (val > bestVal) { bestVal = val; bestIdx = i; }
        }
        result[bestIdx]++;
    }
    return result;
}

function apportion(sts, seats, method) {
    if (method === 'hamilton') return hamilton(sts, seats);
    if (method === 'jefferson') return jefferson(sts, seats);
    if (method === 'adams') return adams(sts, seats);
    if (method === 'webster') return webster(sts, seats);
    return hamilton(sts, seats);
}

function recalculate() {
    totalSeats = parseInt(document.getElementById('totalSeats').value) || 1;
    const method = document.getElementById('method').value;
    allocations = apportion(states, totalSeats, method);
    animProgress = 0;
}

function renderStateList() {
    const list = document.getElementById('stateList');
    list.innerHTML = '<label style="margin-top:8px;">States & Populations:</label>';
    states.forEach((st, i) => {
        const row = document.createElement('div');
        row.className = 'state-row';
        row.innerHTML = `
            <span style="color:${stateColors[i % stateColors.length]}">${st.name}</span>
            <input type="number" value="${st.pop}" min="1" onchange="updatePop(${i}, this.value)">
            <span style="color:#8899bb;font-size:11px;">${allocations[i] !== undefined ? allocations[i] + ' seats' : ''}</span>
            <button style="padding:2px 6px;font-size:10px;background:rgba(180,60,60,0.4);" onclick="removeState(${i})">x</button>
        `;
        list.appendChild(row);
    });
}

window.updatePop = function(i, val) {
    states[i].pop = parseInt(val) || 1;
    recalculate();
    renderStateList();
};

window.removeState = function(i) {
    if (states.length <= 2) return;
    states.splice(i, 1);
    recalculate();
    renderStateList();
};

document.getElementById('addState').addEventListener('click', () => {
    if (states.length >= 12) return;
    const names = ['Zeta','Eta','Theta','Iota','Kappa','Lambda','Mu'];
    states.push({ name: names[states.length - 5] || 'State' + states.length, pop: 1000 });
    recalculate();
    renderStateList();
});

document.getElementById('totalSeats').addEventListener('change', () => {
    alabamaMode = false;
    recalculate();
    renderStateList();
});
document.getElementById('method').addEventListener('change', () => {
    alabamaMode = false;
    recalculate();
    renderStateList();
});

document.getElementById('showAlabama').addEventListener('click', () => {
    document.getElementById('method').value = 'hamilton';
    alabamaMode = true;
    alabamaData = null;
    // Search for alabama paradox
    for (let seats = 5; seats < 200; seats++) {
        const a1 = hamilton(states, seats);
        const a2 = hamilton(states, seats + 1);
        for (let i = 0; i < states.length; i++) {
            if (a2[i] < a1[i]) {
                alabamaData = { seats, a1, a2, loser: i };
                break;
            }
        }
        if (alabamaData) break;
    }
    if (alabamaData) {
        document.getElementById('paradoxMsg').innerHTML =
            `<div class="paradox-alert">ALABAMA PARADOX FOUND!<br>With ${alabamaData.seats} seats, ${states[alabamaData.loser].name} gets ${alabamaData.a1[alabamaData.loser]} seats.<br>With ${alabamaData.seats + 1} seats, ${states[alabamaData.loser].name} gets only ${alabamaData.a2[alabamaData.loser]}!</div>`;
        totalSeats = alabamaData.seats;
        document.getElementById('totalSeats').value = totalSeats;
        allocations = alabamaData.a1;
        animProgress = 0;
    } else {
        document.getElementById('paradoxMsg').innerHTML =
            '<div style="color:#50d890;font-size:12px;margin:6px 0;">No Alabama paradox found for this configuration (try different populations).</div>';
    }
    renderStateList();
});

function draw() {
    ctx.clearRect(0, 0, W, H);

    // Grid
    ctx.strokeStyle = 'rgba(60,80,120,0.12)';
    for (let x = 0; x < W; x += 40) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
    for (let y = 0; y < H; y += 40) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }

    animProgress = Math.min(animProgress + 0.02, 1);

    const n = states.length;
    const totalPop = states.reduce((s, st) => s + st.pop, 0);
    const maxSeats = Math.max(...allocations, 1);

    // Title
    ctx.fillStyle = '#c0d4f0';
    ctx.font = 'bold 20px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Apportionment: ' + totalSeats + ' Seats Among ' + n + ' States', W * 0.35, 45);

    // Draw state blocks
    const areaLeft = 60;
    const areaRight = Math.min(W - 380, W * 0.6);
    const areaTop = 80;
    const areaW = areaRight - areaLeft;

    const blockSize = Math.min(40, areaW / (maxSeats + 2), (H - 200) / (n * 2));
    const rowHeight = blockSize + 20;

    for (let i = 0; i < n; i++) {
        const y = areaTop + i * rowHeight;
        const seats = allocations[i] || 0;
        const fairShare = (states[i].pop / totalPop) * totalSeats;

        // State name
        ctx.fillStyle = stateColors[i % stateColors.length];
        ctx.font = 'bold 13px system-ui';
        ctx.textAlign = 'right';
        ctx.fillText(states[i].name, areaLeft - 10, y + blockSize / 2 + 5);

        // Seat blocks
        const animSeats = Math.round(seats * animProgress);
        for (let s = 0; s < animSeats; s++) {
            ctx.fillStyle = stateColors[i % stateColors.length];
            ctx.globalAlpha = 0.7;
            ctx.fillRect(areaLeft + s * (blockSize + 3), y, blockSize, blockSize);
            ctx.globalAlpha = 1;
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.strokeRect(areaLeft + s * (blockSize + 3), y, blockSize, blockSize);
        }

        // Fair share line
        const fairX = areaLeft + fairShare * (blockSize + 3);
        ctx.strokeStyle = 'rgba(240,192,64,0.6)';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 3]);
        ctx.beginPath();
        ctx.moveTo(fairX, y - 3);
        ctx.lineTo(fairX, y + blockSize + 3);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.lineWidth = 1;

        // Info
        ctx.fillStyle = '#8899bb';
        ctx.font = '11px system-ui';
        ctx.textAlign = 'left';
        const infoX = areaLeft + Math.max(seats, Math.ceil(fairShare)) * (blockSize + 3) + 10;
        ctx.fillText(`${seats} seats (fair: ${fairShare.toFixed(2)})  pop: ${states[i].pop.toLocaleString()}`, infoX, y + blockSize / 2 + 4);

        // Alabama highlight
        if (alabamaMode && alabamaData && i === alabamaData.loser) {
            ctx.strokeStyle = '#f06070';
            ctx.lineWidth = 2;
            ctx.strokeRect(areaLeft - 5, y - 5, Math.max(seats, 1) * (blockSize + 3) + 10, blockSize + 10);
            ctx.lineWidth = 1;
        }
    }

    // Legend
    ctx.fillStyle = '#8090b0';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('Solid blocks = allocated seats.  Dashed line = exact fair share.', areaLeft, areaTop + n * rowHeight + 20);

    requestAnimationFrame(draw);
}

window.reset = function() {
    states = [
        { name: 'Alpha', pop: 1500 },
        { name: 'Beta', pop: 3200 },
        { name: 'Gamma', pop: 2800 },
        { name: 'Delta', pop: 1000 },
        { name: 'Epsilon', pop: 1500 }
    ];
    totalSeats = 10;
    document.getElementById('totalSeats').value = 10;
    document.getElementById('method').value = 'hamilton';
    alabamaMode = false;
    alabamaData = null;
    document.getElementById('paradoxMsg').innerHTML = '';
    recalculate();
    renderStateList();
};

recalculate();
renderStateList();
draw();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
