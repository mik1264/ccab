<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Voting Method Showdown - 6 Methods Compared</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
canvas { display: block; position: fixed; top: 0; left: 0; z-index: 0; }

#controls {
    position: fixed; top: 15px; left: 50%; transform: translateX(-50%); z-index: 10;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100,140,255,0.2); border-radius: 12px;
    padding: 12px 18px; display: flex; gap: 8px; align-items: center;
}
.btn {
    display: inline-block; padding: 8px 14px;
    background: rgba(100,140,255,0.15); border: 1px solid rgba(100,140,255,0.3);
    border-radius: 6px; color: #b0c8ff; cursor: pointer; font-size: 12px;
    transition: all 0.2s; white-space: nowrap;
}
.btn:hover { background: rgba(100,140,255,0.3); color: #fff; }
.btn.highlight { background: rgba(255,200,60,0.2); border-color: rgba(255,200,60,0.4); color: #ffe088; }
.btn.highlight:hover { background: rgba(255,200,60,0.35); color: #fff; }

#methods-grid {
    position: fixed; bottom: 0; left: 0; right: 0; z-index: 10;
    display: grid; grid-template-columns: repeat(6, 1fr); gap: 0;
    height: 42vh; min-height: 260px;
}
.method-panel {
    background: rgba(16,18,34,0.92); backdrop-filter: blur(10px);
    border: 1px solid rgba(100,140,255,0.1);
    padding: 12px; display: flex; flex-direction: column; overflow: hidden;
}
.method-panel h3 {
    font-size: 12px; color: #7ba4ff; margin-bottom: 8px;
    text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.method-panel .winner-line {
    text-align: center; font-size: 12px; font-weight: bold;
    margin-bottom: 6px; padding: 4px; border-radius: 6px;
    background: rgba(100,255,140,0.06); min-height: 28px;
    display: flex; align-items: center; justify-content: center;
}
.method-bars { flex: 1; overflow: hidden; display: flex; flex-direction: column; justify-content: center; }
.m-bar { display: flex; align-items: center; margin: 2px 0; }
.m-bar .cname { width: 42px; font-size: 9px; text-align: right; padding-right: 4px; overflow: hidden; text-overflow: ellipsis; }
.m-bar .bar-bg { flex: 1; height: 16px; background: rgba(255,255,255,0.04); border-radius: 3px; overflow: hidden; position: relative; }
.m-bar .bar-fill {
    height: 100%; border-radius: 3px; transition: width 0.5s ease;
    display: flex; align-items: center; padding-left: 3px;
    font-size: 8px; color: #fff; font-weight: bold;
}
.m-bar .score { width: 32px; text-align: right; font-size: 9px; color: #667; padding-left: 3px; }
.disagree-badge {
    position: fixed; top: 70px; left: 50%; transform: translateX(-50%); z-index: 20;
    background: rgba(255,80,60,0.15); border: 1px solid rgba(255,80,60,0.3);
    border-radius: 10px; padding: 8px 20px; font-size: 13px; color: #ff9988;
    text-align: center; display: none;
}

#info {
    position: fixed; top: 15px; right: 15px; z-index: 10;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100,140,255,0.2); border-radius: 12px;
    padding: 14px; width: 260px; font-size: 11px; line-height: 1.5;
}
#info h3 { color: #7ba4ff; margin-bottom: 6px; font-size: 13px; }
#info p { color: #8899aa; margin-bottom: 4px; }
#info .highlight { color: #ffaa66; font-weight: bold; }

a.back { position: fixed; top: 15px; left: 15px; color: #7ba4ff; text-decoration: none; font-size: 13px; z-index: 20; }
a.back:hover { color: #aaccff; }

#voter-count {
    font-size: 11px; color: #6688aa;
}

@media (max-width: 900px) {
    #methods-grid { grid-template-columns: repeat(3, 1fr); height: 55vh; }
}
</style>
</head>
<body>
<a href="index.html" class="back">&#8592; Back</a>
<canvas id="c"></canvas>

<div id="controls">
    <button class="btn" onclick="addRandomVoters(30)">+30 Voters</button>
    <button class="btn" onclick="addRandomVoters(80)">+80 Voters</button>
    <button class="btn highlight" onclick="randomizeAll()">Randomize All</button>
    <button class="btn highlight" onclick="findDisagreement()">Find Disagreement</button>
    <button class="btn" onclick="window.reset()">Reset</button>
    <span id="voter-count">0 voters</span>
</div>

<div class="disagree-badge" id="disagreeBadge"></div>

<div id="methods-grid">
    <div class="method-panel" id="panel-plurality">
        <h3>1. Plurality</h3>
        <div class="winner-line" id="win-plurality">--</div>
        <div class="method-bars" id="bars-plurality"></div>
    </div>
    <div class="method-panel" id="panel-rcv">
        <h3>2. Ranked Choice (IRV)</h3>
        <div class="winner-line" id="win-rcv">--</div>
        <div class="method-bars" id="bars-rcv"></div>
    </div>
    <div class="method-panel" id="panel-borda">
        <h3>3. Borda Count</h3>
        <div class="winner-line" id="win-borda">--</div>
        <div class="method-bars" id="bars-borda"></div>
    </div>
    <div class="method-panel" id="panel-approval">
        <h3>4. Approval Voting</h3>
        <div class="winner-line" id="win-approval">--</div>
        <div class="method-bars" id="bars-approval"></div>
    </div>
    <div class="method-panel" id="panel-condorcet">
        <h3>5. Condorcet</h3>
        <div class="winner-line" id="win-condorcet">--</div>
        <div class="method-bars" id="bars-condorcet"></div>
    </div>
    <div class="method-panel" id="panel-score">
        <h3>6. Score Voting</h3>
        <div class="winner-line" id="win-score">--</div>
        <div class="method-bars" id="bars-score"></div>
    </div>
</div>

<div id="info">
    <h3>Method Showdown</h3>
    <p>Same voters, same preferences -- <span class="highlight">6 different methods</span> can produce <span class="highlight">different winners</span>.</p>
    <p>Click <span class="highlight">"Find Disagreement"</span> to auto-search for voter configurations where the methods disagree the most.</p>
    <p>Click the canvas to add voters. Drag candidates (large circles).</p>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

const COLORS = ['#4488ff', '#ff4466', '#44dd88', '#ffaa22', '#cc66ff'];
const NAMES = ['Blue', 'Red', 'Green', 'Orange', 'Purple'];
const NUM_CANDIDATES = 5;
const APPROVAL_RADIUS = 180;
const SCORE_MAX = 5;

let candidates = [];
let voters = [];
let dragging = null;
let dragOffset = { x: 0, y: 0 };
let animFrame;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}

function dist(a, b) { return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2); }

function initCandidates() {
    const cx = W * 0.5, cy = (H * 0.58) * 0.5;
    const spread = Math.min(W, H * 0.58) * 0.25;
    candidates = [];
    for (let i = 0; i < NUM_CANDIDATES; i++) {
        const angle = (i / NUM_CANDIDATES) * Math.PI * 2 - Math.PI / 2;
        candidates.push({
            x: cx + Math.cos(angle) * spread,
            y: cy + Math.sin(angle) * spread,
            color: COLORS[i], name: NAMES[i], r: 18
        });
    }
}

function rankFor(voter, activeCands) {
    if (!activeCands) activeCands = candidates.map((_, i) => i);
    return activeCands.map(i => ({ i, d: dist(voter, candidates[i]) }))
        .sort((a, b) => a.d - b.d)
        .map(x => x.i);
}

// --- Voting Methods ---

function runPlurality() {
    const counts = new Array(NUM_CANDIDATES).fill(0);
    for (const v of voters) {
        const ranking = rankFor(v);
        counts[ranking[0]]++;
    }
    return counts;
}

function runRCV() {
    const eliminated = new Set();
    const roundScores = new Array(NUM_CANDIDATES).fill(0);

    for (let round = 0; round < NUM_CANDIDATES - 1; round++) {
        const active = [];
        for (let i = 0; i < NUM_CANDIDATES; i++) if (!eliminated.has(i)) active.push(i);
        if (active.length <= 1) break;

        const counts = {};
        for (const i of active) counts[i] = 0;

        for (const v of voters) {
            const ranking = rankFor(v, active);
            if (ranking.length > 0) counts[ranking[0]]++;
        }

        // Check majority
        const total = voters.length;
        for (const i of active) {
            if (counts[i] > total / 2) {
                // Surviving rounds = score
                for (const i2 of active) roundScores[i2] = counts[i2];
                return roundScores;
            }
        }

        // Eliminate lowest
        let minV = Infinity, minI = -1;
        for (const i of active) {
            if (counts[i] < minV) { minV = counts[i]; minI = i; }
        }
        eliminated.add(minI);
        for (const i of active) roundScores[i] = counts[i];
    }

    // Last standing
    for (let i = 0; i < NUM_CANDIDATES; i++) {
        if (!eliminated.has(i)) roundScores[i] = voters.length;
    }
    return roundScores;
}

function runBorda() {
    const scores = new Array(NUM_CANDIDATES).fill(0);
    for (const v of voters) {
        const ranking = rankFor(v);
        ranking.forEach((ci, rank) => {
            scores[ci] += (NUM_CANDIDATES - 1 - rank);
        });
    }
    return scores;
}

function runApproval() {
    const counts = new Array(NUM_CANDIDATES).fill(0);
    for (const v of voters) {
        for (let i = 0; i < NUM_CANDIDATES; i++) {
            if (dist(v, candidates[i]) <= APPROVAL_RADIUS) counts[i]++;
        }
    }
    return counts;
}

function runCondorcet() {
    // Pairwise wins matrix
    const wins = Array.from({ length: NUM_CANDIDATES }, () => new Array(NUM_CANDIDATES).fill(0));
    for (const v of voters) {
        for (let i = 0; i < NUM_CANDIDATES; i++) {
            for (let j = i + 1; j < NUM_CANDIDATES; j++) {
                if (dist(v, candidates[i]) < dist(v, candidates[j])) {
                    wins[i][j]++;
                } else {
                    wins[j][i]++;
                }
            }
        }
    }

    // Condorcet score: number of head-to-head matchups won
    const scores = new Array(NUM_CANDIDATES).fill(0);
    for (let i = 0; i < NUM_CANDIDATES; i++) {
        for (let j = 0; j < NUM_CANDIDATES; j++) {
            if (i !== j && wins[i][j] > wins[j][i]) scores[i]++;
        }
    }
    return scores;
}

function runScore() {
    // Score voting: each voter gives 0-5 based on distance
    const scores = new Array(NUM_CANDIDATES).fill(0);
    const maxDist = Math.sqrt(W * W + H * H) * 0.5;
    for (const v of voters) {
        for (let i = 0; i < NUM_CANDIDATES; i++) {
            const d = dist(v, candidates[i]);
            const normalized = 1 - Math.min(d / (maxDist * 0.6), 1);
            const s = Math.round(normalized * SCORE_MAX);
            scores[i] += s;
        }
    }
    return scores;
}

function getWinner(scores) {
    let best = 0;
    for (let i = 1; i < scores.length; i++) if (scores[i] > scores[best]) best = i;
    return best;
}

function renderBars(containerId, winnerId, scores, labelSuffix) {
    const container = document.getElementById(containerId);
    const winEl = document.getElementById(winnerId);
    const maxS = Math.max(...scores, 1);
    const winner = getWinner(scores);

    let html = '';
    for (let i = 0; i < NUM_CANDIDATES; i++) {
        const barW = scores[i] / maxS * 100;
        const isWin = i === winner;
        html += `<div class="m-bar">
            <span class="cname" style="color:${COLORS[i]}">${NAMES[i]}</span>
            <span class="bar-bg"><span class="bar-fill" style="width:${barW}%;background:${COLORS[i]}${isWin ? '' : '88'}">${scores[i]}</span></span>
            <span class="score">${labelSuffix ? scores[i] + labelSuffix : ''}</span>
        </div>`;
    }
    container.innerHTML = html;
    winEl.innerHTML = voters.length > 0
        ? `<span style="color:${COLORS[winner]}">&#9733; ${NAMES[winner]}</span>`
        : '--';

    return winner;
}

function tallyAll() {
    if (voters.length === 0) {
        ['plurality', 'rcv', 'borda', 'approval', 'condorcet', 'score'].forEach(m => {
            document.getElementById('bars-' + m).innerHTML = '';
            document.getElementById('win-' + m).textContent = '--';
        });
        document.getElementById('voter-count').textContent = '0 voters';
        document.getElementById('disagreeBadge').style.display = 'none';
        return;
    }

    const results = {};
    results.plurality = runPlurality();
    results.rcv = runRCV();
    results.borda = runBorda();
    results.approval = runApproval();
    results.condorcet = runCondorcet();
    results.score = runScore();

    const winners = {};
    winners.plurality = renderBars('bars-plurality', 'win-plurality', results.plurality, '');
    winners.rcv = renderBars('bars-rcv', 'win-rcv', results.rcv, '');
    winners.borda = renderBars('bars-borda', 'win-borda', results.borda, 'pt');
    winners.approval = renderBars('bars-approval', 'win-approval', results.approval, '');
    winners.condorcet = renderBars('bars-condorcet', 'win-condorcet', results.condorcet, 'w');
    winners.score = renderBars('bars-score', 'win-score', results.score, 'pt');

    document.getElementById('voter-count').textContent = voters.length + ' voters';

    // Highlight panels with unique winners
    const winSet = new Set(Object.values(winners));
    const methods = ['plurality', 'rcv', 'borda', 'approval', 'condorcet', 'score'];
    for (const m of methods) {
        const panel = document.getElementById('panel-' + m);
        panel.style.borderColor = winSet.size > 1 ? COLORS[winners[m]] + '44' : 'rgba(100,140,255,0.1)';
    }

    // Disagreement badge
    const badge = document.getElementById('disagreeBadge');
    if (winSet.size >= 3) {
        badge.style.display = 'block';
        badge.textContent = winSet.size + ' different winners from 6 methods! Democracy depends on the rules.';
    } else if (winSet.size === 2) {
        badge.style.display = 'block';
        badge.textContent = '2 different winners -- methods disagree!';
    } else {
        badge.style.display = 'none';
    }
}

function addRandomVoters(n) {
    const margin = 60;
    const maxY = H * 0.55;
    for (let i = 0; i < n; i++) {
        if (candidates.length > 0 && Math.random() < 0.65) {
            const c = candidates[Math.floor(Math.random() * candidates.length)];
            voters.push({
                x: Math.max(margin, Math.min(W - margin, c.x + (Math.random() - 0.5) * 280)),
                y: Math.max(margin, Math.min(maxY - margin, c.y + (Math.random() - 0.5) * 280))
            });
        } else {
            voters.push({
                x: margin + Math.random() * (W - 2 * margin),
                y: margin + Math.random() * (maxY - 2 * margin)
            });
        }
    }
    tallyAll();
}

function randomizeAll() {
    voters = [];
    const margin = 60;
    const maxY = H * 0.55;
    // Randomize candidate positions
    for (const c of candidates) {
        c.x = margin + Math.random() * (W - 2 * margin);
        c.y = margin + Math.random() * (maxY - 2 * margin);
    }
    addRandomVoters(60 + Math.floor(Math.random() * 80));
}

function findDisagreement() {
    // Try many random configs, keep the one with most unique winners
    let bestVoters = null;
    let bestCands = null;
    let bestUniqueCount = 0;

    const origCands = candidates.map(c => ({ ...c }));
    const margin = 60;
    const maxY = H * 0.55;

    for (let attempt = 0; attempt < 200; attempt++) {
        // Random candidate positions
        for (let i = 0; i < NUM_CANDIDATES; i++) {
            candidates[i].x = margin + Math.random() * (W - 2 * margin);
            candidates[i].y = margin + Math.random() * (maxY - 2 * margin);
        }

        // Random voters
        voters = [];
        const nv = 40 + Math.floor(Math.random() * 80);
        for (let i = 0; i < nv; i++) {
            if (Math.random() < 0.7) {
                const c = candidates[Math.floor(Math.random() * NUM_CANDIDATES)];
                voters.push({
                    x: Math.max(margin, Math.min(W - margin, c.x + (Math.random() - 0.5) * 240)),
                    y: Math.max(margin, Math.min(maxY - margin, c.y + (Math.random() - 0.5) * 240))
                });
            } else {
                voters.push({
                    x: margin + Math.random() * (W - 2 * margin),
                    y: margin + Math.random() * (maxY - 2 * margin)
                });
            }
        }

        const winners = new Set([
            getWinner(runPlurality()),
            getWinner(runRCV()),
            getWinner(runBorda()),
            getWinner(runApproval()),
            getWinner(runCondorcet()),
            getWinner(runScore())
        ]);

        if (winners.size > bestUniqueCount) {
            bestUniqueCount = winners.size;
            bestVoters = voters.map(v => ({ ...v }));
            bestCands = candidates.map(c => ({ ...c }));
            if (bestUniqueCount >= 4) break; // Good enough
        }
    }

    if (bestCands) {
        for (let i = 0; i < NUM_CANDIDATES; i++) {
            candidates[i].x = bestCands[i].x;
            candidates[i].y = bestCands[i].y;
        }
        voters = bestVoters;
    }

    tallyAll();
}

function draw() {
    ctx.clearRect(0, 0, W, H);

    // Grid
    ctx.strokeStyle = 'rgba(100,140,255,0.03)';
    ctx.lineWidth = 1;
    for (let x = 0; x < W; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
    for (let y = 0; y < H; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }

    const canvasBottom = H * 0.58;

    // Dim region below canvas area
    ctx.fillStyle = 'rgba(10,14,26,0.5)';
    ctx.fillRect(0, canvasBottom, W, H - canvasBottom);

    // Voter -> nearest candidate lines
    for (const v of voters) {
        if (v.y > canvasBottom) continue;
        const ranking = rankFor(v);
        if (ranking.length > 0) {
            const c = candidates[ranking[0]];
            ctx.beginPath();
            ctx.moveTo(v.x, v.y);
            ctx.lineTo(c.x, c.y);
            ctx.strokeStyle = c.color + '0a';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }

    // Voters
    for (const v of voters) {
        const ranking = rankFor(v);
        const col = ranking.length > 0 ? candidates[ranking[0]].color : '#555';
        ctx.beginPath(); ctx.arc(v.x, v.y, 3.5, 0, Math.PI * 2);
        ctx.fillStyle = col + '77'; ctx.fill();
    }

    // Candidates
    for (let i = 0; i < candidates.length; i++) {
        const c = candidates[i];

        // Glow
        const grad = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, 40);
        grad.addColorStop(0, c.color + '55');
        grad.addColorStop(1, c.color + '00');
        ctx.beginPath(); ctx.arc(c.x, c.y, 40, 0, Math.PI * 2);
        ctx.fillStyle = grad; ctx.fill();

        // Approval radius hint (dashed)
        ctx.beginPath(); ctx.arc(c.x, c.y, APPROVAL_RADIUS, 0, Math.PI * 2);
        ctx.strokeStyle = c.color + '12'; ctx.lineWidth = 1; ctx.setLineDash([3, 5]); ctx.stroke();
        ctx.setLineDash([]);

        // Body
        ctx.beginPath(); ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
        ctx.fillStyle = c.color; ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();

        // Label
        ctx.fillStyle = '#fff'; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText(c.name, c.x, c.y - c.r - 8);
    }

    animFrame = requestAnimationFrame(draw);
}

// Interaction
canvas.addEventListener('mousedown', (e) => {
    const mx = e.clientX, my = e.clientY;
    if (my > H * 0.58) return;
    for (const c of candidates) {
        if (dist({ x: mx, y: my }, c) < c.r + 5) {
            dragging = c; dragOffset.x = mx - c.x; dragOffset.y = my - c.y; return;
        }
    }
    voters.push({ x: mx, y: my });
    tallyAll();
});
canvas.addEventListener('mousemove', (e) => {
    if (dragging) {
        dragging.x = e.clientX - dragOffset.x;
        dragging.y = Math.min(e.clientY - dragOffset.y, H * 0.55);
        tallyAll();
    }
});
canvas.addEventListener('mouseup', () => { dragging = null; });

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const t = e.touches[0]; const mx = t.clientX, my = t.clientY;
    if (my > H * 0.58) return;
    for (const c of candidates) {
        if (dist({ x: mx, y: my }, c) < c.r + 15) {
            dragging = c; dragOffset.x = mx - c.x; dragOffset.y = my - c.y; return;
        }
    }
    voters.push({ x: mx, y: my }); tallyAll();
}, { passive: false });
canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (dragging) {
        const t = e.touches[0];
        dragging.x = t.clientX - dragOffset.x;
        dragging.y = Math.min(t.clientY - dragOffset.y, H * 0.55);
        tallyAll();
    }
}, { passive: false });
canvas.addEventListener('touchend', () => { dragging = null; });

window.addEventListener('resize', () => { resize(); });

window.reset = function() {
    cancelAnimationFrame(animFrame);
    voters = [];
    document.getElementById('disagreeBadge').style.display = 'none';
    resize(); initCandidates(); tallyAll(); draw();
};

resize();
initCandidates();
addRandomVoters(100);
draw();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
