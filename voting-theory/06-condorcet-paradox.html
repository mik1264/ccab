<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Condorcet Paradox - Voting Cycles</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        a.back-link {
            position: fixed;
            top: 16px;
            left: 16px;
            color: #7eb8da;
            text-decoration: none;
            z-index: 100;
            font-size: 14px;
            opacity: 0.8;
            transition: opacity 0.3s;
        }
        a.back-link:hover { opacity: 1; }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #controls {
            position: fixed;
            top: 16px;
            right: 16px;
            background: rgba(20,20,40,0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
            z-index: 50;
            width: 300px;
            max-height: calc(100vh - 32px);
            overflow-y: auto;
        }
        #controls h2 {
            font-size: 16px;
            margin-bottom: 12px;
            color: #7eb8da;
        }
        #controls h3 {
            font-size: 13px;
            color: #aaa;
            margin: 12px 0 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .slider-row label {
            font-size: 13px;
            min-width: 100px;
            color: #ccc;
        }
        .slider-row input[type="range"] {
            flex: 1;
            accent-color: #7eb8da;
        }
        .slider-row .val {
            font-size: 13px;
            min-width: 30px;
            text-align: right;
            color: #fff;
            font-weight: bold;
        }
        #info-panel {
            position: fixed;
            bottom: 16px;
            left: 16px;
            background: rgba(20,20,40,0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 16px 20px;
            z-index: 50;
            max-width: 420px;
            font-size: 13px;
            line-height: 1.5;
            color: #bbb;
        }
        #info-panel strong { color: #e0e0e0; }
        #info-panel em { color: #ff6b6b; font-style: normal; font-weight: bold; }
        #result-box {
            margin-top: 12px;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
        }
        .result-cycle {
            background: rgba(255,80,80,0.15);
            border: 1px solid rgba(255,80,80,0.4);
            color: #ff6b6b;
        }
        .result-winner {
            background: rgba(80,200,120,0.15);
            border: 1px solid rgba(80,200,120,0.4);
            color: #50c878;
        }
        #matrix-panel {
            position: fixed;
            bottom: 16px;
            right: 16px;
            background: rgba(20,20,40,0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 16px 20px;
            z-index: 50;
            font-size: 13px;
        }
        #matrix-panel h3 {
            font-size: 13px;
            color: #7eb8da;
            margin-bottom: 8px;
        }
        table {
            border-collapse: collapse;
        }
        table th, table td {
            padding: 6px 12px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
            font-size: 13px;
        }
        table th {
            background: rgba(126,184,218,0.15);
            color: #7eb8da;
        }
        td.win { color: #50c878; font-weight: bold; }
        td.lose { color: #ff6b6b; }
        td.na { color: #555; }
        button {
            background: rgba(126,184,218,0.2);
            color: #7eb8da;
            border: 1px solid rgba(126,184,218,0.3);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            margin-top: 8px;
            transition: background 0.2s;
        }
        button:hover { background: rgba(126,184,218,0.35); }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Back to Voting Theory</a>
    <canvas id="canvas"></canvas>

    <div id="controls">
        <h2>Condorcet Paradox</h2>
        <h3>Voter Groups</h3>
        <div class="slider-row">
            <label>A &gt; B &gt; C:</label>
            <input type="range" id="g1" min="0" max="40" value="23">
            <span class="val" id="g1v">23</span>
        </div>
        <div class="slider-row">
            <label>B &gt; C &gt; A:</label>
            <input type="range" id="g2" min="0" max="40" value="17">
            <span class="val" id="g2v">17</span>
        </div>
        <div class="slider-row">
            <label>C &gt; A &gt; B:</label>
            <input type="range" id="g3" min="0" max="40" value="2">
            <span class="val" id="g3v">2</span>
        </div>
        <div class="slider-row">
            <label>A &gt; C &gt; B:</label>
            <input type="range" id="g4" min="0" max="40" value="10">
            <span class="val" id="g4v">10</span>
        </div>
        <div class="slider-row">
            <label>B &gt; A &gt; C:</label>
            <input type="range" id="g5" min="0" max="40" value="8">
            <span class="val" id="g5v">8</span>
        </div>
        <div class="slider-row">
            <label>C &gt; B &gt; A:</label>
            <input type="range" id="g6" min="0" max="40" value="20">
            <span class="val" id="g6v">20</span>
        </div>
        <button id="preset-cycle">Preset: Cycle</button>
        <button id="preset-winner">Preset: Clear Winner</button>
    </div>

    <div id="info-panel">
        <strong>The Condorcet Paradox</strong> shows that majority preferences can be <em>cyclic</em>.
        Even if most voters prefer A over B, and B over C, a majority may still prefer C over A.
        There is no single "will of the people" -- collective preferences can be irrational even when
        every individual's preferences are perfectly rational.
        <div id="result-box" class="result-cycle">Cycle detected: A &gt; B &gt; C &gt; A</div>
    </div>

    <div id="matrix-panel">
        <h3>Pairwise Matchup Matrix</h3>
        <table id="matrix">
            <thead>
                <tr><th></th><th>vs A</th><th>vs B</th><th>vs C</th><th>Wins</th></tr>
            </thead>
            <tbody id="matrix-body"></tbody>
        </table>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const candidates = ['A', 'B', 'C'];
        const colors = { A: '#ff6b6b', B: '#4ecdc4', C: '#ffe66d' };

        // Voter group preference orders (all 6 permutations of 3 candidates)
        const groupPrefs = [
            ['A','B','C'], // g1
            ['B','C','A'], // g2
            ['C','A','B'], // g3
            ['A','C','B'], // g4
            ['B','A','C'], // g5
            ['C','B','A'], // g6
        ];

        let groups = [23, 17, 2, 10, 8, 20];
        let pairwise = {};
        let cycleEdges = [];
        let condorcetWinner = null;
        let animT = 0;

        const sliders = [];
        const valSpans = [];
        for (let i = 1; i <= 6; i++) {
            const sl = document.getElementById('g' + i);
            const vs = document.getElementById('g' + i + 'v');
            sliders.push(sl);
            valSpans.push(vs);
            sl.addEventListener('input', () => {
                groups[i - 1] = parseInt(sl.value);
                vs.textContent = sl.value;
                computePairwise();
            });
        }

        document.getElementById('preset-cycle').addEventListener('click', () => {
            const vals = [23, 17, 2, 10, 8, 20];
            for (let i = 0; i < 6; i++) {
                sliders[i].value = vals[i];
                valSpans[i].textContent = vals[i];
                groups[i] = vals[i];
            }
            computePairwise();
        });

        document.getElementById('preset-winner').addEventListener('click', () => {
            const vals = [30, 5, 5, 25, 3, 2];
            for (let i = 0; i < 6; i++) {
                sliders[i].value = vals[i];
                valSpans[i].textContent = vals[i];
                groups[i] = vals[i];
            }
            computePairwise();
        });

        function computePairwise() {
            pairwise = {};
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (i === j) continue;
                    const a = candidates[i];
                    const b = candidates[j];
                    let votes = 0;
                    for (let g = 0; g < 6; g++) {
                        const prefs = groupPrefs[g];
                        if (prefs.indexOf(a) < prefs.indexOf(b)) {
                            votes += groups[g];
                        }
                    }
                    pairwise[a + b] = votes;
                }
            }

            // Detect cycle or winner
            const wins = { A: 0, B: 0, C: 0 };
            const pairs = [['A','B'],['B','C'],['A','C']];
            const edges = [];

            for (const [a, b] of pairs) {
                const ab = pairwise[a + b];
                const ba = pairwise[b + a];
                if (ab > ba) {
                    wins[a]++;
                    edges.push([a, b]);
                } else if (ba > ab) {
                    wins[b]++;
                    edges.push([b, a]);
                }
            }

            condorcetWinner = null;
            cycleEdges = edges;

            for (const c of candidates) {
                if (wins[c] === 2) {
                    condorcetWinner = c;
                }
            }

            // Check for actual cycle: A>B, B>C, C>A or A>C, C>B, B>A
            const hasAB = edges.some(e => e[0]==='A' && e[1]==='B');
            const hasBA = edges.some(e => e[0]==='B' && e[1]==='A');
            const hasBC = edges.some(e => e[0]==='B' && e[1]==='C');
            const hasCB = edges.some(e => e[0]==='C' && e[1]==='B');
            const hasAC = edges.some(e => e[0]==='A' && e[1]==='C');
            const hasCA = edges.some(e => e[0]==='C' && e[1]==='A');

            const isCycle = (hasAB && hasBC && hasCA) || (hasBA && hasCB && hasAC);

            const resultBox = document.getElementById('result-box');
            if (isCycle) {
                let cycleStr;
                if (hasAB && hasBC && hasCA) cycleStr = 'A \u2192 B \u2192 C \u2192 A';
                else cycleStr = 'A \u2192 C \u2192 B \u2192 A';
                resultBox.className = 'result-cycle';
                resultBox.innerHTML = 'CYCLE DETECTED: ' + cycleStr;
            } else if (condorcetWinner) {
                resultBox.className = 'result-winner';
                resultBox.innerHTML = 'Condorcet Winner: <span style="color:' + colors[condorcetWinner] + '">' + condorcetWinner + '</span> (beats all others head-to-head)';
            } else {
                resultBox.className = 'result-cycle';
                resultBox.innerHTML = 'No clear winner (ties exist)';
            }

            updateMatrix();
        }

        function updateMatrix() {
            const tbody = document.getElementById('matrix-body');
            tbody.innerHTML = '';
            for (const a of candidates) {
                const tr = document.createElement('tr');
                const th = document.createElement('th');
                th.textContent = a;
                th.style.color = colors[a];
                tr.appendChild(th);
                let wCount = 0;
                for (const b of candidates) {
                    const td = document.createElement('td');
                    if (a === b) {
                        td.textContent = '-';
                        td.className = 'na';
                    } else {
                        const ab = pairwise[a + b];
                        const ba = pairwise[b + a];
                        td.textContent = ab + '-' + ba;
                        if (ab > ba) { td.className = 'win'; wCount++; }
                        else if (ba > ab) { td.className = 'lose'; }
                        else { td.className = 'na'; }
                    }
                    tr.appendChild(td);
                }
                const tdw = document.createElement('td');
                tdw.textContent = wCount;
                tdw.style.fontWeight = 'bold';
                tdw.style.color = wCount === 2 ? '#50c878' : '#ccc';
                tr.appendChild(tdw);
                tbody.appendChild(tr);
            }
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Candidate node positions (triangle)
        function getNodePositions() {
            const cx = canvas.width * 0.42;
            const cy = canvas.height * 0.48;
            const r = Math.min(canvas.width, canvas.height) * 0.2;
            return {
                A: { x: cx, y: cy - r },
                B: { x: cx - r * Math.cos(Math.PI / 6), y: cy + r * Math.sin(Math.PI / 6) },
                C: { x: cx + r * Math.cos(Math.PI / 6), y: cy + r * Math.sin(Math.PI / 6) }
            };
        }

        function drawArrow(x1, y1, x2, y2, color, width, pulse) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.sqrt(dx * dx + dy * dy);
            const nx = dx / len;
            const ny = dy / len;

            // Shorten to not overlap circles
            const nodeR = 40;
            const sx = x1 + nx * nodeR;
            const sy = y1 + ny * nodeR;
            const ex = x2 - nx * (nodeR + 15);
            const ey = y2 - ny * (nodeR + 15);

            // Curve offset
            const mx = (sx + ex) / 2 - ny * 30;
            const my = (sy + ey) / 2 + nx * 30;

            ctx.save();
            if (pulse) {
                ctx.shadowColor = color;
                ctx.shadowBlur = 15 + Math.sin(animT * 3) * 8;
            }
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.quadraticCurveTo(mx, my, ex, ey);
            ctx.stroke();

            // Arrowhead
            const t = 0.98;
            const ax = (1-t)*(1-t)*sx + 2*(1-t)*t*mx + t*t*ex;
            const ay = (1-t)*(1-t)*sy + 2*(1-t)*t*my + t*t*ey;
            const angle = Math.atan2(ey - ay, ex - ax);
            const headLen = 14;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(ex, ey);
            ctx.lineTo(ex - headLen * Math.cos(angle - 0.4), ey - headLen * Math.sin(angle - 0.4));
            ctx.lineTo(ex - headLen * Math.cos(angle + 0.4), ey - headLen * Math.sin(angle + 0.4));
            ctx.closePath();
            ctx.fill();

            // Vote count label on curve
            const lx = mx;
            const ly = my;
            const from = color === '#ff6b6b' ? 'A' : color === '#4ecdc4' ? 'B' : 'C';
            // Find actual edge for this arrow
            ctx.restore();
        }

        function drawNode(x, y, label, color) {
            const r = 40;
            ctx.save();
            ctx.shadowColor = color;
            ctx.shadowBlur = 20;
            ctx.fillStyle = color + '33';
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.restore();

            ctx.fillStyle = color;
            ctx.font = 'bold 32px Segoe UI, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, x, y);
        }

        function drawVoteLabel(x1, y1, x2, y2, text, color) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.sqrt(dx * dx + dy * dy);
            const nx = dx / len;
            const ny = dy / len;
            const mx = (x1 + x2) / 2 - ny * 45;
            const my = (y1 + y2) / 2 + nx * 45;

            ctx.fillStyle = color;
            ctx.font = 'bold 14px Segoe UI, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, mx, my);
        }

        function animate() {
            animT += 0.016;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background grid
            ctx.strokeStyle = 'rgba(126,184,218,0.03)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            const pos = getNodePositions();

            // Detect cycle for coloring
            const pairs = [['A','B'],['B','C'],['A','C']];
            const edgeWinners = [];
            for (const [a, b] of pairs) {
                const ab = pairwise[a + b] || 0;
                const ba = pairwise[b + a] || 0;
                if (ab > ba) edgeWinners.push([a, b, ab, ba]);
                else if (ba > ab) edgeWinners.push([b, a, ba, ab]);
            }

            const hasAB = edgeWinners.some(e => e[0]==='A' && e[1]==='B');
            const hasBA = edgeWinners.some(e => e[0]==='B' && e[1]==='A');
            const hasBC = edgeWinners.some(e => e[0]==='B' && e[1]==='C');
            const hasCB = edgeWinners.some(e => e[0]==='C' && e[1]==='B');
            const hasAC = edgeWinners.some(e => e[0]==='A' && e[1]==='C');
            const hasCA = edgeWinners.some(e => e[0]==='C' && e[1]==='A');
            const isCycle = (hasAB && hasBC && hasCA) || (hasBA && hasCB && hasAC);

            // Draw edges
            for (const [winner, loser, wVotes, lVotes] of edgeWinners) {
                const from = pos[winner];
                const to = pos[loser];
                const edgeColor = isCycle ? '#ff6b6b' : colors[winner];
                drawArrow(from.x, from.y, to.x, to.y, edgeColor, isCycle ? 3 : 2.5, isCycle);
                drawVoteLabel(from.x, from.y, to.x, to.y, wVotes + '-' + lVotes, edgeColor);
            }

            // Draw nodes
            for (const c of candidates) {
                const highlight = condorcetWinner === c;
                const nodeColor = colors[c];
                drawNode(pos[c].x, pos[c].y, c, nodeColor);
                if (highlight) {
                    ctx.save();
                    ctx.strokeStyle = '#50c878';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#50c878';
                    ctx.shadowBlur = 20 + Math.sin(animT * 2) * 10;
                    ctx.beginPath();
                    ctx.arc(pos[c].x, pos[c].y, 52, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();

                    ctx.fillStyle = '#50c878';
                    ctx.font = '13px Segoe UI, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('CONDORCET WINNER', pos[c].x, pos[c].y + 62);
                }
            }

            // Cycle animation - pulsing ring
            if (isCycle) {
                const cycleOrder = hasAB ? ['A','B','C'] : ['A','C','B'];
                const progress = (animT * 0.5) % 1;
                const segIdx = Math.floor(progress * 3);
                const segT = (progress * 3) % 1;
                const fromC = cycleOrder[segIdx % 3];
                const toC = cycleOrder[(segIdx + 1) % 3];
                const fx = pos[fromC].x;
                const fy = pos[fromC].y;
                const tx = pos[toC].x;
                const ty = pos[toC].y;
                const px = fx + (tx - fx) * segT;
                const py = fy + (ty - fy) * segT;

                ctx.save();
                ctx.shadowColor = '#ff6b6b';
                ctx.shadowBlur = 25;
                ctx.fillStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.arc(px, py, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Title
            ctx.fillStyle = 'rgba(255,255,255,0.06)';
            ctx.font = 'bold 48px Segoe UI, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('CONDORCET PARADOX', canvas.width * 0.42, 60);

            // Total voters
            const total = groups.reduce((s, v) => s + v, 0);
            ctx.fillStyle = '#888';
            ctx.font = '14px Segoe UI, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Total voters: ' + total, canvas.width * 0.42, canvas.height - 20);

            requestAnimationFrame(animate);
        }

        window.reset = function() {
            const vals = [23, 17, 2, 10, 8, 20];
            for (let i = 0; i < 6; i++) {
                sliders[i].value = vals[i];
                valSpans[i].textContent = vals[i];
                groups[i] = vals[i];
            }
            computePairwise();
        };

        computePairwise();
        animate();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
