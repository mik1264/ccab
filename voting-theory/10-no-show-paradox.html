<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>No-Show Paradox - Voting Against Yourself</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        a.back-link {
            position: fixed;
            top: 16px;
            left: 16px;
            color: #7eb8da;
            text-decoration: none;
            z-index: 100;
            font-size: 14px;
            opacity: 0.8;
        }
        a.back-link:hover { opacity: 1; }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #controls {
            position: fixed;
            top: 16px;
            right: 16px;
            background: rgba(20,20,40,0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
            z-index: 50;
            width: 290px;
            max-height: calc(100vh - 32px);
            overflow-y: auto;
        }
        #controls h2 {
            font-size: 16px;
            margin-bottom: 4px;
            color: #7eb8da;
        }
        #controls p.sub {
            font-size: 11px;
            color: #666;
            margin-bottom: 14px;
            line-height: 1.4;
        }
        #controls h3 {
            font-size: 12px;
            color: #888;
            margin: 14px 0 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .toggle-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .toggle-row:hover { background: rgba(255,255,255,0.04); }
        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            flex-shrink: 0;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            transition: background 0.3s;
            cursor: pointer;
        }
        .toggle-slider::before {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            left: 3px;
            bottom: 3px;
            background: #666;
            border-radius: 50%;
            transition: all 0.3s;
        }
        .toggle-switch input:checked + .toggle-slider {
            background: rgba(255,80,80,0.4);
        }
        .toggle-switch input:checked + .toggle-slider::before {
            transform: translateX(20px);
            background: #ff6b6b;
        }
        .toggle-label {
            font-size: 13px;
            color: #ccc;
            line-height: 1.3;
        }
        .toggle-label small {
            display: block;
            font-size: 11px;
            color: #777;
            margin-top: 2px;
        }
        .scenario-btn {
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin-bottom: 6px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            color: #ccc;
            cursor: pointer;
            font-size: 12px;
            text-align: left;
            transition: all 0.2s;
        }
        .scenario-btn:hover { background: rgba(126,184,218,0.15); }
        .scenario-btn.active {
            background: rgba(126,184,218,0.2);
            border-color: rgba(126,184,218,0.5);
            color: #7eb8da;
        }
        .step-controls {
            display: flex;
            gap: 6px;
            margin-top: 12px;
        }
        .step-controls button {
            flex: 1;
            padding: 8px;
            background: rgba(126,184,218,0.2);
            color: #7eb8da;
            border: 1px solid rgba(126,184,218,0.3);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }
        .step-controls button:hover { background: rgba(126,184,218,0.35); }
        .step-controls button:disabled { opacity: 0.3; cursor: not-allowed; }
        button.reset-btn {
            display: block;
            width: 100%;
            padding: 8px;
            margin-top: 8px;
            background: rgba(126,184,218,0.2);
            color: #7eb8da;
            border: 1px solid rgba(126,184,218,0.3);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
        }
        button.reset-btn:hover { background: rgba(126,184,218,0.35); }
        #info-panel {
            position: fixed;
            bottom: 16px;
            left: 16px;
            background: rgba(20,20,40,0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 16px 20px;
            z-index: 50;
            max-width: 420px;
            font-size: 13px;
            line-height: 1.5;
            color: #bbb;
        }
        #info-panel strong { color: #e0e0e0; }
        #info-panel em { color: #ff6b6b; font-style: normal; font-weight: bold; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Back to Voting Theory</a>
    <canvas id="canvas"></canvas>

    <div id="controls">
        <h2>No-Show Paradox</h2>
        <p class="sub">Under IRV, a group of voters who prefer candidate X can cause X to LOSE by showing up to vote honestly for X.</p>

        <div class="toggle-row" id="toggle-area">
            <div class="toggle-switch">
                <input type="checkbox" id="extra-voters-toggle">
                <span class="toggle-slider"></span>
            </div>
            <div class="toggle-label">
                Extra voters show up
                <small>They honestly vote for their favorite</small>
            </div>
        </div>

        <h3>Scenario</h3>
        <button class="scenario-btn active" data-scenario="classic">Classic 3-Candidate</button>
        <button class="scenario-btn" data-scenario="tight">Tight Race</button>

        <h3>Walkthrough</h3>
        <div class="step-controls">
            <button id="btn-prev" disabled>&larr; Prev</button>
            <button id="btn-next">Next &rarr;</button>
        </div>

        <h3 style="margin-top:16px;">Compare Methods</h3>
        <p style="font-size:11px;color:#666;margin-bottom:8px;">The no-show paradox affects IRV but not these methods:</p>
        <div style="display:flex;gap:4px;">
            <button class="scenario-btn" style="margin:0;text-align:center;" data-method="irv" id="m-irv">IRV</button>
            <button class="scenario-btn" style="margin:0;text-align:center;" data-method="plurality" id="m-plurality">Plurality</button>
            <button class="scenario-btn" style="margin:0;text-align:center;" data-method="approval" id="m-approval">Approval</button>
        </div>

        <button class="reset-btn" id="btn-reset">Reset</button>
    </div>

    <div id="info-panel">
        <strong>The No-Show Paradox</strong> is one of the most shocking results in voting theory. Under Instant
        Runoff Voting (IRV), a group of voters who prefer candidate X can <em>cause X to lose</em> simply by
        showing up and voting honestly for X. If they had stayed home, X would have won. This means that in IRV,
        it can be <em>rational not to vote</em>, even when you have a strong preference. Plurality and approval
        voting are immune to this paradox.
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let animT = 0;

        const candColors = { A: '#ff6b6b', B: '#4ecdc4', C: '#ffe66d' };

        // Classic no-show paradox scenario under IRV:
        //
        // Scenario "classic":
        //   Without extra voters (25 total):
        //     7: A > B > C
        //     8: B > C > A
        //    10: C > A > B
        //   Round 1: A=7, B=8, C=10 -> A eliminated
        //   Round 2: A's 7 votes go to B -> B=15 vs C=10 -> B wins
        //
        //   With 4 extra voters who prefer B (B > A > C) (29 total):
        //     7: A > B > C
        //     8: B > C > A
        //     4: B > A > C  (extra voters)
        //    10: C > A > B
        //   Round 1: A=7, B=12, C=10 -> A eliminated
        //   Round 2: A's 7 go to B -> B=19 vs C=10 -> B wins
        //
        // That doesn't trigger the paradox. Let me use the correct construction:
        //
        //   Without extra voters (17 total):
        //     6: A > B > C
        //     5: B > C > A
        //     6: C > A > B
        //   Round 1: A=6, B=5, C=6 -> B eliminated (fewest)
        //   Round 2: B's 5 go to C -> A=6 vs C=11 -> C wins
        //
        //   With 2 extra voters who prefer C (C > A > B) (19 total):
        //     6: A > B > C
        //     5: B > C > A
        //     8: C > A > B  (6 original + 2 extra)
        //   Round 1: A=6, B=5, C=8 -> B eliminated
        //   Round 2: B's 5 go to C -> A=6 vs C=13 -> C wins
        //
        // Still C wins. Need different structure. The paradox needs the extra
        // voters to change which candidate gets eliminated first.
        //
        // Correct construction:
        //   Without extra voters (21 total):
        //     7: A > C > B
        //     6: B > A > C
        //     8: C > B > A
        //   Round 1: A=7, B=6, C=8 -> B eliminated
        //   Round 2: B's 6 prefer A -> A=13 vs C=8 -> A wins
        //
        //   With 2 extra voters who prefer A (A > C > B) (23 total):
        //     9: A > C > B  (7+2)
        //     6: B > A > C
        //     8: C > B > A
        //   Round 1: A=9, B=6, C=8 -> B eliminated
        //   Round 2: B's 6 prefer A -> A=15 vs C=8 -> A wins
        //
        // A still wins. Need to flip elimination order.
        //
        // Correct no-show construction:
        //   Without extra voters (25 total):
        //     8: A > B > C
        //     5: B > C > A
        //    12: C > A > B
        //   Round 1: A=8, B=5, C=12 -> B eliminated
        //   Round 2: B's 5 go to C -> A=8, C=17 -> C wins
        //
        //   With 2 extra voters (C > A > B) (27 total):
        //     8: A > B > C
        //     5: B > C > A
        //    14: C > A > B
        //   Round 1: A=8, B=5, C=14 -> B eliminated
        //   Round 2: B's 5 go to C -> A=8, C=19 -> C wins
        //
        // Need the extra voters to shift elimination. Actual paradox:
        //
        //   Without extra voters (13 voters):
        //     5: A > C > B
        //     4: B > A > C
        //     4: C > B > A
        //   Round 1: A=5, B=4, C=4 -> C eliminated (or B, say C)
        //   Round 2: C's 4 go to B -> A=5 vs B=8 -> B wins
        //   Or if B eliminated: B's 4 go to A -> A=9 vs C=4 -> A wins
        //   Tie-break matters. Let me use well-known example.
        //
        // WELL-KNOWN NO-SHOW PARADOX:
        //   Without 2 extra voters (25 voters):
        //     8: A > B > C
        //     2: B > A > C
        //     7: B > C > A
        //     8: C > A > B
        //   Round 1: A=8, B=9, C=8 -> A eliminated (fewest, or tied-fewest)
        //   Round 2: A's 8 go to B -> B=17 vs C=8 -> B wins
        //
        //   With 2 extra voters who prefer B (B > A > C) (27 voters):
        //     8: A > B > C
        //     4: B > A > C  (2+2)
        //     7: B > C > A
        //     8: C > A > B
        //   Round 1: A=8, B=11, C=8 -> A or C eliminated (tied)
        //   Hmm, ambiguous.
        //
        // Let me use the textbook example from Fishburn & Brams 1983:
        //   Without extra voters (11 voters):
        //     3: A > B > C
        //     4: B > C > A
        //     4: C > A > B
        //   Round 1: A=3, B=4, C=4 -> A eliminated
        //   Round 2: A's 3 go to B -> B=7 vs C=4 -> B wins
        //
        //   Add 2 voters: B > C > A (13 voters total):
        //     3: A > B > C
        //     6: B > C > A
        //     4: C > A > B
        //   Round 1: A=3, B=6, C=4 -> A eliminated
        //   Round 2: A's 3 go to B -> B=9 vs C=4 -> B wins
        //   Same winner! Not a paradox.
        //
        // The actual paradox needs the extra voters to change elimination order:
        //   Without extra voters (17 voters):
        //     6: A > B > C
        //     4: C > A > B
        //     5: B > C > A
        //     2: C > B > A
        //   Round 1: A=6, B=5, C=6 -> B eliminated
        //   Round 2: B's 5 go to C -> A=6, C=11 -> C wins
        //
        //   Add 2 voters: C > A > B (19 total):
        //     6: A > B > C
        //     6: C > A > B  (4+2)
        //     5: B > C > A
        //     2: C > B > A
        //   Round 1: A=6, B=5, C=8 -> B eliminated
        //   Round 2: B's 5 go to C -> A=6, C=13 -> C wins
        //   Same! Elimination order didn't change.
        //
        // ACTUAL WORKING EXAMPLE (Moulin 1988):
        //   Without extra voters (17 voters):
        //     5: A > B > C
        //     4: C > A > B
        //     3: B > C > A
        //     5: B > A > C
        //   A=5, B=8, C=4 -> C eliminated
        //   C's 4 go to A -> A=9 vs B=8 -> A wins
        //
        //   Add 2 voters: A > B > C (19 total):
        //     7: A > B > C
        //     4: C > A > B
        //     3: B > C > A
        //     5: B > A > C
        //   A=7, B=8, C=4 -> C eliminated
        //   C's 4 go to A -> A=11 vs B=8 -> A wins
        //   Still A! Need to flip elimination.
        //
        // CORRECT WORKING EXAMPLE:
        //   Without extra voters (15 voters):
        //     6: A > C > B
        //     4: B > A > C
        //     5: C > B > A
        //   A=6, B=4, C=5 -> B eliminated
        //   B's 4 go to A -> A=10 vs C=5 -> A wins!
        //
        //   Add 2 voters: A > C > B (17 total):
        //     8: A > C > B
        //     4: B > A > C
        //     5: C > B > A
        //   A=8, B=4, C=5 -> B eliminated
        //   B's 4 go to A -> A=12 vs C=5 -> A wins
        //   Still same. The extra A voters just pad A's lead.
        //
        // The trick is: extra voters must change who is eliminated FIRST.
        //
        // DEFINITIVE WORKING EXAMPLE:
        //   Without extra voters (9 voters):
        //     4: B > C > A
        //     3: A > B > C
        //     2: C > A > B
        //   A=3, B=4, C=2 -> C eliminated
        //   C's 2 go to A -> A=5 vs B=4 -> A wins
        //
        //   Add 2 voters: A > B > C (11 total):
        //     4: B > C > A
        //     5: A > B > C
        //     2: C > A > B
        //   A=5, B=4, C=2 -> C eliminated
        //   C's 2 go to A -> A=7 vs B=4 -> A wins
        //   Same! A just wins more.
        //
        // I need extra voters for A to CHANGE the elimination order so that a
        // different candidate is eliminated first, causing a chain reaction.
        //
        // THE REAL TRICK - 3 candidates, the extra A-voters cause B to be
        // eliminated instead of C, and C beats A in the final:
        //
        //   Without 2 extra voters (15 voters):
        //     6: B > A > C
        //     4: A > C > B
        //     5: C > B > A
        //   A=4, B=6, C=5 -> A eliminated
        //   A's 4 go to C -> B=6 vs C=9 -> C wins
        //
        //   With 2 extra A-voters (A > C > B) (17 voters):
        //     6: B > A > C
        //     6: A > C > B  (4+2 extra)
        //     5: C > B > A
        //   A=6, B=6, C=5 -> C eliminated (fewest!)
        //   C's 5 go to B (C>B>A, 2nd choice is B) -> B=11 vs A=6 -> B wins
        //
        //   The extra voters prefer A > C > B.
        //   Without them: C wins. Their LEAST favorite is B, their 2nd is C.
        //   With them showing up and voting for A: B wins! Their LEAST favorite!
        //   They made their worst outcome happen by voting!
        //
        // PERFECT. That's the paradox.

        const scenarioData = {
            classic: {
                candidates: ['A', 'B', 'C'],
                baseGroups: [
                    { voters: 6, prefs: ['B', 'A', 'C'], label: '6 voters: B > A > C' },
                    { voters: 4, prefs: ['A', 'C', 'B'], label: '4 voters: A > C > B' },
                    { voters: 5, prefs: ['C', 'B', 'A'], label: '5 voters: C > B > A' }
                ],
                extraGroup: { voters: 2, prefs: ['A', 'C', 'B'], label: '2 extra: A > C > B' },
                extraFavorite: 'A',
                description: '2 extra voters honestly prefer A. Without them, C wins (acceptable to them). With them, B wins (their WORST candidate).'
            },
            tight: {
                candidates: ['A', 'B', 'C'],
                baseGroups: [
                    { voters: 9, prefs: ['B', 'A', 'C'], label: '9 voters: B > A > C' },
                    { voters: 6, prefs: ['A', 'C', 'B'], label: '6 voters: A > C > B' },
                    { voters: 8, prefs: ['C', 'B', 'A'], label: '8 voters: C > B > A' }
                ],
                extraGroup: { voters: 3, prefs: ['A', 'C', 'B'], label: '3 extra: A > C > B' },
                extraFavorite: 'A',
                description: '3 extra voters support A. Without them, C wins. With them, B wins -- their least favorite!'
            }
        };

        let currentScenario = 'classic';
        let extraVotersActive = false;
        let step = 0;
        const maxStep = 4;
        let currentMethod = 'irv';

        const extraToggle = document.getElementById('extra-voters-toggle');
        const toggleArea = document.getElementById('toggle-area');
        toggleArea.addEventListener('click', (e) => {
            if (e.target.tagName !== 'INPUT') {
                extraToggle.checked = !extraToggle.checked;
            }
            extraVotersActive = extraToggle.checked;
        });
        extraToggle.addEventListener('change', () => {
            extraVotersActive = extraToggle.checked;
        });

        document.querySelectorAll('.scenario-btn[data-scenario]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.scenario-btn[data-scenario]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentScenario = btn.dataset.scenario;
                step = 0;
                updateControls();
            });
        });

        document.querySelectorAll('[data-method]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-method]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMethod = btn.dataset.method;
            });
        });
        document.getElementById('m-irv').classList.add('active');

        document.getElementById('btn-next').addEventListener('click', () => {
            if (step < maxStep) step++;
            updateControls();
        });
        document.getElementById('btn-prev').addEventListener('click', () => {
            if (step > 0) step--;
            updateControls();
        });
        document.getElementById('btn-reset').addEventListener('click', () => { window.reset(); });

        function updateControls() {
            document.getElementById('btn-prev').disabled = step === 0;
            document.getElementById('btn-next').disabled = step === maxStep;
        }

        function runIRV(groups, candidates) {
            let remaining = [...candidates];
            const rounds = [];
            while (remaining.length > 1) {
                const scores = {};
                remaining.forEach(c => scores[c] = 0);
                groups.forEach(g => {
                    for (const c of g.prefs) {
                        if (remaining.includes(c)) {
                            scores[c] += g.voters;
                            break;
                        }
                    }
                });
                let minScore = Infinity;
                let eliminated = null;
                for (const c of remaining) {
                    if (scores[c] < minScore) {
                        minScore = scores[c];
                        eliminated = c;
                    }
                }
                rounds.push({ scores: {...scores}, eliminated, remaining: [...remaining] });
                remaining = remaining.filter(c => c !== eliminated);
            }
            return { rounds, winner: remaining[0] };
        }

        function runPlurality(groups, candidates) {
            const scores = {};
            candidates.forEach(c => scores[c] = 0);
            groups.forEach(g => { scores[g.prefs[0]] += g.voters; });
            let winner = candidates[0];
            for (const c of candidates) {
                if (scores[c] > scores[winner]) winner = c;
            }
            return { scores, winner };
        }

        function runApproval(groups, candidates) {
            // Voters approve top 2
            const scores = {};
            candidates.forEach(c => scores[c] = 0);
            groups.forEach(g => {
                scores[g.prefs[0]] += g.voters;
                if (g.prefs.length > 1) scores[g.prefs[1]] += g.voters;
            });
            let winner = candidates[0];
            for (const c of candidates) {
                if (scores[c] > scores[winner]) winner = c;
            }
            return { scores, winner };
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        function roundRect(x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.arcTo(x + w, y, x + w, y + r, r);
            ctx.lineTo(x + w, y + h - r);
            ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
            ctx.lineTo(x + r, y + h);
            ctx.arcTo(x, y + h, x, y + h - r, r);
            ctx.lineTo(x, y + r);
            ctx.arcTo(x, y, x + r, y, r);
            ctx.closePath();
        }

        function drawBallotGroup(x, y, g, highlight, isExtra) {
            const w = 180;
            const h = 90;
            ctx.save();
            const bg = isExtra ? 'rgba(255,80,80,0.1)' : 'rgba(255,255,255,0.03)';
            const border = isExtra ? 'rgba(255,80,80,0.35)' : 'rgba(255,255,255,0.08)';
            ctx.fillStyle = bg;
            ctx.strokeStyle = border;
            ctx.lineWidth = isExtra ? 2 : 1;
            roundRect(x, y, w, h, 8);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = isExtra ? '#ff6b6b' : '#888';
            ctx.font = '11px Segoe UI, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(g.label, x + 10, y + 18);

            for (let i = 0; i < g.prefs.length; i++) {
                const c = g.prefs[i];
                const ry = y + 30 + i * 18;
                ctx.fillStyle = candColors[c];
                ctx.font = (i === 0 && highlight ? 'bold ' : '') + '13px Segoe UI, sans-serif';
                ctx.fillText((i + 1) + '. ' + c, x + 14, ry + 6);
            }

            if (isExtra) {
                ctx.fillStyle = '#ff6b6b';
                ctx.font = 'bold 9px Segoe UI, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('EXTRA VOTERS', x + w / 2, y + h - 6);
            }
            ctx.restore();
        }

        function drawRoundResult(x, y, round, idx, totalVoters, isFinal) {
            const w = 260;
            ctx.fillStyle = '#7eb8da';
            ctx.font = 'bold 13px Segoe UI, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Round ' + (idx + 1), x, y);

            round.remaining.forEach((c, i) => {
                const barY = y + 8 + i * 28;
                const barMaxW = 180;
                const barW = (round.scores[c] / totalVoters) * barMaxW;
                const isElim = c === round.eliminated;
                const isWinner = isFinal && round.remaining.length === 2 && c !== round.eliminated;

                ctx.fillStyle = (candColors[c] || '#888') + (isElim ? '22' : '44');
                ctx.fillRect(x, barY, Math.max(barW, 2), 20);
                ctx.strokeStyle = (candColors[c] || '#888') + (isElim ? '44' : '88');
                ctx.lineWidth = 1;
                ctx.strokeRect(x, barY, Math.max(barW, 2), 20);

                ctx.fillStyle = isElim ? '#666' : candColors[c];
                ctx.font = (isWinner ? 'bold ' : '') + '12px Segoe UI, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(c + ': ' + round.scores[c], x + 4, barY + 15);

                if (isElim) {
                    ctx.fillStyle = '#ff6b6b';
                    ctx.font = 'bold 10px Segoe UI, sans-serif';
                    ctx.textAlign = 'right';
                    ctx.fillText('ELIMINATED', x + w - 10, barY + 15);
                }
                if (isWinner) {
                    ctx.save();
                    ctx.shadowColor = '#50c878';
                    ctx.shadowBlur = 10;
                    ctx.strokeStyle = '#50c878';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x - 2, barY - 2, Math.max(barW, 2) + 4, 24);
                    ctx.restore();
                    ctx.fillStyle = '#50c878';
                    ctx.font = 'bold 10px Segoe UI, sans-serif';
                    ctx.textAlign = 'right';
                    ctx.fillText('WINNER', x + w - 10, barY + 15);
                }
            });

            if (round.eliminated && !isFinal) {
                ctx.fillStyle = '#666';
                ctx.font = '11px Segoe UI, sans-serif';
                ctx.textAlign = 'left';
                const transferIdx = round.remaining.length;
                ctx.fillText(round.eliminated + "'s votes transfer to next preference", x, y + 8 + transferIdx * 28 + 14);
            }
        }

        function animate() {
            animT += 0.016;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background grid
            ctx.strokeStyle = 'rgba(126,184,218,0.03)';
            ctx.lineWidth = 1;
            for (let gx = 0; gx < canvas.width; gx += 40) {
                ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, canvas.height); ctx.stroke();
            }
            for (let gy = 0; gy < canvas.height; gy += 40) {
                ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(canvas.width, gy); ctx.stroke();
            }

            const sc = scenarioData[currentScenario];
            const groups = extraVotersActive
                ? [...sc.baseGroups, sc.extraGroup]
                : [...sc.baseGroups];
            const totalVoters = groups.reduce((s, g) => s + g.voters, 0);

            // Title
            ctx.fillStyle = 'rgba(255,255,255,0.07)';
            ctx.font = 'bold 36px Segoe UI, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('NO-SHOW PARADOX', canvas.width / 2 - 80, 50);

            // Side labels
            const leftX = 50;
            const rightX = canvas.width / 2 + 10;
            const sectionW = canvas.width / 2 - 100;

            // Run both scenarios for side-by-side
            const withoutGroups = [...sc.baseGroups];
            const withGroups = [...sc.baseGroups, sc.extraGroup];
            const totalWithout = withoutGroups.reduce((s, g) => s + g.voters, 0);
            const totalWith = withGroups.reduce((s, g) => s + g.voters, 0);

            let resultWithout, resultWith;
            if (currentMethod === 'irv') {
                resultWithout = runIRV(withoutGroups, sc.candidates);
                resultWith = runIRV(withGroups, sc.candidates);
            } else if (currentMethod === 'plurality') {
                const pw = runPlurality(withoutGroups, sc.candidates);
                const pwo = runPlurality(withGroups, sc.candidates);
                resultWithout = { rounds: [{ scores: pw.scores, remaining: sc.candidates, eliminated: null }], winner: pw.winner };
                resultWith = { rounds: [{ scores: pwo.scores, remaining: sc.candidates, eliminated: null }], winner: pwo.winner };
            } else {
                const aw = runApproval(withoutGroups, sc.candidates);
                const awo = runApproval(withGroups, sc.candidates);
                resultWithout = { rounds: [{ scores: aw.scores, remaining: sc.candidates, eliminated: null }], winner: aw.winner };
                resultWith = { rounds: [{ scores: awo.scores, remaining: sc.candidates, eliminated: null }], winner: awo.winner };
            }

            // === LEFT: Without extra voters ===
            ctx.fillStyle = '#50c878';
            ctx.font = 'bold 15px Segoe UI, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Extra voters STAY HOME', leftX, 80);
            ctx.fillStyle = '#888';
            ctx.font = '12px Segoe UI, sans-serif';
            ctx.fillText(totalWithout + ' voters total', leftX, 96);

            // Ballots (step >= 0)
            if (step >= 0) {
                withoutGroups.forEach((g, i) => {
                    drawBallotGroup(leftX, 110 + i * 98, g, step >= 1, false);
                });
            }

            // IRV rounds (step >= 2)
            if (step >= 2) {
                const roundStartY = 110 + withoutGroups.length * 98 + 10;
                resultWithout.rounds.forEach((round, i) => {
                    const isFinal = i === resultWithout.rounds.length - 1;
                    drawRoundResult(leftX, roundStartY + i * 110, round, i, totalWithout, isFinal);
                });
            }

            // Winner (step >= 3)
            if (step >= 3) {
                const winY = canvas.height - 120;
                ctx.save();
                ctx.fillStyle = 'rgba(80,200,120,0.1)';
                ctx.strokeStyle = 'rgba(80,200,120,0.4)';
                ctx.lineWidth = 2;
                roundRect(leftX, winY, 220, 44, 8);
                ctx.fill();
                ctx.stroke();
                ctx.restore();

                ctx.fillStyle = '#50c878';
                ctx.font = 'bold 16px Segoe UI, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Winner: ' + resultWithout.winner, leftX + 110, winY + 28);
            }

            // === RIGHT: With extra voters ===
            ctx.fillStyle = '#ff6b6b';
            ctx.font = 'bold 15px Segoe UI, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Extra voters SHOW UP (vote for ' + sc.extraFavorite + ')', rightX, 80);
            ctx.fillStyle = '#888';
            ctx.font = '12px Segoe UI, sans-serif';
            ctx.fillText(totalWith + ' voters total', rightX, 96);

            // Ballots
            if (step >= 0) {
                withGroups.forEach((g, i) => {
                    const isExtra = i === withGroups.length - 1;
                    drawBallotGroup(rightX, 110 + i * 98, g, step >= 1, isExtra);
                });
            }

            // IRV rounds (step >= 2)
            if (step >= 2) {
                const roundStartY = 110 + withGroups.length * 98 + 10;
                resultWith.rounds.forEach((round, i) => {
                    const isFinal = i === resultWith.rounds.length - 1;
                    drawRoundResult(rightX, roundStartY + i * 110, round, i, totalWith, isFinal);
                });
            }

            // Winner (step >= 3)
            if (step >= 3) {
                const winY = canvas.height - 120;
                const paradox = resultWithout.winner !== resultWith.winner;
                const col = paradox ? '#ff6b6b' : '#50c878';
                ctx.save();
                ctx.fillStyle = paradox ? 'rgba(255,80,80,0.1)' : 'rgba(80,200,120,0.1)';
                ctx.strokeStyle = paradox ? 'rgba(255,80,80,0.4)' : 'rgba(80,200,120,0.4)';
                ctx.lineWidth = 2;
                roundRect(rightX, winY, 220, 44, 8);
                ctx.fill();
                ctx.stroke();
                ctx.restore();

                ctx.fillStyle = col;
                ctx.font = 'bold 16px Segoe UI, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Winner: ' + resultWith.winner, rightX + 110, winY + 28);
            }

            // Paradox verdict (step >= 4)
            if (step >= 4) {
                const paradox = resultWithout.winner !== resultWith.winner;
                const verdictY = canvas.height - 65;

                if (paradox) {
                    const pulse = 0.6 + Math.sin(animT * 3) * 0.4;
                    ctx.save();
                    ctx.fillStyle = `rgba(255,80,80,${0.12 * pulse})`;
                    ctx.strokeStyle = `rgba(255,80,80,${0.5 * pulse})`;
                    ctx.lineWidth = 2;
                    const vw = canvas.width - 400;
                    const vx = (canvas.width - 290) / 2 - vw / 2 + 50;
                    roundRect(vx, verdictY, vw, 52, 10);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();

                    ctx.fillStyle = '#ff6b6b';
                    ctx.font = 'bold 18px Segoe UI, sans-serif';
                    ctx.textAlign = 'center';
                    const cx = (canvas.width - 290) / 2 + 50;
                    ctx.fillText('NO-SHOW PARADOX!', cx, verdictY + 22);
                    ctx.font = '13px Segoe UI, sans-serif';
                    ctx.fillStyle = '#ccc';
                    ctx.fillText(
                        'Voters who prefer ' + sc.extraFavorite + ' caused ' + sc.extraFavorite + ' to LOSE by voting for ' + sc.extraFavorite + '!',
                        cx, verdictY + 42
                    );
                } else {
                    ctx.fillStyle = 'rgba(80,200,120,0.08)';
                    ctx.strokeStyle = 'rgba(80,200,120,0.3)';
                    ctx.lineWidth = 1;
                    const vw = 360;
                    const vx = (canvas.width - 290) / 2 - vw / 2 + 50;
                    roundRect(vx, verdictY, vw, 42, 8);
                    ctx.fill();
                    ctx.stroke();

                    ctx.fillStyle = '#50c878';
                    ctx.font = 'bold 14px Segoe UI, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('No paradox with ' + currentMethod.toUpperCase() + ' -- same winner!', (canvas.width - 290) / 2 + 50, verdictY + 26);
                }
            }

            // Divider line
            ctx.strokeStyle = 'rgba(255,255,255,0.08)';
            ctx.lineWidth = 1;
            ctx.setLineDash([6, 6]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2 - 5, 70);
            ctx.lineTo(canvas.width / 2 - 5, canvas.height - 80);
            ctx.stroke();
            ctx.setLineDash([]);

            // Step indicator
            const stepLabels = ['View Ballots', 'First Choice', 'Count Rounds', 'See Winner', 'Compare'];
            ctx.textAlign = 'center';
            const stepsBaseX = (canvas.width - 290) / 2 + 50;
            for (let i = 0; i <= maxStep; i++) {
                const sx = stepsBaseX - 220 + i * 100;
                const sy = canvas.height - 15;
                ctx.fillStyle = i <= step ? '#7eb8da' : '#333';
                ctx.beginPath();
                ctx.arc(sx, sy, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = i <= step ? '#fff' : '#555';
                ctx.font = 'bold 9px Segoe UI, sans-serif';
                ctx.fillText(i + 1, sx, sy + 3);
            }

            requestAnimationFrame(animate);
        }

        window.reset = function() {
            currentScenario = 'classic';
            extraVotersActive = false;
            extraToggle.checked = false;
            step = 0;
            currentMethod = 'irv';
            document.querySelectorAll('.scenario-btn[data-scenario]').forEach(b => b.classList.remove('active'));
            document.querySelector('[data-scenario="classic"]').classList.add('active');
            document.querySelectorAll('[data-method]').forEach(b => b.classList.remove('active'));
            document.getElementById('m-irv').classList.add('active');
            updateControls();
        };

        updateControls();
        animate();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
