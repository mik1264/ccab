<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategic Voting - Gibbard-Satterthwaite Theorem</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e1a;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        a.back-link {
            position: fixed;
            top: 16px;
            left: 16px;
            color: #7eb8da;
            text-decoration: none;
            z-index: 100;
            font-size: 14px;
            opacity: 0.8;
        }
        a.back-link:hover { opacity: 1; }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #controls {
            position: fixed;
            top: 16px;
            right: 16px;
            background: rgba(20,20,40,0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
            z-index: 50;
            width: 300px;
            max-height: calc(100vh - 32px);
            overflow-y: auto;
        }
        #controls h2 {
            font-size: 16px;
            margin-bottom: 6px;
            color: #7eb8da;
        }
        #controls p.sub {
            font-size: 11px;
            color: #666;
            margin-bottom: 14px;
        }
        #controls h3 {
            font-size: 12px;
            color: #888;
            margin: 14px 0 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .method-btn {
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin-bottom: 6px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            color: #ccc;
            cursor: pointer;
            font-size: 13px;
            text-align: left;
            transition: all 0.2s;
        }
        .method-btn:hover { background: rgba(126,184,218,0.15); }
        .method-btn.active {
            background: rgba(126,184,218,0.2);
            border-color: rgba(126,184,218,0.5);
            color: #7eb8da;
        }
        .step-controls {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }
        .step-controls button {
            flex: 1;
            padding: 8px;
            background: rgba(126,184,218,0.2);
            color: #7eb8da;
            border: 1px solid rgba(126,184,218,0.3);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }
        .step-controls button:hover { background: rgba(126,184,218,0.35); }
        .step-controls button:disabled { opacity: 0.3; cursor: not-allowed; }
        #strategy-btn {
            display: block;
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: rgba(255,160,80,0.2);
            color: #ffa050;
            border: 1px solid rgba(255,160,80,0.4);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: background 0.2s;
        }
        #strategy-btn:hover { background: rgba(255,160,80,0.35); }
        #strategy-btn.strategic {
            background: rgba(255,80,80,0.2);
            color: #ff6b6b;
            border-color: rgba(255,80,80,0.4);
        }
        #info-panel {
            position: fixed;
            bottom: 16px;
            left: 16px;
            background: rgba(20,20,40,0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 16px 20px;
            z-index: 50;
            max-width: 420px;
            font-size: 13px;
            line-height: 1.5;
            color: #bbb;
        }
        #info-panel strong { color: #e0e0e0; }
        #info-panel em { color: #ffa050; font-style: normal; font-weight: bold; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Back to Voting Theory</a>
    <canvas id="canvas"></canvas>

    <div id="controls">
        <h2>Strategic Voting</h2>
        <p class="sub">The Gibbard-Satterthwaite theorem proves that every non-dictatorial voting method is manipulable.</p>

        <h3>Voting Method</h3>
        <button class="method-btn active" data-method="plurality">Plurality</button>
        <button class="method-btn" data-method="borda">Borda Count</button>
        <button class="method-btn" data-method="irv">Ranked Choice (IRV)</button>

        <h3>Scenario</h3>
        <div id="scenario-info" style="font-size:12px;color:#aaa;margin-bottom:8px;"></div>

        <div class="step-controls">
            <button id="btn-prev" disabled>&larr; Prev</button>
            <button id="btn-next">Next &rarr;</button>
        </div>

        <button id="strategy-btn">Toggle Strategic Vote</button>

        <button id="btn-reset" style="display:block;width:100%;padding:8px;margin-top:6px;background:rgba(126,184,218,0.2);color:#7eb8da;border:1px solid rgba(126,184,218,0.3);border-radius:6px;cursor:pointer;font-size:13px;">Reset</button>
    </div>

    <div id="info-panel">
        <strong>Gibbard-Satterthwaite Theorem:</strong> Any voting system that uses ranked ballots, has 3+ candidates,
        and is not a dictatorship can be <em>strategically manipulated</em>. Some voters can get a better outcome by
        lying about their preferences. This is not a flaw in specific systems -- it is a mathematical inevitability.
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let animT = 0;

        const candidateColors = { A: '#ff6b6b', B: '#4ecdc4', C: '#ffe66d', D: '#c084fc' };

        // Scenarios for each method
        const scenarios = {
            plurality: {
                candidates: ['A', 'B', 'C'],
                groups: [
                    { voters: 35, honest: ['A', 'B', 'C'], label: 'Group 1 (35 voters)' },
                    { voters: 33, honest: ['B', 'C', 'A'], label: 'Group 2 (33 voters)' },
                    { voters: 32, honest: ['C', 'B', 'A'], label: 'Group 3 (32 voters)', canManipulate: true }
                ],
                strategicGroup: 2,
                strategicVote: ['B', 'C', 'A'],
                explainHonest: 'Group 3 honestly prefers C, but C cannot win. Under plurality, only the first choice counts.',
                explainStrategic: 'Group 3 strategically votes B first. They prefer B over A, so lying helps them avoid their worst outcome.',
                honestWinner: 'A',
                strategicWinner: 'B'
            },
            borda: {
                candidates: ['A', 'B', 'C'],
                groups: [
                    { voters: 5, honest: ['A', 'B', 'C'], label: 'Group 1 (5 voters)' },
                    { voters: 4, honest: ['B', 'C', 'A'], label: 'Group 2 (4 voters)' },
                    { voters: 3, honest: ['C', 'A', 'B'], label: 'Group 3 (3 voters)', canManipulate: true }
                ],
                strategicGroup: 2,
                strategicVote: ['C', 'A', 'B'],
                explainHonest: 'Borda gives 2 points for 1st, 1 for 2nd, 0 for 3rd. A wins with honest voting.',
                explainStrategic: 'Group 3 buries B (moves to last) even though honest ranking is C>A>B. This changes point totals.',
                honestWinner: 'A',
                strategicWinner: 'C'
            },
            irv: {
                candidates: ['A', 'B', 'C'],
                groups: [
                    { voters: 6, honest: ['A', 'C', 'B'], label: 'Group 1 (6 voters)' },
                    { voters: 5, honest: ['B', 'A', 'C'], label: 'Group 2 (5 voters)', canManipulate: true },
                    { voters: 4, honest: ['C', 'B', 'A'], label: 'Group 3 (4 voters)' }
                ],
                strategicGroup: 1,
                strategicVote: ['A', 'B', 'C'],
                explainHonest: 'IRV eliminates the weakest candidate each round. C is eliminated, C\'s votes transfer to B. B wins.',
                explainStrategic: 'Group 2 lies and ranks A first. Now B is eliminated first, B votes transfer to A. A wins -- but Group 2 prefers A over C, so they benefit.',
                honestWinner: 'B',
                strategicWinner: 'A'
            }
        };

        let currentMethod = 'plurality';
        let isStrategic = false;
        let step = 0;
        let maxStep = 3;

        // Method buttons
        document.querySelectorAll('.method-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.method-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMethod = btn.dataset.method;
                isStrategic = false;
                step = 0;
                updateControls();
            });
        });

        document.getElementById('strategy-btn').addEventListener('click', () => {
            isStrategic = !isStrategic;
            updateControls();
        });

        document.getElementById('btn-next').addEventListener('click', () => {
            if (step < maxStep) step++;
            updateControls();
        });

        document.getElementById('btn-prev').addEventListener('click', () => {
            if (step > 0) step--;
            updateControls();
        });

        document.getElementById('btn-reset').addEventListener('click', () => {
            window.reset();
        });

        function updateControls() {
            document.getElementById('btn-prev').disabled = step === 0;
            document.getElementById('btn-next').disabled = step === maxStep;

            const stratBtn = document.getElementById('strategy-btn');
            stratBtn.textContent = isStrategic ? 'Show Honest Voting' : 'Show Strategic Manipulation';
            stratBtn.className = isStrategic ? 'strategic' : '';

            const sc = scenarios[currentMethod];
            const info = document.getElementById('scenario-info');
            if (isStrategic) {
                info.textContent = sc.explainStrategic;
            } else {
                info.textContent = sc.explainHonest;
            }
        }

        function computePlurality(groups, candidates) {
            const scores = {};
            candidates.forEach(c => scores[c] = 0);
            groups.forEach(g => {
                scores[g.prefs[0]] += g.voters;
            });
            return { scores, winner: candidates.reduce((a, b) => scores[a] >= scores[b] ? a : b) };
        }

        function computeBorda(groups, candidates) {
            const n = candidates.length;
            const scores = {};
            candidates.forEach(c => scores[c] = 0);
            groups.forEach(g => {
                g.prefs.forEach((c, i) => {
                    scores[c] += (n - 1 - i) * g.voters;
                });
            });
            return { scores, winner: candidates.reduce((a, b) => scores[a] >= scores[b] ? a : b) };
        }

        function computeIRV(groups, candidates) {
            let remaining = [...candidates];
            const rounds = [];

            while (remaining.length > 1) {
                const scores = {};
                remaining.forEach(c => scores[c] = 0);
                groups.forEach(g => {
                    for (const c of g.prefs) {
                        if (remaining.includes(c)) {
                            scores[c] += g.voters;
                            break;
                        }
                    }
                });

                const min = Math.min(...remaining.map(c => scores[c]));
                const eliminated = remaining.find(c => scores[c] === min);
                rounds.push({ scores: { ...scores }, eliminated, remaining: [...remaining] });
                remaining = remaining.filter(c => c !== eliminated);
            }

            return { rounds, winner: remaining[0] };
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        function drawBallot(x, y, w, h, prefs, label, voters, highlight, isManip) {
            ctx.save();
            const bg = isManip ? 'rgba(255,80,80,0.12)' : 'rgba(255,255,255,0.04)';
            const border = isManip ? 'rgba(255,80,80,0.4)' : 'rgba(255,255,255,0.1)';

            ctx.fillStyle = bg;
            ctx.strokeStyle = border;
            ctx.lineWidth = isManip ? 2 : 1;
            roundRect(ctx, x, y, w, h, 8);
            ctx.fill();
            ctx.stroke();

            // Label
            ctx.fillStyle = isManip ? '#ff6b6b' : '#888';
            ctx.font = '11px Segoe UI, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(label, x + 10, y + 18);
            ctx.fillStyle = '#aaa';
            ctx.textAlign = 'right';
            ctx.fillText(voters + ' voters', x + w - 10, y + 18);

            // Rankings
            for (let i = 0; i < prefs.length; i++) {
                const ry = y + 30 + i * 24;
                const c = prefs[i];
                ctx.fillStyle = candidateColors[c] || '#ccc';
                ctx.font = 'bold 14px Segoe UI, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText((i + 1) + '.', x + 14, ry + 6);
                ctx.fillText(c, x + 34, ry + 6);

                if (highlight && i === 0) {
                    ctx.fillStyle = candidateColors[c] + '22';
                    ctx.fillRect(x + 5, ry - 8, w - 10, 22);
                }
            }

            if (isManip) {
                ctx.fillStyle = '#ff6b6b';
                ctx.font = 'bold 10px Segoe UI, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('MANIPULATED', x + w / 2, y + h - 8);
            }

            ctx.restore();
        }

        function drawScoreBar(x, y, w, maxW, candidate, score, total, isWinner) {
            const barW = (score / total) * maxW;

            ctx.fillStyle = (candidateColors[candidate] || '#ccc') + '33';
            ctx.fillRect(x, y, barW, 24);
            ctx.strokeStyle = (candidateColors[candidate] || '#ccc') + '88';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, barW, 24);

            ctx.fillStyle = candidateColors[candidate] || '#ccc';
            ctx.font = 'bold 14px Segoe UI, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(candidate, x + 6, y + 17);

            ctx.textAlign = 'right';
            ctx.font = '13px Segoe UI, sans-serif';
            ctx.fillText(score, x + barW - 6, y + 17);

            if (isWinner) {
                ctx.save();
                ctx.shadowColor = '#50c878';
                ctx.shadowBlur = 10;
                ctx.strokeStyle = '#50c878';
                ctx.lineWidth = 2;
                ctx.strokeRect(x - 2, y - 2, barW + 4, 28);
                ctx.restore();

                ctx.fillStyle = '#50c878';
                ctx.font = 'bold 12px Segoe UI, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('WINNER', x + barW + 10, y + 17);
            }
        }

        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.arcTo(x + w, y, x + w, y + r, r);
            ctx.lineTo(x + w, y + h - r);
            ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
            ctx.lineTo(x + r, y + h);
            ctx.arcTo(x, y + h, x, y + h - r, r);
            ctx.lineTo(x, y + r);
            ctx.arcTo(x, y, x + r, y, r);
            ctx.closePath();
        }

        function animate() {
            animT += 0.016;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background grid
            ctx.strokeStyle = 'rgba(126,184,218,0.03)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 40) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 40) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }

            const sc = scenarios[currentMethod];
            const groups = sc.groups.map((g, i) => ({
                voters: g.voters,
                prefs: (isStrategic && i === sc.strategicGroup) ? sc.strategicVote : g.honest,
                label: g.label,
                isManip: isStrategic && i === sc.strategicGroup
            }));

            // Title
            ctx.fillStyle = 'rgba(255,255,255,0.07)';
            ctx.font = 'bold 36px Segoe UI, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('STRATEGIC VOTING', canvas.width / 2 - 100, 50);

            const methodNames = { plurality: 'Plurality', borda: 'Borda Count', irv: 'Ranked Choice (IRV)' };
            ctx.fillStyle = '#7eb8da';
            ctx.font = '18px Segoe UI, sans-serif';
            ctx.fillText('Method: ' + methodNames[currentMethod], canvas.width / 2 - 100, 80);

            // Draw ballots
            const ballotW = 160;
            const ballotH = 110;
            const startX = 50;
            const startY = 110;
            const gap = 20;

            for (let i = 0; i < groups.length; i++) {
                const g = groups[i];
                drawBallot(startX + i * (ballotW + gap), startY, ballotW, ballotH, g.prefs, g.label, g.voters, step >= 1, g.isManip);
            }

            // Arrow from ballots to results
            if (step >= 1) {
                const arrowY = startY + ballotH + 20;
                ctx.strokeStyle = 'rgba(126,184,218,0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(startX + (groups.length * (ballotW + gap)) / 2, arrowY);
                ctx.lineTo(startX + (groups.length * (ballotW + gap)) / 2, arrowY + 30);
                ctx.stroke();

                // Arrowhead
                const ax = startX + (groups.length * (ballotW + gap)) / 2;
                ctx.fillStyle = 'rgba(126,184,218,0.3)';
                ctx.beginPath();
                ctx.moveTo(ax, arrowY + 35);
                ctx.lineTo(ax - 6, arrowY + 25);
                ctx.lineTo(ax + 6, arrowY + 25);
                ctx.closePath();
                ctx.fill();
            }

            // Results
            if (step >= 2) {
                const resultY = startY + ballotH + 60;
                const totalVoters = groups.reduce((s, g) => s + g.voters, 0);
                const maxBarW = 300;

                let result;
                if (currentMethod === 'plurality') {
                    result = computePlurality(groups, sc.candidates);
                    ctx.fillStyle = '#aaa';
                    ctx.font = '14px Segoe UI, sans-serif';
                    ctx.textAlign = 'left';
                    ctx.fillText('First-choice votes:', startX, resultY);

                    sc.candidates.forEach((c, i) => {
                        drawScoreBar(startX, resultY + 14 + i * 34, maxBarW, maxBarW, c, result.scores[c], totalVoters, c === result.winner);
                    });
                } else if (currentMethod === 'borda') {
                    result = computeBorda(groups, sc.candidates);
                    const maxScore = Math.max(...Object.values(result.scores));
                    ctx.fillStyle = '#aaa';
                    ctx.font = '14px Segoe UI, sans-serif';
                    ctx.textAlign = 'left';
                    ctx.fillText('Borda scores (2/1/0 points):', startX, resultY);

                    sc.candidates.forEach((c, i) => {
                        drawScoreBar(startX, resultY + 14 + i * 34, maxBarW, maxBarW, c, result.scores[c], maxScore * 1.2, c === result.winner);
                    });
                } else if (currentMethod === 'irv') {
                    result = computeIRV(groups, sc.candidates);
                    ctx.fillStyle = '#aaa';
                    ctx.font = '14px Segoe UI, sans-serif';
                    ctx.textAlign = 'left';

                    result.rounds.forEach((round, ri) => {
                        const ry = resultY + ri * 120;
                        ctx.fillStyle = '#7eb8da';
                        ctx.fillText('Round ' + (ri + 1) + ':', startX, ry);

                        round.remaining.forEach((c, i) => {
                            drawScoreBar(startX, ry + 14 + i * 34, maxBarW, maxBarW, c, round.scores[c], totalVoters,
                                ri === result.rounds.length - 1 && c === result.winner);
                        });

                        if (round.eliminated) {
                            ctx.fillStyle = '#ff6b6b';
                            ctx.font = '12px Segoe UI, sans-serif';
                            ctx.fillText('Eliminated: ' + round.eliminated, startX, ry + 14 + round.remaining.length * 34 + 10);
                        }
                    });
                }
            }

            // Comparison panel
            if (step >= 3) {
                const cx = startX + 380;
                const cy = startY + ballotH + 60;

                ctx.save();
                ctx.fillStyle = isStrategic ? 'rgba(255,80,80,0.08)' : 'rgba(80,200,120,0.08)';
                ctx.strokeStyle = isStrategic ? 'rgba(255,80,80,0.3)' : 'rgba(80,200,120,0.3)';
                ctx.lineWidth = 1;
                roundRect(ctx, cx, cy, 240, 120, 10);
                ctx.fill();
                ctx.stroke();
                ctx.restore();

                ctx.font = 'bold 14px Segoe UI, sans-serif';
                ctx.textAlign = 'left';

                if (isStrategic) {
                    ctx.fillStyle = '#ff6b6b';
                    ctx.fillText('Strategic Manipulation Succeeded!', cx + 14, cy + 24);
                    ctx.font = '13px Segoe UI, sans-serif';
                    ctx.fillStyle = '#ccc';
                    ctx.fillText('Honest winner: ' + sc.honestWinner, cx + 14, cy + 50);
                    ctx.fillStyle = '#ff6b6b';
                    ctx.fillText('Manipulated winner: ' + sc.strategicWinner, cx + 14, cy + 72);
                    ctx.fillStyle = '#aaa';
                    ctx.font = '11px Segoe UI, sans-serif';
                    ctx.fillText('By lying, voters improved', cx + 14, cy + 96);
                    ctx.fillText('their outcome.', cx + 14, cy + 110);
                } else {
                    ctx.fillStyle = '#50c878';
                    ctx.fillText('Honest Voting Result', cx + 14, cy + 24);
                    ctx.font = '13px Segoe UI, sans-serif';
                    ctx.fillStyle = '#ccc';
                    ctx.fillText('Winner: ' + sc.honestWinner, cx + 14, cy + 50);
                    ctx.fillStyle = '#ffa050';
                    ctx.fillText('But this can be manipulated...', cx + 14, cy + 72);
                    ctx.fillStyle = '#aaa';
                    ctx.font = '11px Segoe UI, sans-serif';
                    ctx.fillText('Click "Show Strategic Manipulation"', cx + 14, cy + 96);
                    ctx.fillText('to see how.', cx + 14, cy + 110);
                }
            }

            // Step indicator
            const stepLabels = ['1. View Preferences', '2. Cast Ballots', '3. Count Votes', '4. Analyze Result'];
            ctx.textAlign = 'center';
            for (let i = 0; i <= maxStep; i++) {
                const sx = canvas.width / 2 - 200 + i * 110;
                const sy = canvas.height - 40;
                ctx.fillStyle = i <= step ? '#7eb8da' : '#444';
                ctx.beginPath();
                ctx.arc(sx, sy, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = i <= step ? '#fff' : '#666';
                ctx.font = 'bold 10px Segoe UI, sans-serif';
                ctx.fillText(i + 1, sx, sy + 4);
                ctx.fillStyle = i <= step ? '#aaa' : '#444';
                ctx.font = '10px Segoe UI, sans-serif';
                ctx.fillText(stepLabels[i], sx, sy + 24);
            }

            requestAnimationFrame(animate);
        }

        window.reset = function() {
            currentMethod = 'plurality';
            isStrategic = false;
            step = 0;
            document.querySelectorAll('.method-btn').forEach(b => b.classList.remove('active'));
            document.querySelector('[data-method="plurality"]').classList.add('active');
            updateControls();
        };

        updateControls();
        animate();
    </script>
    <script src="../assets/js/enhance.js"></script>
</body>
</html>
