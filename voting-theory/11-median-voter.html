<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Median Voter Theorem - Voting Theory</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; }
canvas { display: block; }
a.back-link {
    position: fixed; top: 16px; left: 16px; color: #8ab4f8; text-decoration: none;
    font-size: 14px; z-index: 100; opacity: 0.8; transition: opacity 0.2s;
}
a.back-link:hover { opacity: 1; }

.controls {
    position: fixed; top: 16px; right: 16px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 16px; min-width: 240px;
    border: 1px solid rgba(255,255,255,0.08);
}
.controls h3 { font-size: 14px; color: #8ab4f8; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
.controls label { display: block; font-size: 12px; color: #aaa; margin-top: 8px; }
.controls input[type=range] { width: 100%; margin: 4px 0; accent-color: #8ab4f8; }
.controls .value { font-size: 11px; color: #666; text-align: right; }
.btn {
    display: inline-block; margin: 4px 2px; padding: 6px 14px; border: none; border-radius: 6px;
    background: #1a3a5c; color: #8ab4f8; font-size: 12px; cursor: pointer; transition: background 0.2s;
}
.btn:hover { background: #244a6c; }
.btn.active { background: #2e6b3e; color: #8f8; }
.btn-row { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 4px; }

.stats {
    position: fixed; bottom: 16px; left: 16px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px;
    border: 1px solid rgba(255,255,255,0.08); font-size: 13px;
}
.stats .stat-row { display: flex; justify-content: space-between; gap: 20px; margin: 3px 0; }
.stats .stat-label { color: #888; }
.stats .stat-value { color: #8ab4f8; font-family: 'Courier New', monospace; }

.info-panel {
    position: fixed; bottom: 16px; right: 16px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px; max-width: 320px;
    border: 1px solid rgba(255,255,255,0.08); font-size: 12px; line-height: 1.6;
}
.info-panel h4 { color: #8ab4f8; margin-bottom: 6px; }
.info-panel p { color: #aaa; }
</style>
</head>
<body>
<a href="index.html" class="back-link">&#8592; Back to Gallery</a>
<canvas id="canvas"></canvas>

<div class="controls">
    <h3>Median Voter</h3>
    <label>Voters: <span id="voterCountVal">200</span></label>
    <input type="range" id="voterCount" min="50" max="500" value="200" step="10">
    <label>Distribution Spread: <span id="spreadVal">0.20</span></label>
    <input type="range" id="spread" min="5" max="40" value="20">
    <label>Distribution Skew: <span id="skewVal">0.00</span></label>
    <input type="range" id="skew" min="-50" max="50" value="0">
    <label>Convergence Speed: <span id="speedVal">0.50</span></label>
    <input type="range" id="speed" min="1" max="20" value="5">
    <div class="btn-row">
        <button class="btn" id="autoBtn">Auto-Converge</button>
        <button class="btn" id="resetBtn">Reset</button>
    </div>
</div>

<div class="stats">
    <div class="stat-row"><span class="stat-label">Candidate A Votes</span><span class="stat-value" id="votesA">0</span></div>
    <div class="stat-row"><span class="stat-label">Candidate B Votes</span><span class="stat-value" id="votesB">0</span></div>
    <div class="stat-row"><span class="stat-label">Median Position</span><span class="stat-value" id="medianPos">0.50</span></div>
    <div class="stat-row"><span class="stat-label">Winner</span><span class="stat-value" id="winner">-</span></div>
</div>

<div class="info-panel">
    <h4>Median Voter Theorem</h4>
    <p>In a two-candidate election on a single political dimension, both candidates converge to the position of the median voter to maximize votes. Drag candidates to see vote shares change. Enable Auto-Converge to watch them find equilibrium.</p>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// State
let voters = [];
let candidateA = { x: 0.3, color: '#ff6b6b', name: 'A' };
let candidateB = { x: 0.7, color: '#4ecdc4', name: 'B' };
let autoConverge = false;
let dragging = null;

const spectrumY = () => H * 0.55;
const spectrumLeft = () => W * 0.08;
const spectrumRight = () => W * 0.92;
const spectrumWidth = () => spectrumRight() - spectrumLeft();

function posToX(pos) { return spectrumLeft() + pos * spectrumWidth(); }
function xToPos(x) { return Math.max(0, Math.min(1, (x - spectrumLeft()) / spectrumWidth())); }

function generateVoters() {
    const count = parseInt(document.getElementById('voterCount').value);
    const spread = parseInt(document.getElementById('spread').value) / 100;
    const skew = parseInt(document.getElementById('skew').value) / 100;
    voters = [];
    for (let i = 0; i < count; i++) {
        let u1 = Math.random(), u2 = Math.random();
        let z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        let pos = 0.5 + skew * 0.3 + z * spread;
        pos = Math.max(0.01, Math.min(0.99, pos));
        voters.push(pos);
    }
    voters.sort((a, b) => a - b);
}

function getMedian() {
    if (voters.length === 0) return 0.5;
    const mid = Math.floor(voters.length / 2);
    return voters.length % 2 ? voters[mid] : (voters[mid - 1] + voters[mid]) / 2;
}

function countVotes() {
    let a = 0, b = 0;
    for (const v of voters) {
        const da = Math.abs(v - candidateA.x);
        const db = Math.abs(v - candidateB.x);
        if (da < db) a++;
        else if (db < da) b++;
        else { a += 0.5; b += 0.5; }
    }
    return { a, b };
}

generateVoters();

// Controls
document.getElementById('voterCount').addEventListener('input', function() {
    document.getElementById('voterCountVal').textContent = this.value;
    generateVoters();
});
document.getElementById('spread').addEventListener('input', function() {
    document.getElementById('spreadVal').textContent = (this.value / 100).toFixed(2);
    generateVoters();
});
document.getElementById('skew').addEventListener('input', function() {
    document.getElementById('skewVal').textContent = (this.value / 100).toFixed(2);
    generateVoters();
});
document.getElementById('speed').addEventListener('input', function() {
    document.getElementById('speedVal').textContent = (this.value / 10).toFixed(2);
});
document.getElementById('autoBtn').addEventListener('click', function() {
    autoConverge = !autoConverge;
    this.classList.toggle('active', autoConverge);
    this.textContent = autoConverge ? 'Stop' : 'Auto-Converge';
});
document.getElementById('resetBtn').addEventListener('click', function() {
    window.reset();
});

// Dragging
canvas.addEventListener('mousedown', function(e) {
    const mx = e.clientX, my = e.clientY;
    const sy = spectrumY();
    const cAx = posToX(candidateA.x), cBx = posToX(candidateB.x);
    if (Math.abs(mx - cAx) < 20 && Math.abs(my - sy) < 40) dragging = candidateA;
    else if (Math.abs(mx - cBx) < 20 && Math.abs(my - sy) < 40) dragging = candidateB;
});
canvas.addEventListener('mousemove', function(e) {
    if (dragging) {
        dragging.x = xToPos(e.clientX);
    }
});
canvas.addEventListener('mouseup', function() { dragging = null; });

// Touch
canvas.addEventListener('touchstart', function(e) {
    const t = e.touches[0];
    const mx = t.clientX, my = t.clientY;
    const sy = spectrumY();
    const cAx = posToX(candidateA.x), cBx = posToX(candidateB.x);
    if (Math.abs(mx - cAx) < 30 && Math.abs(my - sy) < 50) dragging = candidateA;
    else if (Math.abs(mx - cBx) < 30 && Math.abs(my - sy) < 50) dragging = candidateB;
    if (dragging) e.preventDefault();
}, { passive: false });
canvas.addEventListener('touchmove', function(e) {
    if (dragging) {
        dragging.x = xToPos(e.touches[0].clientX);
        e.preventDefault();
    }
}, { passive: false });
canvas.addEventListener('touchend', function() { dragging = null; });

function drawHistogram() {
    const bins = 50;
    const counts = new Array(bins).fill(0);
    for (const v of voters) {
        const bin = Math.min(bins - 1, Math.floor(v * bins));
        counts[bin]++;
    }
    const maxCount = Math.max(...counts, 1);
    const barW = spectrumWidth() / bins;
    const maxH = H * 0.25;
    const baseY = spectrumY() - 30;

    const midpoint = (candidateA.x + candidateB.x) / 2;

    for (let i = 0; i < bins; i++) {
        const binCenter = (i + 0.5) / bins;
        const h = (counts[i] / maxCount) * maxH;
        const x = spectrumLeft() + i * barW;

        let color;
        if (binCenter < midpoint) {
            color = candidateA.x < candidateB.x ? candidateA.color : candidateB.color;
        } else {
            color = candidateA.x < candidateB.x ? candidateB.color : candidateA.color;
        }

        ctx.fillStyle = color + '55';
        ctx.fillRect(x, baseY - h, barW - 1, h);
        ctx.fillStyle = color + '99';
        ctx.fillRect(x, baseY - h, barW - 1, 2);
    }
}

function drawSpectrum() {
    const sy = spectrumY();
    const sl = spectrumLeft();
    const sr = spectrumRight();

    // Spectrum line
    const grad = ctx.createLinearGradient(sl, 0, sr, 0);
    grad.addColorStop(0, '#3366cc');
    grad.addColorStop(0.5, '#888');
    grad.addColorStop(1, '#cc3333');
    ctx.strokeStyle = grad;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(sl, sy);
    ctx.lineTo(sr, sy);
    ctx.stroke();

    // Labels
    ctx.fillStyle = '#3366cc';
    ctx.font = '13px Segoe UI, system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Left', sl, sy + 30);
    ctx.fillStyle = '#cc3333';
    ctx.fillText('Right', sr, sy + 30);
    ctx.fillStyle = '#888';
    ctx.fillText('Center', (sl + sr) / 2, sy + 30);

    // Tick marks
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 10; i++) {
        const x = sl + (i / 10) * spectrumWidth();
        ctx.beginPath();
        ctx.moveTo(x, sy - 8);
        ctx.lineTo(x, sy + 8);
        ctx.stroke();
    }
}

function drawCandidate(cand, label) {
    const sy = spectrumY();
    const cx = posToX(cand.x);

    // Marker triangle
    ctx.fillStyle = cand.color;
    ctx.beginPath();
    ctx.moveTo(cx, sy - 15);
    ctx.lineTo(cx - 12, sy - 35);
    ctx.lineTo(cx + 12, sy - 35);
    ctx.closePath();
    ctx.fill();

    // Circle
    ctx.beginPath();
    ctx.arc(cx, sy - 45, 16, 0, Math.PI * 2);
    ctx.fillStyle = cand.color;
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 16px Segoe UI, system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, cx, sy - 45);

    // Position label
    ctx.fillStyle = cand.color;
    ctx.font = '11px Courier New, monospace';
    ctx.textBaseline = 'top';
    ctx.fillText(cand.x.toFixed(2), cx, sy + 40);

    // Glow when dragging
    if (dragging === cand) {
        ctx.beginPath();
        ctx.arc(cx, sy - 45, 22, 0, Math.PI * 2);
        ctx.strokeStyle = cand.color + '88';
        ctx.lineWidth = 2;
        ctx.stroke();
    }
}

function drawMedian() {
    const sy = spectrumY();
    const median = getMedian();
    const mx = posToX(median);

    ctx.setLineDash([5, 5]);
    ctx.strokeStyle = '#f8d868';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(mx, sy - spectrumY() * 0.4);
    ctx.lineTo(mx, sy + 15);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = '#f8d868';
    ctx.font = 'bold 12px Segoe UI, system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText('MEDIAN', mx, sy + 55);
    ctx.font = '11px Courier New, monospace';
    ctx.fillText(median.toFixed(3), mx, sy + 72);
}

function drawVoteShare() {
    const votes = countVotes();
    const total = voters.length;
    const shareA = total > 0 ? votes.a / total : 0.5;
    const shareB = total > 0 ? votes.b / total : 0.5;

    const barY = H * 0.82;
    const barH = 20;
    const sl = spectrumLeft();
    const sw = spectrumWidth();

    // Bar background
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(sl, barY, sw, barH);

    // A share
    ctx.fillStyle = candidateA.color + 'cc';
    ctx.fillRect(sl, barY, sw * shareA, barH);

    // B share
    ctx.fillStyle = candidateB.color + 'cc';
    ctx.fillRect(sl + sw * shareA, barY, sw * shareB, barH);

    // Labels on bar
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 12px Segoe UI, system-ui';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    if (shareA > 0.1) ctx.fillText(`A: ${(shareA * 100).toFixed(1)}%`, sl + 8, barY + barH / 2);
    ctx.textAlign = 'right';
    if (shareB > 0.1) ctx.fillText(`B: ${(shareB * 100).toFixed(1)}%`, sl + sw - 8, barY + barH / 2);

    // Update stats
    document.getElementById('votesA').textContent = Math.round(votes.a);
    document.getElementById('votesB').textContent = Math.round(votes.b);
    document.getElementById('medianPos').textContent = getMedian().toFixed(3);
    const winner = votes.a > votes.b ? 'A' : votes.b > votes.a ? 'B' : 'Tie';
    document.getElementById('winner').textContent = winner;
    document.getElementById('winner').style.color = winner === 'A' ? candidateA.color : winner === 'B' ? candidateB.color : '#f8d868';
}

function animate() {
    ctx.clearRect(0, 0, W, H);

    // Title
    ctx.fillStyle = '#8ab4f8';
    ctx.font = 'bold 20px Segoe UI, system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText('Median Voter Theorem', W / 2, 20);
    ctx.fillStyle = '#666';
    ctx.font = '13px Segoe UI, system-ui';
    ctx.fillText('Drag candidates along the spectrum. Both converge to the median in equilibrium.', W / 2, 48);

    drawHistogram();
    drawSpectrum();
    drawMedian();
    drawCandidate(candidateA, 'A');
    drawCandidate(candidateB, 'B');
    drawVoteShare();

    // Auto-converge logic
    if (autoConverge && !dragging) {
        const speed = parseInt(document.getElementById('speed').value) / 10000;
        const median = getMedian();
        // Each candidate moves toward the median
        candidateA.x += (median - candidateA.x) * speed * 2;
        candidateB.x += (median - candidateB.x) * speed * 2;
    }

    requestAnimationFrame(animate);
}

window.reset = function() {
    candidateA.x = 0.3;
    candidateB.x = 0.7;
    autoConverge = false;
    document.getElementById('autoBtn').classList.remove('active');
    document.getElementById('autoBtn').textContent = 'Auto-Converge';
    document.getElementById('voterCount').value = 200;
    document.getElementById('voterCountVal').textContent = '200';
    document.getElementById('spread').value = 20;
    document.getElementById('spreadVal').textContent = '0.20';
    document.getElementById('skew').value = 0;
    document.getElementById('skewVal').textContent = '0.00';
    document.getElementById('speed').value = 5;
    document.getElementById('speedVal').textContent = '0.50';
    generateVoters();
};

animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
