<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Yee Diagrams - Voting Theory</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; color: #e0e0e0; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; }
canvas { display: block; }
a.back-link {
    position: fixed; top: 16px; left: 16px; color: #8ab4f8; text-decoration: none;
    font-size: 14px; z-index: 100; opacity: 0.8; transition: opacity 0.2s;
}
a.back-link:hover { opacity: 1; }

.controls {
    position: fixed; top: 16px; right: 16px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 16px; min-width: 220px;
    border: 1px solid rgba(255,255,255,0.08);
}
.controls h3 { font-size: 14px; color: #8ab4f8; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
.controls label { display: block; font-size: 12px; color: #aaa; margin-top: 8px; }
.controls select {
    width: 100%; margin: 4px 0; padding: 5px 8px; border-radius: 6px;
    background: #1a1a2e; color: #e0e0e0; border: 1px solid rgba(255,255,255,0.1);
    font-size: 12px;
}
.controls input[type=range] { width: 100%; margin: 4px 0; accent-color: #8ab4f8; }
.controls .value { font-size: 11px; color: #666; text-align: right; }
.btn {
    display: inline-block; margin: 4px 2px; padding: 6px 14px; border: none; border-radius: 6px;
    background: #1a3a5c; color: #8ab4f8; font-size: 12px; cursor: pointer; transition: background 0.2s;
}
.btn:hover { background: #244a6c; }
.btn.active { background: #2e6b3e; color: #8f8; }
.btn-row { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 4px; }

.legend {
    position: fixed; bottom: 16px; left: 16px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px;
    border: 1px solid rgba(255,255,255,0.08); font-size: 13px;
}
.legend-item { display: flex; align-items: center; gap: 8px; margin: 4px 0; }
.legend-swatch { width: 16px; height: 16px; border-radius: 4px; }

.info-panel {
    position: fixed; bottom: 16px; right: 16px; z-index: 100;
    background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
    border-radius: 12px; padding: 14px 18px; max-width: 300px;
    border: 1px solid rgba(255,255,255,0.08); font-size: 12px; line-height: 1.6;
}
.info-panel h4 { color: #8ab4f8; margin-bottom: 6px; }
.info-panel p { color: #aaa; }

.progress-bar {
    margin-top: 8px; height: 4px; background: #1a1a2e; border-radius: 2px; overflow: hidden;
}
.progress-fill { height: 100%; background: #8ab4f8; transition: width 0.1s; }
</style>
</head>
<body>
<a href="index.html" class="back-link">&#8592; Back to Gallery</a>
<canvas id="canvas"></canvas>

<div class="controls">
    <h3>Yee Diagram</h3>
    <label>Voting Method</label>
    <select id="method">
        <option value="plurality">Plurality</option>
        <option value="irv">Instant Runoff (IRV)</option>
        <option value="borda">Borda Count</option>
        <option value="approval">Approval Voting</option>
        <option value="condorcet">Condorcet</option>
    </select>
    <label>Resolution: <span id="resVal">4</span>px</label>
    <input type="range" id="resolution" min="2" max="10" value="4">
    <label>Voter Spread: <span id="spreadVal">0.15</span></label>
    <input type="range" id="voterSpread" min="5" max="40" value="15">
    <div class="progress-bar"><div class="progress-fill" id="progress" style="width:0%"></div></div>
    <div class="btn-row">
        <button class="btn" id="renderBtn">Render</button>
        <button class="btn" id="resetBtn">Reset</button>
    </div>
    <div style="font-size:10px;color:#555;margin-top:6px">Drag candidates to reposition</div>
</div>

<div class="legend" id="legend"></div>

<div class="info-panel">
    <h4>Yee Diagrams</h4>
    <p>For each pixel, simulate: "If voters were centered here, who wins?" The pixel is colored by the winner. Different voting methods produce dramatically different maps -- some create bizarre non-convex winning regions.</p>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    needsRender = true;
}
resize();
window.addEventListener('resize', resize);

const candidateColors = [
    { r: 255, g: 80, b: 80, hex: '#ff5050' },
    { r: 80, g: 200, b: 200, hex: '#50c8c8' },
    { r: 255, g: 200, b: 60, hex: '#ffc83c' },
    { r: 150, g: 100, b: 255, hex: '#9664ff' }
];

let candidates = [
    { x: 0.3, y: 0.3 },
    { x: 0.7, y: 0.3 },
    { x: 0.3, y: 0.7 },
    { x: 0.7, y: 0.7 }
];

let imageData = null;
let needsRender = true;
let rendering = false;
let renderGen = 0;
let dragging = null;

function buildLegend() {
    const el = document.getElementById('legend');
    el.innerHTML = '<div style="font-size:11px;color:#888;margin-bottom:6px">CANDIDATES</div>';
    candidates.forEach((c, i) => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.innerHTML = `<div class="legend-swatch" style="background:${candidateColors[i].hex}"></div><span>${String.fromCharCode(65 + i)} (${c.x.toFixed(2)}, ${c.y.toFixed(2)})</span>`;
        el.appendChild(item);
    });
}
buildLegend();

// Convert canvas pixel to [0,1] space
function pxToNorm(px, py) {
    const size = Math.min(W, H) * 0.85;
    const ox = (W - size) / 2, oy = (H - size) / 2;
    return { x: (px - ox) / size, y: (py - oy) / size };
}
function normToPx(nx, ny) {
    const size = Math.min(W, H) * 0.85;
    const ox = (W - size) / 2, oy = (H - size) / 2;
    return { x: ox + nx * size, y: oy + ny * size };
}

function dist(ax, ay, bx, by) {
    return Math.sqrt((ax - bx) ** 2 + (ay - by) ** 2);
}

// Generate voters as a gaussian blob centered at (cx, cy)
function genVoters(cx, cy, spread, n) {
    const vs = [];
    for (let i = 0; i < n; i++) {
        const u1 = Math.random(), u2 = Math.random();
        const z1 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        const z2 = Math.sqrt(-2 * Math.log(u1)) * Math.sin(2 * Math.PI * u2);
        vs.push({ x: cx + z1 * spread, y: cy + z2 * spread });
    }
    return vs;
}

// Voting methods
function plurality(voters, cands) {
    const counts = new Array(cands.length).fill(0);
    for (const v of voters) {
        let best = 0, bestD = Infinity;
        for (let i = 0; i < cands.length; i++) {
            const d = dist(v.x, v.y, cands[i].x, cands[i].y);
            if (d < bestD) { bestD = d; best = i; }
        }
        counts[best]++;
    }
    let winner = 0;
    for (let i = 1; i < counts.length; i++) if (counts[i] > counts[winner]) winner = i;
    return winner;
}

function rankByDistance(voter, cands) {
    const ranked = cands.map((c, i) => ({ i, d: dist(voter.x, voter.y, c.x, c.y) }));
    ranked.sort((a, b) => a.d - b.d);
    return ranked.map(r => r.i);
}

function irv(voters, cands) {
    const n = cands.length;
    const eliminated = new Set();
    const ballots = voters.map(v => rankByDistance(v, cands));

    while (eliminated.size < n - 1) {
        const counts = new Array(n).fill(0);
        for (const ballot of ballots) {
            for (const c of ballot) {
                if (!eliminated.has(c)) { counts[c]++; break; }
            }
        }
        // Check majority
        const total = voters.length;
        for (let i = 0; i < n; i++) {
            if (!eliminated.has(i) && counts[i] > total / 2) return i;
        }
        // Eliminate lowest
        let minC = -1, minV = Infinity;
        for (let i = 0; i < n; i++) {
            if (!eliminated.has(i) && counts[i] < minV) { minV = counts[i]; minC = i; }
        }
        if (minC === -1) break;
        eliminated.add(minC);
    }
    for (let i = 0; i < n; i++) if (!eliminated.has(i)) return i;
    return 0;
}

function borda(voters, cands) {
    const n = cands.length;
    const scores = new Array(n).fill(0);
    for (const v of voters) {
        const ranking = rankByDistance(v, cands);
        for (let r = 0; r < ranking.length; r++) {
            scores[ranking[r]] += (n - 1 - r);
        }
    }
    let winner = 0;
    for (let i = 1; i < n; i++) if (scores[i] > scores[winner]) winner = i;
    return winner;
}

function approval(voters, cands) {
    // Approve candidates within median distance
    const counts = new Array(cands.length).fill(0);
    for (const v of voters) {
        const dists = cands.map((c, i) => ({ i, d: dist(v.x, v.y, c.x, c.y) }));
        dists.sort((a, b) => a.d - b.d);
        // Approve top half
        const approveCount = Math.max(1, Math.ceil(cands.length / 2));
        for (let k = 0; k < approveCount; k++) counts[dists[k].i]++;
    }
    let winner = 0;
    for (let i = 1; i < counts.length; i++) if (counts[i] > counts[winner]) winner = i;
    return winner;
}

function condorcet(voters, cands) {
    const n = cands.length;
    const pairwise = Array.from({ length: n }, () => new Array(n).fill(0));
    for (const v of voters) {
        for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
                const di = dist(v.x, v.y, cands[i].x, cands[i].y);
                const dj = dist(v.x, v.y, cands[j].x, cands[j].y);
                if (di < dj) pairwise[i][j]++;
                else pairwise[j][i]++;
            }
        }
    }
    // Condorcet winner
    for (let i = 0; i < n; i++) {
        let wins = true;
        for (let j = 0; j < n; j++) {
            if (i !== j && pairwise[i][j] <= pairwise[j][i]) { wins = false; break; }
        }
        if (wins) return i;
    }
    // Fallback: minimax
    let best = 0, bestWorst = -Infinity;
    for (let i = 0; i < n; i++) {
        let worst = Infinity;
        for (let j = 0; j < n; j++) {
            if (i !== j) worst = Math.min(worst, pairwise[i][j] - pairwise[j][i]);
        }
        if (worst > bestWorst) { bestWorst = worst; best = i; }
    }
    return best;
}

const methods = { plurality, irv, borda, approval, condorcet };

async function renderYee() {
    const gen = ++renderGen;
    rendering = true;
    const method = document.getElementById('method').value;
    const res = parseInt(document.getElementById('resolution').value);
    const spread = parseInt(document.getElementById('voterSpread').value) / 100;
    const voteFn = methods[method];
    const numVoters = 80;

    const size = Math.min(W, H) * 0.85;
    const ox = (W - size) / 2, oy = (H - size) / 2;

    // Clear
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    imageData = ctx.createImageData(W, H);
    const data = imageData.data;

    // Fill background
    for (let i = 0; i < data.length; i += 4) {
        data[i] = 10; data[i+1] = 14; data[i+2] = 26; data[i+3] = 255;
    }

    const totalRows = Math.ceil(size / res);
    let rowsDone = 0;

    // Use seeded random for consistency
    let seed = 42;
    function seededRandom() {
        seed = (seed * 16807 + 0) % 2147483647;
        return (seed - 1) / 2147483646;
    }

    for (let py = oy; py < oy + size; py += res) {
        if (gen !== renderGen) return;
        for (let px = ox; px < ox + size; px += res) {
            const nx = (px - ox) / size;
            const ny = (py - oy) / size;

            // Generate voters centered at this pixel
            seed = 42; // Reset seed for each pixel for consistency
            const voters = [];
            for (let i = 0; i < numVoters; i++) {
                const u1 = seededRandom(), u2 = seededRandom();
                const z1 = Math.sqrt(-2 * Math.log(u1 + 0.0001)) * Math.cos(2 * Math.PI * u2);
                const z2 = Math.sqrt(-2 * Math.log(u1 + 0.0001)) * Math.sin(2 * Math.PI * u2);
                voters.push({ x: nx + z1 * spread, y: ny + z2 * spread });
            }

            const winner = voteFn(voters, candidates);
            const col = candidateColors[winner];

            for (let dy = 0; dy < res && py + dy < H; dy++) {
                for (let dx = 0; dx < res && px + dx < H; dx++) {
                    const idx = ((py + dy) * W + (px + dx)) * 4;
                    data[idx] = col.r;
                    data[idx + 1] = col.g;
                    data[idx + 2] = col.b;
                    data[idx + 3] = 200;
                }
            }
        }
        rowsDone++;
        if (rowsDone % 4 === 0) {
            document.getElementById('progress').style.width = ((rowsDone / totalRows) * 100) + '%';
            ctx.putImageData(imageData, 0, 0);
            drawCandidateMarkers();
            await new Promise(r => setTimeout(r, 0));
        }
    }

    ctx.putImageData(imageData, 0, 0);
    drawCandidateMarkers();
    document.getElementById('progress').style.width = '100%';
    rendering = false;
}

function drawCandidateMarkers() {
    candidates.forEach((c, i) => {
        const p = normToPx(c.x, c.y);
        ctx.beginPath();
        ctx.arc(p.x, p.y, 12, 0, Math.PI * 2);
        ctx.fillStyle = candidateColors[i].hex;
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Segoe UI, system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(String.fromCharCode(65 + i), p.x, p.y);
    });

    // Border around diagram
    const size = Math.min(W, H) * 0.85;
    const ox = (W - size) / 2, oy = (H - size) / 2;
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.strokeRect(ox, oy, size, size);
}

// Dragging candidates
canvas.addEventListener('mousedown', function(e) {
    const norm = pxToNorm(e.clientX, e.clientY);
    for (let i = 0; i < candidates.length; i++) {
        if (dist(norm.x, norm.y, candidates[i].x, candidates[i].y) < 0.04) {
            dragging = i;
            return;
        }
    }
});
canvas.addEventListener('mousemove', function(e) {
    if (dragging !== null) {
        const norm = pxToNorm(e.clientX, e.clientY);
        candidates[dragging].x = Math.max(0.02, Math.min(0.98, norm.x));
        candidates[dragging].y = Math.max(0.02, Math.min(0.98, norm.y));
        buildLegend();
    }
});
canvas.addEventListener('mouseup', function() {
    if (dragging !== null) {
        dragging = null;
        renderYee();
    }
});

// Touch support
canvas.addEventListener('touchstart', function(e) {
    const t = e.touches[0];
    const norm = pxToNorm(t.clientX, t.clientY);
    for (let i = 0; i < candidates.length; i++) {
        if (dist(norm.x, norm.y, candidates[i].x, candidates[i].y) < 0.06) {
            dragging = i;
            e.preventDefault();
            return;
        }
    }
}, { passive: false });
canvas.addEventListener('touchmove', function(e) {
    if (dragging !== null) {
        const t = e.touches[0];
        const norm = pxToNorm(t.clientX, t.clientY);
        candidates[dragging].x = Math.max(0.02, Math.min(0.98, norm.x));
        candidates[dragging].y = Math.max(0.02, Math.min(0.98, norm.y));
        buildLegend();
        e.preventDefault();
    }
}, { passive: false });
canvas.addEventListener('touchend', function() {
    if (dragging !== null) { dragging = null; renderYee(); }
});

document.getElementById('method').addEventListener('change', () => renderYee());
document.getElementById('resolution').addEventListener('input', function() {
    document.getElementById('resVal').textContent = this.value;
});
document.getElementById('voterSpread').addEventListener('input', function() {
    document.getElementById('spreadVal').textContent = (this.value / 100).toFixed(2);
});
document.getElementById('renderBtn').addEventListener('click', () => renderYee());
document.getElementById('resetBtn').addEventListener('click', () => window.reset());

window.reset = function() {
    candidates = [
        { x: 0.3, y: 0.3 },
        { x: 0.7, y: 0.3 },
        { x: 0.3, y: 0.7 },
        { x: 0.7, y: 0.7 }
    ];
    document.getElementById('method').value = 'plurality';
    document.getElementById('resolution').value = 4;
    document.getElementById('resVal').textContent = '4';
    document.getElementById('voterSpread').value = 15;
    document.getElementById('spreadVal').textContent = '0.15';
    buildLegend();
    renderYee();
};

// Redraw markers during drag via rAF
function animateLoop() {
    if (dragging !== null && imageData) {
        ctx.putImageData(imageData, 0, 0);
        drawCandidateMarkers();
    }
    requestAnimationFrame(animateLoop);
}
animateLoop();

// Initial render
renderYee();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
