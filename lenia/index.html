<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lenia - Continuous Cellular Automata - CCAB</title>
    <meta name="description" content="Interactive WebGL simulation of Lenia, a continuous cellular automaton that produces complex artificial lifeforms. Over 400 species discovered including the famous Orbium.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        canvas {
            display: block;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.7);
            color: #ff9f43;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 159, 67, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(255, 159, 67, 0.2);
            transform: translateX(-4px);
        }

        #info {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: #ff9f43;
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 159, 67, 0.2);
            z-index: 1000;
            max-width: 200px;
        }

        #info h3 {
            margin-bottom: 8px;
            font-weight: 600;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 95vw;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 18px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 159, 67, 0.2);
        }

        .control-group label {
            color: #ff9f43;
            font-size: 12px;
            display: block;
            margin-bottom: 6px;
        }

        .control-group input[type="range"] {
            width: 100px;
            accent-color: #ff9f43;
        }

        .control-group span {
            color: #fff;
            font-size: 11px;
            margin-left: 8px;
        }

        button {
            background: rgba(255, 159, 67, 0.2);
            border: 1px solid rgba(255, 159, 67, 0.5);
            color: #ff9f43;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(255, 159, 67, 0.4);
        }

        #species-buttons {
            position: fixed;
            top: 80px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }

        #species-buttons button {
            font-size: 11px;
            padding: 8px 12px;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff9f43;
            font-size: 18px;
            z-index: 2000;
            text-align: center;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 159, 67, 0.2);
            border-top-color: #ff9f43;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #error {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(200, 50, 50, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 3000;
            max-width: 80vw;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">← Back to Gallery</a>

    <div id="loading">
        <div class="spinner"></div>
        <p>Initializing Lenia...</p>
    </div>

    <div id="error">
        <h2>WebGL2 Required</h2>
        <p id="error-msg">This simulation requires WebGL2 support.</p>
    </div>

    <div id="info">
        <h3>Lenia</h3>
        <div>Species: <span id="species-name">Orbium</span></div>
        <div>FPS: <span id="fps">0</span></div>
        <div style="margin-top:8px;font-size:10px;opacity:0.7">
            Click to add lifeforms<br>
            Drag to draw patterns
        </div>
    </div>

    <div id="species-buttons">
        <button onclick="loadSpecies('orbium')">Orbium</button>
        <button onclick="loadSpecies('geminium')">Geminium</button>
        <button onclick="loadSpecies('hydrogeminium')">Hydrogeminium</button>
        <button onclick="loadSpecies('scutium')">Scutium</button>
        <button onclick="loadSpecies('random')">Random</button>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>Kernel Radius (R)</label>
            <input type="range" id="radius" min="5" max="30" value="13">
            <span id="radiusVal">13</span>
        </div>
        <div class="control-group">
            <label>Growth Center (μ)</label>
            <input type="range" id="mu" min="0.1" max="0.5" step="0.01" value="0.15">
            <span id="muVal">0.15</span>
        </div>
        <div class="control-group">
            <label>Growth Width (σ)</label>
            <input type="range" id="sigma" min="0.01" max="0.1" step="0.005" value="0.017">
            <span id="sigmaVal">0.017</span>
        </div>
        <div class="control-group">
            <label>Time Step (dt)</label>
            <input type="range" id="dt" min="0.05" max="0.5" step="0.01" value="0.1">
            <span id="dtVal">0.1</span>
        </div>
        <button onclick="resetSimulation()">Clear</button>
        <button onclick="addRandomLifeform()">Add Life</button>
    </div>

    <canvas id="canvas"></canvas>

    <script>
    // Lenia - Continuous Cellular Automata
    // Based on Bert Wang-Chak Chan's research (2018)
    // https://chakazul.github.io/lenia.html

    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2');

    if (!gl) {
        document.getElementById('loading').style.display = 'none';
        document.getElementById('error').style.display = 'block';
        throw new Error('WebGL2 not supported');
    }

    // Check for float texture support
    const ext = gl.getExtension('EXT_color_buffer_float');
    gl.getExtension('OES_texture_float_linear');

    // Configuration - Orbium (the classic Lenia lifeform)
    let config = {
        R: 13,          // Kernel radius
        T: 10,          // Time resolution (1/dt)
        dt: 0.1,        // Time step
        mu: 0.15,       // Growth center
        sigma: 0.017,   // Growth width
        beta: [1],      // Kernel ring weights (single ring for basic)
        kernelCore: 4   // Kernel core type: 4 = polynomial bump
    };

    // Known species parameters
    const species = {
        orbium: { R: 13, mu: 0.15, sigma: 0.017, dt: 0.1, name: 'Orbium' },
        geminium: { R: 10, mu: 0.14, sigma: 0.014, dt: 0.1, name: 'Geminium' },
        hydrogeminium: { R: 13, mu: 0.15, sigma: 0.015, dt: 0.1, name: 'Hydrogeminium' },
        scutium: { R: 12, mu: 0.16, sigma: 0.02, dt: 0.1, name: 'Scutium' }
    };

    function loadSpecies(name) {
        if (name === 'random') {
            config.R = 8 + Math.floor(Math.random() * 15);
            config.mu = 0.1 + Math.random() * 0.2;
            config.sigma = 0.01 + Math.random() * 0.04;
            config.dt = 0.05 + Math.random() * 0.15;
            document.getElementById('species-name').textContent = 'Random';
        } else {
            const s = species[name];
            config.R = s.R;
            config.mu = s.mu;
            config.sigma = s.sigma;
            config.dt = s.dt;
            document.getElementById('species-name').textContent = s.name;
        }
        updateControlsUI();
        createKernelTexture();
    }

    function updateControlsUI() {
        document.getElementById('radius').value = config.R;
        document.getElementById('radiusVal').textContent = config.R;
        document.getElementById('mu').value = config.mu;
        document.getElementById('muVal').textContent = config.mu.toFixed(2);
        document.getElementById('sigma').value = config.sigma;
        document.getElementById('sigmaVal').textContent = config.sigma.toFixed(3);
        document.getElementById('dt').value = config.dt;
        document.getElementById('dtVal').textContent = config.dt.toFixed(2);
    }

    // Shader sources
    const quadVertexShader = `#version 300 es
        in vec2 a_position;
        out vec2 v_uv;
        void main() {
            v_uv = a_position * 0.5 + 0.5;
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    `;

    // Convolution shader - computes U = K * A using FFT-like sliding window
    const convolutionShader = `#version 300 es
        precision highp float;

        uniform sampler2D u_state;
        uniform sampler2D u_kernel;
        uniform vec2 u_resolution;
        uniform float u_kernelRadius;

        in vec2 v_uv;
        out vec4 outColor;

        void main() {
            float sum = 0.0;
            float kernelSum = 0.0;
            int R = int(u_kernelRadius);

            // Convolve with kernel
            for (int dy = -R; dy <= R; dy++) {
                for (int dx = -R; dx <= R; dx++) {
                    vec2 offset = vec2(float(dx), float(dy)) / u_resolution;
                    vec2 sampleUV = fract(v_uv + offset);

                    // Get kernel weight at this position
                    float dist = length(vec2(dx, dy)) / u_kernelRadius;
                    if (dist <= 1.0) {
                        vec2 kernelUV = vec2(dist, 0.5);
                        float weight = texture(u_kernel, kernelUV).r;
                        float state = texture(u_state, sampleUV).r;
                        sum += state * weight;
                        kernelSum += weight;
                    }
                }
            }

            // Normalize
            float U = kernelSum > 0.0 ? sum / kernelSum : 0.0;
            outColor = vec4(U, 0.0, 0.0, 1.0);
        }
    `;

    // Growth shader - applies growth function G(U) and updates state
    const growthShader = `#version 300 es
        precision highp float;

        uniform sampler2D u_state;
        uniform sampler2D u_potential;
        uniform float u_mu;
        uniform float u_sigma;
        uniform float u_dt;

        in vec2 v_uv;
        out vec4 outColor;

        // Growth function: Gaussian bell curve centered at mu with width sigma
        float growth(float U) {
            return 2.0 * exp(-pow((U - u_mu) / u_sigma, 2.0) / 2.0) - 1.0;
        }

        void main() {
            float A = texture(u_state, v_uv).r;
            float U = texture(u_potential, v_uv).r;

            // Apply growth and time step
            float G = growth(U);
            float newA = A + u_dt * G;

            // Clamp to [0, 1]
            newA = clamp(newA, 0.0, 1.0);

            outColor = vec4(newA, newA, newA, 1.0);
        }
    `;

    // Display shader with colorful rendering
    const displayShader = `#version 300 es
        precision highp float;

        uniform sampler2D u_state;
        in vec2 v_uv;
        out vec4 outColor;

        vec3 colormap(float t) {
            // Warm orange-yellow-white colormap
            vec3 c0 = vec3(0.05, 0.02, 0.08);  // Dark purple background
            vec3 c1 = vec3(0.8, 0.3, 0.1);     // Orange
            vec3 c2 = vec3(1.0, 0.7, 0.2);     // Yellow
            vec3 c3 = vec3(1.0, 1.0, 0.9);     // White

            if (t < 0.33) {
                return mix(c0, c1, t * 3.0);
            } else if (t < 0.66) {
                return mix(c1, c2, (t - 0.33) * 3.0);
            } else {
                return mix(c2, c3, (t - 0.66) * 3.0);
            }
        }

        void main() {
            float state = texture(u_state, v_uv).r;
            vec3 color = colormap(state);
            outColor = vec4(color, 1.0);
        }
    `;

    // Brush shader for drawing
    const brushShader = `#version 300 es
        precision highp float;

        uniform sampler2D u_state;
        uniform vec2 u_resolution;
        uniform vec2 u_brushPos;
        uniform float u_brushRadius;
        uniform float u_brushValue;

        in vec2 v_uv;
        out vec4 outColor;

        void main() {
            float state = texture(u_state, v_uv).r;

            vec2 pos = v_uv * u_resolution;
            float dist = length(pos - u_brushPos);

            if (dist < u_brushRadius) {
                // Gaussian brush
                float falloff = exp(-dist * dist / (u_brushRadius * u_brushRadius * 0.5));
                state = max(state, u_brushValue * falloff);
            }

            outColor = vec4(state, state, state, 1.0);
        }
    `;

    // Compile shader helper
    function compileShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader error:', gl.getShaderInfoLog(shader));
            throw new Error('Shader compilation failed');
        }
        return shader;
    }

    function createProgram(vs, fs) {
        const program = gl.createProgram();
        gl.attachShader(program, compileShader(gl.VERTEX_SHADER, vs));
        gl.attachShader(program, compileShader(gl.FRAGMENT_SHADER, fs));
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program error:', gl.getProgramInfoLog(program));
            throw new Error('Program linking failed');
        }
        return program;
    }

    let width, height;
    let stateTextures = [];
    let stateFramebuffers = [];
    let potentialTexture, potentialFramebuffer;
    let kernelTexture;
    let currentState = 0;

    let convProgram, growthProgram, displayProgram, brushProgram;
    let quadBuffer;

    function resize() {
        const dpr = Math.min(window.devicePixelRatio, 1.5);
        width = Math.floor(window.innerWidth * dpr / 2) * 2;
        height = Math.floor(window.innerHeight * dpr / 2) * 2;

        // Limit size for performance
        const maxSize = 800;
        if (width > maxSize) {
            height = Math.floor(height * maxSize / width);
            width = maxSize;
        }
        if (height > maxSize) {
            width = Math.floor(width * maxSize / height);
            height = maxSize;
        }

        canvas.width = width;
        canvas.height = height;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
    }

    function createStateTextures() {
        for (let i = 0; i < 2; i++) {
            if (stateTextures[i]) gl.deleteTexture(stateTextures[i]);
            if (stateFramebuffers[i]) gl.deleteFramebuffer(stateFramebuffers[i]);

            stateTextures[i] = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, stateTextures[i]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, width, height, 0, gl.RGBA, gl.FLOAT, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

            stateFramebuffers[i] = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, stateFramebuffers[i]);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, stateTextures[i], 0);
        }

        // Potential field texture
        if (potentialTexture) gl.deleteTexture(potentialTexture);
        if (potentialFramebuffer) gl.deleteFramebuffer(potentialFramebuffer);

        potentialTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, potentialTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, width, height, 0, gl.RGBA, gl.FLOAT, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

        potentialFramebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, potentialFramebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, potentialTexture, 0);

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    function createKernelTexture() {
        // Generate 1D kernel lookup texture
        // K(r) = bell(r, 0.5, 0.15) for basic Lenia
        const kernelSize = 256;
        const kernelData = new Float32Array(kernelSize * 4);

        for (let i = 0; i < kernelSize; i++) {
            const r = i / kernelSize;  // r in [0, 1]

            // Polynomial bump kernel: (4r(1-r))^4
            // Peaks at r = 0.5
            let k = 4.0 * r * (1.0 - r);
            k = Math.pow(k, 4);

            kernelData[i * 4] = k;
            kernelData[i * 4 + 1] = k;
            kernelData[i * 4 + 2] = k;
            kernelData[i * 4 + 3] = 1.0;
        }

        if (kernelTexture) gl.deleteTexture(kernelTexture);
        kernelTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, kernelTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, kernelSize, 1, 0, gl.RGBA, gl.FLOAT, kernelData);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }

    function init() {
        resize();

        // Create shader programs
        convProgram = createProgram(quadVertexShader, convolutionShader);
        growthProgram = createProgram(quadVertexShader, growthShader);
        displayProgram = createProgram(quadVertexShader, displayShader);
        brushProgram = createProgram(quadVertexShader, brushShader);

        // Create quad buffer
        quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

        createStateTextures();
        createKernelTexture();

        // Initialize with random noise
        seedWithOrbium();

        setupControls();
        document.getElementById('loading').style.display = 'none';
    }

    function seedWithOrbium() {
        // Create an Orbium-like pattern
        const cx = width / 2;
        const cy = height / 2;
        const data = new Float32Array(width * height * 4);

        const orbiumRadius = config.R * 1.5;

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const dx = x - cx;
                const dy = y - cy;
                const dist = Math.sqrt(dx * dx + dy * dy);

                let val = 0;
                if (dist < orbiumRadius) {
                    // Bell-shaped initial condition
                    const r = dist / orbiumRadius;
                    val = Math.exp(-r * r * 4) * 0.8;
                    // Add some asymmetry for movement
                    val *= (1.0 + 0.3 * Math.cos(Math.atan2(dy, dx) * 2));
                }

                const idx = (y * width + x) * 4;
                data[idx] = val;
                data[idx + 1] = val;
                data[idx + 2] = val;
                data[idx + 3] = 1.0;
            }
        }

        gl.bindTexture(gl.TEXTURE_2D, stateTextures[currentState]);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGBA, gl.FLOAT, data);
    }

    function resetSimulation() {
        // Clear to zero
        const data = new Float32Array(width * height * 4);
        gl.bindTexture(gl.TEXTURE_2D, stateTextures[currentState]);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGBA, gl.FLOAT, data);
    }

    function addRandomLifeform() {
        const x = Math.random() * width;
        const y = Math.random() * height;
        addLifeformAt(x, y);
    }

    function addLifeformAt(x, y) {
        // Use brush shader to add a blob
        gl.bindFramebuffer(gl.FRAMEBUFFER, stateFramebuffers[1 - currentState]);
        gl.viewport(0, 0, width, height);

        gl.useProgram(brushProgram);
        gl.uniform1i(gl.getUniformLocation(brushProgram, 'u_state'), 0);
        gl.uniform2f(gl.getUniformLocation(brushProgram, 'u_resolution'), width, height);
        gl.uniform2f(gl.getUniformLocation(brushProgram, 'u_brushPos'), x, y);
        gl.uniform1f(gl.getUniformLocation(brushProgram, 'u_brushRadius'), config.R * 1.2);
        gl.uniform1f(gl.getUniformLocation(brushProgram, 'u_brushValue'), 0.8);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, stateTextures[currentState]);

        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        const loc = gl.getAttribLocation(brushProgram, 'a_position');
        gl.enableVertexAttribArray(loc);
        gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        currentState = 1 - currentState;
    }

    function setupControls() {
        const controls = {
            'radius': (v) => { config.R = parseInt(v); createKernelTexture(); },
            'mu': (v) => { config.mu = parseFloat(v); },
            'sigma': (v) => { config.sigma = parseFloat(v); },
            'dt': (v) => { config.dt = parseFloat(v); }
        };

        for (const [id, handler] of Object.entries(controls)) {
            const input = document.getElementById(id);
            const valSpan = document.getElementById(id + 'Val');
            input.addEventListener('input', () => {
                const val = input.value;
                handler(val);
                if (id === 'radius') valSpan.textContent = val;
                else if (id === 'sigma') valSpan.textContent = parseFloat(val).toFixed(3);
                else valSpan.textContent = parseFloat(val).toFixed(2);
            });
        }
    }

    // Mouse interaction
    let isDrawing = false;
    canvas.addEventListener('mousedown', (e) => {
        isDrawing = true;
        handleMouse(e);
    });
    canvas.addEventListener('mouseup', () => isDrawing = false);
    canvas.addEventListener('mouseleave', () => isDrawing = false);
    canvas.addEventListener('mousemove', (e) => {
        if (isDrawing) handleMouse(e);
    });

    function handleMouse(e) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width * width;
        const y = (1 - (e.clientY - rect.top) / rect.height) * height;
        addLifeformAt(x, y);
    }

    // Animation loop
    let frameCount = 0;
    let fpsTime = 0;

    function render(time) {
        // FPS counter
        frameCount++;
        if (time - fpsTime > 1000) {
            document.getElementById('fps').textContent = frameCount;
            frameCount = 0;
            fpsTime = time;
        }

        // Step 1: Convolution - compute potential field U = K * A
        gl.bindFramebuffer(gl.FRAMEBUFFER, potentialFramebuffer);
        gl.viewport(0, 0, width, height);

        gl.useProgram(convProgram);
        gl.uniform1i(gl.getUniformLocation(convProgram, 'u_state'), 0);
        gl.uniform1i(gl.getUniformLocation(convProgram, 'u_kernel'), 1);
        gl.uniform2f(gl.getUniformLocation(convProgram, 'u_resolution'), width, height);
        gl.uniform1f(gl.getUniformLocation(convProgram, 'u_kernelRadius'), config.R);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, stateTextures[currentState]);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, kernelTexture);

        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        const convLoc = gl.getAttribLocation(convProgram, 'a_position');
        gl.enableVertexAttribArray(convLoc);
        gl.vertexAttribPointer(convLoc, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        // Step 2: Growth - apply G(U) and update state
        const nextState = 1 - currentState;
        gl.bindFramebuffer(gl.FRAMEBUFFER, stateFramebuffers[nextState]);

        gl.useProgram(growthProgram);
        gl.uniform1i(gl.getUniformLocation(growthProgram, 'u_state'), 0);
        gl.uniform1i(gl.getUniformLocation(growthProgram, 'u_potential'), 1);
        gl.uniform1f(gl.getUniformLocation(growthProgram, 'u_mu'), config.mu);
        gl.uniform1f(gl.getUniformLocation(growthProgram, 'u_sigma'), config.sigma);
        gl.uniform1f(gl.getUniformLocation(growthProgram, 'u_dt'), config.dt);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, stateTextures[currentState]);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, potentialTexture);

        const growthLoc = gl.getAttribLocation(growthProgram, 'a_position');
        gl.enableVertexAttribArray(growthLoc);
        gl.vertexAttribPointer(growthLoc, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        currentState = nextState;

        // Step 3: Display
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, width, height);

        gl.useProgram(displayProgram);
        gl.uniform1i(gl.getUniformLocation(displayProgram, 'u_state'), 0);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, stateTextures[currentState]);

        const dispLoc = gl.getAttribLocation(displayProgram, 'a_position');
        gl.enableVertexAttribArray(dispLoc);
        gl.vertexAttribPointer(dispLoc, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        requestAnimationFrame(render);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
        resize();
        createStateTextures();
        createKernelTexture();
        seedWithOrbium();
    });

    // Expose for enhance.js
    window.reset = resetSimulation;

    // Start
    try {
        init();
        requestAnimationFrame(render);
    } catch (e) {
        document.getElementById('loading').style.display = 'none';
        document.getElementById('error').style.display = 'block';
        document.getElementById('error-msg').textContent = e.message;
        console.error(e);
    }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
