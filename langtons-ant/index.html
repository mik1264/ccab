<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Langton's Ant - CCAB</title>
    <link rel="stylesheet" href="../assets/css/navigation.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Spectral:ital,wght@0,400;0,600;1,400&family=Space+Mono:wght@400;700&display=swap');

        :root {
            /* Color scheme matching main index */
            --bg-primary: #0a0e1a;
            --bg-secondary: #111827;
            --text-primary: #e0e0ff;
            --text-secondary: #a0a0c0;
            --text-accent: #fbbf24;
            --theme-color: #667eea;

            /* Spacing */
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;
            --spacing-2xl: 4rem;

            /* Typography */
            --font-display: 'Orbitron', sans-serif;
            --font-heading: 'Spectral', serif;
            --font-mono: 'Space Mono', monospace;
            --font-body: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

            /* Layout */
            --max-width: 1600px;
            --header-height: 64px;

            /* Transitions */
            --transition-base: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: linear-gradient(135deg, var(--bg-primary) 0%, #0f172a 50%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            padding: 20px;
            padding-top: calc(var(--header-height) + 20px);
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            font-family: var(--font-display);
            text-align: center;
            margin-bottom: 10px;
            font-size: clamp(2rem, 5vw, 3rem);
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 50%, var(--theme-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            padding: 12px 24px;
            background: rgba(224, 224, 255, 0.1);
            border: 2px solid rgba(224, 224, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
            color: var(--text-primary);
        }

        .tab:hover {
            background: rgba(224, 224, 255, 0.2);
            transform: translateY(-2px);
        }

        .tab.active {
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border-color: var(--theme-color);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .view {
            display: none;
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .view.active {
            display: block;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        input[type="range"] {
            width: 200px;
        }

        input[type="text"],
        input[type="number"] {
            width: 120px;
            padding: 8px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 1em;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
        }

        canvas {
            display: block;
            margin: 20px auto;
            background: #000;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 100%;
            cursor: crosshair;
        }

        .stats-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: var(--theme-color);
            font-family: var(--font-mono);
        }

        .stat-label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid var(--theme-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .info-box h3 {
            margin-bottom: 10px;
            color: var(--theme-color);
        }

        .info-box ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 15px 0;
        }

        .preset-btn {
            padding: 8px 16px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }

        .preset-btn:hover {
            background: rgba(224, 224, 255, 0.2);
        }

        .preset-btn.featured {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            border-color: #ff6b6b;
        }

        .ant-config {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }

        .ant-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .ant-card {
            background: rgba(224, 224, 255, 0.05);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            position: relative;
        }

        .ant-card h4 {
            color: var(--theme-color);
            margin-bottom: 10px;
        }

        .color-picker-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        input[type="color"] {
            width: 50px;
            height: 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .remove-ant {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            font-size: 0.8em;
            background: rgba(255, 107, 107, 0.3);
            border: 1px solid #ff6b6b;
        }

        .heatmap-legend {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin: 20px 0;
        }

        .legend-gradient {
            width: 300px;
            height: 30px;
            background: linear-gradient(to right,
                #000000, #0000ff, #00ffff, #00ff00, #ffff00, #ff0000, #ffffff);
            border-radius: 5px;
            border: 1px solid rgba(224, 224, 255, 0.3);
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.8);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }

            .tabs {
                font-size: 0.9em;
            }

            .tab {
                padding: 8px 16px;
            }

            input[type="range"] {
                width: 150px;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation Header -->
    <nav class="ccab-nav">
        <div class="nav-container">
            <a href="../index.html" class="nav-home">
                <span class="nav-logo">CCAB</span>
                <span class="nav-tagline">Claude Code and Algorithmic Beauty</span>
            </a>
            <div class="nav-breadcrumb"></div>
        </div>
    </nav>

    <div class="container">
        <h1>Langton's Ant</h1>
        <p class="subtitle">Simple Rules, Emergent Complexity, and the Highway to Infinity</p>

        <div class="tabs">
            <div class="tab active" data-view="classic">Classic RL</div>
            <div class="tab" data-view="multi-rule">Multi-Rule</div>
            <div class="tab" data-view="multi-ant">Multi-Ant</div>
            <div class="tab" data-view="heatmap">Heat Map</div>
        </div>

        <!-- Classic RL View -->
        <div class="view active" id="classic">
            <div class="info-box">
                <h3>About Langton's Ant</h3>
                <p>Discovered by Christopher Langton in 1986, this simple cellular automaton demonstrates how complexity emerges from simple rules:</p>
                <ul>
                    <li><strong>Rule:</strong> At a white cell, turn 90째 right (R), flip color, move forward. At a black cell, turn 90째 left (L), flip color, move forward.</li>
                    <li><strong>Initial Chaos:</strong> The ant creates seemingly random patterns for the first ~10,000 steps</li>
                    <li><strong>Highway Emergence:</strong> After chaos, the ant builds a repeating "highway" that extends forever</li>
                    <li><strong>Turing Complete:</strong> Can be used to perform universal computation</li>
                    <li><strong>No Proven Limit:</strong> It's unproven whether the ant always builds a highway from any starting condition</li>
                </ul>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="speedClassic">Speed: <span id="speedClassicVal">20</span>ms</label>
                    <input type="range" id="speedClassic" min="1" max="100" value="20">
                </div>
                <div class="control-group">
                    <label for="cellSizeClassic">Cell Size: <span id="cellSizeClassicVal">4</span>px</label>
                    <input type="range" id="cellSizeClassic" min="2" max="10" value="4">
                </div>
                <button id="playPauseClassic">Play</button>
                <button class="secondary" onclick="stepClassic()">Step</button>
                <button class="secondary" onclick="resetClassic()">Reset</button>
                <button class="secondary" onclick="skipToHighway()">Skip to Highway (~10k steps)</button>
            </div>

            <canvas id="canvasClassic"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="stepsClassic">0</div>
                        <div class="stat-label">Steps</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="cellsFlippedClassic">0</div>
                        <div class="stat-label">Cells Flipped</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="gridSizeClassic">0</div>
                        <div class="stat-label">Grid Size</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="cellsVisitedClassic">0%</div>
                        <div class="stat-label">Cells Visited</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Multi-Rule View -->
        <div class="view" id="multi-rule">
            <div class="info-box">
                <h3>Multi-Color Rules</h3>
                <p>Extend Langton's Ant to multiple colors and rules. Each letter in the rule string represents a turn direction:</p>
                <ul>
                    <li><strong>L</strong> = Turn 90째 left</li>
                    <li><strong>R</strong> = Turn 90째 right</li>
                    <li><strong>Rule Length:</strong> Determines number of colors (RLR = 3 colors, LLRR = 4 colors)</li>
                    <li><strong>Famous Rules:</strong> RLR creates symmetric patterns, LLRR makes triangular structures, RLLR builds highways</li>
                </ul>
            </div>

            <div class="preset-buttons">
                <button class="preset-btn featured" onclick="setRule('RL')">RL (Classic)</button>
                <button class="preset-btn featured" onclick="setRule('RLR')">RLR (Symmetric)</button>
                <button class="preset-btn featured" onclick="setRule('LLRR')">LLRR (Triangular)</button>
                <button class="preset-btn featured" onclick="setRule('RLLR')">RLLR (Highway)</button>
                <button class="preset-btn" onclick="setRule('LRRRRRLLR')">LRRRRRLLR (Spiral)</button>
                <button class="preset-btn" onclick="setRule('LLRRRLRLRLLR')">LLRRRLRLRLLR (Chaotic)</button>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="ruleString">Custom Rule:</label>
                    <input type="text" id="ruleString" value="RLR" placeholder="L/R pattern">
                </div>
                <button onclick="applyCustomRule()">Apply Rule</button>
                <div class="control-group">
                    <label for="speedMulti">Speed: <span id="speedMultiVal">20</span>ms</label>
                    <input type="range" id="speedMulti" min="1" max="100" value="20">
                </div>
                <button id="playPauseMulti">Play</button>
                <button class="secondary" onclick="stepMultiRule()">Step</button>
                <button class="secondary" onclick="resetMultiRule()">Reset</button>
            </div>

            <canvas id="canvasMultiRule"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="stepsMulti">0</div>
                        <div class="stat-label">Steps</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="currentRuleMulti">RLR</div>
                        <div class="stat-label">Current Rule</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="colorsMulti">3</div>
                        <div class="stat-label">Colors</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="cellsVisitedMulti">0%</div>
                        <div class="stat-label">Cells Visited</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Multi-Ant View -->
        <div class="view" id="multi-ant">
            <div class="info-box">
                <h3>Multiple Ants Simultaneously</h3>
                <p>Watch multiple ants with different rules and colors interact on the same grid. Each ant follows its own rule, but they all affect the same cells, creating emergent interference patterns.</p>
            </div>

            <div class="ant-config">
                <h4 style="color: var(--theme-color); margin-bottom: 15px;">Ant Configuration</h4>
                <button onclick="addAnt()">Add Ant</button>
                <button class="secondary" onclick="removeAllAnts()">Remove All</button>
                <button class="secondary" onclick="randomizeAnts()">Randomize Positions</button>

                <div class="ant-list" id="antList"></div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="speedMultiAnt">Speed: <span id="speedMultiAntVal">30</span>ms</label>
                    <input type="range" id="speedMultiAnt" min="1" max="100" value="30">
                </div>
                <button id="playPauseMultiAnt">Play</button>
                <button class="secondary" onclick="stepMultiAnt()">Step</button>
                <button class="secondary" onclick="resetMultiAnt()">Reset</button>
            </div>

            <canvas id="canvasMultiAnt"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="stepsMultiAnt">0</div>
                        <div class="stat-label">Steps</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="antCountMultiAnt">2</div>
                        <div class="stat-label">Active Ants</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="collisionsMultiAnt">0</div>
                        <div class="stat-label">Collisions</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="cellsVisitedMultiAnt">0%</div>
                        <div class="stat-label">Cells Visited</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Heat Map View -->
        <div class="view" id="heatmap">
            <div class="info-box">
                <h3>Cell Visit Frequency Heat Map</h3>
                <p>Visualize how many times each cell has been visited. Colors represent visit frequency:</p>
                <ul>
                    <li><strong>Black:</strong> Never visited</li>
                    <li><strong>Blue/Cyan:</strong> Rarely visited (1-10 times)</li>
                    <li><strong>Green/Yellow:</strong> Moderately visited (11-50 times)</li>
                    <li><strong>Red/White:</strong> Heavily visited (50+ times)</li>
                </ul>
            </div>

            <div class="heatmap-legend">
                <span>Low Visits</span>
                <div class="legend-gradient"></div>
                <span>High Visits</span>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="speedHeat">Speed: <span id="speedHeatVal">10</span>ms</label>
                    <input type="range" id="speedHeat" min="1" max="100" value="10">
                </div>
                <div class="control-group">
                    <label for="heatRule">Rule:</label>
                    <input type="text" id="heatRule" value="RL" placeholder="L/R pattern">
                </div>
                <button onclick="applyHeatRule()">Apply Rule</button>
                <button id="playPauseHeat">Play</button>
                <button class="secondary" onclick="stepHeatmap()">Step</button>
                <button class="secondary" onclick="resetHeatmap()">Reset</button>
            </div>

            <canvas id="canvasHeatmap"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="stepsHeat">0</div>
                        <div class="stat-label">Steps</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="maxVisitsHeat">0</div>
                        <div class="stat-label">Max Visits</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="avgVisitsHeat">0.0</div>
                        <div class="stat-label">Avg Visits</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="cellsVisitedHeat">0%</div>
                        <div class="stat-label">Cells Visited</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== CORE ANT ENGINE ====================
        class LangtonsAnt {
            constructor(rule = 'RL', gridWidth = 200, gridHeight = 200) {
                this.rule = rule;
                this.gridWidth = gridWidth;
                this.gridHeight = gridHeight;
                this.grid = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(0));
                this.x = Math.floor(gridWidth / 2);
                this.y = Math.floor(gridHeight / 2);
                this.direction = 0; // 0=N, 1=E, 2=S, 3=W
                this.steps = 0;
                this.cellsFlipped = 0;
                this.visitedCells = new Set();
                this.visitedCells.add(`${this.x},${this.y}`);
            }

            step() {
                const currentColor = this.grid[this.y][this.x];
                const turn = this.rule[currentColor];

                // Turn based on rule
                if (turn === 'R') {
                    this.direction = (this.direction + 1) % 4;
                } else if (turn === 'L') {
                    this.direction = (this.direction + 3) % 4;
                }

                // Flip cell color (cycle through colors)
                this.grid[this.y][this.x] = (currentColor + 1) % this.rule.length;
                this.cellsFlipped++;

                // Move forward
                switch(this.direction) {
                    case 0: this.y--; break; // North
                    case 1: this.x++; break; // East
                    case 2: this.y++; break; // South
                    case 3: this.x--; break; // West
                }

                // Wrap around edges
                this.x = (this.x + this.gridWidth) % this.gridWidth;
                this.y = (this.y + this.gridHeight) % this.gridHeight;

                this.visitedCells.add(`${this.x},${this.y}`);
                this.steps++;
            }

            reset() {
                this.grid = Array(this.gridHeight).fill(null).map(() => Array(this.gridWidth).fill(0));
                this.x = Math.floor(this.gridWidth / 2);
                this.y = Math.floor(this.gridHeight / 2);
                this.direction = 0;
                this.steps = 0;
                this.cellsFlipped = 0;
                this.visitedCells = new Set();
                this.visitedCells.add(`${this.x},${this.y}`);
            }

            getCellsVisitedPercent() {
                return ((this.visitedCells.size / (this.gridWidth * this.gridHeight)) * 100).toFixed(2);
            }
        }

        class HeatMapAnt extends LangtonsAnt {
            constructor(rule = 'RL', gridWidth = 200, gridHeight = 200) {
                super(rule, gridWidth, gridHeight);
                this.heatMap = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(0));
                this.heatMap[this.y][this.x] = 1;
            }

            step() {
                super.step();
                this.heatMap[this.y][this.x]++;
            }

            reset() {
                super.reset();
                this.heatMap = Array(this.gridHeight).fill(null).map(() => Array(this.gridWidth).fill(0));
                this.heatMap[this.y][this.x] = 1;
            }

            getMaxVisits() {
                return Math.max(...this.heatMap.flat());
            }

            getAvgVisits() {
                const total = this.heatMap.flat().reduce((a, b) => a + b, 0);
                return (total / this.visitedCells.size).toFixed(1);
            }
        }

        // Multi-Ant System
        class MultiAntSystem {
            constructor(gridWidth = 200, gridHeight = 200) {
                this.gridWidth = gridWidth;
                this.gridHeight = gridHeight;
                this.grid = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(0));
                this.ants = [];
                this.steps = 0;
                this.collisions = 0;
                this.visitedCells = new Set();
            }

            addAnt(rule, color, x = null, y = null) {
                const ant = {
                    rule: rule,
                    color: color,
                    x: x !== null ? x : Math.floor(Math.random() * this.gridWidth),
                    y: y !== null ? y : Math.floor(Math.random() * this.gridHeight),
                    direction: Math.floor(Math.random() * 4)
                };
                this.ants.push(ant);
                this.visitedCells.add(`${ant.x},${ant.y}`);
            }

            removeAnt(index) {
                this.ants.splice(index, 1);
            }

            step() {
                const positions = new Map();

                this.ants.forEach((ant, idx) => {
                    const currentColor = this.grid[ant.y][ant.x];
                    const turn = ant.rule[currentColor % ant.rule.length];

                    // Turn
                    if (turn === 'R') {
                        ant.direction = (ant.direction + 1) % 4;
                    } else if (turn === 'L') {
                        ant.direction = (ant.direction + 3) % 4;
                    }

                    // Flip cell
                    this.grid[ant.y][ant.x] = (currentColor + 1) % Math.max(...this.ants.map(a => a.rule.length));

                    // Move
                    switch(ant.direction) {
                        case 0: ant.y--; break;
                        case 1: ant.x++; break;
                        case 2: ant.y++; break;
                        case 3: ant.x--; break;
                    }

                    // Wrap
                    ant.x = (ant.x + this.gridWidth) % this.gridWidth;
                    ant.y = (ant.y + this.gridHeight) % this.gridHeight;

                    const posKey = `${ant.x},${ant.y}`;
                    if (positions.has(posKey)) {
                        this.collisions++;
                    }
                    positions.set(posKey, true);
                    this.visitedCells.add(posKey);
                });

                this.steps++;
            }

            reset() {
                this.grid = Array(this.gridHeight).fill(null).map(() => Array(this.gridWidth).fill(0));
                this.ants.forEach(ant => {
                    ant.x = Math.floor(Math.random() * this.gridWidth);
                    ant.y = Math.floor(Math.random() * this.gridHeight);
                    ant.direction = Math.floor(Math.random() * 4);
                });
                this.steps = 0;
                this.collisions = 0;
                this.visitedCells = new Set();
                this.ants.forEach(ant => this.visitedCells.add(`${ant.x},${ant.y}`));
            }

            getCellsVisitedPercent() {
                return ((this.visitedCells.size / (this.gridWidth * this.gridHeight)) * 100).toFixed(2);
            }
        }

        // ==================== RENDERING ====================
        function drawGrid(ctx, grid, cellSize, colors = null, antX = null, antY = null, antDir = null) {
            const width = grid[0].length;
            const height = grid.length;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width * cellSize, height * cellSize);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const value = grid[y][x];
                    if (value > 0) {
                        if (colors) {
                            ctx.fillStyle = colors[value % colors.length];
                        } else {
                            ctx.fillStyle = '#ffffff';
                        }
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }

            // Draw ant
            if (antX !== null && antY !== null) {
                drawAnt(ctx, antX, antY, antDir, cellSize);
            }
        }

        function drawAnt(ctx, x, y, direction, cellSize) {
            const centerX = x * cellSize + cellSize / 2;
            const centerY = y * cellSize + cellSize / 2;
            const size = cellSize * 0.6;

            ctx.fillStyle = '#ff0000';
            ctx.beginPath();

            // Draw triangle pointing in direction
            const angle = (direction - 1) * Math.PI / 2;
            for (let i = 0; i < 3; i++) {
                const a = angle + (i * 2 * Math.PI / 3);
                const px = centerX + Math.cos(a) * size;
                const py = centerY + Math.sin(a) * size;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
        }

        function drawHeatMap(ctx, heatMap, cellSize) {
            const width = heatMap[0].length;
            const height = heatMap.length;
            const maxVisits = Math.max(...heatMap.flat());

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width * cellSize, height * cellSize);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const visits = heatMap[y][x];
                    if (visits > 0) {
                        const normalized = Math.min(1, visits / Math.max(maxVisits, 50));
                        const color = getHeatColor(normalized);
                        ctx.fillStyle = color;
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }
        }

        function getHeatColor(value) {
            // Black -> Blue -> Cyan -> Green -> Yellow -> Red -> White
            if (value < 0.16) {
                const t = value / 0.16;
                return `rgb(0, 0, ${Math.floor(255 * t)})`;
            } else if (value < 0.33) {
                const t = (value - 0.16) / 0.17;
                return `rgb(0, ${Math.floor(255 * t)}, 255)`;
            } else if (value < 0.5) {
                const t = (value - 0.33) / 0.17;
                return `rgb(0, 255, ${Math.floor(255 * (1 - t))})`;
            } else if (value < 0.66) {
                const t = (value - 0.5) / 0.16;
                return `rgb(${Math.floor(255 * t)}, 255, 0)`;
            } else if (value < 0.83) {
                const t = (value - 0.66) / 0.17;
                return `rgb(255, ${Math.floor(255 * (1 - t))}, 0)`;
            } else {
                const t = (value - 0.83) / 0.17;
                return `rgb(255, ${Math.floor(255 * t)}, ${Math.floor(255 * t)})`;
            }
        }

        // ==================== CLASSIC RL VIEW ====================
        let classicAnt;
        let classicCanvas, classicCtx;
        let classicRunning = false;
        let classicInterval;
        const classicCellSize = 4;

        function initClassic() {
            classicCanvas = document.getElementById('canvasClassic');
            classicCtx = classicCanvas.getContext('2d');

            const gridSize = Math.min(200, Math.floor(Math.min(window.innerWidth - 100, 1000) / classicCellSize));
            classicCanvas.width = gridSize * classicCellSize;
            classicCanvas.height = gridSize * classicCellSize;

            classicAnt = new LangtonsAnt('RL', gridSize, gridSize);
            drawGrid(classicCtx, classicAnt.grid, classicCellSize, null, classicAnt.x, classicAnt.y, classicAnt.direction);
            updateClassicStats();
        }

        function stepClassic() {
            classicAnt.step();
            drawGrid(classicCtx, classicAnt.grid, classicCellSize, null, classicAnt.x, classicAnt.y, classicAnt.direction);
            updateClassicStats();
        }

        function resetClassic() {
            classicRunning = false;
            clearInterval(classicInterval);
            document.getElementById('playPauseClassic').textContent = 'Play';
            classicAnt.reset();
            drawGrid(classicCtx, classicAnt.grid, classicCellSize, null, classicAnt.x, classicAnt.y, classicAnt.direction);
            updateClassicStats();
        }

        function skipToHighway() {
            classicRunning = false;
            clearInterval(classicInterval);
            document.getElementById('playPauseClassic').textContent = 'Play';

            for (let i = 0; i < 10000; i++) {
                classicAnt.step();
                if (i % 1000 === 0) {
                    drawGrid(classicCtx, classicAnt.grid, classicCellSize, null, classicAnt.x, classicAnt.y, classicAnt.direction);
                    updateClassicStats();
                }
            }
            drawGrid(classicCtx, classicAnt.grid, classicCellSize, null, classicAnt.x, classicAnt.y, classicAnt.direction);
            updateClassicStats();
        }

        function updateClassicStats() {
            document.getElementById('stepsClassic').textContent = classicAnt.steps.toLocaleString();
            document.getElementById('cellsFlippedClassic').textContent = classicAnt.cellsFlipped.toLocaleString();
            document.getElementById('gridSizeClassic').textContent = `${classicAnt.gridWidth}x${classicAnt.gridHeight}`;
            document.getElementById('cellsVisitedClassic').textContent = classicAnt.getCellsVisitedPercent() + '%';
        }

        document.getElementById('playPauseClassic').addEventListener('click', function() {
            if (classicRunning) {
                classicRunning = false;
                clearInterval(classicInterval);
                this.textContent = 'Play';
            } else {
                classicRunning = true;
                this.textContent = 'Pause';
                const speed = parseInt(document.getElementById('speedClassic').value);
                classicInterval = setInterval(() => {
                    for (let i = 0; i < 10; i++) stepClassic();
                }, speed);
            }
        });

        document.getElementById('speedClassic').addEventListener('input', (e) => {
            document.getElementById('speedClassicVal').textContent = e.target.value;
            if (classicRunning) {
                clearInterval(classicInterval);
                const speed = parseInt(e.target.value);
                classicInterval = setInterval(() => {
                    for (let i = 0; i < 10; i++) stepClassic();
                }, speed);
            }
        });

        document.getElementById('cellSizeClassic').addEventListener('input', (e) => {
            document.getElementById('cellSizeClassicVal').textContent = e.target.value;
        });

        // ==================== MULTI-RULE VIEW ====================
        let multiRuleAnt;
        let multiRuleCanvas, multiRuleCtx;
        let multiRuleRunning = false;
        let multiRuleInterval;
        const multiRuleCellSize = 4;
        let currentMultiRule = 'RLR';

        function initMultiRule() {
            multiRuleCanvas = document.getElementById('canvasMultiRule');
            multiRuleCtx = multiRuleCanvas.getContext('2d');

            const gridSize = Math.min(200, Math.floor(Math.min(window.innerWidth - 100, 1000) / multiRuleCellSize));
            multiRuleCanvas.width = gridSize * multiRuleCellSize;
            multiRuleCanvas.height = gridSize * multiRuleCellSize;

            multiRuleAnt = new LangtonsAnt(currentMultiRule, gridSize, gridSize);
            const colors = generateRuleColors(currentMultiRule.length);
            drawGrid(multiRuleCtx, multiRuleAnt.grid, multiRuleCellSize, colors, multiRuleAnt.x, multiRuleAnt.y, multiRuleAnt.direction);
            updateMultiRuleStats();
        }

        function generateRuleColors(numColors) {
            const colors = ['#000000']; // Black is always 0
            for (let i = 1; i < numColors; i++) {
                const hue = (i * 360 / (numColors - 1)) % 360;
                colors.push(`hsl(${hue}, 70%, 60%)`);
            }
            return colors;
        }

        function setRule(rule) {
            currentMultiRule = rule;
            document.getElementById('ruleString').value = rule;
            multiRuleRunning = false;
            clearInterval(multiRuleInterval);
            document.getElementById('playPauseMulti').textContent = 'Play';

            const gridSize = multiRuleAnt ? multiRuleAnt.gridWidth : 200;
            multiRuleAnt = new LangtonsAnt(rule, gridSize, gridSize);
            const colors = generateRuleColors(rule.length);
            drawGrid(multiRuleCtx, multiRuleAnt.grid, multiRuleCellSize, colors, multiRuleAnt.x, multiRuleAnt.y, multiRuleAnt.direction);
            updateMultiRuleStats();
        }

        function applyCustomRule() {
            const rule = document.getElementById('ruleString').value.toUpperCase().replace(/[^LR]/g, '');
            if (rule.length > 0) {
                setRule(rule);
            }
        }

        function stepMultiRule() {
            multiRuleAnt.step();
            const colors = generateRuleColors(currentMultiRule.length);
            drawGrid(multiRuleCtx, multiRuleAnt.grid, multiRuleCellSize, colors, multiRuleAnt.x, multiRuleAnt.y, multiRuleAnt.direction);
            updateMultiRuleStats();
        }

        function resetMultiRule() {
            multiRuleRunning = false;
            clearInterval(multiRuleInterval);
            document.getElementById('playPauseMulti').textContent = 'Play';
            multiRuleAnt.reset();
            const colors = generateRuleColors(currentMultiRule.length);
            drawGrid(multiRuleCtx, multiRuleAnt.grid, multiRuleCellSize, colors, multiRuleAnt.x, multiRuleAnt.y, multiRuleAnt.direction);
            updateMultiRuleStats();
        }

        function updateMultiRuleStats() {
            document.getElementById('stepsMulti').textContent = multiRuleAnt.steps.toLocaleString();
            document.getElementById('currentRuleMulti').textContent = currentMultiRule;
            document.getElementById('colorsMulti').textContent = currentMultiRule.length;
            document.getElementById('cellsVisitedMulti').textContent = multiRuleAnt.getCellsVisitedPercent() + '%';
        }

        document.getElementById('playPauseMulti').addEventListener('click', function() {
            if (multiRuleRunning) {
                multiRuleRunning = false;
                clearInterval(multiRuleInterval);
                this.textContent = 'Play';
            } else {
                multiRuleRunning = true;
                this.textContent = 'Pause';
                const speed = parseInt(document.getElementById('speedMulti').value);
                multiRuleInterval = setInterval(() => {
                    for (let i = 0; i < 10; i++) stepMultiRule();
                }, speed);
            }
        });

        document.getElementById('speedMulti').addEventListener('input', (e) => {
            document.getElementById('speedMultiVal').textContent = e.target.value;
            if (multiRuleRunning) {
                clearInterval(multiRuleInterval);
                const speed = parseInt(e.target.value);
                multiRuleInterval = setInterval(() => {
                    for (let i = 0; i < 10; i++) stepMultiRule();
                }, speed);
            }
        });

        // ==================== MULTI-ANT VIEW ====================
        let multiAntSystem;
        let multiAntCanvas, multiAntCtx;
        let multiAntRunning = false;
        let multiAntInterval;
        const multiAntCellSize = 4;

        function initMultiAnt() {
            multiAntCanvas = document.getElementById('canvasMultiAnt');
            multiAntCtx = multiAntCanvas.getContext('2d');

            const gridSize = Math.min(200, Math.floor(Math.min(window.innerWidth - 100, 1000) / multiAntCellSize));
            multiAntCanvas.width = gridSize * multiAntCellSize;
            multiAntCanvas.height = gridSize * multiAntCellSize;

            multiAntSystem = new MultiAntSystem(gridSize, gridSize);

            // Add 2 default ants
            multiAntSystem.addAnt('RL', '#ff0000', Math.floor(gridSize * 0.3), Math.floor(gridSize * 0.5));
            multiAntSystem.addAnt('RLR', '#00ff00', Math.floor(gridSize * 0.7), Math.floor(gridSize * 0.5));

            renderMultiAnt();
            updateMultiAntUI();
        }

        function addAnt() {
            const rules = ['RL', 'RLR', 'LLRR', 'RLLR', 'LR', 'RRL'];
            const rule = rules[Math.floor(Math.random() * rules.length)];
            const color = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            multiAntSystem.addAnt(rule, color);
            updateMultiAntUI();
        }

        function removeAllAnts() {
            multiAntSystem.ants = [];
            updateMultiAntUI();
        }

        function randomizeAnts() {
            multiAntSystem.ants.forEach(ant => {
                ant.x = Math.floor(Math.random() * multiAntSystem.gridWidth);
                ant.y = Math.floor(Math.random() * multiAntSystem.gridHeight);
                ant.direction = Math.floor(Math.random() * 4);
            });
            renderMultiAnt();
        }

        function removeAntAt(index) {
            multiAntSystem.removeAnt(index);
            updateMultiAntUI();
        }

        function updateAntRule(index, rule) {
            multiAntSystem.ants[index].rule = rule.toUpperCase().replace(/[^LR]/g, '');
        }

        function updateAntColor(index, color) {
            multiAntSystem.ants[index].color = color;
            renderMultiAnt();
        }

        function updateMultiAntUI() {
            const antList = document.getElementById('antList');
            antList.innerHTML = '';

            multiAntSystem.ants.forEach((ant, idx) => {
                const card = document.createElement('div');
                card.className = 'ant-card';
                card.innerHTML = `
                    <button class="remove-ant" onclick="removeAntAt(${idx})">Remove</button>
                    <h4>Ant ${idx + 1}</h4>
                    <div class="control-group">
                        <label>Rule:</label>
                        <input type="text" value="${ant.rule}" onchange="updateAntRule(${idx}, this.value)">
                    </div>
                    <div class="color-picker-wrapper">
                        <label>Color:</label>
                        <input type="color" value="${ant.color}" onchange="updateAntColor(${idx}, this.value)">
                    </div>
                    <div style="font-size: 0.9em; color: var(--text-secondary); margin-top: 10px;">
                        Position: (${ant.x}, ${ant.y})<br>
                        Direction: ${['N','E','S','W'][ant.direction]}
                    </div>
                `;
                antList.appendChild(card);
            });

            document.getElementById('antCountMultiAnt').textContent = multiAntSystem.ants.length;
            renderMultiAnt();
        }

        function stepMultiAnt() {
            multiAntSystem.step();
            renderMultiAnt();
            updateMultiAntStats();
        }

        function resetMultiAnt() {
            multiAntRunning = false;
            clearInterval(multiAntInterval);
            document.getElementById('playPauseMultiAnt').textContent = 'Play';
            multiAntSystem.reset();
            renderMultiAnt();
            updateMultiAntStats();
            updateMultiAntUI();
        }

        function renderMultiAnt() {
            const colors = generateRuleColors(10);
            drawGrid(multiAntCtx, multiAntSystem.grid, multiAntCellSize, colors);

            // Draw all ants
            multiAntSystem.ants.forEach(ant => {
                const centerX = ant.x * multiAntCellSize + multiAntCellSize / 2;
                const centerY = ant.y * multiAntCellSize + multiAntCellSize / 2;
                const size = multiAntCellSize * 0.6;

                multiAntCtx.fillStyle = ant.color;
                multiAntCtx.beginPath();

                const angle = (ant.direction - 1) * Math.PI / 2;
                for (let i = 0; i < 3; i++) {
                    const a = angle + (i * 2 * Math.PI / 3);
                    const px = centerX + Math.cos(a) * size;
                    const py = centerY + Math.sin(a) * size;
                    if (i === 0) multiAntCtx.moveTo(px, py);
                    else multiAntCtx.lineTo(px, py);
                }
                multiAntCtx.closePath();
                multiAntCtx.fill();
            });
        }

        function updateMultiAntStats() {
            document.getElementById('stepsMultiAnt').textContent = multiAntSystem.steps.toLocaleString();
            document.getElementById('collisionsMultiAnt').textContent = multiAntSystem.collisions.toLocaleString();
            document.getElementById('cellsVisitedMultiAnt').textContent = multiAntSystem.getCellsVisitedPercent() + '%';
        }

        document.getElementById('playPauseMultiAnt').addEventListener('click', function() {
            if (multiAntRunning) {
                multiAntRunning = false;
                clearInterval(multiAntInterval);
                this.textContent = 'Play';
            } else {
                multiAntRunning = true;
                this.textContent = 'Pause';
                const speed = parseInt(document.getElementById('speedMultiAnt').value);
                multiAntInterval = setInterval(() => {
                    for (let i = 0; i < 5; i++) stepMultiAnt();
                }, speed);
            }
        });

        document.getElementById('speedMultiAnt').addEventListener('input', (e) => {
            document.getElementById('speedMultiAntVal').textContent = e.target.value;
            if (multiAntRunning) {
                clearInterval(multiAntInterval);
                const speed = parseInt(e.target.value);
                multiAntInterval = setInterval(() => {
                    for (let i = 0; i < 5; i++) stepMultiAnt();
                }, speed);
            }
        });

        // ==================== HEATMAP VIEW ====================
        let heatmapAnt;
        let heatmapCanvas, heatmapCtx;
        let heatmapRunning = false;
        let heatmapInterval;
        const heatmapCellSize = 4;
        let currentHeatRule = 'RL';

        function initHeatmap() {
            heatmapCanvas = document.getElementById('canvasHeatmap');
            heatmapCtx = heatmapCanvas.getContext('2d');

            const gridSize = Math.min(200, Math.floor(Math.min(window.innerWidth - 100, 1000) / heatmapCellSize));
            heatmapCanvas.width = gridSize * heatmapCellSize;
            heatmapCanvas.height = gridSize * heatmapCellSize;

            heatmapAnt = new HeatMapAnt(currentHeatRule, gridSize, gridSize);
            drawHeatMap(heatmapCtx, heatmapAnt.heatMap, heatmapCellSize);
            drawAnt(heatmapCtx, heatmapAnt.x, heatmapAnt.y, heatmapAnt.direction, heatmapCellSize);
            updateHeatmapStats();
        }

        function applyHeatRule() {
            const rule = document.getElementById('heatRule').value.toUpperCase().replace(/[^LR]/g, '');
            if (rule.length > 0) {
                currentHeatRule = rule;
                heatmapRunning = false;
                clearInterval(heatmapInterval);
                document.getElementById('playPauseHeat').textContent = 'Play';

                const gridSize = heatmapAnt.gridWidth;
                heatmapAnt = new HeatMapAnt(rule, gridSize, gridSize);
                drawHeatMap(heatmapCtx, heatmapAnt.heatMap, heatmapCellSize);
                drawAnt(heatmapCtx, heatmapAnt.x, heatmapAnt.y, heatmapAnt.direction, heatmapCellSize);
                updateHeatmapStats();
            }
        }

        function stepHeatmap() {
            heatmapAnt.step();
            drawHeatMap(heatmapCtx, heatmapAnt.heatMap, heatmapCellSize);
            drawAnt(heatmapCtx, heatmapAnt.x, heatmapAnt.y, heatmapAnt.direction, heatmapCellSize);
            updateHeatmapStats();
        }

        function resetHeatmap() {
            heatmapRunning = false;
            clearInterval(heatmapInterval);
            document.getElementById('playPauseHeat').textContent = 'Play';
            heatmapAnt.reset();
            drawHeatMap(heatmapCtx, heatmapAnt.heatMap, heatmapCellSize);
            drawAnt(heatmapCtx, heatmapAnt.x, heatmapAnt.y, heatmapAnt.direction, heatmapCellSize);
            updateHeatmapStats();
        }

        function updateHeatmapStats() {
            document.getElementById('stepsHeat').textContent = heatmapAnt.steps.toLocaleString();
            document.getElementById('maxVisitsHeat').textContent = heatmapAnt.getMaxVisits().toLocaleString();
            document.getElementById('avgVisitsHeat').textContent = heatmapAnt.getAvgVisits();
            document.getElementById('cellsVisitedHeat').textContent = heatmapAnt.getCellsVisitedPercent() + '%';
        }

        document.getElementById('playPauseHeat').addEventListener('click', function() {
            if (heatmapRunning) {
                heatmapRunning = false;
                clearInterval(heatmapInterval);
                this.textContent = 'Play';
            } else {
                heatmapRunning = true;
                this.textContent = 'Pause';
                const speed = parseInt(document.getElementById('speedHeat').value);
                heatmapInterval = setInterval(() => {
                    for (let i = 0; i < 20; i++) stepHeatmap();
                }, speed);
            }
        });

        document.getElementById('speedHeat').addEventListener('input', (e) => {
            document.getElementById('speedHeatVal').textContent = e.target.value;
            if (heatmapRunning) {
                clearInterval(heatmapInterval);
                const speed = parseInt(e.target.value);
                heatmapInterval = setInterval(() => {
                    for (let i = 0; i < 20; i++) stepHeatmap();
                }, speed);
            }
        });

        // ==================== TAB SYSTEM ====================
        function setupTabs() {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    // Stop all animations
                    classicRunning = false;
                    clearInterval(classicInterval);
                    multiRuleRunning = false;
                    clearInterval(multiRuleInterval);
                    multiAntRunning = false;
                    clearInterval(multiAntInterval);
                    heatmapRunning = false;
                    clearInterval(heatmapInterval);

                    // Reset play buttons
                    document.getElementById('playPauseClassic').textContent = 'Play';
                    document.getElementById('playPauseMulti').textContent = 'Play';
                    document.getElementById('playPauseMultiAnt').textContent = 'Play';
                    document.getElementById('playPauseHeat').textContent = 'Play';

                    // Switch tabs
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.view).classList.add('active');
                });
            });
        }

        // ==================== INITIALIZATION ====================
        window.addEventListener('load', () => {
            setupTabs();
            initClassic();
            initMultiRule();
            initMultiAnt();
            initHeatmap();
        });
    </script>
    <script src="../assets/js/navigation.js"></script>
</body>
</html>
