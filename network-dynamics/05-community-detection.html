<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Community Detection - Network Dynamics</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #canvas {
            display: block;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #64ffda;
            text-decoration: none;
            font-size: 16px;
            font-weight: 600;
            z-index: 1000;
            padding: 10px 20px;
            background: rgba(10, 14, 26, 0.8);
            border-radius: 8px;
            border: 1px solid #64ffda;
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(100, 255, 218, 0.1);
            transform: translateX(-5px);
        }

        .info-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(10, 14, 26, 0.9);
            border: 1px solid #64ffda;
            border-radius: 12px;
            padding: 20px;
            min-width: 280px;
            z-index: 1000;
        }

        .info-panel h2 {
            color: #64ffda;
            font-size: 20px;
            margin-bottom: 15px;
            border-bottom: 2px solid #64ffda;
            padding-bottom: 10px;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 14px;
        }

        .stat-label {
            color: #a0a0a0;
        }

        .stat-value {
            color: #64ffda;
            font-weight: bold;
        }

        .community-list {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
            max-height: 200px;
            overflow-y: auto;
        }

        .community-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 13px;
        }

        .community-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #fff;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 14, 26, 0.9);
            border: 1px solid #64ffda;
            border-radius: 12px;
            padding: 20px;
            z-index: 1000;
        }

        button {
            background: #64ffda;
            color: #0a0e1a;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 10px;
        }

        button:first-child {
            margin-top: 0;
        }

        button:hover {
            background: #52d4ba;
            transform: translateY(-2px);
        }

        .instructions {
            position: fixed;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 14, 26, 0.9);
            border: 1px solid #64ffda;
            border-radius: 8px;
            padding: 15px 25px;
            color: #64ffda;
            text-align: center;
            z-index: 1000;
            max-width: 500px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Network Dynamics</a>

    <div class="info-panel">
        <h2>Community Detection</h2>
        <div class="stat">
            <span class="stat-label">Nodes:</span>
            <span class="stat-value" id="nodeCount">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Edges:</span>
            <span class="stat-value" id="edgeCount">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Communities:</span>
            <span class="stat-value" id="communityCount">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Modularity:</span>
            <span class="stat-value" id="modularity">0</span>
        </div>
        <div class="community-list" id="communityList"></div>
    </div>

    <div class="instructions">
        Click "Detect Communities" to identify clusters using a greedy modularity-based algorithm
    </div>

    <div class="controls">
        <button onclick="detectCommunities()">Detect Communities</button>
        <button onclick="resetSimulation()">Generate New Network</button>
    </div>

    <svg id="canvas"></svg>

    <script>
        const width = window.innerWidth;
        const height = window.innerHeight;

        const svg = d3.select('#canvas')
            .attr('width', width)
            .attr('height', height);

        const numNodes = 60;
        const numCommunities = 4;
        let nodes = [];
        let links = [];
        let simulation;
        let communities = new Map();

        const colors = [
            '#ff6b6b', '#4ecdc4', '#45b7d1', '#ffd93d',
            '#a8e6cf', '#ff8b94', '#95e1d3', '#f38181',
            '#aa96da', '#fcbad3', '#a8d8ea', '#ffaaa5'
        ];

        function createModularNetwork() {
            nodes = [];
            links = [];
            communities.clear();

            const nodesPerCommunity = Math.floor(numNodes / numCommunities);

            // Create nodes and assign to communities
            for (let comm = 0; comm < numCommunities; comm++) {
                const communityNodes = [];
                const start = comm * nodesPerCommunity;
                const end = comm === numCommunities - 1 ? numNodes : start + nodesPerCommunity;

                for (let i = start; i < end; i++) {
                    const angle = (2 * Math.PI * (i - start)) / (end - start);
                    const radius = 200;
                    const cx = width / 2 + (comm % 2 === 0 ? -300 : 300) * Math.cos(comm * Math.PI);
                    const cy = height / 2 + (comm < 2 ? -200 : 200);

                    nodes.push({
                        id: i,
                        community: -1, // Will be detected
                        trueCommunity: comm,
                        x: cx + radius * Math.cos(angle),
                        y: cy + radius * Math.sin(angle)
                    });
                    communityNodes.push(i);
                }

                // Dense connections within community
                for (let i = 0; i < communityNodes.length; i++) {
                    for (let j = i + 1; j < communityNodes.length; j++) {
                        if (Math.random() < 0.3) {
                            links.push({ source: communityNodes[i], target: communityNodes[j] });
                        }
                    }
                }
            }

            // Sparse connections between communities
            for (let i = 0; i < numNodes; i++) {
                for (let j = i + 1; j < numNodes; j++) {
                    if (nodes[i].trueCommunity !== nodes[j].trueCommunity && Math.random() < 0.02) {
                        links.push({ source: i, target: j });
                    }
                }
            }
        }

        function detectCommunities() {
            // Simple greedy modularity-based community detection
            // Initialize each node in its own community
            nodes.forEach((node, i) => {
                node.community = i;
                communities.set(i, [i]);
            });

            let improved = true;
            let iterations = 0;

            while (improved && iterations < 20) {
                improved = false;
                iterations++;

                for (let node of nodes) {
                    const currentCommunity = node.community;
                    let bestCommunity = currentCommunity;
                    let bestModularityGain = 0;

                    // Get neighbor communities
                    const neighborCommunities = new Set();
                    links.forEach(link => {
                        const source = typeof link.source === 'object' ? link.source : nodes[link.source];
                        const target = typeof link.target === 'object' ? link.target : nodes[link.target];

                        if (source.id === node.id) {
                            neighborCommunities.add(target.community);
                        } else if (target.id === node.id) {
                            neighborCommunities.add(source.community);
                        }
                    });

                    // Try moving to each neighbor community
                    for (let comm of neighborCommunities) {
                        if (comm === currentCommunity) continue;

                        const gain = modularityGain(node, comm);
                        if (gain > bestModularityGain) {
                            bestModularityGain = gain;
                            bestCommunity = comm;
                        }
                    }

                    if (bestCommunity !== currentCommunity) {
                        node.community = bestCommunity;
                        improved = true;
                    }
                }
            }

            // Rebuild community map
            communities.clear();
            nodes.forEach(node => {
                if (!communities.has(node.community)) {
                    communities.set(node.community, []);
                }
                communities.get(node.community).push(node.id);
            });

            // Remove empty communities and renumber
            let commId = 0;
            const commMap = new Map();
            for (let [id, members] of communities) {
                if (members.length > 0) {
                    commMap.set(id, commId++);
                }
            }

            nodes.forEach(node => {
                node.community = commMap.get(node.community);
            });

            updateVisualization();
        }

        function modularityGain(node, targetCommunity) {
            // Simplified modularity gain calculation
            let edgesToTarget = 0;
            let edgesFromCurrent = 0;

            links.forEach(link => {
                const source = typeof link.source === 'object' ? link.source : nodes[link.source];
                const target = typeof link.target === 'object' ? link.target : nodes[link.target];

                if (source.id === node.id) {
                    if (target.community === targetCommunity) edgesToTarget++;
                    if (target.community === node.community && target.id !== node.id) edgesFromCurrent++;
                } else if (target.id === node.id) {
                    if (source.community === targetCommunity) edgesToTarget++;
                    if (source.community === node.community && source.id !== node.id) edgesFromCurrent++;
                }
            });

            return edgesToTarget - edgesFromCurrent;
        }

        function calculateModularity() {
            const m = links.length;
            if (m === 0) return 0;

            let Q = 0;
            const degrees = new Map();

            nodes.forEach(node => degrees.set(node.id, 0));
            links.forEach(link => {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                degrees.set(sourceId, degrees.get(sourceId) + 1);
                degrees.set(targetId, degrees.get(targetId) + 1);
            });

            links.forEach(link => {
                const source = typeof link.source === 'object' ? link.source : nodes[link.source];
                const target = typeof link.target === 'object' ? link.target : nodes[link.target];

                if (source.community === target.community) {
                    const ki = degrees.get(source.id);
                    const kj = degrees.get(target.id);
                    Q += 1 - (ki * kj) / (2 * m);
                }
            });

            return Q / (2 * m);
        }

        function initVisualization() {
            svg.selectAll('*').remove();

            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(80))
                .force('charge', d3.forceManyBody().strength(-200))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(15));

            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .join('line')
                .attr('stroke', d => {
                    const source = typeof d.source === 'object' ? d.source : nodes[d.source];
                    const target = typeof d.target === 'object' ? d.target : nodes[d.target];
                    return source.community === target.community ? '#4caf50' : '#666';
                })
                .attr('stroke-width', d => {
                    const source = typeof d.source === 'object' ? d.source : nodes[d.source];
                    const target = typeof d.target === 'object' ? d.target : nodes[d.target];
                    return source.community === target.community ? 2 : 1;
                })
                .attr('opacity', 0.6);

            const node = svg.append('g')
                .selectAll('circle')
                .data(nodes)
                .join('circle')
                .attr('r', 8)
                .attr('fill', d => d.community >= 0 ? colors[d.community % colors.length] : '#888')
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
            });

            updateStats();
        }

        function updateVisualization() {
            svg.selectAll('circle')
                .transition()
                .duration(500)
                .attr('fill', d => d.community >= 0 ? colors[d.community % colors.length] : '#888');

            svg.selectAll('line')
                .transition()
                .duration(500)
                .attr('stroke', d => {
                    const source = typeof d.source === 'object' ? d.source : nodes[d.source];
                    const target = typeof d.target === 'object' ? d.target : nodes[d.target];
                    return source.community === target.community ? '#4caf50' : '#666';
                })
                .attr('stroke-width', d => {
                    const source = typeof d.source === 'object' ? d.source : nodes[d.source];
                    const target = typeof d.target === 'object' ? d.target : nodes[d.target];
                    return source.community === target.community ? 2 : 1;
                });

            updateStats();
        }

        function updateStats() {
            // Count unique communities
            const uniqueCommunities = new Set(nodes.map(n => n.community).filter(c => c >= 0));
            const modularity = calculateModularity();

            document.getElementById('nodeCount').textContent = nodes.length;
            document.getElementById('edgeCount').textContent = links.length;
            document.getElementById('communityCount').textContent = uniqueCommunities.size;
            document.getElementById('modularity').textContent = modularity.toFixed(3);

            // Update community list
            const commCounts = new Map();
            nodes.forEach(node => {
                if (node.community >= 0) {
                    commCounts.set(node.community, (commCounts.get(node.community) || 0) + 1);
                }
            });

            const listHtml = Array.from(commCounts.entries())
                .sort((a, b) => b[1] - a[1])
                .map(([comm, count]) => `
                    <div class="community-item">
                        <div class="community-color" style="background: ${colors[comm % colors.length]}"></div>
                        <span>Community ${comm + 1}: ${count} nodes</span>
                    </div>
                `).join('');

            document.getElementById('communityList').innerHTML = listHtml || '<div style="color: #a0a0a0; font-size: 12px;">No communities detected</div>';
        }

        function resetSimulation() {
            createModularNetwork();
            initVisualization();
        }

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        createModularNetwork();
        initVisualization();
    </script>
</body>
</html>
