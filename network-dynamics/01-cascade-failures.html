<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cascade Failures - Network Dynamics</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        #canvas {
            display: block;
            cursor: pointer;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #64ffda;
            text-decoration: none;
            font-size: 16px;
            font-weight: 600;
            z-index: 1000;
            padding: 10px 20px;
            background: rgba(10, 14, 26, 0.8);
            border-radius: 8px;
            border: 1px solid #64ffda;
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(100, 255, 218, 0.1);
            transform: translateX(-5px);
        }

        .info-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(10, 14, 26, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid #64ffda;
            border-radius: 12px;
            padding: 20px;
            min-width: 250px;
            z-index: 1000;
        }

        .info-panel h2 {
            color: #64ffda;
            font-size: 20px;
            margin-bottom: 15px;
            border-bottom: 2px solid #64ffda;
            padding-bottom: 10px;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 14px;
        }

        .stat-label {
            color: #a0a0a0;
        }

        .stat-value {
            color: #64ffda;
            font-weight: bold;
        }

        .status {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }

        .status-active { color: #4caf50; }
        .status-failed { color: #f44336; }
        .status-overloaded { color: #ff9800; }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 14, 26, 0.9);
            border: 1px solid #64ffda;
            border-radius: 12px;
            padding: 20px;
            z-index: 1000;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        button {
            background: #64ffda;
            color: #0a0e1a;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #52d4ba;
            transform: translateY(-2px);
        }

        .instructions {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 14, 26, 0.9);
            border: 1px solid #64ffda;
            border-radius: 8px;
            padding: 15px 25px;
            color: #64ffda;
            text-align: center;
            z-index: 1000;
        }

        .legend {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 14, 26, 0.9);
            border: 1px solid #64ffda;
            border-radius: 8px;
            padding: 15px 25px;
            z-index: 1000;
            display: flex;
            gap: 20px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .legend-circle {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Network Dynamics</a>

    <div class="info-panel">
        <h2>Cascade Failures</h2>
        <div class="stat">
            <span class="stat-label">Nodes:</span>
            <span class="stat-value" id="nodeCount">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Edges:</span>
            <span class="stat-value" id="edgeCount">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Active:</span>
            <span class="stat-value status-active" id="activeCount">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Failed:</span>
            <span class="stat-value status-failed" id="failedCount">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Overloaded:</span>
            <span class="stat-value status-overloaded" id="overloadedCount">0</span>
        </div>
        <div class="status">
            <div style="font-size: 12px; color: #a0a0a0; margin-bottom: 5px;">Cascade Progress:</div>
            <div style="font-size: 18px; color: #64ffda; font-weight: bold;" id="cascadeProgress">Ready</div>
        </div>
    </div>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-circle" style="background: #4caf50;"></div>
            <span>Active</span>
        </div>
        <div class="legend-item">
            <div class="legend-circle" style="background: #f44336;"></div>
            <span>Failed</span>
        </div>
        <div class="legend-item">
            <div class="legend-circle" style="background: #ff9800;"></div>
            <span>Overloaded</span>
        </div>
    </div>

    <div class="instructions">
        Click any node to trigger a failure and watch the cascade propagate
    </div>

    <div class="controls">
        <button onclick="resetSimulation()">Reset Network</button>
        <button onclick="triggerRandomFailure()">Random Failure</button>
    </div>

    <svg id="canvas"></svg>

    <script>
        const width = window.innerWidth;
        const height = window.innerHeight;

        const svg = d3.select('#canvas')
            .attr('width', width)
            .attr('height', height);

        // Network parameters
        const numNodes = 50;
        const avgDegree = 4;
        let nodes = [];
        let links = [];
        let simulation;

        // Node states
        const STATE = {
            ACTIVE: 'active',
            FAILED: 'failed',
            OVERLOADED: 'overloaded'
        };

        function createNetwork() {
            nodes = [];
            links = [];

            // Create nodes with capacity
            for (let i = 0; i < numNodes; i++) {
                nodes.push({
                    id: i,
                    state: STATE.ACTIVE,
                    capacity: Math.random() * 3 + 2, // Random capacity between 2-5
                    load: 0,
                    x: Math.random() * width,
                    y: Math.random() * height
                });
            }

            // Create scale-free network (some hubs, many small nodes)
            for (let i = 0; i < nodes.length; i++) {
                const numConnections = Math.floor(Math.random() * avgDegree) + 1;
                for (let j = 0; j < numConnections; j++) {
                    const target = Math.floor(Math.random() * nodes.length);
                    if (target !== i && !links.find(l =>
                        (l.source.id === i && l.target.id === target) ||
                        (l.source.id === target && l.target.id === i))) {
                        links.push({ source: i, target: target });
                    }
                }
            }

            // Calculate initial loads (based on betweenness)
            calculateLoads();
        }

        function calculateLoads() {
            // Reset loads
            nodes.forEach(n => n.load = 0);

            // Simple load calculation: load increases with degree
            nodes.forEach(node => {
                const degree = links.filter(l =>
                    l.source.id === node.id || l.target.id === node.id
                ).length;
                node.load = degree * 0.5;
            });
        }

        function initVisualization() {
            svg.selectAll('*').remove();

            // Create force simulation
            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(80))
                .force('charge', d3.forceManyBody().strength(-200))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(15));

            // Draw links
            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .join('line')
                .attr('stroke', '#333')
                .attr('stroke-width', 2)
                .attr('opacity', 0.6);

            // Draw nodes
            const node = svg.append('g')
                .selectAll('circle')
                .data(nodes)
                .join('circle')
                .attr('r', d => 5 + d.capacity * 2)
                .attr('fill', d => getNodeColor(d))
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .on('click', (event, d) => {
                    if (d.state === STATE.ACTIVE) {
                        triggerFailure(d);
                    }
                })
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .attr('fill', d => getNodeColor(d));
            });

            updateStats();
        }

        function getNodeColor(node) {
            switch(node.state) {
                case STATE.FAILED: return '#f44336';
                case STATE.OVERLOADED: return '#ff9800';
                case STATE.ACTIVE:
                    const loadRatio = node.load / node.capacity;
                    if (loadRatio > 0.8) return '#ffc107';
                    return '#4caf50';
                default: return '#4caf50';
            }
        }

        function triggerFailure(node) {
            if (node.state !== STATE.ACTIVE) return;

            node.state = STATE.FAILED;
            document.getElementById('cascadeProgress').textContent = 'Cascading...';

            // Redistribute load from failed node
            const neighbors = getNeighbors(node);
            if (neighbors.length > 0) {
                const redistributedLoad = node.load / neighbors.length;
                neighbors.forEach(n => {
                    if (n.state === STATE.ACTIVE) {
                        n.load += redistributedLoad;
                    }
                });
            }

            // Check for overloads
            setTimeout(() => checkCascade(), 500);
            updateVisualization();
        }

        function checkCascade() {
            let hadFailures = false;

            nodes.forEach(node => {
                if (node.state === STATE.ACTIVE && node.load > node.capacity) {
                    node.state = STATE.OVERLOADED;
                    hadFailures = true;
                }
            });

            updateVisualization();

            if (hadFailures) {
                // Trigger failures for overloaded nodes
                setTimeout(() => {
                    const overloaded = nodes.filter(n => n.state === STATE.OVERLOADED);
                    overloaded.forEach(n => {
                        if (n.state === STATE.OVERLOADED) {
                            triggerFailure(n);
                        }
                    });
                }, 500);
            } else {
                const failedCount = nodes.filter(n => n.state === STATE.FAILED).length;
                if (failedCount === 0) {
                    document.getElementById('cascadeProgress').textContent = 'Ready';
                } else {
                    document.getElementById('cascadeProgress').textContent = 'Complete';
                }
            }
        }

        function getNeighbors(node) {
            const neighbors = [];
            links.forEach(link => {
                if (link.source.id === node.id && link.target.state === STATE.ACTIVE) {
                    neighbors.push(link.target);
                } else if (link.target.id === node.id && link.source.state === STATE.ACTIVE) {
                    neighbors.push(link.source);
                }
            });
            return neighbors;
        }

        function updateVisualization() {
            svg.selectAll('circle')
                .transition()
                .duration(300)
                .attr('fill', d => getNodeColor(d));

            updateStats();
        }

        function updateStats() {
            const active = nodes.filter(n => n.state === STATE.ACTIVE).length;
            const failed = nodes.filter(n => n.state === STATE.FAILED).length;
            const overloaded = nodes.filter(n => n.state === STATE.OVERLOADED).length;

            document.getElementById('nodeCount').textContent = nodes.length;
            document.getElementById('edgeCount').textContent = links.length;
            document.getElementById('activeCount').textContent = active;
            document.getElementById('failedCount').textContent = failed;
            document.getElementById('overloadedCount').textContent = overloaded;
        }

        function resetSimulation() {
            createNetwork();
            initVisualization();
            document.getElementById('cascadeProgress').textContent = 'Ready';
        }

        function triggerRandomFailure() {
            const activeNodes = nodes.filter(n => n.state === STATE.ACTIVE);
            if (activeNodes.length > 0) {
                const randomNode = activeNodes[Math.floor(Math.random() * activeNodes.length)];
                triggerFailure(randomNode);
            }
        }

        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Expose for enhance.js
        window.reset = function() { createNetwork(); initVisualization(); };

        // Initialize
        createNetwork();
        initVisualization();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
