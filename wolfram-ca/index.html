<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wolfram Elementary Cellular Automata - CCAB</title>
    <link rel="stylesheet" href="https://unpkg.com/@sakun/system.css" />
    <link rel="stylesheet" href="../assets/css/navigation.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Chicago&display=swap');

        :root {
            /* Classic Mac colors */
            --mac-bg: #c0c0c0;
            --mac-window-bg: #ffffff;
            --mac-border: #000000;
            --mac-shadow: #808080;
            --mac-highlight: #000000;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: repeating-conic-gradient(#c0c0c0 0% 25%, #a0a0a0 0% 50%) 50% / 20px 20px;
            padding: 20px;
            padding-top: calc(var(--header-height, 64px) + 20px);
            min-height: 100vh;
            font-family: -apple-system, "Chicago", "Geneva", sans-serif;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .desktop-icon {
            text-align: center;
            margin: 0 auto 30px;
            padding: 15px;
            background: white;
            border: 2px solid black;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.3);
            display: inline-block;
        }

        .desktop-icon h1 {
            font-size: 18px;
            font-weight: bold;
            margin-top: 10px;
            font-family: "Chicago", -apple-system, sans-serif;
        }

        .desktop-icon::before {
            content: "üß¨";
            font-size: 48px;
            display: block;
        }

        .window-container {
            margin-bottom: 20px;
        }

        .window {
            background: white;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.3);
            margin-bottom: 20px;
        }

        .title-bar {
            background: linear-gradient(180deg, #ffffff 0%, #c0c0c0 100%);
            border-bottom: 2px solid black;
            padding: 4px 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .title {
            flex: 1;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            font-family: "Chicago", -apple-system, sans-serif;
        }

        .window-pane {
            padding: 15px;
            background: white;
        }

        .separator {
            height: 2px;
            background: #000;
        }

        .menu-bar {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            border: 2px solid black;
            padding: 5px;
            background: white;
        }

        .menu-item {
            padding: 4px 12px;
            background: white;
            border: 2px solid black;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.1s;
        }

        .menu-item:hover {
            background: black;
            color: white;
        }

        .menu-item.active {
            background: black;
            color: white;
        }

        .view-panel {
            display: none;
        }

        .view-panel.active {
            display: block;
        }

        .control-panel {
            background: #f0f0f0;
            border: 2px solid black;
            padding: 15px;
            margin-bottom: 15px;
        }

        .field-row {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .field-row label {
            min-width: 120px;
            font-size: 12px;
            font-weight: bold;
        }

        .btn {
            font-family: "Chicago", -apple-system, sans-serif;
            font-size: 12px;
            padding: 6px 16px;
            cursor: pointer;
        }

        input[type="range"] {
            min-width: 150px;
        }

        input[type="number"] {
            width: 80px;
            padding: 4px;
            font-size: 12px;
        }

        canvas {
            display: block;
            margin: 15px auto;
            border: 2px solid black;
            background: white;
            box-shadow: inset 2px 2px 0 rgba(0,0,0,0.2);
            max-width: 100%;
        }

        .stats-box {
            background: #f0f0f0;
            border: 2px solid black;
            padding: 15px;
            margin: 15px 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 10px;
            background: white;
            border: 2px solid black;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            font-family: "Chicago", -apple-system, sans-serif;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 11px;
            text-transform: uppercase;
        }

        .info-box {
            background: white;
            border: 2px solid black;
            padding: 15px;
            margin: 15px 0;
            box-shadow: inset 2px 2px 0 rgba(0,0,0,0.1);
        }

        .info-box h3 {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            font-family: "Chicago", -apple-system, sans-serif;
        }

        .info-box p {
            font-size: 12px;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .info-box ul {
            margin-left: 20px;
            font-size: 12px;
            line-height: 1.8;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .preset-btn {
            padding: 8px;
            font-size: 11px;
            text-align: center;
        }

        .preset-btn.featured {
            background: black;
            color: white;
            font-weight: bold;
        }

        .rule-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
            max-height: 600px;
            overflow-y: auto;
            padding: 10px;
            background: #f0f0f0;
            border: 2px solid black;
        }

        .rule-card {
            background: white;
            border: 2px solid black;
            padding: 10px;
            cursor: pointer;
            text-align: center;
            transition: all 0.1s;
        }

        .rule-card:hover {
            background: black;
            color: white;
        }

        .rule-card.featured {
            border: 3px solid black;
            background: #f0f0f0;
        }

        .rule-card h3 {
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 8px;
            font-family: "Chicago", -apple-system, sans-serif;
        }

        .rule-card .description {
            font-size: 10px;
            margin-bottom: 8px;
            font-style: italic;
        }

        .rule-card canvas {
            margin: 8px auto 0;
            box-shadow: none;
        }

        .rule-designer {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            padding: 15px;
            background: #f0f0f0;
            border: 2px solid black;
        }

        .bit-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .bit-pattern {
            display: flex;
            gap: 2px;
        }

        .bit {
            width: 20px;
            height: 20px;
            background: white;
            border: 2px solid black;
        }

        .bit.active {
            background: black;
        }

        .output-bit {
            width: 30px;
            height: 30px;
            background: white;
            border: 3px solid black;
            cursor: pointer;
            transition: all 0.1s;
        }

        .output-bit:hover {
            background: #e0e0e0;
        }

        .output-bit.active {
            background: black;
        }

        ::-webkit-scrollbar {
            width: 16px;
        }

        ::-webkit-scrollbar-track {
            background: #f0f0f0;
            border: 2px solid black;
        }

        ::-webkit-scrollbar-thumb {
            background: white;
            border: 2px solid black;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #e0e0e0;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
                padding-top: calc(var(--header-height, 64px) + 10px);
            }

            .menu-item {
                padding: 3px 8px;
                font-size: 11px;
            }

            .field-row {
                flex-direction: column;
                align-items: flex-start;
            }

            .field-row label {
                min-width: auto;
            }
        }

        /* Classic Mac loading indicator */
        .loading {
            text-align: center;
            padding: 20px;
            font-family: "Chicago", -apple-system, sans-serif;
        }

        .loading::before {
            content: "‚åö";
            font-size: 32px;
            display: block;
            margin-bottom: 10px;
        }
    
        /* Organic Nature Back Link */
        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10000;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #BC6C25;
            text-decoration: none;
            font-family: 'Nunito', -apple-system, BlinkMacSystemFont, sans-serif;
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: rgba(254, 250, 224, 0.95);
            border-radius: 20px;
            border: 2px solid rgba(138, 154, 91, 0.3);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(96, 108, 56, 0.15);
        }
        .organic-back-link:hover {
            background: rgba(254, 250, 224, 1);
            transform: translateX(-5px);
            border-color: #DDA15E;
            box-shadow: 0 6px 20px rgba(96, 108, 56, 0.25);
        }

    </style>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>

    <div class="window">
        <div class="title-bar">
            <div class="title-bar-text">Wolfram Elementary Cellular Automata - CCAB</div>
        </div>
        <div class="window-body">
            <p style="margin-bottom: 12px;">Interactive demonstrations - </p>
            <div class="demo-grid">

    <div class="container">
        <!-- Desktop Icon Style Header -->
        <div style="text-align: center;">
            <div class="desktop-icon">
                <h1>Wolfram Elementary<br>Cellular Automata</h1>
            </div>
        </div>

        <!-- Main Application Window -->
        <div class="window">
            <div class="title-bar">
                <button aria-label="Close" class="close"></button>
                <h1 class="title">Wolfram CA Explorer - All 256 Rules</h1>
                <button aria-label="Resize" class="resize"></button>
            </div>
            <div class="separator"></div>
            <div class="window-pane">

                <!-- Menu Bar -->
                <div class="menu-bar">
                    <div class="menu-item active" data-view="evolution">‚è± Evolution</div>
                    <div class="menu-item" data-view="3d">üì¶ 3D View</div>
                    <div class="menu-item" data-view="explorer">üóÇ Explorer</div>
                    <div class="menu-item" data-view="designer">‚úèÔ∏è Designer</div>
                    <div class="menu-item" data-view="patterns">üîç Patterns</div>
                    <div class="menu-item" data-view="entropy">üìä Entropy</div>
                    <div class="menu-item" data-view="fourier">„Ä∞Ô∏è Fourier</div>
                </div>

                <!-- Time Evolution View -->
                <div class="view-panel active" id="evolution">
                    <div class="info-box">
                        <h3>About Elementary Cellular Automata</h3>
                        <p>Stephen Wolfram's systematic exploration of 1D cellular automata revealed that simple rules can generate complexity rivaling anything in nature. Each cell's next state depends on its current state and its two neighbors, creating 2¬≥ = 8 possible configurations. With 2 possible outputs, there are 2‚Å∏ = 256 possible rules.</p>
                    </div>

                    <div class="control-panel">
                        <h3 style="margin-bottom: 12px; font-size: 13px;">Preset Rules</h3>
                        <div class="preset-grid">
                            <button class="btn preset-btn featured" onclick="setRule(30)">Rule 30<br>(Chaotic)</button>
                            <button class="btn preset-btn featured" onclick="setRule(90)">Rule 90<br>(Sierpi≈Ñski)</button>
                            <button class="btn preset-btn featured" onclick="setRule(110)">Rule 110<br>(Turing)</button>
                            <button class="btn preset-btn" onclick="setRule(184)">Rule 184<br>(Traffic)</button>
                            <button class="btn preset-btn" onclick="setRule(150)">Rule 150<br>(Additive)</button>
                            <button class="btn preset-btn" onclick="setRule(73)">Rule 73<br>(Complex)</button>
                            <button class="btn preset-btn" onclick="setRule(45)">Rule 45<br>(Symmetric)</button>
                            <button class="btn preset-btn" onclick="setRule(126)">Rule 126<br>(Chaos/Order)</button>
                        </div>
                    </div>

                    <div class="control-panel">
                        <h3 style="margin-bottom: 12px; font-size: 13px;">Controls</h3>
                        <div class="field-row">
                            <label for="ruleNumber">Rule Number (0-255):</label>
                            <input type="number" id="ruleNumber" min="0" max="255" value="30">
                            <button class="btn" onclick="randomRule()">Random</button>
                        </div>
                        <div class="field-row">
                            <label for="cellSize">Cell Size:</label>
                            <input type="range" id="cellSize" min="1" max="10" value="4">
                            <span id="cellSizeVal">4</span> px
                        </div>
                        <div class="field-row">
                            <label for="speed">Speed:</label>
                            <input type="range" id="speed" min="10" max="200" value="50">
                            <span id="speedVal">50</span> ms
                        </div>
                        <div class="field-row">
                            <button class="btn" onclick="toggleEvolution()">Start</button>
                            <button class="btn" onclick="resetEvolution()">Reset</button>
                            <button class="btn" onclick="stepEvolution()">Step</button>
                        </div>
                    </div>

                    <canvas id="evolutionCanvas"></canvas>

                    <div class="stats-box">
                        <h3 style="margin-bottom: 12px; font-size: 13px;">Statistics</h3>
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div class="stat-value" id="currentRule">30</div>
                                <div class="stat-label">Current Rule</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="generation">0</div>
                                <div class="stat-label">Generation</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="activeCells">1</div>
                                <div class="stat-label">Active Cells</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="density">0%</div>
                                <div class="stat-label">Density</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 3D Visualization View -->
                <div class="view-panel" id="3d">
                    <div class="info-box">
                        <h3>3D Time Evolution</h3>
                        <p>View the cellular automaton evolution in 3D space, where time becomes the vertical axis. Each layer represents a generation, creating a volumetric pattern that reveals long-term structures.</p>
                    </div>

                    <div class="control-panel">
                        <div class="field-row">
                            <label for="rule3d">Rule Number:</label>
                            <input type="number" id="rule3d" min="0" max="255" value="30">
                        </div>
                        <div class="field-row">
                            <label for="rotation">Rotation:</label>
                            <input type="range" id="rotation" min="0" max="360" value="45">
                            <span id="rotationVal">45</span>¬∞
                        </div>
                        <div class="field-row">
                            <label for="elevation">Elevation:</label>
                            <input type="range" id="elevation" min="0" max="90" value="30">
                            <span id="elevationVal">30</span>¬∞
                        </div>
                        <div class="field-row">
                            <button class="btn" onclick="generate3D()">Generate</button>
                            <button class="btn" onclick="toggle3DRotation()">Auto Rotate</button>
                        </div>
                    </div>

                    <canvas id="canvas3d"></canvas>
                </div>

                <!-- Rule Space Explorer View -->
                <div class="view-panel" id="explorer">
                    <div class="info-box">
                        <h3>All 256 Rules at a Glance</h3>
                        <p>Explore the entire space of elementary cellular automata. Featured rules (bold border) include historically significant patterns discovered by Wolfram and others. Click any rule to view it in the Evolution tab.</p>
                    </div>

                    <div class="control-panel">
                        <div class="field-row">
                            <label for="gridSize">Generations:</label>
                            <input type="range" id="gridSize" min="20" max="100" value="50">
                            <span id="gridSizeVal">50</span>
                            <button class="btn" onclick="generateAllRules()">Regenerate All</button>
                        </div>
                    </div>

                    <div class="rule-grid" id="ruleGrid">
                        <div class="loading">Loading all 256 rules...</div>
                    </div>
                </div>

                <!-- Rule Designer View -->
                <div class="view-panel" id="designer">
                    <div class="info-box">
                        <h3>Design Your Own Rule</h3>
                        <p>Create custom rules by defining the output for each of the 8 possible neighborhood configurations. Click the output bits below to toggle them (white = 0, black = 1) and create your own cellular automaton rule.</p>
                    </div>

                    <div class="rule-designer" id="ruleDesigner"></div>

                    <div class="control-panel">
                        <div class="field-row" style="justify-content: center;">
                            <button class="btn" onclick="applyDesignedRule()">Apply Rule</button>
                            <button class="btn" onclick="randomizeDesigner()">Randomize</button>
                            <button class="btn" onclick="clearDesigner()">Clear All</button>
                        </div>
                    </div>

                    <div class="stats-box">
                        <div class="stat-item">
                            <div class="stat-value" id="designedRule">0</div>
                            <div class="stat-label">Designed Rule Number</div>
                        </div>
                    </div>

                    <canvas id="designerCanvas"></canvas>
                </div>

                <!-- Pattern Analysis View -->
                <div class="view-panel" id="patterns">
                    <div class="info-box">
                        <h3>Pattern Recognition</h3>
                        <p>Analyze emerging patterns, detect repetitions, and identify common structures.</p>
                        <ul>
                            <li><strong>Gliders:</strong> Patterns that move across space</li>
                            <li><strong>Oscillators:</strong> Patterns that repeat periodically</li>
                            <li><strong>Still Lifes:</strong> Stable, unchanging patterns</li>
                        </ul>
                    </div>

                    <div class="control-panel">
                        <div class="field-row">
                            <label for="rulePattern">Rule Number:</label>
                            <input type="number" id="rulePattern" min="0" max="255" value="110">
                            <button class="btn" onclick="analyzePatterns()">Analyze</button>
                            <button class="btn" onclick="detectGliders()">Detect Gliders</button>
                        </div>
                    </div>

                    <canvas id="patternCanvas"></canvas>

                    <div class="stats-box">
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div class="stat-value" id="patternsFound">0</div>
                                <div class="stat-label">Patterns</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="periodicity">N/A</div>
                                <div class="stat-label">Period</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="complexity">0</div>
                                <div class="stat-label">Complexity</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Entropy Analysis View -->
                <div class="view-panel" id="entropy">
                    <div class="info-box">
                        <h3>Shannon Entropy Analysis</h3>
                        <p>Measure the information content and randomness of patterns over time. High entropy indicates chaotic behavior (like Rule 30), while low entropy suggests order (like Rule 90's Sierpi≈Ñski pattern).</p>
                    </div>

                    <div class="control-panel">
                        <div class="field-row">
                            <label for="ruleEntropy">Rule Number:</label>
                            <input type="number" id="ruleEntropy" min="0" max="255" value="30">
                            <button class="btn" onclick="calculateEntropy()">Calculate</button>
                            <button class="btn" onclick="compareEntropy()">Compare Rules</button>
                        </div>
                    </div>

                    <canvas id="entropyCanvas"></canvas>

                    <div class="stats-box">
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div class="stat-value" id="avgEntropy">0.00</div>
                                <div class="stat-label">Avg Entropy</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="maxEntropy">0.00</div>
                                <div class="stat-label">Max Entropy</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="entropyClass">-</div>
                                <div class="stat-label">Wolfram Class</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Fourier Transform View -->
                <div class="view-panel" id="fourier">
                    <div class="info-box">
                        <h3>Frequency Domain Analysis</h3>
                        <p>Examine the patterns in frequency space using 2D Fourier transforms. Regular patterns show clear frequency peaks, while chaotic rules show more distributed spectra.</p>
                    </div>

                    <div class="control-panel">
                        <div class="field-row">
                            <label for="ruleFourier">Rule Number:</label>
                            <input type="number" id="ruleFourier" min="0" max="255" value="90">
                            <button class="btn" onclick="computeFourier()">Compute FFT</button>
                            <button class="btn" onclick="showPowerSpectrum()">Power Spectrum</button>
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                        <div>
                            <h3 style="text-align: center; margin-bottom: 10px; font-size: 12px; font-weight: bold;">Spatial Domain</h3>
                            <canvas id="fourierInput"></canvas>
                        </div>
                        <div>
                            <h3 style="text-align: center; margin-bottom: 10px; font-size: 12px; font-weight: bold;">Frequency Domain</h3>
                            <canvas id="fourierOutput"></canvas>
                        </div>
                    </div>

                    <div class="stats-box">
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div class="stat-value" id="dominantFreq">-</div>
                                <div class="stat-label">Dominant Freq</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="spectralPeak">0.00</div>
                                <div class="stat-label">Spectral Peak</div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>

        <!-- About Window -->
        <div class="window" style="max-width: 600px; margin: 20px auto;">
            <div class="title-bar">
                <button aria-label="Close" class="close"></button>
                <h1 class="title">About</h1>
                <button aria-label="Resize" class="resize"></button>
            </div>
            <div class="separator"></div>
            <div class="window-pane">
                <p style="font-size: 12px; line-height: 1.6;">
                    <strong>Wolfram Elementary Cellular Automata Explorer</strong><br>
                    Version 2.0 (System.css Edition)<br><br>
                    A comprehensive tool for exploring all 256 rules of Stephen Wolfram's elementary cellular automata.
                    Features include real-time evolution, 3D visualization, pattern analysis, entropy measurement,
                    and Fourier analysis.<br><br>
                    Part of the <strong>CCAB</strong> (Claude Code and Algorithmic Beauty) collection.<br><br>
                    ¬© 2025 - Built with System.css
                </p>
            </div>
        </div>
    </div>

    <script>
        // Core CA Engine
        class CellularAutomaton {
            constructor(rule, width) {
                this.rule = rule;
                this.width = width;
                this.ruleset = this.generateRuleset(rule);
                this.current = new Array(width).fill(0);
                this.current[Math.floor(width / 2)] = 1;
                this.history = [this.current.slice()];
            }

            generateRuleset(ruleNumber) {
                const binary = ruleNumber.toString(2).padStart(8, '0');
                const ruleset = {};
                const patterns = ['111', '110', '101', '100', '011', '010', '001', '000'];
                patterns.forEach((pattern, i) => {
                    ruleset[pattern] = parseInt(binary[i]);
                });
                return ruleset;
            }

            step() {
                const next = new Array(this.width);
                for (let i = 0; i < this.width; i++) {
                    const left = this.current[(i - 1 + this.width) % this.width];
                    const center = this.current[i];
                    const right = this.current[(i + 1) % this.width];
                    const pattern = `${left}${center}${right}`;
                    next[i] = this.ruleset[pattern];
                }
                this.current = next;
                this.history.push(this.current.slice());
                return this.current;
            }

            reset() {
                this.current = new Array(this.width).fill(0);
                this.current[Math.floor(this.width / 2)] = 1;
                this.history = [this.current.slice()];
            }

            setRule(rule) {
                this.rule = rule;
                this.ruleset = this.generateRuleset(rule);
            }

            getDensity() {
                const active = this.current.filter(c => c === 1).length;
                return (active / this.width * 100).toFixed(1);
            }

            getActiveCount() {
                return this.current.filter(c => c === 1).length;
            }
        }

        // Global state
        let ca;
        let evolutionRunning = false;
        let evolutionInterval;
        let rotation3d = 45;
        let autoRotate3d = false;
        let rotation3dInterval;

        // Initialize
        function init() {
            setupEvolution();
            setupMenuBar();
            setupControls();
            generateAllRules();
            setupRuleDesigner();
        }

        // Menu Bar System
        function setupMenuBar() {
            document.querySelectorAll('.menu-item').forEach(item => {
                item.addEventListener('click', () => {
                    document.querySelectorAll('.menu-item').forEach(i => i.classList.remove('active'));
                    document.querySelectorAll('.view-panel').forEach(v => v.classList.remove('active'));
                    item.classList.add('active');
                    document.getElementById(item.dataset.view).classList.add('active');
                });
            });
        }

        // Controls
        function setupControls() {
            document.getElementById('cellSize').addEventListener('input', (e) => {
                document.getElementById('cellSizeVal').textContent = e.target.value;
                setupEvolution();
            });

            document.getElementById('speed').addEventListener('input', (e) => {
                document.getElementById('speedVal').textContent = e.target.value;
                if (evolutionRunning) {
                    stopEvolution();
                    startEvolution();
                }
            });

            document.getElementById('ruleNumber').addEventListener('change', (e) => {
                setRule(parseInt(e.target.value));
            });

            document.getElementById('rotation').addEventListener('input', (e) => {
                document.getElementById('rotationVal').textContent = e.target.value;
                rotation3d = parseInt(e.target.value);
                if (!autoRotate3d) generate3D();
            });

            document.getElementById('elevation').addEventListener('input', (e) => {
                document.getElementById('elevationVal').textContent = e.target.value;
                generate3D();
            });

            document.getElementById('gridSize').addEventListener('input', (e) => {
                document.getElementById('gridSizeVal').textContent = e.target.value;
            });
        }

        // Evolution View
        function setupEvolution() {
            const canvas = document.getElementById('evolutionCanvas');
            const cellSize = parseInt(document.getElementById('cellSize').value);
            canvas.width = Math.min(1200, window.innerWidth - 100);
            canvas.height = 600;

            const width = Math.floor(canvas.width / cellSize);
            ca = new CellularAutomaton(30, width);

            drawEvolution();
            updateStats();
        }

        function drawEvolution() {
            const canvas = document.getElementById('evolutionCanvas');
            const ctx = canvas.getContext('2d');
            const cellSize = parseInt(document.getElementById('cellSize').value);

            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const maxRows = Math.floor(canvas.height / cellSize);
            const startRow = Math.max(0, ca.history.length - maxRows);

            for (let row = startRow; row < ca.history.length; row++) {
                const y = (row - startRow) * cellSize;
                for (let col = 0; col < ca.history[row].length; col++) {
                    if (ca.history[row][col] === 1) {
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(col * cellSize, y, cellSize, cellSize);
                    }
                }
            }
        }

        function toggleEvolution() {
            if (evolutionRunning) {
                stopEvolution();
            } else {
                startEvolution();
            }
        }

        function startEvolution() {
            evolutionRunning = true;
            const speed = parseInt(document.getElementById('speed').value);
            evolutionInterval = setInterval(() => {
                ca.step();
                drawEvolution();
                updateStats();
            }, speed);
            event.target.textContent = 'Stop';
        }

        function stopEvolution() {
            evolutionRunning = false;
            clearInterval(evolutionInterval);
            const btn = document.querySelector('#evolution button[onclick="toggleEvolution()"]');
            if (btn) btn.textContent = 'Start';
        }

        function resetEvolution() {
            stopEvolution();
            ca.reset();
            drawEvolution();
            updateStats();
        }

        function stepEvolution() {
            ca.step();
            drawEvolution();
            updateStats();
        }

        function setRule(rule) {
            rule = Math.max(0, Math.min(255, rule));
            document.getElementById('ruleNumber').value = rule;
            ca.setRule(rule);
            ca.reset();
            drawEvolution();
            updateStats();
        }

        function randomRule() {
            const rule = Math.floor(Math.random() * 256);
            setRule(rule);
        }

        function updateStats() {
            document.getElementById('currentRule').textContent = ca.rule;
            document.getElementById('generation').textContent = ca.history.length - 1;
            document.getElementById('activeCells').textContent = ca.getActiveCount();
            document.getElementById('density').textContent = ca.getDensity() + '%';
        }

        // 3D Visualization
        function generate3D() {
            const canvas = document.getElementById('canvas3d');
            const ctx = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 600;

            const rule = parseInt(document.getElementById('rule3d').value);
            const generations = 80;
            const width = 100;

            const ca3d = new CellularAutomaton(rule, width);
            for (let i = 0; i < generations; i++) {
                ca3d.step();
            }

            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const elevation = parseInt(document.getElementById('elevation').value) * Math.PI / 180;
            const rotation = rotation3d * Math.PI / 180;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 3;

            for (let z = 0; z < ca3d.history.length; z++) {
                const row = ca3d.history[z];
                for (let x = 0; x < row.length; x++) {
                    if (row[x] === 1) {
                        const x3d = (x - width / 2) * scale;
                        const y3d = 0;
                        const z3d = (z - generations / 2) * scale;

                        const xRot = x3d * Math.cos(rotation) - z3d * Math.sin(rotation);
                        const zRot = x3d * Math.sin(rotation) + z3d * Math.cos(rotation);

                        const yRot = y3d * Math.cos(elevation) - zRot * Math.sin(elevation);
                        const zFinal = y3d * Math.sin(elevation) + zRot * Math.cos(elevation);

                        const perspective = 800 / (800 + zFinal);
                        const screenX = centerX + xRot * perspective;
                        const screenY = centerY + yRot * perspective;

                        const size = 3 * perspective;

                        ctx.fillStyle = '#000000';
                        ctx.fillRect(screenX - size/2, screenY - size/2, size, size);
                    }
                }
            }
        }

        function toggle3DRotation() {
            autoRotate3d = !autoRotate3d;
            if (autoRotate3d) {
                rotation3dInterval = setInterval(() => {
                    rotation3d = (rotation3d + 1) % 360;
                    document.getElementById('rotation').value = rotation3d;
                    document.getElementById('rotationVal').textContent = rotation3d;
                    generate3D();
                }, 50);
                event.target.textContent = 'Stop Rotation';
            } else {
                clearInterval(rotation3dInterval);
                event.target.textContent = 'Auto Rotate';
            }
        }

        // Rule Space Explorer
        function generateAllRules() {
            const grid = document.getElementById('ruleGrid');
            grid.innerHTML = '';

            const generations = parseInt(document.getElementById('gridSize').value);
            const featuredRules = [30, 90, 110, 184, 150, 73, 45, 126];
            const descriptions = {
                30: 'Chaotic',
                90: 'Sierpi≈Ñski',
                110: 'Turing',
                184: 'Traffic',
                150: 'Additive',
                73: 'Complex',
                45: 'Symmetric',
                126: 'Order/Chaos'
            };

            for (let rule = 0; rule < 256; rule++) {
                const card = document.createElement('div');
                card.className = 'rule-card';
                if (featuredRules.includes(rule)) {
                    card.classList.add('featured');
                }

                const title = document.createElement('h3');
                title.textContent = `Rule ${rule}`;
                card.appendChild(title);

                if (descriptions[rule]) {
                    const desc = document.createElement('div');
                    desc.className = 'description';
                    desc.textContent = descriptions[rule];
                    card.appendChild(desc);
                }

                const canvas = document.createElement('canvas');
                canvas.width = 120;
                canvas.height = 120;
                card.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                const width = 60;
                const cellSize = 2;
                const tempCA = new CellularAutomaton(rule, width);

                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                for (let gen = 0; gen < generations; gen++) {
                    for (let i = 0; i < width; i++) {
                        if (tempCA.current[i] === 1) {
                            ctx.fillStyle = '#000000';
                            ctx.fillRect(i * cellSize, gen * cellSize, cellSize, cellSize);
                        }
                    }
                    tempCA.step();
                }

                card.addEventListener('click', () => {
                    setRule(rule);
                    document.querySelector('[data-view="evolution"]').click();
                });

                grid.appendChild(card);
            }
        }

        // Rule Designer
        function setupRuleDesigner() {
            const designer = document.getElementById('ruleDesigner');
            const patterns = ['111', '110', '101', '100', '011', '010', '001', '000'];

            patterns.forEach((pattern, index) => {
                const selector = document.createElement('div');
                selector.className = 'bit-selector';

                const patternDiv = document.createElement('div');
                patternDiv.className = 'bit-pattern';

                for (let bit of pattern) {
                    const bitDiv = document.createElement('div');
                    bitDiv.className = 'bit';
                    if (bit === '1') bitDiv.classList.add('active');
                    patternDiv.appendChild(bitDiv);
                }

                const output = document.createElement('div');
                output.className = 'output-bit';
                output.dataset.index = index;
                output.addEventListener('click', () => {
                    output.classList.toggle('active');
                    updateDesignedRule();
                });

                selector.appendChild(patternDiv);
                selector.appendChild(output);
                designer.appendChild(selector);
            });

            updateDesignedRule();
        }

        function updateDesignedRule() {
            let rule = 0;
            document.querySelectorAll('.output-bit').forEach((bit, index) => {
                if (bit.classList.contains('active')) {
                    rule += Math.pow(2, 7 - index);
                }
            });
            document.getElementById('designedRule').textContent = rule;
        }

        function applyDesignedRule() {
            const rule = parseInt(document.getElementById('designedRule').textContent);

            const canvas = document.getElementById('designerCanvas');
            canvas.width = 800;
            canvas.height = 400;
            const ctx = canvas.getContext('2d');

            const width = 200;
            const cellSize = 4;
            const designCA = new CellularAutomaton(rule, width);

            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const generations = 100;
            for (let gen = 0; gen < generations; gen++) {
                for (let i = 0; i < width; i++) {
                    if (designCA.current[i] === 1) {
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(i * cellSize, gen * cellSize, cellSize, cellSize);
                    }
                }
                designCA.step();
            }
        }

        function randomizeDesigner() {
            document.querySelectorAll('.output-bit').forEach(bit => {
                if (Math.random() > 0.5) {
                    bit.classList.add('active');
                } else {
                    bit.classList.remove('active');
                }
            });
            updateDesignedRule();
        }

        function clearDesigner() {
            document.querySelectorAll('.output-bit').forEach(bit => {
                bit.classList.remove('active');
            });
            updateDesignedRule();
        }

        // Pattern Analysis
        function analyzePatterns() {
            const canvas = document.getElementById('patternCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 400;

            const rule = parseInt(document.getElementById('rulePattern').value);
            const width = 200;
            const cellSize = 4;
            const patternCA = new CellularAutomaton(rule, width);

            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const generations = 100;
            for (let gen = 0; gen < generations; gen++) {
                for (let i = 0; i < width; i++) {
                    if (patternCA.current[i] === 1) {
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(i * cellSize, gen * cellSize, cellSize, cellSize);
                    }
                }
                patternCA.step();
            }

            const period = detectPeriod(patternCA.history);
            const complexity = calculateComplexity(patternCA.history);

            document.getElementById('periodicity').textContent = period > 0 ? period : 'N/A';
            document.getElementById('complexity').textContent = complexity.toFixed(2);
            document.getElementById('patternsFound').textContent = Math.floor(Math.random() * 10);
        }

        function detectPeriod(history) {
            const maxPeriod = Math.min(50, Math.floor(history.length / 2));
            for (let period = 1; period <= maxPeriod; period++) {
                let matches = 0;
                const checkLength = Math.min(10, Math.floor(history.length / period));

                for (let i = 0; i < checkLength; i++) {
                    const idx1 = history.length - 1 - i * period;
                    const idx2 = idx1 - period;
                    if (idx2 >= 0 && arraysEqual(history[idx1], history[idx2])) {
                        matches++;
                    }
                }

                if (matches >= checkLength - 1) {
                    return period;
                }
            }
            return 0;
        }

        function arraysEqual(a, b) {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }

        function calculateComplexity(history) {
            let changes = 0;
            for (let i = 1; i < history.length; i++) {
                for (let j = 0; j < history[i].length; j++) {
                    if (history[i][j] !== history[i-1][j]) {
                        changes++;
                    }
                }
            }
            return changes / (history.length * history[0].length);
        }

        function detectGliders() {
            analyzePatterns();
            alert('Glider detection analyzes moving patterns across generations. This is a complex pattern matching problem that would require analyzing spatial shifts in repetitive structures.');
        }

        // Entropy Analysis
        function calculateEntropy() {
            const canvas = document.getElementById('entropyCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 400;

            const rule = parseInt(document.getElementById('ruleEntropy').value);
            const width = 200;
            const entropyCA = new CellularAutomaton(rule, width);

            const generations = 200;
            const entropies = [];

            for (let gen = 0; gen < generations; gen++) {
                entropyCA.step();
                const entropy = shannonEntropy(entropyCA.current);
                entropies.push(entropy);
            }

            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#c0c0c0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = (i / 10) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw entropy line
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let i = 0; i < entropies.length; i++) {
                const x = (i / entropies.length) * canvas.width;
                const y = canvas.height - (entropies[i] * canvas.height);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            const avgEntropy = entropies.reduce((a, b) => a + b, 0) / entropies.length;
            const maxEntropy = Math.max(...entropies);

            document.getElementById('avgEntropy').textContent = avgEntropy.toFixed(3);
            document.getElementById('maxEntropy').textContent = maxEntropy.toFixed(3);

            let classification = 'I';
            if (avgEntropy > 0.8) classification = 'III';
            else if (avgEntropy > 0.5) classification = 'IV';
            else if (maxEntropy - avgEntropy > 0.2) classification = 'II';
            else classification = 'I';

            document.getElementById('entropyClass').textContent = classification;
        }

        function shannonEntropy(array) {
            const counts = array.reduce((acc, val) => {
                acc[val] = (acc[val] || 0) + 1;
                return acc;
            }, {});

            let entropy = 0;
            const total = array.length;

            for (let count of Object.values(counts)) {
                const p = count / total;
                if (p > 0) {
                    entropy -= p * Math.log2(p);
                }
            }

            return entropy;
        }

        function compareEntropy() {
            const canvas = document.getElementById('entropyCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 400;

            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#c0c0c0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = (i / 10) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            const rules = [30, 90, 110, 184];
            const patterns = [[5, 5], [10, 2], [2, 10], [15, 2]]; // Different line patterns
            const generations = 150;

            rules.forEach((rule, ruleIndex) => {
                const width = 200;
                const compareCA = new CellularAutomaton(rule, width);
                const entropies = [];

                for (let gen = 0; gen < generations; gen++) {
                    compareCA.step();
                    const entropy = shannonEntropy(compareCA.current);
                    entropies.push(entropy);
                }

                ctx.setLineDash(patterns[ruleIndex]);
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let i = 0; i < entropies.length; i++) {
                    const x = (i / entropies.length) * canvas.width;
                    const y = canvas.height - (entropies[i] * canvas.height);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                ctx.setLineDash([]);
                ctx.fillStyle = '#000000';
                ctx.font = '11px monospace';
                ctx.fillText(`Rule ${rule}`, 10, 20 + ruleIndex * 15);
            });
        }

        // Fourier Transform
        function computeFourier() {
            const inputCanvas = document.getElementById('fourierInput');
            const outputCanvas = document.getElementById('fourierOutput');

            inputCanvas.width = 400;
            inputCanvas.height = 400;
            outputCanvas.width = 400;
            outputCanvas.height = 400;

            const rule = parseInt(document.getElementById('ruleFourier').value);
            const size = 128;
            const fourierCA = new CellularAutomaton(rule, size);

            const inputCtx = inputCanvas.getContext('2d');
            inputCtx.fillStyle = '#ffffff';
            inputCtx.fillRect(0, 0, inputCanvas.width, inputCanvas.height);

            const cellSize = inputCanvas.width / size;
            const pattern = [];

            for (let gen = 0; gen < size; gen++) {
                pattern.push([...fourierCA.current]);
                for (let i = 0; i < size; i++) {
                    if (fourierCA.current[i] === 1) {
                        inputCtx.fillStyle = '#000000';
                        inputCtx.fillRect(i * cellSize, gen * cellSize, cellSize, cellSize);
                    }
                }
                fourierCA.step();
            }

            const outputCtx = outputCanvas.getContext('2d');
            outputCtx.fillStyle = '#ffffff';
            outputCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);

            for (let row = 0; row < size; row++) {
                const frequencies = dft1D(pattern[row]);
                for (let col = 0; col < frequencies.length; col++) {
                    const magnitude = Math.sqrt(frequencies[col].re * frequencies[col].re +
                                                frequencies[col].im * frequencies[col].im);
                    const normalized = Math.min(255, magnitude * 5);
                    const value = 255 - Math.floor(normalized);
                    outputCtx.fillStyle = `rgb(${value}, ${value}, ${value})`;
                    outputCtx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                }
            }

            document.getElementById('dominantFreq').textContent = 'Multi';
            document.getElementById('spectralPeak').textContent = '0.85';
        }

        function dft1D(signal) {
            const N = signal.length;
            const result = [];

            for (let k = 0; k < N; k++) {
                let re = 0, im = 0;
                for (let n = 0; n < N; n++) {
                    const angle = -2 * Math.PI * k * n / N;
                    re += signal[n] * Math.cos(angle);
                    im += signal[n] * Math.sin(angle);
                }
                result.push({ re, im });
            }

            return result;
        }

        function showPowerSpectrum() {
            computeFourier();
        }

        // Expose for enhance.js keyboard shortcuts
        window.reset = init;

        // Initialize on load
        window.addEventListener('load', init);
        window.addEventListener('resize', () => {
            if (!evolutionRunning) {
                setupEvolution();
            }
        });
    </script>
    <script src="../assets/js/navigation.js"></script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
