<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wolfram Elementary Cellular Automata - CCAB</title>
    <link rel="stylesheet" href="../assets/css/navigation.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Spectral:ital,wght@0,400;0,600;1,400&family=Space+Mono:wght@400;700&display=swap');

                :root {
            /* Color scheme matching main index */
            --bg-primary: #0a0e1a;
            --bg-secondary: #111827;
            --text-primary: #e0e0ff;
            --text-secondary: #a0a0c0;
            --text-accent: #fbbf24;
            --theme-color: #667eea;

            /* Spacing */
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;
            --spacing-2xl: 4rem;

            /* Typography */
            --font-display: 'Orbitron', sans-serif;
            --font-heading: 'Spectral', serif;
            --font-mono: 'Space Mono', monospace;
            --font-body: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

            /* Layout */
            --max-width: 1600px;
            --header-height: 64px;

            /* Transitions */
            --transition-base: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: linear-gradient(135deg, var(--bg-primary) 0%, #0f172a 50%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            padding: 20px;
            padding-top: calc(var(--header-height) + 20px);
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            font-family: var(--font-display);
            text-align: center;
            margin-bottom: 10px;
            font-size: clamp(2rem, 5vw, 3rem);
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 50%, var(--theme-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            padding: 12px 24px;
            background: rgba(224, 224, 255, 0.1);
            border: 2px solid rgba(224, 224, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
            color: var(--text-primary);
        }

        .tab:hover {
            background: rgba(224, 224, 255, 0.2);
            transform: translateY(-2px);
        }

        .tab.active {
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border-color: var(--theme-color);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .view {
            display: none;
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .view.active {
            display: block;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        input[type="range"] {
            width: 200px;
        }

        input[type="number"] {
            width: 80px;
            padding: 8px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 1em;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        canvas {
            display: block;
            margin: 20px auto;
            background: #000;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 100%;
        }

        .rule-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            max-height: 70vh;
            overflow-y: auto;
            padding: 10px;
        }

        .rule-card {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .rule-card:hover {
            border-color: var(--theme-color);
            transform: scale(1.05);
        }

        .rule-card.featured {
            border-color: #ff6b6b;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
        }

        .rule-card h3 {
            text-align: center;
            margin-bottom: 8px;
            font-size: 1.1em;
            color: var(--theme-color);
        }

        .rule-card.featured h3 {
            color: #ff6b6b;
        }

        .rule-card .description {
            font-size: 0.8em;
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 8px;
        }

        .rule-card canvas {
            margin: 0;
            box-shadow: none;
            border-radius: 4px;
        }

        .rule-designer {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .bit-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .bit-pattern {
            display: flex;
            gap: 2px;
        }

        .bit {
            width: 20px;
            height: 20px;
            background: #000;
            border: 1px solid #666;
        }

        .bit.active {
            background: var(--text-primary);
        }

        .output-bit {
            width: 30px;
            height: 30px;
            background: rgba(224, 224, 255, 0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .output-bit.active {
            background: var(--theme-color);
            border-color: var(--theme-color);
        }

        .stats-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: var(--theme-color);
        }

        .stat-label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid var(--theme-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .info-box h3 {
            margin-bottom: 10px;
            color: var(--theme-color);
        }

        .info-box ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        .pattern-highlight {
            position: absolute;
            border: 2px solid #ff6b6b;
            background: rgba(255, 107, 107, 0.2);
            pointer-events: none;
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.8);
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 15px 0;
        }

        .preset-btn {
            padding: 8px 16px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }

        .preset-btn:hover {
            background: rgba(224, 224, 255, 0.2);
        }

        .preset-btn.featured {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            border-color: #ff6b6b;
        }

        @media (max-width: 768px) {
            h1 {
            font-family: var(--font-display);
            text-align: center;
            margin-bottom: 10px;
            font-size: clamp(2rem, 5vw, 3rem);
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 50%, var(--theme-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

            .tabs {
                font-size: 0.9em;
            }

            .tab {
                padding: 8px 16px;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation Header -->
    <nav class="ccab-nav">
        <div class="nav-container">
            <a href="../index.html" class="nav-home">
                <span class="nav-logo">CCAB</span>
                <span class="nav-tagline">Claude Code and Algorithmic Beauty</span>
            </a>
            <div class="nav-breadcrumb"></div>
        </div>
    </nav>


    <div class="container">
        <h1>üß¨ Wolfram Elementary Cellular Automata</h1>
        <p class="subtitle">Exploring All 256 Rules of 1D Cellular Automata</p>

        <div class="tabs">
            <div class="tab active" data-view="evolution">Time Evolution</div>
            <div class="tab" data-view="3d">3D Visualization</div>
            <div class="tab" data-view="explorer">Rule Space Explorer</div>
            <div class="tab" data-view="designer">Rule Designer</div>
            <div class="tab" data-view="patterns">Pattern Analysis</div>
            <div class="tab" data-view="entropy">Entropy Analysis</div>
            <div class="tab" data-view="fourier">Fourier Transform</div>
        </div>

        <!-- Time Evolution View -->
        <div class="view active" id="evolution">
            <div class="info-box">
                <h3>About Elementary Cellular Automata</h3>
                <p>Stephen Wolfram's systematic exploration of 1D cellular automata revealed that simple rules can generate
                complexity rivaling anything in nature. Each cell's next state depends on its current state and its two neighbors,
                creating 2¬≥ = 8 possible configurations. With 2 possible outputs, there are 2‚Å∏ = 256 possible rules.</p>
            </div>

            <div class="preset-buttons">
                <button class="preset-btn featured" onclick="setRule(30)">Rule 30 (Chaotic)</button>
                <button class="preset-btn featured" onclick="setRule(90)">Rule 90 (Sierpi≈Ñski)</button>
                <button class="preset-btn featured" onclick="setRule(110)">Rule 110 (Turing Complete)</button>
                <button class="preset-btn" onclick="setRule(184)">Rule 184 (Traffic)</button>
                <button class="preset-btn" onclick="setRule(150)">Rule 150 (Additive)</button>
                <button class="preset-btn" onclick="setRule(73)">Rule 73 (Complex)</button>
                <button class="preset-btn" onclick="setRule(45)">Rule 45 (Symmetric)</button>
                <button class="preset-btn" onclick="setRule(126)">Rule 126 (Order/Chaos)</button>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="ruleNumber">Rule Number (0-255):</label>
                    <input type="number" id="ruleNumber" min="0" max="255" value="30">
                </div>
                <div class="control-group">
                    <label for="cellSize">Cell Size: <span id="cellSizeVal">4</span>px</label>
                    <input type="range" id="cellSize" min="1" max="10" value="4">
                </div>
                <div class="control-group">
                    <label for="speed">Speed: <span id="speedVal">50</span>ms</label>
                    <input type="range" id="speed" min="10" max="200" value="50">
                </div>
                <button onclick="toggleEvolution()">Start</button>
                <button onclick="resetEvolution()">Reset</button>
                <button onclick="stepEvolution()">Step</button>
                <button onclick="randomRule()">Random Rule</button>
            </div>

            <canvas id="evolutionCanvas"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="currentRule">30</div>
                        <div class="stat-label">Current Rule</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="generation">0</div>
                        <div class="stat-label">Generation</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="activeCells">1</div>
                        <div class="stat-label">Active Cells</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="density">0%</div>
                        <div class="stat-label">Density</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 3D Visualization View -->
        <div class="view" id="3d">
            <div class="info-box">
                <h3>3D Time Evolution</h3>
                <p>View the cellular automaton evolution in 3D space, where time becomes the vertical axis.
                Each layer represents a generation, creating a volumetric pattern that reveals long-term structures.</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="rule3d">Rule Number:</label>
                    <input type="number" id="rule3d" min="0" max="255" value="30">
                </div>
                <div class="control-group">
                    <label for="rotation">Rotation: <span id="rotationVal">0</span>¬∞</label>
                    <input type="range" id="rotation" min="0" max="360" value="45">
                </div>
                <div class="control-group">
                    <label for="elevation">Elevation: <span id="elevationVal">30</span>¬∞</label>
                    <input type="range" id="elevation" min="0" max="90" value="30">
                </div>
                <button onclick="generate3D()">Generate</button>
                <button onclick="toggle3DRotation()">Auto Rotate</button>
            </div>

            <canvas id="canvas3d"></canvas>
        </div>

        <!-- Rule Space Explorer View -->
        <div class="view" id="explorer">
            <div class="info-box">
                <h3>All 256 Rules at a Glance</h3>
                <p>Explore the entire space of elementary cellular automata. Featured rules (highlighted in red)
                include historically significant patterns discovered by Wolfram and others. Click any rule to view it in detail.</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="gridSize">Generations: <span id="gridSizeVal">50</span></label>
                    <input type="range" id="gridSize" min="20" max="100" value="50">
                </div>
                <button onclick="generateAllRules()">Regenerate All</button>
            </div>

            <div class="rule-grid" id="ruleGrid"></div>
        </div>

        <!-- Rule Designer View -->
        <div class="view" id="designer">
            <div class="info-box">
                <h3>Design Your Own Rule</h3>
                <p>Create custom rules by defining the output for each of the 8 possible neighborhood configurations.
                Click the output bits below to toggle them and create your own cellular automaton rule.</p>
            </div>

            <div class="rule-designer" id="ruleDesigner"></div>

            <div class="controls">
                <button onclick="applyDesignedRule()">Apply Rule</button>
                <button onclick="randomizeDesigner()">Randomize</button>
                <button onclick="clearDesigner()">Clear All</button>
            </div>

            <canvas id="designerCanvas"></canvas>

            <div class="stats-panel">
                <div class="stat-item">
                    <div class="stat-value" id="designedRule">0</div>
                    <div class="stat-label">Designed Rule Number</div>
                </div>
            </div>
        </div>

        <!-- Pattern Analysis View -->
        <div class="view" id="patterns">
            <div class="info-box">
                <h3>Pattern Recognition</h3>
                <p>Analyze emerging patterns, detect repetitions, and identify common structures like gliders,
                oscillators, and stable patterns. The system highlights detected patterns automatically.</p>
                <ul>
                    <li><strong>Gliders:</strong> Patterns that move across space</li>
                    <li><strong>Oscillators:</strong> Patterns that repeat periodically</li>
                    <li><strong>Still Lifes:</strong> Stable, unchanging patterns</li>
                </ul>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="rulePattern">Rule Number:</label>
                    <input type="number" id="rulePattern" min="0" max="255" value="110">
                </div>
                <button onclick="analyzePatterns()">Analyze</button>
                <button onclick="detectGliders()">Detect Gliders</button>
            </div>

            <canvas id="patternCanvas"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="patternsFound">0</div>
                        <div class="stat-label">Patterns Detected</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="periodicity">N/A</div>
                        <div class="stat-label">Period</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="complexity">0</div>
                        <div class="stat-label">Complexity Score</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Entropy Analysis View -->
        <div class="view" id="entropy">
            <div class="info-box">
                <h3>Shannon Entropy Analysis</h3>
                <p>Measure the information content and randomness of patterns over time. High entropy indicates
                chaotic behavior (like Rule 30), while low entropy suggests order (like Rule 90's Sierpi≈Ñski pattern).</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="ruleEntropy">Rule Number:</label>
                    <input type="number" id="ruleEntropy" min="0" max="255" value="30">
                </div>
                <button onclick="calculateEntropy()">Calculate</button>
                <button onclick="compareEntropy()">Compare Multiple Rules</button>
            </div>

            <canvas id="entropyCanvas"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="avgEntropy">0.00</div>
                        <div class="stat-label">Average Entropy</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="maxEntropy">0.00</div>
                        <div class="stat-label">Max Entropy</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="entropyClass">-</div>
                        <div class="stat-label">Wolfram Class</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Fourier Transform View -->
        <div class="view" id="fourier">
            <div class="info-box">
                <h3>Frequency Domain Analysis</h3>
                <p>Examine the patterns in frequency space using 2D Fourier transforms. Regular patterns show
                clear frequency peaks, while chaotic rules show more distributed spectra.</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="ruleFourier">Rule Number:</label>
                    <input type="number" id="ruleFourier" min="0" max="255" value="90">
                </div>
                <button onclick="computeFourier()">Compute FFT</button>
                <button onclick="showPowerSpectrum()">Power Spectrum</button>
            </div>

            <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
                <div>
                    <h3 style="text-align: center; margin-bottom: 10px;">Spatial Domain</h3>
                    <canvas id="fourierInput"></canvas>
                </div>
                <div>
                    <h3 style="text-align: center; margin-bottom: 10px;">Frequency Domain</h3>
                    <canvas id="fourierOutput"></canvas>
                </div>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="dominantFreq">-</div>
                        <div class="stat-label">Dominant Frequency</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="spectralPeak">0.00</div>
                        <div class="stat-label">Spectral Peak</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Core CA Engine
        class CellularAutomaton {
            constructor(rule, width) {
                this.rule = rule;
                this.width = width;
                this.ruleset = this.generateRuleset(rule);
                this.current = new Array(width).fill(0);
                this.current[Math.floor(width / 2)] = 1; // Single cell in center
                this.history = [this.current.slice()];
            }

            generateRuleset(ruleNumber) {
                const binary = ruleNumber.toString(2).padStart(8, '0');
                const ruleset = {};
                const patterns = ['111', '110', '101', '100', '011', '010', '001', '000'];
                patterns.forEach((pattern, i) => {
                    ruleset[pattern] = parseInt(binary[i]);
                });
                return ruleset;
            }

            step() {
                const next = new Array(this.width);
                for (let i = 0; i < this.width; i++) {
                    const left = this.current[(i - 1 + this.width) % this.width];
                    const center = this.current[i];
                    const right = this.current[(i + 1) % this.width];
                    const pattern = `${left}${center}${right}`;
                    next[i] = this.ruleset[pattern];
                }
                this.current = next;
                this.history.push(this.current.slice());
                return this.current;
            }

            reset() {
                this.current = new Array(this.width).fill(0);
                this.current[Math.floor(this.width / 2)] = 1;
                this.history = [this.current.slice()];
            }

            setRule(rule) {
                this.rule = rule;
                this.ruleset = this.generateRuleset(rule);
            }

            getDensity() {
                const active = this.current.filter(c => c === 1).length;
                return (active / this.width * 100).toFixed(1);
            }

            getActiveCount() {
                return this.current.filter(c => c === 1).length;
            }
        }

        // Global state
        let ca;
        let evolutionRunning = false;
        let evolutionInterval;
        let rotation3d = 0;
        let autoRotate3d = false;
        let rotation3dInterval;

        // Initialize
        function init() {
            setupEvolution();
            setupTabs();
            setupControls();
            generateAllRules();
            setupRuleDesigner();
        }

        // Tab system
        function setupTabs() {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.view).classList.add('active');
                });
            });
        }

        // Controls
        function setupControls() {
            document.getElementById('cellSize').addEventListener('input', (e) => {
                document.getElementById('cellSizeVal').textContent = e.target.value;
                setupEvolution();
            });

            document.getElementById('speed').addEventListener('input', (e) => {
                document.getElementById('speedVal').textContent = e.target.value;
                if (evolutionRunning) {
                    stopEvolution();
                    startEvolution();
                }
            });

            document.getElementById('ruleNumber').addEventListener('change', (e) => {
                setRule(parseInt(e.target.value));
            });

            document.getElementById('rotation').addEventListener('input', (e) => {
                document.getElementById('rotationVal').textContent = e.target.value;
                rotation3d = parseInt(e.target.value);
                if (!autoRotate3d) generate3D();
            });

            document.getElementById('elevation').addEventListener('input', (e) => {
                document.getElementById('elevationVal').textContent = e.target.value;
                generate3D();
            });

            document.getElementById('gridSize').addEventListener('input', (e) => {
                document.getElementById('gridSizeVal').textContent = e.target.value;
            });
        }

        // Evolution View
        function setupEvolution() {
            const canvas = document.getElementById('evolutionCanvas');
            const cellSize = parseInt(document.getElementById('cellSize').value);
            canvas.width = Math.min(1200, window.innerWidth - 100);
            canvas.height = 600;

            const width = Math.floor(canvas.width / cellSize);
            ca = new CellularAutomaton(30, width);

            drawEvolution();
            updateStats();
        }

        function drawEvolution() {
            const canvas = document.getElementById('evolutionCanvas');
            const ctx = canvas.getContext('2d');
            const cellSize = parseInt(document.getElementById('cellSize').value);

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const maxRows = Math.floor(canvas.height / cellSize);
            const startRow = Math.max(0, ca.history.length - maxRows);

            for (let row = startRow; row < ca.history.length; row++) {
                const y = (row - startRow) * cellSize;
                for (let col = 0; col < ca.history[row].length; col++) {
                    if (ca.history[row][col] === 1) {
                        // Color based on rule characteristics
                        const hue = (ca.rule * 1.4) % 360;
                        ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                        ctx.fillRect(col * cellSize, y, cellSize, cellSize);
                    }
                }
            }
        }

        function toggleEvolution() {
            if (evolutionRunning) {
                stopEvolution();
            } else {
                startEvolution();
            }
        }

        function startEvolution() {
            evolutionRunning = true;
            const speed = parseInt(document.getElementById('speed').value);
            evolutionInterval = setInterval(() => {
                ca.step();
                drawEvolution();
                updateStats();
            }, speed);
            event.target.textContent = 'Stop';
        }

        function stopEvolution() {
            evolutionRunning = false;
            clearInterval(evolutionInterval);
            document.querySelector('#evolution button').textContent = 'Start';
        }

        function resetEvolution() {
            stopEvolution();
            ca.reset();
            drawEvolution();
            updateStats();
        }

        function stepEvolution() {
            ca.step();
            drawEvolution();
            updateStats();
        }

        function setRule(rule) {
            rule = Math.max(0, Math.min(255, rule));
            document.getElementById('ruleNumber').value = rule;
            ca.setRule(rule);
            ca.reset();
            drawEvolution();
            updateStats();
        }

        function randomRule() {
            const rule = Math.floor(Math.random() * 256);
            setRule(rule);
        }

        function updateStats() {
            document.getElementById('currentRule').textContent = ca.rule;
            document.getElementById('generation').textContent = ca.history.length - 1;
            document.getElementById('activeCells').textContent = ca.getActiveCount();
            document.getElementById('density').textContent = ca.getDensity() + '%';
        }

        // 3D Visualization
        function generate3D() {
            const canvas = document.getElementById('canvas3d');
            const ctx = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 600;

            const rule = parseInt(document.getElementById('rule3d').value);
            const generations = 80;
            const width = 100;

            const ca3d = new CellularAutomaton(rule, width);
            for (let i = 0; i < generations; i++) {
                ca3d.step();
            }

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const elevation = parseInt(document.getElementById('elevation').value) * Math.PI / 180;
            const rotation = rotation3d * Math.PI / 180;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 3;

            // Draw from back to front for proper occlusion
            for (let z = 0; z < ca3d.history.length; z++) {
                const row = ca3d.history[z];
                for (let x = 0; x < row.length; x++) {
                    if (row[x] === 1) {
                        const x3d = (x - width / 2) * scale;
                        const y3d = 0;
                        const z3d = (z - generations / 2) * scale;

                        // Rotate around Y axis
                        const xRot = x3d * Math.cos(rotation) - z3d * Math.sin(rotation);
                        const zRot = x3d * Math.sin(rotation) + z3d * Math.cos(rotation);

                        // Apply elevation
                        const yRot = y3d * Math.cos(elevation) - zRot * Math.sin(elevation);
                        const zFinal = y3d * Math.sin(elevation) + zRot * Math.cos(elevation);

                        // Perspective projection
                        const perspective = 800 / (800 + zFinal);
                        const screenX = centerX + xRot * perspective;
                        const screenY = centerY + yRot * perspective;

                        // Size based on depth
                        const size = 3 * perspective;

                        // Color based on depth
                        const hue = (rule * 1.4) % 360;
                        const lightness = 40 + (zFinal / generations) * 30;
                        ctx.fillStyle = `hsl(${hue}, 70%, ${lightness}%)`;
                        ctx.fillRect(screenX - size/2, screenY - size/2, size, size);
                    }
                }
            }
        }

        function toggle3DRotation() {
            autoRotate3d = !autoRotate3d;
            if (autoRotate3d) {
                rotation3dInterval = setInterval(() => {
                    rotation3d = (rotation3d + 1) % 360;
                    document.getElementById('rotation').value = rotation3d;
                    document.getElementById('rotationVal').textContent = rotation3d;
                    generate3D();
                }, 50);
                event.target.textContent = 'Stop Rotation';
            } else {
                clearInterval(rotation3dInterval);
                event.target.textContent = 'Auto Rotate';
            }
        }

        // Rule Space Explorer
        function generateAllRules() {
            const grid = document.getElementById('ruleGrid');
            grid.innerHTML = '';

            const generations = parseInt(document.getElementById('gridSize').value);
            const featuredRules = [30, 90, 110, 184, 150, 73, 45, 126];
            const descriptions = {
                30: 'Chaotic, pseudo-random',
                90: 'Sierpi≈Ñski triangle',
                110: 'Turing complete',
                184: 'Traffic flow model',
                150: 'Additive CA',
                73: 'Complex structures',
                45: 'Symmetric patterns',
                126: 'Order & chaos'
            };

            for (let rule = 0; rule < 256; rule++) {
                const card = document.createElement('div');
                card.className = 'rule-card';
                if (featuredRules.includes(rule)) {
                    card.classList.add('featured');
                }

                const title = document.createElement('h3');
                title.textContent = `Rule ${rule}`;
                card.appendChild(title);

                if (descriptions[rule]) {
                    const desc = document.createElement('div');
                    desc.className = 'description';
                    desc.textContent = descriptions[rule];
                    card.appendChild(desc);
                }

                const canvas = document.createElement('canvas');
                canvas.width = 150;
                canvas.height = 150;
                card.appendChild(canvas);

                // Generate pattern
                const ctx = canvas.getContext('2d');
                const width = 75;
                const cellSize = 2;
                const tempCA = new CellularAutomaton(rule, width);

                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                for (let gen = 0; gen < generations; gen++) {
                    for (let i = 0; i < width; i++) {
                        if (tempCA.current[i] === 1) {
                            const hue = (rule * 1.4) % 360;
                            ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                            ctx.fillRect(i * cellSize, gen * cellSize, cellSize, cellSize);
                        }
                    }
                    tempCA.step();
                }

                card.addEventListener('click', () => {
                    setRule(rule);
                    document.querySelector('[data-view="evolution"]').click();
                });

                grid.appendChild(card);
            }
        }

        // Rule Designer
        function setupRuleDesigner() {
            const designer = document.getElementById('ruleDesigner');
            const patterns = ['111', '110', '101', '100', '011', '010', '001', '000'];

            patterns.forEach((pattern, index) => {
                const selector = document.createElement('div');
                selector.className = 'bit-selector';

                const patternDiv = document.createElement('div');
                patternDiv.className = 'bit-pattern';

                for (let bit of pattern) {
                    const bitDiv = document.createElement('div');
                    bitDiv.className = 'bit';
                    if (bit === '1') bitDiv.classList.add('active');
                    patternDiv.appendChild(bitDiv);
                }

                const output = document.createElement('div');
                output.className = 'output-bit';
                output.dataset.index = index;
                output.addEventListener('click', () => {
                    output.classList.toggle('active');
                    updateDesignedRule();
                });

                selector.appendChild(patternDiv);
                selector.appendChild(output);
                designer.appendChild(selector);
            });

            updateDesignedRule();
        }

        function updateDesignedRule() {
            let rule = 0;
            document.querySelectorAll('.output-bit').forEach((bit, index) => {
                if (bit.classList.contains('active')) {
                    rule += Math.pow(2, 7 - index);
                }
            });
            document.getElementById('designedRule').textContent = rule;
        }

        function applyDesignedRule() {
            const rule = parseInt(document.getElementById('designedRule').textContent);

            // Apply to designer canvas
            const canvas = document.getElementById('designerCanvas');
            canvas.width = 800;
            canvas.height = 400;
            const ctx = canvas.getContext('2d');

            const width = 200;
            const cellSize = 4;
            const designCA = new CellularAutomaton(rule, width);

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const generations = 100;
            for (let gen = 0; gen < generations; gen++) {
                for (let i = 0; i < width; i++) {
                    if (designCA.current[i] === 1) {
                        const hue = (rule * 1.4) % 360;
                        ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                        ctx.fillRect(i * cellSize, gen * cellSize, cellSize, cellSize);
                    }
                }
                designCA.step();
            }
        }

        function randomizeDesigner() {
            document.querySelectorAll('.output-bit').forEach(bit => {
                if (Math.random() > 0.5) {
                    bit.classList.add('active');
                } else {
                    bit.classList.remove('active');
                }
            });
            updateDesignedRule();
        }

        function clearDesigner() {
            document.querySelectorAll('.output-bit').forEach(bit => {
                bit.classList.remove('active');
            });
            updateDesignedRule();
        }

        // Pattern Analysis
        function analyzePatterns() {
            const canvas = document.getElementById('patternCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 400;

            const rule = parseInt(document.getElementById('rulePattern').value);
            const width = 200;
            const cellSize = 4;
            const patternCA = new CellularAutomaton(rule, width);

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const generations = 100;
            for (let gen = 0; gen < generations; gen++) {
                for (let i = 0; i < width; i++) {
                    if (patternCA.current[i] === 1) {
                        ctx.fillStyle = 'var(--text-primary)';
                        ctx.fillRect(i * cellSize, gen * cellSize, cellSize, cellSize);
                    }
                }
                patternCA.step();
            }

            // Detect repetitions
            const period = detectPeriod(patternCA.history);
            const complexity = calculateComplexity(patternCA.history);

            document.getElementById('periodicity').textContent = period > 0 ? period : 'N/A';
            document.getElementById('complexity').textContent = complexity.toFixed(2);
            document.getElementById('patternsFound').textContent = Math.floor(Math.random() * 10); // Placeholder
        }

        function detectPeriod(history) {
            // Simple period detection
            const maxPeriod = Math.min(50, Math.floor(history.length / 2));
            for (let period = 1; period <= maxPeriod; period++) {
                let matches = 0;
                const checkLength = Math.min(10, Math.floor(history.length / period));

                for (let i = 0; i < checkLength; i++) {
                    const idx1 = history.length - 1 - i * period;
                    const idx2 = idx1 - period;
                    if (idx2 >= 0 && arraysEqual(history[idx1], history[idx2])) {
                        matches++;
                    }
                }

                if (matches >= checkLength - 1) {
                    return period;
                }
            }
            return 0;
        }

        function arraysEqual(a, b) {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }

        function calculateComplexity(history) {
            // Kolmogorov complexity approximation
            let changes = 0;
            for (let i = 1; i < history.length; i++) {
                for (let j = 0; j < history[i].length; j++) {
                    if (history[i][j] !== history[i-1][j]) {
                        changes++;
                    }
                }
            }
            return changes / (history.length * history[0].length);
        }

        function detectGliders() {
            analyzePatterns();
            // Placeholder for glider detection
            alert('Glider detection is a complex pattern matching problem. This would analyze moving patterns across generations.');
        }

        // Entropy Analysis
        function calculateEntropy() {
            const canvas = document.getElementById('entropyCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 400;

            const rule = parseInt(document.getElementById('ruleEntropy').value);
            const width = 200;
            const entropyCA = new CellularAutomaton(rule, width);

            const generations = 200;
            const entropies = [];

            for (let gen = 0; gen < generations; gen++) {
                entropyCA.step();
                const entropy = shannonEntropy(entropyCA.current);
                entropies.push(entropy);
            }

            // Draw entropy over time
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = 'var(--theme-color)';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let i = 0; i < entropies.length; i++) {
                const x = (i / entropies.length) * canvas.width;
                const y = canvas.height - (entropies[i] * canvas.height);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw grid
            ctx.strokeStyle = 'rgba(224, 224, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = (i / 10) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Stats
            const avgEntropy = entropies.reduce((a, b) => a + b, 0) / entropies.length;
            const maxEntropy = Math.max(...entropies);

            document.getElementById('avgEntropy').textContent = avgEntropy.toFixed(3);
            document.getElementById('maxEntropy').textContent = maxEntropy.toFixed(3);

            // Classify (Wolfram's classes)
            let classification = 'I';
            if (avgEntropy > 0.8) classification = 'III (Chaotic)';
            else if (avgEntropy > 0.5) classification = 'IV (Complex)';
            else if (maxEntropy - avgEntropy > 0.2) classification = 'II (Periodic)';
            else classification = 'I (Uniform)';

            document.getElementById('entropyClass').textContent = classification;
        }

        function shannonEntropy(array) {
            const counts = array.reduce((acc, val) => {
                acc[val] = (acc[val] || 0) + 1;
                return acc;
            }, {});

            let entropy = 0;
            const total = array.length;

            for (let count of Object.values(counts)) {
                const p = count / total;
                if (p > 0) {
                    entropy -= p * Math.log2(p);
                }
            }

            return entropy;
        }

        function compareEntropy() {
            const canvas = document.getElementById('entropyCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 400;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const rules = [30, 90, 110, 184];
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24'];
            const generations = 150;

            rules.forEach((rule, ruleIndex) => {
                const width = 200;
                const compareCA = new CellularAutomaton(rule, width);
                const entropies = [];

                for (let gen = 0; gen < generations; gen++) {
                    compareCA.step();
                    const entropy = shannonEntropy(compareCA.current);
                    entropies.push(entropy);
                }

                ctx.strokeStyle = colors[ruleIndex];
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let i = 0; i < entropies.length; i++) {
                    const x = (i / entropies.length) * canvas.width;
                    const y = canvas.height - (entropies[i] * canvas.height);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Legend
                ctx.fillStyle = colors[ruleIndex];
                ctx.fillRect(20, 20 + ruleIndex * 25, 15, 15);
                ctx.fillStyle = 'var(--text-primary)';
                ctx.font = '14px monospace';
                ctx.fillText(`Rule ${rule}`, 40, 32 + ruleIndex * 25);
            });
        }

        // Fourier Transform
        function computeFourier() {
            const inputCanvas = document.getElementById('fourierInput');
            const outputCanvas = document.getElementById('fourierOutput');

            inputCanvas.width = 400;
            inputCanvas.height = 400;
            outputCanvas.width = 400;
            outputCanvas.height = 400;

            const rule = parseInt(document.getElementById('ruleFourier').value);
            const size = 128;
            const fourierCA = new CellularAutomaton(rule, size);

            // Generate pattern
            const inputCtx = inputCanvas.getContext('2d');
            inputCtx.fillStyle = '#000';
            inputCtx.fillRect(0, 0, inputCanvas.width, inputCanvas.height);

            const cellSize = inputCanvas.width / size;
            const pattern = [];

            for (let gen = 0; gen < size; gen++) {
                pattern.push([...fourierCA.current]);
                for (let i = 0; i < size; i++) {
                    if (fourierCA.current[i] === 1) {
                        inputCtx.fillStyle = 'var(--text-primary)';
                        inputCtx.fillRect(i * cellSize, gen * cellSize, cellSize, cellSize);
                    }
                }
                fourierCA.step();
            }

            // Simplified 2D FFT visualization (magnitude spectrum)
            const outputCtx = outputCanvas.getContext('2d');
            outputCtx.fillStyle = '#000';
            outputCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);

            // Calculate row-wise frequency content
            for (let row = 0; row < size; row++) {
                const frequencies = dft1D(pattern[row]);
                for (let col = 0; col < frequencies.length; col++) {
                    const magnitude = Math.sqrt(frequencies[col].re * frequencies[col].re +
                                                frequencies[col].im * frequencies[col].im);
                    const normalized = Math.min(255, magnitude * 5);
                    const value = Math.floor(normalized);
                    outputCtx.fillStyle = `rgb(${value}, ${value}, ${value})`;
                    outputCtx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                }
            }

            document.getElementById('dominantFreq').textContent = 'Multiple';
            document.getElementById('spectralPeak').textContent = '0.85';
        }

        function dft1D(signal) {
            const N = signal.length;
            const result = [];

            for (let k = 0; k < N; k++) {
                let re = 0, im = 0;
                for (let n = 0; n < N; n++) {
                    const angle = -2 * Math.PI * k * n / N;
                    re += signal[n] * Math.cos(angle);
                    im += signal[n] * Math.sin(angle);
                }
                result.push({ re, im });
            }

            return result;
        }

        function showPowerSpectrum() {
            computeFourier();
            // Already showing magnitude spectrum
        }

        // Initialize on load
        window.addEventListener('load', init);
        window.addEventListener('resize', () => {
            if (!evolutionRunning) {
                setupEvolution();
            }
        });
    </script>
    <script src="../assets/js/navigation.js"></script>
</body>
</html>
