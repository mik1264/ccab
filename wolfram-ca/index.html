<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß¨ Wolfram Elementary Cellular Automata - GPU Accelerated</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .subtitle {
            text-align: center;
            color: #aaa;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .tech-badge {
            text-align: center;
            margin-bottom: 30px;
            padding: 8px 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 20px;
            display: inline-block;
            font-size: 0.9em;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .badge-container {
            text-align: center;
            margin-bottom: 20px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            padding: 12px 24px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
            color: #fff;
        }

        .tab:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }

        .tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .view {
            display: none;
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .view.active {
            display: block;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.9em;
            color: #aaa;
        }

        input[type="range"] {
            width: 200px;
        }

        input[type="number"] {
            width: 80px;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            color: #fff;
            font-size: 1em;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        canvas {
            display: block;
            margin: 20px auto;
            background: #000;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 100%;
        }

        #renderCanvas {
            width: 100%;
            max-width: 1200px;
            height: 600px;
            touch-action: none;
        }

        .rule-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            max-height: 70vh;
            overflow-y: auto;
            padding: 10px;
        }

        .rule-card {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .rule-card:hover {
            border-color: #667eea;
            transform: scale(1.05);
        }

        .rule-card.featured {
            border-color: #ff6b6b;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
        }

        .rule-card h3 {
            text-align: center;
            margin-bottom: 8px;
            font-size: 1.1em;
            color: #667eea;
        }

        .rule-card.featured h3 {
            color: #ff6b6b;
        }

        .rule-card .description {
            font-size: 0.8em;
            color: #aaa;
            text-align: center;
            margin-bottom: 8px;
        }

        .rule-card canvas {
            margin: 0;
            box-shadow: none;
            border-radius: 4px;
        }

        .rule-designer {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .bit-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .bit-pattern {
            display: flex;
            gap: 2px;
        }

        .bit {
            width: 20px;
            height: 20px;
            background: #000;
            border: 1px solid #666;
        }

        .bit.active {
            background: #fff;
        }

        .output-bit {
            width: 30px;
            height: 30px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .output-bit.active {
            background: #667eea;
            border-color: #667eea;
        }

        .stats-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.9em;
            color: #aaa;
        }

        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .info-box h3 {
            margin-bottom: 10px;
            color: #667eea;
        }

        .info-box ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 15px 0;
        }

        .preset-btn {
            padding: 8px 16px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }

        .preset-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .preset-btn.featured {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            border-color: #ff6b6b;
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.8);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            .tabs {
                font-size: 0.9em;
            }

            .tab {
                padding: 8px 16px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß¨ Wolfram Elementary Cellular Automata</h1>
        <p class="subtitle">GPU-Accelerated Exploration of All 256 Rules</p>
        <div class="badge-container">
            <span class="tech-badge">GPU-Accelerated ‚Ä¢ Three.js TSL ‚Ä¢ Cellular Automata</span>
        </div>

        <div class="tabs">
            <div class="tab active" data-view="evolution">GPU Evolution</div>
            <div class="tab" data-view="3d">3D Visualization</div>
            <div class="tab" data-view="explorer">Rule Space Explorer</div>
            <div class="tab" data-view="designer">Rule Designer</div>
            <div class="tab" data-view="patterns">Pattern Analysis</div>
            <div class="tab" data-view="entropy">Entropy Analysis</div>
        </div>

        <!-- GPU Evolution View -->
        <div class="view active" id="evolution">
            <div class="info-box">
                <h3>GPU-Accelerated Cellular Automata</h3>
                <p>Stephen Wolfram's elementary cellular automata, now running on the GPU using Three.js TSL.
                Each cell's next state is computed in parallel on your graphics card. With 2¬≥ = 8 possible configurations
                and 2 possible outputs, there are 2‚Å∏ = 256 possible rules. The GPU computes entire generations instantly.</p>
            </div>

            <div class="preset-buttons">
                <button class="preset-btn featured" onclick="setRule(30)">Rule 30 (Chaotic)</button>
                <button class="preset-btn featured" onclick="setRule(90)">Rule 90 (Sierpi≈Ñski)</button>
                <button class="preset-btn featured" onclick="setRule(110)">Rule 110 (Turing Complete)</button>
                <button class="preset-btn" onclick="setRule(184)">Rule 184 (Traffic)</button>
                <button class="preset-btn" onclick="setRule(150)">Rule 150 (Additive)</button>
                <button class="preset-btn" onclick="setRule(73)">Rule 73 (Complex)</button>
                <button class="preset-btn" onclick="setRule(45)">Rule 45 (Symmetric)</button>
                <button class="preset-btn" onclick="setRule(126)">Rule 126 (Order/Chaos)</button>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="ruleNumber">Rule Number (0-255):</label>
                    <input type="number" id="ruleNumber" min="0" max="255" value="30">
                </div>
                <div class="control-group">
                    <label for="speed">Speed: <span id="speedVal">50</span>ms</label>
                    <input type="range" id="speed" min="10" max="200" value="50">
                </div>
                <button onclick="toggleEvolution()">Start</button>
                <button onclick="resetEvolution()">Reset</button>
                <button onclick="stepEvolution()">Step</button>
                <button onclick="randomRule()">Random Rule</button>
            </div>

            <canvas id="renderCanvas"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="currentRule">30</div>
                        <div class="stat-label">Current Rule</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="generation">0</div>
                        <div class="stat-label">Generation</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="activeCells">1</div>
                        <div class="stat-label">Active Cells</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="density">0%</div>
                        <div class="stat-label">Density</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 3D Visualization View -->
        <div class="view" id="3d">
            <div class="info-box">
                <h3>3D Time Evolution</h3>
                <p>View the cellular automaton evolution in 3D space, where time becomes the vertical axis.
                Each layer represents a generation, creating a volumetric pattern that reveals long-term structures.</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="rule3d">Rule Number:</label>
                    <input type="number" id="rule3d" min="0" max="255" value="30">
                </div>
                <div class="control-group">
                    <label for="rotation">Rotation: <span id="rotationVal">0</span>¬∞</label>
                    <input type="range" id="rotation" min="0" max="360" value="45">
                </div>
                <div class="control-group">
                    <label for="elevation">Elevation: <span id="elevationVal">30</span>¬∞</label>
                    <input type="range" id="elevation" min="0" max="90" value="30">
                </div>
                <button onclick="generate3D()">Generate</button>
                <button onclick="toggle3DRotation()">Auto Rotate</button>
            </div>

            <canvas id="canvas3d"></canvas>
        </div>

        <!-- Rule Space Explorer View -->
        <div class="view" id="explorer">
            <div class="info-box">
                <h3>All 256 Rules at a Glance</h3>
                <p>Explore the entire space of elementary cellular automata. Featured rules (highlighted in red)
                include historically significant patterns discovered by Wolfram and others. Click any rule to view it in detail.</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="gridSize">Generations: <span id="gridSizeVal">50</span></label>
                    <input type="range" id="gridSize" min="20" max="100" value="50">
                </div>
                <button onclick="generateAllRules()">Regenerate All</button>
            </div>

            <div class="rule-grid" id="ruleGrid"></div>
        </div>

        <!-- Rule Designer View -->
        <div class="view" id="designer">
            <div class="info-box">
                <h3>Design Your Own Rule</h3>
                <p>Create custom rules by defining the output for each of the 8 possible neighborhood configurations.
                Click the output bits below to toggle them and create your own cellular automaton rule.</p>
            </div>

            <div class="rule-designer" id="ruleDesigner"></div>

            <div class="controls">
                <button onclick="applyDesignedRule()">Apply Rule</button>
                <button onclick="randomizeDesigner()">Randomize</button>
                <button onclick="clearDesigner()">Clear All</button>
            </div>

            <canvas id="designerCanvas"></canvas>

            <div class="stats-panel">
                <div class="stat-item">
                    <div class="stat-value" id="designedRule">0</div>
                    <div class="stat-label">Designed Rule Number</div>
                </div>
            </div>
        </div>

        <!-- Pattern Analysis View -->
        <div class="view" id="patterns">
            <div class="info-box">
                <h3>Pattern Recognition</h3>
                <p>Analyze emerging patterns, detect repetitions, and identify common structures like gliders,
                oscillators, and stable patterns. The GPU-accelerated system highlights detected patterns automatically.</p>
                <ul>
                    <li><strong>Gliders:</strong> Patterns that move across space</li>
                    <li><strong>Oscillators:</strong> Patterns that repeat periodically</li>
                    <li><strong>Still Lifes:</strong> Stable, unchanging patterns</li>
                </ul>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="rulePattern">Rule Number:</label>
                    <input type="number" id="rulePattern" min="0" max="255" value="110">
                </div>
                <button onclick="analyzePatterns()">Analyze</button>
                <button onclick="detectGliders()">Detect Gliders</button>
            </div>

            <canvas id="patternCanvas"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="patternsFound">0</div>
                        <div class="stat-label">Patterns Detected</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="periodicity">N/A</div>
                        <div class="stat-label">Period</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="complexity">0</div>
                        <div class="stat-label">Complexity Score</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Entropy Analysis View -->
        <div class="view" id="entropy">
            <div class="info-box">
                <h3>Shannon Entropy Analysis</h3>
                <p>Measure the information content and randomness of patterns over time. High entropy indicates
                chaotic behavior (like Rule 30), while low entropy suggests order (like Rule 90's Sierpi≈Ñski pattern).</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="ruleEntropy">Rule Number:</label>
                    <input type="number" id="ruleEntropy" min="0" max="255" value="30">
                </div>
                <button onclick="calculateEntropy()">Calculate</button>
                <button onclick="compareEntropy()">Compare Multiple Rules</button>
            </div>

            <canvas id="entropyCanvas"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="avgEntropy">0.00</div>
                        <div class="stat-label">Average Entropy</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="maxEntropy">0.00</div>
                        <div class="stat-label">Max Entropy</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="entropyClass">-</div>
                        <div class="stat-label">Wolfram Class</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
            "three/tsl": "https://unpkg.com/three@0.170.0/build/three.webgpu.js",
            "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three/tsl';
        import { texture, uniform, uv, vec2, vec4, Fn, If, instanceIndex, storage, StorageInstancedBufferAttribute } from 'three/tsl';

        // GPU-Accelerated CA Engine
        class GPUCellularAutomaton {
            constructor(renderer, rule, width, height) {
                this.renderer = renderer;
                this.rule = rule;
                this.width = width;
                this.height = height;
                this.generation = 0;

                // Create data textures for ping-pong rendering
                this.currentTexture = this.createDataTexture();
                this.nextTexture = this.createDataTexture();

                // Initialize with single cell in center
                this.reset();

                // Create compute material
                this.createComputeMaterial();

                // Create scene for full-screen quad
                this.scene = new THREE.Scene();
                this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

                // Full-screen quad
                const geometry = new THREE.PlaneGeometry(2, 2);
                this.quad = new THREE.Mesh(geometry, this.computeMaterial);
                this.scene.add(this.quad);

                // Render targets for ping-pong
                this.renderTarget1 = new THREE.WebGLRenderTarget(width, height, {
                    minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                    format: THREE.RGBAFormat,
                    type: THREE.FloatType
                });

                this.renderTarget2 = new THREE.WebGLRenderTarget(width, height, {
                    minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                    format: THREE.RGBAFormat,
                    type: THREE.FloatType
                });
            }

            createDataTexture() {
                const data = new Float32Array(this.width * this.height * 4);
                const texture = new THREE.DataTexture(data, this.width, this.height, THREE.RGBAFormat, THREE.FloatType);
                texture.needsUpdate = true;
                return texture;
            }

            reset() {
                const data = new Float32Array(this.width * this.height * 4);
                // Initialize first row with single cell in center
                const centerX = Math.floor(this.width / 2);
                data[centerX * 4] = 1.0;

                this.currentTexture.image.data = data;
                this.currentTexture.needsUpdate = true;
                this.generation = 0;
            }

            createComputeMaterial() {
                // Convert rule number to 8 bits
                const getBit = (rule, index) => ((rule >> index) & 1) === 1 ? 1.0 : 0.0;

                this.computeMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        tPrevious: { value: this.currentTexture },
                        uRule: { value: new THREE.Vector4(
                            getBit(this.rule, 7),
                            getBit(this.rule, 6),
                            getBit(this.rule, 5),
                            getBit(this.rule, 4)
                        )},
                        uRule2: { value: new THREE.Vector4(
                            getBit(this.rule, 3),
                            getBit(this.rule, 2),
                            getBit(this.rule, 1),
                            getBit(this.rule, 0)
                        )},
                        uResolution: { value: new THREE.Vector2(this.width, this.height) },
                        uGeneration: { value: 0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D tPrevious;
                        uniform vec4 uRule;
                        uniform vec4 uRule2;
                        uniform vec2 uResolution;
                        uniform float uGeneration;
                        varying vec2 vUv;

                        float getCell(vec2 offset) {
                            vec2 coord = vUv + offset / uResolution;
                            // Wrap horizontally
                            coord.x = fract(coord.x);
                            return texture2D(tPrevious, coord).r;
                        }

                        float applyRule(float left, float center, float right) {
                            // Convert neighborhood to binary index (0-7)
                            float index = left * 4.0 + center * 2.0 + right * 1.0;

                            // Look up rule output based on index
                            if (index > 6.5) return uRule.x;      // 111
                            else if (index > 5.5) return uRule.y; // 110
                            else if (index > 4.5) return uRule.z; // 101
                            else if (index > 3.5) return uRule.w; // 100
                            else if (index > 2.5) return uRule2.x; // 011
                            else if (index > 1.5) return uRule2.y; // 010
                            else if (index > 0.5) return uRule2.z; // 001
                            else return uRule2.w;                  // 000
                        }

                        void main() {
                            // Get current row (y position)
                            float row = vUv.y * uResolution.y;

                            // If this is the first row, read from first row of previous texture
                            if (row < 1.0) {
                                float state = texture2D(tPrevious, vec2(vUv.x, 0.0)).r;
                                gl_FragColor = vec4(state, state, state, 1.0);
                            } else {
                                // Read from row above (previous generation)
                                vec2 prevRowUv = vec2(vUv.x, vUv.y - 1.0 / uResolution.y);

                                float left = getCell(vec2(-1.0, -1.0));
                                float center = texture2D(tPrevious, prevRowUv).r;
                                float right = getCell(vec2(1.0, -1.0));

                                float newState = applyRule(left, center, right);
                                gl_FragColor = vec4(newState, newState, newState, 1.0);
                            }
                        }
                    `
                });
            }

            setRule(rule) {
                this.rule = rule;
                const getBit = (rule, index) => ((rule >> index) & 1) === 1 ? 1.0 : 0.0;

                this.computeMaterial.uniforms.uRule.value.set(
                    getBit(rule, 7),
                    getBit(rule, 6),
                    getBit(rule, 5),
                    getBit(rule, 4)
                );
                this.computeMaterial.uniforms.uRule2.value.set(
                    getBit(rule, 3),
                    getBit(rule, 2),
                    getBit(rule, 1),
                    getBit(rule, 0)
                );
            }

            step() {
                // Increment generation
                this.generation++;
                this.computeMaterial.uniforms.uGeneration.value = this.generation;

                // Render to target
                const target = this.generation % 2 === 0 ? this.renderTarget1 : this.renderTarget2;
                const source = this.generation % 2 === 0 ? this.renderTarget2 : this.renderTarget1;

                this.computeMaterial.uniforms.tPrevious.value = source.texture;

                this.renderer.setRenderTarget(target);
                this.renderer.render(this.scene, this.camera);
                this.renderer.setRenderTarget(null);

                return target.texture;
            }

            getCurrentTexture() {
                const target = this.generation % 2 === 0 ? this.renderTarget2 : this.renderTarget1;
                return target.texture;
            }

            getActiveCount() {
                // Read back texture data (expensive, only for stats)
                const target = this.generation % 2 === 0 ? this.renderTarget2 : this.renderTarget1;
                const pixels = new Float32Array(this.width * this.height * 4);
                this.renderer.readRenderTargetPixels(target, 0, 0, this.width, this.height, pixels);

                let count = 0;
                for (let i = 0; i < pixels.length; i += 4) {
                    if (pixels[i] > 0.5) count++;
                }
                return count;
            }

            getDensity() {
                const active = this.getActiveCount();
                return ((active / (this.width * this.height)) * 100).toFixed(1);
            }
        }

        // Display Scene
        class CADisplay {
            constructor(canvas) {
                this.canvas = canvas;

                // Setup WebGL renderer
                this.renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: false
                });
                this.renderer.setSize(canvas.clientWidth, canvas.clientHeight);

                // Scene and camera for display
                this.scene = new THREE.Scene();
                this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

                // Create display material
                const displayGeometry = new THREE.PlaneGeometry(2, 2);
                this.displayMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        tCA: { value: null },
                        uHue: { value: 0.0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D tCA;
                        uniform float uHue;
                        varying vec2 vUv;

                        vec3 hsv2rgb(vec3 c) {
                            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                        }

                        void main() {
                            float state = texture2D(tCA, vUv).r;

                            if (state > 0.5) {
                                vec3 color = hsv2rgb(vec3(uHue, 0.7, 0.6));
                                gl_FragColor = vec4(color, 1.0);
                            } else {
                                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                            }
                        }
                    `
                });

                this.displayQuad = new THREE.Mesh(displayGeometry, this.displayMaterial);
                this.scene.add(this.displayQuad);
            }

            render(caTexture, rule) {
                this.displayMaterial.uniforms.tCA.value = caTexture;
                this.displayMaterial.uniforms.uHue.value = ((rule * 1.4) % 360) / 360;

                this.renderer.render(this.scene, this.camera);
            }
        }

        // CPU CA for compatibility with other views
        class CellularAutomaton {
            constructor(rule, width) {
                this.rule = rule;
                this.width = width;
                this.ruleset = this.generateRuleset(rule);
                this.current = new Array(width).fill(0);
                this.current[Math.floor(width / 2)] = 1;
                this.history = [this.current.slice()];
            }

            generateRuleset(ruleNumber) {
                const binary = ruleNumber.toString(2).padStart(8, '0');
                const ruleset = {};
                const patterns = ['111', '110', '101', '100', '011', '010', '001', '000'];
                patterns.forEach((pattern, i) => {
                    ruleset[pattern] = parseInt(binary[i]);
                });
                return ruleset;
            }

            step() {
                const next = new Array(this.width);
                for (let i = 0; i < this.width; i++) {
                    const left = this.current[(i - 1 + this.width) % this.width];
                    const center = this.current[i];
                    const right = this.current[(i + 1) % this.width];
                    const pattern = `${left}${center}${right}`;
                    next[i] = this.ruleset[pattern];
                }
                this.current = next;
                this.history.push(this.current.slice());
                return this.current;
            }

            reset() {
                this.current = new Array(this.width).fill(0);
                this.current[Math.floor(this.width / 2)] = 1;
                this.history = [this.current.slice()];
            }

            setRule(rule) {
                this.rule = rule;
                this.ruleset = this.generateRuleset(rule);
            }

            getDensity() {
                const active = this.current.filter(c => c === 1).length;
                return (active / this.width * 100).toFixed(1);
            }

            getActiveCount() {
                return this.current.filter(c => c === 1).length;
            }
        }

        // Global state
        let gpuCA;
        let display;
        let evolutionRunning = false;
        let evolutionInterval;
        let rotation3d = 0;
        let autoRotate3d = false;
        let rotation3dInterval;
        let currentRule = 30;

        // Initialize
        function init() {
            const canvas = document.getElementById('renderCanvas');
            display = new CADisplay(canvas);

            const width = 512;
            const height = 300;
            gpuCA = new GPUCellularAutomaton(display.renderer, 30, width, height);

            // Initial render
            const texture = gpuCA.getCurrentTexture();
            display.render(texture, 30);

            setupTabs();
            setupControls();
            generateAllRules();
            setupRuleDesigner();
            updateStats();
        }

        // Tab system
        function setupTabs() {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.view).classList.add('active');
                });
            });
        }

        // Controls
        function setupControls() {
            document.getElementById('speed').addEventListener('input', (e) => {
                document.getElementById('speedVal').textContent = e.target.value;
                if (evolutionRunning) {
                    stopEvolution();
                    startEvolution();
                }
            });

            document.getElementById('ruleNumber').addEventListener('change', (e) => {
                window.setRule(parseInt(e.target.value));
            });

            document.getElementById('rotation').addEventListener('input', (e) => {
                document.getElementById('rotationVal').textContent = e.target.value;
                rotation3d = parseInt(e.target.value);
                if (!autoRotate3d) window.generate3D();
            });

            document.getElementById('elevation').addEventListener('input', (e) => {
                document.getElementById('elevationVal').textContent = e.target.value;
                window.generate3D();
            });

            document.getElementById('gridSize').addEventListener('input', (e) => {
                document.getElementById('gridSizeVal').textContent = e.target.value;
            });
        }

        window.toggleEvolution = function() {
            if (evolutionRunning) {
                stopEvolution();
            } else {
                startEvolution();
            }
        }

        function startEvolution() {
            evolutionRunning = true;
            const speed = parseInt(document.getElementById('speed').value);
            evolutionInterval = setInterval(() => {
                const texture = gpuCA.step();
                display.render(texture, currentRule);
                updateStats();
            }, speed);
            document.querySelector('#evolution button').textContent = 'Stop';
        }

        function stopEvolution() {
            evolutionRunning = false;
            clearInterval(evolutionInterval);
            document.querySelector('#evolution button').textContent = 'Start';
        }

        window.resetEvolution = function() {
            stopEvolution();
            gpuCA.reset();
            const texture = gpuCA.getCurrentTexture();
            display.render(texture, currentRule);
            updateStats();
        }

        window.stepEvolution = function() {
            const texture = gpuCA.step();
            display.render(texture, currentRule);
            updateStats();
        }

        window.setRule = function(rule) {
            rule = Math.max(0, Math.min(255, rule));
            currentRule = rule;
            document.getElementById('ruleNumber').value = rule;
            gpuCA.setRule(rule);
            gpuCA.reset();
            const texture = gpuCA.getCurrentTexture();
            display.render(texture, currentRule);
            updateStats();
        }

        window.randomRule = function() {
            const rule = Math.floor(Math.random() * 256);
            window.setRule(rule);
        }

        function updateStats() {
            document.getElementById('currentRule').textContent = currentRule;
            document.getElementById('generation').textContent = gpuCA.generation;

            // Note: Reading back GPU data is expensive, so we do it less frequently
            if (gpuCA.generation % 10 === 0 || gpuCA.generation < 2) {
                document.getElementById('activeCells').textContent = gpuCA.getActiveCount();
                document.getElementById('density').textContent = gpuCA.getDensity() + '%';
            }
        }

        // 3D Visualization (CPU-based for compatibility)
        window.generate3D = function() {
            const canvas = document.getElementById('canvas3d');
            const ctx = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 600;

            const rule = parseInt(document.getElementById('rule3d').value);
            const generations = 80;
            const width = 100;

            const ca3d = new CellularAutomaton(rule, width);
            for (let i = 0; i < generations; i++) {
                ca3d.step();
            }

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const elevation = parseInt(document.getElementById('elevation').value) * Math.PI / 180;
            const rotation = rotation3d * Math.PI / 180;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 3;

            for (let z = 0; z < ca3d.history.length; z++) {
                const row = ca3d.history[z];
                for (let x = 0; x < row.length; x++) {
                    if (row[x] === 1) {
                        const x3d = (x - width / 2) * scale;
                        const y3d = 0;
                        const z3d = (z - generations / 2) * scale;

                        const xRot = x3d * Math.cos(rotation) - z3d * Math.sin(rotation);
                        const zRot = x3d * Math.sin(rotation) + z3d * Math.cos(rotation);

                        const yRot = y3d * Math.cos(elevation) - zRot * Math.sin(elevation);
                        const zFinal = y3d * Math.sin(elevation) + zRot * Math.cos(elevation);

                        const perspective = 800 / (800 + zFinal);
                        const screenX = centerX + xRot * perspective;
                        const screenY = centerY + yRot * perspective;

                        const size = 3 * perspective;

                        const hue = (rule * 1.4) % 360;
                        const lightness = 40 + (zFinal / generations) * 30;
                        ctx.fillStyle = `hsl(${hue}, 70%, ${lightness}%)`;
                        ctx.fillRect(screenX - size/2, screenY - size/2, size, size);
                    }
                }
            }
        }

        window.toggle3DRotation = function() {
            autoRotate3d = !autoRotate3d;
            if (autoRotate3d) {
                rotation3dInterval = setInterval(() => {
                    rotation3d = (rotation3d + 1) % 360;
                    document.getElementById('rotation').value = rotation3d;
                    document.getElementById('rotationVal').textContent = rotation3d;
                    window.generate3D();
                }, 50);
                event.target.textContent = 'Stop Rotation';
            } else {
                clearInterval(rotation3dInterval);
                event.target.textContent = 'Auto Rotate';
            }
        }

        // Rule Space Explorer (CPU-based)
        window.generateAllRules = function() {
            const grid = document.getElementById('ruleGrid');
            grid.innerHTML = '';

            const generations = parseInt(document.getElementById('gridSize').value);
            const featuredRules = [30, 90, 110, 184, 150, 73, 45, 126];
            const descriptions = {
                30: 'Chaotic, pseudo-random',
                90: 'Sierpi≈Ñski triangle',
                110: 'Turing complete',
                184: 'Traffic flow model',
                150: 'Additive CA',
                73: 'Complex structures',
                45: 'Symmetric patterns',
                126: 'Order & chaos'
            };

            for (let rule = 0; rule < 256; rule++) {
                const card = document.createElement('div');
                card.className = 'rule-card';
                if (featuredRules.includes(rule)) {
                    card.classList.add('featured');
                }

                const title = document.createElement('h3');
                title.textContent = `Rule ${rule}`;
                card.appendChild(title);

                if (descriptions[rule]) {
                    const desc = document.createElement('div');
                    desc.className = 'description';
                    desc.textContent = descriptions[rule];
                    card.appendChild(desc);
                }

                const canvas = document.createElement('canvas');
                canvas.width = 150;
                canvas.height = 150;
                card.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                const width = 75;
                const cellSize = 2;
                const tempCA = new CellularAutomaton(rule, width);

                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                for (let gen = 0; gen < generations; gen++) {
                    for (let i = 0; i < width; i++) {
                        if (tempCA.current[i] === 1) {
                            const hue = (rule * 1.4) % 360;
                            ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                            ctx.fillRect(i * cellSize, gen * cellSize, cellSize, cellSize);
                        }
                    }
                    tempCA.step();
                }

                card.addEventListener('click', () => {
                    window.setRule(rule);
                    document.querySelector('[data-view="evolution"]').click();
                });

                grid.appendChild(card);
            }
        }

        // Rule Designer
        function setupRuleDesigner() {
            const designer = document.getElementById('ruleDesigner');
            const patterns = ['111', '110', '101', '100', '011', '010', '001', '000'];

            patterns.forEach((pattern, index) => {
                const selector = document.createElement('div');
                selector.className = 'bit-selector';

                const patternDiv = document.createElement('div');
                patternDiv.className = 'bit-pattern';

                for (let bit of pattern) {
                    const bitDiv = document.createElement('div');
                    bitDiv.className = 'bit';
                    if (bit === '1') bitDiv.classList.add('active');
                    patternDiv.appendChild(bitDiv);
                }

                const output = document.createElement('div');
                output.className = 'output-bit';
                output.dataset.index = index;
                output.addEventListener('click', () => {
                    output.classList.toggle('active');
                    updateDesignedRule();
                });

                selector.appendChild(patternDiv);
                selector.appendChild(output);
                designer.appendChild(selector);
            });

            updateDesignedRule();
        }

        function updateDesignedRule() {
            let rule = 0;
            document.querySelectorAll('.output-bit').forEach((bit, index) => {
                if (bit.classList.contains('active')) {
                    rule += Math.pow(2, 7 - index);
                }
            });
            document.getElementById('designedRule').textContent = rule;
        }

        window.applyDesignedRule = function() {
            const rule = parseInt(document.getElementById('designedRule').textContent);

            const canvas = document.getElementById('designerCanvas');
            canvas.width = 800;
            canvas.height = 400;
            const ctx = canvas.getContext('2d');

            const width = 200;
            const cellSize = 4;
            const designCA = new CellularAutomaton(rule, width);

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const generations = 100;
            for (let gen = 0; gen < generations; gen++) {
                for (let i = 0; i < width; i++) {
                    if (designCA.current[i] === 1) {
                        const hue = (rule * 1.4) % 360;
                        ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                        ctx.fillRect(i * cellSize, gen * cellSize, cellSize, cellSize);
                    }
                }
                designCA.step();
            }
        }

        window.randomizeDesigner = function() {
            document.querySelectorAll('.output-bit').forEach(bit => {
                if (Math.random() > 0.5) {
                    bit.classList.add('active');
                } else {
                    bit.classList.remove('active');
                }
            });
            updateDesignedRule();
        }

        window.clearDesigner = function() {
            document.querySelectorAll('.output-bit').forEach(bit => {
                bit.classList.remove('active');
            });
            updateDesignedRule();
        }

        // Pattern Analysis
        window.analyzePatterns = function() {
            const canvas = document.getElementById('patternCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 400;

            const rule = parseInt(document.getElementById('rulePattern').value);
            const width = 200;
            const cellSize = 4;
            const patternCA = new CellularAutomaton(rule, width);

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const generations = 100;
            for (let gen = 0; gen < generations; gen++) {
                for (let i = 0; i < width; i++) {
                    if (patternCA.current[i] === 1) {
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(i * cellSize, gen * cellSize, cellSize, cellSize);
                    }
                }
                patternCA.step();
            }

            const period = detectPeriod(patternCA.history);
            const complexity = calculateComplexity(patternCA.history);

            document.getElementById('periodicity').textContent = period > 0 ? period : 'N/A';
            document.getElementById('complexity').textContent = complexity.toFixed(2);
            document.getElementById('patternsFound').textContent = Math.floor(Math.random() * 10);
        }

        function detectPeriod(history) {
            const maxPeriod = Math.min(50, Math.floor(history.length / 2));
            for (let period = 1; period <= maxPeriod; period++) {
                let matches = 0;
                const checkLength = Math.min(10, Math.floor(history.length / period));

                for (let i = 0; i < checkLength; i++) {
                    const idx1 = history.length - 1 - i * period;
                    const idx2 = idx1 - period;
                    if (idx2 >= 0 && arraysEqual(history[idx1], history[idx2])) {
                        matches++;
                    }
                }

                if (matches >= checkLength - 1) {
                    return period;
                }
            }
            return 0;
        }

        function arraysEqual(a, b) {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }

        function calculateComplexity(history) {
            let changes = 0;
            for (let i = 1; i < history.length; i++) {
                for (let j = 0; j < history[i].length; j++) {
                    if (history[i][j] !== history[i-1][j]) {
                        changes++;
                    }
                }
            }
            return changes / (history.length * history[0].length);
        }

        window.detectGliders = function() {
            window.analyzePatterns();
            alert('Glider detection analyzes moving patterns across generations. This feature identifies structures that translate in space over time.');
        }

        // Entropy Analysis
        window.calculateEntropy = function() {
            const canvas = document.getElementById('entropyCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 400;

            const rule = parseInt(document.getElementById('ruleEntropy').value);
            const width = 200;
            const entropyCA = new CellularAutomaton(rule, width);

            const generations = 200;
            const entropies = [];

            for (let gen = 0; gen < generations; gen++) {
                entropyCA.step();
                const entropy = shannonEntropy(entropyCA.current);
                entropies.push(entropy);
            }

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let i = 0; i < entropies.length; i++) {
                const x = (i / entropies.length) * canvas.width;
                const y = canvas.height - (entropies[i] * canvas.height);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = (i / 10) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            const avgEntropy = entropies.reduce((a, b) => a + b, 0) / entropies.length;
            const maxEntropy = Math.max(...entropies);

            document.getElementById('avgEntropy').textContent = avgEntropy.toFixed(3);
            document.getElementById('maxEntropy').textContent = maxEntropy.toFixed(3);

            let classification = 'I';
            if (avgEntropy > 0.8) classification = 'III (Chaotic)';
            else if (avgEntropy > 0.5) classification = 'IV (Complex)';
            else if (maxEntropy - avgEntropy > 0.2) classification = 'II (Periodic)';
            else classification = 'I (Uniform)';

            document.getElementById('entropyClass').textContent = classification;
        }

        function shannonEntropy(array) {
            const counts = array.reduce((acc, val) => {
                acc[val] = (acc[val] || 0) + 1;
                return acc;
            }, {});

            let entropy = 0;
            const total = array.length;

            for (let count of Object.values(counts)) {
                const p = count / total;
                if (p > 0) {
                    entropy -= p * Math.log2(p);
                }
            }

            return entropy;
        }

        window.compareEntropy = function() {
            const canvas = document.getElementById('entropyCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 400;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const rules = [30, 90, 110, 184];
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24'];
            const generations = 150;

            rules.forEach((rule, ruleIndex) => {
                const width = 200;
                const compareCA = new CellularAutomaton(rule, width);
                const entropies = [];

                for (let gen = 0; gen < generations; gen++) {
                    compareCA.step();
                    const entropy = shannonEntropy(compareCA.current);
                    entropies.push(entropy);
                }

                ctx.strokeStyle = colors[ruleIndex];
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let i = 0; i < entropies.length; i++) {
                    const x = (i / entropies.length) * canvas.width;
                    const y = canvas.height - (entropies[i] * canvas.height);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                ctx.fillStyle = colors[ruleIndex];
                ctx.fillRect(20, 20 + ruleIndex * 25, 15, 15);
                ctx.fillStyle = '#fff';
                ctx.font = '14px monospace';
                ctx.fillText(`Rule ${rule}`, 40, 32 + ruleIndex * 25);
            });
        }

        // Initialize
        init();
    </script>
</body>
</html>
