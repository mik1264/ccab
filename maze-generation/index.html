<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Generation Algorithms - CCAB</title>
    <meta name="description" content="Interactive maze generation with DFS, Prim's, Kruskal's, and Recursive Division algorithms. Watch mazes build step-by-step and solve them with pathfinding.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e8e6e1;
            overflow: hidden;
        }
        #container { display: flex; height: 100vh; }
        #canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        canvas {
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }
        #controls {
            width: 300px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid #333;
            backdrop-filter: blur(10px);
        }
        h2 {
            color: #00d4aa;
            margin-bottom: 15px;
            font-size: 1.4em;
            border-bottom: 1px solid #00d4aa;
            padding-bottom: 10px;
        }
        h3 {
            color: #4dd0e1;
            margin: 15px 0 10px;
            font-size: 0.95em;
        }
        .control-group { margin-bottom: 12px; }
        label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 0.85em;
        }
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
            accent-color: #00d4aa;
        }
        .value {
            color: #00d4aa;
            font-weight: bold;
            float: right;
        }
        select {
            width: 100%;
            padding: 8px;
            background: #222;
            border: 1px solid #444;
            color: #fff;
            border-radius: 4px;
            font-size: 0.9em;
        }
        button {
            width: 48%;
            padding: 10px;
            margin: 5px 1%;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s;
        }
        .generate-btn { background: #00d4aa; color: #000; }
        .generate-btn:hover { background: #00eebb; }
        .solve-btn { background: #4dd0e1; color: #000; }
        .solve-btn:hover { background: #80deea; }
        .reset-btn { background: #ff5722; color: white; }
        .reset-btn:hover { background: #ff7043; }
        .step-btn { background: #9c27b0; color: white; }
        .step-btn:hover { background: #ba68c8; }
        .stats-panel {
            background: rgba(0, 212, 170, 0.1);
            border: 1px solid #00d4aa;
            border-radius: 5px;
            padding: 10px;
            margin-top: 15px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 0.8em;
        }
        .stat-label { color: #888; }
        .stat-value { color: #00d4aa; font-weight: bold; }
        .info-box {
            background: rgba(0, 212, 170, 0.1);
            border-left: 3px solid #00d4aa;
            padding: 10px;
            margin-top: 15px;
            font-size: 0.75em;
            line-height: 1.5;
        }
        .back-link {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00d4aa;
            text-decoration: none;
            font-size: 0.9em;
            z-index: 100;
            background: rgba(0,0,0,0.5);
            padding: 8px 12px;
            border-radius: 5px;
        }
        .back-link:hover { color: #00eebb; }
        .legend { margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px; }
        .legend-item { display: flex; align-items: center; margin: 5px 0; font-size: 0.75em; }
        .legend-color { width: 16px; height: 16px; margin-right: 8px; border-radius: 3px; }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        <div id="controls">
            <h2>üè∞ Maze Generation</h2>

            <h3>Algorithm</h3>
            <div class="control-group">
                <select id="algorithm">
                    <option value="dfs">DFS / Recursive Backtracker</option>
                    <option value="prim">Randomized Prim's</option>
                    <option value="kruskal">Randomized Kruskal's</option>
                    <option value="division">Recursive Division</option>
                    <option value="eller">Eller's Algorithm</option>
                </select>
            </div>

            <h3>Maze Size</h3>
            <div class="control-group">
                <label>Width: <span class="value" id="width-val">31</span> cells</label>
                <input type="range" id="width" min="11" max="81" step="2" value="31">
            </div>
            <div class="control-group">
                <label>Height: <span class="value" id="height-val">31</span> cells</label>
                <input type="range" id="height" min="11" max="61" step="2" value="31">
            </div>

            <h3>Animation</h3>
            <div class="control-group">
                <label>Speed: <span class="value" id="speed-val">20</span> steps/frame</label>
                <input type="range" id="speed" min="1" max="100" step="1" value="20">
            </div>

            <h3>Solve Algorithm</h3>
            <div class="control-group">
                <select id="solver">
                    <option value="astar">A* Pathfinding</option>
                    <option value="bfs">Breadth-First Search</option>
                    <option value="dfs">Depth-First Search</option>
                </select>
            </div>

            <div style="margin: 15px 0;">
                <button class="generate-btn" onclick="generate()">Generate</button>
                <button class="solve-btn" onclick="solve()">Solve</button>
            </div>
            <div>
                <button class="step-btn" onclick="stepMode()">Step Mode</button>
                <button class="reset-btn" onclick="reset()">Reset</button>
            </div>

            <div class="stats-panel">
                <div class="stat-row">
                    <span class="stat-label">Status:</span>
                    <span class="stat-value" id="status-stat">Ready</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Cells Visited:</span>
                    <span class="stat-value" id="visited-stat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Walls Removed:</span>
                    <span class="stat-value" id="walls-stat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Solution Length:</span>
                    <span class="stat-value" id="path-stat">--</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Dead Ends:</span>
                    <span class="stat-value" id="deadends-stat">0</span>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #1a1a2e;"></div>
                    <span>Wall</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #fff;"></div>
                    <span>Passage</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00d4aa;"></div>
                    <span>Current / Active</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4dd0e1;"></div>
                    <span>Visited</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff5722;"></div>
                    <span>Solution Path</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4caf50;"></div>
                    <span>Start</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f44336;"></div>
                    <span>End</span>
                </div>
            </div>

            <div class="info-box">
                <strong>Algorithms:</strong><br>
                <strong>DFS:</strong> Long winding corridors, few dead ends<br>
                <strong>Prim's:</strong> Many short dead ends<br>
                <strong>Kruskal's:</strong> High branching factor<br>
                <strong>Division:</strong> Rectangular rooms<br>
                <strong>Eller's:</strong> Row-by-row, memory efficient
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let mazeWidth = 31;
        let mazeHeight = 31;
        let cellSize = 12;
        let speed = 20;
        let grid = [];
        let generating = false;
        let solving = false;
        let stepping = false;
        let animationId = null;

        // Stats
        let visitedCount = 0;
        let wallsRemoved = 0;
        let solutionPath = [];

        // Algorithm state
        let genState = null;

        const WALL = 1;
        const PASSAGE = 0;
        const VISITED = 2;
        const CURRENT = 3;
        const PATH = 4;
        const START = 5;
        const END = 6;

        function resize() {
            const container = document.getElementById('canvas-container');
            const maxW = container.clientWidth - 40;
            const maxH = container.clientHeight - 40;

            cellSize = Math.min(
                Math.floor(maxW / mazeWidth),
                Math.floor(maxH / mazeHeight),
                20
            );
            cellSize = Math.max(cellSize, 4);

            canvas.width = mazeWidth * cellSize;
            canvas.height = mazeHeight * cellSize;
        }

        function initGrid() {
            grid = [];
            for (let y = 0; y < mazeHeight; y++) {
                grid[y] = [];
                for (let x = 0; x < mazeWidth; x++) {
                    grid[y][x] = WALL;
                }
            }
            visitedCount = 0;
            wallsRemoved = 0;
            solutionPath = [];
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    let color;
                    switch (grid[y][x]) {
                        case WALL: color = '#1a1a2e'; break;
                        case PASSAGE: color = '#ffffff'; break;
                        case VISITED: color = 'rgba(77, 208, 225, 0.4)'; break;
                        case CURRENT: color = '#00d4aa'; break;
                        case PATH: color = '#ff5722'; break;
                        case START: color = '#4caf50'; break;
                        case END: color = '#f44336'; break;
                        default: color = '#ffffff';
                    }

                    if (grid[y][x] !== WALL) {
                        ctx.fillStyle = color;
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }

            updateStats();
        }

        function updateStats() {
            document.getElementById('visited-stat').textContent = visitedCount;
            document.getElementById('walls-stat').textContent = wallsRemoved;
            document.getElementById('path-stat').textContent = solutionPath.length > 0 ? solutionPath.length : '--';

            // Count dead ends
            let deadEnds = 0;
            for (let y = 1; y < mazeHeight - 1; y += 2) {
                for (let x = 1; x < mazeWidth - 1; x += 2) {
                    if (grid[y][x] !== WALL) {
                        let neighbors = 0;
                        if (grid[y-1] && grid[y-1][x] !== WALL) neighbors++;
                        if (grid[y+1] && grid[y+1][x] !== WALL) neighbors++;
                        if (grid[y][x-1] !== WALL) neighbors++;
                        if (grid[y][x+1] !== WALL) neighbors++;
                        if (neighbors === 1) deadEnds++;
                    }
                }
            }
            document.getElementById('deadends-stat').textContent = deadEnds;
        }

        // DFS / Recursive Backtracker
        function initDFS() {
            const startX = 1;
            const startY = 1;
            grid[startY][startX] = PASSAGE;
            visitedCount = 1;

            return {
                stack: [{x: startX, y: startY}],
                done: false
            };
        }

        function stepDFS(state) {
            if (state.stack.length === 0) {
                state.done = true;
                return;
            }

            const current = state.stack[state.stack.length - 1];

            // Clear previous current markers
            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (grid[y][x] === CURRENT) grid[y][x] = PASSAGE;
                }
            }
            grid[current.y][current.x] = CURRENT;

            // Get unvisited neighbors (2 cells away)
            const neighbors = [];
            const dirs = [{dx: 0, dy: -2}, {dx: 2, dy: 0}, {dx: 0, dy: 2}, {dx: -2, dy: 0}];

            for (const dir of dirs) {
                const nx = current.x + dir.dx;
                const ny = current.y + dir.dy;
                if (nx > 0 && nx < mazeWidth - 1 && ny > 0 && ny < mazeHeight - 1) {
                    if (grid[ny][nx] === WALL) {
                        neighbors.push({x: nx, y: ny, wx: current.x + dir.dx/2, wy: current.y + dir.dy/2});
                    }
                }
            }

            if (neighbors.length > 0) {
                const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                grid[next.wy][next.wx] = PASSAGE;
                grid[next.y][next.x] = PASSAGE;
                wallsRemoved++;
                visitedCount++;
                state.stack.push({x: next.x, y: next.y});
            } else {
                state.stack.pop();
            }
        }

        // Randomized Prim's
        function initPrim() {
            const startX = 1;
            const startY = 1;
            grid[startY][startX] = PASSAGE;
            visitedCount = 1;

            const walls = [];
            addWalls(startX, startY, walls);

            return { walls, done: false };
        }

        function addWalls(x, y, walls) {
            const dirs = [{dx: 0, dy: -2}, {dx: 2, dy: 0}, {dx: 0, dy: 2}, {dx: -2, dy: 0}];
            for (const dir of dirs) {
                const nx = x + dir.dx;
                const ny = y + dir.dy;
                if (nx > 0 && nx < mazeWidth - 1 && ny > 0 && ny < mazeHeight - 1) {
                    if (grid[ny][nx] === WALL) {
                        walls.push({x: nx, y: ny, wx: x + dir.dx/2, wy: y + dir.dy/2});
                    }
                }
            }
        }

        function stepPrim(state) {
            // Clear previous current markers
            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (grid[y][x] === CURRENT || grid[y][x] === VISITED) grid[y][x] = PASSAGE;
                }
            }

            // Show frontier
            for (const w of state.walls) {
                if (grid[w.y][w.x] === WALL) {
                    grid[w.wy][w.wx] = VISITED;
                }
            }

            if (state.walls.length === 0) {
                state.done = true;
                return;
            }

            const idx = Math.floor(Math.random() * state.walls.length);
            const wall = state.walls[idx];
            state.walls.splice(idx, 1);

            if (grid[wall.y][wall.x] === WALL) {
                grid[wall.wy][wall.wx] = PASSAGE;
                grid[wall.y][wall.x] = CURRENT;
                wallsRemoved++;
                visitedCount++;
                addWalls(wall.x, wall.y, state.walls);
            }
        }

        // Randomized Kruskal's
        function initKruskal() {
            const sets = [];
            const edges = [];
            let setId = 0;

            // Initialize cells and sets
            for (let y = 1; y < mazeHeight - 1; y += 2) {
                for (let x = 1; x < mazeWidth - 1; x += 2) {
                    grid[y][x] = PASSAGE;
                    sets.push({id: setId, cells: [{x, y}]});
                    setId++;
                }
            }

            // Initialize edges (walls between cells)
            for (let y = 1; y < mazeHeight - 1; y += 2) {
                for (let x = 1; x < mazeWidth - 1; x += 2) {
                    if (x + 2 < mazeWidth - 1) {
                        edges.push({x1: x, y1: y, x2: x + 2, y2: y, wx: x + 1, wy: y});
                    }
                    if (y + 2 < mazeHeight - 1) {
                        edges.push({x1: x, y1: y, x2: x, y2: y + 2, wx: x, wy: y + 1});
                    }
                }
            }

            // Shuffle edges
            for (let i = edges.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [edges[i], edges[j]] = [edges[j], edges[i]];
            }

            visitedCount = sets.length;
            return { sets, edges, cellToSet: new Map(), done: false };
        }

        function findSet(sets, x, y) {
            for (const set of sets) {
                for (const cell of set.cells) {
                    if (cell.x === x && cell.y === y) return set;
                }
            }
            return null;
        }

        function stepKruskal(state) {
            // Clear markers
            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (grid[y][x] === CURRENT) grid[y][x] = PASSAGE;
                }
            }

            if (state.edges.length === 0) {
                state.done = true;
                return;
            }

            const edge = state.edges.pop();
            const set1 = findSet(state.sets, edge.x1, edge.y1);
            const set2 = findSet(state.sets, edge.x2, edge.y2);

            if (set1 && set2 && set1.id !== set2.id) {
                grid[edge.wy][edge.wx] = CURRENT;
                wallsRemoved++;

                // Merge sets
                for (const cell of set2.cells) {
                    set1.cells.push(cell);
                }
                set2.cells = [];
                set2.id = set1.id;
            }
        }

        // Recursive Division
        function initDivision() {
            // Start with all passages
            for (let y = 1; y < mazeHeight - 1; y++) {
                for (let x = 1; x < mazeWidth - 1; x++) {
                    grid[y][x] = PASSAGE;
                }
            }
            visitedCount = (mazeWidth - 2) * (mazeHeight - 2);

            return {
                chambers: [{x: 1, y: 1, w: mazeWidth - 2, h: mazeHeight - 2}],
                done: false
            };
        }

        function stepDivision(state) {
            // Clear markers
            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (grid[y][x] === CURRENT) grid[y][x] = PASSAGE;
                }
            }

            if (state.chambers.length === 0) {
                state.done = true;
                return;
            }

            const chamber = state.chambers.pop();
            if (chamber.w < 2 || chamber.h < 2) return;

            const horizontal = chamber.w < chamber.h ? true : (chamber.h < chamber.w ? false : Math.random() < 0.5);

            if (horizontal) {
                if (chamber.h < 2) return;
                const wallY = chamber.y + 1 + Math.floor(Math.random() * (chamber.h - 1));
                const holeX = chamber.x + Math.floor(Math.random() * chamber.w);

                for (let x = chamber.x; x < chamber.x + chamber.w; x++) {
                    if (x !== holeX) {
                        grid[wallY][x] = WALL;
                        wallsRemoved++;
                    }
                    grid[wallY][x] = x === holeX ? CURRENT : WALL;
                }

                if (wallY - chamber.y > 1) {
                    state.chambers.push({x: chamber.x, y: chamber.y, w: chamber.w, h: wallY - chamber.y});
                }
                if (chamber.y + chamber.h - wallY - 1 > 1) {
                    state.chambers.push({x: chamber.x, y: wallY + 1, w: chamber.w, h: chamber.y + chamber.h - wallY - 1});
                }
            } else {
                if (chamber.w < 2) return;
                const wallX = chamber.x + 1 + Math.floor(Math.random() * (chamber.w - 1));
                const holeY = chamber.y + Math.floor(Math.random() * chamber.h);

                for (let y = chamber.y; y < chamber.y + chamber.h; y++) {
                    grid[y][wallX] = y === holeY ? CURRENT : WALL;
                    wallsRemoved++;
                }

                if (wallX - chamber.x > 1) {
                    state.chambers.push({x: chamber.x, y: chamber.y, w: wallX - chamber.x, h: chamber.h});
                }
                if (chamber.x + chamber.w - wallX - 1 > 1) {
                    state.chambers.push({x: wallX + 1, y: chamber.y, w: chamber.x + chamber.w - wallX - 1, h: chamber.h});
                }
            }
        }

        // Eller's Algorithm
        function initEller() {
            let setId = 0;
            const row = [];
            for (let x = 1; x < mazeWidth - 1; x += 2) {
                grid[1][x] = PASSAGE;
                row.push({x, set: setId++});
                visitedCount++;
            }
            return { row, currentY: 1, setId, done: false };
        }

        function stepEller(state) {
            // Clear markers
            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (grid[y][x] === CURRENT) grid[y][x] = PASSAGE;
                }
            }

            if (state.currentY >= mazeHeight - 2) {
                // Connect all in last row
                for (let i = 0; i < state.row.length - 1; i++) {
                    if (state.row[i].set !== state.row[i + 1].set) {
                        const wx = state.row[i].x + 1;
                        grid[state.currentY][wx] = CURRENT;
                        wallsRemoved++;
                        const oldSet = state.row[i + 1].set;
                        for (const cell of state.row) {
                            if (cell.set === oldSet) cell.set = state.row[i].set;
                        }
                    }
                }
                state.done = true;
                return;
            }

            // Randomly join adjacent cells in same row
            for (let i = 0; i < state.row.length - 1; i++) {
                if (state.row[i].set !== state.row[i + 1].set && Math.random() < 0.5) {
                    const wx = state.row[i].x + 1;
                    grid[state.currentY][wx] = PASSAGE;
                    wallsRemoved++;
                    const oldSet = state.row[i + 1].set;
                    for (const cell of state.row) {
                        if (cell.set === oldSet) cell.set = state.row[i].set;
                    }
                }
            }

            // Create vertical connections
            const sets = {};
            for (const cell of state.row) {
                if (!sets[cell.set]) sets[cell.set] = [];
                sets[cell.set].push(cell);
            }

            const nextY = state.currentY + 2;
            const newRow = [];

            for (const setId in sets) {
                const cells = sets[setId];
                // At least one cell must connect down
                const numConnections = 1 + Math.floor(Math.random() * cells.length);
                const shuffled = [...cells].sort(() => Math.random() - 0.5);

                for (let i = 0; i < cells.length; i++) {
                    const cell = shuffled[i];
                    if (i < numConnections) {
                        grid[state.currentY + 1][cell.x] = PASSAGE;
                        grid[nextY][cell.x] = CURRENT;
                        wallsRemoved++;
                        visitedCount++;
                        newRow.push({x: cell.x, set: parseInt(setId)});
                    }
                }
            }

            // Add new cells with new sets
            for (let x = 1; x < mazeWidth - 1; x += 2) {
                if (!newRow.find(c => c.x === x)) {
                    grid[nextY][x] = PASSAGE;
                    visitedCount++;
                    newRow.push({x, set: state.setId++});
                }
            }

            newRow.sort((a, b) => a.x - b.x);
            state.row = newRow;
            state.currentY = nextY;
        }

        // Pathfinding
        function solve() {
            if (generating) return;

            const algo = document.getElementById('solver').value;
            document.getElementById('status-stat').textContent = 'Solving...';

            // Clear previous solution
            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (grid[y][x] === PATH || grid[y][x] === VISITED || grid[y][x] === CURRENT) {
                        grid[y][x] = PASSAGE;
                    }
                }
            }

            const start = {x: 1, y: 1};
            const end = {x: mazeWidth - 2, y: mazeHeight - 2};

            grid[start.y][start.x] = START;
            grid[end.y][end.x] = END;

            let path;
            switch (algo) {
                case 'astar': path = astar(start, end); break;
                case 'bfs': path = bfs(start, end); break;
                case 'dfs': path = dfsSolve(start, end); break;
            }

            if (path) {
                solutionPath = path;
                for (const p of path) {
                    if (grid[p.y][p.x] !== START && grid[p.y][p.x] !== END) {
                        grid[p.y][p.x] = PATH;
                    }
                }
                document.getElementById('status-stat').textContent = 'Solved!';
            } else {
                document.getElementById('status-stat').textContent = 'No path!';
            }

            draw();
        }

        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        function astar(start, end) {
            const openSet = [start];
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();

            const key = (p) => `${p.x},${p.y}`;
            gScore.set(key(start), 0);
            fScore.set(key(start), heuristic(start, end));

            while (openSet.length > 0) {
                openSet.sort((a, b) => (fScore.get(key(a)) || Infinity) - (fScore.get(key(b)) || Infinity));
                const current = openSet.shift();

                if (current.x === end.x && current.y === end.y) {
                    const path = [current];
                    let c = current;
                    while (cameFrom.has(key(c))) {
                        c = cameFrom.get(key(c));
                        path.unshift(c);
                    }
                    return path;
                }

                const dirs = [{dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: -1, dy: 0}];
                for (const dir of dirs) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    if (nx >= 0 && nx < mazeWidth && ny >= 0 && ny < mazeHeight) {
                        if (grid[ny][nx] !== WALL) {
                            const tentative = (gScore.get(key(current)) || 0) + 1;
                            const neighbor = {x: nx, y: ny};
                            if (tentative < (gScore.get(key(neighbor)) || Infinity)) {
                                cameFrom.set(key(neighbor), current);
                                gScore.set(key(neighbor), tentative);
                                fScore.set(key(neighbor), tentative + heuristic(neighbor, end));
                                if (!openSet.find(n => n.x === nx && n.y === ny)) {
                                    openSet.push(neighbor);
                                }
                            }
                        }
                    }
                }
            }
            return null;
        }

        function bfs(start, end) {
            const queue = [start];
            const visited = new Set();
            const cameFrom = new Map();
            const key = (p) => `${p.x},${p.y}`;
            visited.add(key(start));

            while (queue.length > 0) {
                const current = queue.shift();

                if (current.x === end.x && current.y === end.y) {
                    const path = [current];
                    let c = current;
                    while (cameFrom.has(key(c))) {
                        c = cameFrom.get(key(c));
                        path.unshift(c);
                    }
                    return path;
                }

                const dirs = [{dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: -1, dy: 0}];
                for (const dir of dirs) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    const nk = `${nx},${ny}`;
                    if (nx >= 0 && nx < mazeWidth && ny >= 0 && ny < mazeHeight) {
                        if (grid[ny][nx] !== WALL && !visited.has(nk)) {
                            visited.add(nk);
                            cameFrom.set(nk, current);
                            queue.push({x: nx, y: ny});
                        }
                    }
                }
            }
            return null;
        }

        function dfsSolve(start, end) {
            const stack = [start];
            const visited = new Set();
            const cameFrom = new Map();
            const key = (p) => `${p.x},${p.y}`;

            while (stack.length > 0) {
                const current = stack.pop();
                const ck = key(current);

                if (visited.has(ck)) continue;
                visited.add(ck);

                if (current.x === end.x && current.y === end.y) {
                    const path = [current];
                    let c = current;
                    while (cameFrom.has(key(c))) {
                        c = cameFrom.get(key(c));
                        path.unshift(c);
                    }
                    return path;
                }

                const dirs = [{dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: -1, dy: 0}];
                for (const dir of dirs) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    const nk = `${nx},${ny}`;
                    if (nx >= 0 && nx < mazeWidth && ny >= 0 && ny < mazeHeight) {
                        if (grid[ny][nx] !== WALL && !visited.has(nk)) {
                            cameFrom.set(nk, current);
                            stack.push({x: nx, y: ny});
                        }
                    }
                }
            }
            return null;
        }

        function generate() {
            if (animationId) cancelAnimationFrame(animationId);
            generating = true;
            stepping = false;
            document.getElementById('status-stat').textContent = 'Generating...';

            initGrid();
            resize();

            const algo = document.getElementById('algorithm').value;
            switch (algo) {
                case 'dfs': genState = initDFS(); break;
                case 'prim': genState = initPrim(); break;
                case 'kruskal': genState = initKruskal(); break;
                case 'division': genState = initDivision(); break;
                case 'eller': genState = initEller(); break;
            }

            animate();
        }

        function stepMode() {
            if (!generating && !genState) {
                generate();
            }
            stepping = !stepping;
            if (!stepping && generating) {
                animate();
            }
        }

        function animate() {
            if (!generating || stepping) {
                draw();
                return;
            }

            const algo = document.getElementById('algorithm').value;

            for (let i = 0; i < speed && !genState.done; i++) {
                switch (algo) {
                    case 'dfs': stepDFS(genState); break;
                    case 'prim': stepPrim(genState); break;
                    case 'kruskal': stepKruskal(genState); break;
                    case 'division': stepDivision(genState); break;
                    case 'eller': stepEller(genState); break;
                }
            }

            draw();

            if (genState.done) {
                // Clear markers
                for (let y = 0; y < mazeHeight; y++) {
                    for (let x = 0; x < mazeWidth; x++) {
                        if (grid[y][x] === CURRENT || grid[y][x] === VISITED) {
                            grid[y][x] = PASSAGE;
                        }
                    }
                }
                generating = false;
                document.getElementById('status-stat').textContent = 'Complete!';
                draw();
            } else {
                animationId = requestAnimationFrame(animate);
            }
        }

        function reset() {
            if (animationId) cancelAnimationFrame(animationId);
            generating = false;
            stepping = false;
            genState = null;
            initGrid();
            resize();
            draw();
            document.getElementById('status-stat').textContent = 'Ready';
        }

        window.generate = generate;
        window.solve = solve;
        window.stepMode = stepMode;
        window.reset = reset;

        // Setup controls
        function setupControls() {
            document.getElementById('width').addEventListener('input', (e) => {
                mazeWidth = parseInt(e.target.value);
                document.getElementById('width-val').textContent = mazeWidth;
            });
            document.getElementById('height').addEventListener('input', (e) => {
                mazeHeight = parseInt(e.target.value);
                document.getElementById('height-val').textContent = mazeHeight;
            });
            document.getElementById('speed').addEventListener('input', (e) => {
                speed = parseInt(e.target.value);
                document.getElementById('speed-val').textContent = speed;
            });
        }

        window.addEventListener('resize', () => { resize(); draw(); });

        setupControls();
        initGrid();
        resize();
        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
