<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time Alignment Chart - Timezone Tools</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%);
            color: var(--moss);
            line-height: 1.7;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .organic-shape {
            position: fixed;
            border-radius: 63% 37% 54% 46% / 55% 48% 52% 45%;
            opacity: 0.08;
            animation: morph 30s infinite ease-in-out;
            z-index: 0;
            pointer-events: none;
        }

        .shape-1 {
            width: 500px;
            height: 500px;
            background: var(--sage);
            top: -100px;
            left: -100px;
        }

        .shape-2 {
            width: 350px;
            height: 350px;
            background: var(--earth);
            bottom: -50px;
            right: -50px;
            animation-delay: -10s;
        }

        @keyframes morph {
            0%, 100% {
                border-radius: 63% 37% 54% 46% / 55% 48% 52% 45%;
                transform: rotate(0deg) scale(1);
            }
            25% {
                border-radius: 40% 60% 70% 30% / 40% 40% 60% 60%;
                transform: rotate(90deg) scale(1.05);
            }
            50% {
                border-radius: 50% 50% 33% 67% / 55% 27% 73% 45%;
                transform: rotate(180deg) scale(1);
            }
            75% {
                border-radius: 70% 30% 50% 50% / 30% 65% 35% 70%;
                transform: rotate(270deg) scale(0.95);
            }
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 18px;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 25px;
            text-decoration: none;
            color: var(--terracotta);
            font-weight: 600;
            font-size: 0.95rem;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 2px solid transparent;
            z-index: 1000;
        }

        .organic-back-link:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateX(-5px);
            border-color: var(--earth);
            box-shadow: 0 8px 25px rgba(188, 108, 37, 0.2);
        }

        .back-arrow {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }

        .organic-back-link:hover .back-arrow {
            transform: translateX(-3px);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            padding-top: 80px;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
        }

        h1 {
            font-family: 'Lora', serif;
            font-size: clamp(1.8rem, 4vw, 2.8rem);
            font-weight: 700;
            color: var(--moss);
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--terracotta);
            font-weight: 500;
        }

        .controls-panel {
            background: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-group label {
            font-weight: 600;
            color: var(--dark-moss);
            font-size: 0.9rem;
        }

        .control-group input[type="date"] {
            padding: 0.6rem 1rem;
            border: 2px solid var(--sage);
            border-radius: 10px;
            font-family: 'Nunito', sans-serif;
            font-size: 1rem;
            background: white;
            color: var(--dark-moss);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-group input[type="date"]:hover,
        .control-group input[type="date"]:focus {
            border-color: var(--terracotta);
            outline: none;
            box-shadow: 0 4px 12px rgba(188, 108, 37, 0.2);
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            color: var(--dark-moss);
        }

        .legend-color {
            width: 20px;
            height: 14px;
            border-radius: 3px;
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        #chart {
            width: 100%;
            overflow-x: auto;
        }

        #chart svg {
            display: block;
            margin: 0 auto;
        }

        .bar {
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        .bar:hover {
            opacity: 0.8;
        }

        .bar-working {
            fill: var(--sage);
        }

        .bar-night {
            fill: #2a3a1a;
        }

        .bar-off {
            fill: #d4d4d4;
        }

        .overlap-zone {
            fill: var(--terracotta);
            opacity: 0.3;
        }

        .axis-label {
            font-family: 'Nunito', sans-serif;
            font-size: 12px;
            fill: var(--dark-moss);
        }

        .city-label {
            font-family: 'Nunito', sans-serif;
            font-size: 14px;
            font-weight: 600;
            fill: var(--dark-moss);
        }

        .grid line {
            stroke: #ccc;
            stroke-opacity: 0.5;
            stroke-dasharray: 2, 2;
        }

        .tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid var(--earth);
            border-radius: 12px;
            padding: 1rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000;
            min-width: 200px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip-title {
            font-family: 'Lora', serif;
            font-weight: 600;
            color: var(--moss);
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--earth);
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
            font-size: 0.9rem;
        }

        .tooltip-city {
            color: var(--dark-moss);
            font-weight: 500;
        }

        .tooltip-time {
            color: var(--terracotta);
            font-weight: 600;
        }

        .tooltip-status {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
        }

        .status-working {
            background: var(--sage);
            color: white;
        }

        .status-night {
            background: #2a3a1a;
            color: white;
        }

        .status-off {
            background: #d4d4d4;
            color: #666;
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 1.5rem;
        }

        .info-panel h3 {
            font-family: 'Lora', serif;
            color: var(--moss);
            margin-bottom: 1rem;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            padding: 1rem;
            text-align: center;
        }

        .info-card-city {
            font-weight: 600;
            color: var(--dark-moss);
            margin-bottom: 0.5rem;
        }

        .info-card-offset {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--terracotta);
        }

        .info-card-dst {
            font-size: 0.8rem;
            color: var(--moss);
            margin-top: 0.25rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
                padding-top: 70px;
            }

            .controls-panel {
                flex-direction: column;
                align-items: stretch;
            }

            .legend {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="organic-shape shape-1"></div>
    <div class="organic-shape shape-2"></div>

    <a href="index.html" class="organic-back-link">
        <span class="back-arrow">&#8592;</span>
        <span class="back-text">Gallery</span>
    </a>

    <div class="container">
        <header class="header">
            <h1>Time Alignment Chart</h1>
            <p class="subtitle">Visualize working hours overlap across time zones</p>
        </header>

        <div class="controls-panel">
            <div class="control-group">
                <label for="date-selector">Select Date (for DST)</label>
                <input type="date" id="date-selector" value="">
            </div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: var(--sage);"></div>
                    <span>Working Hours (9-17)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #2a3a1a;"></div>
                    <span>Night (22-6)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #d4d4d4;"></div>
                    <span>Off Hours</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: var(--terracotta); opacity: 0.5;"></div>
                    <span>Overlap Zone</span>
                </div>
            </div>
        </div>

        <div class="chart-container">
            <div id="chart"></div>
        </div>

        <div class="info-panel">
            <h3>Current UTC Offsets</h3>
            <div class="info-grid" id="offset-info"></div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // City timezone configuration with DST rules
        const cities = [
            {
                name: 'Miami',
                winterOffset: -5,
                summerOffset: -4,
                dstStart: { month: 3, week: 2, day: 0 }, // Second Sunday of March
                dstEnd: { month: 11, week: 1, day: 0 }   // First Sunday of November
            },
            {
                name: 'London',
                winterOffset: 0,
                summerOffset: 1,
                dstStart: { month: 3, week: -1, day: 0 }, // Last Sunday of March
                dstEnd: { month: 10, week: -1, day: 0 }   // Last Sunday of October
            },
            {
                name: 'Malta',
                winterOffset: 1,
                summerOffset: 2,
                dstStart: { month: 3, week: -1, day: 0 }, // Last Sunday of March
                dstEnd: { month: 10, week: -1, day: 0 }   // Last Sunday of October
            },
            {
                name: 'Moscow',
                winterOffset: 3,
                summerOffset: 3, // No DST
                dstStart: null,
                dstEnd: null
            },
            {
                name: 'Dubai',
                winterOffset: 4,
                summerOffset: 4, // No DST
                dstStart: null,
                dstEnd: null
            }
        ];

        // Get the nth weekday of a month (or last if week is -1)
        function getNthWeekday(year, month, week, dayOfWeek) {
            const firstDay = new Date(year, month - 1, 1);
            const lastDay = new Date(year, month, 0);

            if (week === -1) {
                // Last occurrence
                let date = lastDay.getDate();
                while (new Date(year, month - 1, date).getDay() !== dayOfWeek) {
                    date--;
                }
                return new Date(year, month - 1, date);
            } else {
                // Nth occurrence
                let count = 0;
                for (let d = 1; d <= lastDay.getDate(); d++) {
                    if (new Date(year, month - 1, d).getDay() === dayOfWeek) {
                        count++;
                        if (count === week) {
                            return new Date(year, month - 1, d);
                        }
                    }
                }
            }
            return null;
        }

        // Check if a date is in DST for a city
        function isDST(date, city) {
            if (!city.dstStart || !city.dstEnd) return false;

            const year = date.getFullYear();
            const dstStartDate = getNthWeekday(year, city.dstStart.month, city.dstStart.week, city.dstStart.day);
            const dstEndDate = getNthWeekday(year, city.dstEnd.month, city.dstEnd.week, city.dstEnd.day);

            return date >= dstStartDate && date < dstEndDate;
        }

        // Get current offset for a city on a given date
        function getOffset(date, city) {
            return isDST(date, city) ? city.summerOffset : city.winterOffset;
        }

        // Format offset as string
        function formatOffset(offset) {
            const sign = offset >= 0 ? '+' : '';
            return `UTC${sign}${offset}`;
        }

        // Get local hour from UTC hour
        function getLocalHour(utcHour, offset) {
            let local = utcHour + offset;
            if (local < 0) local += 24;
            if (local >= 24) local -= 24;
            return local;
        }

        // Determine hour status (working, night, off)
        function getHourStatus(localHour) {
            if (localHour >= 9 && localHour < 17) return 'working';
            if (localHour >= 22 || localHour < 6) return 'night';
            return 'off';
        }

        // Format time
        function formatTime(hour) {
            const h = hour % 12 || 12;
            const ampm = hour < 12 ? 'AM' : 'PM';
            return `${h}:00 ${ampm}`;
        }

        // Chart dimensions
        const margin = { top: 60, right: 40, bottom: 60, left: 100 };
        const width = Math.min(1200, window.innerWidth - 100) - margin.left - margin.right;
        const height = cities.length * 60;

        // Create SVG
        const svg = d3.select('#chart')
            .append('svg')
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom)
            .append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);

        // Scales
        const xScale = d3.scaleLinear()
            .domain([0, 24])
            .range([0, width]);

        const yScale = d3.scaleBand()
            .domain(cities.map(c => c.name))
            .range([0, height])
            .padding(0.2);

        // Grid lines
        const gridGroup = svg.append('g').attr('class', 'grid');

        // Overlap zones group (behind bars)
        const overlapGroup = svg.append('g').attr('class', 'overlap-zones');

        // Bars group
        const barsGroup = svg.append('g').attr('class', 'bars');

        // Axes
        const xAxis = d3.axisBottom(xScale)
            .tickValues(d3.range(0, 25, 2))
            .tickFormat(d => `${d}:00`);

        const xAxisTop = d3.axisTop(xScale)
            .tickValues(d3.range(0, 25, 2))
            .tickFormat(d => `${d}:00`);

        svg.append('g')
            .attr('class', 'x-axis')
            .attr('transform', `translate(0,${height})`)
            .call(xAxis)
            .selectAll('text')
            .attr('class', 'axis-label');

        svg.append('g')
            .attr('class', 'x-axis-top')
            .call(xAxisTop)
            .selectAll('text')
            .attr('class', 'axis-label');

        // X-axis label
        svg.append('text')
            .attr('x', width / 2)
            .attr('y', height + 45)
            .attr('text-anchor', 'middle')
            .attr('class', 'axis-label')
            .style('font-weight', '600')
            .text('UTC Hour');

        // Y-axis (city labels)
        svg.append('g')
            .attr('class', 'y-axis')
            .selectAll('.city-label')
            .data(cities)
            .join('text')
            .attr('class', 'city-label')
            .attr('x', -10)
            .attr('y', d => yScale(d.name) + yScale.bandwidth() / 2)
            .attr('dy', '0.35em')
            .attr('text-anchor', 'end')
            .text(d => d.name);

        // Tooltip
        const tooltip = d3.select('#tooltip');

        // Update chart based on selected date
        function updateChart(selectedDate) {
            const date = new Date(selectedDate);

            // Calculate offsets for each city
            const cityOffsets = cities.map(city => ({
                ...city,
                offset: getOffset(date, city),
                isDST: isDST(date, city)
            }));

            // Generate hour data for each city
            const hourData = [];
            cityOffsets.forEach(city => {
                for (let utcHour = 0; utcHour < 24; utcHour++) {
                    const localHour = getLocalHour(utcHour, city.offset);
                    hourData.push({
                        city: city.name,
                        utcHour,
                        localHour,
                        status: getHourStatus(localHour),
                        offset: city.offset
                    });
                }
            });

            // Calculate overlap zones (hours where all cities are in working hours)
            const overlapHours = [];
            for (let utcHour = 0; utcHour < 24; utcHour++) {
                const allWorking = cityOffsets.every(city => {
                    const localHour = getLocalHour(utcHour, city.offset);
                    return getHourStatus(localHour) === 'working';
                });
                if (allWorking) {
                    overlapHours.push(utcHour);
                }
            }

            // Draw grid lines
            gridGroup.selectAll('line').remove();
            gridGroup.selectAll('line')
                .data(d3.range(0, 25, 2))
                .join('line')
                .attr('x1', d => xScale(d))
                .attr('x2', d => xScale(d))
                .attr('y1', 0)
                .attr('y2', height)
                .attr('stroke', '#ccc')
                .attr('stroke-opacity', 0.5)
                .attr('stroke-dasharray', '2,2');

            // Draw overlap zones
            overlapGroup.selectAll('rect').remove();
            if (overlapHours.length > 0) {
                // Find contiguous ranges
                const ranges = [];
                let start = overlapHours[0];
                let end = overlapHours[0];

                for (let i = 1; i < overlapHours.length; i++) {
                    if (overlapHours[i] === end + 1) {
                        end = overlapHours[i];
                    } else {
                        ranges.push({ start, end: end + 1 });
                        start = overlapHours[i];
                        end = overlapHours[i];
                    }
                }
                ranges.push({ start, end: end + 1 });

                overlapGroup.selectAll('rect')
                    .data(ranges)
                    .join('rect')
                    .attr('class', 'overlap-zone')
                    .attr('x', d => xScale(d.start))
                    .attr('y', 0)
                    .attr('width', d => xScale(d.end) - xScale(d.start))
                    .attr('height', height)
                    .attr('fill', 'var(--terracotta)')
                    .attr('opacity', 0.2);
            }

            // Draw bars
            const barHeight = yScale.bandwidth();
            const hourWidth = width / 24;

            barsGroup.selectAll('rect').remove();
            barsGroup.selectAll('rect')
                .data(hourData)
                .join('rect')
                .attr('class', d => `bar bar-${d.status}`)
                .attr('x', d => xScale(d.utcHour))
                .attr('y', d => yScale(d.city))
                .attr('width', hourWidth - 1)
                .attr('height', barHeight)
                .attr('rx', 2)
                .attr('ry', 2)
                .on('mouseover', function(event, d) {
                    showTooltip(event, d, cityOffsets);
                })
                .on('mousemove', function(event) {
                    moveTooltip(event);
                })
                .on('mouseout', hideTooltip);

            // Apply transitions
            barsGroup.selectAll('rect')
                .transition()
                .duration(500)
                .attr('opacity', 1);

            // Update offset info panel
            updateOffsetInfo(cityOffsets, overlapHours);
        }

        function showTooltip(event, d, cityOffsets) {
            const utcHour = d.utcHour;

            let html = `<div class="tooltip-title">UTC ${utcHour}:00</div>`;

            cityOffsets.forEach(city => {
                const localHour = getLocalHour(utcHour, city.offset);
                const status = getHourStatus(localHour);
                const statusLabel = status === 'working' ? 'Working' :
                                   status === 'night' ? 'Night' : 'Off';

                html += `
                    <div class="tooltip-row">
                        <span class="tooltip-city">${city.name}</span>
                        <span>
                            <span class="tooltip-time">${formatTime(localHour)}</span>
                            <span class="tooltip-status status-${status}">${statusLabel}</span>
                        </span>
                    </div>
                `;
            });

            tooltip.html(html);
            tooltip.classed('visible', true);
            moveTooltip(event);
        }

        function moveTooltip(event) {
            const tooltipNode = tooltip.node();
            const tooltipRect = tooltipNode.getBoundingClientRect();

            let left = event.pageX + 15;
            let top = event.pageY - 10;

            // Keep tooltip within viewport
            if (left + tooltipRect.width > window.innerWidth - 20) {
                left = event.pageX - tooltipRect.width - 15;
            }
            if (top + tooltipRect.height > window.innerHeight - 20) {
                top = event.pageY - tooltipRect.height - 10;
            }

            tooltip
                .style('left', left + 'px')
                .style('top', top + 'px');
        }

        function hideTooltip() {
            tooltip.classed('visible', false);
        }

        function updateOffsetInfo(cityOffsets, overlapHours) {
            const infoDiv = document.getElementById('offset-info');

            let html = '';
            cityOffsets.forEach(city => {
                const dstText = city.isDST ? '(DST active)' : '(Standard time)';
                html += `
                    <div class="info-card">
                        <div class="info-card-city">${city.name}</div>
                        <div class="info-card-offset">${formatOffset(city.offset)}</div>
                        <div class="info-card-dst">${dstText}</div>
                    </div>
                `;
            });

            // Add overlap info
            const overlapText = overlapHours.length > 0
                ? `${overlapHours.length} hours (UTC ${overlapHours[0]}:00 - ${overlapHours[overlapHours.length - 1] + 1}:00)`
                : 'No common working hours';

            html += `
                <div class="info-card" style="background: rgba(188, 108, 37, 0.1);">
                    <div class="info-card-city">Working Overlap</div>
                    <div class="info-card-offset" style="font-size: 1rem;">${overlapText}</div>
                    <div class="info-card-dst">All cities 9AM-5PM</div>
                </div>
            `;

            infoDiv.innerHTML = html;
        }

        // Initialize date selector with today's date
        const today = new Date();
        const dateInput = document.getElementById('date-selector');
        dateInput.value = today.toISOString().split('T')[0];

        // Listen for date changes
        dateInput.addEventListener('change', (e) => {
            updateChart(e.target.value);
        });

        // Initial render
        updateChart(dateInput.value);

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                location.reload(); // Simple approach for responsive resize
            }, 250);
        });
    </script>
</body>
</html>
