<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M0 Prototype - Ancient Economy ABM</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .back-link {
            display: inline-block;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            margin-bottom: 20px;
            transition: all 0.3s;
        }

        .back-link:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .main-grid {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .panel h2 {
            color: #2c3e50;
            font-size: 1.3em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            font-weight: 500;
            margin-bottom: 5px;
            color: #555;
            font-size: 0.9em;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-value {
            text-align: right;
            font-size: 0.9em;
            color: #3498db;
            font-weight: 600;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.95em;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        canvas {
            display: block;
            width: 100%;
            height: 600px;
            border-radius: 8px;
            background: #f8f9fa;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid #3498db;
        }

        .stat-label {
            font-size: 0.85em;
            color: #7f8c8d;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 1.4em;
            font-weight: 700;
            color: #2c3e50;
        }

        .chart-container {
            margin-top: 15px;
        }

        .chart-canvas {
            width: 100%;
            height: 150px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .info-text {
            font-size: 0.85em;
            color: #7f8c8d;
            line-height: 1.5;
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
            font-size: 0.85em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-running { background: #27ae60; }
        .status-paused { background: #f39c12; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">← Back to Ancient Economy ABM</a>
            <h1>M0: Basic Grid Prototype</h1>
            <p class="subtitle">Foundational agent-based model with local markets and transport friction</p>
        </header>

        <div class="main-grid">
            <!-- Left Panel: Controls -->
            <div class="panel">
                <h2>Controls</h2>

                <div class="button-group">
                    <button class="btn-primary" id="startBtn">Start</button>
                    <button class="btn-secondary" id="pauseBtn">Pause</button>
                    <button class="btn-secondary" id="stepBtn">Step</button>
                    <button class="btn-danger" id="resetBtn">Reset</button>
                </div>

                <div style="margin: 15px 0; padding: 10px; background: #f8f9fa; border-radius: 6px;">
                    <span class="status-indicator status-paused" id="statusIndicator"></span>
                    <span id="statusText">Paused</span>
                    <div style="margin-top: 8px; font-size: 0.9em; color: #7f8c8d;">
                        Tick: <span id="tickCount" style="font-weight: 600; color: #2c3e50;">0</span>
                    </div>
                </div>

                <h2 style="margin-top: 25px;">Parameters</h2>

                <div class="control-group">
                    <label>Transport Friction</label>
                    <input type="range" id="frictionSlider" min="0" max="100" value="30">
                    <div class="control-value"><span id="frictionValue">0.30</span></div>
                </div>

                <div class="control-group">
                    <label>Production Variance</label>
                    <input type="range" id="varianceSlider" min="0" max="50" value="20">
                    <div class="control-value"><span id="varianceValue">20%</span></div>
                </div>

                <div class="control-group">
                    <label>Subsistence Need</label>
                    <input type="range" id="subsistenceSlider" min="50" max="150" value="100">
                    <div class="control-value"><span id="subsistenceValue">100</span> kg</div>
                </div>

                <div class="control-group">
                    <label>Storage Loss Rate</label>
                    <input type="range" id="storageLossSlider" min="0" max="20" value="5">
                    <div class="control-value"><span id="storageLossValue">5%</span></div>
                </div>

                <div class="control-group">
                    <label>Number of Nodes</label>
                    <input type="range" id="nodesSlider" min="5" max="25" value="12">
                    <div class="control-value"><span id="nodesValue">12</span></div>
                </div>

                <div class="info-text">
                    <strong>How it works:</strong><br>
                    • Each node represents a settlement with households<br>
                    • Households produce grain with variance<br>
                    • Local markets form prices via auction<br>
                    • Traders arbitrage between nodes<br>
                    • Higher friction = higher transport costs
                </div>
            </div>

            <!-- Center Panel: Visualization -->
            <div class="panel">
                <h2>World View</h2>
                <canvas id="worldCanvas"></canvas>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db;"></div>
                        <span>Low Price</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f39c12;"></div>
                        <span>Medium Price</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>High Price</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #95a5a6; opacity: 0.5;"></div>
                        <span>Trade Flow</span>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Statistics & Charts -->
            <div class="panel">
                <h2>Statistics</h2>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-label">Avg Price</div>
                        <div class="stat-value" id="avgPrice">0.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Price Std Dev</div>
                        <div class="stat-value" id="priceStdDev">0.00</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Total Trade</div>
                        <div class="stat-value" id="totalTrade">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Avg Welfare</div>
                        <div class="stat-value" id="avgWelfare">0.0</div>
                    </div>
                </div>

                <div class="chart-container">
                    <h3 style="font-size: 1.1em; margin-bottom: 10px; color: #2c3e50;">Price Dispersion</h3>
                    <canvas id="priceChart" class="chart-canvas"></canvas>
                </div>

                <div class="chart-container">
                    <h3 style="font-size: 1.1em; margin-bottom: 10px; color: #2c3e50;">Trade Volume</h3>
                    <canvas id="tradeChart" class="chart-canvas"></canvas>
                </div>

                <div class="info-text" style="margin-top: 20px;">
                    <strong>Observations:</strong><br>
                    <span id="observations">Run the simulation to see emergent patterns...</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== MODEL PARAMETERS =====
        const config = {
            numNodes: 12,
            householdsPerNode: 50,
            baseProduction: 120,
            productionVariance: 0.2,
            subsistenceNeed: 100,
            storageLoss: 0.05,
            transportFriction: 0.3,
            maxPrice: 5.0,
            minPrice: 0.1,
            traderCapacity: 500,
            numTraders: 30
        };

        // ===== STATE =====
        let nodes = [];
        let traders = [];
        let tick = 0;
        let isRunning = false;
        let priceHistory = [];
        let tradeHistory = [];
        const maxHistory = 100;

        // ===== CANVAS SETUP =====
        const worldCanvas = document.getElementById('worldCanvas');
        const worldCtx = worldCanvas.getContext('2d');
        const priceChart = document.getElementById('priceChart');
        const priceCtx = priceChart.getContext('2d');
        const tradeChart = document.getElementById('tradeChart');
        const tradeCtx = tradeChart.getContext('2d');

        function resizeCanvas() {
            worldCanvas.width = worldCanvas.offsetWidth;
            worldCanvas.height = worldCanvas.offsetHeight;
            priceChart.width = priceChart.offsetWidth;
            priceChart.height = priceChart.offsetHeight;
            tradeChart.width = tradeChart.offsetWidth;
            tradeChart.height = tradeChart.offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ===== NODE CLASS =====
        class Node {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.households = [];
                this.price = 1.0;
                this.totalSupply = 0;
                this.totalDemand = 0;
                this.inventory = 0;

                // Initialize households
                for (let i = 0; i < config.householdsPerNode; i++) {
                    this.households.push({
                        grain: config.baseProduction,
                        need: config.subsistenceNeed,
                        production: config.baseProduction * (1 + (Math.random() - 0.5) * config.productionVariance)
                    });
                }
            }

            produce() {
                this.households.forEach(h => {
                    h.grain += h.production * (1 + (Math.random() - 0.5) * config.productionVariance);
                });
            }

            consume() {
                this.households.forEach(h => {
                    const consumed = Math.min(h.grain, h.need);
                    h.grain -= consumed;
                    h.welfare = consumed / h.need;
                });
            }

            applyStorageLoss() {
                this.households.forEach(h => {
                    h.grain *= (1 - config.storageLoss);
                });
            }

            formMarket() {
                // Calculate supply and demand
                this.totalSupply = 0;
                this.totalDemand = 0;

                this.households.forEach(h => {
                    const surplus = h.grain - h.need;
                    if (surplus > 0) {
                        this.totalSupply += surplus * 0.5; // Willing to sell half of surplus
                    } else {
                        this.totalDemand += -surplus * 0.5; // Want to buy half of deficit
                    }
                });

                // Simple price formation: supply-demand ratio
                if (this.totalSupply > 0 && this.totalDemand > 0) {
                    const ratio = this.totalDemand / this.totalSupply;
                    this.price = Math.max(config.minPrice, Math.min(config.maxPrice, ratio));
                } else if (this.totalSupply > 0) {
                    this.price *= 0.95; // Excess supply, price drops
                } else if (this.totalDemand > 0) {
                    this.price *= 1.05; // Excess demand, price rises
                }

                this.price = Math.max(config.minPrice, Math.min(config.maxPrice, this.price));

                // Update total inventory
                this.inventory = this.households.reduce((sum, h) => sum + h.grain, 0);
            }

            getWelfare() {
                return this.households.reduce((sum, h) => sum + (h.welfare || 0), 0) / this.households.length;
            }
        }

        // ===== TRADER CLASS =====
        class Trader {
            constructor() {
                this.capacity = config.traderCapacity;
                this.cargo = 0;
                this.location = null;
            }

            findArbitrage() {
                if (nodes.length < 2) return;

                // Find highest and lowest price nodes
                let maxPriceNode = nodes[0];
                let minPriceNode = nodes[0];

                nodes.forEach(node => {
                    if (node.price > maxPriceNode.price) maxPriceNode = node;
                    if (node.price < minPriceNode.price) minPriceNode = node;
                });

                const priceDiff = maxPriceNode.price - minPriceNode.price;
                const distance = Math.hypot(maxPriceNode.x - minPriceNode.x, maxPriceNode.y - minPriceNode.y);
                const transportCost = distance * config.transportFriction;
                const profit = priceDiff - transportCost;

                if (profit > 0.1 && minPriceNode.totalSupply > 10) {
                    // Buy from low price node
                    const buyAmount = Math.min(this.capacity, minPriceNode.totalSupply * 0.1);
                    this.cargo = buyAmount;
                    this.source = minPriceNode;
                    this.destination = maxPriceNode;

                    // Execute trade
                    minPriceNode.inventory -= buyAmount;
                    maxPriceNode.inventory += buyAmount * 0.95; // 5% transport loss

                    return buyAmount;
                }

                return 0;
            }
        }

        // ===== INITIALIZATION =====
        function initialize() {
            nodes = [];
            traders = [];
            tick = 0;
            priceHistory = [];
            tradeHistory = [];

            // Create nodes in a grid-like pattern with some randomness
            const gridSize = Math.ceil(Math.sqrt(config.numNodes));
            const margin = 50;
            const cellW = (worldCanvas.width - 2 * margin) / gridSize;
            const cellH = (worldCanvas.height - 2 * margin) / gridSize;

            for (let i = 0; i < config.numNodes; i++) {
                const row = Math.floor(i / gridSize);
                const col = i % gridSize;
                const x = margin + col * cellW + cellW/2 + (Math.random() - 0.5) * 20;
                const y = margin + row * cellH + cellH/2 + (Math.random() - 0.5) * 20;
                nodes.push(new Node(i, x, y));
            }

            // Create traders
            for (let i = 0; i < config.numTraders; i++) {
                traders.push(new Trader());
            }

            updateDisplay();
        }

        // ===== SIMULATION STEP =====
        function step() {
            tick++;

            // 1. Production phase
            nodes.forEach(node => node.produce());

            // 2. Consumption phase
            nodes.forEach(node => node.consume());

            // 3. Storage loss
            nodes.forEach(node => node.applyStorageLoss());

            // 4. Market formation
            nodes.forEach(node => node.formMarket());

            // 5. Trade
            let totalTradeVolume = 0;
            traders.forEach(trader => {
                totalTradeVolume += trader.findArbitrage();
            });

            // Record history
            const prices = nodes.map(n => n.price);
            const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;
            const variance = prices.reduce((sum, p) => sum + Math.pow(p - avgPrice, 2), 0) / prices.length;
            const stdDev = Math.sqrt(variance);

            priceHistory.push({ avg: avgPrice, stdDev: stdDev });
            tradeHistory.push(totalTradeVolume);

            if (priceHistory.length > maxHistory) {
                priceHistory.shift();
                tradeHistory.shift();
            }

            updateDisplay();
        }

        // ===== RENDERING =====
        function drawWorld() {
            worldCtx.clearRect(0, 0, worldCanvas.width, worldCanvas.height);

            // Draw connections with trade flows
            const avgPrice = nodes.reduce((sum, n) => sum + n.price, 0) / nodes.length;

            worldCtx.strokeStyle = 'rgba(149, 165, 166, 0.2)';
            worldCtx.lineWidth = 1;
            nodes.forEach((n1, i) => {
                nodes.forEach((n2, j) => {
                    if (i < j && Math.random() < 0.3) { // Sparse connections
                        worldCtx.beginPath();
                        worldCtx.moveTo(n1.x, n1.y);
                        worldCtx.lineTo(n2.x, n2.y);
                        worldCtx.stroke();
                    }
                });
            });

            // Draw nodes
            nodes.forEach(node => {
                // Color based on price (blue = low, orange = medium, red = high)
                const priceRatio = (node.price - config.minPrice) / (config.maxPrice - config.minPrice);
                let color;
                if (priceRatio < 0.33) {
                    color = '#3498db'; // Blue
                } else if (priceRatio < 0.66) {
                    color = '#f39c12'; // Orange
                } else {
                    color = '#e74c3c'; // Red
                }

                // Size based on inventory
                const maxInventory = config.householdsPerNode * config.baseProduction;
                const inventoryRatio = Math.min(1, node.inventory / maxInventory);
                const radius = 15 + inventoryRatio * 20;

                // Draw node
                worldCtx.fillStyle = color;
                worldCtx.beginPath();
                worldCtx.arc(node.x, node.y, radius, 0, Math.PI * 2);
                worldCtx.fill();

                // Draw border
                worldCtx.strokeStyle = '#2c3e50';
                worldCtx.lineWidth = 2;
                worldCtx.stroke();

                // Draw price label
                worldCtx.fillStyle = '#2c3e50';
                worldCtx.font = 'bold 11px sans-serif';
                worldCtx.textAlign = 'center';
                worldCtx.fillText(node.price.toFixed(2), node.x, node.y - radius - 8);
            });
        }

        function drawChart(ctx, data, color, label) {
            if (data.length === 0) return;

            const width = ctx.canvas.width;
            const height = ctx.canvas.height;
            const padding = 40;

            ctx.clearRect(0, 0, width, height);

            // Find max value
            let max = Math.max(...data);
            if (max === 0) max = 1;

            // Draw axes
            ctx.strokeStyle = '#95a5a6';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();

            // Draw data
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();

            data.forEach((value, i) => {
                const x = padding + (i / data.length) * (width - 2 * padding);
                const y = height - padding - (value / max) * (height - 2 * padding);

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });

            ctx.stroke();

            // Draw labels
            ctx.fillStyle = '#7f8c8d';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('0', 5, height - padding + 4);
            ctx.fillText(max.toFixed(1), 5, padding);
        }

        function updateDisplay() {
            // Update tick counter
            document.getElementById('tickCount').textContent = tick;

            // Calculate statistics
            const prices = nodes.map(n => n.price);
            const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;
            const variance = prices.reduce((sum, p) => sum + Math.pow(p - avgPrice, 2), 0) / prices.length;
            const stdDev = Math.sqrt(variance);
            const totalTrade = tradeHistory.length > 0 ? tradeHistory[tradeHistory.length - 1] : 0;
            const avgWelfare = nodes.reduce((sum, n) => sum + n.getWelfare(), 0) / nodes.length;

            // Update stat boxes
            document.getElementById('avgPrice').textContent = avgPrice.toFixed(2);
            document.getElementById('priceStdDev').textContent = stdDev.toFixed(3);
            document.getElementById('totalTrade').textContent = Math.round(totalTrade);
            document.getElementById('avgWelfare').textContent = avgWelfare.toFixed(2);

            // Draw visualizations
            drawWorld();

            if (priceHistory.length > 0) {
                drawChart(priceCtx, priceHistory.map(h => h.stdDev), '#e74c3c', 'Price Dispersion');
                drawChart(tradeCtx, tradeHistory, '#3498db', 'Trade Volume');
            }

            // Update observations
            let obs = '';
            if (tick > 20) {
                if (stdDev < 0.2) {
                    obs = 'Prices are converging - market integration is high.';
                } else if (stdDev > 0.8) {
                    obs = 'High price dispersion - transport frictions or local shocks dominating.';
                } else {
                    obs = 'Moderate price variation - trade is balancing local differences.';
                }

                if (avgWelfare < 0.8) {
                    obs += ' Some households are experiencing shortfalls.';
                } else if (avgWelfare > 0.95) {
                    obs += ' Households are well-supplied.';
                }
            }
            document.getElementById('observations').textContent = obs || 'Run the simulation to see emergent patterns...';
        }

        // ===== ANIMATION LOOP =====
        let lastTime = 0;
        const stepInterval = 200; // ms between steps

        function animate(currentTime) {
            if (isRunning && currentTime - lastTime > stepInterval) {
                step();
                lastTime = currentTime;
            }
            requestAnimationFrame(animate);
        }

        // ===== EVENT LISTENERS =====
        document.getElementById('startBtn').addEventListener('click', () => {
            isRunning = true;
            document.getElementById('statusIndicator').className = 'status-indicator status-running';
            document.getElementById('statusText').textContent = 'Running';
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            isRunning = false;
            document.getElementById('statusIndicator').className = 'status-indicator status-paused';
            document.getElementById('statusText').textContent = 'Paused';
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            step();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            isRunning = false;
            document.getElementById('statusIndicator').className = 'status-indicator status-paused';
            document.getElementById('statusText').textContent = 'Paused';
            initialize();
        });

        // Parameter sliders
        document.getElementById('frictionSlider').addEventListener('input', (e) => {
            config.transportFriction = e.target.value / 100;
            document.getElementById('frictionValue').textContent = config.transportFriction.toFixed(2);
        });

        document.getElementById('varianceSlider').addEventListener('input', (e) => {
            config.productionVariance = e.target.value / 100;
            document.getElementById('varianceValue').textContent = e.target.value + '%';
        });

        document.getElementById('subsistenceSlider').addEventListener('input', (e) => {
            config.subsistenceNeed = parseInt(e.target.value);
            document.getElementById('subsistenceValue').textContent = e.target.value;
        });

        document.getElementById('storageLossSlider').addEventListener('input', (e) => {
            config.storageLoss = e.target.value / 100;
            document.getElementById('storageLossValue').textContent = e.target.value + '%';
        });

        document.getElementById('nodesSlider').addEventListener('input', (e) => {
            config.numNodes = parseInt(e.target.value);
            document.getElementById('nodesValue').textContent = e.target.value;
        });

        // Expose for enhance.js keyboard shortcuts
        window.reset = function() { isRunning = false; initialize(); };
        window.init = initialize;

        // ===== INITIALIZE & START =====
        initialize();
        requestAnimationFrame(animate);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
