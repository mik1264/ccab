<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cloth Simulation - Verlet Integration - CCAB</title>
    <meta name="description" content="Interactive cloth simulation using Verlet integration and spring-mass constraints. Drag to interact, watch realistic fabric physics unfold.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.6);
            color: #ff6b9d;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 107, 157, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(255, 107, 157, 0.2);
            transform: translateX(-4px);
        }

        #info {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 12px;
            color: #ff6b9d;
            font-size: 13px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 107, 157, 0.2);
            z-index: 1000;
            max-width: 260px;
        }

        #info h3 {
            margin-bottom: 10px;
            color: #fff;
        }

        #info .stats {
            font-size: 11px;
            color: #ddd;
            margin-top: 8px;
        }

        #info p {
            font-size: 11px;
            opacity: 0.8;
            line-height: 1.5;
            margin-top: 10px;
            color: #ddd;
        }

        #presets {
            position: fixed;
            top: 200px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }

        button {
            background: rgba(255, 107, 157, 0.15);
            border: 1px solid rgba(255, 107, 157, 0.4);
            color: #ff6b9d;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(255, 107, 157, 0.3);
        }

        button.active {
            background: rgba(255, 107, 157, 0.4);
            border-color: #ff6b9d;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 16px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 107, 157, 0.2);
        }

        .control-group label {
            color: #ff6b9d;
            font-size: 11px;
            display: block;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 100px;
            accent-color: #ff6b9d;
        }

        .control-group span {
            color: #fff;
            font-size: 10px;
            margin-left: 6px;
        }

        #fps-display {
            position: fixed;
            bottom: 80px;
            right: 15px;
            background: rgba(0, 0, 0, 0.6);
            color: #ff6b9d;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
        }

        #instructions {
            position: fixed;
            bottom: 80px;
            left: 15px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            color: #ddd;
            font-size: 11px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>

    <div id="info">
        <h3>Cloth Simulation</h3>
        <div>Mode: <span id="mode-name">Hanging Cloth</span></div>
        <div class="stats">
            <div>Points: <span id="point-count">0</span></div>
            <div>Constraints: <span id="constraint-count">0</span></div>
        </div>
        <p>Verlet integration with distance constraints creates realistic cloth physics. Drag to interact with the fabric. The simulation uses iterative constraint relaxation.</p>
    </div>

    <div id="presets">
        <button class="active" data-preset="hanging">Hanging Cloth</button>
        <button data-preset="flag">Flag in Wind</button>
        <button data-preset="curtain">Curtain</button>
        <button data-preset="tablecloth">Tablecloth</button>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>Gravity: <span id="gravity-val">1.0</span></label>
            <input type="range" id="gravity" min="0" max="2" value="1" step="0.1">
        </div>
        <div class="control-group">
            <label>Stiffness: <span id="stiffness-val">3</span></label>
            <input type="range" id="stiffness" min="1" max="10" value="3" step="1">
        </div>
        <div class="control-group">
            <label>Damping: <span id="damping-val">0.01</span></label>
            <input type="range" id="damping" min="0" max="0.05" value="0.01" step="0.005">
        </div>
        <button id="reset">Reset</button>
        <button id="tear">Tear Mode</button>
    </div>

    <div id="fps-display">FPS: <span id="fps">0</span></div>

    <div id="instructions">
        Click & drag to move cloth | Right-click to pin/unpin
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // Cloth Simulation using Verlet Integration
        // Based on Thomas Jakobsen's constraint-based approach

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Configuration
        const config = {
            gravity: 1.0,
            damping: 0.01,
            constraintIterations: 3,
            tearDistance: 50,
            tearMode: false
        };

        // Presets
        const presets = {
            hanging: {
                name: "Hanging Cloth",
                cols: 40,
                rows: 30,
                spacing: 12,
                pinnedPoints: row => row === 0 && true,  // Top row pinned
                wind: { x: 0, y: 0 }
            },
            flag: {
                name: "Flag in Wind",
                cols: 50,
                rows: 25,
                spacing: 10,
                pinnedPoints: (row, col, cols) => col === 0,  // Left edge pinned
                wind: { x: 0.3, y: 0.05 }
            },
            curtain: {
                name: "Curtain",
                cols: 60,
                rows: 40,
                spacing: 10,
                pinnedPoints: (row, col, cols) => row === 0 && col % 8 === 0,  // Top, every 8th
                wind: { x: 0.1, y: 0 }
            },
            tablecloth: {
                name: "Tablecloth",
                cols: 35,
                rows: 35,
                spacing: 14,
                pinnedPoints: (row, col, cols, rows) => {
                    // Pin corners only
                    return (row === 0 && col === 0) ||
                           (row === 0 && col === cols - 1) ||
                           (row === rows - 1 && col === 0) ||
                           (row === rows - 1 && col === cols - 1);
                },
                wind: { x: 0, y: 0 }
            }
        };

        let currentPreset = 'hanging';
        let points = [];
        let constraints = [];
        let wind = { x: 0, y: 0 };

        // Mouse state
        let mouse = { x: 0, y: 0, down: false, button: 0 };
        let selectedPoint = null;

        // Resize canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', () => {
            resize();
            initCloth(currentPreset);
        });

        // Point class
        class Point {
            constructor(x, y, pinned = false) {
                this.x = x;
                this.y = y;
                this.oldX = x;
                this.oldY = y;
                this.pinned = pinned;
                this.initX = x;
                this.initY = y;
            }

            update(gravity, damping, wind) {
                if (this.pinned) return;

                // Verlet integration
                const vx = (this.x - this.oldX) * (1 - damping);
                const vy = (this.y - this.oldY) * (1 - damping);

                this.oldX = this.x;
                this.oldY = this.y;

                // Apply forces
                this.x += vx + wind.x + (Math.random() - 0.5) * wind.x * 2;
                this.y += vy + gravity + wind.y;

                // Boundary constraints
                if (this.y > canvas.height - 10) {
                    this.y = canvas.height - 10;
                    this.oldY = this.y + vy * 0.5;  // Bounce
                }
                if (this.x < 10) this.x = 10;
                if (this.x > canvas.width - 10) this.x = canvas.width - 10;
            }
        }

        // Constraint class
        class Constraint {
            constructor(p1, p2) {
                this.p1 = p1;
                this.p2 = p2;
                this.length = Math.sqrt(
                    (p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2
                );
                this.active = true;
            }

            solve() {
                if (!this.active) return;

                const dx = this.p2.x - this.p1.x;
                const dy = this.p2.y - this.p1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Check for tearing
                if (config.tearMode && dist > config.tearDistance) {
                    this.active = false;
                    return;
                }

                if (dist === 0) return;

                const diff = (this.length - dist) / dist;
                const offsetX = dx * diff * 0.5;
                const offsetY = dy * diff * 0.5;

                if (!this.p1.pinned) {
                    this.p1.x -= offsetX;
                    this.p1.y -= offsetY;
                }
                if (!this.p2.pinned) {
                    this.p2.x += offsetX;
                    this.p2.y += offsetY;
                }
            }
        }

        // Initialize cloth
        function initCloth(presetName) {
            const preset = presets[presetName];
            currentPreset = presetName;
            points = [];
            constraints = [];
            wind = { ...preset.wind };

            const { cols, rows, spacing } = preset;

            // Calculate starting position to center cloth
            const startX = (canvas.width - cols * spacing) / 2;
            const startY = 80;

            // Create points
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = startX + col * spacing;
                    const y = startY + row * spacing;
                    const pinned = preset.pinnedPoints(row, col, cols, rows);
                    points.push(new Point(x, y, pinned));
                }
            }

            // Create constraints (structural)
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const index = row * cols + col;

                    // Horizontal constraint
                    if (col < cols - 1) {
                        constraints.push(new Constraint(points[index], points[index + 1]));
                    }

                    // Vertical constraint
                    if (row < rows - 1) {
                        constraints.push(new Constraint(points[index], points[index + cols]));
                    }

                    // Shear constraints (diagonals) for stability
                    if (col < cols - 1 && row < rows - 1) {
                        constraints.push(new Constraint(points[index], points[index + cols + 1]));
                        constraints.push(new Constraint(points[index + 1], points[index + cols]));
                    }
                }
            }

            document.getElementById('mode-name').textContent = preset.name;
            document.getElementById('point-count').textContent = points.length.toLocaleString();
            document.getElementById('constraint-count').textContent = constraints.filter(c => c.active).length.toLocaleString();

            // Update UI
            document.querySelectorAll('#presets button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.preset === presetName);
            });
        }

        // Find closest point to mouse
        function findClosestPoint(x, y, maxDist = 30) {
            let closest = null;
            let minDist = maxDist;

            for (const point of points) {
                const dx = point.x - x;
                const dy = point.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < minDist) {
                    minDist = dist;
                    closest = point;
                }
            }

            return closest;
        }

        // Update simulation
        function update() {
            // Update points
            for (const point of points) {
                point.update(config.gravity, config.damping, wind);
            }

            // Handle mouse interaction
            if (mouse.down && selectedPoint && mouse.button === 0) {
                selectedPoint.x = mouse.x;
                selectedPoint.y = mouse.y;
                selectedPoint.oldX = mouse.x;
                selectedPoint.oldY = mouse.y;
            }

            // Solve constraints multiple times for stability
            for (let i = 0; i < config.constraintIterations; i++) {
                for (const constraint of constraints) {
                    constraint.solve();
                }
            }

            // Update constraint count (for tear mode)
            document.getElementById('constraint-count').textContent =
                constraints.filter(c => c.active).length.toLocaleString();
        }

        // Render
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw constraints (cloth surface)
            ctx.strokeStyle = 'rgba(255, 200, 220, 0.6)';
            ctx.lineWidth = 1;

            for (const constraint of constraints) {
                if (!constraint.active) continue;

                ctx.beginPath();
                ctx.moveTo(constraint.p1.x, constraint.p1.y);
                ctx.lineTo(constraint.p2.x, constraint.p2.y);
                ctx.stroke();
            }

            // Draw filled polygons for cloth appearance
            const preset = presets[currentPreset];
            const cols = preset.cols;
            const rows = preset.rows;

            ctx.fillStyle = 'rgba(255, 107, 157, 0.15)';

            for (let row = 0; row < rows - 1; row++) {
                for (let col = 0; col < cols - 1; col++) {
                    const i = row * cols + col;
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const p3 = points[i + cols + 1];
                    const p4 = points[i + cols];

                    // Check if constraints are active
                    const h1Active = constraints.find(c =>
                        (c.p1 === p1 && c.p2 === p2) || (c.p1 === p2 && c.p2 === p1)
                    )?.active !== false;
                    const v1Active = constraints.find(c =>
                        (c.p1 === p1 && c.p2 === p4) || (c.p1 === p4 && c.p2 === p1)
                    )?.active !== false;

                    if (h1Active && v1Active) {
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.lineTo(p3.x, p3.y);
                        ctx.lineTo(p4.x, p4.y);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }

            // Draw pinned points
            for (const point of points) {
                if (point.pinned) {
                    ctx.fillStyle = '#ff6b9d';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw selected point
            if (selectedPoint && mouse.down) {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(selectedPoint.x, selectedPoint.y, 8, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // FPS counter
        let frameCount = 0;
        let lastFpsTime = performance.now();

        function updateFPS() {
            frameCount++;
            const now = performance.now();
            if (now - lastFpsTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFpsTime = now;
            }
        }

        // Animation loop
        function animate() {
            updateFPS();
            update();
            render();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.querySelectorAll('#presets button').forEach(btn => {
            btn.addEventListener('click', () => initCloth(btn.dataset.preset));
        });

        document.getElementById('gravity').addEventListener('input', e => {
            config.gravity = parseFloat(e.target.value);
            document.getElementById('gravity-val').textContent = config.gravity.toFixed(1);
        });

        document.getElementById('stiffness').addEventListener('input', e => {
            config.constraintIterations = parseInt(e.target.value);
            document.getElementById('stiffness-val').textContent = config.constraintIterations;
        });

        document.getElementById('damping').addEventListener('input', e => {
            config.damping = parseFloat(e.target.value);
            document.getElementById('damping-val').textContent = config.damping.toFixed(3);
        });

        document.getElementById('reset').addEventListener('click', () => initCloth(currentPreset));

        document.getElementById('tear').addEventListener('click', e => {
            config.tearMode = !config.tearMode;
            e.target.textContent = config.tearMode ? 'Tear: ON' : 'Tear Mode';
            e.target.classList.toggle('active', config.tearMode);
        });

        // Mouse events
        canvas.addEventListener('mousedown', e => {
            mouse.down = true;
            mouse.button = e.button;
            mouse.x = e.clientX;
            mouse.y = e.clientY;

            if (e.button === 0) {  // Left click - drag
                selectedPoint = findClosestPoint(mouse.x, mouse.y);
            } else if (e.button === 2) {  // Right click - toggle pin
                const point = findClosestPoint(mouse.x, mouse.y);
                if (point) {
                    point.pinned = !point.pinned;
                    if (point.pinned) {
                        point.initX = point.x;
                        point.initY = point.y;
                    }
                }
            }
        });

        canvas.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        canvas.addEventListener('mouseup', () => {
            mouse.down = false;
            selectedPoint = null;
        });

        canvas.addEventListener('mouseleave', () => {
            mouse.down = false;
            selectedPoint = null;
        });

        canvas.addEventListener('contextmenu', e => e.preventDefault());

        // Touch events
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.touches[0];
            mouse.down = true;
            mouse.button = 0;
            mouse.x = touch.clientX;
            mouse.y = touch.clientY;
            selectedPoint = findClosestPoint(mouse.x, mouse.y);
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const touch = e.touches[0];
            mouse.x = touch.clientX;
            mouse.y = touch.clientY;
        });

        canvas.addEventListener('touchend', () => {
            mouse.down = false;
            selectedPoint = null;
        });

        // Initialize and start
        initCloth('hanging');
        animate();
    </script>
</body>
</html>
