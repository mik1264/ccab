<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lichtenberg Figure Growth - Scientific Visualizations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #ce93d8;
            text-decoration: none;
            font-size: 14px;
            opacity: 0.8;
            z-index: 100;
            background: rgba(0,0,0,0.3);
            padding: 8px 16px;
            border-radius: 20px;
            transition: all 0.3s;
        }

        .back-link:hover {
            opacity: 1;
            background: rgba(0,0,0,0.5);
        }

        header {
            text-align: center;
            padding: 60px 20px 20px;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #ce93d8, #ba68c8);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #e1bee7;
            font-size: 1rem;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .panel {
            background: rgba(0,0,0,0.3);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(206, 147, 216, 0.2);
        }

        .main-panel {
            flex: 1;
            min-width: 500px;
        }

        .panel-title {
            font-size: 1rem;
            color: #ce93d8;
            margin-bottom: 15px;
            text-align: center;
        }

        canvas {
            display: block;
            margin: 0 auto;
            border-radius: 8px;
            background: #0a0a1a;
        }

        .controls {
            width: 320px;
        }

        .control-group {
            margin-bottom: 18px;
        }

        .control-group label {
            display: block;
            font-size: 0.85rem;
            color: #e1bee7;
            margin-bottom: 8px;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(206, 147, 216, 0.2);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #ce93d8;
            border-radius: 50%;
            cursor: pointer;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .btn {
            flex: 1;
            padding: 10px;
            background: rgba(206, 147, 216, 0.2);
            border: 1px solid rgba(206, 147, 216, 0.4);
            color: #e1bee7;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .btn:hover {
            background: rgba(206, 147, 216, 0.3);
        }

        .btn.primary {
            background: rgba(206, 147, 216, 0.4);
            border-color: #ce93d8;
        }

        .stats {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            margin-bottom: 6px;
        }

        .stat-label {
            color: #e1bee7;
        }

        .stat-value {
            color: #ce93d8;
            font-weight: 600;
        }

        .mode-select {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .mode-btn {
            flex: 1;
            padding: 8px;
            background: rgba(206, 147, 216, 0.1);
            border: 1px solid rgba(206, 147, 216, 0.3);
            color: #e1bee7;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s;
        }

        .mode-btn.active {
            background: rgba(206, 147, 216, 0.3);
            border-color: #ce93d8;
            color: #fff;
        }

        .info-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(206, 147, 216, 0.2);
            max-width: 1160px;
            margin: 20px auto;
        }

        .info-panel h3 {
            color: #ce93d8;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .info-panel p {
            font-size: 0.9rem;
            line-height: 1.6;
            color: #b0bec5;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                align-items: center;
            }

            .main-panel, .controls {
                width: 100%;
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <header>
        <h1>Lichtenberg Figure Growth</h1>
        <p class="subtitle">Dielectric breakdown patterns via Diffusion-Limited Aggregation</p>
    </header>

    <div class="container">
        <div class="panel main-panel">
            <h3 class="panel-title">Electrical Discharge Pattern</h3>
            <canvas id="mainCanvas" width="550" height="550"></canvas>
        </div>

        <div class="panel controls">
            <div class="btn-group">
                <button class="btn primary" id="startBtn">Start</button>
                <button class="btn" id="resetBtn">Reset</button>
            </div>

            <div class="control-group">
                <label>Growth Mode:</label>
                <div class="mode-select">
                    <button class="mode-btn active" id="modeCenter">Center</button>
                    <button class="mode-btn" id="modePoint">Point</button>
                    <button class="mode-btn" id="modeLine">Line</button>
                </div>
            </div>

            <div class="control-group">
                <label>Branching Bias η: <span id="etaVal">3.0</span></label>
                <input type="range" id="etaSlider" min="1" max="5" value="3" step="0.1">
                <div style="font-size: 0.75rem; color: #b39ddb; margin-top: 3px;">
                    Higher = more branching (fractal dimension)
                </div>
            </div>

            <div class="control-group">
                <label>Noise Level: <span id="noiseVal">0.3</span></label>
                <input type="range" id="noiseSlider" min="0" max="1" value="0.3" step="0.05">
            </div>

            <div class="control-group">
                <label>Growth Speed: <span id="speedVal">50</span> particles/frame</label>
                <input type="range" id="speedSlider" min="1" max="200" value="50" step="1">
            </div>

            <div class="control-group">
                <label>Color Scheme:</label>
                <div class="mode-select">
                    <button class="mode-btn active" id="colorElectric">Electric</button>
                    <button class="mode-btn" id="colorPlasma">Plasma</button>
                    <button class="mode-btn" id="colorMono">Mono</button>
                </div>
            </div>

            <div class="stats">
                <div class="stat-row">
                    <span class="stat-label">Particles:</span>
                    <span class="stat-value" id="particleCount">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Branches:</span>
                    <span class="stat-value" id="branchCount">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Max depth:</span>
                    <span class="stat-value" id="maxDepth">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Est. fractal dim:</span>
                    <span class="stat-value" id="fractalDim">-</span>
                </div>
            </div>
        </div>
    </div>

    <div class="info-panel">
        <h3>Lichtenberg Figures & Dielectric Breakdown</h3>
        <p>
            Named after German physicist Georg Christoph Lichtenberg (1777), these branching patterns
            form when electrical discharge travels through or across an insulating material. The pattern
            grows preferentially toward regions of high electric field gradient, creating fractal structures
            with dimension ~1.7-2.0. This simulation uses a <strong>Diffusion-Limited Aggregation (DLA)</strong>
            model with a bias parameter η that controls how strongly growth favors high-gradient regions.
            Higher η values produce more dendritic, tree-like structures resembling lightning.
        </p>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        // Grid for efficient neighbor lookup
        const CELL_SIZE = 2;
        const gridW = Math.ceil(W / CELL_SIZE);
        const gridH = Math.ceil(H / CELL_SIZE);
        let grid = new Uint8Array(gridW * gridH);
        let depthGrid = new Uint16Array(gridW * gridH);

        // Parameters
        let eta = 3.0;
        let noise = 0.3;
        let speed = 50;
        let running = false;
        let mode = 'center'; // 'center', 'point', 'line'
        let colorScheme = 'electric';

        // Stats
        let particleCount = 0;
        let maxDepth = 0;
        let branches = 0;

        // Image data for faster rendering
        let imageData = ctx.createImageData(W, H);

        // Controls
        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
            if (running) animate();
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        document.getElementById('etaSlider').addEventListener('input', (e) => {
            eta = parseFloat(e.target.value);
            document.getElementById('etaVal').textContent = eta.toFixed(1);
        });

        document.getElementById('noiseSlider').addEventListener('input', (e) => {
            noise = parseFloat(e.target.value);
            document.getElementById('noiseVal').textContent = noise.toFixed(2);
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            document.getElementById('speedVal').textContent = speed;
        });

        // Mode buttons
        ['Center', 'Point', 'Line'].forEach(m => {
            document.getElementById('mode' + m).addEventListener('click', () => {
                mode = m.toLowerCase();
                document.querySelectorAll('.mode-select .mode-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById('mode' + m).classList.add('active');
                reset();
            });
        });

        // Color buttons
        ['Electric', 'Plasma', 'Mono'].forEach(c => {
            document.getElementById('color' + c).addEventListener('click', () => {
                colorScheme = c.toLowerCase();
                document.querySelectorAll('.mode-select:last-of-type .mode-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById('color' + c).classList.add('active');
                redraw();
            });
        });

        function gridIndex(x, y) {
            return y * gridW + x;
        }

        function setPixel(x, y, depth) {
            const gx = Math.floor(x / CELL_SIZE);
            const gy = Math.floor(y / CELL_SIZE);
            if (gx >= 0 && gx < gridW && gy >= 0 && gy < gridH) {
                const idx = gridIndex(gx, gy);
                if (grid[idx] === 0) {
                    grid[idx] = 1;
                    depthGrid[idx] = depth;
                    particleCount++;
                    if (depth > maxDepth) maxDepth = depth;
                    return true;
                }
            }
            return false;
        }

        function hasNeighbor(gx, gy) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = gx + dx;
                    const ny = gy + dy;
                    if (nx >= 0 && nx < gridW && ny >= 0 && ny < gridH) {
                        if (grid[gridIndex(nx, ny)] === 1) {
                            return { x: nx, y: ny };
                        }
                    }
                }
            }
            return null;
        }

        function getNeighborDepth(gx, gy) {
            let minDepth = Infinity;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = gx + dx;
                    const ny = gy + dy;
                    if (nx >= 0 && nx < gridW && ny >= 0 && ny < gridH) {
                        const d = depthGrid[gridIndex(nx, ny)];
                        if (d > 0 && d < minDepth) {
                            minDepth = d;
                        }
                    }
                }
            }
            return minDepth === Infinity ? 1 : minDepth;
        }

        function countNeighbors(gx, gy) {
            let count = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = gx + dx;
                    const ny = gy + dy;
                    if (nx >= 0 && nx < gridW && ny >= 0 && ny < gridH) {
                        if (grid[gridIndex(nx, ny)] === 1) {
                            count++;
                        }
                    }
                }
            }
            return count;
        }

        function distanceToStructure(gx, gy) {
            // Simple approximation: find nearest occupied cell
            let minDist = Infinity;
            const searchRadius = 50;

            for (let r = 1; r <= searchRadius; r++) {
                for (let dy = -r; dy <= r; dy++) {
                    for (let dx = -r; dx <= r; dx++) {
                        if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
                        const nx = gx + dx;
                        const ny = gy + dy;
                        if (nx >= 0 && nx < gridW && ny >= 0 && ny < gridH) {
                            if (grid[gridIndex(nx, ny)] === 1) {
                                const d = Math.sqrt(dx * dx + dy * dy);
                                if (d < minDist) minDist = d;
                            }
                        }
                    }
                }
                if (minDist < Infinity) return minDist;
            }
            return searchRadius;
        }

        function initSeed() {
            if (mode === 'center') {
                // Single point at center
                const cx = Math.floor(gridW / 2);
                const cy = Math.floor(gridH / 2);
                grid[gridIndex(cx, cy)] = 1;
                depthGrid[gridIndex(cx, cy)] = 1;
                particleCount = 1;
            } else if (mode === 'point') {
                // Point at top
                const cx = Math.floor(gridW / 2);
                grid[gridIndex(cx, 5)] = 1;
                depthGrid[gridIndex(cx, 5)] = 1;
                particleCount = 1;
            } else if (mode === 'line') {
                // Line at top
                for (let x = gridW / 4; x < 3 * gridW / 4; x++) {
                    grid[gridIndex(Math.floor(x), 5)] = 1;
                    depthGrid[gridIndex(Math.floor(x), 5)] = 1;
                    particleCount++;
                }
            }
        }

        function reset() {
            grid = new Uint8Array(gridW * gridH);
            depthGrid = new Uint16Array(gridW * gridH);
            particleCount = 0;
            maxDepth = 0;
            branches = 0;

            imageData = ctx.createImageData(W, H);

            initSeed();
            redraw();
            updateStats();
        }

        function growStep() {
            let added = 0;

            for (let i = 0; i < speed * 10 && added < speed; i++) {
                // Random walker from boundary
                let x, y;

                if (mode === 'center') {
                    // Start from random position on circle
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.min(gridW, gridH) / 2 - 5;
                    x = Math.floor(gridW / 2 + radius * Math.cos(angle));
                    y = Math.floor(gridH / 2 + radius * Math.sin(angle));
                } else {
                    // Start from bottom for point/line modes
                    x = Math.floor(Math.random() * gridW);
                    y = gridH - 5;
                }

                // Random walk
                let steps = 0;
                const maxSteps = 5000;

                while (steps < maxSteps) {
                    steps++;

                    // Check if adjacent to structure
                    const neighbor = hasNeighbor(x, y);
                    if (neighbor) {
                        // Calculate attachment probability based on local "field"
                        const neighborCount = countNeighbors(x, y);

                        // Field-based probability (DBM model)
                        let prob = Math.pow(1.0 / (neighborCount + 0.1), eta - 1);

                        // Add noise
                        prob = prob * (1 - noise) + Math.random() * noise;

                        if (Math.random() < prob) {
                            const depth = getNeighborDepth(x, y) + 1;
                            if (setPixel(x * CELL_SIZE, y * CELL_SIZE, depth)) {
                                if (neighborCount > 1) branches++;
                                added++;
                            }
                        }
                        break;
                    }

                    // Random step with bias toward structure
                    const dx = Math.floor(Math.random() * 3) - 1;
                    const dy = Math.floor(Math.random() * 3) - 1;

                    x += dx;
                    y += dy;

                    // Boundary check
                    if (x < 0 || x >= gridW || y < 0 || y >= gridH) {
                        break;
                    }

                    // Already occupied
                    if (grid[gridIndex(x, y)] === 1) {
                        break;
                    }
                }
            }

            return added;
        }

        function getColor(depth) {
            const t = Math.min(1, depth / Math.max(1, maxDepth));

            if (colorScheme === 'electric') {
                // Blue -> Cyan -> White
                if (t < 0.5) {
                    const s = t * 2;
                    return [
                        Math.floor(100 + 155 * s),
                        Math.floor(150 + 105 * s),
                        255
                    ];
                } else {
                    const s = (t - 0.5) * 2;
                    return [
                        Math.floor(255),
                        Math.floor(255),
                        255
                    ];
                }
            } else if (colorScheme === 'plasma') {
                // Purple -> Pink -> Orange -> Yellow
                if (t < 0.33) {
                    const s = t * 3;
                    return [
                        Math.floor(128 + 127 * s),
                        Math.floor(0 + 100 * s),
                        Math.floor(255 - 55 * s)
                    ];
                } else if (t < 0.66) {
                    const s = (t - 0.33) * 3;
                    return [
                        255,
                        Math.floor(100 + 100 * s),
                        Math.floor(200 - 200 * s)
                    ];
                } else {
                    const s = (t - 0.66) * 3;
                    return [
                        255,
                        Math.floor(200 + 55 * s),
                        0
                    ];
                }
            } else {
                // Monochrome white
                const v = Math.floor(150 + 105 * t);
                return [v, v, v];
            }
        }

        function redraw() {
            // Clear image data
            for (let i = 0; i < imageData.data.length; i += 4) {
                imageData.data[i] = 10;
                imageData.data[i + 1] = 10;
                imageData.data[i + 2] = 26;
                imageData.data[i + 3] = 255;
            }

            // Draw all particles
            for (let gy = 0; gy < gridH; gy++) {
                for (let gx = 0; gx < gridW; gx++) {
                    if (grid[gridIndex(gx, gy)] === 1) {
                        const depth = depthGrid[gridIndex(gx, gy)];
                        const [r, g, b] = getColor(depth);

                        for (let py = 0; py < CELL_SIZE; py++) {
                            for (let px = 0; px < CELL_SIZE; px++) {
                                const x = gx * CELL_SIZE + px;
                                const y = gy * CELL_SIZE + py;
                                if (x < W && y < H) {
                                    const idx = (y * W + x) * 4;
                                    imageData.data[idx] = r;
                                    imageData.data[idx + 1] = g;
                                    imageData.data[idx + 2] = b;
                                    imageData.data[idx + 3] = 255;
                                }
                            }
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Add glow effect
            ctx.globalCompositeOperation = 'lighter';
            ctx.filter = 'blur(3px)';
            ctx.globalAlpha = 0.3;
            ctx.drawImage(canvas, 0, 0);
            ctx.globalAlpha = 1;
            ctx.filter = 'none';
            ctx.globalCompositeOperation = 'source-over';
        }

        function updateStats() {
            document.getElementById('particleCount').textContent = particleCount.toLocaleString();
            document.getElementById('branchCount').textContent = branches.toLocaleString();
            document.getElementById('maxDepth').textContent = maxDepth;

            // Estimate fractal dimension using box-counting approximation
            if (particleCount > 100) {
                const radius = Math.sqrt(particleCount / Math.PI);
                const dim = Math.log(particleCount) / Math.log(radius);
                document.getElementById('fractalDim').textContent = dim.toFixed(2);
            }
        }

        function animate() {
            if (!running) return;

            growStep();
            redraw();
            updateStats();

            requestAnimationFrame(animate);
        }

        // Initialize
        reset();
    </script>
</body>
</html>
