<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphene Lattice</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0ff;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="info">
        <h2>Graphene Lattice</h2>
        <p>Hexagonal carbon structure</p>
        <p>Single layer of atoms in honeycomb pattern</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        let rotationX = 0.3;
        let rotationY = 0;
        let time = 0;

        class CarbonAtom {
            constructor(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.bonds = [];
            }

            rotate(rx, ry) {
                let x1 = this.x * Math.cos(ry) - this.z * Math.sin(ry);
                let z1 = this.x * Math.sin(ry) + this.z * Math.cos(ry);
                let y1 = this.y * Math.cos(rx) - z1 * Math.sin(rx);
                let z2 = this.y * Math.sin(rx) + z1 * Math.cos(rx);
                return {x: x1, y: y1, z: z2};
            }

            project(rx, ry) {
                const rotated = this.rotate(rx, ry);
                const wave = Math.sin(time + this.x * 0.05 + this.y * 0.05) * 5;
                const scale = 500 / (500 + rotated.z + wave);
                return {
                    x: centerX + rotated.x * scale,
                    y: centerY + (rotated.y + wave) * scale,
                    z: rotated.z + wave,
                    scale: scale
                };
            }
        }

        // Create hexagonal graphene lattice
        const atoms = [];
        const spacing = 30;
        const hexHeight = spacing * Math.sqrt(3);
        const rows = 15;
        const cols = 20;

        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                const xOffset = (row % 2) * spacing * 1.5;
                const x = col * spacing * 3 - cols * spacing * 1.5 + xOffset;
                const y = row * hexHeight / 2 - rows * hexHeight / 4;
                const z = 0;

                atoms.push(new CarbonAtom(x, y, z));

                // Second atom in hexagon
                atoms.push(new CarbonAtom(x + spacing, y, z));
            }
        }

        // Create bonds between atoms
        const bondDistance = spacing * 1.1;
        for (let i = 0; i < atoms.length; i++) {
            for (let j = i + 1; j < atoms.length; j++) {
                const dx = atoms[i].x - atoms[j].x;
                const dy = atoms[i].y - atoms[j].y;
                const dz = atoms[i].z - atoms[j].z;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                if (dist < bondDistance) {
                    atoms[i].bonds.push(j);
                    atoms[j].bonds.push(i);
                }
            }
        }

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            rotationY += 0.003;

            // Project all atoms
            const projected = atoms.map((atom, index) => ({
                ...atom.project(rotationX, rotationY),
                index: index,
                bonds: atom.bonds
            }));

            // Sort by z-depth for proper rendering
            projected.sort((a, b) => a.z - b.z);

            // Draw bonds
            projected.forEach(p => {
                p.bonds.forEach(bondIndex => {
                    const other = projected.find(pr => pr.index === bondIndex);
                    if (other && p.z < other.z) {
                        const intensity = Math.max(0, 1 - (p.z + other.z) / 1000);
                        ctx.beginPath();
                        ctx.strokeStyle = `rgba(0, 255, 255, ${intensity * 0.6})`;
                        ctx.lineWidth = 2 * (p.scale + other.scale) / 2;
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(other.x, other.y);
                        ctx.stroke();

                        // Electron flow animation
                        const t = (time * 2) % 1;
                        const ex = p.x + (other.x - p.x) * t;
                        const ey = p.y + (other.y - p.y) * t;
                        ctx.beginPath();
                        ctx.arc(ex, ey, 2, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 100, ${intensity})`;
                        ctx.fill();
                    }
                });
            });

            // Draw atoms
            projected.forEach(p => {
                const intensity = Math.max(0, 1 - p.z / 500);
                const size = 5 * p.scale;

                // Glow effect
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 2);
                gradient.addColorStop(0, `rgba(100, 255, 255, ${intensity})`);
                gradient.addColorStop(0.5, `rgba(0, 200, 255, ${intensity * 0.5})`);
                gradient.addColorStop(1, 'rgba(0, 100, 200, 0)');

                ctx.beginPath();
                ctx.arc(p.x, p.y, size * 2, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Core
                ctx.beginPath();
                ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(200, 255, 255, ${intensity})`;
                ctx.fill();
                ctx.strokeStyle = `rgba(255, 255, 255, ${intensity * 0.8})`;
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            time += 0.03;
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        animate();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>