<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Figure-8 Orbit (Chenciner-Montgomery)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: Arial; }
        canvas { display: block; }
        .info { position: absolute; top: 20px; left: 20px; color: #ff88ff; background: rgba(0,0,0,0.9); padding: 15px; border-radius: 10px; }
    </style>
</head>
<body>
    <div class="info">
        <h2>Figure-8 Orbit</h2>
        <p>Periodic solution to 3-body problem</p>
        <p>Discovered in 1993</p>
        <p>All three bodies follow same path</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const scale = 150;

        class Body {
            constructor(x, y, vx, vy, color, name) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.mass = 1;
                this.color = color;
                this.name = name;
                this.trail = [];
            }

            draw() {
                // Trail
                ctx.beginPath();
                this.trail.forEach((p, i) => {
                    const sx = centerX + p.x * scale;
                    const sy = centerY + p.y * scale;
                    if (i === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                });
                ctx.strokeStyle = this.color + '88';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Body
                const sx = centerX + this.x * scale;
                const sy = centerY + this.y * scale;

                const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, 15);
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(0.5, this.color);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                ctx.beginPath();
                ctx.arc(sx, sy, 15, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                ctx.beginPath();
                ctx.arc(sx, sy, 8, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        // Initial conditions for figure-8 orbit
        const bodies = [
            new Body(-0.97000436, 0.24308753, 0.4662036850, 0.4323657300, '#FF6B6B', 'Body 1'),
            new Body(0, 0, -0.93240737, -0.86473146, '#4ECDC4', 'Body 2'),
            new Body(0.97000436, -0.24308753, 0.4662036850, 0.4323657300, '#FFE66D', 'Body 3')
        ];

        const G = 1;

        function updateBodies(dt) {
            // Calculate forces
            const forces = bodies.map(() => ({fx: 0, fy: 0}));

            for (let i = 0; i < bodies.length; i++) {
                for (let j = i + 1; j < bodies.length; j++) {
                    const dx = bodies[j].x - bodies[i].x;
                    const dy = bodies[j].y - bodies[i].y;
                    const distSq = dx * dx + dy * dy;
                    const dist = Math.sqrt(distSq);

                    if (dist > 0.01) {
                        const force = G * bodies[i].mass * bodies[j].mass / distSq;
                        const fx = force * dx / dist;
                        const fy = force * dy / dist;

                        forces[i].fx += fx;
                        forces[i].fy += fy;
                        forces[j].fx -= fx;
                        forces[j].fy -= fy;
                    }
                }
            }

            // Update velocities and positions
            bodies.forEach((body, i) => {
                body.vx += (forces[i].fx / body.mass) * dt;
                body.vy += (forces[i].fy / body.mass) * dt;
                body.x += body.vx * dt;
                body.y += body.vy * dt;

                body.trail.push({x: body.x, y: body.y});
                if (body.trail.length > 400) body.trail.shift();
            });
        }

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.02)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const substeps = 5;
            for (let i = 0; i < substeps; i++) {
                updateBodies(0.005);
            }

            bodies.forEach(b => b.draw());

            // Draw center of mass
            let cmX = 0, cmY = 0, totalMass = 0;
            bodies.forEach(b => {
                cmX += b.x * b.mass;
                cmY += b.y * b.mass;
                totalMass += b.mass;
            });
            cmX /= totalMass;
            cmY /= totalMass;

            ctx.beginPath();
            ctx.arc(centerX + cmX * scale, centerY + cmY * scale, 5, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fill();
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>