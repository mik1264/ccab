<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ornstein-Uhlenbeck Process - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        header { text-align: center; padding: 20px; margin-bottom: 20px; }
        h1 {
            font-size: 2.2rem;
            background: linear-gradient(90deg, #00cec9, #0984e3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { color: #888; }
        .back-link { position: absolute; top: 20px; left: 20px; color: #00cec9; text-decoration: none; }
        .main-content { display: grid; grid-template-columns: 1fr 350px; gap: 20px; }
        .canvas-container { background: rgba(255,255,255,0.05); border-radius: 16px; padding: 20px; }
        canvas { display: block; margin: 0 auto; background: #0a0a1a; border-radius: 8px; }
        .controls { display: flex; flex-direction: column; gap: 15px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 15px; }
        .panel h3 { color: #00cec9; font-size: 1rem; margin-bottom: 10px; border-bottom: 1px solid rgba(0,206,201,0.3); padding-bottom: 5px; }
        button {
            padding: 10px 15px; background: rgba(0,206,201,0.2);
            border: 1px solid rgba(0,206,201,0.5); border-radius: 6px;
            color: #00cec9; cursor: pointer; width: 100%; margin-bottom: 8px;
        }
        button:hover { background: rgba(0,206,201,0.3); }
        .control-group { margin-bottom: 12px; }
        .control-group label { display: block; color: #00cec9; font-size: 0.85rem; margin-bottom: 5px; }
        input[type="range"] {
            width: 100%; height: 6px; -webkit-appearance: none;
            background: rgba(0,206,201,0.2); border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px;
            background: #00cec9; border-radius: 50%; cursor: pointer;
        }
        .stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
        .stat { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px; text-align: center; }
        .stat-value { font-size: 1rem; color: #00cec9; font-weight: bold; }
        .stat-label { font-size: 0.7rem; color: #888; }
        .info-text { font-size: 0.85rem; color: #aaa; line-height: 1.6; }
        .equation { font-family: 'Times New Roman', serif; font-size: 1.1rem; text-align: center; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 6px; margin: 10px 0; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Ornstein-Uhlenbeck Process</h1>
            <p class="subtitle">Mean-reverting stochastic process</p>
        </header>
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas" width="900" height="550"></canvas>
            </div>
            <div class="controls">
                <div class="panel">
                    <h3>Parameters</h3>
                    <div class="control-group">
                        <label>Mean Level (μ): <span id="mu-val">0.0</span></label>
                        <input type="range" id="mu" min="-2" max="2" step="0.1" value="0">
                    </div>
                    <div class="control-group">
                        <label>Mean Reversion Speed (θ): <span id="theta-val">1.0</span></label>
                        <input type="range" id="theta" min="0.1" max="5" step="0.1" value="1">
                    </div>
                    <div class="control-group">
                        <label>Volatility (σ): <span id="sigma-val">0.5</span></label>
                        <input type="range" id="sigma" min="0.1" max="2" step="0.05" value="0.5">
                    </div>
                    <div class="equation">
                        dX = θ(μ - X)dt + σdW
                    </div>
                </div>
                <div class="panel">
                    <h3>Simulation</h3>
                    <div class="control-group">
                        <label>Number of Paths: <span id="paths-val">5</span></label>
                        <input type="range" id="paths" min="1" max="20" value="5">
                    </div>
                    <div class="control-group">
                        <label>Time Steps: <span id="steps-val">500</span></label>
                        <input type="range" id="steps" min="100" max="1000" step="50" value="500">
                    </div>
                    <button onclick="simulate()">New Simulation</button>
                    <button onclick="toggleAnimation()">Start/Stop Animation</button>
                </div>
                <div class="panel">
                    <h3>Statistics</h3>
                    <div class="stats">
                        <div class="stat">
                            <div class="stat-value" id="current-mean">0</div>
                            <div class="stat-label">Sample Mean</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="current-var">0</div>
                            <div class="stat-label">Sample Variance</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="theory-mean">0</div>
                            <div class="stat-label">Theory Mean</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="theory-var">0</div>
                            <div class="stat-label">Stationary Var</div>
                        </div>
                    </div>
                </div>
                <div class="panel">
                    <h3>Autocorrelation</h3>
                    <canvas id="acf-canvas" width="280" height="100"></canvas>
                </div>
                <div class="panel">
                    <h3>About</h3>
                    <p class="info-text">
                        The Ornstein-Uhlenbeck process is a mean-reverting stochastic process.
                        The parameter θ controls reversion speed, μ is the long-run mean,
                        and σ is volatility. Used in interest rate models (Vasicek)
                        and physics (velocity of Brownian particle).
                    </p>
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const acfCanvas = document.getElementById('acf-canvas');
        const acfCtx = acfCanvas.getContext('2d');

        let paths = [];
        let animating = false;
        let animFrame = 0;
        let animationId = null;

        const colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#e91e63', '#00bcd4', '#ff9800', '#4caf50',
            '#673ab7', '#ff5722', '#795548', '#607d8b', '#8bc34a',
            '#03a9f4', '#ffc107', '#ff4081', '#7c4dff', '#69f0ae'
        ];

        function getParams() {
            return {
                mu: parseFloat(document.getElementById('mu').value),
                theta: parseFloat(document.getElementById('theta').value),
                sigma: parseFloat(document.getElementById('sigma').value),
                numPaths: parseInt(document.getElementById('paths').value),
                steps: parseInt(document.getElementById('steps').value)
            };
        }

        function gaussianRandom() {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        function simulate() {
            const { mu, theta, sigma, numPaths, steps } = getParams();
            const dt = 0.01;
            paths = [];

            for (let p = 0; p < numPaths; p++) {
                const path = [mu + (Math.random() - 0.5) * 2]; // Random start near mu

                for (let i = 1; i < steps; i++) {
                    const x = path[i - 1];
                    const drift = theta * (mu - x) * dt;
                    const diffusion = sigma * Math.sqrt(dt) * gaussianRandom();
                    path.push(x + drift + diffusion);
                }

                paths.push(path);
            }

            animFrame = 0;
            updateStats();
            drawACF();
            draw();
        }

        function toggleAnimation() {
            animating = !animating;
            if (animating) {
                animate();
            } else if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }

        function animate() {
            if (!animating) return;

            animFrame += 2;
            const { steps } = getParams();
            if (animFrame >= steps) {
                animFrame = steps;
                animating = false;
            }

            draw();
            if (animating) {
                animationId = requestAnimationFrame(animate);
            }
        }

        function updateStats() {
            const { mu, theta, sigma } = getParams();

            // Sample statistics from final values
            if (paths.length > 0) {
                const finalValues = paths.map(p => p[p.length - 1]);
                const sampleMean = finalValues.reduce((a, b) => a + b, 0) / finalValues.length;
                const sampleVar = finalValues.reduce((a, b) => a + (b - sampleMean) ** 2, 0) / finalValues.length;

                document.getElementById('current-mean').textContent = sampleMean.toFixed(3);
                document.getElementById('current-var').textContent = sampleVar.toFixed(3);
            }

            // Theoretical values
            document.getElementById('theory-mean').textContent = mu.toFixed(3);
            const stationaryVar = (sigma * sigma) / (2 * theta);
            document.getElementById('theory-var').textContent = stationaryVar.toFixed(3);
        }

        function drawACF() {
            const { theta } = getParams();
            acfCtx.clearRect(0, 0, acfCanvas.width, acfCanvas.height);

            const padding = 20;
            const w = acfCanvas.width - 2 * padding;
            const h = acfCanvas.height - 2 * padding;

            // Draw axes
            acfCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            acfCtx.lineWidth = 1;
            acfCtx.beginPath();
            acfCtx.moveTo(padding, padding);
            acfCtx.lineTo(padding, padding + h);
            acfCtx.lineTo(padding + w, padding + h);
            acfCtx.stroke();

            // Draw theoretical ACF: ρ(τ) = exp(-θτ)
            acfCtx.strokeStyle = '#00cec9';
            acfCtx.lineWidth = 2;
            acfCtx.beginPath();
            const maxLag = 2;
            for (let i = 0; i <= 50; i++) {
                const tau = (i / 50) * maxLag;
                const acf = Math.exp(-theta * tau);
                const x = padding + (i / 50) * w;
                const y = padding + h * (1 - acf);
                if (i === 0) acfCtx.moveTo(x, y);
                else acfCtx.lineTo(x, y);
            }
            acfCtx.stroke();

            // Labels
            acfCtx.fillStyle = '#888';
            acfCtx.font = '10px sans-serif';
            acfCtx.textAlign = 'center';
            acfCtx.fillText('τ', padding + w / 2, acfCanvas.height - 5);
            acfCtx.fillText('ρ(τ)', 10, padding + h / 2);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const { mu, steps } = getParams();
            const padding = 60;
            const chartWidth = canvas.width - 2 * padding;
            const chartHeight = canvas.height - 2 * padding;

            // Find y range
            let yMin = Infinity, yMax = -Infinity;
            const frameToDraw = animFrame > 0 ? animFrame : steps;

            for (const path of paths) {
                for (let i = 0; i < Math.min(frameToDraw, path.length); i++) {
                    yMin = Math.min(yMin, path[i]);
                    yMax = Math.max(yMax, path[i]);
                }
            }

            const yRange = Math.max(yMax - yMin, 1);
            yMin -= yRange * 0.1;
            yMax += yRange * 0.1;

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = padding + (i / 10) * chartHeight;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + chartWidth, y);
                ctx.stroke();
            }

            // Draw mean line
            const muY = padding + chartHeight * (1 - (mu - yMin) / (yMax - yMin));
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding, muY);
            ctx.lineTo(padding + chartWidth, muY);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#fff';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(`μ = ${mu.toFixed(1)}`, padding - 5, muY + 4);

            // Draw stationary distribution on right side
            const { theta, sigma } = getParams();
            const stationaryVar = (sigma * sigma) / (2 * theta);
            const stationarySd = Math.sqrt(stationaryVar);

            ctx.fillStyle = 'rgba(0, 206, 201, 0.1)';
            ctx.beginPath();
            const distWidth = 40;
            ctx.moveTo(padding + chartWidth, muY);
            for (let y = yMin; y <= yMax; y += 0.02) {
                const py = padding + chartHeight * (1 - (y - yMin) / (yMax - yMin));
                const prob = Math.exp(-((y - mu) ** 2) / (2 * stationaryVar)) / (stationarySd * Math.sqrt(2 * Math.PI));
                const px = padding + chartWidth + prob * distWidth * 50;
                ctx.lineTo(px, py);
            }
            ctx.lineTo(padding + chartWidth, padding);
            ctx.closePath();
            ctx.fill();

            // Draw paths
            for (let p = 0; p < paths.length; p++) {
                const path = paths[p];
                ctx.strokeStyle = colors[p % colors.length];
                ctx.lineWidth = 1.5;
                ctx.beginPath();

                for (let i = 0; i < Math.min(frameToDraw, path.length); i++) {
                    const x = padding + (i / steps) * chartWidth;
                    const y = padding + chartHeight * (1 - (path[i] - yMin) / (yMax - yMin));
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Draw current point
                if (frameToDraw > 0 && frameToDraw <= path.length) {
                    const i = frameToDraw - 1;
                    const x = padding + (i / steps) * chartWidth;
                    const y = padding + chartHeight * (1 - (path[i] - yMin) / (yMax - yMin));
                    ctx.fillStyle = colors[p % colors.length];
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + chartHeight);
            ctx.lineTo(padding + chartWidth, padding + chartHeight);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Time', padding + chartWidth / 2, canvas.height - 15);

            ctx.save();
            ctx.translate(15, padding + chartHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('X(t)', 0, 0);
            ctx.restore();

            // Y-axis labels
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const val = yMin + (i / 5) * (yMax - yMin);
                const y = padding + chartHeight - (i / 5) * chartHeight;
                ctx.fillText(val.toFixed(1), padding - 10, y + 4);
            }
        }

        // Event listeners
        ['mu', 'theta', 'sigma', 'paths', 'steps'].forEach(id => {
            document.getElementById(id).addEventListener('input', e => {
                document.getElementById(id + '-val').textContent = e.target.value;
                if (id === 'theta') drawACF();
            });
        });

        simulate();
    </script>
</body>
</html>
