<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reynolds Number - Laminar vs Turbulent</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0a0a15; font-family: Arial; }
        canvas { display: block; }
        .info { position: absolute; top: 20px; left: 20px; color: #ffaa88; background: rgba(0,0,0,0.9); padding: 15px; border-radius: 10px; }
    </style>
</head>
<body>
    <div class="info">
        <h2>Reynolds Number</h2>
        <p>Re = ρvL/μ</p>
        <p>Low Re: Laminar (smooth)</p>
        <p>High Re: Turbulent (chaotic)</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        class StreamLine {
            constructor(startY, reynolds, yOffset) {
                this.startY = startY;
                this.yOffset = yOffset;
                this.reynolds = reynolds;
                this.particles = [];
                this.spawnTimer = 0;
            }

            update() {
                this.spawnTimer++;
                if (this.spawnTimer > 5) {
                    this.particles.push({
                        x: 50,
                        y: this.startY + this.yOffset,
                        vy: 0,
                        phase: Math.random() * Math.PI * 2
                    });
                    this.spawnTimer = 0;
                }

                this.particles.forEach((p, idx) => {
                    p.x += 3;

                    if (this.reynolds < 2300) {
                        // Laminar: smooth flow
                        p.vy = 0;
                    } else {
                        // Turbulent: chaotic fluctuations
                        const turbulence = (this.reynolds - 2300) / 2000;
                        p.vy += (Math.random() - 0.5) * turbulence;
                        p.vy *= 0.95; // Damping
                        p.phase += 0.1;
                    }

                    p.y += p.vy;

                    if (p.x > canvas.width) {
                        this.particles.splice(idx, 1);
                    }
                });
            }

            draw() {
                this.particles.forEach(p => {
                    const hue = this.reynolds < 2300 ? 120 : 0;
                    ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }

        const laminarY = canvas.height * 0.3;
        const turbulentY = canvas.height * 0.7;

        const laminarStreams = Array.from({length: 8}, (_, i) =>
            new StreamLine(laminarY, 1000, (i - 3.5) * 15)
        );

        const turbulentStreams = Array.from({length: 8}, (_, i) =>
            new StreamLine(turbulentY, 4000, (i - 3.5) * 15)
        );

        function draw() {
            ctx.fillStyle = 'rgba(10, 10, 21, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw pipe outlines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 2;

            // Laminar pipe
            ctx.strokeRect(40, laminarY - 70, canvas.width - 80, 140);

            // Turbulent pipe
            ctx.strokeRect(40, turbulentY - 70, canvas.width - 80, 140);

            // Labels
            ctx.fillStyle = '#88ff88';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('LAMINAR FLOW', 60, laminarY - 80);
            ctx.font = '14px Arial';
            ctx.fillText('Re < 2300', 60, laminarY - 60);

            ctx.fillStyle = '#ff8888';
            ctx.font = 'bold 18px Arial';
            ctx.fillText('TURBULENT FLOW', 60, turbulentY - 80);
            ctx.font = '14px Arial';
            ctx.fillText('Re > 4000', 60, turbulentY - 60);

            // Update and draw
            laminarStreams.forEach(s => {
                s.update();
                s.draw();
            });

            turbulentStreams.forEach(s => {
                s.update();
                s.draw();
            });
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>