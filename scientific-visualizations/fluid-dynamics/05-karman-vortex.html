<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K치rm치n Vortex Street</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: Arial; }
        canvas { display: block; }
        .info { position: absolute; top: 20px; left: 20px; color: #00ddff; background: rgba(0,0,0,0.9); padding: 15px; border-radius: 10px; }
    </style>
</head>
<body>
    <div class="info">
        <h2>K치rm치n Vortex Street</h2>
        <p>Alternating vortices shed from obstacle</p>
        <p>Occurs in flow past cylinders</p>
        <p>Creates oscillating wake pattern</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const obstacleX = 300;
        const obstacleY = canvas.height / 2;
        const obstacleRadius = 40;

        let time = 0;

        class Vortex {
            constructor(x, y, strength, rotation) {
                this.x = x;
                this.y = y;
                this.strength = strength;
                this.rotation = rotation; // 1 or -1
                this.size = 20;
                this.age = 0;
            }

            update() {
                this.x += 2;
                this.age++;
                this.size += 0.3;
            }

            draw() {
                const alpha = Math.max(0, 1 - this.age / 200);

                // Draw vortex spiral
                ctx.beginPath();
                for (let angle = 0; angle < Math.PI * 4; angle += 0.1) {
                    const r = (angle / (Math.PI * 4)) * this.size;
                    const x = this.x + Math.cos(angle * this.rotation) * r;
                    const y = this.y + Math.sin(angle * this.rotation) * r;

                    if (angle === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }

                const color = this.rotation > 0 ? '100, 200, 255' : '255, 100, 150';
                ctx.strokeStyle = `rgba(${color}, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Center
                ctx.beginPath();
                ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${color}, ${alpha})`;
                ctx.fill();
            }
        }

        const vortices = [];
        let vortexTimer = 0;

        class FlowParticle {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = 0;
                this.y = Math.random() * canvas.height;
                this.trail = [];
            }

            update() {
                let vx = 3;
                let vy = 0;

                // Avoid obstacle
                const dx = this.x - obstacleX;
                const dy = this.y - obstacleY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < obstacleRadius + 50) {
                    const avoidanceStrength = (obstacleRadius + 50 - dist) / 50;
                    vx -= (dx / dist) * avoidanceStrength * 2;
                    vy -= (dy / dist) * avoidanceStrength * 2;
                }

                // Influenced by vortices
                vortices.forEach(vortex => {
                    const vdx = this.x - vortex.x;
                    const vdy = this.y - vortex.y;
                    const vdist = Math.sqrt(vdx * vdx + vdy * vdy);

                    if (vdist < vortex.size * 2) {
                        const influence = (vortex.size * 2 - vdist) / (vortex.size * 2);
                        vx += -vdy / vdist * vortex.rotation * influence;
                        vy += vdx / vdist * vortex.rotation * influence;
                    }
                });

                this.x += vx;
                this.y += vy;

                this.trail.push({x: this.x, y: this.y});
                if (this.trail.length > 30) this.trail.shift();

                if (this.x > canvas.width || this.x < 0 || this.y < 0 || this.y > canvas.height) {
                    this.reset();
                }
            }

            draw() {
                if (this.trail.length > 1) {
                    ctx.beginPath();
                    this.trail.forEach((p, i) => {
                        if (i === 0) ctx.moveTo(p.x, p.y);
                        else ctx.lineTo(p.x, p.y);
                    });
                    ctx.strokeStyle = 'rgba(0, 221, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        }

        const particles = Array.from({length: 200}, () => new FlowParticle());

        function drawObstacle() {
            const gradient = ctx.createRadialGradient(obstacleX, obstacleY, 0, obstacleX, obstacleY, obstacleRadius);
            gradient.addColorStop(0, '#666');
            gradient.addColorStop(1, '#333');

            ctx.beginPath();
            ctx.arc(obstacleX, obstacleY, obstacleRadius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Generate vortices alternately
            vortexTimer++;
            if (vortexTimer > 30) {
                const rotation = Math.sin(time * 0.1) > 0 ? 1 : -1;
                const offsetY = rotation * 30;
                vortices.push(new Vortex(
                    obstacleX + obstacleRadius,
                    obstacleY + offsetY,
                    1,
                    rotation
                ));
                vortexTimer = 0;
            }

            // Update vortices
            vortices.forEach((v, idx) => {
                v.update();
                if (v.x > canvas.width || v.age > 200) {
                    vortices.splice(idx, 1);
                }
            });

            // Draw
            particles.forEach(p => {
                p.update();
                p.draw();
            });

            vortices.forEach(v => v.draw());
            drawObstacle();

            time++;
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>