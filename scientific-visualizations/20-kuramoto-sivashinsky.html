<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kuramoto-Sivashinsky Chaos - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0;
        }

        h1 {
            font-size: 2.2rem;
            background: linear-gradient(135deg, #ef4444, #f97316);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #888;
            font-size: 1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 280px;
            gap: 20px;
            margin-top: 20px;
        }

        .canvas-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .canvas-container h3 {
            color: #ef4444;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        canvas {
            display: block;
            background: #0a0a1a;
            border-radius: 10px;
        }

        #mainCanvas {
            width: 100%;
            height: 200px;
        }

        #spacetimeCanvas {
            width: 100%;
            height: 300px;
        }

        #spectrumCanvas {
            width: 100%;
            height: 150px;
        }

        .controls {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group h3 {
            color: #ef4444;
            font-size: 0.85rem;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        label {
            display: block;
            margin: 10px 0 5px;
            color: #aaa;
            font-size: 0.8rem;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ef4444;
            cursor: pointer;
        }

        button {
            width: 100%;
            padding: 10px 15px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(239, 68, 68, 0.4);
        }

        .btn-secondary {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.5);
        }

        .btn-secondary:hover {
            background: rgba(239, 68, 68, 0.3);
        }

        select {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(239, 68, 68, 0.5);
            color: #e0e0e0;
            font-size: 0.85rem;
        }

        .stats {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            font-size: 0.8rem;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            font-family: monospace;
            color: #f97316;
        }

        .equation-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-family: 'Times New Roman', serif;
            font-size: 0.85rem;
            text-align: center;
            color: #f97316;
        }

        .info-text {
            font-size: 0.75rem;
            color: #888;
            margin-top: 5px;
            line-height: 1.4;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #ef4444;
            text-decoration: none;
            font-weight: 600;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            border: 1px solid rgba(239, 68, 68, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .back-link:hover {
            background: rgba(239, 68, 68, 0.2);
            transform: translateX(-5px);
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <div class="container">
        <header>
            <h1>Kuramoto-Sivashinsky Chaos</h1>
            <p class="subtitle">One of the Simplest Chaotic PDEs</p>
        </header>

        <div class="main-content">
            <div class="canvas-section">
                <div class="canvas-container">
                    <h3>Current Profile u(x, t)</h3>
                    <canvas id="mainCanvas"></canvas>
                </div>

                <div class="canvas-container">
                    <h3>Spatiotemporal Evolution (Space-Time Diagram)</h3>
                    <canvas id="spacetimeCanvas"></canvas>
                </div>

                <div class="canvas-container">
                    <h3>Power Spectrum |û(k)|²</h3>
                    <canvas id="spectrumCanvas"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="equation-box">
                    ∂u/∂t + u·∂u/∂x + ∂²u/∂x² + ∂⁴u/∂x⁴ = 0
                </div>

                <div class="control-group">
                    <h3>Simulation</h3>
                    <button class="btn-primary" onclick="toggleSimulation()">
                        <span id="playBtn">▶ Start</span>
                    </button>
                    <button class="btn-secondary" onclick="resetSimulation()">Reset</button>
                    <button class="btn-secondary" onclick="perturbSolution()">Add Perturbation</button>
                </div>

                <div class="control-group">
                    <h3>Initial Condition</h3>
                    <select id="initialSelect" onchange="resetSimulation()">
                        <option value="random">Random Noise</option>
                        <option value="sine">Single Sine Wave</option>
                        <option value="cosines">Multiple Cosines</option>
                        <option value="localized">Localized Bump</option>
                    </select>
                </div>

                <div class="control-group">
                    <h3>Parameters</h3>

                    <label>Domain Size L: <span id="domainValue">32π</span></label>
                    <input type="range" id="domainSlider" min="4" max="64" value="32" step="4" oninput="updateDomain()">
                    <p class="info-text">Larger domains → more chaotic</p>

                    <label>Time Step dt: <span id="dtValue">0.05</span></label>
                    <input type="range" id="dtSlider" min="0.01" max="0.1" value="0.05" step="0.01" oninput="updateParams()">

                    <label>Display Speed: <span id="speedValue">5</span></label>
                    <input type="range" id="speedSlider" min="1" max="20" value="5" step="1" oninput="updateParams()">
                </div>

                <div class="control-group">
                    <h3>Visualization</h3>
                    <select id="colormapSelect" onchange="updateColormap()">
                        <option value="thermal">Thermal (Red-Yellow)</option>
                        <option value="ocean">Ocean (Blue-Cyan)</option>
                        <option value="diverging">Diverging (Blue-Red)</option>
                        <option value="viridis">Viridis</option>
                    </select>
                </div>

                <div class="stats">
                    <div class="stat-row">
                        <span class="stat-label">Time:</span>
                        <span class="stat-value" id="timeStat">0.00</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Max |u|:</span>
                        <span class="stat-value" id="maxStat">—</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Energy:</span>
                        <span class="stat-value" id="energyStat">—</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Grid Points:</span>
                        <span class="stat-value" id="gridStat">256</span>
                    </div>
                </div>

                <p class="info-text" style="margin-top: 15px;">
                    The KS equation models flame fronts, crystal growth, and turbulent flows.
                    It exhibits spatiotemporal chaos with sensitive dependence on initial conditions.
                </p>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const mainCanvas = document.getElementById('mainCanvas');
        const mainCtx = mainCanvas.getContext('2d');
        const spacetimeCanvas = document.getElementById('spacetimeCanvas');
        const spacetimeCtx = spacetimeCanvas.getContext('2d');
        const spectrumCanvas = document.getElementById('spectrumCanvas');
        const spectrumCtx = spectrumCanvas.getContext('2d');

        function resizeCanvases() {
            [mainCanvas, spacetimeCanvas, spectrumCanvas].forEach(canvas => {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                canvas.getContext('2d').scale(window.devicePixelRatio, window.devicePixelRatio);
            });
        }

        resizeCanvases();

        // Simulation parameters
        let N = 256;  // Grid points
        let L = 32 * Math.PI;  // Domain size
        let dx = L / N;
        let dt = 0.05;
        let speed = 5;
        let time = 0;

        // State
        let u = new Array(N).fill(0);
        let spacetimeHistory = [];
        const maxHistory = 300;

        let running = false;
        let animationId = null;
        let colormap = 'thermal';

        // Colormaps
        const colormaps = {
            thermal: (v) => {
                // v in [-1, 1] -> black to red to yellow to white
                const t = (v + 1) / 2;
                if (t < 0.33) {
                    return { r: Math.floor(t * 3 * 255), g: 0, b: 0 };
                } else if (t < 0.66) {
                    const s = (t - 0.33) * 3;
                    return { r: 255, g: Math.floor(s * 255), b: 0 };
                } else {
                    const s = (t - 0.66) * 3;
                    return { r: 255, g: 255, b: Math.floor(s * 255) };
                }
            },
            ocean: (v) => {
                const t = (v + 1) / 2;
                return {
                    r: Math.floor(t * 100),
                    g: Math.floor(50 + t * 200),
                    b: Math.floor(100 + t * 155)
                };
            },
            diverging: (v) => {
                if (v < 0) {
                    const t = -v;
                    return { r: Math.floor(50 + (1-t) * 200), g: Math.floor(50 + (1-t) * 200), b: Math.floor(150 + t * 105) };
                } else {
                    const t = v;
                    return { r: Math.floor(150 + t * 105), g: Math.floor(50 + (1-t) * 200), b: Math.floor(50 + (1-t) * 200) };
                }
            },
            viridis: (v) => {
                const t = (v + 1) / 2;
                // Simplified viridis
                return {
                    r: Math.floor(68 + t * 180 - t * t * 150),
                    g: Math.floor(1 + t * 200),
                    b: Math.floor(84 + t * 100 - t * t * 50)
                };
            }
        };

        // Initialize solution
        function initializeSolution() {
            const initial = document.getElementById('initialSelect').value;

            for (let i = 0; i < N; i++) {
                const x = i * dx;

                if (initial === 'random') {
                    u[i] = 0.1 * (Math.random() - 0.5);
                } else if (initial === 'sine') {
                    u[i] = Math.sin(2 * Math.PI * x / L);
                } else if (initial === 'cosines') {
                    u[i] = Math.cos(2 * Math.PI * x / L) +
                           0.5 * Math.cos(4 * Math.PI * x / L) +
                           0.3 * Math.cos(6 * Math.PI * x / L);
                } else if (initial === 'localized') {
                    const center = L / 2;
                    const width = L / 10;
                    u[i] = 2 * Math.exp(-(x - center) * (x - center) / (2 * width * width));
                }
            }

            spacetimeHistory = [];
            time = 0;
        }

        // ETDRK4 or simple explicit method for KS equation
        // ∂u/∂t = -u·∂u/∂x - ∂²u/∂x² - ∂⁴u/∂x⁴
        // Using pseudo-spectral method in Fourier space would be ideal,
        // but we'll use finite differences for simplicity

        function stepKS() {
            const uNew = new Array(N).fill(0);

            for (let i = 0; i < N; i++) {
                // Periodic boundary indices
                const im2 = (i - 2 + N) % N;
                const im1 = (i - 1 + N) % N;
                const ip1 = (i + 1) % N;
                const ip2 = (i + 2) % N;

                // First derivative (central difference)
                const ux = (u[ip1] - u[im1]) / (2 * dx);

                // Second derivative
                const uxx = (u[ip1] - 2 * u[i] + u[im1]) / (dx * dx);

                // Fourth derivative
                const uxxxx = (u[ip2] - 4 * u[ip1] + 6 * u[i] - 4 * u[im1] + u[im2]) / (dx * dx * dx * dx);

                // KS equation: ∂u/∂t = -u·ux - uxx - uxxxx
                const dudt = -u[i] * ux - uxx - uxxxx;

                uNew[i] = u[i] + dt * dudt;
            }

            // Copy back
            for (let i = 0; i < N; i++) {
                u[i] = uNew[i];
            }

            // Store history for spacetime plot
            spacetimeHistory.push([...u]);
            if (spacetimeHistory.length > maxHistory) {
                spacetimeHistory.shift();
            }

            time += dt;
        }

        // Compute energy (L2 norm squared)
        function computeEnergy() {
            let energy = 0;
            for (let i = 0; i < N; i++) {
                energy += u[i] * u[i] * dx;
            }
            return energy;
        }

        // Compute power spectrum using DFT
        function computeSpectrum() {
            const spectrum = new Array(Math.floor(N / 2)).fill(0);

            // Simple DFT (not FFT, but works for visualization)
            for (let k = 0; k < spectrum.length; k++) {
                let real = 0, imag = 0;
                for (let n = 0; n < N; n++) {
                    const angle = -2 * Math.PI * k * n / N;
                    real += u[n] * Math.cos(angle);
                    imag += u[n] * Math.sin(angle);
                }
                spectrum[k] = (real * real + imag * imag) / (N * N);
            }

            return spectrum;
        }

        // Draw current profile
        function drawMain() {
            const rect = mainCanvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;
            const padding = { top: 20, bottom: 30, left: 40, right: 20 };

            mainCtx.fillStyle = '#0a0a1a';
            mainCtx.fillRect(0, 0, w, h);

            // Find scale
            let maxU = Math.max(...u.map(Math.abs)) || 1;
            maxU = Math.max(maxU, 1);

            // Draw axes
            mainCtx.strokeStyle = '#444';
            mainCtx.lineWidth = 1;
            mainCtx.beginPath();
            mainCtx.moveTo(padding.left, h / 2);
            mainCtx.lineTo(w - padding.right, h / 2);
            mainCtx.stroke();

            // Draw solution
            mainCtx.strokeStyle = '#ef4444';
            mainCtx.lineWidth = 2;
            mainCtx.beginPath();

            for (let i = 0; i < N; i++) {
                const x = padding.left + (i / (N - 1)) * (w - padding.left - padding.right);
                const y = h / 2 - (u[i] / maxU) * (h / 2 - padding.top);

                if (i === 0) mainCtx.moveTo(x, y);
                else mainCtx.lineTo(x, y);
            }
            mainCtx.stroke();

            // Fill area
            mainCtx.fillStyle = 'rgba(239, 68, 68, 0.15)';
            mainCtx.beginPath();
            mainCtx.moveTo(padding.left, h / 2);
            for (let i = 0; i < N; i++) {
                const x = padding.left + (i / (N - 1)) * (w - padding.left - padding.right);
                const y = h / 2 - (u[i] / maxU) * (h / 2 - padding.top);
                mainCtx.lineTo(x, y);
            }
            mainCtx.lineTo(w - padding.right, h / 2);
            mainCtx.closePath();
            mainCtx.fill();

            // Labels
            mainCtx.fillStyle = '#888';
            mainCtx.font = '10px sans-serif';
            mainCtx.textAlign = 'center';
            mainCtx.fillText('x', w / 2, h - 5);
            mainCtx.fillText('0', padding.left, h / 2 + 12);
            mainCtx.fillText('L', w - padding.right, h / 2 + 12);
        }

        // Draw spacetime diagram
        function drawSpacetime() {
            const rect = spacetimeCanvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;

            spacetimeCtx.fillStyle = '#0a0a1a';
            spacetimeCtx.fillRect(0, 0, w, h);

            if (spacetimeHistory.length < 2) {
                spacetimeCtx.fillStyle = '#666';
                spacetimeCtx.font = '12px sans-serif';
                spacetimeCtx.textAlign = 'center';
                spacetimeCtx.fillText('Run simulation to see spatiotemporal evolution', w / 2, h / 2);
                return;
            }

            // Find color scale
            let maxVal = 0;
            for (const row of spacetimeHistory) {
                for (const v of row) {
                    maxVal = Math.max(maxVal, Math.abs(v));
                }
            }
            maxVal = Math.max(maxVal, 0.1);

            // Draw as image
            const imgData = spacetimeCtx.createImageData(w, h);

            for (let py = 0; py < h; py++) {
                // Time index (bottom = recent)
                const tIdx = Math.floor((1 - py / h) * spacetimeHistory.length);
                if (tIdx < 0 || tIdx >= spacetimeHistory.length) continue;

                const row = spacetimeHistory[tIdx];

                for (let px = 0; px < w; px++) {
                    // Space index
                    const xIdx = Math.floor(px / w * N);
                    if (xIdx < 0 || xIdx >= N) continue;

                    const v = row[xIdx] / maxVal;
                    const clamped = Math.max(-1, Math.min(1, v));
                    const color = colormaps[colormap](clamped);

                    const idx = (py * w + px) * 4;
                    imgData.data[idx] = color.r;
                    imgData.data[idx + 1] = color.g;
                    imgData.data[idx + 2] = color.b;
                    imgData.data[idx + 3] = 255;
                }
            }

            spacetimeCtx.putImageData(imgData, 0, 0);

            // Labels
            spacetimeCtx.fillStyle = '#fff';
            spacetimeCtx.font = '10px sans-serif';
            spacetimeCtx.textAlign = 'left';
            spacetimeCtx.fillText('t', 5, 15);
            spacetimeCtx.fillText('↓', 5, 28);
            spacetimeCtx.textAlign = 'center';
            spacetimeCtx.fillText('x →', w / 2, h - 5);
        }

        // Draw power spectrum
        function drawSpectrum() {
            const rect = spectrumCanvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;
            const padding = { top: 15, bottom: 25, left: 40, right: 20 };

            spectrumCtx.fillStyle = '#0a0a1a';
            spectrumCtx.fillRect(0, 0, w, h);

            const spectrum = computeSpectrum();

            // Log scale
            const logSpectrum = spectrum.map(s => Math.log10(s + 1e-10));
            const minLog = Math.min(...logSpectrum);
            const maxLog = Math.max(...logSpectrum);
            const rangeLog = Math.max(maxLog - minLog, 1);

            // Draw axes
            spectrumCtx.strokeStyle = '#444';
            spectrumCtx.lineWidth = 1;
            spectrumCtx.beginPath();
            spectrumCtx.moveTo(padding.left, padding.top);
            spectrumCtx.lineTo(padding.left, h - padding.bottom);
            spectrumCtx.lineTo(w - padding.right, h - padding.bottom);
            spectrumCtx.stroke();

            // Draw spectrum as bars
            const barWidth = (w - padding.left - padding.right) / spectrum.length;

            for (let k = 0; k < spectrum.length; k++) {
                const x = padding.left + k * barWidth;
                const normalizedH = (logSpectrum[k] - minLog) / rangeLog;
                const barH = normalizedH * (h - padding.top - padding.bottom);

                const hue = 0 + (k / spectrum.length) * 60;
                spectrumCtx.fillStyle = `hsl(${hue}, 80%, 50%)`;
                spectrumCtx.fillRect(x, h - padding.bottom - barH, barWidth - 1, barH);
            }

            // Labels
            spectrumCtx.fillStyle = '#888';
            spectrumCtx.font = '10px sans-serif';
            spectrumCtx.textAlign = 'center';
            spectrumCtx.fillText('Wavenumber k', w / 2, h - 3);

            spectrumCtx.save();
            spectrumCtx.translate(12, h / 2);
            spectrumCtx.rotate(-Math.PI / 2);
            spectrumCtx.fillText('log |û|²', 0, 0);
            spectrumCtx.restore();
        }

        // Update stats
        function updateStats() {
            document.getElementById('timeStat').textContent = time.toFixed(2);
            document.getElementById('maxStat').textContent = Math.max(...u.map(Math.abs)).toFixed(3);
            document.getElementById('energyStat').textContent = computeEnergy().toFixed(3);
        }

        // Animation loop
        function animate() {
            if (!running) return;

            for (let i = 0; i < speed; i++) {
                stepKS();
            }

            drawMain();
            drawSpacetime();
            drawSpectrum();
            updateStats();

            animationId = requestAnimationFrame(animate);
        }

        // Controls
        function toggleSimulation() {
            running = !running;
            document.getElementById('playBtn').textContent = running ? '⏸ Pause' : '▶ Start';

            if (running) {
                animate();
            } else if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }

        function resetSimulation() {
            running = false;
            document.getElementById('playBtn').textContent = '▶ Start';
            if (animationId) cancelAnimationFrame(animationId);

            updateDomain();
            initializeSolution();
            drawMain();
            drawSpacetime();
            drawSpectrum();
            updateStats();
        }

        function perturbSolution() {
            for (let i = 0; i < N; i++) {
                u[i] += 0.1 * (Math.random() - 0.5);
            }
            drawMain();
        }

        function updateDomain() {
            const Lmult = parseInt(document.getElementById('domainSlider').value);
            L = Lmult * Math.PI;
            dx = L / N;
            document.getElementById('domainValue').textContent = Lmult + 'π';
            document.getElementById('gridStat').textContent = N;
        }

        function updateParams() {
            dt = parseFloat(document.getElementById('dtSlider').value);
            speed = parseInt(document.getElementById('speedSlider').value);
            document.getElementById('dtValue').textContent = dt.toFixed(2);
            document.getElementById('speedValue').textContent = speed;
        }

        function updateColormap() {
            colormap = document.getElementById('colormapSelect').value;
            drawSpacetime();
        }

        // Initialize
        window.addEventListener('resize', () => {
            resizeCanvases();
            drawMain();
            drawSpacetime();
            drawSpectrum();
        });

        resetSimulation();
    </script>
</body>
</html>
