<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Joukowski Airfoil Designer - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a192f 0%, #112240 50%, #1d3461 100%);
            min-height: 100vh;
            color: #e6f1ff;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
        }
        h1 {
            font-size: 2.2rem;
            background: linear-gradient(90deg, #64ffda, #48aff0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        .subtitle { color: #8892b0; font-size: 1rem; }
        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #64ffda;
            text-decoration: none;
            font-weight: 500;
            transition: transform 0.3s;
        }
        .back-link:hover { transform: translateX(-5px); }
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .canvas-container {
            background: rgba(17, 34, 64, 0.8);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(100, 255, 218, 0.2);
        }
        .canvas-container h3 {
            color: #64ffda;
            margin-bottom: 10px;
            font-size: 1rem;
        }
        canvas {
            display: block;
            margin: 0 auto;
            background: #0a192f;
            border-radius: 8px;
        }
        .controls {
            background: rgba(17, 34, 64, 0.8);
            border-radius: 16px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid rgba(100, 255, 218, 0.2);
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            color: #64ffda;
            font-size: 0.9rem;
            margin-bottom: 5px;
        }
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(100, 255, 218, 0.2);
            border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #64ffda;
            border-radius: 50%;
            cursor: pointer;
        }
        .value-display {
            min-width: 60px;
            text-align: right;
            color: #8892b0;
            font-family: monospace;
        }
        .info-panel {
            background: rgba(17, 34, 64, 0.8);
            border-radius: 16px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid rgba(100, 255, 218, 0.2);
        }
        .info-panel h3 {
            color: #64ffda;
            margin-bottom: 10px;
        }
        .formula {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            color: #ccd6f6;
            text-align: center;
            margin: 10px 0;
            font-size: 1.1rem;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        .stat {
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            font-size: 1.2rem;
            color: #64ffda;
            font-weight: bold;
        }
        .stat-label {
            font-size: 0.75rem;
            color: #8892b0;
        }
        .buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        button {
            padding: 10px 20px;
            background: rgba(100, 255, 218, 0.1);
            border: 1px solid #64ffda;
            border-radius: 6px;
            color: #64ffda;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(100, 255, 218, 0.2);
        }
        .help-text {
            font-size: 0.85rem;
            color: #8892b0;
            line-height: 1.6;
            margin-top: 10px;
        }
        @media (max-width: 900px) {
            .main-content { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <div class="container">
        <header>
            <h1>Joukowski Airfoil Designer</h1>
            <p class="subtitle">Conformal mapping from circle to airfoil in the complex plane</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <h3>Z-Plane (Circle + Offset)</h3>
                <canvas id="z-plane" width="500" height="500"></canvas>
                <p class="help-text">Drag the circle center to adjust the airfoil shape</p>
            </div>

            <div class="canvas-container">
                <h3>W-Plane (Joukowski Airfoil)</h3>
                <canvas id="w-plane" width="500" height="500"></canvas>
            </div>
        </div>

        <div class="controls">
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                <div class="control-group">
                    <label>Circle Center X (offset)</label>
                    <div class="control-row">
                        <input type="range" id="cx" min="-0.3" max="0.1" step="0.01" value="-0.1">
                        <span class="value-display" id="cx-val">-0.10</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Circle Center Y</label>
                    <div class="control-row">
                        <input type="range" id="cy" min="-0.2" max="0.2" step="0.01" value="0.1">
                        <span class="value-display" id="cy-val">0.10</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Resolution (points)</label>
                    <div class="control-row">
                        <input type="range" id="resolution" min="50" max="500" step="10" value="200">
                        <span class="value-display" id="res-val">200</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Angle of Attack (degrees)</label>
                    <div class="control-row">
                        <input type="range" id="aoa" min="-15" max="15" step="1" value="5">
                        <span class="value-display" id="aoa-val">5°</span>
                    </div>
                </div>
            </div>
            <div class="buttons">
                <button onclick="resetDefaults()">Reset Defaults</button>
                <button onclick="animateFlow()">Toggle Flow Lines</button>
                <button onclick="toggleCamber()">Toggle Camber Line</button>
            </div>
        </div>

        <div class="info-panel">
            <h3>Joukowski Transformation</h3>
            <div class="formula">w = z + 1/z</div>
            <p class="help-text">
                The Joukowski transformation maps a circle in the z-plane to an airfoil shape in the w-plane.
                By offsetting the circle center from the origin and ensuring it passes through z = 1,
                we get realistic airfoil shapes with sharp trailing edges.
            </p>
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="thickness-stat">12%</div>
                    <div class="stat-label">Thickness Ratio</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="camber-stat">4%</div>
                    <div class="stat-label">Maximum Camber</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="chord-stat">4.00</div>
                    <div class="stat-label">Chord Length</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="radius-stat">1.10</div>
                    <div class="stat-label">Circle Radius</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const zCanvas = document.getElementById('z-plane');
        const wCanvas = document.getElementById('w-plane');
        const zCtx = zCanvas.getContext('2d');
        const wCtx = wCanvas.getContext('2d');

        // Parameters
        let cx = -0.1;  // Circle center x (offset from origin)
        let cy = 0.1;   // Circle center y
        let resolution = 200;
        let angleOfAttack = 5;
        let showFlow = false;
        let showCamber = true;

        // Circle must pass through z = 1 for sharp trailing edge
        function getRadius() {
            return Math.sqrt((1 - cx) * (1 - cx) + cy * cy);
        }

        // Joukowski transformation: w = z + 1/z
        function joukowski(z) {
            const r2 = z.re * z.re + z.im * z.im;
            if (r2 < 0.0001) return { re: 0, im: 0 };
            return {
                re: z.re + z.re / r2,
                im: z.im - z.im / r2
            };
        }

        // Generate circle points
        function generateCircle() {
            const r = getRadius();
            const points = [];
            for (let i = 0; i <= resolution; i++) {
                const theta = (i / resolution) * 2 * Math.PI;
                points.push({
                    re: cx + r * Math.cos(theta),
                    im: cy + r * Math.sin(theta)
                });
            }
            return points;
        }

        // Transform circle to airfoil
        function transformToAirfoil(circlePoints) {
            return circlePoints.map(p => joukowski(p));
        }

        // Calculate airfoil statistics
        function calculateStats(airfoilPoints) {
            let minX = Infinity, maxX = -Infinity;
            let maxY = -Infinity, minY = Infinity;
            let maxCamberY = 0;

            airfoilPoints.forEach(p => {
                minX = Math.min(minX, p.re);
                maxX = Math.max(maxX, p.re);
                maxY = Math.max(maxY, p.im);
                minY = Math.min(minY, p.im);
            });

            const chord = maxX - minX;
            const thickness = (maxY - minY) / chord * 100;

            // Approximate camber (maximum deviation of mean line from chord)
            const camber = Math.abs(cy) * 100;

            return {
                chord: chord.toFixed(2),
                thickness: thickness.toFixed(1) + '%',
                camber: camber.toFixed(1) + '%',
                radius: getRadius().toFixed(2)
            };
        }

        // Draw z-plane (circle)
        function drawZPlane() {
            const w = zCanvas.width;
            const h = zCanvas.height;
            const scale = 150;

            zCtx.clearRect(0, 0, w, h);

            // Grid
            zCtx.strokeStyle = 'rgba(100, 255, 218, 0.1)';
            zCtx.lineWidth = 1;
            for (let i = -2; i <= 2; i += 0.5) {
                // Vertical
                zCtx.beginPath();
                zCtx.moveTo(w/2 + i * scale, 0);
                zCtx.lineTo(w/2 + i * scale, h);
                zCtx.stroke();
                // Horizontal
                zCtx.beginPath();
                zCtx.moveTo(0, h/2 - i * scale);
                zCtx.lineTo(w, h/2 - i * scale);
                zCtx.stroke();
            }

            // Axes
            zCtx.strokeStyle = 'rgba(100, 255, 218, 0.3)';
            zCtx.lineWidth = 2;
            zCtx.beginPath();
            zCtx.moveTo(0, h/2);
            zCtx.lineTo(w, h/2);
            zCtx.moveTo(w/2, 0);
            zCtx.lineTo(w/2, h);
            zCtx.stroke();

            // Unit circle (dashed)
            zCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            zCtx.setLineDash([5, 5]);
            zCtx.beginPath();
            zCtx.arc(w/2, h/2, scale, 0, Math.PI * 2);
            zCtx.stroke();
            zCtx.setLineDash([]);

            // Draw the offset circle
            const r = getRadius();
            zCtx.strokeStyle = '#64ffda';
            zCtx.lineWidth = 2;
            zCtx.beginPath();
            zCtx.arc(w/2 + cx * scale, h/2 - cy * scale, r * scale, 0, Math.PI * 2);
            zCtx.stroke();

            // Fill circle
            zCtx.fillStyle = 'rgba(100, 255, 218, 0.1)';
            zCtx.fill();

            // Mark center
            zCtx.fillStyle = '#64ffda';
            zCtx.beginPath();
            zCtx.arc(w/2 + cx * scale, h/2 - cy * scale, 6, 0, Math.PI * 2);
            zCtx.fill();

            // Mark the point z = 1 (trailing edge maps here)
            zCtx.fillStyle = '#ff6b6b';
            zCtx.beginPath();
            zCtx.arc(w/2 + scale, h/2, 6, 0, Math.PI * 2);
            zCtx.fill();

            // Mark origin
            zCtx.fillStyle = '#ffd93d';
            zCtx.beginPath();
            zCtx.arc(w/2, h/2, 4, 0, Math.PI * 2);
            zCtx.fill();

            // Labels
            zCtx.fillStyle = '#8892b0';
            zCtx.font = '12px sans-serif';
            zCtx.fillText('z = 1', w/2 + scale + 10, h/2 - 5);
            zCtx.fillText('Origin', w/2 + 5, h/2 - 10);
            zCtx.fillText(`Center (${cx.toFixed(2)}, ${cy.toFixed(2)})`,
                w/2 + cx * scale + 10, h/2 - cy * scale - 10);
        }

        // Draw w-plane (airfoil)
        function drawWPlane() {
            const w = wCanvas.width;
            const h = wCanvas.height;
            const scale = 100;

            wCtx.clearRect(0, 0, w, h);

            // Grid
            wCtx.strokeStyle = 'rgba(100, 255, 218, 0.1)';
            wCtx.lineWidth = 1;
            for (let i = -3; i <= 3; i++) {
                wCtx.beginPath();
                wCtx.moveTo(w/2 + i * scale, 0);
                wCtx.lineTo(w/2 + i * scale, h);
                wCtx.stroke();
                wCtx.beginPath();
                wCtx.moveTo(0, h/2 - i * scale);
                wCtx.lineTo(w, h/2 - i * scale);
                wCtx.stroke();
            }

            // Axes
            wCtx.strokeStyle = 'rgba(100, 255, 218, 0.3)';
            wCtx.lineWidth = 2;
            wCtx.beginPath();
            wCtx.moveTo(0, h/2);
            wCtx.lineTo(w, h/2);
            wCtx.moveTo(w/2, 0);
            wCtx.lineTo(w/2, h);
            wCtx.stroke();

            // Generate and draw airfoil
            const circle = generateCircle();
            const airfoil = transformToAirfoil(circle);

            // Apply angle of attack rotation
            const aoaRad = angleOfAttack * Math.PI / 180;
            const rotatedAirfoil = airfoil.map(p => ({
                re: p.re * Math.cos(aoaRad) + p.im * Math.sin(aoaRad),
                im: -p.re * Math.sin(aoaRad) + p.im * Math.cos(aoaRad)
            }));

            // Draw airfoil
            wCtx.beginPath();
            wCtx.moveTo(w/2 + rotatedAirfoil[0].re * scale, h/2 - rotatedAirfoil[0].im * scale);
            for (let i = 1; i < rotatedAirfoil.length; i++) {
                wCtx.lineTo(w/2 + rotatedAirfoil[i].re * scale, h/2 - rotatedAirfoil[i].im * scale);
            }
            wCtx.closePath();
            wCtx.fillStyle = 'rgba(100, 255, 218, 0.2)';
            wCtx.fill();
            wCtx.strokeStyle = '#64ffda';
            wCtx.lineWidth = 2;
            wCtx.stroke();

            // Draw camber line (mean line) if enabled
            if (showCamber) {
                wCtx.strokeStyle = '#ffd93d';
                wCtx.lineWidth = 1;
                wCtx.setLineDash([5, 5]);
                wCtx.beginPath();

                // Simple camber line approximation
                const n = rotatedAirfoil.length;
                for (let i = 0; i < n / 2; i++) {
                    const upper = rotatedAirfoil[i];
                    const lower = rotatedAirfoil[n - 1 - i];
                    const midY = (upper.im + lower.im) / 2;
                    const midX = (upper.re + lower.re) / 2;
                    if (i === 0) {
                        wCtx.moveTo(w/2 + midX * scale, h/2 - midY * scale);
                    } else {
                        wCtx.lineTo(w/2 + midX * scale, h/2 - midY * scale);
                    }
                }
                wCtx.stroke();
                wCtx.setLineDash([]);
            }

            // Draw flow lines if enabled
            if (showFlow) {
                drawFlowLines(w, h, scale);
            }

            // Mark trailing edge
            wCtx.fillStyle = '#ff6b6b';
            wCtx.beginPath();
            wCtx.arc(w/2 + 2 * scale, h/2, 5, 0, Math.PI * 2);
            wCtx.fill();

            // Update stats
            const stats = calculateStats(airfoil);
            document.getElementById('thickness-stat').textContent = stats.thickness;
            document.getElementById('camber-stat').textContent = stats.camber;
            document.getElementById('chord-stat').textContent = stats.chord;
            document.getElementById('radius-stat').textContent = stats.radius;
        }

        // Draw simplified flow lines
        function drawFlowLines(w, h, scale) {
            wCtx.strokeStyle = 'rgba(72, 175, 240, 0.3)';
            wCtx.lineWidth = 1;

            const aoaRad = angleOfAttack * Math.PI / 180;

            for (let y = -2; y <= 2; y += 0.3) {
                wCtx.beginPath();
                let started = false;

                for (let x = -3; x <= 3; x += 0.05) {
                    // Simple flow deflection based on distance to airfoil
                    const deflection = Math.exp(-0.5 * (y * y)) * 0.2 * Math.sign(y);
                    const flowY = y + deflection * Math.sin(x + Math.PI);

                    // Rotate by AoA
                    const rotX = x * Math.cos(aoaRad) + flowY * Math.sin(aoaRad);
                    const rotY = -x * Math.sin(aoaRad) + flowY * Math.cos(aoaRad);

                    if (!started) {
                        wCtx.moveTo(w/2 + rotX * scale, h/2 - rotY * scale);
                        started = true;
                    } else {
                        wCtx.lineTo(w/2 + rotX * scale, h/2 - rotY * scale);
                    }
                }
                wCtx.stroke();
            }
        }

        function draw() {
            drawZPlane();
            drawWPlane();
        }

        // Event handlers
        document.getElementById('cx').addEventListener('input', (e) => {
            cx = parseFloat(e.target.value);
            document.getElementById('cx-val').textContent = cx.toFixed(2);
            draw();
        });

        document.getElementById('cy').addEventListener('input', (e) => {
            cy = parseFloat(e.target.value);
            document.getElementById('cy-val').textContent = cy.toFixed(2);
            draw();
        });

        document.getElementById('resolution').addEventListener('input', (e) => {
            resolution = parseInt(e.target.value);
            document.getElementById('res-val').textContent = resolution;
            draw();
        });

        document.getElementById('aoa').addEventListener('input', (e) => {
            angleOfAttack = parseInt(e.target.value);
            document.getElementById('aoa-val').textContent = angleOfAttack + '°';
            draw();
        });

        // Drag to move circle center
        let dragging = false;
        zCanvas.addEventListener('mousedown', (e) => {
            const rect = zCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const scale = 150;
            const centerX = zCanvas.width/2 + cx * scale;
            const centerY = zCanvas.height/2 - cy * scale;
            const dx = x - centerX;
            const dy = y - centerY;
            if (dx * dx + dy * dy < 400) {
                dragging = true;
            }
        });

        zCanvas.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const rect = zCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const scale = 150;
            cx = (x - zCanvas.width/2) / scale;
            cy = (zCanvas.height/2 - y) / scale;
            cx = Math.max(-0.3, Math.min(0.1, cx));
            cy = Math.max(-0.2, Math.min(0.2, cy));
            document.getElementById('cx').value = cx;
            document.getElementById('cy').value = cy;
            document.getElementById('cx-val').textContent = cx.toFixed(2);
            document.getElementById('cy-val').textContent = cy.toFixed(2);
            draw();
        });

        zCanvas.addEventListener('mouseup', () => dragging = false);
        zCanvas.addEventListener('mouseleave', () => dragging = false);

        function resetDefaults() {
            cx = -0.1;
            cy = 0.1;
            resolution = 200;
            angleOfAttack = 5;
            document.getElementById('cx').value = cx;
            document.getElementById('cy').value = cy;
            document.getElementById('resolution').value = resolution;
            document.getElementById('aoa').value = angleOfAttack;
            document.getElementById('cx-val').textContent = cx.toFixed(2);
            document.getElementById('cy-val').textContent = cy.toFixed(2);
            document.getElementById('res-val').textContent = resolution;
            document.getElementById('aoa-val').textContent = angleOfAttack + '°';
            draw();
        }

        function animateFlow() {
            showFlow = !showFlow;
            draw();
        }

        function toggleCamber() {
            showCamber = !showCamber;
            draw();
        }

        // Expose for enhance.js keyboard shortcuts
        window.reset = resetDefaults;

        // Initial draw
        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
