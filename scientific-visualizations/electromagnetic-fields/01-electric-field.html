<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electric Field Lines</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff00;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="info">
        <h2>Electric Field Lines</h2>
        <p>Field lines from positive to negative charges</p>
        <p>Strength indicated by line density</p>
        <p>Click to add/remove charges (left: +, right: -)</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        class Charge {
            constructor(x, y, charge) {
                this.x = x;
                this.y = y;
                this.charge = charge; // positive or negative
            }

            draw() {
                const radius = Math.abs(this.charge) * 15;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, radius);

                if (this.charge > 0) {
                    gradient.addColorStop(0, '#ffff00');
                    gradient.addColorStop(0.5, '#ff8800');
                    gradient.addColorStop(1, '#ff0000');
                } else {
                    gradient.addColorStop(0, '#00ffff');
                    gradient.addColorStop(0.5, '#0088ff');
                    gradient.addColorStop(1, '#0000ff');
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw + or - symbol
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.charge > 0 ? '+' : '-', this.x, this.y);
            }
        }

        const charges = [
            new Charge(canvas.width * 0.3, canvas.height / 2, 2),
            new Charge(canvas.width * 0.7, canvas.height / 2, -2)
        ];

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if clicking near existing charge
            for (let i = charges.length - 1; i >= 0; i--) {
                const dx = charges[i].x - x;
                const dy = charges[i].y - y;
                if (Math.sqrt(dx * dx + dy * dy) < 30) {
                    charges.splice(i, 1);
                    return;
                }
            }

            // Add new charge (left click = positive, will use right click for negative)
            charges.push(new Charge(x, y, 1));
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            charges.push(new Charge(x, y, -1));
        });

        function calculateField(x, y) {
            let Ex = 0;
            let Ey = 0;

            charges.forEach(charge => {
                const dx = x - charge.x;
                const dy = y - charge.y;
                const distSq = dx * dx + dy * dy;
                const dist = Math.sqrt(distSq);

                if (dist > 1) {
                    const k = 1000; // Coulomb constant
                    const E = k * charge.charge / distSq;
                    Ex += E * dx / dist;
                    Ey += E * dy / dist;
                }
            });

            return {Ex, Ey};
        }

        function drawFieldLine(startX, startY, direction) {
            const points = [];
            let x = startX;
            let y = startY;
            const stepSize = 3;
            const maxSteps = 500;

            for (let i = 0; i < maxSteps; i++) {
                points.push({x, y});

                const field = calculateField(x, y);
                const magnitude = Math.sqrt(field.Ex * field.Ex + field.Ey * field.Ey);

                if (magnitude < 0.1) break;

                // Normalize and step
                x += direction * (field.Ex / magnitude) * stepSize;
                y += direction * (field.Ey / magnitude) * stepSize;

                // Check if hit a charge or out of bounds
                let hitCharge = false;
                charges.forEach(charge => {
                    const dx = x - charge.x;
                    const dy = y - charge.y;
                    if (Math.sqrt(dx * dx + dy * dy) < 15) {
                        hitCharge = true;
                    }
                });

                if (hitCharge || x < 0 || x > canvas.width || y < 0 || y > canvas.height) {
                    break;
                }
            }

            // Draw the line
            if (points.length > 5) {
                ctx.beginPath();
                points.forEach((point, i) => {
                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });

                const gradient = ctx.createLinearGradient(
                    points[0].x, points[0].y,
                    points[points.length - 1].x, points[points.length - 1].y
                );
                gradient.addColorStop(0, 'rgba(0, 255, 0, 0.7)');
                gradient.addColorStop(0.5, 'rgba(0, 200, 100, 0.5)');
                gradient.addColorStop(1, 'rgba(0, 150, 150, 0.3)');

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw arrow
                if (points.length > 10) {
                    const arrowIndex = Math.floor(points.length / 2);
                    const p1 = points[arrowIndex - 1];
                    const p2 = points[arrowIndex];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const angle = Math.atan2(dy, dx);

                    ctx.save();
                    ctx.translate(p2.x, p2.y);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-8, -4);
                    ctx.lineTo(-8, 4);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
                    ctx.fill();
                    ctx.restore();
                }
            }
        }

        function drawFieldLines() {
            // Draw field lines starting from positive charges
            charges.forEach(charge => {
                if (charge.charge > 0) {
                    const numLines = 16;
                    for (let i = 0; i < numLines; i++) {
                        const angle = (i / numLines) * Math.PI * 2;
                        const startX = charge.x + Math.cos(angle) * 20;
                        const startY = charge.y + Math.sin(angle) * 20;
                        drawFieldLine(startX, startY, 1);
                    }
                }
            });
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw field intensity as background
            const resolution = 20;
            for (let x = 0; x < canvas.width; x += resolution) {
                for (let y = 0; y < canvas.height; y += resolution) {
                    const field = calculateField(x, y);
                    const magnitude = Math.sqrt(field.Ex * field.Ex + field.Ey * field.Ey);
                    const intensity = Math.min(1, magnitude / 50);

                    ctx.fillStyle = `rgba(0, 50, 0, ${intensity * 0.3})`;
                    ctx.fillRect(x, y, resolution, resolution);
                }
            }

            drawFieldLines();

            charges.forEach(charge => charge.draw());
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        animate();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>