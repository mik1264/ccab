<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electric Field Lines - GPU Accelerated</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff00;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
        }
        .badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 100, 255, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="info">
        <h2>Electric Field Lines (GPU)</h2>
        <p>Field lines from positive to negative charges</p>
        <p>Strength indicated by line density</p>
        <p>Click to add/remove charges (left: +, right: -)</p>
        <p><strong>GPU vector field calculation</strong></p>
    </div>
    <div class="badge">GPU-Accelerated • Three.js TSL • Physics Simulation</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/nodes": "https://unpkg.com/three@0.160.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { uniform, uv, vec2, vec3, vec4, length, mix, dot, sub, mul, add, min as minNode, abs as absNode, sqrt, MeshBasicNodeMaterial, positionLocal, varying, Loop, Break, If } from 'three/nodes';

        let camera, scene, renderer;
        let fieldMaterial;
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();

        const MAX_CHARGES = 8;
        const charges = [
            { pos: new THREE.Vector3(-0.4, 0, 0), charge: 2.0 },
            { pos: new THREE.Vector3(0.4, 0, 0), charge: -2.0 }
        ];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();

            camera = new THREE.OrthographicCamera(-1.5, 1.5, 1.5, -1.5, 0.1, 10);
            camera.position.z = 1;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Create field intensity background
            createFieldBackground();

            // Create field lines
            createFieldLines();

            // Create charge objects
            updateCharges();

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('contextmenu', onRightClick);
        }

        function createFieldBackground() {
            const geometry = new THREE.PlaneGeometry(3, 3);

            // Keep as ShaderMaterial due to complex array uniforms and dynamic loop
            // TSL doesn't handle dynamic uniform arrays and loops as elegantly
            fieldMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    numCharges: { value: charges.length },
                    chargePositions: { value: charges.map(c => c.pos) },
                    chargeValues: { value: charges.map(c => c.charge) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform int numCharges;
                    uniform vec3 chargePositions[${MAX_CHARGES}];
                    uniform float chargeValues[${MAX_CHARGES}];

                    varying vec2 vUv;

                    void main() {
                        vec2 pos = (vUv - 0.5) * 3.0;

                        float fieldMagnitude = 0.0;

                        for(int i = 0; i < ${MAX_CHARGES}; i++) {
                            if(i >= numCharges) break;

                            vec2 chargePos = chargePositions[i].xy;
                            vec2 r = pos - chargePos;
                            float distSq = dot(r, r);
                            float dist = sqrt(distSq);

                            if(dist > 0.01) {
                                float k = 1.0;
                                float E = k * abs(chargeValues[i]) / distSq;
                                fieldMagnitude += E;
                            }
                        }

                        float intensity = min(1.0, fieldMagnitude / 20.0);

                        vec3 color = vec3(0.0, intensity * 0.2, 0.0);
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                transparent: true
            });

            const plane = new THREE.Mesh(geometry, fieldMaterial);
            plane.position.z = -0.1;
            scene.add(plane);
        }

        function createFieldLines() {
            // Remove old field lines
            scene.children = scene.children.filter(child =>
                !child.userData.isFieldLine
            );

            charges.forEach((charge, chargeIdx) => {
                if (charge.charge <= 0) return; // Only draw from positive charges

                const numLines = 16;
                for (let i = 0; i < numLines; i++) {
                    const angle = (i / numLines) * Math.PI * 2;
                    const startOffset = 0.06;
                    const startX = charge.pos.x + Math.cos(angle) * startOffset;
                    const startY = charge.pos.y + Math.sin(angle) * startOffset;

                    createFieldLine(startX, startY);
                }
            });
        }

        function createFieldLine(startX, startY) {
            const maxSteps = 200;
            const stepSize = 0.01;
            const points = [];

            let x = startX;
            let y = startY;

            for (let step = 0; step < maxSteps; step++) {
                points.push(new THREE.Vector3(x, y, 0));

                // Calculate field at current position
                let Ex = 0, Ey = 0;

                for (let charge of charges) {
                    const dx = x - charge.pos.x;
                    const dy = y - charge.pos.y;
                    const distSq = dx * dx + dy * dy;
                    const dist = Math.sqrt(distSq);

                    if (dist > 0.01) {
                        const k = 1.0;
                        const E = k * charge.charge / distSq;
                        Ex += E * dx / dist;
                        Ey += E * dy / dist;
                    }
                }

                const magnitude = Math.sqrt(Ex * Ex + Ey * Ey);
                if (magnitude < 0.1) break;

                // Normalize and step
                x += (Ex / magnitude) * stepSize;
                y += (Ey / magnitude) * stepSize;

                // Check if hit a charge or out of bounds
                let hitCharge = false;
                for (let charge of charges) {
                    const dx = x - charge.pos.x;
                    const dy = y - charge.pos.y;
                    if (Math.sqrt(dx * dx + dy * dy) < 0.05) {
                        hitCharge = true;
                        break;
                    }
                }

                if (hitCharge || Math.abs(x) > 1.5 || Math.abs(y) > 1.5) {
                    break;
                }
            }

            if (points.length > 5) {
                const geometry = new THREE.BufferGeometry().setFromPoints(points);

                const vProgress = varying(positionLocal.z);

                const color1 = vec3(0.0, 1.0, 0.0);
                const color2 = vec3(0.0, 0.6, 0.6);
                const color = mix(color1, color2, vProgress);

                const material = new MeshBasicNodeMaterial();
                material.colorNode = vec4(color, 0.7);
                material.transparent = true;

                const line = new THREE.Line(geometry, material);
                line.userData.isFieldLine = true;
                scene.add(line);

                // Add arrow at midpoint
                if (points.length > 20) {
                    const midIdx = Math.floor(points.length / 2);
                    const p1 = points[midIdx - 1];
                    const p2 = points[midIdx];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const angle = Math.atan2(dy, dx);

                    const arrowGeometry = new THREE.BufferGeometry();
                    const arrowSize = 0.02;
                    const arrowPoints = [
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(-arrowSize * 2, -arrowSize, 0),
                        new THREE.Vector3(-arrowSize * 2, arrowSize, 0),
                        new THREE.Vector3(0, 0, 0)
                    ];
                    arrowGeometry.setFromPoints(arrowPoints);

                    const arrowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ff00,
                        transparent: true,
                        opacity: 0.7
                    });

                    const arrow = new THREE.Line(arrowGeometry, arrowMaterial);
                    arrow.position.set(p2.x, p2.y, 0.01);
                    arrow.rotation.z = angle;
                    arrow.userData.isFieldLine = true;
                    scene.add(arrow);
                }
            }
        }

        function updateCharges() {
            // Remove old charge objects
            scene.children = scene.children.filter(child =>
                !child.userData.isCharge
            );

            charges.forEach((charge, idx) => {
                // Outer glow
                const glowGeometry = new THREE.CircleGeometry(0.06, 32);
                const glowColor = charge.charge > 0 ? 0xff8800 : 0x0088ff;
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: glowColor,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(charge.pos);
                glow.position.z = 0.01;
                glow.userData.isCharge = true;
                scene.add(glow);

                // Inner charge
                const chargeGeometry = new THREE.CircleGeometry(0.04, 32);
                const chargeColor = charge.charge > 0 ? 0xffff00 : 0x00ffff;
                const chargeMaterial = new THREE.MeshBasicMaterial({
                    color: chargeColor
                });
                const chargeMesh = new THREE.Mesh(chargeGeometry, chargeMaterial);
                chargeMesh.position.copy(charge.pos);
                chargeMesh.position.z = 0.02;
                chargeMesh.userData.isCharge = true;
                chargeMesh.userData.chargeIndex = idx;
                scene.add(chargeMesh);

                // Border
                const borderGeometry = new THREE.RingGeometry(0.04, 0.045, 32);
                const borderMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    side: THREE.DoubleSide
                });
                const border = new THREE.Mesh(borderGeometry, borderMaterial);
                border.position.copy(charge.pos);
                border.position.z = 0.03;
                border.userData.isCharge = true;
                scene.add(border);

                // Label (+/-)
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 64;
                canvas.height = 64;
                context.fillStyle = '#ffffff';
                context.font = 'bold 48px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(charge.charge > 0 ? '+' : '-', 32, 32);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.copy(charge.pos);
                sprite.position.z = 0.04;
                sprite.scale.set(0.05, 0.05, 1);
                sprite.userData.isCharge = true;
                scene.add(sprite);
            });

            // Update field
            if (fieldMaterial) {
                fieldMaterial.uniforms.numCharges.value = charges.length;
                fieldMaterial.uniforms.chargePositions.value = charges.map(c => c.pos);
                fieldMaterial.uniforms.chargeValues.value = charges.map(c => c.charge);
            }

            createFieldLines();
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const worldPos = new THREE.Vector3(
                mouse.x * 1.5,
                mouse.y * 1.5,
                0
            );

            // Check if clicking near existing charge
            let removed = false;
            for (let i = charges.length - 1; i >= 0; i--) {
                const dist = worldPos.distanceTo(charges[i].pos);
                if (dist < 0.1) {
                    charges.splice(i, 1);
                    removed = true;
                    break;
                }
            }

            // Add new positive charge if not removing
            if (!removed && charges.length < MAX_CHARGES) {
                charges.push({ pos: worldPos.clone(), charge: 1.0 });
            }

            updateCharges();
        }

        function onRightClick(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const worldPos = new THREE.Vector3(
                mouse.x * 1.5,
                mouse.y * 1.5,
                0
            );

            // Add negative charge
            if (charges.length < MAX_CHARGES) {
                charges.push({ pos: worldPos.clone(), charge: -1.0 });
                updateCharges();
            }
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -1.5 * aspect;
            camera.right = 1.5 * aspect;
            camera.top = 1.5;
            camera.bottom = -1.5;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
