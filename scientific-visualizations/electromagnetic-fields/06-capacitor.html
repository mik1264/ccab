<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Capacitor Electric Field - GPU Accelerated</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0a0a15; font-family: Arial; }
        canvas { display: block; }
        .info { position: absolute; top: 20px; left: 20px; color: #ffcc00; background: rgba(0,0,0,0.9); padding: 15px; border-radius: 10px; max-width: 300px; }
        .badge { position: absolute; top: 20px; right: 20px; background: rgba(0, 100, 255, 0.9); color: white; padding: 8px 12px; border-radius: 5px; font-size: 11px; font-weight: bold; }
    </style>
</head>
<body>
    <div class="info">
        <h2>Parallel Plate Capacitor (GPU)</h2>
        <p>Uniform electric field between plates</p>
        <p>E = V/d</p>
        <p>Stores electrical energy</p>
        <p><strong>GPU field visualization</strong></p>
    </div>
    <div class="badge">GPU-Accelerated • Three.js TSL • Physics Simulation</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/nodes": "https://unpkg.com/three@0.160.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { uniform, uv, vec2, vec3, vec4, sin, mul, add, mod, MeshBasicNodeMaterial, positionLocal, varying, If, greaterThan } from 'three/nodes';

        let camera, scene, renderer;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();

            camera = new THREE.OrthographicCamera(-1.5, 1.5, 1, -1, 0.1, 10);
            camera.position.z = 1;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            createCapacitorVisualization();

            window.addEventListener('resize', onWindowResize);
        }

        function createCapacitorVisualization() {
            const plateWidth = 0.15;
            const plateHeight = 0.8;
            const separation = 1.0;

            // Create field visualization plane
            const fieldGeometry = new THREE.PlaneGeometry(separation - plateWidth * 2, plateHeight + 0.2, 1, 1);

            const timeUniform = uniform(0);

            const uvCoord = uv();
            const brightness = add(0.15, mul(sin(add(mul(timeUniform, 2.0), mul(uvCoord.x, 10.0))), 0.05));
            const color = mul(vec3(1.0, 0.8, 0.0), brightness);

            const fieldMaterial = new MeshBasicNodeMaterial();
            fieldMaterial.colorNode = vec4(color, 0.3);
            fieldMaterial.transparent = true;
            fieldMaterial.userData.timeUniform = timeUniform;

            const fieldPlane = new THREE.Mesh(fieldGeometry, fieldMaterial);
            fieldPlane.userData.isField = true;
            scene.add(fieldPlane);

            // Left plate (positive)
            createPlate(-separation/2, plateWidth, plateHeight, 0xff4444, true);

            // Right plate (negative)
            createPlate(separation/2, plateWidth, plateHeight, 0x4444ff, false);

            // Field lines
            createFieldLines(separation, plateWidth, plateHeight);

            // Equipotential lines
            createEquipotentialLines(separation, plateWidth, plateHeight);
        }

        function createPlate(x, width, height, color, isPositive) {
            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshBasicMaterial({ color: color });

            const plate = new THREE.Mesh(geometry, material);
            plate.position.x = x;
            scene.add(plate);

            // Border
            const borderGeometry = new THREE.EdgesGeometry(geometry);
            const borderMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const border = new THREE.LineSegments(borderGeometry, borderMaterial);
            border.position.x = x;
            border.position.z = 0.01;
            scene.add(border);

            // Charge symbols
            const numCharges = 8;
            for (let i = 0; i < numCharges; i++) {
                const y = -height/2 + (height / (numCharges - 1)) * i;

                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 64;
                canvas.height = 64;
                context.fillStyle = '#ffffff';
                context.font = 'bold 48px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(isPositive ? '+' : '-', 32, 32);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(x, y, 0.02);
                sprite.scale.set(0.08, 0.08, 1);
                scene.add(sprite);
            }
        }

        function createFieldLines(separation, plateWidth, plateHeight) {
            const numLines = 12;
            const startX = -separation/2 + plateWidth;
            const endX = separation/2 - plateWidth;

            for (let i = 0; i < numLines; i++) {
                const y = -plateHeight/2 + (plateHeight / (numLines - 1)) * i;

                const geometry = new THREE.BufferGeometry();
                const segments = 5;
                const positions = new Float32Array((segments + 1) * 3);

                for (let j = 0; j <= segments; j++) {
                    const x = startX + (endX - startX) * (j / segments);
                    positions[j * 3] = x;
                    positions[j * 3 + 1] = y;
                    positions[j * 3 + 2] = 0.01;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const timeUniformLine = uniform(0);

                const vProgress = varying(positionLocal.x);
                const arrowPattern = mod(add(mul(vProgress, 5.0), mul(timeUniformLine, -1.0)), 1.0);

                // Use conditional to set alpha based on arrow pattern
                const baseAlpha = 0.6;
                const highlightAlpha = 0.9;
                const alpha = If(greaterThan(arrowPattern, 0.8), highlightAlpha, baseAlpha);

                const material = new MeshBasicNodeMaterial();
                material.colorNode = vec4(vec3(1.0, 0.8, 0.0), alpha);
                material.transparent = true;
                material.userData.timeUniform = timeUniformLine;

                const line = new THREE.Line(geometry, material);
                line.userData.isFieldLine = true;
                scene.add(line);
            }
        }

        function createEquipotentialLines(separation, plateWidth, plateHeight) {
            const numLines = 7;
            const startX = -separation/2 + plateWidth;
            const endX = separation/2 - plateWidth;

            for (let i = 1; i < numLines; i++) {
                const x = startX + (endX - startX) * (i / numLines);

                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array([
                    x, -plateHeight/2 - 0.05, 0.005,
                    x, plateHeight/2 + 0.05, 0.005
                ]);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const material = new THREE.LineDashedMaterial({
                    color: 0x96ff96,
                    dashSize: 0.02,
                    gapSize: 0.02,
                    transparent: true,
                    opacity: 0.3
                });

                const line = new THREE.Line(geometry, material);
                line.computeLineDistances();
                scene.add(line);

                // Voltage label
                const voltage = ((numLines - i) / numLines) * 100;
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 32;
                context.fillStyle = 'rgba(150, 255, 150, 0.8)';
                context.font = 'bold 20px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(`${voltage.toFixed(0)}V`, 64, 16);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(x, plateHeight/2 + 0.15, 0.02);
                sprite.scale.set(0.2, 0.05, 1);
                scene.add(sprite);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;

            // Update time-dependent materials
            scene.children.forEach(child => {
                if (child.material && child.material.userData && child.material.userData.timeUniform) {
                    child.material.userData.timeUniform.value = time;
                }
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
