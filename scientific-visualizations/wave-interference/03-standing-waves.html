<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Standing Waves - GPU Accelerated</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ff66cc;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
        }
        .badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 100, 255, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="info">
        <h2>Standing Waves (GPU Accelerated)</h2>
        <p>Wave modes in bounded medium</p>
        <p>Nodes (no motion) and Antinodes (maximum motion)</p>
        <p><strong>Multiple harmonics - GPU rendered</strong></p>
    </div>
    <div class="badge">GPU-Accelerated • Three.js TSL • Physics Simulation</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let camera, scene, renderer;
        const harmonics = [
            { n: 1, y: 0.6, amplitude: 0.15, color: new THREE.Color(0xFF6B6B), frequency: 0.05 },
            { n: 2, y: 0.3, amplitude: 0.12, color: new THREE.Color(0x4ECDC4), frequency: 0.10 },
            { n: 3, y: 0.0, amplitude: 0.10, color: new THREE.Color(0xFFE66D), frequency: 0.15 },
            { n: 4, y: -0.3, amplitude: 0.09, color: new THREE.Color(0x95E1D3), frequency: 0.20 },
            { n: 5, y: -0.6, amplitude: 0.08, color: new THREE.Color(0xFF9FF3), frequency: 0.25 }
        ];

        init();
        animate();

        function init() {
            // Scene setup
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.OrthographicCamera(-1.5, 1.5, 1, -1, 0.1, 10);
            camera.position.z = 1;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Create standing wave visualizations
            harmonics.forEach((harmonic, index) => {
                createStandingWave(harmonic);
            });

            window.addEventListener('resize', onWindowResize);
        }

        function createStandingWave(harmonic) {
            const segments = 200;
            const width = 2.4;

            // Create wave line using shader
            const geometry = new THREE.PlaneGeometry(width, 0.4, segments, 1);

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    harmonic: { value: harmonic.n },
                    amplitude: { value: harmonic.amplitude },
                    frequency: { value: harmonic.frequency },
                    color: { value: harmonic.color },
                    yOffset: { value: harmonic.y }
                },
                vertexShader: `
                    uniform float time;
                    uniform int harmonic;
                    uniform float amplitude;
                    uniform float frequency;
                    uniform float yOffset;

                    varying float vDisplacement;
                    varying vec2 vUv;

                    void main() {
                        vUv = uv;

                        // Standing wave equation: y = A * sin(kx) * cos(ωt)
                        float x = (uv.x - 0.5) * 2.0;
                        float spatialPart = sin(x * float(harmonic) * 3.14159);
                        float temporalPart = cos(time * frequency * 6.28318);
                        float displacement = spatialPart * temporalPart * amplitude;

                        vDisplacement = displacement;

                        vec3 newPosition = position;
                        newPosition.y = yOffset + displacement + (uv.y - 0.5) * 0.02;

                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    varying float vDisplacement;
                    varying vec2 vUv;

                    void main() {
                        // Create gradient effect along the wave
                        float intensity = abs(vDisplacement) * 5.0;
                        vec3 finalColor = color * (0.7 + intensity * 0.3);

                        // Add brightness at edges
                        float edge = abs(vUv.y - 0.5) * 2.0;
                        finalColor += vec3(edge * 0.2);

                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });

            const waveMesh = new THREE.Mesh(geometry, material);
            waveMesh.userData.harmonic = harmonic;
            scene.add(waveMesh);

            // Add equilibrium line
            const lineGeometry = new THREE.BufferGeometry();
            const linePoints = [
                new THREE.Vector3(-width/2, harmonic.y, 0.01),
                new THREE.Vector3(width/2, harmonic.y, 0.01)
            ];
            lineGeometry.setFromPoints(linePoints);
            const lineMaterial = new THREE.LineDashedMaterial({
                color: 0xffffff,
                dashSize: 0.02,
                gapSize: 0.02,
                opacity: 0.3,
                transparent: true
            });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            line.computeLineDistances();
            scene.add(line);

            // Add boundary points
            const boundaryGeometry = new THREE.CircleGeometry(0.02, 16);
            const boundaryMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

            const leftBoundary = new THREE.Mesh(boundaryGeometry, boundaryMaterial);
            leftBoundary.position.set(-width/2, harmonic.y, 0.02);
            scene.add(leftBoundary);

            const rightBoundary = new THREE.Mesh(boundaryGeometry, boundaryMaterial);
            rightBoundary.position.set(width/2, harmonic.y, 0.02);
            scene.add(rightBoundary);

            // Add node markers
            for (let i = 0; i <= harmonic.n; i++) {
                const nodeX = -width/2 + (i / harmonic.n) * width;
                const nodeGeometry = new THREE.CircleGeometry(0.015, 16);
                const nodeMaterial = new THREE.MeshBasicMaterial({
                    color: harmonic.color,
                    transparent: true,
                    opacity: 0.8
                });
                const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                node.position.set(nodeX, harmonic.y, 0.02);
                scene.add(node);

                // Add outer ring
                const ringGeometry = new THREE.RingGeometry(0.015, 0.02, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.5
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.set(nodeX, harmonic.y, 0.02);
                scene.add(ring);
            }

            // Add antinode markers (animated)
            for (let i = 0; i < harmonic.n; i++) {
                const antinodeX = -width/2 + ((i + 0.5) / harmonic.n) * width;
                const antinodeGeometry = new THREE.CircleGeometry(0.012, 16);
                const antinodeMaterial = new THREE.MeshBasicMaterial({
                    color: harmonic.color,
                    transparent: true,
                    opacity: 0.6
                });
                const antinode = new THREE.Mesh(antinodeGeometry, antinodeMaterial);
                antinode.position.set(antinodeX, harmonic.y, 0.02);
                antinode.userData.isAntinode = true;
                antinode.userData.harmonic = harmonic;
                antinode.userData.antinodeIndex = i;
                scene.add(antinode);
            }

            // Add harmonic label
            createTextLabel(`n = ${harmonic.n}`, -width/2 - 0.15, harmonic.y, harmonic.color);
        }

        function createTextLabel(text, x, y, color) {
            // Create a canvas for text rendering
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 64;

            context.fillStyle = `rgb(${color.r * 255}, ${color.g * 255}, ${color.b * 255})`;
            context.font = 'bold 32px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 64, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.position.set(x, y, 0.03);
            sprite.scale.set(0.2, 0.1, 1);
            scene.add(sprite);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;

            // Update all wave materials
            scene.children.forEach(child => {
                if (child.material && child.material.uniforms && child.material.uniforms.time) {
                    child.material.uniforms.time.value = time;
                }

                // Animate antinodes
                if (child.userData.isAntinode) {
                    const harmonic = child.userData.harmonic;
                    const spatialPart = Math.sin((child.userData.antinodeIndex + 0.5) / harmonic.n * harmonic.n * Math.PI);
                    const temporalPart = Math.cos(time * harmonic.frequency * Math.PI * 2);
                    const displacement = spatialPart * temporalPart * harmonic.amplitude;
                    child.position.y = harmonic.y + displacement;
                }
            });

            renderer.render(scene, camera);
        }
    </script>
    <script src="../../assets/js/enhance.js" defer></script>
</body>
</html>
