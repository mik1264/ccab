<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Standing Waves - GPU Accelerated</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ff66cc;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
        }
        .badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 100, 255, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="info">
        <h2>Standing Waves (GPU Accelerated)</h2>
        <p>Wave modes in bounded medium</p>
        <p>Nodes (no motion) and Antinodes (maximum motion)</p>
        <p><strong>Multiple harmonics - GPU rendered</strong></p>
    </div>
    <div class="badge">GPU-Accelerated • Three.js TSL • Physics Simulation</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/nodes": "https://unpkg.com/three@0.160.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { uv, uniform, vec3, float, sin, cos, abs, Fn, MeshBasicNodeMaterial, positionLocal } from 'three/nodes';

        let camera, scene, renderer;
        const harmonics = [
            { n: 1, y: 0.6, amplitude: 0.15, color: new THREE.Color(0xFF6B6B), frequency: 0.05 },
            { n: 2, y: 0.3, amplitude: 0.12, color: new THREE.Color(0x4ECDC4), frequency: 0.10 },
            { n: 3, y: 0.0, amplitude: 0.10, color: new THREE.Color(0xFFE66D), frequency: 0.15 },
            { n: 4, y: -0.3, amplitude: 0.09, color: new THREE.Color(0x95E1D3), frequency: 0.20 },
            { n: 5, y: -0.6, amplitude: 0.08, color: new THREE.Color(0xFF9FF3), frequency: 0.25 }
        ];

        init();
        animate();

        function init() {
            // Scene setup
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.OrthographicCamera(-1.5, 1.5, 1, -1, 0.1, 10);
            camera.position.z = 1;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Create standing wave visualizations
            harmonics.forEach((harmonic, index) => {
                createStandingWave(harmonic);
            });

            window.addEventListener('resize', onWindowResize);
        }

        function createStandingWave(harmonic) {
            const segments = 200;
            const width = 2.4;

            // Create wave line using shader
            const geometry = new THREE.PlaneGeometry(width, 0.4, segments, 1);

            // TSL uniforms
            const uTime = uniform(0);
            const uHarmonic = uniform(harmonic.n);
            const uAmplitude = uniform(harmonic.amplitude);
            const uFrequency = uniform(harmonic.frequency);
            const uColor = uniform(vec3(harmonic.color.r, harmonic.color.g, harmonic.color.b));
            const uYOffset = uniform(harmonic.y);

            // TSL position displacement
            const positionShader = Fn(() => {
                const uvCoord = uv();

                // Standing wave equation: y = A * sin(kx) * cos(ωt)
                const x = uvCoord.x.sub(0.5).mul(2.0);
                const spatialPart = sin(x.mul(uHarmonic).mul(3.14159));
                const temporalPart = cos(uTime.mul(uFrequency).mul(6.28318));
                const displacement = spatialPart.mul(temporalPart).mul(uAmplitude);

                const newPosition = positionLocal.toVar();
                newPosition.y.assign(uYOffset.add(displacement).add(uvCoord.y.sub(0.5).mul(0.02)));

                return newPosition;
            })();

            // TSL color shader
            const colorShader = Fn(() => {
                const uvCoord = uv();

                // Calculate displacement for coloring
                const x = uvCoord.x.sub(0.5).mul(2.0);
                const spatialPart = sin(x.mul(uHarmonic).mul(3.14159));
                const temporalPart = cos(uTime.mul(uFrequency).mul(6.28318));
                const displacement = spatialPart.mul(temporalPart).mul(uAmplitude);

                // Create gradient effect along the wave
                const intensity = abs(displacement).mul(5.0);
                const intensityColor = uColor.mul(float(0.7).add(intensity.mul(0.3)));

                // Add brightness at edges
                const edge = abs(uvCoord.y.sub(0.5)).mul(2.0);
                const finalColor = intensityColor.add(vec3(edge.mul(0.2)));

                return finalColor;
            })();

            const material = new MeshBasicNodeMaterial({ side: THREE.DoubleSide });
            material.positionNode = positionShader;
            material.colorNode = colorShader;

            // Store uniforms for updates
            material.userData.uniforms = {
                time: uTime,
                harmonic: uHarmonic,
                amplitude: uAmplitude,
                frequency: uFrequency,
                color: uColor,
                yOffset: uYOffset
            };

            const waveMesh = new THREE.Mesh(geometry, material);
            waveMesh.userData.harmonic = harmonic;
            scene.add(waveMesh);

            // Add equilibrium line
            const lineGeometry = new THREE.BufferGeometry();
            const linePoints = [
                new THREE.Vector3(-width/2, harmonic.y, 0.01),
                new THREE.Vector3(width/2, harmonic.y, 0.01)
            ];
            lineGeometry.setFromPoints(linePoints);
            const lineMaterial = new THREE.LineDashedMaterial({
                color: 0xffffff,
                dashSize: 0.02,
                gapSize: 0.02,
                opacity: 0.3,
                transparent: true
            });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            line.computeLineDistances();
            scene.add(line);

            // Add boundary points
            const boundaryGeometry = new THREE.CircleGeometry(0.02, 16);
            const boundaryMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

            const leftBoundary = new THREE.Mesh(boundaryGeometry, boundaryMaterial);
            leftBoundary.position.set(-width/2, harmonic.y, 0.02);
            scene.add(leftBoundary);

            const rightBoundary = new THREE.Mesh(boundaryGeometry, boundaryMaterial);
            rightBoundary.position.set(width/2, harmonic.y, 0.02);
            scene.add(rightBoundary);

            // Add node markers
            for (let i = 0; i <= harmonic.n; i++) {
                const nodeX = -width/2 + (i / harmonic.n) * width;
                const nodeGeometry = new THREE.CircleGeometry(0.015, 16);
                const nodeMaterial = new THREE.MeshBasicMaterial({
                    color: harmonic.color,
                    transparent: true,
                    opacity: 0.8
                });
                const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                node.position.set(nodeX, harmonic.y, 0.02);
                scene.add(node);

                // Add outer ring
                const ringGeometry = new THREE.RingGeometry(0.015, 0.02, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.5
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.set(nodeX, harmonic.y, 0.02);
                scene.add(ring);
            }

            // Add antinode markers (animated)
            for (let i = 0; i < harmonic.n; i++) {
                const antinodeX = -width/2 + ((i + 0.5) / harmonic.n) * width;
                const antinodeGeometry = new THREE.CircleGeometry(0.012, 16);
                const antinodeMaterial = new THREE.MeshBasicMaterial({
                    color: harmonic.color,
                    transparent: true,
                    opacity: 0.6
                });
                const antinode = new THREE.Mesh(antinodeGeometry, antinodeMaterial);
                antinode.position.set(antinodeX, harmonic.y, 0.02);
                antinode.userData.isAntinode = true;
                antinode.userData.harmonic = harmonic;
                antinode.userData.antinodeIndex = i;
                scene.add(antinode);
            }

            // Add harmonic label
            createTextLabel(`n = ${harmonic.n}`, -width/2 - 0.15, harmonic.y, harmonic.color);
        }

        function createTextLabel(text, x, y, color) {
            // Create a canvas for text rendering
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 64;

            context.fillStyle = `rgb(${color.r * 255}, ${color.g * 255}, ${color.b * 255})`;
            context.font = 'bold 32px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 64, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.position.set(x, y, 0.03);
            sprite.scale.set(0.2, 0.1, 1);
            scene.add(sprite);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;

            // Update all wave materials
            scene.children.forEach(child => {
                if (child.material && child.material.userData && child.material.userData.uniforms && child.material.userData.uniforms.time) {
                    child.material.userData.uniforms.time.value = time;
                }

                // Animate antinodes
                if (child.userData.isAntinode) {
                    const harmonic = child.userData.harmonic;
                    const spatialPart = Math.sin((child.userData.antinodeIndex + 0.5) / harmonic.n * harmonic.n * Math.PI);
                    const temporalPart = Math.cos(time * harmonic.frequency * Math.PI * 2);
                    const displacement = spatialPart * temporalPart * harmonic.amplitude;
                    child.position.y = harmonic.y + displacement;
                }
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
