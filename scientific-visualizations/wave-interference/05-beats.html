<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beat Frequency - GPU Accelerated</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff88;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
        }
        .badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 100, 255, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="info">
        <h2>Beat Frequency (GPU Accelerated)</h2>
        <p>Interference of two close frequencies</p>
        <p>f<sub>beat</sub> = |f₁ - f₂|</p>
        <p>Creates amplitude modulation</p>
        <p><strong>GPU-rendered wave superposition</strong></p>
    </div>
    <div class="badge">GPU-Accelerated • Three.js TSL • Physics Simulation</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let camera, scene, renderer;

        const freq1 = 0.15;
        const freq2 = 0.12;
        const beatFreq = Math.abs(freq1 - freq2);
        const amplitude = 0.2;

        const waves = [
            { y: 0.5, frequency: freq1, color: new THREE.Color(0xFF6B6B), label: `f₁ = ${freq1.toFixed(2)} Hz` },
            { y: 0.0, frequency: freq2, color: new THREE.Color(0x4ECDC4), label: `f₂ = ${freq2.toFixed(2)} Hz` },
        ];

        init();
        animate();

        function init() {
            // Scene setup
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.OrthographicCamera(-1.5, 1.5, 1, -1, 0.1, 10);
            camera.position.z = 1;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Create individual wave visualizations
            waves.forEach(wave => {
                createWave(wave);
            });

            // Create superposition wave
            createSuperpositionWave();

            window.addEventListener('resize', onWindowResize);
        }

        function createWave(wave) {
            const segments = 300;
            const width = 2.4;

            const geometry = new THREE.PlaneGeometry(width, 0.1, segments, 1);

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    frequency: { value: wave.frequency },
                    amplitude: { value: amplitude },
                    color: { value: wave.color },
                    yOffset: { value: wave.y }
                },
                vertexShader: `
                    uniform float time;
                    uniform float frequency;
                    uniform float amplitude;
                    uniform float yOffset;

                    varying float vDisplacement;

                    void main() {
                        float x = (uv.x - 0.5) * 2.0;
                        float displacement = sin((x * 10.0 - time * frequency) * 6.28318) * amplitude;

                        vDisplacement = displacement;

                        vec3 newPosition = position;
                        newPosition.y = yOffset + displacement;

                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;

                    void main() {
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });

            const waveMesh = new THREE.Mesh(geometry, material);
            waveMesh.userData.wave = wave;
            scene.add(waveMesh);

            // Add equilibrium line
            const lineGeometry = new THREE.BufferGeometry();
            const linePoints = [
                new THREE.Vector3(-width/2, wave.y, 0.001),
                new THREE.Vector3(width/2, wave.y, 0.001)
            ];
            lineGeometry.setFromPoints(linePoints);
            const lineMaterial = new THREE.LineDashedMaterial({
                color: 0xffffff,
                dashSize: 0.02,
                gapSize: 0.02,
                opacity: 0.2,
                transparent: true
            });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            line.computeLineDistances();
            scene.add(line);

            // Add label
            createTextLabel(wave.label, -width/2 - 0.25, wave.y, wave.color);
        }

        function createSuperpositionWave() {
            const segments = 300;
            const width = 2.4;
            const yOffset = -0.5;

            const geometry = new THREE.PlaneGeometry(width, 0.8, segments, 1);

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    freq1: { value: freq1 },
                    freq2: { value: freq2 },
                    beatFreq: { value: beatFreq },
                    amplitude: { value: amplitude },
                    yOffset: { value: yOffset }
                },
                vertexShader: `
                    uniform float time;
                    uniform float freq1;
                    uniform float freq2;
                    uniform float amplitude;
                    uniform float yOffset;

                    varying float vDisplacement;
                    varying vec2 vUv;

                    void main() {
                        vUv = uv;

                        float x = (uv.x - 0.5) * 2.0;

                        // Superposition of two waves
                        float wave1 = sin((x * 10.0 - time * freq1) * 6.28318);
                        float wave2 = sin((x * 10.0 - time * freq2) * 6.28318);
                        float displacement = (wave1 + wave2) * amplitude;

                        vDisplacement = displacement;

                        vec3 newPosition = position;
                        newPosition.y = yOffset + displacement;

                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float beatFreq;

                    varying float vDisplacement;
                    varying vec2 vUv;

                    void main() {
                        // Beat pattern color intensity
                        float x = (vUv.x - 0.5) * 2.0;
                        float envelope = abs(cos((x * 10.0 * beatFreq - time * beatFreq) * 3.14159));

                        // Gradient color based on displacement
                        vec3 color = vec3(1.0, 0.843, 0.0); // Gold color
                        float intensity = abs(vDisplacement) / 0.4;
                        color *= (0.6 + intensity * 0.4);

                        // Add envelope highlight
                        color += vec3(envelope * 0.2);

                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                side: THREE.DoubleSide,
                transparent: true
            });

            const waveMesh = new THREE.Mesh(geometry, material);
            waveMesh.userData.isSuperposition = true;
            scene.add(waveMesh);

            // Add envelope lines (beat pattern visualization)
            createEnvelopeLines(width, yOffset);

            // Add equilibrium line
            const lineGeometry = new THREE.BufferGeometry();
            const linePoints = [
                new THREE.Vector3(-width/2, yOffset, 0.001),
                new THREE.Vector3(width/2, yOffset, 0.001)
            ];
            lineGeometry.setFromPoints(linePoints);
            const lineMaterial = new THREE.LineDashedMaterial({
                color: 0xffffff,
                dashSize: 0.02,
                gapSize: 0.02,
                opacity: 0.2,
                transparent: true
            });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            line.computeLineDistances();
            scene.add(line);

            // Add label
            createTextLabel('Superposition (Beats)', -width/2 - 0.25, yOffset, new THREE.Color(0xFFD700));
        }

        function createEnvelopeLines(width, yOffset) {
            const segments = 150;
            const points = [];

            for (let i = 0; i <= segments; i++) {
                const x = -width/2 + (i / segments) * width;
                points.push(new THREE.Vector3(x, 0, 0.002));
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    beatFreq: { value: beatFreq },
                    amplitude: { value: amplitude },
                    yOffset: { value: yOffset },
                    width: { value: width },
                    sign: { value: 1 }
                },
                vertexShader: `
                    uniform float time;
                    uniform float beatFreq;
                    uniform float amplitude;
                    uniform float yOffset;
                    uniform float width;
                    uniform float sign;

                    void main() {
                        float x = (position.x / (width / 2.0));
                        float envelope = abs(cos((x * 10.0 * beatFreq - time * beatFreq) * 3.14159)) * amplitude * 2.0;

                        vec3 newPosition = position;
                        newPosition.y = yOffset + sign * envelope;

                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                    }
                `,
                fragmentShader: `
                    void main() {
                        gl_FragColor = vec4(1.0, 1.0, 1.0, 0.4);
                    }
                `,
                transparent: true
            });

            const envelopeLine = new THREE.Line(geometry, material);
            envelopeLine.userData.isEnvelope = true;
            envelopeLine.userData.sign = 1;
            scene.add(envelopeLine);

            // Negative envelope
            const material2 = material.clone();
            material2.uniforms.sign.value = -1;
            const envelopeLine2 = new THREE.Line(geometry.clone(), material2);
            envelopeLine2.userData.isEnvelope = true;
            envelopeLine2.userData.sign = -1;
            scene.add(envelopeLine2);
        }

        function createTextLabel(text, x, y, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;

            context.fillStyle = `rgb(${color.r * 255}, ${color.g * 255}, ${color.b * 255})`;
            context.font = 'bold 24px Arial';
            context.textAlign = 'right';
            context.textBaseline = 'middle';
            context.fillText(text, 240, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.position.set(x, y, 0.03);
            sprite.scale.set(0.4, 0.1, 1);
            scene.add(sprite);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;

            // Update all materials
            scene.children.forEach(child => {
                if (child.material && child.material.uniforms && child.material.uniforms.time) {
                    child.material.uniforms.time.value = time;
                }
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
