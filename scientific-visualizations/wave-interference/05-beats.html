<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beat Frequency - GPU Accelerated</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff88;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
        }
        .badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 100, 255, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="info">
        <h2>Beat Frequency (GPU Accelerated)</h2>
        <p>Interference of two close frequencies</p>
        <p>f<sub>beat</sub> = |f₁ - f₂|</p>
        <p>Creates amplitude modulation</p>
        <p><strong>GPU-rendered wave superposition</strong></p>
    </div>
    <div class="badge">GPU-Accelerated • Three.js TSL • Physics Simulation</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/nodes": "https://unpkg.com/three@0.160.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { uv, uniform, vec3, float, sin, cos, abs, add, Fn, MeshBasicNodeMaterial, positionLocal } from 'three/nodes';

        let camera, scene, renderer;

        const freq1 = 0.15;
        const freq2 = 0.12;
        const beatFreq = Math.abs(freq1 - freq2);
        const amplitude = 0.2;

        const waves = [
            { y: 0.5, frequency: freq1, color: new THREE.Color(0xFF6B6B), label: `f₁ = ${freq1.toFixed(2)} Hz` },
            { y: 0.0, frequency: freq2, color: new THREE.Color(0x4ECDC4), label: `f₂ = ${freq2.toFixed(2)} Hz` },
        ];

        init();
        animate();

        function init() {
            // Scene setup
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.OrthographicCamera(-1.5, 1.5, 1, -1, 0.1, 10);
            camera.position.z = 1;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Create individual wave visualizations
            waves.forEach(wave => {
                createWave(wave);
            });

            // Create superposition wave
            createSuperpositionWave();

            window.addEventListener('resize', onWindowResize);
        }

        function createWave(wave) {
            const segments = 300;
            const width = 2.4;

            const geometry = new THREE.PlaneGeometry(width, 0.1, segments, 1);

            // TSL uniforms
            const uTime = uniform(0);
            const uFrequency = uniform(wave.frequency);
            const uAmplitude = uniform(amplitude);
            const uColor = uniform(vec3(wave.color.r, wave.color.g, wave.color.b));
            const uYOffset = uniform(wave.y);

            // TSL position displacement
            const positionShader = Fn(() => {
                const uvCoord = uv();
                const x = uvCoord.x.sub(0.5).mul(2.0);
                const displacement = sin(x.mul(10.0).sub(uTime.mul(uFrequency)).mul(6.28318)).mul(uAmplitude);

                const newPosition = positionLocal.toVar();
                newPosition.y.assign(uYOffset.add(displacement));

                return newPosition;
            })();

            // TSL color shader
            const colorShader = Fn(() => {
                return uColor;
            })();

            const material = new MeshBasicNodeMaterial({ side: THREE.DoubleSide });
            material.positionNode = positionShader;
            material.colorNode = colorShader;

            // Store uniforms for updates
            material.userData.uniforms = {
                time: uTime,
                frequency: uFrequency,
                amplitude: uAmplitude,
                color: uColor,
                yOffset: uYOffset
            };

            const waveMesh = new THREE.Mesh(geometry, material);
            waveMesh.userData.wave = wave;
            scene.add(waveMesh);

            // Add equilibrium line
            const lineGeometry = new THREE.BufferGeometry();
            const linePoints = [
                new THREE.Vector3(-width/2, wave.y, 0.001),
                new THREE.Vector3(width/2, wave.y, 0.001)
            ];
            lineGeometry.setFromPoints(linePoints);
            const lineMaterial = new THREE.LineDashedMaterial({
                color: 0xffffff,
                dashSize: 0.02,
                gapSize: 0.02,
                opacity: 0.2,
                transparent: true
            });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            line.computeLineDistances();
            scene.add(line);

            // Add label
            createTextLabel(wave.label, -width/2 - 0.25, wave.y, wave.color);
        }

        function createSuperpositionWave() {
            const segments = 300;
            const width = 2.4;
            const yOffset = -0.5;

            const geometry = new THREE.PlaneGeometry(width, 0.8, segments, 1);

            // TSL uniforms
            const uTime = uniform(0);
            const uFreq1 = uniform(freq1);
            const uFreq2 = uniform(freq2);
            const uBeatFreq = uniform(beatFreq);
            const uAmplitude = uniform(amplitude);
            const uYOffset = uniform(yOffset);

            // TSL position displacement
            const positionShader = Fn(() => {
                const uvCoord = uv();
                const x = uvCoord.x.sub(0.5).mul(2.0);

                // Superposition of two waves
                const wave1 = sin(x.mul(10.0).sub(uTime.mul(uFreq1)).mul(6.28318));
                const wave2 = sin(x.mul(10.0).sub(uTime.mul(uFreq2)).mul(6.28318));
                const displacement = wave1.add(wave2).mul(uAmplitude);

                const newPosition = positionLocal.toVar();
                newPosition.y.assign(uYOffset.add(displacement));

                return newPosition;
            })();

            // TSL color shader
            const colorShader = Fn(() => {
                const uvCoord = uv();
                const x = uvCoord.x.sub(0.5).mul(2.0);

                // Calculate displacement for intensity
                const wave1 = sin(x.mul(10.0).sub(uTime.mul(uFreq1)).mul(6.28318));
                const wave2 = sin(x.mul(10.0).sub(uTime.mul(uFreq2)).mul(6.28318));
                const displacement = wave1.add(wave2).mul(uAmplitude);

                // Beat pattern color intensity
                const envelope = abs(cos(x.mul(10.0).mul(uBeatFreq).sub(uTime.mul(uBeatFreq)).mul(3.14159)));

                // Gradient color based on displacement
                const baseColor = vec3(1.0, 0.843, 0.0); // Gold color
                const intensity = abs(displacement).div(0.4);
                const intensityColor = baseColor.mul(float(0.6).add(intensity.mul(0.4)));

                // Add envelope highlight
                const finalColor = intensityColor.add(vec3(envelope.mul(0.2)));

                return finalColor;
            })();

            const material = new MeshBasicNodeMaterial({ side: THREE.DoubleSide, transparent: true });
            material.positionNode = positionShader;
            material.colorNode = colorShader;

            // Store uniforms for updates
            material.userData.uniforms = {
                time: uTime,
                freq1: uFreq1,
                freq2: uFreq2,
                beatFreq: uBeatFreq,
                amplitude: uAmplitude,
                yOffset: uYOffset
            };

            const waveMesh = new THREE.Mesh(geometry, material);
            waveMesh.userData.isSuperposition = true;
            scene.add(waveMesh);

            // Add envelope lines (beat pattern visualization)
            createEnvelopeLines(width, yOffset);

            // Add equilibrium line
            const lineGeometry = new THREE.BufferGeometry();
            const linePoints = [
                new THREE.Vector3(-width/2, yOffset, 0.001),
                new THREE.Vector3(width/2, yOffset, 0.001)
            ];
            lineGeometry.setFromPoints(linePoints);
            const lineMaterial = new THREE.LineDashedMaterial({
                color: 0xffffff,
                dashSize: 0.02,
                gapSize: 0.02,
                opacity: 0.2,
                transparent: true
            });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            line.computeLineDistances();
            scene.add(line);

            // Add label
            createTextLabel('Superposition (Beats)', -width/2 - 0.25, yOffset, new THREE.Color(0xFFD700));
        }

        function createEnvelopeLines(width, yOffset) {
            const segments = 150;
            const points = [];

            for (let i = 0; i <= segments; i++) {
                const x = -width/2 + (i / segments) * width;
                points.push(new THREE.Vector3(x, 0, 0.002));
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);

            // Create positive envelope
            createEnvelopeLine(geometry, width, yOffset, 1);

            // Create negative envelope
            createEnvelopeLine(geometry.clone(), width, yOffset, -1);
        }

        function createEnvelopeLine(geometry, width, yOffset, sign) {
            // TSL uniforms
            const uTime = uniform(0);
            const uBeatFreq = uniform(beatFreq);
            const uAmplitude = uniform(amplitude);
            const uYOffset = uniform(yOffset);
            const uWidth = uniform(width);
            const uSign = uniform(sign);

            // TSL position displacement
            const positionShader = Fn(() => {
                const pos = positionLocal;
                const x = pos.x.div(uWidth.div(2.0));
                const envelope = abs(cos(x.mul(10.0).mul(uBeatFreq).sub(uTime.mul(uBeatFreq)).mul(3.14159))).mul(uAmplitude).mul(2.0);

                const newPosition = pos.toVar();
                newPosition.y.assign(uYOffset.add(uSign.mul(envelope)));

                return newPosition;
            })();

            // TSL color shader
            const colorShader = Fn(() => {
                return vec3(1.0, 1.0, 1.0);
            })();

            const material = new MeshBasicNodeMaterial({ transparent: true });
            material.positionNode = positionShader;
            material.colorNode = colorShader;
            material.opacity = 0.4;

            // Store uniforms for updates
            material.userData.uniforms = {
                time: uTime,
                beatFreq: uBeatFreq,
                amplitude: uAmplitude,
                yOffset: uYOffset,
                width: uWidth,
                sign: uSign
            };

            const envelopeLine = new THREE.Line(geometry, material);
            envelopeLine.userData.isEnvelope = true;
            envelopeLine.userData.sign = sign;
            scene.add(envelopeLine);
        }

        function createTextLabel(text, x, y, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;

            context.fillStyle = `rgb(${color.r * 255}, ${color.g * 255}, ${color.b * 255})`;
            context.font = 'bold 24px Arial';
            context.textAlign = 'right';
            context.textBaseline = 'middle';
            context.fillText(text, 240, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.position.set(x, y, 0.03);
            sprite.scale.set(0.4, 0.1, 1);
            scene.add(sprite);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;

            // Update all materials
            scene.children.forEach(child => {
                if (child.material && child.material.userData && child.material.userData.uniforms && child.material.userData.uniforms.time) {
                    child.material.userData.uniforms.time.value = time;
                }
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
