<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ripple Tank - GPU Accelerated</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #001122;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ddff;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
        }
        .badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 100, 255, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="info">
        <h2>Ripple Tank (GPU Accelerated)</h2>
        <p>Multiple point sources creating waves</p>
        <p>Click to add/remove wave sources (max 8)</p>
        <p><strong>Real-time wave equation on GPU</strong></p>
    </div>
    <div class="badge">GPU-Accelerated • Three.js TSL • Physics Simulation</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let camera, scene, renderer, plane, material;
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();

        const MAX_SOURCES = 8;
        const sources = [
            new THREE.Vector3(-0.3, 0.1, 0),
            new THREE.Vector3(0.3, 0.1, 0),
            new THREE.Vector3(0, -0.2, 0)
        ];

        init();
        animate();

        function init() {
            // Scene setup
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
            camera.position.z = 1;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Custom shader material for wave simulation
            material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    numSources: { value: sources.length },
                    sources: { value: sources },
                    wavelength: { value: 0.15 },
                    frequency: { value: 2.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec2 resolution;
                    uniform int numSources;
                    uniform vec3 sources[${MAX_SOURCES}];
                    uniform float wavelength;
                    uniform float frequency;

                    varying vec2 vUv;

                    void main() {
                        // Map UV to centered coordinates
                        vec2 pos = (vUv - 0.5) * 2.0;
                        float aspect = resolution.x / resolution.y;
                        pos.x *= aspect;

                        float totalAmplitude = 0.0;

                        // Calculate wave interference from all sources
                        for(int i = 0; i < ${MAX_SOURCES}; i++) {
                            if(i >= numSources) break;

                            vec2 sourcePos = sources[i].xy;
                            sourcePos.x *= aspect;

                            float dist = length(pos - sourcePos);

                            // Wave equation with damping
                            float damping = exp(-dist * 1.5);
                            float phase = (dist / wavelength) - time * frequency;
                            float amplitude = sin(phase * 6.28318) * damping;

                            totalAmplitude += amplitude;
                        }

                        // Normalize amplitude
                        totalAmplitude /= sqrt(float(numSources));

                        // Color mapping
                        float intensity = (totalAmplitude + 1.0) / 2.0;

                        // Create color gradient based on wave amplitude
                        vec3 color1 = vec3(0.0, 0.1, 0.3); // Dark blue
                        vec3 color2 = vec3(0.0, 0.6, 0.8); // Cyan
                        vec3 color3 = vec3(0.8, 1.0, 1.0); // Light cyan

                        vec3 color;
                        if(intensity < 0.5) {
                            color = mix(color1, color2, intensity * 2.0);
                        } else {
                            color = mix(color2, color3, (intensity - 0.5) * 2.0);
                        }

                        // Add wave crests highlight
                        float crestHighlight = smoothstep(0.8, 0.95, intensity);
                        color += vec3(crestHighlight * 0.3);

                        gl_FragColor = vec4(color, 1.0);
                    }
                `
            });

            // Create plane for wave visualization
            const geometry = new THREE.PlaneGeometry(2, 2, 1, 1);
            plane = new THREE.Mesh(geometry, material);
            scene.add(plane);

            // Add source markers
            updateSourceMarkers();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('click', onMouseClick);
        }

        function updateSourceMarkers() {
            // Remove old markers
            scene.children = scene.children.filter(child => child !== plane);
            scene.add(plane);

            // Add new markers
            sources.forEach((source, index) => {
                // Outer glow
                const glowGeometry = new THREE.CircleGeometry(0.04, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(source);
                glow.position.z = 0.01;
                scene.add(glow);

                // Inner marker
                const markerGeometry = new THREE.CircleGeometry(0.02, 32);
                const markerMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.copy(source);
                marker.position.z = 0.02;
                scene.add(marker);

                // Pulsing ring (animated in shader)
                const ringGeometry = new THREE.RingGeometry(0.025, 0.03, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(source);
                ring.position.z = 0.02;
                ring.userData.sourceIndex = index;
                scene.add(ring);
            });
        }

        function onMouseClick(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Convert to world coordinates
            const distance = -camera.position.z / 1;
            const worldPos = new THREE.Vector3();
            raycaster.ray.at(distance, worldPos);

            // Check if clicking near existing source
            let removed = false;
            for (let i = sources.length - 1; i >= 0; i--) {
                const dist = worldPos.distanceTo(sources[i]);
                if (dist < 0.08) {
                    sources.splice(i, 1);
                    removed = true;
                    break;
                }
            }

            // Add new source if not removing and under limit
            if (!removed && sources.length < MAX_SOURCES) {
                sources.push(worldPos.clone());
            }

            // Update uniforms and markers
            material.uniforms.numSources.value = sources.length;
            material.uniforms.sources.value = sources;
            updateSourceMarkers();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Update time uniform
            material.uniforms.time.value += 0.016;

            // Animate source ring pulses
            scene.children.forEach(child => {
                if (child.geometry && child.geometry.type === 'RingGeometry') {
                    const index = child.userData.sourceIndex;
                    if (index !== undefined) {
                        const scale = 1 + Math.sin(material.uniforms.time.value * 3 + index) * 0.3;
                        child.scale.set(scale, scale, 1);
                        child.material.opacity = 0.6 - Math.sin(material.uniforms.time.value * 3 + index) * 0.3;
                    }
                }
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
