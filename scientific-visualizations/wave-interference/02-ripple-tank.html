<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ripple Tank - GPU Accelerated</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #001122;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ddff;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
        }
        .badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 100, 255, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="info">
        <h2>Ripple Tank (GPU Accelerated)</h2>
        <p>Multiple point sources creating waves</p>
        <p>Click to add/remove wave sources (max 8)</p>
        <p><strong>Real-time wave equation on GPU</strong></p>
    </div>
    <div class="badge">GPU-Accelerated • Three.js TSL • Physics Simulation</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/nodes": "https://unpkg.com/three@0.160.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { uv, uniform, vec2, vec3, float, sin, cos, exp, sqrt, length, mix, smoothstep, Fn, MeshBasicNodeMaterial } from 'three/nodes';

        let camera, scene, renderer, plane, material;
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();

        const MAX_SOURCES = 8;
        const sources = [
            new THREE.Vector3(-0.3, 0.1, 0),
            new THREE.Vector3(0.3, 0.1, 0),
            new THREE.Vector3(0, -0.2, 0)
        ];

        init();
        animate();

        function init() {
            // Scene setup
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
            camera.position.z = 1;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // TSL uniforms
            const uTime = uniform(0);
            const uResolution = uniform(vec2(window.innerWidth, window.innerHeight));
            const uNumSources = uniform(sources.length);
            const uWavelength = uniform(0.15);
            const uFrequency = uniform(2.0);

            // Create uniform array for sources
            const uSources = [];
            for (let i = 0; i < MAX_SOURCES; i++) {
                if (i < sources.length) {
                    uSources.push(uniform(vec3(sources[i].x, sources[i].y, sources[i].z)));
                } else {
                    uSources.push(uniform(vec3(0, 0, 0)));
                }
            }

            // TSL wave interference shader
            const waveShader = Fn(() => {
                // Map UV to centered coordinates
                const uvCoord = uv();
                const pos = uvCoord.sub(0.5).mul(2.0);
                const aspect = uResolution.x.div(uResolution.y);
                const posX = pos.x.mul(aspect);
                const posY = pos.y;

                // Calculate wave interference from all sources
                let totalAmplitude = float(0.0).toVar();

                // Unroll loop for all sources
                for (let i = 0; i < MAX_SOURCES; i++) {
                    const sourcePos = uSources[i];
                    const sourcePosX = sourcePos.x.mul(aspect);
                    const sourcePosY = sourcePos.y;

                    const dx = posX.sub(sourcePosX);
                    const dy = posY.sub(sourcePosY);
                    const dist = sqrt(dx.mul(dx).add(dy.mul(dy)));

                    // Wave equation with damping
                    const damping = exp(dist.mul(-1.5));
                    const phase = dist.div(uWavelength).sub(uTime.mul(uFrequency));
                    const amplitude = sin(phase.mul(6.28318)).mul(damping);

                    // Only add if within numSources
                    const isActive = float(i).lessThan(uNumSources);
                    totalAmplitude.addAssign(isActive.select(amplitude, 0.0));
                }

                // Normalize amplitude
                totalAmplitude.assign(totalAmplitude.div(sqrt(uNumSources)));

                // Color mapping
                const intensity = totalAmplitude.add(1.0).div(2.0);

                // Create color gradient based on wave amplitude
                const color1 = vec3(0.0, 0.1, 0.3); // Dark blue
                const color2 = vec3(0.0, 0.6, 0.8); // Cyan
                const color3 = vec3(0.8, 1.0, 1.0); // Light cyan

                const lowerColor = mix(color1, color2, intensity.mul(2.0));
                const upperColor = mix(color2, color3, intensity.sub(0.5).mul(2.0));
                const baseColor = intensity.lessThan(0.5).select(lowerColor, upperColor);

                // Add wave crests highlight
                const crestHighlight = smoothstep(0.8, 0.95, intensity);
                const finalColor = baseColor.add(vec3(crestHighlight.mul(0.3)));

                return vec3(finalColor);
            })();

            // Custom TSL material for wave simulation
            material = new MeshBasicNodeMaterial();
            material.colorNode = waveShader;

            // Store uniforms for updates
            material.userData.uniforms = {
                time: uTime,
                resolution: uResolution,
                numSources: uNumSources,
                sources: uSources,
                wavelength: uWavelength,
                frequency: uFrequency
            };

            // Create plane for wave visualization
            const geometry = new THREE.PlaneGeometry(2, 2, 1, 1);
            plane = new THREE.Mesh(geometry, material);
            scene.add(plane);

            // Add source markers
            updateSourceMarkers();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('click', onMouseClick);
        }

        function updateSourceMarkers() {
            // Remove old markers
            scene.children = scene.children.filter(child => child !== plane);
            scene.add(plane);

            // Add new markers
            sources.forEach((source, index) => {
                // Outer glow
                const glowGeometry = new THREE.CircleGeometry(0.04, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(source);
                glow.position.z = 0.01;
                scene.add(glow);

                // Inner marker
                const markerGeometry = new THREE.CircleGeometry(0.02, 32);
                const markerMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.copy(source);
                marker.position.z = 0.02;
                scene.add(marker);

                // Pulsing ring (animated in shader)
                const ringGeometry = new THREE.RingGeometry(0.025, 0.03, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(source);
                ring.position.z = 0.02;
                ring.userData.sourceIndex = index;
                scene.add(ring);
            });
        }

        function onMouseClick(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Convert to world coordinates
            const distance = -camera.position.z / 1;
            const worldPos = new THREE.Vector3();
            raycaster.ray.at(distance, worldPos);

            // Check if clicking near existing source
            let removed = false;
            for (let i = sources.length - 1; i >= 0; i--) {
                const dist = worldPos.distanceTo(sources[i]);
                if (dist < 0.08) {
                    sources.splice(i, 1);
                    removed = true;
                    break;
                }
            }

            // Add new source if not removing and under limit
            if (!removed && sources.length < MAX_SOURCES) {
                sources.push(worldPos.clone());
            }

            // Update uniforms and markers
            material.userData.uniforms.numSources.value = sources.length;
            for (let i = 0; i < MAX_SOURCES; i++) {
                if (i < sources.length) {
                    material.userData.uniforms.sources[i].value.set(sources[i].x, sources[i].y, sources[i].z);
                } else {
                    material.userData.uniforms.sources[i].value.set(0, 0, 0);
                }
            }
            updateSourceMarkers();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.userData.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Update time uniform
            material.userData.uniforms.time.value += 0.016;

            // Animate source ring pulses
            scene.children.forEach(child => {
                if (child.geometry && child.geometry.type === 'RingGeometry') {
                    const index = child.userData.sourceIndex;
                    if (index !== undefined) {
                        const scale = 1 + Math.sin(material.userData.uniforms.time.value * 3 + index) * 0.3;
                        child.scale.set(scale, scale, 1);
                        child.material.opacity = 0.6 - Math.sin(material.userData.uniforms.time.value * 3 + index) * 0.3;
                    }
                }
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
