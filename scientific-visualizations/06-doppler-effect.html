<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doppler Effect</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ff66ff;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="info">
        <h2>Doppler Effect</h2>
        <p>Frequency shift due to relative motion</p>
        <p>Moving toward observer: higher frequency (blue shift)</p>
        <p>Moving away: lower frequency (red shift)</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let time = 0;

        class MovingSource {
            constructor() {
                this.x = 100;
                this.y = canvas.height / 2;
                this.vx = 2;
                this.emissionInterval = 20;
                this.lastEmission = 0;
                this.wavefronts = [];
                this.waveSpeed = 3;
            }

            update() {
                this.x += this.vx;

                // Bounce off edges
                if (this.x > canvas.width - 100 || this.x < 100) {
                    this.vx *= -1;
                }

                // Emit wavefront
                this.lastEmission++;
                if (this.lastEmission >= this.emissionInterval) {
                    this.wavefronts.push({
                        x: this.x,
                        y: this.y,
                        radius: 0,
                        emissionTime: time
                    });
                    this.lastEmission = 0;
                }

                // Update wavefronts
                this.wavefronts.forEach(wf => {
                    wf.radius += this.waveSpeed;
                });

                // Remove old wavefronts
                this.wavefronts = this.wavefronts.filter(wf => wf.radius < 600);
            }

            draw() {
                // Draw wavefronts
                this.wavefronts.forEach((wf, index) => {
                    const age = this.wavefronts.length - index;
                    const alpha = Math.max(0, 1 - wf.radius / 400);

                    ctx.beginPath();
                    ctx.arc(wf.x, wf.y, wf.radius, 0, Math.PI * 2);

                    // Color shift based on position relative to source
                    const wavelength = wf.radius / (time - wf.emissionTime + 1);

                    ctx.strokeStyle = `rgba(255, 100, 255, ${alpha})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });

                // Draw source
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 20);
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(0.5, '#ff66ff');
                gradient.addColorStop(1, '#aa00aa');

                ctx.beginPath();
                ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Velocity arrow
                const arrowLength = Math.abs(this.vx) * 20;
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + Math.sign(this.vx) * arrowLength, this.y);
                ctx.stroke();

                // Arrowhead
                ctx.beginPath();
                ctx.moveTo(this.x + Math.sign(this.vx) * arrowLength, this.y);
                ctx.lineTo(this.x + Math.sign(this.vx) * (arrowLength - 10), this.y - 5);
                ctx.lineTo(this.x + Math.sign(this.vx) * (arrowLength - 10), this.y + 5);
                ctx.closePath();
                ctx.fillStyle = '#00ff00';
                ctx.fill();

                // Label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Source', this.x, this.y - 30);
            }

            drawObservers() {
                // Observer on the right (approaching)
                const rightObserverX = canvas.width - 100;
                const rightObserverY = canvas.height / 2;

                // Count wavefronts near observer
                let rightCount = 0;
                this.wavefronts.forEach(wf => {
                    const dist = Math.sqrt((wf.x - rightObserverX) ** 2 + (wf.y - rightObserverY) ** 2);
                    if (Math.abs(dist - wf.radius) < 20) {
                        rightCount++;
                    }
                });

                this.drawObserver(rightObserverX, rightObserverY, '#00ffff', 'Observer (Right)', rightCount > 0);

                // Observer on the left (receding)
                const leftObserverX = 100;
                const leftObserverY = canvas.height / 2;

                let leftCount = 0;
                this.wavefronts.forEach(wf => {
                    const dist = Math.sqrt((wf.x - leftObserverX) ** 2 + (wf.y - leftObserverY) ** 2);
                    if (Math.abs(dist - wf.radius) < 20) {
                        leftCount++;
                    }
                });

                this.drawObserver(leftObserverX, leftObserverY, '#ffaa00', 'Observer (Left)', leftCount > 0);
            }

            drawObserver(x, y, color, label, receiving) {
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI * 2);
                ctx.fillStyle = receiving ? color : '#666';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Ear
                ctx.beginPath();
                ctx.arc(x + 15, y, 8, Math.PI * 0.7, Math.PI * 1.3);
                ctx.stroke();

                // Label
                ctx.fillStyle = color;
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(label, x, y + 30);

                // Indication light when receiving
                if (receiving) {
                    ctx.beginPath();
                    ctx.arc(x, y - 20, 5, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                }
            }
        }

        const source = new MovingSource();

        function drawWavelengthIndicators() {
            // Show compressed wavelengths on leading edge
            const rightX = canvas.width - 100;
            const rightY = canvas.height / 2 + 80;

            ctx.fillStyle = '#00ffff';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Shorter wavelength', rightX, rightY);
            ctx.fillText('(Higher frequency)', rightX, rightY + 20);

            // Show expanded wavelengths on trailing edge
            const leftX = 100;
            const leftY = canvas.height / 2 + 80;

            ctx.fillStyle = '#ffaa00';
            ctx.fillText('Longer wavelength', leftX, leftY);
            ctx.fillText('(Lower frequency)', leftX, leftY + 20);
        }

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            source.update();
            source.draw();
            source.drawObservers();
            drawWavelengthIndicators();

            time++;
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        animate();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>