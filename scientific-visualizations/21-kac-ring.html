<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kac Ring Irreversibility Demo - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0;
        }

        h1 {
            font-size: 2.2rem;
            background: linear-gradient(135deg, #a855f7, #ec4899);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #888;
            font-size: 1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
            margin-top: 20px;
        }

        .canvas-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(168, 85, 247, 0.3);
        }

        .canvas-container h3 {
            color: #a855f7;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        canvas {
            display: block;
            background: #0a0a1a;
            border-radius: 10px;
        }

        #ringCanvas {
            width: 100%;
            height: 350px;
        }

        #historyCanvas {
            width: 100%;
            height: 200px;
        }

        .controls {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(168, 85, 247, 0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group h3 {
            color: #a855f7;
            font-size: 0.85rem;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        label {
            display: block;
            margin: 10px 0 5px;
            color: #aaa;
            font-size: 0.8rem;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #a855f7;
            cursor: pointer;
        }

        button {
            width: 100%;
            padding: 10px 15px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #a855f7, #9333ea);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(168, 85, 247, 0.4);
        }

        .btn-secondary {
            background: rgba(168, 85, 247, 0.2);
            color: #a855f7;
            border: 1px solid rgba(168, 85, 247, 0.5);
        }

        .btn-secondary:hover {
            background: rgba(168, 85, 247, 0.3);
        }

        select {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(168, 85, 247, 0.5);
            color: #e0e0e0;
            font-size: 0.85rem;
        }

        .stats {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            font-size: 0.8rem;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            font-family: monospace;
            color: #ec4899;
        }

        .info-box {
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            font-size: 0.8rem;
            line-height: 1.5;
            color: #ccc;
        }

        .info-box strong {
            color: #a855f7;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
            font-size: 0.8rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
        }

        .legend-marker {
            width: 14px;
            height: 14px;
            background: #facc15;
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #a855f7;
            text-decoration: none;
            font-weight: 600;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            border: 1px solid rgba(168, 85, 247, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .back-link:hover {
            background: rgba(168, 85, 247, 0.2);
            transform: translateX(-5px);
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <div class="container">
        <header>
            <h1>Kac Ring Model</h1>
            <p class="subtitle">Irreversibility from Reversible Dynamics</p>
        </header>

        <div class="main-content">
            <div class="canvas-section">
                <div class="canvas-container">
                    <h3>The Ring</h3>
                    <canvas id="ringCanvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-dot" style="background: #22c55e;"></div>
                            <span>White Ball</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: #ef4444;"></div>
                            <span>Black Ball</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-marker"></div>
                            <span>Marker (flips ball)</span>
                        </div>
                    </div>
                </div>

                <div class="canvas-container">
                    <h3>Fraction of White Balls Over Time</h3>
                    <canvas id="historyCanvas"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="info-box">
                    <strong>The Paradox:</strong> Each ball moves clockwise and flips color when passing a marker.
                    The dynamics are <em>deterministic</em> and <em>reversible</em> (system returns to initial state after N steps).
                    Yet we observe <em>macroscopic relaxation</em> to equilibrium!
                </div>

                <div class="control-group">
                    <h3>Simulation</h3>
                    <button class="btn-primary" onclick="toggleSimulation()">
                        <span id="playBtn">▶ Start</span>
                    </button>
                    <button class="btn-secondary" onclick="stepOnce()">Single Step</button>
                    <button class="btn-secondary" onclick="resetSimulation()">Reset</button>
                </div>

                <div class="control-group">
                    <h3>Initial State</h3>
                    <select id="initialSelect" onchange="resetSimulation()">
                        <option value="all_white">All White</option>
                        <option value="all_black">All Black</option>
                        <option value="half">Half White, Half Black</option>
                        <option value="random">Random</option>
                    </select>
                </div>

                <div class="control-group">
                    <h3>Parameters</h3>

                    <label>Number of Balls (N): <span id="nValue">32</span></label>
                    <input type="range" id="nSlider" min="16" max="64" value="32" step="4" oninput="updateN()">

                    <label>Number of Markers (n): <span id="mValue">12</span></label>
                    <input type="range" id="mSlider" min="1" max="30" value="12" step="1" oninput="updateM()">

                    <label>Animation Speed: <span id="speedValue">5</span></label>
                    <input type="range" id="speedSlider" min="1" max="20" value="5" step="1" oninput="updateSpeed()">
                </div>

                <div class="control-group">
                    <h3>Marker Placement</h3>
                    <select id="markerSelect" onchange="resetSimulation()">
                        <option value="random">Random</option>
                        <option value="regular">Regular Spacing</option>
                        <option value="clustered">Clustered</option>
                    </select>
                </div>

                <div class="stats">
                    <div class="stat-row">
                        <span class="stat-label">Time Step:</span>
                        <span class="stat-value" id="timeStat">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">White Balls:</span>
                        <span class="stat-value" id="whiteStat">32</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Fraction White:</span>
                        <span class="stat-value" id="fractionStat">100%</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Poincaré Period:</span>
                        <span class="stat-value" id="periodStat">—</span>
                    </div>
                </div>

                <div class="info-box" style="margin-top: 15px;">
                    <strong>Boltzmann's H-theorem:</strong> In the large N limit, the fraction of white balls
                    approaches f(t) = ½ + ½(1 - 2n/N)^t·(f₀ - ½) — exponential relaxation despite reversibility!
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const ringCanvas = document.getElementById('ringCanvas');
        const ringCtx = ringCanvas.getContext('2d');
        const historyCanvas = document.getElementById('historyCanvas');
        const historyCtx = historyCanvas.getContext('2d');

        function resizeCanvases() {
            [ringCanvas, historyCanvas].forEach(canvas => {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                canvas.getContext('2d').scale(window.devicePixelRatio, window.devicePixelRatio);
            });
        }

        resizeCanvases();

        // State
        let N = 32;  // Number of balls
        let nMarkers = 12;  // Number of markers
        let balls = [];  // true = white, false = black
        let markers = [];  // indices with markers
        let timeStep = 0;
        let history = [];
        let running = false;
        let animationId = null;
        let speed = 5;
        let frameCount = 0;

        // Initialize balls
        function initializeBalls() {
            const initial = document.getElementById('initialSelect').value;
            balls = new Array(N);

            if (initial === 'all_white') {
                balls.fill(true);
            } else if (initial === 'all_black') {
                balls.fill(false);
            } else if (initial === 'half') {
                for (let i = 0; i < N; i++) {
                    balls[i] = i < N / 2;
                }
            } else if (initial === 'random') {
                for (let i = 0; i < N; i++) {
                    balls[i] = Math.random() < 0.5;
                }
            }
        }

        // Initialize markers
        function initializeMarkers() {
            const placement = document.getElementById('markerSelect').value;
            markers = [];

            if (placement === 'random') {
                // Random positions
                const indices = Array.from({length: N}, (_, i) => i);
                for (let i = indices.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [indices[i], indices[j]] = [indices[j], indices[i]];
                }
                markers = indices.slice(0, nMarkers);
            } else if (placement === 'regular') {
                // Regular spacing
                const spacing = N / nMarkers;
                for (let i = 0; i < nMarkers; i++) {
                    markers.push(Math.floor(i * spacing) % N);
                }
            } else if (placement === 'clustered') {
                // Clustered on one side
                for (let i = 0; i < nMarkers; i++) {
                    markers.push(i % N);
                }
            }
        }

        // Step the simulation
        function step() {
            // Each ball moves one position clockwise
            // When passing a marker (on the edge after the ball's current position),
            // the ball flips color

            const newBalls = new Array(N);

            for (let i = 0; i < N; i++) {
                const newPos = (i + 1) % N;

                // Check if there's a marker on the edge from i to newPos
                // We'll say marker at position i means the edge from i to (i+1)%N
                const hasMarker = markers.includes(i);

                if (hasMarker) {
                    newBalls[newPos] = !balls[i];  // Flip
                } else {
                    newBalls[newPos] = balls[i];  // No flip
                }
            }

            balls = newBalls;
            timeStep++;

            // Record history
            const fractionWhite = balls.filter(b => b).length / N;
            history.push(fractionWhite);

            // Limit history length
            if (history.length > 500) {
                history.shift();
            }
        }

        // Count white balls
        function countWhite() {
            return balls.filter(b => b).length;
        }

        // Compute Poincaré recurrence period
        function computePeriod() {
            // For Kac ring, the period is N (or 2N if odd number of markers on a ball's path)
            // In general, it's related to the structure, but N is a good approximation
            return N;
        }

        // Draw the ring
        function drawRing() {
            const rect = ringCanvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;

            ringCtx.fillStyle = '#0a0a1a';
            ringCtx.fillRect(0, 0, w, h);

            const centerX = w / 2;
            const centerY = h / 2;
            const radius = Math.min(w, h) * 0.38;
            const ballRadius = Math.max(8, radius / N * 2);

            // Draw ring circle
            ringCtx.strokeStyle = '#444';
            ringCtx.lineWidth = 2;
            ringCtx.beginPath();
            ringCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ringCtx.stroke();

            // Draw edges with markers highlighted
            for (let i = 0; i < N; i++) {
                const angle1 = (i / N) * Math.PI * 2 - Math.PI / 2;
                const angle2 = ((i + 1) / N) * Math.PI * 2 - Math.PI / 2;

                const x1 = centerX + Math.cos(angle1) * radius;
                const y1 = centerY + Math.sin(angle1) * radius;
                const x2 = centerX + Math.cos(angle2) * radius;
                const y2 = centerY + Math.sin(angle2) * radius;

                if (markers.includes(i)) {
                    // Draw marker (highlighted edge)
                    ringCtx.strokeStyle = '#facc15';
                    ringCtx.lineWidth = 4;
                    ringCtx.beginPath();
                    ringCtx.moveTo(x1, y1);
                    ringCtx.lineTo(x2, y2);
                    ringCtx.stroke();

                    // Draw marker triangle
                    const midAngle = (angle1 + angle2) / 2;
                    const markerX = centerX + Math.cos(midAngle) * (radius + 15);
                    const markerY = centerY + Math.sin(midAngle) * (radius + 15);

                    ringCtx.fillStyle = '#facc15';
                    ringCtx.beginPath();
                    ringCtx.save();
                    ringCtx.translate(markerX, markerY);
                    ringCtx.rotate(midAngle + Math.PI / 2);
                    ringCtx.moveTo(0, -6);
                    ringCtx.lineTo(-5, 4);
                    ringCtx.lineTo(5, 4);
                    ringCtx.closePath();
                    ringCtx.restore();
                    ringCtx.fill();
                }
            }

            // Draw balls
            for (let i = 0; i < N; i++) {
                const angle = (i / N) * Math.PI * 2 - Math.PI / 2;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;

                // Ball color
                const isWhite = balls[i];
                ringCtx.fillStyle = isWhite ? '#22c55e' : '#ef4444';

                ringCtx.beginPath();
                ringCtx.arc(x, y, ballRadius, 0, Math.PI * 2);
                ringCtx.fill();

                // Ball border
                ringCtx.strokeStyle = '#fff';
                ringCtx.lineWidth = 1;
                ringCtx.stroke();
            }

            // Draw center info
            const white = countWhite();
            const fraction = (white / N * 100).toFixed(1);

            ringCtx.fillStyle = '#a855f7';
            ringCtx.font = 'bold 24px sans-serif';
            ringCtx.textAlign = 'center';
            ringCtx.textBaseline = 'middle';
            ringCtx.fillText(`${fraction}%`, centerX, centerY - 10);

            ringCtx.fillStyle = '#888';
            ringCtx.font = '12px sans-serif';
            ringCtx.fillText('white', centerX, centerY + 15);

            // Draw time
            ringCtx.fillStyle = '#666';
            ringCtx.font = '11px sans-serif';
            ringCtx.textAlign = 'left';
            ringCtx.fillText(`t = ${timeStep}`, 10, 20);

            // Draw arrow showing direction
            ringCtx.fillStyle = '#666';
            ringCtx.font = '10px sans-serif';
            ringCtx.textAlign = 'center';
            ringCtx.fillText('↻ clockwise', centerX, h - 15);
        }

        // Draw history plot
        function drawHistory() {
            const rect = historyCanvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;
            const padding = { top: 20, bottom: 30, left: 50, right: 20 };

            historyCtx.fillStyle = '#0a0a1a';
            historyCtx.fillRect(0, 0, w, h);

            // Draw axes
            historyCtx.strokeStyle = '#444';
            historyCtx.lineWidth = 1;
            historyCtx.beginPath();
            historyCtx.moveTo(padding.left, padding.top);
            historyCtx.lineTo(padding.left, h - padding.bottom);
            historyCtx.lineTo(w - padding.right, h - padding.bottom);
            historyCtx.stroke();

            // Draw equilibrium line at 0.5
            historyCtx.strokeStyle = '#666';
            historyCtx.setLineDash([5, 5]);
            const y50 = padding.top + (1 - 0.5) * (h - padding.top - padding.bottom);
            historyCtx.beginPath();
            historyCtx.moveTo(padding.left, y50);
            historyCtx.lineTo(w - padding.right, y50);
            historyCtx.stroke();
            historyCtx.setLineDash([]);

            // Label
            historyCtx.fillStyle = '#666';
            historyCtx.font = '10px sans-serif';
            historyCtx.textAlign = 'right';
            historyCtx.fillText('50%', padding.left - 5, y50 + 4);

            // Y axis labels
            historyCtx.fillText('100%', padding.left - 5, padding.top + 4);
            historyCtx.fillText('0%', padding.left - 5, h - padding.bottom + 4);

            if (history.length < 2) {
                historyCtx.fillStyle = '#666';
                historyCtx.font = '12px sans-serif';
                historyCtx.textAlign = 'center';
                historyCtx.fillText('Run simulation to see time evolution', w / 2, h / 2);
                return;
            }

            // Draw theoretical curve (Boltzmann prediction)
            const f0 = history[0];
            const rho = nMarkers / N;  // Marker density
            const alpha = 1 - 2 * rho;

            historyCtx.strokeStyle = 'rgba(168, 85, 247, 0.4)';
            historyCtx.lineWidth = 2;
            historyCtx.setLineDash([3, 3]);
            historyCtx.beginPath();

            for (let t = 0; t < history.length; t++) {
                const theoreticalF = 0.5 + Math.pow(alpha, t) * (f0 - 0.5);
                const x = padding.left + (t / (history.length - 1)) * (w - padding.left - padding.right);
                const y = padding.top + (1 - theoreticalF) * (h - padding.top - padding.bottom);

                if (t === 0) historyCtx.moveTo(x, y);
                else historyCtx.lineTo(x, y);
            }
            historyCtx.stroke();
            historyCtx.setLineDash([]);

            // Draw actual data
            historyCtx.strokeStyle = '#ec4899';
            historyCtx.lineWidth = 2;
            historyCtx.beginPath();

            for (let i = 0; i < history.length; i++) {
                const x = padding.left + (i / (history.length - 1)) * (w - padding.left - padding.right);
                const y = padding.top + (1 - history[i]) * (h - padding.top - padding.bottom);

                if (i === 0) historyCtx.moveTo(x, y);
                else historyCtx.lineTo(x, y);
            }
            historyCtx.stroke();

            // Labels
            historyCtx.fillStyle = '#888';
            historyCtx.font = '10px sans-serif';
            historyCtx.textAlign = 'center';
            historyCtx.fillText('Time steps', w / 2, h - 5);

            // Legend
            historyCtx.fillStyle = '#ec4899';
            historyCtx.fillRect(w - 100, padding.top, 15, 3);
            historyCtx.fillStyle = '#888';
            historyCtx.font = '9px sans-serif';
            historyCtx.textAlign = 'left';
            historyCtx.fillText('Actual', w - 80, padding.top + 4);

            historyCtx.strokeStyle = 'rgba(168, 85, 247, 0.6)';
            historyCtx.setLineDash([3, 3]);
            historyCtx.beginPath();
            historyCtx.moveTo(w - 100, padding.top + 15);
            historyCtx.lineTo(w - 85, padding.top + 15);
            historyCtx.stroke();
            historyCtx.setLineDash([]);
            historyCtx.fillText('Boltzmann', w - 80, padding.top + 18);
        }

        // Update stats
        function updateStats() {
            const white = countWhite();
            document.getElementById('timeStat').textContent = timeStep;
            document.getElementById('whiteStat').textContent = white;
            document.getElementById('fractionStat').textContent = (white / N * 100).toFixed(1) + '%';
            document.getElementById('periodStat').textContent = computePeriod();
        }

        // Animation loop
        function animate() {
            if (!running) return;

            frameCount++;
            if (frameCount % Math.max(1, Math.floor(20 / speed)) === 0) {
                step();
                drawRing();
                drawHistory();
                updateStats();
            }

            animationId = requestAnimationFrame(animate);
        }

        // Controls
        function toggleSimulation() {
            running = !running;
            document.getElementById('playBtn').textContent = running ? '⏸ Pause' : '▶ Start';

            if (running) {
                animate();
            } else if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }

        function stepOnce() {
            step();
            drawRing();
            drawHistory();
            updateStats();
        }

        function resetSimulation() {
            running = false;
            document.getElementById('playBtn').textContent = '▶ Start';
            if (animationId) cancelAnimationFrame(animationId);

            timeStep = 0;
            history = [];
            frameCount = 0;

            initializeBalls();
            initializeMarkers();

            // Record initial state
            history.push(countWhite() / N);

            drawRing();
            drawHistory();
            updateStats();
        }

        function updateN() {
            N = parseInt(document.getElementById('nSlider').value);
            document.getElementById('nValue').textContent = N;

            // Ensure markers don't exceed N
            if (nMarkers >= N) {
                nMarkers = Math.floor(N * 0.4);
                document.getElementById('mSlider').value = nMarkers;
                document.getElementById('mValue').textContent = nMarkers;
            }

            resetSimulation();
        }

        function updateM() {
            nMarkers = parseInt(document.getElementById('mSlider').value);
            nMarkers = Math.min(nMarkers, N - 1);
            document.getElementById('mSlider').value = nMarkers;
            document.getElementById('mValue').textContent = nMarkers;
            resetSimulation();
        }

        function updateSpeed() {
            speed = parseInt(document.getElementById('speedSlider').value);
            document.getElementById('speedValue').textContent = speed;
        }

        // Initialize
        window.addEventListener('resize', () => {
            resizeCanvases();
            drawRing();
            drawHistory();
        });

        resetSimulation();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
