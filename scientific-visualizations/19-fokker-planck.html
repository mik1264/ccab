<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fokker-Planck PDE Visualizer - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0;
        }

        h1 {
            font-size: 2.2rem;
            background: linear-gradient(135deg, #f97316, #facc15);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #888;
            font-size: 1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-top: 20px;
        }

        .canvas-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(249, 115, 22, 0.3);
        }

        .canvas-container h3 {
            color: #f97316;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        canvas {
            display: block;
            background: #0a0a1a;
            border-radius: 10px;
        }

        #mainCanvas {
            width: 100%;
            height: 320px;
        }

        #potentialCanvas {
            width: 100%;
            height: 150px;
        }

        #particlesCanvas {
            width: 100%;
            height: 150px;
        }

        .controls {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(249, 115, 22, 0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group h3 {
            color: #f97316;
            font-size: 0.85rem;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        label {
            display: block;
            margin: 10px 0 5px;
            color: #aaa;
            font-size: 0.8rem;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #f97316;
            cursor: pointer;
        }

        .value-display {
            text-align: right;
            font-size: 0.75rem;
            color: #f97316;
            font-family: monospace;
        }

        button {
            width: 100%;
            padding: 10px 15px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #f97316, #ea580c);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(249, 115, 22, 0.4);
        }

        .btn-secondary {
            background: rgba(249, 115, 22, 0.2);
            color: #f97316;
            border: 1px solid rgba(249, 115, 22, 0.5);
        }

        .btn-secondary:hover {
            background: rgba(249, 115, 22, 0.3);
        }

        select {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(249, 115, 22, 0.5);
            color: #e0e0e0;
            font-size: 0.85rem;
        }

        .stats {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            font-size: 0.8rem;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            font-family: monospace;
            color: #facc15;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 10px;
            font-size: 0.8rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-line {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        .equation-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-family: 'Times New Roman', serif;
            font-size: 0.9rem;
            text-align: center;
            color: #facc15;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #f97316;
            text-decoration: none;
            font-weight: 600;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            border: 1px solid rgba(249, 115, 22, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .back-link:hover {
            background: rgba(249, 115, 22, 0.2);
            transform: translateX(-5px);
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <div class="container">
        <header>
            <h1>Fokker-Planck PDE Visualizer</h1>
            <p class="subtitle">Probability Density Evolution Under Drift and Diffusion</p>
        </header>

        <div class="main-content">
            <div class="canvas-section">
                <div class="canvas-container">
                    <h3>Probability Density p(x, t)</h3>
                    <canvas id="mainCanvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-line" style="background: #f97316;"></div>
                            <span>FPE Solution</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-line" style="background: #22c55e; opacity: 0.7;"></div>
                            <span>Monte Carlo</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-line" style="background: #3b82f6; border-style: dashed;"></div>
                            <span>Stationary (Boltzmann)</span>
                        </div>
                    </div>
                </div>

                <div class="canvas-container">
                    <h3>Potential V(x) and Drift μ(x) = -V'(x)</h3>
                    <canvas id="potentialCanvas"></canvas>
                </div>

                <div class="canvas-container">
                    <h3>Sample Particle Trajectories (SDE)</h3>
                    <canvas id="particlesCanvas"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="equation-box">
                    ∂p/∂t = -∂(μp)/∂x + D·∂²p/∂x²
                </div>

                <div class="control-group">
                    <h3>Simulation</h3>
                    <button class="btn-primary" onclick="toggleSimulation()">
                        <span id="playBtn">▶ Start</span>
                    </button>
                    <button class="btn-secondary" onclick="resetSimulation()">Reset</button>
                    <button class="btn-secondary" onclick="stepSimulation()">Single Step</button>
                </div>

                <div class="control-group">
                    <h3>Potential</h3>
                    <select id="potentialSelect" onchange="changePotential()">
                        <option value="harmonic">Harmonic (Quadratic)</option>
                        <option value="doublewell">Double Well</option>
                        <option value="asymmetric">Asymmetric Double Well</option>
                        <option value="quartic">Quartic</option>
                        <option value="free">Free (No Potential)</option>
                    </select>
                </div>

                <div class="control-group">
                    <h3>Parameters</h3>

                    <label>Diffusion D: <span id="diffusionValue">0.50</span></label>
                    <input type="range" id="diffusionSlider" min="0.1" max="2" value="0.5" step="0.05" oninput="updateParams()">

                    <label>Temperature T: <span id="tempValue">1.00</span></label>
                    <input type="range" id="tempSlider" min="0.2" max="3" value="1" step="0.1" oninput="updateParams()">

                    <label>Time Step dt: <span id="dtValue">0.005</span></label>
                    <input type="range" id="dtSlider" min="0.001" max="0.01" value="0.005" step="0.001" oninput="updateParams()">
                </div>

                <div class="control-group">
                    <h3>Initial Condition</h3>
                    <select id="initialSelect" onchange="resetSimulation()">
                        <option value="delta_left">Delta (Left)</option>
                        <option value="delta_center">Delta (Center)</option>
                        <option value="delta_right">Delta (Right)</option>
                        <option value="gaussian">Gaussian (Center)</option>
                        <option value="bimodal">Bimodal</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Monte Carlo Particles: <span id="particlesValue">200</span></label>
                    <input type="range" id="particlesSlider" min="50" max="500" value="200" step="50" oninput="updateParticles()">
                </div>

                <div class="stats">
                    <div class="stat-row">
                        <span class="stat-label">Time:</span>
                        <span class="stat-value" id="timeStat">0.00</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Mean (FPE):</span>
                        <span class="stat-value" id="meanFPE">—</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Mean (MC):</span>
                        <span class="stat-value" id="meanMC">—</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Variance (FPE):</span>
                        <span class="stat-value" id="varFPE">—</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Variance (MC):</span>
                        <span class="stat-value" id="varMC">—</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const mainCanvas = document.getElementById('mainCanvas');
        const mainCtx = mainCanvas.getContext('2d');
        const potentialCanvas = document.getElementById('potentialCanvas');
        const potentialCtx = potentialCanvas.getContext('2d');
        const particlesCanvas = document.getElementById('particlesCanvas');
        const particlesCtx = particlesCanvas.getContext('2d');

        function resizeCanvases() {
            [mainCanvas, potentialCanvas, particlesCanvas].forEach(canvas => {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                canvas.getContext('2d').scale(window.devicePixelRatio, window.devicePixelRatio);
            });
        }

        resizeCanvases();

        // Domain
        const xMin = -5;
        const xMax = 5;
        const N = 200; // Grid points
        const dx = (xMax - xMin) / (N - 1);
        const x = Array.from({length: N}, (_, i) => xMin + i * dx);

        // State
        let p = new Array(N).fill(0); // Probability density
        let particles = [];
        let particleHistory = [];
        let D = 0.5;  // Diffusion coefficient
        let T = 1.0;  // Temperature
        let dt = 0.005;
        let time = 0;
        let running = false;
        let animationId = null;
        let nParticles = 200;

        // Potential functions
        const potentials = {
            harmonic: {
                V: (x) => 0.5 * x * x,
                dV: (x) => x,
                name: 'V(x) = ½x²'
            },
            doublewell: {
                V: (x) => 0.25 * x * x * x * x - 0.5 * x * x,
                dV: (x) => x * x * x - x,
                name: 'V(x) = ¼x⁴ - ½x²'
            },
            asymmetric: {
                V: (x) => 0.25 * x * x * x * x - 0.5 * x * x + 0.1 * x,
                dV: (x) => x * x * x - x + 0.1,
                name: 'V(x) = ¼x⁴ - ½x² + 0.1x'
            },
            quartic: {
                V: (x) => 0.1 * x * x * x * x,
                dV: (x) => 0.4 * x * x * x,
                name: 'V(x) = 0.1x⁴'
            },
            free: {
                V: (x) => 0,
                dV: (x) => 0,
                name: 'V(x) = 0'
            }
        };

        let currentPotential = potentials.harmonic;

        // Drift: μ(x) = -dV/dx (gradient descent in potential)
        function drift(x) {
            return -currentPotential.dV(x);
        }

        // Initialize FPE distribution
        function initializeFPE() {
            const initial = document.getElementById('initialSelect').value;
            p.fill(0);

            if (initial === 'delta_left') {
                const idx = Math.floor(N * 0.25);
                p[idx] = 1 / dx;
            } else if (initial === 'delta_center') {
                const idx = Math.floor(N / 2);
                p[idx] = 1 / dx;
            } else if (initial === 'delta_right') {
                const idx = Math.floor(N * 0.75);
                p[idx] = 1 / dx;
            } else if (initial === 'gaussian') {
                const sigma = 0.5;
                for (let i = 0; i < N; i++) {
                    p[i] = Math.exp(-x[i] * x[i] / (2 * sigma * sigma)) / (Math.sqrt(2 * Math.PI) * sigma);
                }
            } else if (initial === 'bimodal') {
                const sigma = 0.4;
                for (let i = 0; i < N; i++) {
                    const g1 = Math.exp(-(x[i] - 1.5) * (x[i] - 1.5) / (2 * sigma * sigma));
                    const g2 = Math.exp(-(x[i] + 1.5) * (x[i] + 1.5) / (2 * sigma * sigma));
                    p[i] = (g1 + g2) / (2 * Math.sqrt(2 * Math.PI) * sigma);
                }
            }

            // Normalize
            const total = p.reduce((s, v) => s + v * dx, 0);
            if (total > 0) {
                for (let i = 0; i < N; i++) {
                    p[i] /= total;
                }
            }
        }

        // Initialize particles
        function initializeParticles() {
            const initial = document.getElementById('initialSelect').value;
            particles = [];
            particleHistory = [];

            for (let i = 0; i < nParticles; i++) {
                let x0;
                if (initial === 'delta_left') {
                    x0 = xMin + (xMax - xMin) * 0.25 + (Math.random() - 0.5) * 0.1;
                } else if (initial === 'delta_center') {
                    x0 = (Math.random() - 0.5) * 0.1;
                } else if (initial === 'delta_right') {
                    x0 = xMin + (xMax - xMin) * 0.75 + (Math.random() - 0.5) * 0.1;
                } else if (initial === 'gaussian') {
                    x0 = randn() * 0.5;
                } else if (initial === 'bimodal') {
                    x0 = Math.random() < 0.5 ? randn() * 0.4 - 1.5 : randn() * 0.4 + 1.5;
                } else {
                    x0 = 0;
                }
                particles.push({ x: x0, history: [x0] });
            }
        }

        // Box-Muller
        function randn() {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
        }

        // Fokker-Planck step (finite differences)
        // ∂p/∂t = -∂(μp)/∂x + D·∂²p/∂x²
        function stepFPE() {
            const pNew = new Array(N).fill(0);

            for (let i = 1; i < N - 1; i++) {
                // Drift term: -∂(μp)/∂x using upwind
                const mu_i = drift(x[i]);
                const mu_ip = drift(x[i + 1]);
                const mu_im = drift(x[i - 1]);

                // Central difference for flux
                const flux_p = mu_ip * p[i + 1];
                const flux_m = mu_im * p[i - 1];
                const driftTerm = -(flux_p - flux_m) / (2 * dx);

                // Diffusion term: D·∂²p/∂x²
                const diffusionTerm = D * (p[i + 1] - 2 * p[i] + p[i - 1]) / (dx * dx);

                pNew[i] = p[i] + dt * (driftTerm + diffusionTerm);
            }

            // Reflecting boundary conditions
            pNew[0] = pNew[1];
            pNew[N - 1] = pNew[N - 2];

            // Ensure non-negative and normalize
            for (let i = 0; i < N; i++) {
                pNew[i] = Math.max(0, pNew[i]);
            }

            const total = pNew.reduce((s, v) => s + v * dx, 0);
            if (total > 0) {
                for (let i = 0; i < N; i++) {
                    pNew[i] /= total;
                }
            }

            p = pNew;
        }

        // Langevin dynamics step (SDE)
        // dX = μ(X)dt + √(2D)dW
        function stepParticles() {
            const noise = Math.sqrt(2 * D * dt);

            for (const particle of particles) {
                const mu = drift(particle.x);
                particle.x += mu * dt + noise * randn();

                // Reflecting boundaries
                if (particle.x < xMin) particle.x = 2 * xMin - particle.x;
                if (particle.x > xMax) particle.x = 2 * xMax - particle.x;

                // Keep history (limit length)
                particle.history.push(particle.x);
                if (particle.history.length > 200) {
                    particle.history.shift();
                }
            }
        }

        // Compute stationary distribution (Boltzmann)
        function getStationaryDistribution() {
            const stat = new Array(N).fill(0);

            for (let i = 0; i < N; i++) {
                stat[i] = Math.exp(-currentPotential.V(x[i]) / (D * T));
            }

            // Normalize
            const total = stat.reduce((s, v) => s + v * dx, 0);
            if (total > 0) {
                for (let i = 0; i < N; i++) {
                    stat[i] /= total;
                }
            }

            return stat;
        }

        // Get histogram from particles
        function getParticleHistogram() {
            const bins = new Array(N).fill(0);

            for (const particle of particles) {
                const idx = Math.floor((particle.x - xMin) / dx);
                if (idx >= 0 && idx < N) {
                    bins[idx]++;
                }
            }

            // Normalize
            const total = bins.reduce((s, v) => s + v, 0);
            if (total > 0) {
                for (let i = 0; i < N; i++) {
                    bins[i] = bins[i] / (total * dx);
                }
            }

            return bins;
        }

        // Compute statistics
        function computeStats() {
            // FPE mean and variance
            let meanFPE = 0, varFPE = 0;
            for (let i = 0; i < N; i++) {
                meanFPE += x[i] * p[i] * dx;
            }
            for (let i = 0; i < N; i++) {
                varFPE += (x[i] - meanFPE) * (x[i] - meanFPE) * p[i] * dx;
            }

            // MC mean and variance
            let meanMC = 0;
            for (const particle of particles) {
                meanMC += particle.x;
            }
            meanMC /= particles.length;

            let varMC = 0;
            for (const particle of particles) {
                varMC += (particle.x - meanMC) * (particle.x - meanMC);
            }
            varMC /= particles.length;

            return { meanFPE, varFPE, meanMC, varMC };
        }

        // Draw main canvas (probability density)
        function drawMain() {
            const rect = mainCanvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;
            const padding = { top: 30, bottom: 40, left: 50, right: 20 };

            mainCtx.fillStyle = '#0a0a1a';
            mainCtx.fillRect(0, 0, w, h);

            // Find y scale
            const stationary = getStationaryDistribution();
            const histogram = getParticleHistogram();
            const maxP = Math.max(
                Math.max(...p),
                Math.max(...stationary),
                Math.max(...histogram)
            ) * 1.1 || 1;

            // Draw axes
            mainCtx.strokeStyle = '#444';
            mainCtx.lineWidth = 1;
            mainCtx.beginPath();
            mainCtx.moveTo(padding.left, padding.top);
            mainCtx.lineTo(padding.left, h - padding.bottom);
            mainCtx.lineTo(w - padding.right, h - padding.bottom);
            mainCtx.stroke();

            // X labels
            mainCtx.fillStyle = '#888';
            mainCtx.font = '10px sans-serif';
            mainCtx.textAlign = 'center';
            for (let v = -4; v <= 4; v += 2) {
                const px = padding.left + ((v - xMin) / (xMax - xMin)) * (w - padding.left - padding.right);
                mainCtx.fillText(v.toString(), px, h - padding.bottom + 15);
            }
            mainCtx.fillText('x', w / 2, h - 5);

            // Y label
            mainCtx.save();
            mainCtx.translate(12, h / 2);
            mainCtx.rotate(-Math.PI / 2);
            mainCtx.fillText('p(x)', 0, 0);
            mainCtx.restore();

            // Helper function
            const toCanvasX = (xVal) => padding.left + ((xVal - xMin) / (xMax - xMin)) * (w - padding.left - padding.right);
            const toCanvasY = (pVal) => h - padding.bottom - (pVal / maxP) * (h - padding.top - padding.bottom);

            // Draw stationary distribution (dashed)
            mainCtx.strokeStyle = '#3b82f6';
            mainCtx.lineWidth = 2;
            mainCtx.setLineDash([5, 5]);
            mainCtx.beginPath();
            for (let i = 0; i < N; i++) {
                const px = toCanvasX(x[i]);
                const py = toCanvasY(stationary[i]);
                if (i === 0) mainCtx.moveTo(px, py);
                else mainCtx.lineTo(px, py);
            }
            mainCtx.stroke();
            mainCtx.setLineDash([]);

            // Draw Monte Carlo histogram
            mainCtx.strokeStyle = 'rgba(34, 197, 94, 0.7)';
            mainCtx.fillStyle = 'rgba(34, 197, 94, 0.2)';
            mainCtx.lineWidth = 1.5;
            mainCtx.beginPath();
            mainCtx.moveTo(toCanvasX(xMin), toCanvasY(0));
            for (let i = 0; i < N; i++) {
                mainCtx.lineTo(toCanvasX(x[i]), toCanvasY(histogram[i]));
            }
            mainCtx.lineTo(toCanvasX(xMax), toCanvasY(0));
            mainCtx.closePath();
            mainCtx.fill();
            mainCtx.stroke();

            // Draw FPE solution
            mainCtx.strokeStyle = '#f97316';
            mainCtx.lineWidth = 2.5;
            mainCtx.beginPath();
            for (let i = 0; i < N; i++) {
                const px = toCanvasX(x[i]);
                const py = toCanvasY(p[i]);
                if (i === 0) mainCtx.moveTo(px, py);
                else mainCtx.lineTo(px, py);
            }
            mainCtx.stroke();

            // Fill under FPE curve
            mainCtx.fillStyle = 'rgba(249, 115, 22, 0.15)';
            mainCtx.beginPath();
            mainCtx.moveTo(toCanvasX(xMin), toCanvasY(0));
            for (let i = 0; i < N; i++) {
                mainCtx.lineTo(toCanvasX(x[i]), toCanvasY(p[i]));
            }
            mainCtx.lineTo(toCanvasX(xMax), toCanvasY(0));
            mainCtx.closePath();
            mainCtx.fill();
        }

        // Draw potential
        function drawPotential() {
            const rect = potentialCanvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;
            const padding = { top: 20, bottom: 30, left: 50, right: 20 };

            potentialCtx.fillStyle = '#0a0a1a';
            potentialCtx.fillRect(0, 0, w, h);

            // Compute potential values
            const V = x.map(xi => currentPotential.V(xi));
            const minV = Math.min(...V);
            const maxV = Math.max(...V);
            const rangeV = Math.max(maxV - minV, 0.1);

            // Draw axes
            potentialCtx.strokeStyle = '#444';
            potentialCtx.lineWidth = 1;
            potentialCtx.beginPath();
            potentialCtx.moveTo(padding.left, padding.top);
            potentialCtx.lineTo(padding.left, h - padding.bottom);
            potentialCtx.lineTo(w - padding.right, h - padding.bottom);
            potentialCtx.stroke();

            const toCanvasX = (xVal) => padding.left + ((xVal - xMin) / (xMax - xMin)) * (w - padding.left - padding.right);
            const toCanvasY = (vVal) => h - padding.bottom - ((vVal - minV) / rangeV) * (h - padding.top - padding.bottom);

            // Draw potential
            potentialCtx.strokeStyle = '#facc15';
            potentialCtx.lineWidth = 2;
            potentialCtx.beginPath();
            for (let i = 0; i < N; i++) {
                const px = toCanvasX(x[i]);
                const py = toCanvasY(V[i]);
                if (i === 0) potentialCtx.moveTo(px, py);
                else potentialCtx.lineTo(px, py);
            }
            potentialCtx.stroke();

            // Label
            potentialCtx.fillStyle = '#888';
            potentialCtx.font = '10px sans-serif';
            potentialCtx.textAlign = 'left';
            potentialCtx.fillText(currentPotential.name, padding.left + 5, padding.top + 5);
        }

        // Draw particle trajectories
        function drawParticles() {
            const rect = particlesCanvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;
            const padding = { top: 10, bottom: 25, left: 50, right: 20 };

            particlesCtx.fillStyle = '#0a0a1a';
            particlesCtx.fillRect(0, 0, w, h);

            // Draw axis
            particlesCtx.strokeStyle = '#444';
            particlesCtx.lineWidth = 1;
            particlesCtx.beginPath();
            particlesCtx.moveTo(padding.left, h - padding.bottom);
            particlesCtx.lineTo(w - padding.right, h - padding.bottom);
            particlesCtx.stroke();

            // Zero line
            const zeroY = (h - padding.top - padding.bottom) / 2 + padding.top;
            potentialCtx.strokeStyle = '#333';
            potentialCtx.beginPath();
            potentialCtx.moveTo(padding.left, zeroY);
            potentialCtx.lineTo(w - padding.right, zeroY);
            potentialCtx.stroke();

            const toCanvasY = (xVal) => padding.top + ((xMax - xVal) / (xMax - xMin)) * (h - padding.top - padding.bottom);

            // Draw trajectories (sample)
            const sampleSize = Math.min(30, particles.length);
            for (let j = 0; j < sampleSize; j++) {
                const particle = particles[j];
                const history = particle.history;

                if (history.length < 2) continue;

                const hue = (j / sampleSize) * 60 + 20; // Yellow to orange
                particlesCtx.strokeStyle = `hsla(${hue}, 80%, 60%, 0.5)`;
                particlesCtx.lineWidth = 1;
                particlesCtx.beginPath();

                for (let i = 0; i < history.length; i++) {
                    const px = padding.left + (i / (history.length - 1)) * (w - padding.left - padding.right);
                    const py = toCanvasY(history[i]);

                    if (i === 0) particlesCtx.moveTo(px, py);
                    else particlesCtx.lineTo(px, py);
                }
                particlesCtx.stroke();
            }

            // Draw current particle positions
            particlesCtx.fillStyle = '#f97316';
            for (const particle of particles) {
                const py = toCanvasY(particle.x);
                particlesCtx.beginPath();
                particlesCtx.arc(w - padding.right - 5, py, 2, 0, Math.PI * 2);
                particlesCtx.fill();
            }

            // Labels
            particlesCtx.fillStyle = '#888';
            particlesCtx.font = '9px sans-serif';
            particlesCtx.textAlign = 'right';
            particlesCtx.fillText(`${xMax}`, padding.left - 5, padding.top + 5);
            particlesCtx.fillText(`${xMin}`, padding.left - 5, h - padding.bottom);
        }

        // Update stats display
        function updateStats() {
            const stats = computeStats();
            document.getElementById('timeStat').textContent = time.toFixed(2);
            document.getElementById('meanFPE').textContent = stats.meanFPE.toFixed(3);
            document.getElementById('meanMC').textContent = stats.meanMC.toFixed(3);
            document.getElementById('varFPE').textContent = stats.varFPE.toFixed(3);
            document.getElementById('varMC').textContent = stats.varMC.toFixed(3);
        }

        // Animation loop
        function animate() {
            if (!running) return;

            // Multiple sub-steps per frame for stability
            const steps = 5;
            for (let i = 0; i < steps; i++) {
                stepFPE();
                stepParticles();
                time += dt;
            }

            drawMain();
            drawParticles();
            updateStats();

            animationId = requestAnimationFrame(animate);
        }

        // Controls
        function toggleSimulation() {
            running = !running;
            document.getElementById('playBtn').textContent = running ? '⏸ Pause' : '▶ Start';

            if (running) {
                animate();
            } else if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }

        function resetSimulation() {
            running = false;
            document.getElementById('playBtn').textContent = '▶ Start';
            if (animationId) cancelAnimationFrame(animationId);

            time = 0;
            initializeFPE();
            initializeParticles();
            drawMain();
            drawPotential();
            drawParticles();
            updateStats();
        }

        function stepSimulation() {
            for (let i = 0; i < 10; i++) {
                stepFPE();
                stepParticles();
                time += dt;
            }
            drawMain();
            drawParticles();
            updateStats();
        }

        function changePotential() {
            const val = document.getElementById('potentialSelect').value;
            currentPotential = potentials[val];
            resetSimulation();
        }

        function updateParams() {
            D = parseFloat(document.getElementById('diffusionSlider').value);
            T = parseFloat(document.getElementById('tempSlider').value);
            dt = parseFloat(document.getElementById('dtSlider').value);

            document.getElementById('diffusionValue').textContent = D.toFixed(2);
            document.getElementById('tempValue').textContent = T.toFixed(2);
            document.getElementById('dtValue').textContent = dt.toFixed(3);

            drawMain();
            drawPotential();
        }

        function updateParticles() {
            nParticles = parseInt(document.getElementById('particlesSlider').value);
            document.getElementById('particlesValue').textContent = nParticles;
            initializeParticles();
            drawParticles();
        }

        // Initialize
        window.addEventListener('resize', () => {
            resizeCanvases();
            drawMain();
            drawPotential();
            drawParticles();
        });

        resetSimulation();
    </script>
</body>
</html>
