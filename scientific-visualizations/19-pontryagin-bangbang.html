<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pontryagin Bang-Bang Control - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #c9a227;
            text-decoration: none;
            font-size: 14px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 20px;
            transition: background 0.3s;
        }

        .back-link:hover {
            background: rgba(201, 162, 39, 0.2);
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(30, 30, 45, 0.95);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(201, 162, 39, 0.2);
            width: 340px;
            z-index: 1000;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        h1 {
            color: #c9a227;
            font-size: 1.2em;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(201, 162, 39, 0.3);
        }

        .subtitle {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 15px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            color: #c9a227;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #c9a227;
            border-radius: 50%;
            cursor: pointer;
        }

        .value-display {
            text-align: right;
            color: #aaa;
            font-size: 11px;
            margin-top: 3px;
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #aaa;
            font-size: 0.85em;
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"] {
            accent-color: #c9a227;
        }

        .btn {
            padding: 10px 16px;
            background: rgba(201, 162, 39, 0.2);
            border: 1px solid rgba(201, 162, 39, 0.4);
            border-radius: 8px;
            color: #c9a227;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        .btn:hover {
            background: rgba(201, 162, 39, 0.3);
            transform: translateY(-1px);
        }

        .control-status {
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 15px;
            font-family: monospace;
            font-size: 1.2em;
        }

        .control-plus {
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
        }

        .control-minus {
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
        }

        .control-zero {
            background: rgba(150, 150, 150, 0.2);
            color: #999;
        }

        .equations {
            background: rgba(0, 0, 0, 0.4);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-family: 'Times New Roman', serif;
        }

        .equation {
            color: #4ecdc4;
            margin: 5px 0;
            text-align: center;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-item .value {
            font-size: 1.1em;
            color: #c9a227;
            font-weight: bold;
            font-family: monospace;
        }

        .stat-item .label {
            font-size: 0.7em;
            color: #888;
            margin-top: 3px;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .info-panel h3 {
            color: #c9a227;
            font-size: 0.95em;
            margin-bottom: 8px;
        }

        .info-panel p {
            color: #aaa;
            font-size: 0.8em;
            line-height: 1.5;
        }

        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8em;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>Pontryagin Bang-Bang Control</h1>
        <p class="subtitle">Time-optimal control of a double integrator</p>

        <div class="control-status" id="controlStatus">u = +1</div>

        <div class="equations">
            <div class="equation">ẋ₁ = x₂ (position → velocity)</div>
            <div class="equation">ẋ₂ = u (acceleration)</div>
            <div class="equation">|u| ≤ 1 (bounded control)</div>
        </div>

        <div class="control-group">
            <label>Initial Position (x₁)</label>
            <input type="range" id="initX1" min="-5" max="5" step="0.1" value="3">
            <div class="value-display" id="initX1Value">3.0</div>
        </div>

        <div class="control-group">
            <label>Initial Velocity (x₂)</label>
            <input type="range" id="initX2" min="-5" max="5" step="0.1" value="2">
            <div class="value-display" id="initX2Value">2.0</div>
        </div>

        <div class="control-group">
            <label>Simulation Speed</label>
            <input type="range" id="simSpeed" min="0.1" max="3" step="0.1" value="1">
            <div class="value-display" id="simSpeedValue">1.0x</div>
        </div>

        <div class="control-group">
            <label>Display Options</label>
            <div class="checkbox-group">
                <label><input type="checkbox" id="showSwitch" checked> Switching Curve</label>
                <label><input type="checkbox" id="showTrajectory" checked> Trajectory</label>
                <label><input type="checkbox" id="showPhaseFlow" checked> Phase Flow</label>
                <label><input type="checkbox" id="showControlRegions"> Control Regions</label>
            </div>
        </div>

        <div>
            <button class="btn" onclick="resetSimulation()">Reset</button>
            <button class="btn" onclick="togglePause()">Pause/Play</button>
            <button class="btn" onclick="randomStart()">Random Start</button>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="value" id="posValue">0.00</div>
                <div class="label">Position x₁</div>
            </div>
            <div class="stat-item">
                <div class="value" id="velValue">0.00</div>
                <div class="label">Velocity x₂</div>
            </div>
            <div class="stat-item">
                <div class="value" id="timeValue">0.00</div>
                <div class="label">Time</div>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #4ecdc4;"></div>
                <span>u = +1</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff6b6b;"></div>
                <span>u = -1</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #c9a227;"></div>
                <span>Switching Curve</span>
            </div>
        </div>

        <div class="info-panel">
            <h3>Optimal Switching Curve</h3>
            <p>
                The switching curve is: <strong>x₁ = -½ sgn(x₂) x₂²</strong>
            </p>
            <p style="margin-top: 8px;">
                <strong>Bang-bang principle:</strong> For time-optimal control, the control
                only takes extreme values (+1 or -1), never intermediate values.
            </p>
            <p style="margin-top: 8px;">
                The trajectory follows parabolas in phase space, switching exactly once
                when crossing the optimal switching curve.
            </p>
        </div>

        <div class="info-panel">
            <h3>Click to Set Initial State</h3>
            <p>
                Click anywhere on the phase plane to start a trajectory from that point.
                Watch how the optimal controller drives the system to the origin.
            </p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // State variables
        let x1 = 3; // position
        let x2 = 2; // velocity
        let time = 0;
        let paused = false;
        let simSpeed = 1;

        // Initial conditions
        let initX1 = 3;
        let initX2 = 2;

        // Display options
        let showSwitch = true;
        let showTrajectory = true;
        let showPhaseFlow = true;
        let showControlRegions = false;

        // Trajectory history
        let trajectory = [];
        const MAX_TRAJECTORY_POINTS = 5000;

        // Scale
        let scale = 60;
        let originX, originY;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            originX = canvas.width / 2;
            originY = canvas.height / 2;
            render();
        }

        // Optimal control law
        function optimalControl(x1, x2) {
            // Switching curve: x1 = -0.5 * sign(x2) * x2^2
            const switchCurve = -0.5 * Math.sign(x2) * x2 * x2;

            // Determine which side of the switching curve we're on
            if (x2 > 0) {
                // Above x-axis: u = -1 if x1 > switchCurve, else u = +1
                return (x1 > switchCurve) ? -1 : 1;
            } else if (x2 < 0) {
                // Below x-axis: u = +1 if x1 < switchCurve, else u = -1
                return (x1 < switchCurve) ? 1 : -1;
            } else {
                // On x-axis
                return (x1 > 0) ? -1 : (x1 < 0) ? 1 : 0;
            }
        }

        // Simulate one step
        function step(dt) {
            const u = optimalControl(x1, x2);

            // Double integrator dynamics
            x1 += x2 * dt;
            x2 += u * dt;
            time += dt;

            // Store trajectory point
            trajectory.push({ x1, x2, u });
            if (trajectory.length > MAX_TRAJECTORY_POINTS) {
                trajectory.shift();
            }

            // Check if reached origin (with tolerance)
            if (Math.abs(x1) < 0.01 && Math.abs(x2) < 0.01) {
                x1 = 0;
                x2 = 0;
            }
        }

        // Convert state to canvas coordinates
        function toCanvas(x1, x2) {
            return {
                x: originX + x1 * scale,
                y: originY - x2 * scale
            };
        }

        // Convert canvas to state coordinates
        function toState(canvasX, canvasY) {
            return {
                x1: (canvasX - originX) / scale,
                x2: (originY - canvasY) / scale
            };
        }

        function render() {
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw control regions
            if (showControlRegions) {
                drawControlRegions();
            }

            // Draw grid
            drawGrid();

            // Draw phase flow field
            if (showPhaseFlow) {
                drawPhaseFlow();
            }

            // Draw switching curve
            if (showSwitch) {
                drawSwitchingCurve();
            }

            // Draw trajectory
            if (showTrajectory && trajectory.length > 1) {
                drawTrajectory();
            }

            // Draw current state
            drawState();

            // Update display
            updateDisplay();
        }

        function drawGrid() {
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.2)';
            ctx.lineWidth = 1;

            // Vertical lines
            for (let x = -10; x <= 10; x++) {
                const pos = toCanvas(x, 0);
                ctx.beginPath();
                ctx.moveTo(pos.x, 0);
                ctx.lineTo(pos.x, canvas.height);
                ctx.stroke();
            }

            // Horizontal lines
            for (let y = -10; y <= 10; y++) {
                const pos = toCanvas(0, y);
                ctx.beginPath();
                ctx.moveTo(0, pos.y);
                ctx.lineTo(canvas.width, pos.y);
                ctx.stroke();
            }

            // Axes
            ctx.strokeStyle = 'rgba(200, 200, 200, 0.5)';
            ctx.lineWidth = 2;

            // x1 axis
            ctx.beginPath();
            ctx.moveTo(0, originY);
            ctx.lineTo(canvas.width, originY);
            ctx.stroke();

            // x2 axis
            ctx.beginPath();
            ctx.moveTo(originX, 0);
            ctx.lineTo(originX, canvas.height);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '14px sans-serif';
            ctx.fillText('x₁ (position)', canvas.width - 100, originY - 10);
            ctx.fillText('x₂ (velocity)', originX + 10, 20);

            // Origin
            ctx.fillStyle = '#c9a227';
            ctx.beginPath();
            ctx.arc(originX, originY, 6, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawControlRegions() {
            // Draw regions where u = +1 and u = -1
            const imageData = ctx.createImageData(canvas.width, canvas.height);

            for (let py = 0; py < canvas.height; py += 2) {
                for (let px = 0; px < canvas.width; px += 2) {
                    const state = toState(px, py);
                    const u = optimalControl(state.x1, state.x2);

                    const color = u > 0 ? [78, 205, 196, 30] : [255, 107, 107, 30];

                    for (let dy = 0; dy < 2; dy++) {
                        for (let dx = 0; dx < 2; dx++) {
                            const idx = ((py + dy) * canvas.width + (px + dx)) * 4;
                            imageData.data[idx] = color[0];
                            imageData.data[idx + 1] = color[1];
                            imageData.data[idx + 2] = color[2];
                            imageData.data[idx + 3] = color[3];
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function drawSwitchingCurve() {
            ctx.strokeStyle = '#c9a227';
            ctx.lineWidth = 3;

            // Upper branch (x2 > 0): x1 = -0.5 * x2^2
            ctx.beginPath();
            for (let x2 = 0; x2 <= 8; x2 += 0.05) {
                const x1 = -0.5 * x2 * x2;
                const pos = toCanvas(x1, x2);
                if (x2 === 0) ctx.moveTo(pos.x, pos.y);
                else ctx.lineTo(pos.x, pos.y);
            }
            ctx.stroke();

            // Lower branch (x2 < 0): x1 = +0.5 * x2^2
            ctx.beginPath();
            for (let x2 = 0; x2 >= -8; x2 -= 0.05) {
                const x1 = 0.5 * x2 * x2;
                const pos = toCanvas(x1, x2);
                if (x2 === 0) ctx.moveTo(pos.x, pos.y);
                else ctx.lineTo(pos.x, pos.y);
            }
            ctx.stroke();
        }

        function drawPhaseFlow() {
            const spacing = 50;
            const arrowLength = 20;

            ctx.strokeStyle = 'rgba(150, 150, 150, 0.3)';
            ctx.lineWidth = 1;

            for (let px = spacing; px < canvas.width; px += spacing) {
                for (let py = spacing; py < canvas.height; py += spacing) {
                    const state = toState(px, py);
                    const u = optimalControl(state.x1, state.x2);

                    // Velocity vector: (x2, u)
                    const dx = state.x2;
                    const dy = u;
                    const mag = Math.sqrt(dx * dx + dy * dy);

                    if (mag > 0.01) {
                        const normDx = (dx / mag) * arrowLength;
                        const normDy = -(dy / mag) * arrowLength;

                        // Color based on control
                        ctx.strokeStyle = u > 0 ? 'rgba(78, 205, 196, 0.4)' : 'rgba(255, 107, 107, 0.4)';

                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(px + normDx, py + normDy);
                        ctx.stroke();

                        // Arrowhead
                        const angle = Math.atan2(normDy, normDx);
                        ctx.beginPath();
                        ctx.moveTo(px + normDx, py + normDy);
                        ctx.lineTo(
                            px + normDx - 5 * Math.cos(angle - 0.4),
                            py + normDy - 5 * Math.sin(angle - 0.4)
                        );
                        ctx.moveTo(px + normDx, py + normDy);
                        ctx.lineTo(
                            px + normDx - 5 * Math.cos(angle + 0.4),
                            py + normDy - 5 * Math.sin(angle + 0.4)
                        );
                        ctx.stroke();
                    }
                }
            }
        }

        function drawTrajectory() {
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            for (let i = 1; i < trajectory.length; i++) {
                const p1 = toCanvas(trajectory[i - 1].x1, trajectory[i - 1].x2);
                const p2 = toCanvas(trajectory[i].x1, trajectory[i].x2);

                ctx.strokeStyle = trajectory[i].u > 0 ? '#4ecdc4' : '#ff6b6b';
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }
        }

        function drawState() {
            const pos = toCanvas(x1, x2);

            // Glow effect
            const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 20);
            gradient.addColorStop(0, 'rgba(201, 162, 39, 0.5)');
            gradient.addColorStop(1, 'rgba(201, 162, 39, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 20, 0, Math.PI * 2);
            ctx.fill();

            // State point
            ctx.fillStyle = '#c9a227';
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function updateDisplay() {
            const u = optimalControl(x1, x2);

            const statusEl = document.getElementById('controlStatus');
            statusEl.textContent = `u = ${u >= 0 ? '+' : ''}${u}`;
            statusEl.className = 'control-status ' + (u > 0 ? 'control-plus' : u < 0 ? 'control-minus' : 'control-zero');

            document.getElementById('posValue').textContent = x1.toFixed(2);
            document.getElementById('velValue').textContent = x2.toFixed(2);
            document.getElementById('timeValue').textContent = time.toFixed(2);
        }

        function resetSimulation() {
            x1 = initX1;
            x2 = initX2;
            time = 0;
            trajectory = [{ x1, x2, u: optimalControl(x1, x2) }];
            render();
        }

        function togglePause() {
            paused = !paused;
        }

        function randomStart() {
            initX1 = (Math.random() - 0.5) * 8;
            initX2 = (Math.random() - 0.5) * 8;

            document.getElementById('initX1').value = initX1;
            document.getElementById('initX2').value = initX2;
            document.getElementById('initX1Value').textContent = initX1.toFixed(1);
            document.getElementById('initX2Value').textContent = initX2.toFixed(1);

            resetSimulation();
        }

        // Event listeners
        document.getElementById('initX1').addEventListener('input', e => {
            initX1 = parseFloat(e.target.value);
            document.getElementById('initX1Value').textContent = initX1.toFixed(1);
            resetSimulation();
        });

        document.getElementById('initX2').addEventListener('input', e => {
            initX2 = parseFloat(e.target.value);
            document.getElementById('initX2Value').textContent = initX2.toFixed(1);
            resetSimulation();
        });

        document.getElementById('simSpeed').addEventListener('input', e => {
            simSpeed = parseFloat(e.target.value);
            document.getElementById('simSpeedValue').textContent = simSpeed.toFixed(1) + 'x';
        });

        document.getElementById('showSwitch').addEventListener('change', e => {
            showSwitch = e.target.checked;
            render();
        });

        document.getElementById('showTrajectory').addEventListener('change', e => {
            showTrajectory = e.target.checked;
            render();
        });

        document.getElementById('showPhaseFlow').addEventListener('change', e => {
            showPhaseFlow = e.target.checked;
            render();
        });

        document.getElementById('showControlRegions').addEventListener('change', e => {
            showControlRegions = e.target.checked;
            render();
        });

        // Click to set initial state
        canvas.addEventListener('click', e => {
            const rect = canvas.getBoundingClientRect();
            const state = toState(e.clientX - rect.left, e.clientY - rect.top);

            initX1 = state.x1;
            initX2 = state.x2;

            document.getElementById('initX1').value = initX1;
            document.getElementById('initX2').value = initX2;
            document.getElementById('initX1Value').textContent = initX1.toFixed(1);
            document.getElementById('initX2Value').textContent = initX2.toFixed(1);

            resetSimulation();
        });

        window.addEventListener('resize', resize);

        // Animation loop
        function animate() {
            if (!paused && (Math.abs(x1) > 0.01 || Math.abs(x2) > 0.01)) {
                const dt = 0.02 * simSpeed;
                step(dt);
            }
            render();
            requestAnimationFrame(animate);
        }

        // Initialize
        resize();
        resetSimulation();
        animate();
    </script>
</body>
</html>
