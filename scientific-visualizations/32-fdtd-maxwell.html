<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D FDTD Maxwell Waves - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            color: var(--cream);
            min-height: 100vh;
            overflow: hidden;
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: rgba(138, 154, 91, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(138, 154, 91, 0.3);
            border-radius: 25px;
            color: var(--sage);
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .organic-back-link:hover {
            background: rgba(138, 154, 91, 0.3);
            transform: translateX(-3px);
        }

        .container {
            display: flex;
            height: 100vh;
            padding: 20px;
            gap: 20px;
        }

        .canvas-container {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 15px;
            display: flex;
            flex-direction: column;
        }

        .canvas-title {
            font-family: 'Lora', serif;
            font-size: 1rem;
            color: var(--earth);
            margin-bottom: 10px;
            text-align: center;
        }

        canvas {
            flex: 1;
            width: 100%;
            border-radius: 8px;
            background: #000;
            cursor: crosshair;
        }

        .controls {
            width: 320px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px;
            overflow-y: auto;
        }

        h1 {
            font-family: 'Lora', serif;
            font-size: 1.5rem;
            color: var(--earth);
            margin-bottom: 8px;
        }

        .subtitle {
            font-size: 0.85rem;
            color: var(--sage);
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            font-size: 0.85rem;
            color: var(--sage);
            margin-bottom: 6px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(138, 154, 91, 0.3);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--earth);
            cursor: pointer;
        }

        select {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(138, 154, 91, 0.3);
            border-radius: 8px;
            color: var(--cream);
            font-family: 'Nunito', sans-serif;
        }

        .value-display {
            font-size: 0.8rem;
            color: var(--cream);
            margin-top: 4px;
        }

        .button-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            flex: 1;
            padding: 10px 16px;
            background: linear-gradient(135deg, var(--sage), var(--moss));
            border: none;
            border-radius: 8px;
            color: white;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(138, 154, 91, 0.4);
        }

        button.secondary {
            background: rgba(138, 154, 91, 0.2);
            border: 1px solid var(--sage);
        }

        button.danger {
            background: rgba(188, 108, 37, 0.3);
            border: 1px solid var(--terracotta);
        }

        .info-box {
            background: rgba(138, 154, 91, 0.1);
            border: 1px solid rgba(138, 154, 91, 0.3);
            border-radius: 10px;
            padding: 12px;
            margin-top: 15px;
        }

        .info-box h3 {
            font-family: 'Lora', serif;
            font-size: 0.9rem;
            color: var(--earth);
            margin-bottom: 8px;
        }

        .info-box p {
            font-size: 0.8rem;
            line-height: 1.5;
            color: var(--cream);
            opacity: 0.9;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--sage);
            margin-bottom: 4px;
        }

        .stat-value {
            font-family: 'Lora', serif;
            font-size: 1rem;
            color: var(--earth);
        }

        .material-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .material-btn {
            padding: 8px;
            border-radius: 8px;
            border: 2px solid transparent;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .material-btn.active {
            border-color: var(--earth);
        }

        .material-btn.vacuum { background: rgba(0, 0, 0, 0.3); }
        .material-btn.dielectric { background: rgba(59, 130, 246, 0.3); }
        .material-btn.conductor { background: rgba(245, 158, 11, 0.3); }
        .material-btn.pml { background: rgba(156, 39, 176, 0.3); }

        @media (max-width: 900px) {
            .container {
                flex-direction: column;
            }
            .controls {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link">
        <span>←</span>
        <span>Gallery</span>
    </a>

    <div class="container">
        <div class="canvas-container">
            <div class="canvas-title">2D FDTD Electromagnetic Wave Propagation (Ez mode)</div>
            <canvas id="canvas"></canvas>
        </div>

        <div class="controls">
            <h1>FDTD Maxwell</h1>
            <p class="subtitle">Finite-Difference Time-Domain simulation of electromagnetic waves</p>

            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">Time Step</div>
                    <div class="stat-value" id="stepValue">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Grid Size</div>
                    <div class="stat-value" id="gridValue">200×150</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Max |Ez|</div>
                    <div class="stat-value" id="maxEValue">0.00</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Source</div>
                    <div class="stat-value" id="sourceType">Point</div>
                </div>
            </div>

            <div class="control-group">
                <label>Source Type</label>
                <select id="sourceSelect">
                    <option value="point">Point Source</option>
                    <option value="line">Line Source</option>
                    <option value="gaussian">Gaussian Pulse</option>
                </select>
            </div>

            <div class="control-group">
                <label>Frequency (relative)</label>
                <input type="range" id="freqSlider" min="0.5" max="3" step="0.1" value="1">
                <div class="value-display" id="freqDisplay">1.0</div>
            </div>

            <div class="control-group">
                <label>Draw Material</label>
                <div class="material-buttons">
                    <button class="material-btn vacuum active" data-material="vacuum">Vacuum</button>
                    <button class="material-btn dielectric" data-material="dielectric">Dielectric</button>
                    <button class="material-btn conductor" data-material="conductor">Conductor</button>
                    <button class="material-btn pml" data-material="pml">Absorber</button>
                </div>
            </div>

            <div class="control-group">
                <label>Brush Size</label>
                <input type="range" id="brushSlider" min="3" max="20" step="1" value="8">
                <div class="value-display" id="brushDisplay">8</div>
            </div>

            <div class="button-row">
                <button id="startBtn">Start</button>
                <button id="resetBtn" class="secondary">Reset</button>
            </div>

            <div class="button-row">
                <button id="slitBtn" class="secondary">Double Slit</button>
                <button id="lensBtn" class="secondary">Lens</button>
            </div>

            <div class="info-box">
                <h3>Yee Algorithm</h3>
                <p>
                    The FDTD method discretizes Maxwell's equations on a staggered grid.
                    E and H fields are updated alternately in a leapfrog scheme.
                </p>
            </div>

            <div class="info-box">
                <h3>Click to Add Sources</h3>
                <p>
                    Click on the canvas to place wave sources. Draw materials by clicking
                    and dragging after selecting a material type.
                </p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Grid parameters
        let NX = 200;
        let NY = 150;
        let cellSize = 4;

        // Fields
        let Ez, Hx, Hy;
        let eps, sigma; // Permittivity and conductivity

        // Simulation state
        let running = false;
        let step = 0;
        let freq = 1;
        let sourceType = 'point';
        let sources = [];

        // Material drawing
        let currentMaterial = 'vacuum';
        let brushSize = 8;
        let isDrawing = false;

        // Constants
        const c = 1; // Speed of light (normalized)
        const dt = 0.5; // Time step
        const dx = 1; // Spatial step

        function initFields() {
            Ez = new Float32Array(NX * NY);
            Hx = new Float32Array(NX * NY);
            Hy = new Float32Array(NX * NY);
            eps = new Float32Array(NX * NY).fill(1);
            sigma = new Float32Array(NX * NY).fill(0);

            // Add absorbing boundaries (simple)
            for (let i = 0; i < NX; i++) {
                for (let j = 0; j < 10; j++) {
                    const idx1 = i + j * NX;
                    const idx2 = i + (NY - 1 - j) * NX;
                    sigma[idx1] = 0.1 * (10 - j) / 10;
                    sigma[idx2] = 0.1 * (10 - j) / 10;
                }
            }
            for (let j = 0; j < NY; j++) {
                for (let i = 0; i < 10; i++) {
                    const idx1 = i + j * NX;
                    const idx2 = (NX - 1 - i) + j * NX;
                    sigma[idx1] = Math.max(sigma[idx1], 0.1 * (10 - i) / 10);
                    sigma[idx2] = Math.max(sigma[idx2], 0.1 * (10 - i) / 10);
                }
            }
        }

        function addSource(x, y) {
            sources.push({ x: Math.floor(x), y: Math.floor(y), phase: Math.random() * Math.PI * 2 });
        }

        function updateFields() {
            const S = c * dt / dx;

            // Update H fields
            for (let j = 0; j < NY - 1; j++) {
                for (let i = 0; i < NX - 1; i++) {
                    const idx = i + j * NX;
                    Hx[idx] -= S * (Ez[idx + NX] - Ez[idx]);
                    Hy[idx] += S * (Ez[idx + 1] - Ez[idx]);
                }
            }

            // Update E field
            for (let j = 1; j < NY - 1; j++) {
                for (let i = 1; i < NX - 1; i++) {
                    const idx = i + j * NX;
                    const epsVal = eps[idx];
                    const sigmaVal = sigma[idx];

                    // Lossy update
                    const ca = (1 - sigmaVal * dt / 2) / (1 + sigmaVal * dt / 2);
                    const cb = (S / epsVal) / (1 + sigmaVal * dt / 2);

                    Ez[idx] = ca * Ez[idx] + cb * (
                        (Hy[idx] - Hy[idx - 1]) - (Hx[idx] - Hx[idx - NX])
                    );
                }
            }

            // Apply sources
            const omega = 2 * Math.PI * freq * 0.1;
            for (const src of sources) {
                if (src.x >= 0 && src.x < NX && src.y >= 0 && src.y < NY) {
                    const idx = src.x + src.y * NX;

                    let value;
                    if (sourceType === 'gaussian') {
                        const t0 = 30;
                        const spread = 10;
                        value = Math.exp(-((step - t0) ** 2) / (2 * spread ** 2)) * Math.sin(omega * step + src.phase);
                    } else {
                        value = Math.sin(omega * step + src.phase);
                    }

                    if (sourceType === 'line') {
                        for (let dy = -5; dy <= 5; dy++) {
                            const idx2 = src.x + (src.y + dy) * NX;
                            if (idx2 >= 0 && idx2 < NX * NY) {
                                Ez[idx2] += value * 0.5;
                            }
                        }
                    } else {
                        Ez[idx] += value;
                    }
                }
            }

            step++;
        }

        function resizeCanvas() {
            const wrapper = canvas.parentElement;
            const rect = wrapper.getBoundingClientRect();
            canvas.width = rect.width - 30;
            canvas.height = rect.height - 50;

            NX = Math.floor(canvas.width / cellSize);
            NY = Math.floor(canvas.height / cellSize);
            document.getElementById('gridValue').textContent = `${NX}×${NY}`;

            initFields();
            sources = [];
            addSource(Math.floor(NX / 4), Math.floor(NY / 2));
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const imageData = ctx.createImageData(NX, NY);
            const data = imageData.data;

            let maxE = 0;

            for (let j = 0; j < NY; j++) {
                for (let i = 0; i < NX; i++) {
                    const idx = i + j * NX;
                    const e = Ez[idx];
                    maxE = Math.max(maxE, Math.abs(e));

                    const pidx = (i + j * NX) * 4;

                    // Material visualization
                    if (sigma[idx] > 0.05) {
                        // Conductor or absorber
                        data[pidx] = 50;
                        data[pidx + 1] = 50;
                        data[pidx + 2] = 50;
                        data[pidx + 3] = 255;
                    } else if (eps[idx] > 1.5) {
                        // Dielectric
                        const bg = 40;
                        data[pidx] = bg + e * 50;
                        data[pidx + 1] = bg + 80;
                        data[pidx + 2] = bg + 150 + e * 50;
                        data[pidx + 3] = 255;
                    } else {
                        // Field visualization
                        if (e > 0) {
                            data[pidx] = Math.min(255, e * 255);
                            data[pidx + 1] = Math.min(255, e * 100);
                            data[pidx + 2] = 0;
                        } else {
                            data[pidx] = 0;
                            data[pidx + 1] = Math.min(255, -e * 100);
                            data[pidx + 2] = Math.min(255, -e * 255);
                        }
                        data[pidx + 3] = 255;
                    }
                }
            }

            // Scale to canvas
            ctx.putImageData(imageData, 0, 0);
            ctx.drawImage(canvas, 0, 0, NX, NY, 0, 0, canvas.width, canvas.height);

            // Draw source markers
            ctx.fillStyle = '#22c55e';
            for (const src of sources) {
                ctx.beginPath();
                ctx.arc(src.x * cellSize, src.y * cellSize, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            document.getElementById('stepValue').textContent = step;
            document.getElementById('maxEValue').textContent = maxE.toFixed(2);
        }

        function setMaterial(x, y, material) {
            const gridX = Math.floor(x / cellSize);
            const gridY = Math.floor(y / cellSize);

            for (let dy = -brushSize; dy <= brushSize; dy++) {
                for (let dx = -brushSize; dx <= brushSize; dx++) {
                    if (dx * dx + dy * dy <= brushSize * brushSize) {
                        const gx = gridX + dx;
                        const gy = gridY + dy;
                        if (gx >= 10 && gx < NX - 10 && gy >= 10 && gy < NY - 10) {
                            const idx = gx + gy * NX;
                            switch (material) {
                                case 'vacuum':
                                    eps[idx] = 1;
                                    sigma[idx] = 0;
                                    break;
                                case 'dielectric':
                                    eps[idx] = 4;
                                    sigma[idx] = 0;
                                    break;
                                case 'conductor':
                                    eps[idx] = 1;
                                    sigma[idx] = 1;
                                    break;
                                case 'pml':
                                    eps[idx] = 1;
                                    sigma[idx] = 0.2;
                                    break;
                            }
                        }
                    }
                }
            }
        }

        function createDoubleSlit() {
            const wallX = Math.floor(NX * 0.5);
            const slitY1 = Math.floor(NY * 0.35);
            const slitY2 = Math.floor(NY * 0.65);
            const slitWidth = 8;
            const wallThick = 5;

            for (let i = wallX - wallThick; i <= wallX + wallThick; i++) {
                for (let j = 15; j < NY - 15; j++) {
                    const idx = i + j * NX;
                    const inSlit1 = Math.abs(j - slitY1) < slitWidth;
                    const inSlit2 = Math.abs(j - slitY2) < slitWidth;
                    if (!inSlit1 && !inSlit2) {
                        sigma[idx] = 1;
                    }
                }
            }

            sources = [{ x: Math.floor(NX * 0.2), y: Math.floor(NY / 2), phase: 0 }];
        }

        function createLens() {
            const cx = Math.floor(NX * 0.5);
            const cy = Math.floor(NY * 0.5);
            const radius = 40;

            for (let j = 0; j < NY; j++) {
                for (let i = 0; i < NX; i++) {
                    const dx = i - cx;
                    const dy = j - cy;
                    if (dx * dx + dy * dy < radius * radius) {
                        const idx = i + j * NX;
                        eps[idx] = 2.5;
                    }
                }
            }

            sources = [{ x: Math.floor(NX * 0.15), y: Math.floor(NY / 2), phase: 0 }];
        }

        // Animation loop
        function animate() {
            if (running) {
                for (let i = 0; i < 3; i++) {
                    updateFields();
                }
            }
            draw();
            requestAnimationFrame(animate);
        }

        // Event handlers
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / cellSize;
            const y = (e.clientY - rect.top) / cellSize;

            if (currentMaterial === 'vacuum' && !isDrawing) {
                addSource(x, y);
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            setMaterial(e.clientX - rect.left, e.clientY - rect.top, currentMaterial);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing && currentMaterial !== 'vacuum') {
                const rect = canvas.getBoundingClientRect();
                setMaterial(e.clientX - rect.left, e.clientY - rect.top, currentMaterial);
            }
        });

        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseleave', () => isDrawing = false);

        document.querySelectorAll('.material-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.material-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMaterial = btn.dataset.material;
            });
        });

        document.getElementById('sourceSelect').addEventListener('change', (e) => {
            sourceType = e.target.value;
            document.getElementById('sourceType').textContent =
                sourceType.charAt(0).toUpperCase() + sourceType.slice(1);
        });

        document.getElementById('freqSlider').addEventListener('input', (e) => {
            freq = parseFloat(e.target.value);
            document.getElementById('freqDisplay').textContent = freq.toFixed(1);
        });

        document.getElementById('brushSlider').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushDisplay').textContent = brushSize;
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            initFields();
            sources = [];
            addSource(Math.floor(NX / 4), Math.floor(NY / 2));
            step = 0;
        });

        document.getElementById('slitBtn').addEventListener('click', () => {
            initFields();
            createDoubleSlit();
            step = 0;
        });

        document.getElementById('lensBtn').addEventListener('click', () => {
            initFields();
            createLens();
            step = 0;
        });

        // Initialize
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        animate();
    </script>
</body>
</html>
