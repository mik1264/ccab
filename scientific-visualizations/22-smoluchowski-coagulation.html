<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smoluchowski Coagulation - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0;
        }

        h1 {
            font-size: 2.2rem;
            background: linear-gradient(135deg, #06b6d4, #3b82f6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #888;
            font-size: 1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-top: 20px;
        }

        .canvas-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(6, 182, 212, 0.3);
        }

        .canvas-container h3 {
            color: #06b6d4;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        canvas {
            display: block;
            background: #0a0a1a;
            border-radius: 10px;
        }

        #particleCanvas {
            width: 100%;
            height: 280px;
        }

        #distributionCanvas {
            width: 100%;
            height: 200px;
        }

        #massCanvas {
            width: 100%;
            height: 150px;
        }

        .controls {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(6, 182, 212, 0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group h3 {
            color: #06b6d4;
            font-size: 0.85rem;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        label {
            display: block;
            margin: 10px 0 5px;
            color: #aaa;
            font-size: 0.8rem;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #06b6d4;
            cursor: pointer;
        }

        button {
            width: 100%;
            padding: 10px 15px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #06b6d4, #0891b2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(6, 182, 212, 0.4);
        }

        .btn-secondary {
            background: rgba(6, 182, 212, 0.2);
            color: #06b6d4;
            border: 1px solid rgba(6, 182, 212, 0.5);
        }

        .btn-secondary:hover {
            background: rgba(6, 182, 212, 0.3);
        }

        select {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(6, 182, 212, 0.5);
            color: #e0e0e0;
            font-size: 0.85rem;
        }

        .stats {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            font-size: 0.8rem;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            font-family: monospace;
            color: #22d3ee;
        }

        .stat-value.warning {
            color: #f97316;
        }

        .info-box {
            background: rgba(6, 182, 212, 0.1);
            border: 1px solid rgba(6, 182, 212, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            font-size: 0.75rem;
            line-height: 1.5;
            color: #ccc;
        }

        .info-box strong {
            color: #06b6d4;
        }

        .kernel-eq {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 8px;
            margin: 5px 0;
            font-family: 'Times New Roman', serif;
            font-size: 0.85rem;
            text-align: center;
            color: #22d3ee;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #06b6d4;
            text-decoration: none;
            font-weight: 600;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            border: 1px solid rgba(6, 182, 212, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .back-link:hover {
            background: rgba(6, 182, 212, 0.2);
            transform: translateX(-5px);
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <div class="container">
        <header>
            <h1>Smoluchowski Coagulation</h1>
            <p class="subtitle">Cluster Aggregation and the Gelation Transition</p>
        </header>

        <div class="main-content">
            <div class="canvas-section">
                <div class="canvas-container">
                    <h3>Particle Clusters (Monte Carlo)</h3>
                    <canvas id="particleCanvas"></canvas>
                </div>

                <div class="canvas-container">
                    <h3>Cluster Size Distribution c(k, t)</h3>
                    <canvas id="distributionCanvas"></canvas>
                </div>

                <div class="canvas-container">
                    <h3>Total Mass & Gelation</h3>
                    <canvas id="massCanvas"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <h3>Simulation</h3>
                    <button class="btn-primary" onclick="toggleSimulation()">
                        <span id="playBtn">▶ Start</span>
                    </button>
                    <button class="btn-secondary" onclick="stepOnce()">Single Step</button>
                    <button class="btn-secondary" onclick="resetSimulation()">Reset</button>
                </div>

                <div class="control-group">
                    <h3>Coagulation Kernel</h3>
                    <select id="kernelSelect" onchange="resetSimulation()">
                        <option value="constant">Constant: K(i,j) = 1</option>
                        <option value="sum">Sum: K(i,j) = i + j</option>
                        <option value="product" selected>Product: K(i,j) = i·j (gelation!)</option>
                        <option value="ballistic">Ballistic: K(i,j) = (i^⅓ + j^⅓)²</option>
                    </select>
                    <div class="kernel-eq" id="kernelEq">K(i,j) = i·j</div>
                </div>

                <div class="control-group">
                    <h3>Parameters</h3>

                    <label>Initial Particles: <span id="nValue">500</span></label>
                    <input type="range" id="nSlider" min="100" max="1000" value="500" step="50" oninput="updateN()">

                    <label>Simulation Speed: <span id="speedValue">10</span></label>
                    <input type="range" id="speedSlider" min="1" max="50" value="10" step="1" oninput="updateSpeed()">
                </div>

                <div class="stats">
                    <div class="stat-row">
                        <span class="stat-label">Time:</span>
                        <span class="stat-value" id="timeStat">0.000</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Clusters:</span>
                        <span class="stat-value" id="clusterStat">500</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Largest Cluster:</span>
                        <span class="stat-value" id="maxStat">1</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Total Mass:</span>
                        <span class="stat-value" id="massStat">500</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Gelation:</span>
                        <span class="stat-value" id="gelStat">No</span>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Gelation:</strong> With superlinear kernels like K(i,j) = i·j,
                    a "gel" (infinite cluster) forms in finite time — mass suddenly
                    disappears from the finite clusters!
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const particleCanvas = document.getElementById('particleCanvas');
        const particleCtx = particleCanvas.getContext('2d');
        const distributionCanvas = document.getElementById('distributionCanvas');
        const distributionCtx = distributionCanvas.getContext('2d');
        const massCanvas = document.getElementById('massCanvas');
        const massCtx = massCanvas.getContext('2d');

        function resizeCanvases() {
            [particleCanvas, distributionCanvas, massCanvas].forEach(canvas => {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                canvas.getContext('2d').scale(window.devicePixelRatio, window.devicePixelRatio);
            });
        }

        resizeCanvases();

        // State
        let N0 = 500;  // Initial number of particles
        let clusters = [];  // Array of cluster sizes
        let time = 0;
        let running = false;
        let animationId = null;
        let speed = 10;
        let massHistory = [];
        let clusterHistory = [];

        let kernelType = 'product';
        const gelationThreshold = 0.2;  // Fraction of mass in one cluster

        // Kernel functions
        const kernels = {
            constant: (i, j) => 1,
            sum: (i, j) => i + j,
            product: (i, j) => i * j,
            ballistic: (i, j) => Math.pow(Math.pow(i, 1/3) + Math.pow(j, 1/3), 2)
        };

        const kernelEqs = {
            constant: 'K(i,j) = 1',
            sum: 'K(i,j) = i + j',
            product: 'K(i,j) = i·j',
            ballistic: 'K(i,j) = (i^⅓ + j^⅓)²'
        };

        // Initialize simulation
        function initializeClusters() {
            clusters = [];
            for (let i = 0; i < N0; i++) {
                clusters.push({
                    size: 1,
                    x: Math.random(),
                    y: Math.random(),
                    vx: (Math.random() - 0.5) * 0.01,
                    vy: (Math.random() - 0.5) * 0.01
                });
            }
            time = 0;
            massHistory = [N0];
            clusterHistory = [N0];
        }

        // Perform one coagulation event
        function coagulationStep() {
            if (clusters.length < 2) return;

            // Compute total rate
            const kernel = kernels[kernelType];
            let totalRate = 0;
            const pairRates = [];

            // For efficiency, sample a subset of pairs
            const maxPairs = Math.min(clusters.length * (clusters.length - 1) / 2, 1000);

            for (let i = 0; i < clusters.length; i++) {
                for (let j = i + 1; j < clusters.length; j++) {
                    const rate = kernel(clusters[i].size, clusters[j].size);
                    totalRate += rate;
                    pairRates.push({ i, j, rate });
                }
            }

            if (totalRate === 0) return;

            // Time increment (Gillespie algorithm)
            const dt = -Math.log(Math.random()) / totalRate;
            time += dt;

            // Select pair to coagulate
            let r = Math.random() * totalRate;
            let selectedPair = null;

            for (const pair of pairRates) {
                r -= pair.rate;
                if (r <= 0) {
                    selectedPair = pair;
                    break;
                }
            }

            if (!selectedPair) {
                selectedPair = pairRates[pairRates.length - 1];
            }

            const i = selectedPair.i;
            const j = selectedPair.j;

            // Merge clusters
            const newSize = clusters[i].size + clusters[j].size;
            const newX = (clusters[i].x * clusters[i].size + clusters[j].x * clusters[j].size) / newSize;
            const newY = (clusters[i].y * clusters[i].size + clusters[j].y * clusters[j].size) / newSize;

            clusters[i] = {
                size: newSize,
                x: newX,
                y: newY,
                vx: clusters[i].vx * 0.5 + clusters[j].vx * 0.5,
                vy: clusters[i].vy * 0.5 + clusters[j].vy * 0.5
            };

            // Remove the merged cluster
            clusters.splice(j, 1);

            // Record history
            const totalMass = clusters.reduce((s, c) => s + c.size, 0);
            massHistory.push(totalMass);
            clusterHistory.push(clusters.length);

            // Limit history
            if (massHistory.length > 500) {
                massHistory.shift();
                clusterHistory.shift();
            }
        }

        // Update particle positions (for visualization)
        function updatePositions() {
            for (const cluster of clusters) {
                cluster.x += cluster.vx;
                cluster.y += cluster.vy;

                // Bounce off walls
                if (cluster.x < 0 || cluster.x > 1) cluster.vx *= -1;
                if (cluster.y < 0 || cluster.y > 1) cluster.vy *= -1;

                cluster.x = Math.max(0, Math.min(1, cluster.x));
                cluster.y = Math.max(0, Math.min(1, cluster.y));
            }
        }

        // Compute size distribution
        function getDistribution() {
            const dist = {};
            for (const cluster of clusters) {
                dist[cluster.size] = (dist[cluster.size] || 0) + 1;
            }
            return dist;
        }

        // Check for gelation
        function checkGelation() {
            if (clusters.length === 0) return false;
            const maxSize = Math.max(...clusters.map(c => c.size));
            const totalMass = clusters.reduce((s, c) => s + c.size, 0);
            return maxSize > totalMass * gelationThreshold;
        }

        // Draw particles
        function drawParticles() {
            const rect = particleCanvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;

            particleCtx.fillStyle = '#0a0a1a';
            particleCtx.fillRect(0, 0, w, h);

            // Draw clusters
            for (const cluster of clusters) {
                const radius = Math.sqrt(cluster.size) * 3;
                const x = cluster.x * w;
                const y = cluster.y * h;

                // Color by size
                const hue = 180 + (cluster.size / 50) * 60;
                const saturation = 70;
                const lightness = 50 + Math.min(cluster.size, 20);

                particleCtx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                particleCtx.beginPath();
                particleCtx.arc(x, y, Math.max(2, radius), 0, Math.PI * 2);
                particleCtx.fill();

                // Highlight large clusters
                if (cluster.size > 10) {
                    particleCtx.strokeStyle = `hsla(${hue}, 80%, 70%, 0.5)`;
                    particleCtx.lineWidth = 2;
                    particleCtx.beginPath();
                    particleCtx.arc(x, y, Math.max(2, radius) + 3, 0, Math.PI * 2);
                    particleCtx.stroke();
                }
            }

            // Time display
            particleCtx.fillStyle = '#666';
            particleCtx.font = '11px sans-serif';
            particleCtx.textAlign = 'left';
            particleCtx.fillText(`t = ${time.toFixed(3)}`, 10, 20);
            particleCtx.fillText(`${clusters.length} clusters`, 10, 35);
        }

        // Draw distribution
        function drawDistribution() {
            const rect = distributionCanvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;
            const padding = { top: 20, bottom: 30, left: 50, right: 20 };

            distributionCtx.fillStyle = '#0a0a1a';
            distributionCtx.fillRect(0, 0, w, h);

            const dist = getDistribution();
            const sizes = Object.keys(dist).map(Number).sort((a, b) => a - b);

            if (sizes.length === 0) return;

            const maxSize = Math.max(...sizes);
            const maxCount = Math.max(...Object.values(dist));

            // Draw axes
            distributionCtx.strokeStyle = '#444';
            distributionCtx.lineWidth = 1;
            distributionCtx.beginPath();
            distributionCtx.moveTo(padding.left, padding.top);
            distributionCtx.lineTo(padding.left, h - padding.bottom);
            distributionCtx.lineTo(w - padding.right, h - padding.bottom);
            distributionCtx.stroke();

            // Draw bars (log-linear scale for size)
            const plotW = w - padding.left - padding.right;
            const plotH = h - padding.top - padding.bottom;

            for (const size of sizes) {
                const count = dist[size];
                const x = padding.left + (Math.log(size + 1) / Math.log(maxSize + 2)) * plotW;
                const barH = (count / maxCount) * plotH;
                const barW = Math.max(2, plotW / (maxSize + 1) * 0.8);

                const hue = 180 + (size / 50) * 60;
                distributionCtx.fillStyle = `hsl(${hue}, 70%, 55%)`;
                distributionCtx.fillRect(x - barW / 2, h - padding.bottom - barH, barW, barH);
            }

            // Labels
            distributionCtx.fillStyle = '#888';
            distributionCtx.font = '10px sans-serif';
            distributionCtx.textAlign = 'center';
            distributionCtx.fillText('Cluster size k (log scale)', w / 2, h - 5);

            distributionCtx.save();
            distributionCtx.translate(12, h / 2);
            distributionCtx.rotate(-Math.PI / 2);
            distributionCtx.fillText('Count', 0, 0);
            distributionCtx.restore();
        }

        // Draw mass evolution
        function drawMass() {
            const rect = massCanvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;
            const padding = { top: 15, bottom: 25, left: 50, right: 20 };

            massCtx.fillStyle = '#0a0a1a';
            massCtx.fillRect(0, 0, w, h);

            if (massHistory.length < 2) {
                massCtx.fillStyle = '#666';
                massCtx.font = '12px sans-serif';
                massCtx.textAlign = 'center';
                massCtx.fillText('Run simulation to see mass evolution', w / 2, h / 2);
                return;
            }

            // Draw axes
            massCtx.strokeStyle = '#444';
            massCtx.lineWidth = 1;
            massCtx.beginPath();
            massCtx.moveTo(padding.left, padding.top);
            massCtx.lineTo(padding.left, h - padding.bottom);
            massCtx.lineTo(w - padding.right, h - padding.bottom);
            massCtx.stroke();

            // Reference line at initial mass
            const plotH = h - padding.top - padding.bottom;
            const plotW = w - padding.left - padding.right;

            massCtx.strokeStyle = '#666';
            massCtx.setLineDash([5, 5]);
            massCtx.beginPath();
            massCtx.moveTo(padding.left, padding.top);
            massCtx.lineTo(w - padding.right, padding.top);
            massCtx.stroke();
            massCtx.setLineDash([]);

            // Draw mass curve
            const maxMass = Math.max(...massHistory);

            massCtx.strokeStyle = '#06b6d4';
            massCtx.lineWidth = 2;
            massCtx.beginPath();

            for (let i = 0; i < massHistory.length; i++) {
                const x = padding.left + (i / (massHistory.length - 1)) * plotW;
                const y = h - padding.bottom - (massHistory[i] / maxMass) * plotH;

                if (i === 0) massCtx.moveTo(x, y);
                else massCtx.lineTo(x, y);
            }
            massCtx.stroke();

            // Gelation indicator
            if (checkGelation()) {
                massCtx.fillStyle = '#f97316';
                massCtx.font = 'bold 12px sans-serif';
                massCtx.textAlign = 'right';
                massCtx.fillText('GELATION!', w - padding.right, padding.top + 15);
            }

            // Labels
            massCtx.fillStyle = '#888';
            massCtx.font = '10px sans-serif';
            massCtx.textAlign = 'center';
            massCtx.fillText('Events', w / 2, h - 3);

            massCtx.textAlign = 'right';
            massCtx.fillText('M₀', padding.left - 5, padding.top + 4);
        }

        // Update stats
        function updateStats() {
            const totalMass = clusters.reduce((s, c) => s + c.size, 0);
            const maxSize = clusters.length > 0 ? Math.max(...clusters.map(c => c.size)) : 0;

            document.getElementById('timeStat').textContent = time.toFixed(3);
            document.getElementById('clusterStat').textContent = clusters.length;
            document.getElementById('maxStat').textContent = maxSize;
            document.getElementById('massStat').textContent = totalMass;

            const gelStat = document.getElementById('gelStat');
            if (checkGelation()) {
                gelStat.textContent = 'YES!';
                gelStat.className = 'stat-value warning';
            } else {
                gelStat.textContent = 'No';
                gelStat.className = 'stat-value';
            }
        }

        // Animation loop
        function animate() {
            if (!running) return;

            for (let i = 0; i < speed; i++) {
                if (clusters.length >= 2) {
                    coagulationStep();
                }
            }

            updatePositions();
            drawParticles();
            drawDistribution();
            drawMass();
            updateStats();

            animationId = requestAnimationFrame(animate);
        }

        // Controls
        function toggleSimulation() {
            running = !running;
            document.getElementById('playBtn').textContent = running ? '⏸ Pause' : '▶ Start';

            if (running) {
                animate();
            } else if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }

        function stepOnce() {
            if (clusters.length >= 2) {
                coagulationStep();
            }
            updatePositions();
            drawParticles();
            drawDistribution();
            drawMass();
            updateStats();
        }

        function resetSimulation() {
            running = false;
            document.getElementById('playBtn').textContent = '▶ Start';
            if (animationId) cancelAnimationFrame(animationId);

            kernelType = document.getElementById('kernelSelect').value;
            document.getElementById('kernelEq').textContent = kernelEqs[kernelType];

            initializeClusters();
            drawParticles();
            drawDistribution();
            drawMass();
            updateStats();
        }

        function updateN() {
            N0 = parseInt(document.getElementById('nSlider').value);
            document.getElementById('nValue').textContent = N0;
        }

        function updateSpeed() {
            speed = parseInt(document.getElementById('speedSlider').value);
            document.getElementById('speedValue').textContent = speed;
        }

        // Initialize
        window.addEventListener('resize', () => {
            resizeCanvases();
            drawParticles();
            drawDistribution();
            drawMass();
        });

        resetSimulation();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
