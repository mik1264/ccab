<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Viscous Fingering (Saffman-Taylor)</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: sans-serif; }
canvas { display: block; }
.title-overlay {
    position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
    color: #fbbf24; font-size: 20px; font-weight: bold; z-index: 999;
    text-shadow: 0 0 10px rgba(0,0,0,0.8); pointer-events: none;
}
.controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 20px; align-items: center; z-index: 999;
    background: rgba(0,0,0,0.7); padding: 12px 20px; border-radius: 10px;
    flex-wrap: wrap; justify-content: center;
}
.controls label { color: #ccc; font-size: 13px; }
.controls input[type=range] { width: 100px; cursor: pointer; }
.controls span { color: #fbbf24; font-size: 13px; min-width: 30px; }
.controls button {
    padding: 6px 14px; background: #fbbf24; color: #0a0e1a; border: none;
    border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: bold;
}
.info {
    position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
    color: rgba(255,255,255,0.5); font-size: 12px; z-index: 999;
    pointer-events: none; text-align: center;
}
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">‚Üê Back to Gallery</a>
<div class="title-overlay">Viscous Fingering (Saffman-Taylor)</div>
<div class="info">Less viscous fluid (bright) displaces more viscous fluid (dark), creating branching fingers</div>
<div class="controls">
    <label>Injection Rate</label>
    <input type="range" id="rateSlider" min="1" max="20" value="8" step="1">
    <span id="rateVal">8</span>
    <label>Noise</label>
    <input type="range" id="noiseSlider" min="1" max="20" value="10" step="1">
    <span id="noiseVal">10</span>
    <label>Viscosity Ratio</label>
    <input type="range" id="viscSlider" min="2" max="20" value="10" step="1">
    <span id="viscVal">10</span>
    <button id="resetBtn">Restart</button>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const SCALE = 2;
let W, H, NX, NY;
let grid, pressure, newGrid;
let running = true;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    NX = Math.floor(W / SCALE);
    NY = Math.floor(H / SCALE);
    init();
}

function init() {
    const N = NX * NY;
    grid = new Float32Array(N); // 0 = viscous, 1 = invading
    pressure = new Float32Array(N);
    newGrid = new Float32Array(N);

    // Start with small seed in center
    const cx = Math.floor(NX / 2);
    const cy = Math.floor(NY / 2);
    const seedR = 5;
    for (let y = cy - seedR; y <= cy + seedR; y++) {
        for (let x = cx - seedR; x <= cx + seedR; x++) {
            if (x >= 0 && x < NX && y >= 0 && y < NY) {
                const dx = x - cx, dy = y - cy;
                if (dx * dx + dy * dy < seedR * seedR) {
                    grid[y * NX + x] = 1.0;
                }
            }
        }
    }
}

function step() {
    const rate = parseInt(document.getElementById('rateSlider').value) * 0.02;
    const noise = parseInt(document.getElementById('noiseSlider').value) * 0.05;
    const viscRatio = parseInt(document.getElementById('viscSlider').value) * 0.1;
    const cx = Math.floor(NX / 2);
    const cy = Math.floor(NY / 2);

    // Solve pressure (simplified Laplace iteration)
    for (let iter = 0; iter < 5; iter++) {
        for (let y = 1; y < NY - 1; y++) {
            for (let x = 1; x < NX - 1; x++) {
                const n = y * NX + x;
                if (grid[n] > 0.5) {
                    pressure[n] = 1.0; // Invaded region has high pressure
                } else {
                    pressure[n] = 0.25 * (
                        pressure[n - 1] + pressure[n + 1] +
                        pressure[n - NX] + pressure[n + NX]
                    );
                }
            }
        }
    }

    // Injection source
    const seedR = 8;
    for (let y = cy - seedR; y <= cy + seedR; y++) {
        for (let x = cx - seedR; x <= cx + seedR; x++) {
            if (x >= 0 && x < NX && y >= 0 && y < NY) {
                const dx = x - cx, dy = y - cy;
                if (dx * dx + dy * dy < seedR * seedR) {
                    grid[y * NX + x] = 1.0;
                }
            }
        }
    }

    // Growth at interface
    newGrid.set(grid);
    for (let y = 1; y < NY - 1; y++) {
        for (let x = 1; x < NX - 1; x++) {
            const n = y * NX + x;
            if (grid[n] < 0.5) {
                // Check if adjacent to invaded region
                const neighbors = [
                    grid[n - 1], grid[n + 1],
                    grid[n - NX], grid[n + NX]
                ];
                const maxNeighbor = Math.max(...neighbors);

                if (maxNeighbor > 0.5) {
                    // Interface cell - growth probability
                    const pGrad = pressure[n]; // Pressure at this cell
                    const dx = x - cx, dy = y - cy;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Growth rate depends on pressure gradient and noise
                    const growthProb = rate * pGrad / (1 + dist * 0.01);
                    const randomFactor = 1 + noise * (Math.random() - 0.3);

                    // Viscosity ratio affects instability
                    const mobilityRatio = viscRatio;

                    if (Math.random() < growthProb * randomFactor * mobilityRatio * 0.1) {
                        newGrid[n] = 1.0;
                    }
                }
            }
        }
    }

    grid = newGrid.slice();
}

// DLA-style growth for more fractal patterns
function dlaStep() {
    const rate = parseInt(document.getElementById('rateSlider').value);
    const noise = parseInt(document.getElementById('noiseSlider').value) * 0.05;
    const viscRatio = parseInt(document.getElementById('viscSlider').value) * 0.1;
    const cx = Math.floor(NX / 2);
    const cy = Math.floor(NY / 2);

    const numWalkers = rate * 5;

    for (let w = 0; w < numWalkers; w++) {
        // Launch walker from random position on a circle
        const maxR = Math.min(NX, NY) * 0.45;
        let angle = Math.random() * Math.PI * 2;

        // Find the current extent
        let extent = 0;
        for (let y = 0; y < NY; y++) {
            for (let x = 0; x < NX; x++) {
                if (grid[y * NX + x] > 0.5) {
                    const dx = x - cx, dy = y - cy;
                    extent = Math.max(extent, Math.sqrt(dx * dx + dy * dy));
                }
            }
        }

        const launchR = Math.min(maxR, extent + 30);
        let wx = cx + Math.cos(angle) * launchR;
        let wy = cy + Math.sin(angle) * launchR;

        // Random walk toward center with bias
        for (let s = 0; s < 500; s++) {
            // Bias toward center
            const dx = cx - wx;
            const dy = cy - wy;
            const dist = Math.sqrt(dx * dx + dy * dy);

            const bias = 0.3 + viscRatio * 0.05;
            wx += (Math.random() - 0.5 + noise * (Math.random() - 0.5)) * 2 + dx / dist * bias;
            wy += (Math.random() - 0.5 + noise * (Math.random() - 0.5)) * 2 + dy / dist * bias;

            const ix = Math.round(wx);
            const iy = Math.round(wy);

            if (ix < 1 || ix >= NX - 1 || iy < 1 || iy >= NY - 1) break;

            const n = iy * NX + ix;
            if (grid[n] < 0.5) {
                // Check if adjacent to invaded
                if (grid[n-1] > 0.5 || grid[n+1] > 0.5 ||
                    grid[n-NX] > 0.5 || grid[n+NX] > 0.5) {
                    grid[n] = 1.0;
                    break;
                }
            }
        }
    }
}

let imageData;
function render() {
    if (!imageData || imageData.width !== NX || imageData.height !== NY) {
        imageData = ctx.createImageData(NX, NY);
    }
    const data = imageData.data;
    const cx = Math.floor(NX / 2);
    const cy = Math.floor(NY / 2);

    for (let y = 0; y < NY; y++) {
        for (let x = 0; x < NX; x++) {
            const n = y * NX + x;
            const p = n * 4;
            const val = grid[n];

            if (val > 0.5) {
                // Invading fluid - bright color based on distance from center
                const dx = x - cx, dy = y - cy;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const t = Math.min(1, dist / (Math.min(NX, NY) * 0.4));

                // Gradient from hot center to cool tips
                const r = 255 - t * 130;
                const g = 200 - t * 120 + Math.sin(dist * 0.1) * 30;
                const b = 80 + t * 120;

                data[p] = r;
                data[p+1] = g;
                data[p+2] = b;
            } else {
                // Viscous fluid - dark
                const dx = x - cx, dy = y - cy;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Check proximity to interface for glow effect
                let minDist = 100;
                for (let dy2 = -3; dy2 <= 3; dy2++) {
                    for (let dx2 = -3; dx2 <= 3; dx2++) {
                        const nx = x + dx2, ny = y + dy2;
                        if (nx >= 0 && nx < NX && ny >= 0 && ny < NY) {
                            if (grid[ny * NX + nx] > 0.5) {
                                minDist = Math.min(minDist, Math.sqrt(dx2*dx2 + dy2*dy2));
                            }
                        }
                    }
                }

                const glow = Math.max(0, 1 - minDist / 4);
                data[p] = 10 + glow * 60;
                data[p+1] = 14 + glow * 40;
                data[p+2] = 26 + glow * 80;
            }
            data[p+3] = 255;
        }
    }

    const off = document.createElement('canvas');
    off.width = NX; off.height = NY;
    off.getContext('2d').putImageData(imageData, 0, 0);
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(off, 0, 0, W, H);
}

document.getElementById('rateSlider').addEventListener('input', function() {
    document.getElementById('rateVal').textContent = this.value;
});
document.getElementById('noiseSlider').addEventListener('input', function() {
    document.getElementById('noiseVal').textContent = this.value;
});
document.getElementById('viscSlider').addEventListener('input', function() {
    document.getElementById('viscVal').textContent = this.value;
});
document.getElementById('resetBtn').addEventListener('click', init);

function animate() {
    dlaStep();
    render();
    requestAnimationFrame(animate);
}

window.addEventListener('resize', resize);
resize();
animate();
</script>
</body>
</html>
