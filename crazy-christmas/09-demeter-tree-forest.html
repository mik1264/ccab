<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demeter: Tree Forest | Crazy Christmas</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a1a10; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(196, 30, 58, 0.8);
            color: white;
            text-decoration: none;
            border-radius: 25px;
            font-weight: bold;
            z-index: 100;
            transition: all 0.3s ease;
        }
        .back-btn:hover { background: rgba(196, 30, 58, 1); transform: scale(1.05); }
        .title {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            text-align: center;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">‚Üê Back</a>
    <canvas id="canvas"></canvas>
    <div class="title">Demeter growing a forest of Christmas trees instantly</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        let time = 0;
        let growPhase = 0;

        // Modern vector colors
        const COLORS = {
            green: '#228B22',
            darkGreen: '#0d5c0d',
            brown: '#5d3a1a',
            gold: '#FFD700',
            magic: '#90EE90',
            earth: '#3d2a1a'
        };

        // Growing trees
        class GrowingTree {
            constructor(x, baseY, delay, maxHeight) {
                this.x = x;
                this.baseY = baseY;
                this.delay = delay;
                this.maxHeight = maxHeight;
                this.currentHeight = 0;
                this.growing = false;
                this.sparkles = [];
            }

            update(time) {
                if (time > this.delay && this.currentHeight < this.maxHeight) {
                    this.growing = true;
                    this.currentHeight = Math.min(this.maxHeight, (time - this.delay) * 80);

                    // Add sparkles while growing
                    if (Math.random() > 0.7) {
                        this.sparkles.push({
                            x: this.x + (Math.random() - 0.5) * 60,
                            y: this.baseY - this.currentHeight * Math.random(),
                            life: 1,
                            size: Math.random() * 4 + 2
                        });
                    }
                } else {
                    this.growing = false;
                }

                // Update sparkles
                this.sparkles = this.sparkles.filter(s => {
                    s.life -= 0.03;
                    s.y -= 1;
                    return s.life > 0;
                });
            }

            draw() {
                if (this.currentHeight <= 0) return;

                const h = this.currentHeight;
                const scale = h / this.maxHeight;

                ctx.save();
                ctx.translate(this.x, this.baseY);

                // Earth mound
                ctx.fillStyle = COLORS.earth;
                ctx.beginPath();
                ctx.ellipse(0, 5, 30 * scale, 10 * scale, 0, 0, Math.PI * 2);
                ctx.fill();

                // Trunk
                ctx.fillStyle = COLORS.brown;
                const trunkWidth = 15 * scale;
                ctx.fillRect(-trunkWidth/2, -h * 0.15, trunkWidth, h * 0.2);

                // Tree layers (growing from ground up)
                const layers = Math.floor(4 * scale);
                for (let i = 0; i <= layers; i++) {
                    const layerProgress = Math.min(1, (scale * 4 - i));
                    if (layerProgress <= 0) continue;

                    const layerY = -h * 0.1 - i * h * 0.2;
                    const layerWidth = (60 - i * 10) * layerProgress;
                    const layerHeight = h * 0.25 * layerProgress;

                    // Main layer
                    ctx.fillStyle = COLORS.green;
                    ctx.beginPath();
                    ctx.moveTo(0, layerY - layerHeight);
                    ctx.lineTo(-layerWidth, layerY);
                    ctx.lineTo(layerWidth, layerY);
                    ctx.closePath();
                    ctx.fill();

                    // Darker side
                    ctx.fillStyle = COLORS.darkGreen;
                    ctx.beginPath();
                    ctx.moveTo(0, layerY - layerHeight);
                    ctx.lineTo(layerWidth, layerY);
                    ctx.lineTo(0, layerY);
                    ctx.closePath();
                    ctx.fill();
                }

                // Star on top (when fully grown)
                if (scale > 0.9) {
                    ctx.fillStyle = COLORS.gold;
                    ctx.beginPath();
                    const starY = -h - 15;
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * Math.PI * 2 / 5) - Math.PI / 2;
                        const r = i % 2 === 0 ? 12 : 5;
                        const px = Math.cos(angle) * r;
                        const py = starY + Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                // Growing glow
                if (this.growing) {
                    ctx.beginPath();
                    ctx.ellipse(0, -h/2, 50, h * 0.6, 0, 0, Math.PI * 2);
                    const glowGradient = ctx.createRadialGradient(0, -h/2, 0, 0, -h/2, 60);
                    glowGradient.addColorStop(0, 'rgba(144, 238, 144, 0.5)');
                    glowGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = glowGradient;
                    ctx.fill();
                }

                ctx.restore();

                // Draw sparkles
                ctx.fillStyle = COLORS.magic;
                this.sparkles.forEach(s => {
                    ctx.globalAlpha = s.life;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
            }
        }

        // Create trees in waves
        const trees = [];
        for (let row = 0; row < 4; row++) {
            const y = canvas.height * 0.5 + row * 60;
            const count = 5 + row * 2;
            for (let i = 0; i < count; i++) {
                trees.push(new GrowingTree(
                    canvas.width * 0.1 + (i / (count - 1)) * canvas.width * 0.8,
                    y,
                    row * 0.5 + i * 0.1, // delay
                    80 + Math.random() * 40 // max height
                ));
            }
        }

        function drawDemeter(x, y, time) {
            ctx.save();
            ctx.translate(x, y);

            const armRaise = Math.sin(time * 2) * 0.3;
            const float = Math.sin(time * 1.5) * 5;
            ctx.translate(0, float);

            // Magical aura
            ctx.beginPath();
            ctx.arc(0, -40, 100, 0, Math.PI * 2);
            const auraGradient = ctx.createRadialGradient(0, -40, 0, 0, -40, 100);
            auraGradient.addColorStop(0, 'rgba(144, 238, 144, 0.5)');
            auraGradient.addColorStop(0.5, 'rgba(34, 139, 34, 0.3)');
            auraGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = auraGradient;
            ctx.fill();

            // Robe (earth tones with green)
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.moveTo(-40, -30);
            ctx.quadraticCurveTo(-60, 40, -50, 100);
            ctx.lineTo(50, 100);
            ctx.quadraticCurveTo(60, 40, 40, -30);
            ctx.closePath();
            ctx.fill();

            // Robe pattern - wheat/plant designs
            ctx.strokeStyle = COLORS.gold;
            ctx.lineWidth = 2;
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(-30 + i * 15, 0);
                ctx.lineTo(-30 + i * 15, 50);
                // Wheat heads
                for (let j = 0; j < 3; j++) {
                    ctx.moveTo(-30 + i * 15, 10 + j * 12);
                    ctx.lineTo(-35 + i * 15, 5 + j * 12);
                    ctx.moveTo(-30 + i * 15, 10 + j * 12);
                    ctx.lineTo(-25 + i * 15, 5 + j * 12);
                }
                ctx.stroke();
            }

            // Head
            ctx.fillStyle = '#E8C4A0';
            ctx.beginPath();
            ctx.arc(0, -60, 28, 0, Math.PI * 2);
            ctx.fill();

            // Wheat crown
            ctx.fillStyle = COLORS.gold;
            for (let i = 0; i < 7; i++) {
                const angle = Math.PI * 0.15 + (i / 6) * Math.PI * 0.7;
                ctx.save();
                ctx.translate(0, -80);
                ctx.rotate(angle - Math.PI/2);
                ctx.fillRect(-2, 0, 4, 25);
                // Wheat grains
                for (let j = 0; j < 3; j++) {
                    ctx.beginPath();
                    ctx.ellipse(-5, 5 + j * 6, 4, 2, -0.3, 0, Math.PI * 2);
                    ctx.ellipse(5, 5 + j * 6, 4, 2, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }

            // Serene face
            ctx.fillStyle = '#4a3a2a';
            ctx.beginPath();
            ctx.ellipse(-8, -62, 4, 3, 0, 0, Math.PI * 2);
            ctx.ellipse(8, -62, 4, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Gentle smile
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, -52, 10, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // Hair
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                ctx.moveTo(-25 + i * 12, -50);
                ctx.quadraticCurveTo(-30 + i * 12, 0, -20 + i * 12, 20);
            }
            ctx.lineWidth = 8;
            ctx.strokeStyle = '#8B4513';
            ctx.stroke();

            // Arms raised, channeling growth magic
            ctx.fillStyle = '#E8C4A0';

            // Left arm
            ctx.save();
            ctx.translate(-35, -20);
            ctx.rotate(-1 - armRaise);
            ctx.fillRect(0, -8, 55, 16);
            // Hand
            ctx.beginPath();
            ctx.arc(55, 0, 12, 0, Math.PI * 2);
            ctx.fill();
            // Fingers spread
            for (let i = 0; i < 5; i++) {
                const fingerAngle = -0.4 + i * 0.2;
                ctx.save();
                ctx.translate(55, 0);
                ctx.rotate(fingerAngle);
                ctx.fillRect(8, -2, 12, 4);
                ctx.restore();
            }

            // Magic emanating from hand
            ctx.strokeStyle = COLORS.magic;
            ctx.lineWidth = 3;
            for (let i = 0; i < 5; i++) {
                const magicAngle = time * 3 + i * 0.5;
                ctx.beginPath();
                ctx.moveTo(60, 0);
                ctx.lineTo(
                    60 + Math.cos(magicAngle) * 40,
                    Math.sin(magicAngle) * 30
                );
                ctx.globalAlpha = 0.5 + Math.sin(time * 5 + i) * 0.3;
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.restore();

            // Right arm
            ctx.save();
            ctx.translate(35, -20);
            ctx.rotate(1 + armRaise);
            ctx.fillRect(-55, -8, 55, 16);
            ctx.beginPath();
            ctx.arc(-55, 0, 12, 0, Math.PI * 2);
            ctx.fill();
            for (let i = 0; i < 5; i++) {
                const fingerAngle = Math.PI - (-0.4 + i * 0.2);
                ctx.save();
                ctx.translate(-55, 0);
                ctx.rotate(fingerAngle);
                ctx.fillRect(8, -2, 12, 4);
                ctx.restore();
            }

            // Magic from right hand
            ctx.strokeStyle = COLORS.magic;
            ctx.lineWidth = 3;
            for (let i = 0; i < 5; i++) {
                const magicAngle = -time * 3 + i * 0.5;
                ctx.beginPath();
                ctx.moveTo(-60, 0);
                ctx.lineTo(
                    -60 + Math.cos(magicAngle) * 40,
                    Math.sin(magicAngle) * 30
                );
                ctx.globalAlpha = 0.5 + Math.sin(time * 5 + i) * 0.3;
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.restore();

            ctx.restore();
        }

        function drawMagicWaves(time) {
            // Waves of growth magic spreading from Demeter
            for (let i = 0; i < 3; i++) {
                const waveRadius = ((time * 100 + i * 150) % 400);
                const opacity = 1 - waveRadius / 400;

                ctx.strokeStyle = `rgba(144, 238, 144, ${opacity * 0.5})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(canvas.width * 0.5, canvas.height * 0.25, waveRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function animate() {
            time += 0.02;
            growPhase = (time % 8);

            // Background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0a2a1a');
            gradient.addColorStop(0.5, '#0a1a10');
            gradient.addColorStop(1, '#1a2a15');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Ground
            ctx.fillStyle = '#2a3a20';
            ctx.fillRect(0, canvas.height * 0.45, canvas.width, canvas.height * 0.55);

            // Update tree positions for responsive
            let treeIndex = 0;
            for (let row = 0; row < 4; row++) {
                const y = canvas.height * 0.5 + row * 60;
                const count = 5 + row * 2;
                for (let i = 0; i < count; i++) {
                    if (trees[treeIndex]) {
                        trees[treeIndex].x = canvas.width * 0.1 + (i / (count - 1)) * canvas.width * 0.8;
                        trees[treeIndex].baseY = y;
                    }
                    treeIndex++;
                }
            }

            // Sort trees by Y for depth
            const sortedTrees = [...trees].sort((a, b) => a.baseY - b.baseY);

            // Growth cycle (reset every 8 seconds)
            const cycleTime = time % 8;
            if (cycleTime < 0.1) {
                trees.forEach(t => {
                    t.currentHeight = 0;
                    t.delay = t.delay % 3; // Reset delays
                });
            }

            // Magic waves
            drawMagicWaves(time);

            // Demeter in front, channeling
            drawDemeter(canvas.width * 0.5, canvas.height * 0.3, time);

            // Update and draw trees
            sortedTrees.forEach(t => {
                t.update(cycleTime);
                t.draw();
            });

            requestAnimationFrame(animate);
        }

        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
