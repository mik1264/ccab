<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kenning Forge Pro - Generative Poetry Studio | CCAB</title>
    <meta name="description" content="Generate Old Norse and Anglo-Saxon kennings with controllable weirdness, rendered as algorithmic runic calligraphy art. Export as SVG prints.">
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --parchment: #f5e6c8;
            --ink: #2a1a0a;
            --gold: #c9a84c;
            --blood: #8b2500;
            --iron: #4a4a4a;
            --rune-glow: #d4a84488;
            --deep-night: #0d0a06;
            --bark: #3d2b1f;
            --moss: #606C38;
            --sage: #8A9A5B;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: var(--deep-night);
            color: var(--parchment);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Back link */
        .back-link {
            position: fixed;
            top: 16px;
            left: 16px;
            padding: 8px 18px;
            background: rgba(42, 26, 10, 0.85);
            color: var(--gold);
            text-decoration: none;
            border-radius: 8px;
            z-index: 1000;
            font-family: 'Lora', serif;
            font-size: 0.9rem;
            border: 1px solid rgba(201, 168, 76, 0.3);
            transition: all 0.3s ease;
        }
        .back-link:hover {
            background: rgba(201, 168, 76, 0.15);
            transform: translateX(-3px);
        }

        /* Loading screen */
        #loading {
            position: fixed;
            inset: 0;
            background: var(--deep-night);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.6s ease;
        }
        #loading.hidden { opacity: 0; pointer-events: none; }
        .loading-rune {
            font-size: 4rem;
            color: var(--gold);
            animation: pulse 1.5s ease-in-out infinite;
        }
        .loading-text {
            margin-top: 1rem;
            font-family: 'Lora', serif;
            color: var(--parchment);
            opacity: 0.7;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.4; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        /* Main layout */
        .app {
            display: grid;
            grid-template-columns: 360px 1fr;
            min-height: 100vh;
        }

        /* Sidebar controls */
        .sidebar {
            background: linear-gradient(180deg, #1a120a 0%, #0d0a06 100%);
            border-right: 1px solid rgba(201, 168, 76, 0.15);
            padding: 80px 24px 24px;
            overflow-y: auto;
            max-height: 100vh;
            position: sticky;
            top: 0;
        }

        .studio-title {
            font-family: 'Lora', serif;
            font-size: 1.6rem;
            color: var(--gold);
            margin-bottom: 4px;
            letter-spacing: 0.03em;
        }
        .studio-subtitle {
            font-size: 0.8rem;
            color: rgba(245, 230, 200, 0.5);
            margin-bottom: 28px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .control-section {
            margin-bottom: 24px;
        }
        .control-section h3 {
            font-family: 'Lora', serif;
            font-size: 0.85rem;
            color: var(--gold);
            text-transform: uppercase;
            letter-spacing: 0.12em;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(201, 168, 76, 0.15);
        }

        .control-group {
            margin-bottom: 14px;
        }
        .control-group label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.82rem;
            color: rgba(245, 230, 200, 0.75);
            margin-bottom: 6px;
        }
        .control-group label .val {
            color: var(--gold);
            font-weight: 600;
            font-size: 0.78rem;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: linear-gradient(90deg, var(--bark), var(--gold));
            outline: none;
            cursor: pointer;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--gold);
            border: 2px solid var(--deep-night);
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--gold);
            border: 2px solid var(--deep-night);
            cursor: pointer;
        }

        select {
            width: 100%;
            padding: 8px 10px;
            background: rgba(42, 26, 10, 0.6);
            border: 1px solid rgba(201, 168, 76, 0.25);
            border-radius: 6px;
            color: var(--parchment);
            font-family: 'Nunito', sans-serif;
            font-size: 0.82rem;
            cursor: pointer;
        }
        select option { background: #1a120a; }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 20px;
            border: 1px solid rgba(201, 168, 76, 0.4);
            border-radius: 8px;
            background: linear-gradient(135deg, rgba(201, 168, 76, 0.15), rgba(201, 168, 76, 0.05));
            color: var(--gold);
            font-family: 'Lora', serif;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 8px;
        }
        .btn:hover {
            background: linear-gradient(135deg, rgba(201, 168, 76, 0.3), rgba(201, 168, 76, 0.1));
            border-color: var(--gold);
            transform: translateY(-1px);
        }
        .btn-primary {
            background: linear-gradient(135deg, rgba(201, 168, 76, 0.35), rgba(201, 168, 76, 0.15));
            font-size: 1rem;
            padding: 12px 24px;
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        .btn-group .btn { margin-bottom: 0; }

        /* Corpus selector chips */
        .corpus-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 10px;
        }
        .corpus-chip {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            border: 1px solid rgba(201, 168, 76, 0.25);
            background: transparent;
            color: rgba(245, 230, 200, 0.6);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .corpus-chip.active {
            background: rgba(201, 168, 76, 0.2);
            color: var(--gold);
            border-color: var(--gold);
        }
        .corpus-chip:hover { border-color: var(--gold); }

        /* Kenning output list */
        .kenning-scroll {
            margin-top: 16px;
            max-height: 180px;
            overflow-y: auto;
            padding-right: 6px;
        }
        .kenning-scroll::-webkit-scrollbar { width: 4px; }
        .kenning-scroll::-webkit-scrollbar-thumb { background: rgba(201, 168, 76, 0.3); border-radius: 2px; }
        .kenning-item {
            padding: 8px 10px;
            margin-bottom: 4px;
            border-radius: 6px;
            font-family: 'Lora', serif;
            font-size: 0.88rem;
            color: var(--parchment);
            background: rgba(201, 168, 76, 0.05);
            border-left: 2px solid var(--gold);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .kenning-item:hover, .kenning-item.selected {
            background: rgba(201, 168, 76, 0.15);
        }
        .kenning-item .meaning {
            display: block;
            font-family: 'Nunito', sans-serif;
            font-size: 0.7rem;
            color: rgba(245, 230, 200, 0.4);
            margin-top: 2px;
            font-style: italic;
        }

        /* Main canvas area */
        .canvas-area {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(ellipse at center, #1a140d 0%, #0d0a06 70%);
            overflow: hidden;
        }
        #art-canvas {
            display: block;
        }

        /* Info overlay on canvas */
        .canvas-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-family: 'Lora', serif;
            font-size: 0.75rem;
            color: rgba(201, 168, 76, 0.4);
            pointer-events: none;
        }

        .export-bar {
            position: absolute;
            top: 16px;
            right: 16px;
            display: flex;
            gap: 8px;
            z-index: 10;
        }
        .export-btn {
            padding: 6px 14px;
            background: rgba(42, 26, 10, 0.85);
            border: 1px solid rgba(201, 168, 76, 0.3);
            border-radius: 6px;
            color: var(--gold);
            font-family: 'Nunito', sans-serif;
            font-size: 0.78rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .export-btn:hover {
            background: rgba(201, 168, 76, 0.2);
            border-color: var(--gold);
        }

        /* Responsive */
        @media (max-width: 900px) {
            .app {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }
            .sidebar {
                max-height: none;
                position: relative;
                padding-top: 60px;
            }
            .canvas-area {
                min-height: 70vh;
            }
        }

        /* Custom scrollbar */
        .sidebar::-webkit-scrollbar { width: 5px; }
        .sidebar::-webkit-scrollbar-thumb { background: rgba(201, 168, 76, 0.2); border-radius: 3px; }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">&#8592; Gallery</a>

    <div id="loading">
        <div class="loading-rune">&#5765;</div>
        <div class="loading-text">Awakening the Forge...</div>
    </div>

    <div class="app">
        <aside class="sidebar">
            <h1 class="studio-title">Kenning Forge Pro</h1>
            <p class="studio-subtitle">Generative Poetry Studio</p>

            <!-- Corpus Selection -->
            <div class="control-section">
                <h3>Source Corpus</h3>
                <div class="corpus-chips">
                    <button class="corpus-chip active" data-corpus="beowulf">Beowulf</button>
                    <button class="corpus-chip active" data-corpus="edda">Prose Edda</button>
                    <button class="corpus-chip" data-corpus="volsunga">V&#246;lsunga</button>
                    <button class="corpus-chip" data-corpus="skaldic">Skaldic</button>
                    <button class="corpus-chip active" data-corpus="custom">Hybrid</button>
                </div>
            </div>

            <!-- Weirdness Controls -->
            <div class="control-section">
                <h3>Weirdness Dials</h3>

                <div class="control-group">
                    <label>Kenning Temperature <span class="val" id="temp-val">0.6</span></label>
                    <input type="range" id="temperature" min="0.1" max="1.5" step="0.05" value="0.6">
                </div>

                <div class="control-group">
                    <label>Compound Depth <span class="val" id="depth-val">2</span></label>
                    <input type="range" id="depth" min="1" max="5" step="1" value="2">
                </div>

                <div class="control-group">
                    <label>Archaism Level <span class="val" id="archaic-val">0.5</span></label>
                    <input type="range" id="archaism" min="0" max="1" step="0.05" value="0.5">
                </div>

                <div class="control-group">
                    <label>Metaphor Stretch <span class="val" id="metaphor-val">0.4</span></label>
                    <input type="range" id="metaphor" min="0" max="1" step="0.05" value="0.4">
                </div>

                <div class="control-group">
                    <label>Alliterative Force <span class="val" id="allit-val">0.3</span></label>
                    <input type="range" id="alliteration" min="0" max="1" step="0.05" value="0.3">
                </div>
            </div>

            <!-- Kenning Domain -->
            <div class="control-section">
                <h3>Domain Focus</h3>
                <div class="control-group">
                    <select id="domain">
                        <option value="all">All Domains</option>
                        <option value="sea">Sea & Ocean</option>
                        <option value="battle">Battle & War</option>
                        <option value="sky">Sky & Weather</option>
                        <option value="wealth">Wealth & Treasure</option>
                        <option value="body">Body & Mind</option>
                        <option value="nature">Nature & Animals</option>
                        <option value="fate">Fate & Death</option>
                        <option value="craft">Craft & Creation</option>
                    </select>
                </div>
            </div>

            <!-- Generation -->
            <div class="control-section">
                <h3>Forge</h3>
                <button class="btn btn-primary" id="btn-forge">&#9876; Forge Kenning</button>
                <div class="btn-group">
                    <button class="btn" id="btn-batch">Batch (x8)</button>
                    <button class="btn" id="btn-verse">Full Verse</button>
                </div>
            </div>

            <!-- Generated kennings list -->
            <div class="control-section">
                <h3>Forged Kennings</h3>
                <div class="kenning-scroll" id="kenning-list">
                    <div class="kenning-item" style="color: rgba(245,230,200,0.3); font-style: italic; border-left-color: transparent;">
                        Press "Forge Kenning" to begin...
                    </div>
                </div>
            </div>

            <!-- Art Style -->
            <div class="control-section">
                <h3>Art Rendering</h3>
                <div class="control-group">
                    <select id="art-style">
                        <option value="runic-circle">Runic Circle</option>
                        <option value="stave-column">Stave Column</option>
                        <option value="woven-knot">Woven Knotwork</option>
                        <option value="tree-branches">Yggdrasil Branches</option>
                        <option value="wave-poem">Wave Poem</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Glow Intensity <span class="val" id="glow-val">0.5</span></label>
                    <input type="range" id="glow" min="0" max="1" step="0.05" value="0.5">
                </div>

                <div class="control-group">
                    <label>Animation Speed <span class="val" id="speed-val">0.5</span></label>
                    <input type="range" id="anim-speed" min="0" max="1" step="0.05" value="0.5">
                </div>

                <div class="control-group">
                    <select id="color-scheme">
                        <option value="gold-ink">Gold & Ink</option>
                        <option value="blood-parchment">Blood & Parchment</option>
                        <option value="frost-silver">Frost & Silver</option>
                        <option value="moss-earth">Moss & Earth</option>
                        <option value="ember-ash">Ember & Ash</option>
                    </select>
                </div>
            </div>
        </aside>

        <main class="canvas-area">
            <div class="export-bar">
                <button class="export-btn" id="btn-svg">Export SVG</button>
                <button class="export-btn" id="btn-png">Export PNG</button>
                <button class="export-btn" id="btn-print">Print-Ready</button>
            </div>
            <div id="p5-container"></div>
            <div class="canvas-info" id="canvas-info"></div>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
    // ========================================================================
    // KENNING FORGE PRO - Generative Poetry Studio
    // Beowulf / Edda corpus-trained Markov kenning generator
    // with p5.js runic calligraphy rendering and SVG export
    // ========================================================================

    (function() {
        'use strict';

        // ====================================================================
        // CORPUS DATA - Old English / Old Norse kenning structures
        // ====================================================================

        const CORPORA = {
            // Beowulf kennings - Anglo-Saxon tradition
            beowulf: {
                // Base nouns that appear as kenning targets (what is being described)
                targets: {
                    sea: ['whale-road', 'swan-road', 'gannet-bath', 'seal-bath', 'sail-road', 'fish-home'],
                    battle: ['sword-play', 'spear-din', 'shield-clash', 'arrow-storm', 'blade-meeting', 'war-sweat'],
                    warrior: ['shield-bearer', 'ring-giver', 'battle-friend', 'spear-dane', 'sword-wielder', 'helm-wearer'],
                    king: ['ring-giver', 'gold-friend', 'throne-holder', 'people-ruler', 'land-guardian', 'war-chief'],
                    ship: ['wave-steed', 'sea-wood', 'ocean-stallion', 'water-floater', 'ring-prowed', 'foam-rider'],
                    body: ['bone-house', 'flesh-covering', 'life-dwelling', 'soul-vessel', 'blood-hall', 'spirit-hold'],
                    blood: ['battle-sweat', 'wound-sea', 'sword-dew', 'war-rain', 'slaughter-dew', 'blade-water'],
                    sun: ['sky-candle', 'heaven-jewel', 'world-candle', 'day-star', 'sky-gem', 'light-bringer'],
                    sword: ['battle-light', 'wound-maker', 'war-flame', 'edge-biter', 'blood-worm', 'death-beam'],
                    dragon: ['sky-plague', 'hoard-guardian', 'flame-serpent', 'night-flyer', 'barrow-keeper', 'fire-drake'],
                    gold: ['dragon-bed', 'war-prize', 'ring-treasure', 'arm-wealth', 'hall-joy', 'earth-gold'],
                    death: ['life-parting', 'soul-severing', 'fate-fall', 'world-leaving', 'bone-breaking', 'doom-shadow'],
                    raven: ['corpse-bird', 'battle-swallow', 'wound-picker', 'slaughter-hawk', 'war-gull', 'blood-crane'],
                    sky: ['heaven-roof', 'wind-hall', 'star-plain', 'cloud-home', 'storm-realm', 'bird-road']
                },
                // Modifier words (first elements)
                modifiers: ['whale', 'swan', 'battle', 'sword', 'shield', 'ring', 'gold', 'bone', 'blood',
                            'flame', 'storm', 'wave', 'wound', 'war', 'spear', 'death', 'life', 'world',
                            'heaven', 'sea', 'iron', 'frost', 'hoard', 'mead', 'earth', 'corpse', 'night'],
                // Base words (second elements)
                bases: ['road', 'path', 'home', 'bath', 'steed', 'house', 'hall', 'light', 'fire',
                        'dew', 'rain', 'friend', 'giver', 'keeper', 'bearer', 'maker', 'bringer',
                        'candle', 'jewel', 'serpent', 'wood', 'stone', 'bed', 'joy', 'worm', 'bird',
                        'plain', 'realm', 'roof', 'wearer', 'rider', 'floater']
            },

            // Prose Edda kennings - Old Norse tradition
            edda: {
                targets: {
                    sea: ['Aegir-domain', 'Ran-embrace', 'whale-acre', 'fish-realm', 'keel-land', 'mast-field'],
                    battle: ['Odin-storm', 'Valkyrie-noise', 'spear-clash', 'Tyr-game', 'weapon-meeting', 'shield-thunder'],
                    warrior: ['Odin-tree', 'battle-bush', 'shield-Tyr', 'weapon-elm', 'armor-Freyr', 'sword-Njord'],
                    gold: ['Sif-hair', 'otter-ransom', 'dragon-lair', 'Fafnir-bed', 'Rhine-fire', 'arm-fire'],
                    sky: ['skull-dome', 'dwarf-burden', 'Odin-roof', 'wind-weaver', 'star-cloth', 'moon-hall'],
                    poetry: ['Odin-mead', 'dwarf-drink', 'Kvasir-blood', 'thought-honey', 'word-sea', 'skald-ale'],
                    ship: ['wave-horse', 'sea-king', 'mast-beast', 'wind-rider', 'fjord-elk', 'surf-bear'],
                    earth: ['Odin-wife', 'sea-floor', 'Ymir-flesh', 'giant-ground', 'snake-bed', 'deep-root'],
                    woman: ['linen-goddess', 'ale-Freya', 'ring-Nanna', 'gold-Sif', 'necklace-Var', 'thread-dis'],
                    man: ['battle-tree', 'sword-ash', 'gold-breaker', 'ring-scatterer', 'shield-maple', 'spear-birch'],
                    blood: ['wound-stream', 'raven-drink', 'wolf-wine', 'sword-rain', 'battle-tide', 'corpse-sea'],
                    wolf: ['Odin-hound', 'corpse-swallower', 'Fenrir-kin', 'forest-dog', 'bone-gnawer', 'night-howler'],
                    raven: ['Odin-bird', 'thought-flyer', 'memory-wing', 'corpse-gull', 'Huginn-kin', 'battle-starling']
                },
                modifiers: ['Odin', 'Thor', 'Freya', 'Tyr', 'Ran', 'Aegir', 'Fenrir', 'Ymir',
                            'Kvasir', 'Fafnir', 'Sif', 'Bragi', 'Huginn', 'Muninn', 'Valkyrie',
                            'raven', 'wolf', 'serpent', 'giant', 'dwarf', 'ash', 'elm', 'birch',
                            'skull', 'frost', 'fire', 'mist', 'thunder', 'fjord', 'ice', 'rune'],
                bases: ['tree', 'mead', 'fire', 'bed', 'domain', 'roof', 'horse', 'steed',
                        'drink', 'blood', 'storm', 'noise', 'game', 'lair', 'hair', 'burden',
                        'cloth', 'flesh', 'bone', 'kin', 'hound', 'song', 'stream', 'ale',
                        'bride', 'goddess', 'dis', 'elm', 'ash', 'maple', 'birch', 'oak']
            },

            // Volsunga Saga kennings
            volsunga: {
                targets: {
                    battle: ['Gram-song', 'shield-wall-break', 'valor-test', 'Sigurd-fury', 'dragon-slayer-art'],
                    hero: ['doom-defier', 'fate-wrestler', 'oath-keeper', 'glory-seeker', 'name-winner'],
                    sword: ['leg-biter', 'mail-gnawer', 'helm-cleaver', 'shield-shatterer', 'Regin-forged'],
                    dragon: ['gold-coiler', 'venom-breather', 'death-worm', 'hoard-sleeper', 'bane-wyrm'],
                    treasure: ['curse-hoard', 'Andvari-doom', 'Rhine-gleam', 'serpent-gold', 'ring-curse'],
                    fate: ['Norn-weaving', 'wyrd-thread', 'doom-spinner', 'life-loom', 'destiny-knot']
                },
                modifiers: ['doom', 'fate', 'glory', 'curse', 'oath', 'honor', 'valor', 'wyrd',
                            'Norn', 'Sigurd', 'Brynhild', 'Gram', 'Regin', 'Fafnir', 'Andvari',
                            'Rhine', 'dragon', 'serpent', 'venom', 'flame', 'forged'],
                bases: ['biter', 'slayer', 'keeper', 'breaker', 'singer', 'weaver', 'seeker',
                        'winner', 'defier', 'wrestler', 'coiler', 'sleeper', 'spinner', 'thread',
                        'doom', 'gleam', 'curse', 'song', 'fury', 'art', 'test']
            },

            // Skaldic tradition - more complex compounds
            skaldic: {
                targets: {
                    poetry: ['thought-forge', 'word-anvil', 'mind-mead', 'verse-stream', 'meter-loom', 'stanza-weave'],
                    sea: ['whale-field', 'anchor-meadow', 'sail-land', 'gull-cliff-base', 'herring-ground'],
                    battle: ['corpse-harvest', 'arrow-hail', 'blade-weather', 'helm-thunder', 'shield-storm'],
                    warrior: ['wound-dealer', 'corpse-feeder', 'raven-gladdener', 'wolf-nourisher', 'fame-earner'],
                    gold: ['hand-ember', 'arm-blaze', 'fist-flame', 'finger-sun', 'wrist-fire'],
                    woman: ['gold-tree', 'linen-land', 'ale-goddess', 'thread-ruler', 'distaff-valkyrie'],
                    ship: ['plank-steed', 'oar-beast', 'anchor-bear', 'tiller-elk', 'keel-reindeer']
                },
                modifiers: ['thought', 'word', 'mind', 'verse', 'corpse', 'arrow', 'blade', 'helm',
                            'wound', 'raven', 'wolf', 'fame', 'hand', 'arm', 'fist', 'finger',
                            'plank', 'oar', 'anchor', 'tiller', 'keel', 'linen', 'ale', 'thread',
                            'bone', 'skull', 'rib', 'sinew', 'tooth', 'claw', 'horn', 'hide'],
                bases: ['forge', 'anvil', 'mead', 'stream', 'loom', 'field', 'meadow', 'land',
                        'harvest', 'hail', 'weather', 'thunder', 'storm', 'dealer', 'feeder',
                        'gladdener', 'nourisher', 'earner', 'ember', 'blaze', 'flame', 'sun',
                        'fire', 'steed', 'beast', 'bear', 'elk', 'reindeer', 'tree', 'ruler']
            },

            // Hybrid/custom creative extensions
            custom: {
                targets: {
                    computer: ['thought-loom', 'lightning-brain', 'silicon-seer', 'logic-forge', 'code-well'],
                    internet: ['mind-web', 'thought-ocean', 'knowledge-tide', 'word-tempest', 'data-fjord'],
                    music: ['air-weaving', 'ear-honey', 'soul-tide', 'heart-storm', 'silence-breaker'],
                    love: ['heart-fire', 'soul-binding', 'fate-weaving', 'dream-anchor', 'joy-root'],
                    time: ['moment-river', 'age-glacier', 'memory-tide', 'now-spark', 'ever-wheel'],
                    moon: ['night-lantern', 'tide-ruler', 'shadow-pearl', 'wolf-bait', 'dream-eye'],
                    forest: ['root-kingdom', 'leaf-ocean', 'bark-fortress', 'branch-heaven', 'moss-realm'],
                    mountain: ['sky-tooth', 'cloud-pier', 'stone-giant', 'earth-horn', 'wind-breaker'],
                    fire: ['wood-wolf', 'ash-maker', 'heat-serpent', 'light-beast', 'ember-dancer'],
                    ice: ['water-bone', 'cold-stone', 'winter-glass', 'frost-blade', 'snow-armor']
                },
                modifiers: ['thought', 'lightning', 'silicon', 'logic', 'code', 'mind', 'knowledge',
                            'data', 'soul', 'heart', 'dream', 'shadow', 'root', 'leaf', 'bark',
                            'branch', 'moss', 'cloud', 'stone', 'ember', 'frost', 'star', 'void',
                            'crystal', 'iron', 'silver', 'copper', 'glass', 'silk', 'bone', 'feather'],
                bases: ['loom', 'brain', 'seer', 'forge', 'well', 'web', 'ocean', 'tide',
                        'weaving', 'honey', 'storm', 'anchor', 'root', 'river', 'glacier',
                        'spark', 'wheel', 'lantern', 'ruler', 'pearl', 'eye', 'kingdom',
                        'fortress', 'heaven', 'realm', 'tooth', 'giant', 'horn', 'wolf',
                        'serpent', 'beast', 'dancer', 'bone', 'blade', 'armor', 'singer']
            }
        };

        // Domain mapping
        const DOMAIN_MAP = {
            all: null,
            sea: ['sea', 'ship'],
            battle: ['battle', 'warrior', 'sword', 'blood'],
            sky: ['sky', 'sun', 'moon'],
            wealth: ['gold', 'treasure'],
            body: ['body', 'blood', 'bone'],
            nature: ['dragon', 'wolf', 'raven', 'forest', 'mountain', 'earth'],
            fate: ['fate', 'death', 'time'],
            craft: ['poetry', 'music', 'craft', 'computer', 'internet']
        };

        // Elder Futhark runes for rendering
        const ELDER_FUTHARK = {
            'f': '\u16A0', 'u': '\u16A2', 'th': '\u16A6', 'a': '\u16A8',
            'r': '\u16B1', 'k': '\u16B2', 'g': '\u16B7', 'w': '\u16B9',
            'h': '\u16BA', 'n': '\u16BE', 'i': '\u16C1', 'j': '\u16C3',
            'p': '\u16C8', 'z': '\u16C9', 's': '\u16CB', 't': '\u16CF',
            'b': '\u16D2', 'e': '\u16D6', 'm': '\u16D7', 'l': '\u16DA',
            'ng': '\u16DC', 'o': '\u16DF', 'd': '\u16DE', 'v': '\u16B9',
            'c': '\u16B2', 'q': '\u16B2', 'x': '\u16B2\u16CB', 'y': '\u16C3'
        };

        const ALL_RUNES = ['\u16A0','\u16A2','\u16A6','\u16A8','\u16B1','\u16B2',
            '\u16B7','\u16B9','\u16BA','\u16BE','\u16C1','\u16C3','\u16C8',
            '\u16C9','\u16CB','\u16CF','\u16D2','\u16D6','\u16D7','\u16DA',
            '\u16DC','\u16DF','\u16DE'];

        // Color schemes
        const COLOR_SCHEMES = {
            'gold-ink': {
                primary: [201, 168, 76],
                secondary: [245, 230, 200],
                bg: [13, 10, 6],
                accent: [170, 130, 50],
                glow: [220, 190, 100]
            },
            'blood-parchment': {
                primary: [160, 30, 20],
                secondary: [245, 230, 200],
                bg: [20, 8, 5],
                accent: [200, 50, 30],
                glow: [220, 60, 40]
            },
            'frost-silver': {
                primary: [180, 200, 220],
                secondary: [220, 230, 245],
                bg: [8, 12, 18],
                accent: [140, 170, 210],
                glow: [200, 220, 255]
            },
            'moss-earth': {
                primary: [138, 154, 91],
                secondary: [200, 210, 170],
                bg: [10, 14, 6],
                accent: [96, 108, 56],
                glow: [160, 180, 100]
            },
            'ember-ash': {
                primary: [220, 120, 40],
                secondary: [200, 180, 160],
                bg: [15, 10, 8],
                accent: [240, 80, 20],
                glow: [255, 150, 50]
            }
        };

        // ====================================================================
        // MARKOV KENNING GENERATOR
        // ====================================================================

        class KenningGenerator {
            constructor() {
                this.activeCorpora = new Set(['beowulf', 'edda', 'custom']);
                this.temperature = 0.6;
                this.compoundDepth = 2;
                this.archaism = 0.5;
                this.metaphorStretch = 0.4;
                this.alliteration = 0.3;
                this.domain = 'all';

                // Build Markov transition tables
                this.buildTransitions();
            }

            buildTransitions() {
                this.transitions = {};
                this.allModifiers = [];
                this.allBases = [];
                this.allTargets = {};

                for (const corpusName of this.activeCorpora) {
                    const corpus = CORPORA[corpusName];
                    if (!corpus) continue;

                    this.allModifiers.push(...corpus.modifiers);
                    this.allBases.push(...corpus.bases);

                    for (const [category, kennings] of Object.entries(corpus.targets)) {
                        if (!this.allTargets[category]) this.allTargets[category] = [];
                        this.allTargets[category].push(...kennings);
                    }

                    // Build bigram transitions from kenning patterns
                    for (const kennings of Object.values(corpus.targets)) {
                        for (const kenning of kennings) {
                            const parts = kenning.split('-');
                            for (let i = 0; i < parts.length - 1; i++) {
                                const key = parts[i].toLowerCase();
                                const next = parts[i + 1].toLowerCase();
                                if (!this.transitions[key]) this.transitions[key] = [];
                                this.transitions[key].push(next);
                            }
                        }
                    }

                    // Cross-link modifiers to bases
                    for (const mod of corpus.modifiers) {
                        const key = mod.toLowerCase();
                        if (!this.transitions[key]) this.transitions[key] = [];
                        this.transitions[key].push(...corpus.bases.slice(0, 8));
                    }
                }

                // Deduplicate
                this.allModifiers = [...new Set(this.allModifiers)];
                this.allBases = [...new Set(this.allBases)];
            }

            weightedChoice(arr, temperature) {
                if (!arr || arr.length === 0) return null;
                const t = temperature || this.temperature;
                if (t <= 0.3) return arr[Math.floor(Math.random() * Math.min(3, arr.length))];
                if (t >= 1.2) return arr[Math.floor(Math.random() * arr.length)];
                const range = Math.floor(arr.length * Math.min(1, t));
                return arr[Math.floor(Math.random() * Math.max(1, range))];
            }

            getFilteredCategories() {
                const domainFilter = DOMAIN_MAP[this.domain];
                const categories = Object.keys(this.allTargets);
                if (!domainFilter) return categories;
                return categories.filter(c => domainFilter.includes(c));
            }

            // Generate a single kenning compound
            generateCompound() {
                const useMarkov = Math.random() < 0.6;

                if (useMarkov) {
                    // Markov-chain approach
                    let current = this.weightedChoice(this.allModifiers, this.temperature);
                    const parts = [current];

                    for (let d = 1; d < this.compoundDepth; d++) {
                        const key = current.toLowerCase();
                        const nexts = this.transitions[key];
                        if (nexts && nexts.length > 0 && Math.random() < 0.7 + this.temperature * 0.2) {
                            current = this.weightedChoice(nexts, this.temperature);
                        } else {
                            current = this.weightedChoice(this.allBases, this.temperature);
                        }
                        parts.push(current);
                    }

                    return parts.join('-');
                } else {
                    // Corpus lookup with variation
                    const cats = this.getFilteredCategories();
                    if (cats.length === 0) return this.generateCompound(); // fallback
                    const cat = cats[Math.floor(Math.random() * cats.length)];
                    const kennings = this.allTargets[cat];
                    if (!kennings || kennings.length === 0) return this.generateCompound();

                    let kenning = this.weightedChoice(kennings, this.temperature);

                    // Apply metaphor stretch - randomly substitute parts
                    if (this.metaphorStretch > Math.random()) {
                        const parts = kenning.split('-');
                        const idx = Math.floor(Math.random() * parts.length);
                        if (Math.random() < 0.5) {
                            parts[idx] = this.weightedChoice(this.allModifiers, this.temperature);
                        } else {
                            parts[idx] = this.weightedChoice(this.allBases, this.temperature);
                        }
                        kenning = parts.join('-');
                    }

                    // Apply compound depth extension
                    if (this.compoundDepth > 2 && Math.random() < 0.5) {
                        const extra = this.weightedChoice(this.allBases, this.temperature);
                        kenning = kenning + '-' + extra;
                    }

                    return kenning;
                }
            }

            // Apply alliterative preference
            applyAlliteration(kenning) {
                if (Math.random() > this.alliteration) return kenning;

                const parts = kenning.split('-');
                if (parts.length < 2) return kenning;

                const firstLetter = parts[0][0].toLowerCase();
                // Try to find a replacement for second part that alliterates
                const candidates = this.allBases.filter(b => b[0].toLowerCase() === firstLetter);
                if (candidates.length > 0) {
                    parts[parts.length - 1] = this.weightedChoice(candidates, this.temperature);
                }
                return parts.join('-');
            }

            // Apply archaism - Old English style affixes
            applyArchaism(kenning) {
                if (Math.random() > this.archaism) return kenning;

                const archaicPrefixes = ['yon-', 'un-', 'fore-'];
                const archaicSuffixes = ['-ward', '-wise', '-wight'];
                const archaic = Math.random() < 0.5;

                if (archaic && Math.random() < 0.4) {
                    const prefix = archaicPrefixes[Math.floor(Math.random() * archaicPrefixes.length)];
                    return prefix + kenning;
                }
                if (Math.random() < 0.3) {
                    const suffix = archaicSuffixes[Math.floor(Math.random() * archaicSuffixes.length)];
                    return kenning + suffix;
                }
                return kenning;
            }

            // Determine the "meaning" based on generation context
            inferMeaning(kenning) {
                const parts = kenning.split('-');
                const meanings = {
                    road: 'a path or passage', path: 'a way forward', home: 'a dwelling place',
                    bath: 'a body of water', steed: 'a mount or vehicle', house: 'a container',
                    hall: 'a grand space', light: 'illumination', fire: 'destructive force',
                    dew: 'a liquid', rain: 'falling substance', friend: 'an ally',
                    giver: 'one who bestows', keeper: 'a guardian', bearer: 'a carrier',
                    maker: 'a creator', bringer: 'a deliverer', candle: 'a light source',
                    tree: 'a person (kenning)', mead: 'drink or inspiration',
                    storm: 'violent conflict', forge: 'a place of creation',
                    serpent: 'something sinuous', wolf: 'a devourer',
                    loom: 'something that weaves', ocean: 'vastness',
                    anchor: 'something that holds fast', river: 'passage of time',
                    dancer: 'something in motion', singer: 'something that makes sound'
                };

                const lastPart = parts[parts.length - 1].toLowerCase();
                const firstPart = parts[0].toLowerCase();

                // Check known target categories
                for (const [cat, kennings] of Object.entries(this.allTargets)) {
                    if (kennings.includes(kenning)) {
                        return cat;
                    }
                }

                // Infer from parts
                if (meanings[lastPart]) return `${firstPart}'s ${meanings[lastPart]}`;
                return `a ${firstPart} ${lastPart}`;
            }

            // Main generation method
            forge() {
                let kenning = this.generateCompound();
                kenning = this.applyAlliteration(kenning);
                kenning = this.applyArchaism(kenning);

                const meaning = this.inferMeaning(kenning);

                return { text: kenning, meaning: meaning };
            }

            // Generate a batch
            forgeBatch(count) {
                const results = [];
                const seen = new Set();
                let attempts = 0;
                while (results.length < count && attempts < count * 5) {
                    const k = this.forge();
                    if (!seen.has(k.text)) {
                        seen.add(k.text);
                        results.push(k);
                    }
                    attempts++;
                }
                return results;
            }

            // Generate a full verse (4-6 lines of kenning poetry)
            forgeVerse() {
                const lineCount = 4 + Math.floor(Math.random() * 3);
                const lines = [];
                const verseStructures = [
                    (k1, k2) => `Behold the ${k1.text}, ${k2.text} of old`,
                    (k1, k2) => `Where ${k1.text} meets ${k2.text}`,
                    (k1, k2) => `From ${k1.text} springs the ${k2.text}`,
                    (k1, k2) => `The ${k1.text} knows the ${k2.text}`,
                    (k1, k2) => `Through ${k1.text}, beyond the ${k2.text}`,
                    (k1, k2) => `In ${k1.text} dwells the ${k2.text}`,
                    (k1) => `Hail, ${k1.text}!`,
                    (k1, k2) => `By ${k1.text} and ${k2.text} sworn`,
                    (k1) => `The ${k1.text} endures`,
                    (k1, k2) => `Neither ${k1.text} nor ${k2.text} shall wane`
                ];

                for (let i = 0; i < lineCount; i++) {
                    const k1 = this.forge();
                    const k2 = this.forge();
                    const struct = verseStructures[Math.floor(Math.random() * verseStructures.length)];
                    lines.push(struct(k1, k2));
                }
                return {
                    text: lines.join('\n'),
                    meaning: 'A forged verse of ' + lineCount + ' lines',
                    lines: lines
                };
            }
        }

        // ====================================================================
        // TEXT TO RUNES CONVERTER
        // ====================================================================

        function textToRunes(text) {
            let result = '';
            const lower = text.toLowerCase();
            let i = 0;
            while (i < lower.length) {
                // Check digraphs first
                if (i < lower.length - 1) {
                    const digraph = lower.substring(i, i + 2);
                    if (ELDER_FUTHARK[digraph]) {
                        result += ELDER_FUTHARK[digraph];
                        i += 2;
                        continue;
                    }
                }
                const ch = lower[i];
                if (ELDER_FUTHARK[ch]) {
                    result += ELDER_FUTHARK[ch];
                } else if (ch === ' ' || ch === '-') {
                    result += ' ';
                } else if (ch === '\n') {
                    result += '\n';
                }
                // Skip characters without rune mapping
                i++;
            }
            return result;
        }

        // ====================================================================
        // P5.JS RENDERING ENGINE
        // ====================================================================

        let p5Instance = null;
        let currentKenning = null;
        let currentStyle = 'runic-circle';
        let currentColors = COLOR_SCHEMES['gold-ink'];
        let glowIntensity = 0.5;
        let animSpeed = 0.5;
        let animTime = 0;
        let particles = [];

        // Ambient particles for background atmosphere
        class RuneParticle {
            constructor(p) {
                this.p = p;
                this.reset();
            }
            reset() {
                this.x = this.p.random(this.p.width);
                this.y = this.p.random(this.p.height);
                this.rune = ALL_RUNES[Math.floor(Math.random() * ALL_RUNES.length)];
                this.size = this.p.random(8, 20);
                this.alpha = this.p.random(10, 40);
                this.drift = this.p.random(-0.3, 0.3);
                this.rise = this.p.random(0.1, 0.5);
                this.phase = this.p.random(this.p.TWO_PI);
            }
            update() {
                this.y -= this.rise;
                this.x += Math.sin(animTime * 0.5 + this.phase) * this.drift;
                this.alpha -= 0.05;
                if (this.y < -20 || this.alpha <= 0) this.reset();
            }
            draw() {
                const p = this.p;
                const c = currentColors.accent;
                p.fill(c[0], c[1], c[2], this.alpha);
                p.noStroke();
                p.textSize(this.size);
                p.textAlign(p.CENTER, p.CENTER);
                p.text(this.rune, this.x, this.y);
            }
        }

        function createP5Sketch() {
            if (p5Instance) p5Instance.remove();

            p5Instance = new p5(function(p) {
                p.setup = function() {
                    const container = document.getElementById('p5-container');
                    const w = container.offsetWidth || 800;
                    const h = container.offsetHeight || 600;
                    const canvas = p.createCanvas(w, h);
                    canvas.parent('p5-container');
                    p.textFont('serif');
                    p.pixelDensity(Math.min(window.devicePixelRatio || 1, 2));

                    // Initialize particles
                    particles = [];
                    for (let i = 0; i < 30; i++) {
                        particles.push(new RuneParticle(p));
                    }
                };

                p.draw = function() {
                    const bg = currentColors.bg;
                    p.background(bg[0], bg[1], bg[2]);

                    animTime += 0.01 * (0.2 + animSpeed * 1.5);

                    // Draw ambient particles
                    for (const particle of particles) {
                        particle.update();
                        particle.draw();
                    }

                    // Draw main kenning art
                    if (currentKenning) {
                        p.push();
                        p.translate(p.width / 2, p.height / 2);

                        switch (currentStyle) {
                            case 'runic-circle': drawRunicCircle(p); break;
                            case 'stave-column': drawStaveColumn(p); break;
                            case 'woven-knot': drawWovenKnot(p); break;
                            case 'tree-branches': drawTreeBranches(p); break;
                            case 'wave-poem': drawWavePoem(p); break;
                        }

                        p.pop();
                    } else {
                        // Draw placeholder
                        drawPlaceholder(p);
                    }
                };

                p.windowResized = function() {
                    const container = document.getElementById('p5-container');
                    const w = container.offsetWidth || 800;
                    const h = container.offsetHeight || 600;
                    p.resizeCanvas(w, h);
                };
            });
        }

        // --- DRAWING STYLES ---

        function drawPlaceholder(p) {
            const c = currentColors.primary;
            p.textAlign(p.CENTER, p.CENTER);
            p.textSize(28);
            p.fill(c[0], c[1], c[2], 60);
            p.noStroke();
            const runes = '\u16A0\u16A2\u16A6\u16A8\u16B1\u16B2';
            p.text(runes, p.width / 2, p.height / 2 - 20);
            p.textSize(14);
            p.fill(c[0], c[1], c[2], 30);
            p.text('Forge a kenning to awaken the runes', p.width / 2, p.height / 2 + 25);
        }

        function drawRunicCircle(p) {
            const text = currentKenning.text || '';
            const runeText = textToRunes(text);
            const c = currentColors.primary;
            const gc = currentColors.glow;
            const sc = currentColors.secondary;

            const baseRadius = Math.min(p.width, p.height) * 0.3;

            // Outer decorative rings
            for (let ring = 0; ring < 3; ring++) {
                const r = baseRadius + ring * 20 + 30;
                const alpha = 20 - ring * 5;
                p.noFill();
                p.stroke(c[0], c[1], c[2], alpha);
                p.strokeWeight(1);
                const offset = animTime * (ring % 2 === 0 ? 1 : -1) * 0.3;
                p.beginShape();
                for (let a = 0; a <= p.TWO_PI; a += 0.05) {
                    const wobble = p.sin(a * 6 + animTime + ring) * 3;
                    const rx = p.cos(a + offset) * (r + wobble);
                    const ry = p.sin(a + offset) * (r + wobble);
                    p.vertex(rx, ry);
                }
                p.endShape(p.CLOSE);
            }

            // Main rune circle
            const runeChars = runeText.replace(/\s/g, '');
            const charCount = Math.max(runeChars.length, 1);
            const angleStep = p.TWO_PI / Math.max(charCount, 8);

            // Glow layer
            if (glowIntensity > 0) {
                p.drawingContext.shadowBlur = 15 * glowIntensity;
                p.drawingContext.shadowColor = `rgba(${gc[0]},${gc[1]},${gc[2]},${glowIntensity * 0.5})`;
            }

            p.textAlign(p.CENTER, p.CENTER);
            p.textSize(24 + Math.sin(animTime) * 2);
            p.noStroke();

            for (let i = 0; i < runeChars.length; i++) {
                const angle = i * angleStep - p.HALF_PI + animTime * 0.1;
                const r = baseRadius + p.sin(animTime * 2 + i * 0.5) * 5;
                const x = p.cos(angle) * r;
                const y = p.sin(angle) * r;

                const flicker = 0.7 + 0.3 * p.sin(animTime * 3 + i * 1.5);
                p.fill(c[0], c[1], c[2], 200 * flicker);

                p.push();
                p.translate(x, y);
                p.rotate(angle + p.HALF_PI);
                p.text(runeChars[i], 0, 0);
                p.pop();
            }

            // Center text (Latin)
            p.drawingContext.shadowBlur = 0;
            p.textSize(16);
            p.fill(sc[0], sc[1], sc[2], 180);
            const lines = text.split('\n');
            if (lines.length <= 1) {
                p.text(text, 0, 0);
            } else {
                for (let i = 0; i < Math.min(lines.length, 6); i++) {
                    p.text(lines[i], 0, (i - lines.length / 2) * 22);
                }
            }

            // Meaning below
            if (currentKenning.meaning) {
                p.textSize(11);
                p.fill(sc[0], sc[1], sc[2], 80);
                p.text('(' + currentKenning.meaning + ')', 0, lines.length <= 1 ? 28 : (lines.length / 2) * 22 + 20);
            }

            // Inner binding circle
            p.noFill();
            p.stroke(c[0], c[1], c[2], 40);
            p.strokeWeight(0.5);
            p.ellipse(0, 0, baseRadius * 0.6, baseRadius * 0.6);

            // Cross lines
            for (let i = 0; i < 4; i++) {
                const a = (p.PI / 4) * i + animTime * 0.05;
                const innerR = baseRadius * 0.3;
                p.line(p.cos(a) * innerR, p.sin(a) * innerR,
                       p.cos(a) * baseRadius * 0.92, p.sin(a) * baseRadius * 0.92);
            }
        }

        function drawStaveColumn(p) {
            const text = currentKenning.text || '';
            const runeText = textToRunes(text);
            const c = currentColors.primary;
            const gc = currentColors.glow;
            const sc = currentColors.secondary;

            const colWidth = 60;
            const totalHeight = Math.min(p.height * 0.7, 500);

            // Vertical stave lines
            p.stroke(c[0], c[1], c[2], 40);
            p.strokeWeight(2);
            p.line(-colWidth / 2, -totalHeight / 2, -colWidth / 2, totalHeight / 2);
            p.line(colWidth / 2, -totalHeight / 2, colWidth / 2, totalHeight / 2);

            // Top and bottom ornaments
            for (let side = -1; side <= 1; side += 2) {
                const y = side * totalHeight / 2;
                p.noFill();
                p.stroke(c[0], c[1], c[2], 50);
                p.strokeWeight(1);
                // Decorative knot at ends
                for (let i = 0; i < 3; i++) {
                    const s = 20 + i * 8;
                    p.ellipse(0, y, s, s * 0.4);
                }
            }

            // Glow
            if (glowIntensity > 0) {
                p.drawingContext.shadowBlur = 12 * glowIntensity;
                p.drawingContext.shadowColor = `rgba(${gc[0]},${gc[1]},${gc[2]},${glowIntensity * 0.4})`;
            }

            // Runes vertically
            const runeChars = runeText.replace(/[\s\n]/g, '');
            p.textAlign(p.CENTER, p.CENTER);
            p.noStroke();

            const spacing = Math.min(36, totalHeight / Math.max(runeChars.length, 1));
            const startY = -((runeChars.length - 1) * spacing) / 2;

            for (let i = 0; i < runeChars.length; i++) {
                const y = startY + i * spacing;
                const wave = p.sin(animTime * 2 + i * 0.4) * 3;
                const flicker = 0.7 + 0.3 * p.sin(animTime * 2.5 + i * 1.2);

                p.textSize(22 + p.sin(animTime + i) * 2);
                p.fill(c[0], c[1], c[2], 220 * flicker);
                p.text(runeChars[i], wave, y);

                // Horizontal notch lines
                p.stroke(c[0], c[1], c[2], 20);
                p.strokeWeight(0.5);
                p.line(-colWidth / 2, y, -colWidth / 2 + 8, y);
                p.line(colWidth / 2, y, colWidth / 2 - 8, y);
                p.noStroke();
            }

            p.drawingContext.shadowBlur = 0;

            // Latin text to the right
            p.textSize(13);
            p.fill(sc[0], sc[1], sc[2], 150);
            p.textAlign(p.LEFT, p.CENTER);
            const displayLines = text.split('\n');
            for (let i = 0; i < displayLines.length; i++) {
                p.text(displayLines[i], colWidth / 2 + 30, (i - displayLines.length / 2) * 20);
            }

            if (currentKenning.meaning) {
                p.textSize(10);
                p.fill(sc[0], sc[1], sc[2], 60);
                p.text(currentKenning.meaning, colWidth / 2 + 30, (displayLines.length / 2) * 20 + 16);
            }
        }

        function drawWovenKnot(p) {
            const text = currentKenning.text || '';
            const runeText = textToRunes(text);
            const c = currentColors.primary;
            const gc = currentColors.glow;
            const sc = currentColors.secondary;
            const ac = currentColors.accent;

            const size = Math.min(p.width, p.height) * 0.35;

            // Draw interlacing knotwork pattern
            p.noFill();
            p.strokeWeight(3);

            const knotPoints = 8;
            for (let layer = 0; layer < 3; layer++) {
                const r = size * (0.5 + layer * 0.2);
                const alpha = 60 - layer * 15;
                p.stroke(c[0], c[1], c[2], alpha);

                p.beginShape();
                for (let i = 0; i <= knotPoints * 10; i++) {
                    const t = (i / (knotPoints * 10)) * p.TWO_PI;
                    const n = knotPoints + layer;
                    const innerR = r * 0.4;
                    const x = (r - innerR) * p.cos(t) + innerR * p.cos((n - 1) * t + animTime * 0.2);
                    const y = (r - innerR) * p.sin(t) - innerR * p.sin((n - 1) * t + animTime * 0.2);
                    p.vertex(x, y);
                }
                p.endShape();
            }

            // Weave runes along the knot path
            if (glowIntensity > 0) {
                p.drawingContext.shadowBlur = 10 * glowIntensity;
                p.drawingContext.shadowColor = `rgba(${gc[0]},${gc[1]},${gc[2]},${glowIntensity * 0.5})`;
            }

            const runeChars = runeText.replace(/[\s\n]/g, '');
            p.textAlign(p.CENTER, p.CENTER);
            p.noStroke();
            p.textSize(18);

            const r = size * 0.65;
            const innerR = r * 0.4;
            const n = 10;

            for (let i = 0; i < runeChars.length; i++) {
                const t = (i / Math.max(runeChars.length, 1)) * p.TWO_PI + animTime * 0.1;
                const x = (r - innerR) * p.cos(t) + innerR * p.cos((n - 1) * t);
                const y = (r - innerR) * p.sin(t) - innerR * p.sin((n - 1) * t);
                const flicker = 0.6 + 0.4 * p.sin(animTime * 2 + i);
                p.fill(c[0], c[1], c[2], 200 * flicker);
                p.text(runeChars[i], x, y);
            }

            p.drawingContext.shadowBlur = 0;

            // Center text
            p.textSize(14);
            p.fill(sc[0], sc[1], sc[2], 170);
            const lines = text.split('\n');
            for (let i = 0; i < lines.length; i++) {
                p.text(lines[i], 0, (i - lines.length / 2) * 20);
            }

            if (currentKenning.meaning) {
                p.textSize(10);
                p.fill(sc[0], sc[1], sc[2], 70);
                p.text('(' + currentKenning.meaning + ')', 0, (lines.length / 2) * 20 + 16);
            }
        }

        function drawTreeBranches(p) {
            const text = currentKenning.text || '';
            const runeText = textToRunes(text);
            const c = currentColors.primary;
            const gc = currentColors.glow;
            const sc = currentColors.secondary;

            const trunkHeight = Math.min(p.height * 0.6, 400);

            // Draw Yggdrasil-style tree
            p.stroke(c[0], c[1], c[2], 50);
            p.strokeWeight(4);
            p.noFill();

            // Trunk
            const trunkBase = trunkHeight * 0.4;
            p.line(0, trunkBase, 0, -trunkHeight * 0.3);

            // Branches (recursive-ish)
            function drawBranch(x, y, angle, length, depth, branchAlpha) {
                if (depth <= 0 || length < 5) return;

                const endX = x + p.cos(angle) * length;
                const endY = y + p.sin(angle) * length;
                const sway = p.sin(animTime + depth * 2 + x * 0.01) * 0.05;

                p.stroke(c[0], c[1], c[2], branchAlpha);
                p.strokeWeight(depth * 0.8);
                p.line(x, y, endX, endY);

                const spread = 0.4 + p.sin(animTime * 0.5) * 0.1;
                drawBranch(endX, endY, angle - spread + sway, length * 0.65, depth - 1, branchAlpha * 0.7);
                drawBranch(endX, endY, angle + spread + sway, length * 0.65, depth - 1, branchAlpha * 0.7);
            }

            // Main branches
            drawBranch(0, -trunkHeight * 0.1, -p.HALF_PI - 0.3, trunkHeight * 0.25, 5, 50);
            drawBranch(0, -trunkHeight * 0.1, -p.HALF_PI + 0.3, trunkHeight * 0.25, 5, 50);
            drawBranch(0, -trunkHeight * 0.2, -p.HALF_PI, trunkHeight * 0.3, 5, 45);

            // Roots
            drawBranch(0, trunkBase, p.HALF_PI - 0.4, trunkHeight * 0.2, 4, 35);
            drawBranch(0, trunkBase, p.HALF_PI + 0.4, trunkHeight * 0.2, 4, 35);
            drawBranch(0, trunkBase, p.HALF_PI, trunkHeight * 0.15, 3, 30);

            // Glow
            if (glowIntensity > 0) {
                p.drawingContext.shadowBlur = 12 * glowIntensity;
                p.drawingContext.shadowColor = `rgba(${gc[0]},${gc[1]},${gc[2]},${glowIntensity * 0.4})`;
            }

            // Place runes along the trunk and branches
            const runeChars = runeText.replace(/[\s\n]/g, '');
            p.textAlign(p.CENTER, p.CENTER);
            p.noStroke();
            p.textSize(16);

            for (let i = 0; i < runeChars.length; i++) {
                const t = i / Math.max(runeChars.length - 1, 1);
                // Distribute along trunk
                const y = p.lerp(trunkBase - 10, -trunkHeight * 0.25, t);
                const xOff = p.sin(animTime + i * 0.8) * (8 + t * 15);
                const flicker = 0.6 + 0.4 * p.sin(animTime * 2 + i * 1.3);
                p.fill(c[0], c[1], c[2], 200 * flicker);
                p.text(runeChars[i], xOff, y);
            }

            p.drawingContext.shadowBlur = 0;

            // Text at the base
            p.textSize(13);
            p.fill(sc[0], sc[1], sc[2], 150);
            const lines = text.split('\n');
            for (let i = 0; i < lines.length; i++) {
                p.text(lines[i], 0, trunkBase + 40 + i * 20);
            }

            if (currentKenning.meaning) {
                p.textSize(10);
                p.fill(sc[0], sc[1], sc[2], 60);
                p.text('(' + currentKenning.meaning + ')', 0, trunkBase + 40 + lines.length * 20 + 14);
            }
        }

        function drawWavePoem(p) {
            const text = currentKenning.text || '';
            const runeText = textToRunes(text);
            const c = currentColors.primary;
            const gc = currentColors.glow;
            const sc = currentColors.secondary;

            const waveWidth = Math.min(p.width * 0.7, 600);
            const waveHeight = 60;

            // Draw undulating wave lines
            for (let wave = 0; wave < 5; wave++) {
                const y = (wave - 2) * 80;
                const alpha = 25 - wave * 3;
                p.noFill();
                p.stroke(c[0], c[1], c[2], alpha);
                p.strokeWeight(1);

                p.beginShape();
                for (let x = -waveWidth / 2; x <= waveWidth / 2; x += 4) {
                    const wy = y + p.sin(x * 0.02 + animTime + wave) * waveHeight * 0.3
                             + p.sin(x * 0.01 + animTime * 0.7 + wave * 2) * waveHeight * 0.2;
                    p.vertex(x, wy);
                }
                p.endShape();
            }

            // Glow
            if (glowIntensity > 0) {
                p.drawingContext.shadowBlur = 10 * glowIntensity;
                p.drawingContext.shadowColor = `rgba(${gc[0]},${gc[1]},${gc[2]},${glowIntensity * 0.4})`;
            }

            // Runes flowing along a central wave
            const runeChars = runeText.replace(/[\s\n]/g, '');
            p.textAlign(p.CENTER, p.CENTER);
            p.noStroke();
            p.textSize(20);

            const spacing = Math.min(30, waveWidth / Math.max(runeChars.length, 1));
            const startX = -((runeChars.length - 1) * spacing) / 2;

            for (let i = 0; i < runeChars.length; i++) {
                const x = startX + i * spacing;
                const y = p.sin(x * 0.015 + animTime * 1.2) * 30
                        + p.cos(x * 0.008 + animTime * 0.8) * 15;
                const flicker = 0.6 + 0.4 * p.sin(animTime * 2.5 + i * 0.9);
                p.fill(c[0], c[1], c[2], 220 * flicker);

                p.push();
                p.translate(x, y);
                const angle = p.cos(x * 0.015 + animTime * 1.2) * 0.015 * 30;
                p.rotate(angle);
                p.text(runeChars[i], 0, 0);
                p.pop();
            }

            p.drawingContext.shadowBlur = 0;

            // Latin text below waves
            p.textSize(14);
            p.fill(sc[0], sc[1], sc[2], 160);
            const lines = text.split('\n');
            const textY = 120;
            for (let i = 0; i < lines.length; i++) {
                p.text(lines[i], 0, textY + i * 22);
            }

            if (currentKenning.meaning) {
                p.textSize(10);
                p.fill(sc[0], sc[1], sc[2], 60);
                p.text('(' + currentKenning.meaning + ')', 0, textY + lines.length * 22 + 16);
            }
        }

        // ====================================================================
        // SVG EXPORT ENGINE
        // ====================================================================

        function generateSVG() {
            if (!currentKenning) return null;

            const w = 800;
            const h = 800;
            const text = currentKenning.text || '';
            const runeText = textToRunes(text);
            const runeChars = runeText.replace(/[\s\n]/g, '');
            const c = currentColors.primary;
            const sc = currentColors.secondary;
            const gc = currentColors.glow;
            const bg = currentColors.bg;

            let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${w} ${h}" width="${w}" height="${h}">
  <defs>
    <filter id="glow">
      <feGaussianBlur stdDeviation="3" result="blur"/>
      <feComposite in="SourceGraphic" in2="blur" operator="over"/>
    </filter>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700');
      .rune { font-family: 'Segoe UI Symbol', 'Noto Sans Runic', serif; }
      .latin { font-family: 'Lora', serif; }
    </style>
  </defs>
  <rect width="${w}" height="${h}" fill="rgb(${bg[0]},${bg[1]},${bg[2]})"/>
`;

            const cx = w / 2;
            const cy = h / 2;

            if (currentStyle === 'runic-circle' || currentStyle === 'woven-knot') {
                const radius = 250;

                // Decorative circles
                for (let i = 0; i < 3; i++) {
                    const r = radius + i * 20 + 30;
                    svg += `  <circle cx="${cx}" cy="${cy}" r="${r}" fill="none" stroke="rgb(${c[0]},${c[1]},${c[2]})" stroke-opacity="${0.15 - i * 0.03}" stroke-width="1"/>\n`;
                }

                // Inner circle
                svg += `  <circle cx="${cx}" cy="${cy}" r="${radius * 0.3}" fill="none" stroke="rgb(${c[0]},${c[1]},${c[2]})" stroke-opacity="0.15" stroke-width="0.5"/>\n`;

                // Cross lines
                for (let i = 0; i < 4; i++) {
                    const a = (Math.PI / 4) * i;
                    const x1 = cx + Math.cos(a) * radius * 0.3;
                    const y1 = cy + Math.sin(a) * radius * 0.3;
                    const x2 = cx + Math.cos(a) * radius * 0.92;
                    const y2 = cy + Math.sin(a) * radius * 0.92;
                    svg += `  <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="rgb(${c[0]},${c[1]},${c[2]})" stroke-opacity="0.15" stroke-width="0.5"/>\n`;
                }

                // Runes around circle
                const count = Math.max(runeChars.length, 8);
                const step = (2 * Math.PI) / count;
                svg += `  <g filter="url(#glow)">\n`;
                for (let i = 0; i < runeChars.length; i++) {
                    const a = i * step - Math.PI / 2;
                    const x = cx + Math.cos(a) * radius;
                    const y = cy + Math.sin(a) * radius;
                    const rot = (a + Math.PI / 2) * (180 / Math.PI);
                    svg += `    <text x="${x}" y="${y}" class="rune" font-size="24" fill="rgb(${c[0]},${c[1]},${c[2]})" text-anchor="middle" dominant-baseline="central" transform="rotate(${rot},${x},${y})">${escapeXml(runeChars[i])}</text>\n`;
                }
                svg += `  </g>\n`;

                // Center text
                const lines = text.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    const ty = cy + (i - lines.length / 2) * 22;
                    svg += `  <text x="${cx}" y="${ty}" class="latin" font-size="16" fill="rgb(${sc[0]},${sc[1]},${sc[2]})" fill-opacity="0.8" text-anchor="middle" dominant-baseline="central">${escapeXml(lines[i])}</text>\n`;
                }

                if (currentKenning.meaning) {
                    svg += `  <text x="${cx}" y="${cy + (lines.length / 2) * 22 + 20}" class="latin" font-size="11" fill="rgb(${sc[0]},${sc[1]},${sc[2]})" fill-opacity="0.35" text-anchor="middle" dominant-baseline="central">(${escapeXml(currentKenning.meaning)})</text>\n`;
                }
            } else if (currentStyle === 'stave-column') {
                const colW = 60;
                const totalH = 500;
                const top = cy - totalH / 2;

                // Stave lines
                svg += `  <line x1="${cx - colW / 2}" y1="${top}" x2="${cx - colW / 2}" y2="${top + totalH}" stroke="rgb(${c[0]},${c[1]},${c[2]})" stroke-opacity="0.15" stroke-width="2"/>\n`;
                svg += `  <line x1="${cx + colW / 2}" y1="${top}" x2="${cx + colW / 2}" y2="${top + totalH}" stroke="rgb(${c[0]},${c[1]},${c[2]})" stroke-opacity="0.15" stroke-width="2"/>\n`;

                // Runes
                const spacing = Math.min(36, totalH / Math.max(runeChars.length, 1));
                const startY = cy - ((runeChars.length - 1) * spacing) / 2;

                svg += `  <g filter="url(#glow)">\n`;
                for (let i = 0; i < runeChars.length; i++) {
                    const ry = startY + i * spacing;
                    svg += `    <text x="${cx}" y="${ry}" class="rune" font-size="22" fill="rgb(${c[0]},${c[1]},${c[2]})" text-anchor="middle" dominant-baseline="central">${escapeXml(runeChars[i])}</text>\n`;
                    // Notch lines
                    svg += `    <line x1="${cx - colW / 2}" y1="${ry}" x2="${cx - colW / 2 + 8}" y2="${ry}" stroke="rgb(${c[0]},${c[1]},${c[2]})" stroke-opacity="0.08" stroke-width="0.5"/>\n`;
                    svg += `    <line x1="${cx + colW / 2}" y1="${ry}" x2="${cx + colW / 2 - 8}" y2="${ry}" stroke="rgb(${c[0]},${c[1]},${c[2]})" stroke-opacity="0.08" stroke-width="0.5"/>\n`;
                }
                svg += `  </g>\n`;

                // Latin text
                const lines = text.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    svg += `  <text x="${cx + colW / 2 + 30}" y="${cy + (i - lines.length / 2) * 20}" class="latin" font-size="13" fill="rgb(${sc[0]},${sc[1]},${sc[2]})" fill-opacity="0.7" text-anchor="start" dominant-baseline="central">${escapeXml(lines[i])}</text>\n`;
                }
            } else {
                // Generic: wave/tree/knot - render runes in a line with text
                svg += `  <g filter="url(#glow)">\n`;
                const spacing = Math.min(30, 600 / Math.max(runeChars.length, 1));
                const startX = cx - ((runeChars.length - 1) * spacing) / 2;
                for (let i = 0; i < runeChars.length; i++) {
                    const rx = startX + i * spacing;
                    svg += `    <text x="${rx}" y="${cy - 30}" class="rune" font-size="22" fill="rgb(${c[0]},${c[1]},${c[2]})" text-anchor="middle" dominant-baseline="central">${escapeXml(runeChars[i])}</text>\n`;
                }
                svg += `  </g>\n`;

                const lines = text.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    svg += `  <text x="${cx}" y="${cy + 30 + i * 22}" class="latin" font-size="16" fill="rgb(${sc[0]},${sc[1]},${sc[2]})" fill-opacity="0.8" text-anchor="middle" dominant-baseline="central">${escapeXml(lines[i])}</text>\n`;
                }

                if (currentKenning.meaning) {
                    svg += `  <text x="${cx}" y="${cy + 30 + lines.length * 22 + 16}" class="latin" font-size="11" fill="rgb(${sc[0]},${sc[1]},${sc[2]})" fill-opacity="0.35" text-anchor="middle" dominant-baseline="central">(${escapeXml(currentKenning.meaning)})</text>\n`;
                }
            }

            // Signature
            svg += `  <text x="${w - 20}" y="${h - 15}" class="latin" font-size="8" fill="rgb(${c[0]},${c[1]},${c[2]})" fill-opacity="0.2" text-anchor="end">Kenning Forge Pro</text>\n`;
            svg += `</svg>`;

            return svg;
        }

        function escapeXml(str) {
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        function downloadSVG() {
            const svg = generateSVG();
            if (!svg) return;
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'kenning-forge-' + (currentKenning.text || 'art').replace(/[^a-z0-9]/gi, '-').substring(0, 40) + '.svg';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function downloadPNG() {
            if (!p5Instance) return;
            p5Instance.saveCanvas('kenning-forge-' + Date.now(), 'png');
        }

        function downloadPrintReady() {
            // Generate high-res SVG with print metadata
            const svg = generateSVG();
            if (!svg) return;
            // Add print-ready attributes
            const printSvg = svg.replace(
                'viewBox="0 0 800 800"',
                'viewBox="0 0 800 800" width="3200" height="3200"'
            );
            const blob = new Blob([printSvg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'kenning-forge-PRINT-' + Date.now() + '.svg';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ====================================================================
        // UI CONTROLLER
        // ====================================================================

        const generator = new KenningGenerator();
        let forgedKennings = [];

        function initUI() {
            // Slider value display bindings
            const sliderBindings = [
                ['temperature', 'temp-val'],
                ['depth', 'depth-val'],
                ['archaism', 'archaic-val'],
                ['metaphor', 'metaphor-val'],
                ['alliteration', 'allit-val'],
                ['glow', 'glow-val'],
                ['anim-speed', 'speed-val']
            ];

            for (const [sliderId, valId] of sliderBindings) {
                const slider = document.getElementById(sliderId);
                const valEl = document.getElementById(valId);
                if (slider && valEl) {
                    slider.addEventListener('input', function() {
                        valEl.textContent = this.value;
                        updateGeneratorParams();
                    });
                }
            }

            // Corpus chips
            document.querySelectorAll('.corpus-chip').forEach(chip => {
                chip.addEventListener('click', function() {
                    this.classList.toggle('active');
                    updateGeneratorParams();
                });
            });

            // Domain selector
            document.getElementById('domain').addEventListener('change', updateGeneratorParams);

            // Art style
            document.getElementById('art-style').addEventListener('change', function() {
                currentStyle = this.value;
            });

            // Color scheme
            document.getElementById('color-scheme').addEventListener('change', function() {
                currentColors = COLOR_SCHEMES[this.value] || COLOR_SCHEMES['gold-ink'];
            });

            // Forge buttons
            document.getElementById('btn-forge').addEventListener('click', forgeOne);
            document.getElementById('btn-batch').addEventListener('click', forgeBatch);
            document.getElementById('btn-verse').addEventListener('click', forgeVerse);

            // Export buttons
            document.getElementById('btn-svg').addEventListener('click', downloadSVG);
            document.getElementById('btn-png').addEventListener('click', downloadPNG);
            document.getElementById('btn-print').addEventListener('click', downloadPrintReady);
        }

        function updateGeneratorParams() {
            generator.temperature = parseFloat(document.getElementById('temperature').value);
            generator.compoundDepth = parseInt(document.getElementById('depth').value);
            generator.archaism = parseFloat(document.getElementById('archaism').value);
            generator.metaphorStretch = parseFloat(document.getElementById('metaphor').value);
            generator.alliteration = parseFloat(document.getElementById('alliteration').value);
            generator.domain = document.getElementById('domain').value;
            glowIntensity = parseFloat(document.getElementById('glow').value);
            animSpeed = parseFloat(document.getElementById('anim-speed').value);

            // Update active corpora
            generator.activeCorpora = new Set();
            document.querySelectorAll('.corpus-chip.active').forEach(chip => {
                generator.activeCorpora.add(chip.dataset.corpus);
            });
            if (generator.activeCorpora.size === 0) generator.activeCorpora.add('beowulf');
            generator.buildTransitions();
        }

        function addKenningToList(kenning) {
            forgedKennings.unshift(kenning);
            renderKenningList();
        }

        function renderKenningList() {
            const list = document.getElementById('kenning-list');
            list.innerHTML = '';
            for (let i = 0; i < forgedKennings.length; i++) {
                const k = forgedKennings[i];
                const div = document.createElement('div');
                div.className = 'kenning-item' + (k === currentKenning ? ' selected' : '');
                div.innerHTML = k.text.replace(/\n/g, '<br>') + (k.meaning ? '<span class="meaning">' + k.meaning + '</span>' : '');
                div.addEventListener('click', () => {
                    currentKenning = k;
                    renderKenningList();
                    updateCanvasInfo();
                });
                list.appendChild(div);
            }
        }

        function updateCanvasInfo() {
            const info = document.getElementById('canvas-info');
            if (currentKenning) {
                const runeText = textToRunes(currentKenning.text);
                info.textContent = currentStyle + ' | ' + runeText.replace(/\s/g, '').length + ' runes | ' + currentKenning.text.split('\n').length + ' line(s)';
            } else {
                info.textContent = '';
            }
        }

        function forgeOne() {
            const kenning = generator.forge();
            currentKenning = kenning;
            addKenningToList(kenning);
            updateCanvasInfo();
        }

        function forgeBatch() {
            const batch = generator.forgeBatch(8);
            for (const k of batch) {
                forgedKennings.unshift(k);
            }
            if (batch.length > 0) {
                currentKenning = batch[0];
            }
            renderKenningList();
            updateCanvasInfo();
        }

        function forgeVerse() {
            const verse = generator.forgeVerse();
            currentKenning = verse;
            addKenningToList(verse);
            updateCanvasInfo();
        }

        // ====================================================================
        // INITIALIZATION
        // ====================================================================

        function init() {
            // Check for p5.js
            if (typeof p5 === 'undefined') {
                document.getElementById('loading').innerHTML = '<div style="color: #c9a84c; font-family: Lora, serif; text-align: center;"><p>Failed to load P5.js</p><p style="font-size: 0.8rem; opacity: 0.6;">Check your internet connection and refresh</p></div>';
                return;
            }

            initUI();
            createP5Sketch();

            // Hide loading
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 600);
        }

        // Wait for p5.js to load
        if (typeof p5 !== 'undefined') {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }
        } else {
            // Retry after delay
            let attempts = 0;
            const checkP5 = setInterval(() => {
                attempts++;
                if (typeof p5 !== 'undefined') {
                    clearInterval(checkP5);
                    init();
                } else if (attempts > 50) {
                    clearInterval(checkP5);
                    document.getElementById('loading').innerHTML = '<div style="color: #c9a84c; font-family: Lora, serif; text-align: center;"><p>Failed to load P5.js</p><p style="font-size: 0.8rem; opacity: 0.6;">Check your internet connection and refresh</p></div>';
                }
            }, 200);
        }

    })();
    </script>
</body>
</html>
