<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Shader Demo Template - CCAB</title>
    <link rel="stylesheet" href="../assets/css/navigation.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0e1a;
            color: #e8e6e1;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* Loading State */
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: #f97316;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Error State */
        #error {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(225, 29, 72, 0.9);
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            max-width: 500px;
            z-index: 1001;
        }

        #error h2 {
            margin: 0 0 1rem 0;
            font-size: 1.5rem;
        }

        #error pre {
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            text-align: left;
            font-size: 12px;
        }

        /* Back Link */
        .back-link {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            color: #f97316;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            z-index: 999;
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(249, 115, 22, 0.2);
            transform: translateX(-4px);
        }

        /* WebGL Info */
        #webgl-info {
            position: fixed;
            top: 80px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #f97316;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 999;
        }
    </style>
</head>
<body>
    <!-- Back Navigation -->
    <a href="../webgl-shaders/index.html" class="back-link">‚Üê Back to WebGL Gallery</a>

    <!-- WebGL Info -->
    <div id="webgl-info">
        <div>Resolution: <span id="resolution">0x0</span></div>
        <div>Time: <span id="time">0.00</span>s</div>
    </div>

    <!-- Loading State -->
    <div id="loading">
        <div class="spinner"></div>
        <p>Initializing WebGL...</p>
    </div>

    <!-- Error State -->
    <div id="error">
        <h2>WebGL Error</h2>
        <p id="error-message"></p>
        <pre id="error-details"></pre>
    </div>

    <!-- Canvas Element -->
    <canvas id="canvas"></canvas>

    <script>
        // Error handling
        function showError(message, details = '') {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').style.display = 'block';
            document.getElementById('error-message').textContent = message;
            if (details) {
                document.getElementById('error-details').textContent = details;
            }
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        // WebGL Context Setup
        class WebGLManager {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                if (!this.canvas) {
                    throw new Error('Canvas element not found');
                }

                // Try to get WebGL2 first, fallback to WebGL1
                this.gl = this.canvas.getContext('webgl2') ||
                          this.canvas.getContext('webgl') ||
                          this.canvas.getContext('experimental-webgl');

                if (!this.gl) {
                    throw new Error('WebGL not supported in this browser');
                }

                this.isWebGL2 = this.gl instanceof WebGL2RenderingContext;
                this.resize();

                // Handle resize
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => this.resize(), 150);
                });
            }

            resize() {
                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                const width = window.innerWidth;
                const height = window.innerHeight;

                this.canvas.width = width * dpr;
                this.canvas.height = height * dpr;
                this.canvas.style.width = `${width}px`;
                this.canvas.style.height = `${height}px`;

                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);

                document.getElementById('resolution').textContent =
                    `${this.canvas.width}x${this.canvas.height}`;
            }

            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);

                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    const error = this.gl.getShaderInfoLog(shader);
                    this.gl.deleteShader(shader);
                    throw new Error(`Shader compilation error: ${error}`);
                }

                return shader;
            }

            createProgram(vertexSource, fragmentSource) {
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);

                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);

                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    const error = this.gl.getProgramInfoLog(program);
                    throw new Error(`Program linking error: ${error}`);
                }

                return program;
            }

            createQuad() {
                const positions = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                     1,  1
                ]);

                const buffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);

                return buffer;
            }
        }

        // Main Demo Code
        try {
            const webgl = new WebGLManager('canvas');
            const gl = webgl.gl;

            // ========================================
            // YOUR SHADER CODE GOES HERE
            // ========================================

            // Vertex Shader
            const vertexShaderSource = webgl.isWebGL2 ? `#version 300 es
                in vec2 a_position;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                }
            ` : `
                attribute vec2 a_position;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                }
            `;

            // Fragment Shader - Example: Animated gradient
            const fragmentShaderSource = webgl.isWebGL2 ? `#version 300 es
                precision highp float;
                uniform vec2 u_resolution;
                uniform float u_time;
                out vec4 outColor;

                void main() {
                    vec2 uv = gl_FragCoord.xy / u_resolution;
                    vec3 color = vec3(
                        0.5 + 0.5 * cos(u_time + uv.x),
                        0.5 + 0.5 * cos(u_time + uv.y + 2.0),
                        0.5 + 0.5 * cos(u_time + uv.x + 4.0)
                    );
                    outColor = vec4(color, 1.0);
                }
            ` : `
                precision highp float;
                uniform vec2 u_resolution;
                uniform float u_time;

                void main() {
                    vec2 uv = gl_FragCoord.xy / u_resolution;
                    vec3 color = vec3(
                        0.5 + 0.5 * cos(u_time + uv.x),
                        0.5 + 0.5 * cos(u_time + uv.y + 2.0),
                        0.5 + 0.5 * cos(u_time + uv.x + 4.0)
                    );
                    gl_FragColor = vec4(color, 1.0);
                }
            `;

            // Create program and setup
            const program = webgl.createProgram(vertexShaderSource, fragmentShaderSource);
            const positionBuffer = webgl.createQuad();

            const positionLocation = gl.getAttribLocation(program, 'a_position');
            const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
            const timeLocation = gl.getUniformLocation(program, 'u_time');

            // ========================================

            // Animation loop
            let startTime = Date.now();

            function render() {
                const currentTime = (Date.now() - startTime) / 1000;
                document.getElementById('time').textContent = currentTime.toFixed(2);

                // Use program
                gl.useProgram(program);

                // Set uniforms
                gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
                gl.uniform1f(timeLocation, currentTime);

                // Setup position attribute
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

                // Draw
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                requestAnimationFrame(render);
            }

            hideLoading();
            render();

        } catch (error) {
            showError(error.message, error.stack);
            console.error(error);
        }
    </script>
</body>
</html>
