<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Star System - Unequal Mass</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="info">Binary Star System - Unequal Mass<br>Massive star (3x) with smaller companion</div>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.170.0/build/three.webgpu.js",
            "three/tsl": "https://unpkg.com/three@0.170.0/build/three.webgpu.js",
            "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { color } from 'three/tsl';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        if (!navigator.gpu) {
            document.body.innerHTML = '<div style="color:white;padding:50px;text-align:center;">WebGPU not supported</div>';
            throw new Error('WebGPU not supported');
        }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 15);

        const renderer = new THREE.WebGPURenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        await renderer.init();

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Massive star (3x mass)
        const star1Geo = new THREE.SphereGeometry(0.7, 32, 32);
        const star1Mat = new THREE.MeshBasicNodeMaterial();
        star1Mat.colorNode = color(1.0, 0.3, 0.1);
        const star1 = new THREE.Mesh(star1Geo, star1Mat);
        scene.add(star1);

        // Smaller companion
        const star2Geo = new THREE.SphereGeometry(0.3, 32, 32);
        const star2Mat = new THREE.MeshBasicNodeMaterial();
        star2Mat.colorNode = color(0.3, 0.7, 1.0);
        const star2 = new THREE.Mesh(star2Geo, star2Mat);
        scene.add(star2);

        // Trails
        const trailPoints1 = [];
        const trailPoints2 = [];
        const maxTrailLength = 250;

        const trail1 = new THREE.Line(
            new THREE.BufferGeometry(),
            new THREE.LineBasicMaterial({ color: 0xff5511, transparent: true, opacity: 0.5 })
        );
        scene.add(trail1);

        const trail2 = new THREE.Line(
            new THREE.BufferGeometry(),
            new THREE.LineBasicMaterial({ color: 0x55aaff, transparent: true, opacity: 0.5 })
        );
        scene.add(trail2);

        // Barycenter
        const barycenter = new THREE.Mesh(
            new THREE.SphereGeometry(0.1, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xffff00 })
        );
        scene.add(barycenter);

        const G = 1.0;
        const m1 = 3.0; // Heavy star
        const m2 = 1.0; // Light star
        const a = 7.0; // Semi-major axis

        // Barycenter distances
        const r1 = a * m2 / (m1 + m2);
        const r2 = a * m1 / (m1 + m2);

        const omega = Math.sqrt(G * (m1 + m2) / (a * a * a));

        let state = {
            x1: r1, y1: 0, z1: 0,
            vx1: 0, vy1: 0, vz1: omega * r1,
            x2: -r2, y2: 0, z2: 0,
            vx2: 0, vy2: 0, vz2: -omega * r2
        };

        function updatePhysics(dt) {
            const dx = state.x2 - state.x1;
            const dy = state.y2 - state.y1;
            const dz = state.z2 - state.z1;
            const r = Math.sqrt(dx*dx + dy*dy + dz*dz);
            const force = G * m1 * m2 / (r * r);

            const ax1 = force * dx / (r * m1);
            const ay1 = force * dy / (r * m1);
            const az1 = force * dz / (r * m1);

            const ax2 = -force * dx / (r * m2);
            const ay2 = -force * dy / (r * m2);
            const az2 = -force * dz / (r * m2);

            state.vx1 += ax1 * dt;
            state.vy1 += ay1 * dt;
            state.vz1 += az1 * dt;

            state.vx2 += ax2 * dt;
            state.vy2 += ay2 * dt;
            state.vz2 += az2 * dt;

            state.x1 += state.vx1 * dt;
            state.y1 += state.vy1 * dt;
            state.z1 += state.vz1 * dt;

            state.x2 += state.vx2 * dt;
            state.y2 += state.vy2 * dt;
            state.z2 += state.vz2 * dt;
        }

        let frameCount = 0;
        function animate() {
            requestAnimationFrame(animate);

            const dt = 0.016 / 4;
            for (let i = 0; i < 4; i++) updatePhysics(dt);

            star1.position.set(state.x1, state.y1, state.z1);
            star2.position.set(state.x2, state.y2, state.z2);

            if (frameCount % 3 === 0) {
                trailPoints1.push(new THREE.Vector3(state.x1, state.y1, state.z1));
                trailPoints2.push(new THREE.Vector3(state.x2, state.y2, state.z2));

                if (trailPoints1.length > maxTrailLength) trailPoints1.shift();
                if (trailPoints2.length > maxTrailLength) trailPoints2.shift();

                trail1.geometry.setFromPoints(trailPoints1);
                trail2.geometry.setFromPoints(trailPoints2);
            }
            frameCount++;

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
