<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Star System - Equal Mass</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="info">Binary Star System - Equal Mass<br>Two stars orbiting their common barycenter</div>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.170.0/build/three.webgpu.js",
            "three/tsl": "https://unpkg.com/three@0.170.0/build/three.webgpu.js",
            "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { pass, uniform, texture, positionLocal, color, vec3, vec4, Fn, instanceIndex, storage, float, If } from 'three/tsl';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        if (!navigator.gpu) {
            document.body.innerHTML = '<div style="color:white;padding:50px;text-align:center;">WebGPU not supported in this browser</div>';
            throw new Error('WebGPU not supported');
        }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 15);

        const renderer = new THREE.WebGPURenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        await renderer.init();

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Create two equal-mass stars orbiting barycenter
        const star1Geo = new THREE.SphereGeometry(0.5, 32, 32);
        const star1Mat = new THREE.MeshBasicNodeMaterial();
        star1Mat.colorNode = color(1.0, 0.4, 0.2);
        const star1 = new THREE.Mesh(star1Geo, star1Mat);
        scene.add(star1);

        const star2Geo = new THREE.SphereGeometry(0.5, 32, 32);
        const star2Mat = new THREE.MeshBasicNodeMaterial();
        star2Mat.colorNode = color(0.2, 0.6, 1.0);
        const star2 = new THREE.Mesh(star2Geo, star2Mat);
        scene.add(star2);

        // Trail lines
        const trailPoints1 = [];
        const trailPoints2 = [];
        const maxTrailLength = 200;

        const trail1Geo = new THREE.BufferGeometry();
        const trail1Mat = new THREE.LineBasicMaterial({ color: 0xff6633, transparent: true, opacity: 0.5 });
        const trail1 = new THREE.Line(trail1Geo, trail1Mat);
        scene.add(trail1);

        const trail2Geo = new THREE.BufferGeometry();
        const trail2Mat = new THREE.LineBasicMaterial({ color: 0x3399ff, transparent: true, opacity: 0.5 });
        const trail2 = new THREE.Line(trail2Geo, trail2Mat);
        scene.add(trail2);

        // Barycenter marker
        const baryGeo = new THREE.SphereGeometry(0.1, 16, 16);
        const baryMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const barycenter = new THREE.Mesh(baryGeo, baryMat);
        scene.add(barycenter);

        // Simulation parameters
        const G = 1.0; // Gravitational constant
        const m1 = 1.0; // Equal masses
        const m2 = 1.0;
        const orbitalRadius = 5.0;

        // Initial conditions for circular orbit
        const omega = Math.sqrt(G * (m1 + m2) / Math.pow(2 * orbitalRadius, 3));

        let state = {
            x1: orbitalRadius, y1: 0, z1: 0,
            vx1: 0, vy1: 0, vz1: omega * orbitalRadius,
            x2: -orbitalRadius, y2: 0, z2: 0,
            vx2: 0, vy2: 0, vz2: -omega * orbitalRadius
        };

        function updatePhysics(dt) {
            // Calculate distance and force
            const dx = state.x2 - state.x1;
            const dy = state.y2 - state.y1;
            const dz = state.z2 - state.z1;
            const r = Math.sqrt(dx*dx + dy*dy + dz*dz);
            const force = G * m1 * m2 / (r * r);

            // Acceleration
            const ax1 = force * dx / (r * m1);
            const ay1 = force * dy / (r * m1);
            const az1 = force * dz / (r * m1);

            const ax2 = -force * dx / (r * m2);
            const ay2 = -force * dy / (r * m2);
            const az2 = -force * dz / (r * m2);

            // Velocity Verlet integration
            state.vx1 += ax1 * dt;
            state.vy1 += ay1 * dt;
            state.vz1 += az1 * dt;

            state.vx2 += ax2 * dt;
            state.vy2 += ay2 * dt;
            state.vz2 += az2 * dt;

            state.x1 += state.vx1 * dt;
            state.y1 += state.vy1 * dt;
            state.z1 += state.vz1 * dt;

            state.x2 += state.vx2 * dt;
            state.y2 += state.vy2 * dt;
            state.z2 += state.vz2 * dt;
        }

        let frameCount = 0;
        function animate() {
            requestAnimationFrame(animate);

            // Multiple substeps for stability
            const dt = 0.016 / 4;
            for (let i = 0; i < 4; i++) {
                updatePhysics(dt);
            }

            // Update star positions
            star1.position.set(state.x1, state.y1, state.z1);
            star2.position.set(state.x2, state.y2, state.z2);

            // Update trails every few frames
            if (frameCount % 3 === 0) {
                trailPoints1.push(new THREE.Vector3(state.x1, state.y1, state.z1));
                trailPoints2.push(new THREE.Vector3(state.x2, state.y2, state.z2));

                if (trailPoints1.length > maxTrailLength) trailPoints1.shift();
                if (trailPoints2.length > maxTrailLength) trailPoints2.shift();

                trail1Geo.setFromPoints(trailPoints1);
                trail2Geo.setFromPoints(trailPoints2);
            }
            frameCount++;

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
