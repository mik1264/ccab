<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cellular Potts Model - CCAB</title>
    <link rel="stylesheet" href="../assets/css/navigation.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Spectral:ital,wght@0,400;0,600;1,400&family=Space+Mono:wght@400;700&display=swap');

        :root {
            /* Color scheme matching main index */
            --bg-primary: #0a0e1a;
            --bg-secondary: #111827;
            --text-primary: #e0e0ff;
            --text-secondary: #a0a0c0;
            --text-accent: #fbbf24;
            --theme-color: #667eea;

            /* Spacing */
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;
            --spacing-2xl: 4rem;

            /* Typography */
            --font-display: 'Orbitron', sans-serif;
            --font-heading: 'Spectral', serif;
            --font-mono: 'Space Mono', monospace;
            --font-body: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

            /* Layout */
            --max-width: 1600px;
            --header-height: 64px;

            /* Transitions */
            --transition-base: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: linear-gradient(135deg, var(--bg-primary) 0%, #0f172a 50%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            padding: 20px;
            padding-top: calc(var(--header-height) + 20px);
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            font-family: var(--font-display);
            text-align: center;
            margin-bottom: 10px;
            font-size: clamp(2rem, 5vw, 3rem);
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 50%, var(--theme-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            padding: 12px 24px;
            background: rgba(224, 224, 255, 0.1);
            border: 2px solid rgba(224, 224, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
            color: var(--text-primary);
        }

        .tab:hover {
            background: rgba(224, 224, 255, 0.2);
            transform: translateY(-2px);
        }

        .tab.active {
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border-color: var(--theme-color);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .view {
            display: none;
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .view.active {
            display: block;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        input[type="range"] {
            width: 200px;
        }

        input[type="number"],
        select {
            width: 100px;
            padding: 8px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 1em;
        }

        select {
            cursor: pointer;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
        }

        canvas {
            display: block;
            margin: 20px auto;
            background: #000;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 100%;
        }

        .stats-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: var(--theme-color);
        }

        .stat-label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid var(--theme-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .info-box h3 {
            margin-bottom: 10px;
            color: var(--theme-color);
        }

        .info-box ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        .info-box p {
            line-height: 1.8;
            margin-bottom: 10px;
        }

        .adhesion-matrix {
            display: grid;
            grid-template-columns: auto repeat(3, 1fr);
            gap: 5px;
            margin: 15px 0;
            font-size: 0.9em;
        }

        .adhesion-matrix > div {
            padding: 5px;
            text-align: center;
        }

        .adhesion-matrix .header {
            font-weight: bold;
            color: var(--text-accent);
        }

        .adhesion-matrix input {
            width: 60px;
            padding: 4px;
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.8);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .tabs {
                font-size: 0.9em;
            }

            .tab {
                padding: 8px 16px;
            }

            input[type="range"] {
                width: 150px;
            }
        }
    
        /* Organic Nature Back Link */
        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10000;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #BC6C25;
            text-decoration: none;
            font-family: 'Nunito', -apple-system, BlinkMacSystemFont, sans-serif;
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: rgba(254, 250, 224, 0.95);
            border-radius: 20px;
            border: 2px solid rgba(138, 154, 91, 0.3);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(96, 108, 56, 0.15);
        }
        .organic-back-link:hover {
            background: rgba(254, 250, 224, 1);
            transform: translateX(-5px);
            border-color: #DDA15E;
            box-shadow: 0 6px 20px rgba(96, 108, 56, 0.25);
        }

    </style>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>

    <a href="../index.html" class="organic-back-link">← Back to Gallery</a>

    <!-- Navigation Header -->
    <nav class="ccab-nav">
        <div class="nav-container">
            <a href="../index.html" class="nav-home">
                <span class="nav-logo">CCAB</span>
                <span class="nav-tagline">Claude Code and Algorithmic Beauty</span>
            </a>
            <div class="nav-breadcrumb"></div>
        </div>
    </nav>

    <div class="container">
        <h1>Cellular Potts Model</h1>
        <p class="subtitle">Simulating Cell Sorting, Division, and Chemotaxis</p>

        <div class="tabs">
            <div class="tab active" data-view="sorting">Cell Sorting</div>
            <div class="tab" data-view="division">Cell Division</div>
            <div class="tab" data-view="chemotaxis">Chemotaxis</div>
        </div>

        <!-- Cell Sorting View -->
        <div class="view active" id="sorting">
            <div class="info-box">
                <h3>Differential Adhesion Hypothesis</h3>
                <p>The Cellular Potts Model simulates cell behavior using energy minimization. Cells with different types
                have different adhesion energies - cells prefer to stick to similar types. This leads to spontaneous sorting,
                mimicking how cells self-organize in developing tissues (like oil and water separating).</p>
                <p><strong>Energy:</strong> E = Σ J(τ(i),τ(j)) × (1 - δ(σ(i),σ(j))) + Σ λ(A - A_target)²</p>
                <ul>
                    <li><strong>J:</strong> Adhesion energy between cell types (lower = stronger adhesion)</li>
                    <li><strong>λ:</strong> Area constraint strength</li>
                    <li><strong>Temperature:</strong> Controls randomness (higher = more jiggling)</li>
                </ul>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="temperature">Temperature: <span id="tempVal">10</span></label>
                    <input type="range" id="temperature" min="1" max="50" step="1" value="10">
                </div>
                <div class="control-group">
                    <label for="lambda">Area Constraint (λ): <span id="lambdaVal">2</span></label>
                    <input type="range" id="lambda" min="0.1" max="10" step="0.1" value="2">
                </div>
                <button onclick="toggleSimulation()">Start</button>
                <button onclick="resetSimulation()" class="secondary">Reset</button>
                <button onclick="applyPreset('sorting')" class="secondary">Two Cell Types</button>
            </div>

            <div class="adhesion-matrix">
                <div class="header"></div>
                <div class="header">Medium</div>
                <div class="header">Type 1</div>
                <div class="header">Type 2</div>

                <div class="header">Medium</div>
                <div><input type="number" id="J_00" value="0" readonly></div>
                <div><input type="number" id="J_01" value="12"></div>
                <div><input type="number" id="J_02" value="12"></div>

                <div class="header">Type 1</div>
                <div><input type="number" id="J_10" value="12"></div>
                <div><input type="number" id="J_11" value="2"></div>
                <div><input type="number" id="J_12" value="16"></div>

                <div class="header">Type 2</div>
                <div><input type="number" id="J_20" value="12"></div>
                <div><input type="number" id="J_21" value="16"></div>
                <div><input type="number" id="J_22" value="2"></div>
            </div>

            <canvas id="sortingCanvas"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="mcsSteps">0</div>
                        <div class="stat-label">Monte Carlo Steps</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalEnergy">0</div>
                        <div class="stat-label">Total Energy</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="cellCount">0</div>
                        <div class="stat-label">Cell Count</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Cell Division View -->
        <div class="view" id="division">
            <div class="info-box">
                <h3>Cell Growth and Division</h3>
                <p>Cells grow over time by increasing their target area. When a cell reaches a division threshold,
                it splits into two daughter cells. This models tissue growth and expansion.</p>
                <ul>
                    <li><strong>Growth Rate:</strong> How fast cells increase their target area</li>
                    <li><strong>Division Threshold:</strong> Area at which cells divide</li>
                    <li><strong>Division:</strong> Cell splits along random axis, creating two cells</li>
                </ul>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="growthRate">Growth Rate: <span id="growthVal">0.1</span></label>
                    <input type="range" id="growthRate" min="0.01" max="0.5" step="0.01" value="0.1">
                </div>
                <div class="control-group">
                    <label for="divisionThreshold">Division At: <span id="divThreshVal">100</span> px</label>
                    <input type="range" id="divisionThreshold" min="50" max="200" step="10" value="100">
                </div>
                <button onclick="toggleDivision()">Start</button>
                <button onclick="resetDivision()" class="secondary">Reset</button>
                <button onclick="applyPreset('division')" class="secondary">Single Cell</button>
            </div>

            <canvas id="divisionCanvas"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="divSteps">0</div>
                        <div class="stat-label">Monte Carlo Steps</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="divCellCount">1</div>
                        <div class="stat-label">Cell Count</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="divisionEvents">0</div>
                        <div class="stat-label">Division Events</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Chemotaxis View -->
        <div class="view" id="chemotaxis">
            <div class="info-box">
                <h3>Chemical Gradient Following</h3>
                <p>Cells can respond to chemical gradients by adding an energy bias. Pixels with higher chemical
                concentration have lower energy, causing cells to migrate up the gradient (like bacteria following food).</p>
                <ul>
                    <li><strong>Gradient Strength:</strong> How strongly cells respond to the chemical</li>
                    <li><strong>Gradient Type:</strong> Linear, radial, or custom patterns</li>
                    <li><strong>Migration:</strong> Cells move by preferentially expanding toward higher concentrations</li>
                </ul>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="chemStrength">Gradient Strength: <span id="chemStrVal">5</span></label>
                    <input type="range" id="chemStrength" min="0" max="20" step="1" value="5">
                </div>
                <div class="control-group">
                    <label for="gradientType">Gradient Type:</label>
                    <select id="gradientType">
                        <option value="linear">Linear (Left to Right)</option>
                        <option value="radial">Radial (Center Point)</option>
                        <option value="dual">Dual Sources</option>
                    </select>
                </div>
                <button onclick="toggleChemotaxis()">Start</button>
                <button onclick="resetChemotaxis()" class="secondary">Reset</button>
                <button onclick="applyPreset('chemotaxis')" class="secondary">Single Cell</button>
            </div>

            <canvas id="chemotaxisCanvas"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="chemSteps">0</div>
                        <div class="stat-label">Monte Carlo Steps</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="cellCenterX">0</div>
                        <div class="stat-label">Cell Center X</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="cellCenterY">0</div>
                        <div class="stat-label">Cell Center Y</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global simulation state
        let lattice;
        let cells;
        let nextCellId = 1;
        let width = 200;
        let height = 200;
        let running = false;
        let mcsCount = 0;
        let animationFrame;

        // Cell type colors
        const cellColors = [
            '#000000', // Medium (0)
            '#667eea', // Type 1 (purple/blue)
            '#fbbf24', // Type 2 (gold)
            '#10b981', // Type 3 (green)
            '#f87171', // Type 4 (red)
            '#8b5cf6', // Type 5 (violet)
            '#ec4899', // Type 6 (pink)
            '#14b8a6', // Type 7 (teal)
        ];

        // Cell class
        class Cell {
            constructor(id, type, targetArea) {
                this.id = id;
                this.type = type;
                this.targetArea = targetArea;
                this.area = 0;
                this.pixels = [];
            }
        }

        // Initialize lattice
        function initLattice() {
            lattice = Array(height).fill(null).map(() => Array(width).fill(0));
            cells = new Map();
            nextCellId = 1;
            mcsCount = 0;
        }

        // Add a cell to the lattice
        function addCell(x, y, radius, type) {
            const id = nextCellId++;
            const cell = new Cell(id, type, Math.PI * radius * radius);
            cells.set(id, cell);

            // Fill circular region
            for (let i = Math.max(0, y - radius); i < Math.min(height, y + radius); i++) {
                for (let j = Math.max(0, x - radius); j < Math.min(width, x + radius); j++) {
                    const dx = j - x;
                    const dy = i - y;
                    if (dx * dx + dy * dy <= radius * radius) {
                        lattice[i][j] = id;
                        cell.pixels.push([i, j]);
                        cell.area++;
                    }
                }
            }

            return id;
        }

        // Get adhesion energy from matrix
        function getAdhesion(type1, type2) {
            const id = `J_${type1}${type2}`;
            const elem = document.getElementById(id);
            return elem ? parseFloat(elem.value) : 10;
        }

        // Calculate energy change for pixel copy
        function deltaE(x, y, newCellId) {
            const oldCellId = lattice[y][x];
            if (oldCellId === newCellId) return Infinity; // No change

            const oldType = oldCellId === 0 ? 0 : cells.get(oldCellId).type;
            const newType = newCellId === 0 ? 0 : cells.get(newCellId).type;

            let dE = 0;

            // Adhesion energy change
            const neighbors = [
                [y - 1, x], [y + 1, x], [y, x - 1], [y, x + 1]
            ];

            for (const [ny, nx] of neighbors) {
                if (ny < 0 || ny >= height || nx < 0 || nx >= width) continue;
                const nCellId = lattice[ny][nx];
                if (nCellId === oldCellId) continue; // Skip same cell

                const nType = nCellId === 0 ? 0 : cells.get(nCellId).type;

                // Energy before
                if (nCellId !== oldCellId) {
                    dE -= getAdhesion(oldType, nType);
                }

                // Energy after
                if (nCellId !== newCellId) {
                    dE += getAdhesion(newType, nType);
                }
            }

            // Area constraint energy change
            const lambda = parseFloat(document.getElementById('lambda').value);

            if (oldCellId !== 0) {
                const oldCell = cells.get(oldCellId);
                const oldDiff = oldCell.area - oldCell.targetArea;
                const newOldDiff = (oldCell.area - 1) - oldCell.targetArea;
                dE -= lambda * (oldDiff * oldDiff);
                dE += lambda * (newOldDiff * newOldDiff);
            }

            if (newCellId !== 0) {
                const newCell = cells.get(newCellId);
                const oldDiff = newCell.area - newCell.targetArea;
                const newNewDiff = (newCell.area + 1) - newCell.targetArea;
                dE -= lambda * (oldDiff * oldDiff);
                dE += lambda * (newNewDiff * newNewDiff);
            }

            return dE;
        }

        // Metropolis step
        function metropolisStep() {
            // Pick random boundary pixel
            let x, y, foundBoundary = false;
            let attempts = 0;

            while (!foundBoundary && attempts < 100) {
                x = Math.floor(Math.random() * width);
                y = Math.floor(Math.random() * height);

                // Check if it's at a boundary
                const cellId = lattice[y][x];
                const neighbors = [
                    [y - 1, x], [y + 1, x], [y, x - 1], [y, x + 1]
                ];

                for (const [ny, nx] of neighbors) {
                    if (ny < 0 || ny >= height || nx < 0 || nx >= width) continue;
                    if (lattice[ny][nx] !== cellId) {
                        foundBoundary = true;
                        break;
                    }
                }

                attempts++;
            }

            if (!foundBoundary) return;

            // Pick random neighbor
            const neighbors = [
                [y - 1, x], [y + 1, x], [y, x - 1], [y, x + 1]
            ].filter(([ny, nx]) => ny >= 0 && ny < height && nx >= 0 && nx < width);

            if (neighbors.length === 0) return;

            const [ny, nx] = neighbors[Math.floor(Math.random() * neighbors.length)];
            const neighborCellId = lattice[ny][nx];

            // Calculate energy change
            const dE = deltaE(x, y, neighborCellId);

            // Metropolis criterion
            const temperature = parseFloat(document.getElementById('temperature').value);
            if (dE < 0 || Math.random() < Math.exp(-dE / temperature)) {
                // Accept the copy
                const oldCellId = lattice[y][x];

                // Update lattice
                lattice[y][x] = neighborCellId;

                // Update cell areas
                if (oldCellId !== 0) {
                    const oldCell = cells.get(oldCellId);
                    oldCell.area--;
                    if (oldCell.area === 0) {
                        cells.delete(oldCellId);
                    }
                }

                if (neighborCellId !== 0) {
                    cells.get(neighborCellId).area++;
                }
            }

            mcsCount++;
        }

        // Draw lattice
        function drawLattice(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const cellSize = Math.floor(canvas.width / width);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw cells
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    const cellId = lattice[i][j];
                    if (cellId === 0) {
                        ctx.fillStyle = '#000000';
                    } else {
                        const cell = cells.get(cellId);
                        // Generate color based on cell ID for variety
                        const hue = (cellId * 137.5) % 360;
                        const type = cell ? cell.type : 1;
                        ctx.fillStyle = cellColors[type] || `hsl(${hue}, 70%, 60%)`;
                    }
                    ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                }
            }

            // Draw cell boundaries
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;

            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    const cellId = lattice[i][j];

                    // Check if boundary
                    const neighbors = [
                        [i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]
                    ];

                    for (const [ny, nx] of neighbors) {
                        if (ny < 0 || ny >= height || nx < 0 || nx >= width) continue;
                        if (lattice[ny][nx] !== cellId) {
                            // Draw boundary
                            ctx.strokeRect(j * cellSize, i * cellSize, cellSize, cellSize);
                            break;
                        }
                    }
                }
            }
        }

        // Update statistics
        function updateStats() {
            document.getElementById('mcsSteps').textContent = mcsCount;
            document.getElementById('cellCount').textContent = cells.size;

            // Calculate total energy
            let totalEnergy = 0;
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    const cellId = lattice[i][j];
                    const type = cellId === 0 ? 0 : cells.get(cellId).type;

                    // Adhesion energy
                    const neighbors = [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]];
                    for (const [ny, nx] of neighbors) {
                        if (ny < 0 || ny >= height || nx < 0 || nx >= width) continue;
                        const nCellId = lattice[ny][nx];
                        if (nCellId === cellId) continue;
                        const nType = nCellId === 0 ? 0 : cells.get(nCellId).type;
                        totalEnergy += getAdhesion(type, nType) / 2;
                    }
                }
            }

            // Area constraint energy
            const lambda = parseFloat(document.getElementById('lambda').value);
            for (const cell of cells.values()) {
                const diff = cell.area - cell.targetArea;
                totalEnergy += lambda * diff * diff;
            }

            document.getElementById('totalEnergy').textContent = Math.round(totalEnergy);
        }

        // Animation loop
        function animate() {
            if (!running) return;

            for (let i = 0; i < 100; i++) {
                metropolisStep();
            }

            drawLattice('sortingCanvas');
            updateStats();

            animationFrame = requestAnimationFrame(animate);
        }

        // Toggle simulation
        function toggleSimulation() {
            running = !running;
            event.target.textContent = running ? 'Stop' : 'Start';
            if (running) {
                animate();
            } else {
                cancelAnimationFrame(animationFrame);
            }
        }

        // Reset simulation
        function resetSimulation() {
            running = false;
            cancelAnimationFrame(animationFrame);
            document.querySelector('#sorting button').textContent = 'Start';

            initLattice();

            // Add cells in a mixed configuration
            const cellRadius = 15;
            for (let i = 0; i < 10; i++) {
                const x = Math.floor(Math.random() * width);
                const y = Math.floor(Math.random() * height);
                const type = i % 2 + 1;
                addCell(x, y, cellRadius, type);
            }

            drawLattice('sortingCanvas');
            updateStats();
        }

        // Apply preset
        function applyPreset(type) {
            initLattice();

            if (type === 'sorting') {
                // Two cell types mixed together
                for (let i = 0; i < 5; i++) {
                    addCell(50 + Math.random() * 50, 50 + Math.random() * 50, 12, 1);
                    addCell(100 + Math.random() * 50, 100 + Math.random() * 50, 12, 2);
                }
            } else if (type === 'division') {
                // Single cell in center
                addCell(width / 2, height / 2, 15, 1);
            } else if (type === 'chemotaxis') {
                // Single cell on left
                addCell(30, height / 2, 15, 1);
            }

            const canvasId = type === 'sorting' ? 'sortingCanvas' :
                           type === 'division' ? 'divisionCanvas' : 'chemotaxisCanvas';
            drawLattice(canvasId);
            updateStats();
        }

        // Division simulation (simplified for this demo)
        let divisionRunning = false;
        let divisionCount = 0;

        function toggleDivision() {
            divisionRunning = !divisionRunning;
            event.target.textContent = divisionRunning ? 'Stop' : 'Start';
            if (divisionRunning) {
                animateDivision();
            }
        }

        function resetDivision() {
            divisionRunning = false;
            divisionCount = 0;
            initLattice();
            addCell(width / 2, height / 2, 15, 1);
            drawLattice('divisionCanvas');
            document.getElementById('divSteps').textContent = '0';
            document.getElementById('divCellCount').textContent = '1';
            document.getElementById('divisionEvents').textContent = '0';
        }

        function animateDivision() {
            if (!divisionRunning) return;

            // Metropolis steps
            for (let i = 0; i < 100; i++) {
                metropolisStep();
            }

            // Check for division
            const growthRate = parseFloat(document.getElementById('growthRate').value);
            const divThreshold = parseFloat(document.getElementById('divisionThreshold').value);

            for (const cell of cells.values()) {
                cell.targetArea += growthRate;

                // Divide if too large
                if (cell.area > divThreshold && cells.size < 20) {
                    divideCell(cell.id);
                    divisionCount++;
                }
            }

            drawLattice('divisionCanvas');
            document.getElementById('divSteps').textContent = mcsCount;
            document.getElementById('divCellCount').textContent = cells.size;
            document.getElementById('divisionEvents').textContent = divisionCount;

            requestAnimationFrame(animateDivision);
        }

        function divideCell(cellId) {
            const cell = cells.get(cellId);
            if (!cell || cell.area < 20) return;

            // Create new cell
            const newCellId = nextCellId++;
            const newCell = new Cell(newCellId, cell.type, cell.targetArea / 2);
            cells.set(newCellId, newCell);

            // Split cell area roughly in half
            const pixels = [];
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    if (lattice[i][j] === cellId) {
                        pixels.push([i, j]);
                    }
                }
            }

            // Randomly assign half to new cell
            for (let i = 0; i < pixels.length / 2; i++) {
                const [y, x] = pixels[i];
                lattice[y][x] = newCellId;
                newCell.area++;
            }

            cell.area = pixels.length - newCell.area;
            cell.targetArea /= 2;
        }

        // Chemotaxis simulation
        let chemotaxisRunning = false;
        let chemicalField;

        function toggleChemotaxis() {
            chemotaxisRunning = !chemotaxisRunning;
            event.target.textContent = chemotaxisRunning ? 'Stop' : 'Start';
            if (chemotaxisRunning) {
                setupChemicalField();
                animateChemotaxis();
            }
        }

        function resetChemotaxis() {
            chemotaxisRunning = false;
            initLattice();
            addCell(30, height / 2, 15, 1);
            setupChemicalField();
            drawLattice('chemotaxisCanvas');
            document.getElementById('chemSteps').textContent = '0';
        }

        function setupChemicalField() {
            chemicalField = Array(height).fill(null).map(() => Array(width).fill(0));
            const type = document.getElementById('gradientType').value;

            if (type === 'linear') {
                for (let i = 0; i < height; i++) {
                    for (let j = 0; j < width; j++) {
                        chemicalField[i][j] = j / width;
                    }
                }
            } else if (type === 'radial') {
                const cx = width * 0.75;
                const cy = height / 2;
                const maxDist = Math.sqrt(width * width + height * height);
                for (let i = 0; i < height; i++) {
                    for (let j = 0; j < width; j++) {
                        const dist = Math.sqrt((j - cx) ** 2 + (i - cy) ** 2);
                        chemicalField[i][j] = 1 - dist / maxDist;
                    }
                }
            } else {
                // Dual sources
                for (let i = 0; i < height; i++) {
                    for (let j = 0; j < width; j++) {
                        const d1 = Math.sqrt((j - width * 0.25) ** 2 + (i - height * 0.25) ** 2);
                        const d2 = Math.sqrt((j - width * 0.75) ** 2 + (i - height * 0.75) ** 2);
                        chemicalField[i][j] = Math.exp(-d1 / 50) + Math.exp(-d2 / 50);
                    }
                }
            }
        }

        function animateChemotaxis() {
            if (!chemotaxisRunning) return;

            const strength = parseFloat(document.getElementById('chemStrength').value);

            // Modified metropolis with chemotaxis bias
            for (let i = 0; i < 100; i++) {
                let x = Math.floor(Math.random() * width);
                let y = Math.floor(Math.random() * height);

                const neighbors = [
                    [y - 1, x], [y + 1, x], [y, x - 1], [y, x + 1]
                ].filter(([ny, nx]) => ny >= 0 && ny < height && nx >= 0 && nx < width);

                if (neighbors.length === 0) continue;

                const [ny, nx] = neighbors[Math.floor(Math.random() * neighbors.length)];
                const neighborCellId = lattice[ny][nx];

                let dE = deltaE(x, y, neighborCellId);

                // Add chemical bias
                dE -= strength * (chemicalField[y][x] - chemicalField[ny][nx]);

                const temperature = parseFloat(document.getElementById('temperature').value);
                if (dE < 0 || Math.random() < Math.exp(-dE / temperature)) {
                    const oldCellId = lattice[y][x];
                    lattice[y][x] = neighborCellId;

                    if (oldCellId !== 0) {
                        cells.get(oldCellId).area--;
                    }
                    if (neighborCellId !== 0) {
                        cells.get(neighborCellId).area++;
                    }
                }

                mcsCount++;
            }

            drawLattice('chemotaxisCanvas');

            // Update cell center
            let sumX = 0, sumY = 0, count = 0;
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    if (lattice[i][j] !== 0) {
                        sumX += j;
                        sumY += i;
                        count++;
                    }
                }
            }

            if (count > 0) {
                document.getElementById('cellCenterX').textContent = Math.round(sumX / count);
                document.getElementById('cellCenterY').textContent = Math.round(sumY / count);
            }

            document.getElementById('chemSteps').textContent = mcsCount;

            requestAnimationFrame(animateChemotaxis);
        }

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.view).classList.add('active');
            });
        });

        // Update slider values
        document.getElementById('temperature').addEventListener('input', (e) => {
            document.getElementById('tempVal').textContent = e.target.value;
        });

        document.getElementById('lambda').addEventListener('input', (e) => {
            document.getElementById('lambdaVal').textContent = e.target.value;
        });

        document.getElementById('growthRate').addEventListener('input', (e) => {
            document.getElementById('growthVal').textContent = e.target.value;
        });

        document.getElementById('divisionThreshold').addEventListener('input', (e) => {
            document.getElementById('divThreshVal').textContent = e.target.value;
        });

        document.getElementById('chemStrength').addEventListener('input', (e) => {
            document.getElementById('chemStrVal').textContent = e.target.value;
        });

        // Initialize
        window.addEventListener('load', () => {
            const canvases = ['sortingCanvas', 'divisionCanvas', 'chemotaxisCanvas'];
            canvases.forEach(id => {
                const canvas = document.getElementById(id);
                canvas.width = Math.min(600, window.innerWidth - 100);
                canvas.height = canvas.width;
            });

            // Initialize with sorting preset
            applyPreset('sorting');
        });
    </script>
    <script src="../assets/js/navigation.js"></script>
</body>
</html>
