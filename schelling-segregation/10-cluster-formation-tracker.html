<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cluster Formation Tracker - Schelling Model</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 2em;
        }
        .description {
            max-width: 900px;
            text-align: center;
            margin-bottom: 20px;
            opacity: 0.95;
            line-height: 1.6;
        }
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 1100px;
            color: #333;
        }
        .main-grid {
            display: grid;
            grid-template-columns: 550px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        canvas {
            border: 2px solid #ddd;
            border-radius: 8px;
            display: block;
        }
        #gridCanvas {
            background: white;
        }
        #chartCanvas {
            background: #f8f9fa;
        }
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        .stats {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 10px;
        }
        .stat {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-label {
            opacity: 0.9;
            font-size: 11px;
        }
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            margin-top: 3px;
        }
        .cluster-info {
            margin-top: 10px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 13px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Cluster Formation Tracker</h1>
    <div class="description">
        Track how clusters form and merge over time. The simulation starts with many small clusters
        (high count) that consolidate into fewer, larger segregated regions (low count, high size).
        The graph shows cluster count evolution through the four phases.
    </div>

    <div class="container">
        <div class="main-grid">
            <canvas id="gridCanvas" width="550" height="550"></canvas>
            <canvas id="chartCanvas" width="450" height="550"></canvas>
        </div>

        <div class="cluster-info">
            <strong>Current Phase:</strong> <span id="phaseInfo">Initial Chaos - Many small clusters forming</span>
        </div>

        <div class="controls">
            <button id="resetBtn">Reset</button>
            <button id="pauseBtn">Pause</button>
            <button id="speedBtn">Speed: 1x</button>
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-label">Iteration</div>
                <div class="stat-value" id="iterations">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Total Clusters</div>
                <div class="stat-value" id="totalClusters">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Red Clusters</div>
                <div class="stat-value" id="redClusters">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Green Clusters</div>
                <div class="stat-value" id="greenClusters">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Avg Cluster Size</div>
                <div class="stat-value" id="avgSize">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Largest Cluster</div>
                <div class="stat-value" id="maxSize">0</div>
            </div>
        </div>
    </div>

    <script>
        const gridCanvas = document.getElementById('gridCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const chartCanvas = document.getElementById('chartCanvas');
        const chartCtx = chartCanvas.getContext('2d');

        const GRID_SIZE = 50;
        const CELL_SIZE = gridCanvas.width / GRID_SIZE;
        const DENSITY = 0.85;
        const SIMILARITY_THRESHOLD = 0.30;
        const MAX_SEARCH_ATTEMPTS = 50;
        const EMPTY = 0, RED = 1, GREEN = 2;

        let grid = [];
        let agents = [];
        let paused = false;
        let iterations = 0;
        let speed = 1;

        let clusterHistory = [];
        const MAX_HISTORY = 500;

        class Agent {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.happy = false;
            }

            getNeighbors() {
                const neighbors = [];
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = (this.x + dx + GRID_SIZE) % GRID_SIZE;
                        const ny = (this.y + dy + GRID_SIZE) % GRID_SIZE;
                        if (grid[ny][nx] !== EMPTY) {
                            neighbors.push(grid[ny][nx]);
                        }
                    }
                }
                return neighbors;
            }

            checkHappiness() {
                const neighbors = this.getNeighbors();
                if (neighbors.length === 0) {
                    this.happy = true;
                    return;
                }

                const similar = neighbors.filter(n => n === this.type).length;
                const similarity = similar / neighbors.length;
                this.happy = similarity >= SIMILARITY_THRESHOLD;
            }

            findEmptySpot() {
                for (let attempt = 0; attempt < MAX_SEARCH_ATTEMPTS; attempt++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 10;
                    const nx = Math.round(this.x + Math.cos(angle) * distance);
                    const ny = Math.round(this.y + Math.sin(angle) * distance);
                    const wx = (nx + GRID_SIZE) % GRID_SIZE;
                    const wy = (ny + GRID_SIZE) % GRID_SIZE;

                    if (grid[wy][wx] === EMPTY) {
                        return { x: wx, y: wy };
                    }
                }
                return null;
            }

            move() {
                const newSpot = this.findEmptySpot();
                if (newSpot) {
                    grid[this.y][this.x] = EMPTY;
                    this.x = newSpot.x;
                    this.y = newSpot.y;
                    grid[this.y][this.x] = this.type;
                    return true;
                }
                return false;
            }
        }

        function initializeGrid() {
            grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(EMPTY));
            agents = [];
            iterations = 0;
            clusterHistory = [];

            const totalCells = GRID_SIZE * GRID_SIZE;
            const agentCount = Math.floor(totalCells * DENSITY);
            const positions = [];

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    positions.push({ x, y });
                }
            }

            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }

            for (let i = 0; i < agentCount; i++) {
                const pos = positions[i];
                const type = i < agentCount / 2 ? RED : GREEN;
                const agent = new Agent(pos.x, pos.y, type);
                agents.push(agent);
                grid[pos.y][pos.x] = type;
            }
        }

        function analyzeClusters() {
            const visited = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(false));
            const clusters = { [RED]: [], [GREEN]: [] };

            function dfs(x, y, type) {
                if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return 0;
                if (visited[y][x] || grid[y][x] !== type) return 0;

                visited[y][x] = true;
                let size = 1;

                size += dfs(x + 1, y, type);
                size += dfs(x - 1, y, type);
                size += dfs(x, y + 1, type);
                size += dfs(x, y - 1, type);

                return size;
            }

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (!visited[y][x] && grid[y][x] !== EMPTY) {
                        const type = grid[y][x];
                        const size = dfs(x, y, type);
                        clusters[type].push(size);
                    }
                }
            }

            return clusters;
        }

        function update() {
            agents.forEach(agent => agent.checkHappiness());

            const unhappy = agents.filter(a => !a.happy);
            for (let i = unhappy.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [unhappy[i], unhappy[j]] = [unhappy[j], unhappy[i]];
            }

            unhappy.forEach(agent => agent.move());

            // Analyze clusters
            const clusters = analyzeClusters();
            const totalCount = clusters[RED].length + clusters[GREEN].length;

            clusterHistory.push({
                total: totalCount,
                red: clusters[RED].length,
                green: clusters[GREEN].length,
                sizes: [...clusters[RED], ...clusters[GREEN]]
            });

            if (clusterHistory.length > MAX_HISTORY) {
                clusterHistory.shift();
            }

            iterations++;
            updatePhaseInfo();
        }

        function updatePhaseInfo() {
            const phaseEl = document.getElementById('phaseInfo');
            if (iterations < 50) {
                phaseEl.textContent = 'Phase 1: Initial Chaos - Many small clusters forming';
            } else if (iterations < 200) {
                phaseEl.textContent = 'Phase 2: Nucleation - Clusters beginning to stabilize';
            } else if (iterations < 500) {
                phaseEl.textContent = 'Phase 3: Consolidation - Clusters merging and growing';
            } else {
                phaseEl.textContent = 'Phase 4: Equilibrium - Stable segregated regions';
            }
        }

        function drawGrid() {
            gridCtx.fillStyle = '#f0f0f0';
            gridCtx.fillRect(0, 0, gridCanvas.width, gridCanvas.height);

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = grid[y][x];
                    if (cell === RED) {
                        gridCtx.fillStyle = '#e74c3c';
                    } else if (cell === GREEN) {
                        gridCtx.fillStyle = '#2ecc71';
                    } else {
                        continue;
                    }

                    gridCtx.fillRect(
                        x * CELL_SIZE + 1,
                        y * CELL_SIZE + 1,
                        CELL_SIZE - 2,
                        CELL_SIZE - 2
                    );
                }
            }
        }

        function drawChart() {
            const padding = 40;
            const chartWidth = chartCanvas.width - padding * 2;
            const chartHeight = chartCanvas.height - padding * 2;

            chartCtx.fillStyle = '#f8f9fa';
            chartCtx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);

            // Draw axes
            chartCtx.strokeStyle = '#333';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();
            chartCtx.moveTo(padding, padding);
            chartCtx.lineTo(padding, chartCanvas.height - padding);
            chartCtx.lineTo(chartCanvas.width - padding, chartCanvas.height - padding);
            chartCtx.stroke();

            // Labels
            chartCtx.fillStyle = '#333';
            chartCtx.font = '12px sans-serif';
            chartCtx.textAlign = 'center';
            chartCtx.fillText('Time (iterations)', chartCanvas.width / 2, chartCanvas.height - 10);

            chartCtx.save();
            chartCtx.translate(15, chartCanvas.height / 2);
            chartCtx.rotate(-Math.PI / 2);
            chartCtx.fillText('Cluster Count', 0, 0);
            chartCtx.restore();

            if (clusterHistory.length < 2) return;

            const maxClusters = Math.max(...clusterHistory.map(h => h.total));

            // Y-axis labels
            chartCtx.textAlign = 'right';
            for (let i = 0; i <= maxClusters; i += Math.ceil(maxClusters / 5)) {
                const y = chartCanvas.height - padding - (i / maxClusters) * chartHeight;
                chartCtx.fillText(i, padding - 5, y + 4);

                chartCtx.strokeStyle = '#ddd';
                chartCtx.lineWidth = 1;
                chartCtx.beginPath();
                chartCtx.moveTo(padding, y);
                chartCtx.lineTo(chartCanvas.width - padding, y);
                chartCtx.stroke();
            }

            // Draw total cluster line
            chartCtx.strokeStyle = '#667eea';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();
            for (let i = 0; i < clusterHistory.length; i++) {
                const x = padding + (i / MAX_HISTORY) * chartWidth;
                const y = chartCanvas.height - padding -
                         (clusterHistory[i].total / maxClusters) * chartHeight;
                if (i === 0) {
                    chartCtx.moveTo(x, y);
                } else {
                    chartCtx.lineTo(x, y);
                }
            }
            chartCtx.stroke();

            // Draw red clusters line
            chartCtx.strokeStyle = '#e74c3c';
            chartCtx.lineWidth = 1.5;
            chartCtx.beginPath();
            for (let i = 0; i < clusterHistory.length; i++) {
                const x = padding + (i / MAX_HISTORY) * chartWidth;
                const y = chartCanvas.height - padding -
                         (clusterHistory[i].red / maxClusters) * chartHeight;
                if (i === 0) {
                    chartCtx.moveTo(x, y);
                } else {
                    chartCtx.lineTo(x, y);
                }
            }
            chartCtx.stroke();

            // Draw green clusters line
            chartCtx.strokeStyle = '#2ecc71';
            chartCtx.lineWidth = 1.5;
            chartCtx.beginPath();
            for (let i = 0; i < clusterHistory.length; i++) {
                const x = padding + (i / MAX_HISTORY) * chartWidth;
                const y = chartCanvas.height - padding -
                         (clusterHistory[i].green / maxClusters) * chartHeight;
                if (i === 0) {
                    chartCtx.moveTo(x, y);
                } else {
                    chartCtx.lineTo(x, y);
                }
            }
            chartCtx.stroke();
        }

        function updateStats() {
            document.getElementById('iterations').textContent = iterations;

            if (clusterHistory.length > 0) {
                const latest = clusterHistory[clusterHistory.length - 1];
                document.getElementById('totalClusters').textContent = latest.total;
                document.getElementById('redClusters').textContent = latest.red;
                document.getElementById('greenClusters').textContent = latest.green;

                if (latest.sizes.length > 0) {
                    const avgSize = Math.round(latest.sizes.reduce((a, b) => a + b, 0) / latest.sizes.length);
                    const maxSize = Math.max(...latest.sizes);
                    document.getElementById('avgSize').textContent = avgSize;
                    document.getElementById('maxSize').textContent = maxSize;
                }
            }
        }

        function animate() {
            if (!paused) {
                for (let i = 0; i < speed; i++) {
                    update();
                }
            }
            drawGrid();
            drawChart();
            updateStats();
            requestAnimationFrame(animate);
        }

        document.getElementById('resetBtn').addEventListener('click', () => {
            initializeGrid();
        });

        document.getElementById('pauseBtn').addEventListener('click', (e) => {
            paused = !paused;
            e.target.textContent = paused ? 'Resume' : 'Pause';
        });

        document.getElementById('speedBtn').addEventListener('click', (e) => {
            speed = speed === 1 ? 5 : speed === 5 ? 10 : 1;
            e.target.textContent = `Speed: ${speed}x`;
        });

        initializeGrid();
        animate();
    </script>
</body>
</html>
