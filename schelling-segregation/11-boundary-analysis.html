<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boundary Analysis - Schelling Model</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 2em;
        }
        .description {
            max-width: 800px;
            text-align: center;
            margin-bottom: 20px;
            opacity: 0.95;
            line-height: 1.6;
        }
        .container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: white;
            display: block;
        }
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            color: #66a6ff;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        button:hover {
            background: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        .stats {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
        }
        .stat {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-label {
            opacity: 0.9;
            font-size: 12px;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            margin-top: 5px;
        }
        .legend {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 14px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.15);
            padding: 8px 12px;
            border-radius: 8px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid white;
        }
    </style>
</head>
<body>
    <h1>Boundary Analysis</h1>
    <div class="description">
        Highlight agents on cluster boundaries. Boundary agents (shown with white borders) have
        mixed neighborhoods and are most likely to move. Interior agents (solid fill) are
        surrounded by similar neighbors and remain happy. Watch boundary erosion during consolidation.
    </div>

    <div class="container">
        <canvas id="canvas" width="700" height="700"></canvas>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #e74c3c;"></div>
                <span>Red Interior</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #e74c3c; border: 3px solid white;"></div>
                <span>Red Boundary</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #2ecc71;"></div>
                <span>Green Interior</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #2ecc71; border: 3px solid white;"></div>
                <span>Green Boundary</span>
            </div>
        </div>

        <div class="controls">
            <button id="resetBtn">Reset</button>
            <button id="pauseBtn">Pause</button>
            <button id="speedBtn">Speed: 1x</button>
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-label">Iterations</div>
                <div class="stat-value" id="iterations">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Boundary Agents</div>
                <div class="stat-value" id="boundary">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">% Boundary</div>
                <div class="stat-value" id="boundaryPercent">0%</div>
            </div>
            <div class="stat">
                <div class="stat-label">Interior Agents</div>
                <div class="stat-value" id="interior">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">% Unhappy</div>
                <div class="stat-value" id="unhappy">0%</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const GRID_SIZE = 50;
        const CELL_SIZE = canvas.width / GRID_SIZE;
        const DENSITY = 0.85;
        const SIMILARITY_THRESHOLD = 0.30;
        const MAX_SEARCH_ATTEMPTS = 50;
        const EMPTY = 0, RED = 1, GREEN = 2;

        let grid = [];
        let agents = [];
        let paused = false;
        let iterations = 0;
        let speed = 1;

        class Agent {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.happy = false;
                this.isBoundary = false;
            }

            getNeighbors() {
                const neighbors = [];
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = (this.x + dx + GRID_SIZE) % GRID_SIZE;
                        const ny = (this.y + dy + GRID_SIZE) % GRID_SIZE;
                        if (grid[ny][nx] !== EMPTY) {
                            neighbors.push(grid[ny][nx]);
                        }
                    }
                }
                return neighbors;
            }

            checkHappiness() {
                const neighbors = this.getNeighbors();
                if (neighbors.length === 0) {
                    this.happy = true;
                    this.isBoundary = false;
                    return;
                }

                const similar = neighbors.filter(n => n === this.type).length;
                const different = neighbors.length - similar;
                const similarity = similar / neighbors.length;

                this.happy = similarity >= SIMILARITY_THRESHOLD;
                // Boundary: has at least one different neighbor
                this.isBoundary = different > 0;
            }

            findEmptySpot() {
                for (let attempt = 0; attempt < MAX_SEARCH_ATTEMPTS; attempt++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 10;
                    const nx = Math.round(this.x + Math.cos(angle) * distance);
                    const ny = Math.round(this.y + Math.sin(angle) * distance);
                    const wx = (nx + GRID_SIZE) % GRID_SIZE;
                    const wy = (ny + GRID_SIZE) % GRID_SIZE;

                    if (grid[wy][wx] === EMPTY) {
                        return { x: wx, y: wy };
                    }
                }
                return null;
            }

            move() {
                const newSpot = this.findEmptySpot();
                if (newSpot) {
                    grid[this.y][this.x] = EMPTY;
                    this.x = newSpot.x;
                    this.y = newSpot.y;
                    grid[this.y][this.x] = this.type;
                    return true;
                }
                return false;
            }
        }

        function initializeGrid() {
            grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(EMPTY));
            agents = [];
            iterations = 0;

            const totalCells = GRID_SIZE * GRID_SIZE;
            const agentCount = Math.floor(totalCells * DENSITY);
            const positions = [];

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    positions.push({ x, y });
                }
            }

            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }

            for (let i = 0; i < agentCount; i++) {
                const pos = positions[i];
                const type = i < agentCount / 2 ? RED : GREEN;
                const agent = new Agent(pos.x, pos.y, type);
                agents.push(agent);
                grid[pos.y][pos.x] = type;
            }
        }

        function update() {
            agents.forEach(agent => agent.checkHappiness());

            const unhappy = agents.filter(a => !a.happy);
            for (let i = unhappy.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [unhappy[i], unhappy[j]] = [unhappy[j], unhappy[i]];
            }

            unhappy.forEach(agent => agent.move());
            iterations++;
        }

        function draw() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = grid[y][x];
                    if (cell === EMPTY) continue;

                    // Find the agent at this position
                    const agent = agents.find(a => a.x === x && a.y === y);
                    if (!agent) continue;

                    if (cell === RED) {
                        ctx.fillStyle = '#e74c3c';
                    } else if (cell === GREEN) {
                        ctx.fillStyle = '#2ecc71';
                    }

                    const px = x * CELL_SIZE + 1;
                    const py = y * CELL_SIZE + 1;
                    const size = CELL_SIZE - 2;

                    ctx.fillRect(px, py, size, size);

                    // Draw white border for boundary agents
                    if (agent.isBoundary) {
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(px + 1, py + 1, size - 2, size - 2);
                    }
                }
            }

            updateStats();
        }

        function updateStats() {
            document.getElementById('iterations').textContent = iterations;

            const boundaryCount = agents.filter(a => a.isBoundary).length;
            const interiorCount = agents.length - boundaryCount;
            const boundaryPercent = (boundaryCount / agents.length * 100).toFixed(1);

            document.getElementById('boundary').textContent = boundaryCount;
            document.getElementById('boundaryPercent').textContent = boundaryPercent + '%';
            document.getElementById('interior').textContent = interiorCount;

            const unhappyCount = agents.filter(a => !a.happy).length;
            const unhappyPercent = (unhappyCount / agents.length * 100).toFixed(1);
            document.getElementById('unhappy').textContent = unhappyPercent + '%';
        }

        function animate() {
            if (!paused) {
                for (let i = 0; i < speed; i++) {
                    update();
                }
            }
            draw();
            requestAnimationFrame(animate);
        }

        document.getElementById('resetBtn').addEventListener('click', () => {
            initializeGrid();
        });

        document.getElementById('pauseBtn').addEventListener('click', (e) => {
            paused = !paused;
            e.target.textContent = paused ? 'Resume' : 'Pause';
        });

        document.getElementById('speedBtn').addEventListener('click', (e) => {
            speed = speed === 1 ? 5 : speed === 5 ? 10 : 1;
            e.target.textContent = `Speed: ${speed}x`;
        });

        initializeGrid();
        animate();
    </script>
</body>
</html>
