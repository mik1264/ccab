<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Historical Movement Traces - Schelling Model</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #134e5e 0%, #71b280 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
        }
        h1 { margin: 0 0 10px 0; font-size: 2em; }
        .description {
            max-width: 800px;
            text-align: center;
            margin-bottom: 20px;
            opacity: 0.95;
            line-height: 1.6;
        }
        .container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: #1a1a1a;
            display: block;
        }
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            color: #134e5e;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        button:hover {
            background: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        .stats {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
        }
        .stat {
            background: rgba(255, 255, 255, 0.15);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-label { opacity: 0.9; font-size: 12px; }
        .stat-value { font-size: 20px; font-weight: bold; margin-top: 3px; }
    </style>
</head>
<body>
    <h1>Historical Movement Traces</h1>
    <div class="description">
        Persistent movement traces show the full history of agent relocations. Bright trails indicate
        recent moves, fading over time. Watch how initial chaos (dense trails everywhere) gives way
        to sparse boundary movements as segregation stabilizes.
    </div>

    <div class="container">
        <canvas id="canvas" width="700" height="700"></canvas>

        <div class="controls">
            <button id="resetBtn">Reset</button>
            <button id="pauseBtn">Pause</button>
            <button id="clearBtn">Clear Traces</button>
            <button id="fadeBtn">Fade: Slow</button>
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-label">Iterations</div>
                <div class="stat-value" id="iterations">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Total Moves</div>
                <div class="stat-value" id="moves">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Active Trails</div>
                <div class="stat-value" id="trails">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">% Unhappy</div>
                <div class="stat-value" id="unhappy">0%</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const GRID_SIZE = 50, CELL_SIZE = canvas.width / GRID_SIZE;
        const DENSITY = 0.85, SIMILARITY_THRESHOLD = 0.30, MAX_SEARCH_ATTEMPTS = 50;
        const EMPTY = 0, RED = 1, GREEN = 2;

        let grid = [], agents = [], paused = false, iterations = 0, totalMoves = 0;
        let trails = [];
        let fadeSpeed = 'slow'; // slow, medium, fast
        const fadeSpeeds = { slow: 300, medium: 150, fast: 60 };

        class Agent {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; this.happy = false;
            }
            getNeighbors() {
                const neighbors = [];
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = (this.x + dx + GRID_SIZE) % GRID_SIZE;
                        const ny = (this.y + dy + GRID_SIZE) % GRID_SIZE;
                        if (grid[ny][nx] !== EMPTY) neighbors.push(grid[ny][nx]);
                    }
                }
                return neighbors;
            }
            checkHappiness() {
                const neighbors = this.getNeighbors();
                if (neighbors.length === 0) { this.happy = true; return; }
                const similar = neighbors.filter(n => n === this.type).length;
                this.happy = similar / neighbors.length >= SIMILARITY_THRESHOLD;
            }
            findEmptySpot() {
                for (let attempt = 0; attempt < MAX_SEARCH_ATTEMPTS; attempt++) {
                    const angle = Math.random() * Math.PI * 2, distance = Math.random() * 10;
                    const wx = (Math.round(this.x + Math.cos(angle) * distance) + GRID_SIZE) % GRID_SIZE;
                    const wy = (Math.round(this.y + Math.sin(angle) * distance) + GRID_SIZE) % GRID_SIZE;
                    if (grid[wy][wx] === EMPTY) return { x: wx, y: wy };
                }
                return null;
            }
            move() {
                const newSpot = this.findEmptySpot();
                if (newSpot) {
                    trails.push({
                        fromX: this.x, fromY: this.y,
                        toX: newSpot.x, toY: newSpot.y,
                        type: this.type, age: 0
                    });
                    grid[this.y][this.x] = EMPTY;
                    this.x = newSpot.x; this.y = newSpot.y;
                    grid[this.y][this.x] = this.type;
                    totalMoves++;
                    return true;
                }
                return false;
            }
        }

        function initializeGrid() {
            grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(EMPTY));
            agents = []; iterations = 0; totalMoves = 0; trails = [];
            const positions = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) positions.push({ x, y });
            }
            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }
            const agentCount = Math.floor(GRID_SIZE * GRID_SIZE * DENSITY);
            for (let i = 0; i < agentCount; i++) {
                const pos = positions[i], type = i < agentCount / 2 ? RED : GREEN;
                agents.push(new Agent(pos.x, pos.y, type));
                grid[pos.y][pos.x] = type;
            }
        }

        function update() {
            agents.forEach(agent => agent.checkHappiness());
            const unhappy = agents.filter(a => !a.happy);
            for (let i = unhappy.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [unhappy[i], unhappy[j]] = [unhappy[j], unhappy[i]];
            }
            unhappy.forEach(agent => agent.move());

            // Age and filter trails
            const maxAge = fadeSpeeds[fadeSpeed];
            trails = trails.map(t => ({ ...t, age: t.age + 1 })).filter(t => t.age < maxAge);

            iterations++;
        }

        function draw() {
            // Dark background
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw trails
            trails.forEach(trail => {
                const maxAge = fadeSpeeds[fadeSpeed];
                const alpha = 1 - (trail.age / maxAge);
                const color = trail.type === RED ? '231, 76, 60' : '46, 204, 113';

                const fromX = trail.fromX * CELL_SIZE + CELL_SIZE / 2;
                const fromY = trail.fromY * CELL_SIZE + CELL_SIZE / 2;
                const toX = trail.toX * CELL_SIZE + CELL_SIZE / 2;
                const toY = trail.toY * CELL_SIZE + CELL_SIZE / 2;

                ctx.strokeStyle = `rgba(${color}, ${alpha * 0.6})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.stroke();
            });

            // Draw agents
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = grid[y][x];
                    if (cell === RED) ctx.fillStyle = '#e74c3c';
                    else if (cell === GREEN) ctx.fillStyle = '#2ecc71';
                    else continue;

                    ctx.beginPath();
                    ctx.arc(
                        x * CELL_SIZE + CELL_SIZE / 2,
                        y * CELL_SIZE + CELL_SIZE / 2,
                        CELL_SIZE / 3,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }

            updateStats();
        }

        function updateStats() {
            document.getElementById('iterations').textContent = iterations;
            document.getElementById('moves').textContent = totalMoves;
            document.getElementById('trails').textContent = trails.length;
            const unhappyCount = agents.filter(a => !a.happy).length;
            document.getElementById('unhappy').textContent = (unhappyCount / agents.length * 100).toFixed(1) + '%';
        }

        function animate() {
            if (!paused) update();
            draw();
            requestAnimationFrame(animate);
        }

        document.getElementById('resetBtn').addEventListener('click', () => initializeGrid());
        document.getElementById('pauseBtn').addEventListener('click', (e) => {
            paused = !paused;
            e.target.textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('clearBtn').addEventListener('click', () => { trails = []; });
        document.getElementById('fadeBtn').addEventListener('click', (e) => {
            const speeds = ['slow', 'medium', 'fast'];
            const currentIndex = speeds.indexOf(fadeSpeed);
            fadeSpeed = speeds[(currentIndex + 1) % speeds.length];
            e.target.textContent = `Fade: ${fadeSpeed.charAt(0).toUpperCase() + fadeSpeed.slice(1)}`;
        });

        initializeGrid();
        animate();
    </script>
</body>
</html>
