<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spatial Tipping Points - Schelling Model</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #a770ef 0%, #cf8bf3 50%, #fdb99b 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
        }
        h1 { margin: 0 0 10px 0; font-size: 2em; }
        .description {
            max-width: 900px;
            text-align: center;
            margin-bottom: 20px;
            opacity: 0.95;
            line-height: 1.6;
        }
        .container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: white;
            display: block;
        }
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            color: #a770ef;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        button:hover {
            background: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        .stats {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
        }
        .stat {
            background: rgba(255, 255, 255, 0.15);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-label { opacity: 0.9; font-size: 12px; }
        .stat-value { font-size: 20px; font-weight: bold; margin-top: 3px; }
        .info-panel {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            font-size: 14px;
            line-height: 1.6;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Spatial Tipping Points</h1>
    <div class="description">
        Click any cell to convert it to the opposite color, creating local perturbations. Watch how
        small changes can trigger cascading effects when near the tipping point. Some changes stabilize
        locally, others spread through chain reactions, demonstrating spatial criticality.
    </div>

    <div class="container">
        <canvas id="canvas" width="700" height="700"></canvas>

        <div class="info-panel">
            <strong>Instructions:</strong> Click cells to flip their color. Try creating small integrated
            pockets in segregated regions to see if they spread or get absorbed. Experiment with different
            perturbation patterns.
        </div>

        <div class="controls">
            <button id="resetBtn">Reset</button>
            <button id="pauseBtn">Pause</button>
            <button id="clearBtn">Clear Changes</button>
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-label">Iterations</div>
                <div class="stat-value" id="iterations">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Manual Changes</div>
                <div class="stat-value" id="changes">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">% Unhappy</div>
                <div class="stat-value" id="unhappy">0%</div>
            </div>
            <div class="stat">
                <div class="stat-label">Recent Moves</div>
                <div class="stat-value" id="recentMoves">0</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const GRID_SIZE = 50, CELL_SIZE = canvas.width / GRID_SIZE;
        const DENSITY = 0.85, SIMILARITY_THRESHOLD = 0.35, MAX_SEARCH_ATTEMPTS = 50;
        const EMPTY = 0, RED = 1, GREEN = 2;

        let grid = [], agents = [], paused = false, iterations = 0;
        let manualChanges = 0, recentMoveCount = 0;
        let changedCells = new Set();

        class Agent {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; this.happy = false;
            }
            getNeighbors() {
                const neighbors = [];
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = (this.x + dx + GRID_SIZE) % GRID_SIZE;
                        const ny = (this.y + dy + GRID_SIZE) % GRID_SIZE;
                        if (grid[ny][nx] !== EMPTY) neighbors.push(grid[ny][nx]);
                    }
                }
                return neighbors;
            }
            checkHappiness() {
                const neighbors = this.getNeighbors();
                if (neighbors.length === 0) { this.happy = true; return; }
                this.happy = neighbors.filter(n => n === this.type).length / neighbors.length >= SIMILARITY_THRESHOLD;
            }
            findEmptySpot() {
                for (let attempt = 0; attempt < MAX_SEARCH_ATTEMPTS; attempt++) {
                    const angle = Math.random() * Math.PI * 2, distance = Math.random() * 10;
                    const wx = (Math.round(this.x + Math.cos(angle) * distance) + GRID_SIZE) % GRID_SIZE;
                    const wy = (Math.round(this.y + Math.sin(angle) * distance) + GRID_SIZE) % GRID_SIZE;
                    if (grid[wy][wx] === EMPTY) return { x: wx, y: wy };
                }
                return null;
            }
            move() {
                const newSpot = this.findEmptySpot();
                if (newSpot) {
                    grid[this.y][this.x] = EMPTY;
                    this.x = newSpot.x; this.y = newSpot.y;
                    grid[this.y][this.x] = this.type;
                    recentMoveCount++;
                    return true;
                }
                return false;
            }
        }

        function initializeGrid() {
            grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(EMPTY));
            agents = []; iterations = 0; manualChanges = 0; changedCells.clear();
            const positions = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) positions.push({ x, y });
            }
            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }
            const agentCount = Math.floor(GRID_SIZE * GRID_SIZE * DENSITY);
            for (let i = 0; i < agentCount; i++) {
                const pos = positions[i], type = i < agentCount / 2 ? RED : GREEN;
                agents.push(new Agent(pos.x, pos.y, type));
                grid[pos.y][pos.x] = type;
            }
        }

        function update() {
            recentMoveCount = 0;
            agents.forEach(agent => agent.checkHappiness());
            const unhappy = agents.filter(a => !a.happy);
            for (let i = unhappy.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [unhappy[i], unhappy[j]] = [unhappy[j], unhappy[i]];
            }
            unhappy.forEach(agent => agent.move());
            iterations++;
        }

        function draw() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = grid[y][x];
                    if (cell === RED) ctx.fillStyle = '#e74c3c';
                    else if (cell === GREEN) ctx.fillStyle = '#2ecc71';
                    else continue;

                    ctx.fillRect(x * CELL_SIZE + 1, y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);

                    // Highlight manually changed cells
                    const key = `${x},${y}`;
                    if (changedCells.has(key)) {
                        ctx.strokeStyle = '#f39c12';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(x * CELL_SIZE + 2, y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                    }
                }
            }

            updateStats();
        }

        function updateStats() {
            document.getElementById('iterations').textContent = iterations;
            document.getElementById('changes').textContent = manualChanges;
            const unhappyCount = agents.filter(a => !a.happy).length;
            document.getElementById('unhappy').textContent = (unhappyCount / agents.length * 100).toFixed(1) + '%';
            document.getElementById('recentMoves').textContent = recentMoveCount;
        }

        function animate() {
            if (!paused) update();
            draw();
            requestAnimationFrame(animate);
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / CELL_SIZE);
            const y = Math.floor((e.clientY - rect.top) / CELL_SIZE);

            if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE && grid[y][x] !== EMPTY) {
                const agent = agents.find(a => a.x === x && a.y === y);
                if (agent) {
                    // Flip the agent's type
                    const newType = agent.type === RED ? GREEN : RED;
                    agent.type = newType;
                    grid[y][x] = newType;
                    manualChanges++;

                    const key = `${x},${y}`;
                    changedCells.add(key);

                    draw();
                }
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => initializeGrid());
        document.getElementById('pauseBtn').addEventListener('click', (e) => {
            paused = !paused;
            e.target.textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('clearBtn').addEventListener('click', () => {
            changedCells.clear();
            draw();
        });

        initializeGrid();
        animate();
    </script>
</body>
</html>
