<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convolutional Codes - Encoder Visualization</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #00aaff; min-height: 100vh; padding: 20px;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px; color: #00aaff;
            text-decoration: none; padding: 10px 20px;
            background: rgba(0,170,255,0.1); border: 1px solid #00aaff;
            border-radius: 5px; z-index: 100;
        }
        .container { max-width: 1100px; margin: 60px auto 0; }
        h1 { font-size: 2rem; margin-bottom: 10px; text-align: center; }
        .subtitle { color: #888; margin-bottom: 30px; text-align: center; }
        .controls {
            display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;
            margin-bottom: 20px; background: rgba(0,170,255,0.05);
            padding: 20px; border-radius: 15px;
        }
        button {
            padding: 12px 25px; font-family: inherit;
            background: rgba(0,170,255,0.1); border: 1px solid #00aaff;
            color: #00aaff; border-radius: 5px; cursor: pointer;
        }
        button:hover { background: rgba(0,170,255,0.3); }
        .bit-display {
            font-size: 1.1rem; font-weight: bold;
            padding: 10px 15px; background: rgba(0,0,0,0.3);
            border-radius: 5px;
        }
        .encoder-panel {
            background: rgba(0,0,0,0.5); padding: 25px;
            border-radius: 15px; border: 1px solid #00aaff;
            margin-bottom: 20px;
        }
        .encoder-panel h3 { color: #00ccff; margin-bottom: 20px; text-align: center; }
        canvas { width: 100%; height: 200px; background: rgba(0,20,40,0.5); border-radius: 10px; }
        .signals-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
            margin-bottom: 20px;
        }
        .panel {
            background: rgba(0,0,0,0.5); padding: 15px;
            border-radius: 15px; border: 1px solid #00aaff;
        }
        .panel h3 { color: #00ccff; margin-bottom: 10px; text-align: center; font-size: 0.95rem; }
        .signal-canvas { height: 100px; }
        .info { background: rgba(0,170,255,0.05); padding: 20px; border-radius: 10px; }
        .info h3 { color: #00ccff; margin-bottom: 10px; }
        .info p { color: #aaa; line-height: 1.6; margin-bottom: 10px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div class="container">
        <h1>Convolutional Codes</h1>
        <p class="subtitle">Rate 1/2, Constraint Length 3 Encoder (K=3, g1=[1,1,1], g2=[1,0,1])</p>

        <div class="controls">
            <button onclick="stepEncoder()">Step (shift 1 bit)</button>
            <button onclick="runSequence()">Run All</button>
            <button onclick="reset()">Reset</button>
            <div class="bit-display">Input: <span id="inputBits">1 0 1 1 0</span></div>
            <div class="bit-display">Output: <span id="outputBits">--</span></div>
        </div>

        <div class="encoder-panel">
            <h3>Convolutional Encoder (Shift Register + XOR Gates)</h3>
            <canvas id="encoderCanvas"></canvas>
        </div>

        <div class="signals-grid">
            <div class="panel">
                <h3>Input Sequence (1 bit at a time)</h3>
                <canvas id="inputCanvas" class="signal-canvas"></canvas>
            </div>
            <div class="panel">
                <h3>Output Sequence (2 bits per input)</h3>
                <canvas id="outputCanvas" class="signal-canvas"></canvas>
            </div>
        </div>

        <div class="info">
            <h3>How Convolutional Codes Work</h3>
            <p><strong>Shift Register:</strong> Input bits shift through K-1 memory cells. Current output depends on current and past inputs.</p>
            <p><strong>Generator Polynomials:</strong> g1=[1,1,1] and g2=[1,0,1] define which taps connect to each output via XOR.</p>
            <p><strong>Rate 1/2:</strong> For every 1 input bit, we get 2 output bits. More redundancy = better error correction!</p>
            <p><strong>Constraint Length K:</strong> Determines memory. Longer K = better performance but more complex decoder.</p>
            <p><strong>Decoding:</strong> Viterbi algorithm finds most likely path through code trellis.</p>
            <p><strong>Applications:</strong> Deep space (Voyager), GSM, satellite, Wi-Fi (802.11a/g/n).</p>
        </div>
    </div>

    <script>
        const inputSequence = [1, 0, 1, 1, 0];
        let shiftReg = [0, 0]; // K-1 = 2 memory cells
        let currentBitIdx = 0;
        let outputPairs = [];

        function resizeCanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.getContext('2d').scale(dpr, dpr);
        }

        function encode(inputBit) {
            // g1 = [1, 1, 1] -> input XOR s0 XOR s1
            const out1 = inputBit ^ shiftReg[0] ^ shiftReg[1];
            // g2 = [1, 0, 1] -> input XOR s1
            const out2 = inputBit ^ shiftReg[1];

            // Shift register
            shiftReg[1] = shiftReg[0];
            shiftReg[0] = inputBit;

            return [out1, out2];
        }

        function stepEncoder() {
            if (currentBitIdx >= inputSequence.length) return;

            const inputBit = inputSequence[currentBitIdx];
            const [out1, out2] = encode(inputBit);
            outputPairs.push([out1, out2]);
            currentBitIdx++;

            updateDisplay();
            draw();
        }

        function runSequence() {
            while (currentBitIdx < inputSequence.length) {
                const inputBit = inputSequence[currentBitIdx];
                const [out1, out2] = encode(inputBit);
                outputPairs.push([out1, out2]);
                currentBitIdx++;
            }
            updateDisplay();
            draw();
        }

        function reset() {
            shiftReg = [0, 0];
            currentBitIdx = 0;
            outputPairs = [];
            updateDisplay();
            draw();
        }

        function updateDisplay() {
            const inputStr = inputSequence.map((b, i) =>
                i < currentBitIdx ? `[${b}]` : b
            ).join(' ');
            document.getElementById('inputBits').textContent = inputStr;

            const outputStr = outputPairs.map(p => p.join('')).join(' ');
            document.getElementById('outputBits').textContent = outputStr || '--';
        }

        function drawEncoder(canvas) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            const boxSize = 50;
            const cx = w / 2;
            const cy = h / 2;

            // Draw shift register boxes
            const boxes = [
                { x: cx - 120, y: cy - 25, label: 'Input', value: currentBitIdx < inputSequence.length ? inputSequence[currentBitIdx] : '-' },
                { x: cx - 30, y: cy - 25, label: 'S0', value: shiftReg[0] },
                { x: cx + 60, y: cy - 25, label: 'S1', value: shiftReg[1] }
            ];

            boxes.forEach(box => {
                ctx.strokeStyle = '#00aaff';
                ctx.lineWidth = 2;
                ctx.strokeRect(box.x, box.y, boxSize, boxSize);

                ctx.fillStyle = 'rgba(0,170,255,0.2)';
                ctx.fillRect(box.x, box.y, boxSize, boxSize);

                ctx.fillStyle = '#00ffff';
                ctx.font = 'bold 20px Courier New';
                ctx.fillText(box.value.toString(), box.x + 18, box.y + 32);

                ctx.fillStyle = '#888';
                ctx.font = '11px Courier New';
                ctx.fillText(box.label, box.x + 10, box.y - 5);
            });

            // Draw connections
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;

            // Arrows between boxes
            ctx.beginPath();
            ctx.moveTo(boxes[0].x + boxSize, cy);
            ctx.lineTo(boxes[1].x, cy);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(boxes[1].x + boxSize, cy);
            ctx.lineTo(boxes[2].x, cy);
            ctx.stroke();

            // XOR gates
            const xor1Y = cy - 70;
            const xor2Y = cy + 70;

            // XOR gate 1 (g1 = [1,1,1])
            ctx.fillStyle = '#ff6688';
            ctx.beginPath();
            ctx.arc(cx + 140, xor1Y, 15, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.font = 'bold 14px Courier New';
            ctx.fillText('⊕', cx + 133, xor1Y + 5);

            // Connections to XOR1 (from input, s0, s1)
            ctx.strokeStyle = 'rgba(255,102,136,0.5)';
            ctx.beginPath();
            ctx.moveTo(boxes[0].x + 25, boxes[0].y);
            ctx.lineTo(boxes[0].x + 25, xor1Y);
            ctx.lineTo(cx + 125, xor1Y);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(boxes[1].x + 25, boxes[1].y);
            ctx.lineTo(boxes[1].x + 25, xor1Y);
            ctx.lineTo(cx + 125, xor1Y);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(boxes[2].x + 25, boxes[2].y);
            ctx.lineTo(boxes[2].x + 25, xor1Y);
            ctx.lineTo(cx + 125, xor1Y);
            ctx.stroke();

            // XOR gate 2 (g2 = [1,0,1])
            ctx.fillStyle = '#00ff88';
            ctx.beginPath();
            ctx.arc(cx + 140, xor2Y, 15, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.fillText('⊕', cx + 133, xor2Y + 5);

            // Connections to XOR2 (from input, s1 only)
            ctx.strokeStyle = 'rgba(0,255,136,0.5)';
            ctx.beginPath();
            ctx.moveTo(boxes[0].x + 25, boxes[0].y + boxSize);
            ctx.lineTo(boxes[0].x + 25, xor2Y);
            ctx.lineTo(cx + 125, xor2Y);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(boxes[2].x + 25, boxes[2].y + boxSize);
            ctx.lineTo(boxes[2].x + 25, xor2Y);
            ctx.lineTo(cx + 125, xor2Y);
            ctx.stroke();

            // Output labels
            ctx.fillStyle = '#ff6688';
            ctx.font = '12px Courier New';
            ctx.fillText('Output 1 (g1=[1,1,1])', cx + 160, xor1Y + 5);

            ctx.fillStyle = '#00ff88';
            ctx.fillText('Output 2 (g2=[1,0,1])', cx + 160, xor2Y + 5);

            // Current outputs
            if (outputPairs.length > 0) {
                const lastPair = outputPairs[outputPairs.length - 1];
                ctx.fillStyle = '#ff6688';
                ctx.font = 'bold 16px Courier New';
                ctx.fillText(lastPair[0].toString(), w - 50, xor1Y + 5);
                ctx.fillStyle = '#00ff88';
                ctx.fillText(lastPair[1].toString(), w - 50, xor2Y + 5);
            }
        }

        function drawSignal(canvas, data, isOutput = false) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            ctx.strokeStyle = 'rgba(0,170,255,0.2)';
            ctx.beginPath();
            ctx.moveTo(0, h / 2);
            ctx.lineTo(w, h / 2);
            ctx.stroke();

            const flatData = isOutput ? data.flat() : data;
            if (flatData.length === 0) return;

            const bitWidth = w / Math.max(flatData.length, 10);

            ctx.strokeStyle = isOutput ? '#00ff88' : '#00aaff';
            ctx.lineWidth = 3;
            ctx.beginPath();

            for (let i = 0; i < flatData.length; i++) {
                const y = flatData[i] === 1 ? h * 0.2 : h * 0.8;
                const x = i * bitWidth;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    const prevY = flatData[i - 1] === 1 ? h * 0.2 : h * 0.8;
                    ctx.lineTo(x, prevY);
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(x + bitWidth, y);
            }
            ctx.stroke();

            ctx.fillStyle = '#888';
            ctx.font = '10px Courier New';
            for (let i = 0; i < flatData.length; i++) {
                ctx.fillText(flatData[i].toString(), i * bitWidth + bitWidth / 2 - 3, h / 2 + 4);
            }
        }

        function draw() {
            drawEncoder(document.getElementById('encoderCanvas'));
            drawSignal(document.getElementById('inputCanvas'), inputSequence.slice(0, currentBitIdx));
            drawSignal(document.getElementById('outputCanvas'), outputPairs, true);
        }

        function init() {
            ['encoderCanvas', 'inputCanvas', 'outputCanvas'].forEach(id => {
                resizeCanvas(document.getElementById(id));
            });
            draw();
        }

        window.addEventListener('resize', init);
        init();
    </script>
</body>
</html>
