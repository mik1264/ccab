<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QAM Constellation - Quadrature Amplitude Modulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #00aaff; min-height: 100vh; padding: 20px;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px; color: #00aaff;
            text-decoration: none; padding: 10px 20px;
            background: rgba(0,170,255,0.1); border: 1px solid #00aaff;
            border-radius: 5px; z-index: 100;
        }
        .container { max-width: 1200px; margin: 60px auto 0; }
        h1 { font-size: 2rem; margin-bottom: 10px; text-align: center; }
        .subtitle { color: #888; margin-bottom: 30px; text-align: center; }
        .controls {
            display: flex; gap: 15px; flex-wrap: wrap; justify-content: center;
            margin-bottom: 20px; background: rgba(0,170,255,0.05);
            padding: 20px; border-radius: 15px;
        }
        button {
            padding: 12px 20px; font-family: inherit;
            background: rgba(0,170,255,0.1); border: 1px solid #00aaff;
            color: #00aaff; border-radius: 5px; cursor: pointer;
        }
        button:hover { background: rgba(0,170,255,0.3); }
        button.active { background: rgba(0,170,255,0.5); }
        .control-group label { color: #888; margin-right: 10px; }
        input[type="range"] { width: 150px; }
        .value { color: #00ffff; margin-left: 10px; }
        .main-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;
        }
        .panel {
            background: rgba(0,0,0,0.5); padding: 20px;
            border-radius: 15px; border: 1px solid #00aaff;
        }
        .panel h3 { color: #00ccff; margin-bottom: 15px; text-align: center; }
        canvas { width: 100%; height: 350px; background: rgba(0,20,40,0.5); border-radius: 8px; }
        .stats {
            display: grid; grid-template-columns: repeat(4, 1fr);
            gap: 10px; margin-top: 15px;
        }
        .stat {
            background: rgba(0,170,255,0.1); padding: 10px;
            border-radius: 8px; text-align: center;
        }
        .stat-value { font-size: 1.3rem; color: #00ffff; }
        .stat-label { font-size: 0.75rem; color: #888; }
        .info { background: rgba(0,170,255,0.05); padding: 20px; border-radius: 10px; }
        .info h3 { color: #00ccff; margin-bottom: 10px; }
        .info p { color: #aaa; line-height: 1.6; margin-bottom: 10px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div class="container">
        <h1>QAM Constellation</h1>
        <p class="subtitle">Quadrature Amplitude Modulation - combining amplitude and phase</p>

        <div class="controls">
            <button id="btn4" onclick="setQAM(4)">4-QAM</button>
            <button id="btn16" class="active" onclick="setQAM(16)">16-QAM</button>
            <button id="btn64" onclick="setQAM(64)">64-QAM</button>
            <button id="btn256" onclick="setQAM(256)">256-QAM</button>
            <div class="control-group">
                <label>SNR (dB):</label>
                <input type="range" id="snr" min="5" max="40" value="20">
                <span class="value" id="snrVal">20 dB</span>
            </div>
        </div>

        <div class="main-grid">
            <div class="panel">
                <h3 id="idealTitle">16-QAM Ideal Constellation</h3>
                <canvas id="idealCanvas"></canvas>
            </div>
            <div class="panel">
                <h3>Received Symbols with AWGN</h3>
                <canvas id="noisyCanvas"></canvas>
            </div>
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="bitsPerSymbol">4</div>
                <div class="stat-label">Bits/Symbol</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="numSymbols">16</div>
                <div class="stat-label">Constellation Points</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="minDistance">0.47</div>
                <div class="stat-label">Min Distance (norm)</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="errorRate">~10⁻⁴</div>
                <div class="stat-label">Est. Symbol Error</div>
            </div>
        </div>

        <div class="info">
            <h3>Understanding QAM</h3>
            <p><strong>Higher Order = More Bits:</strong> 16-QAM carries 4 bits/symbol, 64-QAM carries 6 bits/symbol, 256-QAM carries 8 bits/symbol.</p>
            <p><strong>Trade-off:</strong> More constellation points means higher throughput but requires better SNR to distinguish symbols.</p>
            <p><strong>Gray Coding:</strong> Adjacent symbols differ by only 1 bit to minimize bit errors from symbol errors.</p>
            <p><strong>Applications:</strong> Wi-Fi (up to 1024-QAM), cable modems, LTE, digital TV.</p>
        </div>
    </div>

    <script>
        let qamOrder = 16;
        let snr = 20;
        let constellation = [];

        function resizeCanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.getContext('2d').scale(dpr, dpr);
        }

        function generateConstellation(order) {
            const points = [];
            const gridSize = Math.sqrt(order);

            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const I = (2 * i - gridSize + 1);
                    const Q = (2 * j - gridSize + 1);
                    points.push({ i: I, q: Q });
                }
            }

            // Normalize average power to 1
            const avgPower = points.reduce((sum, p) => sum + p.i * p.i + p.q * p.q, 0) / points.length;
            const normFactor = Math.sqrt(avgPower);
            points.forEach(p => {
                p.i /= normFactor;
                p.q /= normFactor;
            });

            return points;
        }

        function setQAM(order) {
            qamOrder = order;
            constellation = generateConstellation(order);

            document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
            document.getElementById('btn' + order).classList.add('active');
            document.getElementById('idealTitle').textContent = `${order}-QAM Ideal Constellation`;
            document.getElementById('bitsPerSymbol').textContent = Math.log2(order);
            document.getElementById('numSymbols').textContent = order;

            // Calculate minimum distance
            let minDist = Infinity;
            for (let i = 0; i < constellation.length; i++) {
                for (let j = i + 1; j < constellation.length; j++) {
                    const d = Math.sqrt(
                        Math.pow(constellation[i].i - constellation[j].i, 2) +
                        Math.pow(constellation[i].q - constellation[j].q, 2)
                    );
                    minDist = Math.min(minDist, d);
                }
            }
            document.getElementById('minDistance').textContent = minDist.toFixed(2);

            draw();
        }

        function drawConstellation(canvas, withNoise = false) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            const cx = w / 2;
            const cy = h / 2;
            const maxCoord = Math.max(...constellation.map(p => Math.max(Math.abs(p.i), Math.abs(p.q))));
            const scale = Math.min(w, h) * 0.4 / maxCoord;

            // Grid
            ctx.strokeStyle = 'rgba(0,170,255,0.1)';
            ctx.lineWidth = 1;
            for (let i = -Math.ceil(maxCoord); i <= Math.ceil(maxCoord); i++) {
                ctx.beginPath();
                ctx.moveTo(cx + i * scale / maxCoord * maxCoord, 0);
                ctx.lineTo(cx + i * scale / maxCoord * maxCoord, h);
                ctx.moveTo(0, cy - i * scale / maxCoord * maxCoord);
                ctx.lineTo(w, cy - i * scale / maxCoord * maxCoord);
                ctx.stroke();
            }

            // Axes
            ctx.strokeStyle = 'rgba(0,170,255,0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, cy);
            ctx.lineTo(w, cy);
            ctx.moveTo(cx, 0);
            ctx.lineTo(cx, h);
            ctx.stroke();

            ctx.fillStyle = '#888';
            ctx.font = '12px Courier New';
            ctx.fillText('I', w - 15, cy - 8);
            ctx.fillText('Q', cx + 8, 15);

            if (withNoise) {
                const noiseSigma = 1 / Math.sqrt(2 * Math.pow(10, snr / 10));

                // Decision boundaries
                ctx.strokeStyle = 'rgba(255,170,0,0.2)';
                ctx.setLineDash([3, 3]);
                const gridSize = Math.sqrt(qamOrder);
                const spacing = 2 / Math.sqrt(constellation.reduce((s, p) => s + p.i * p.i + p.q * p.q, 0) / constellation.length * gridSize * gridSize / 4);

                for (let i = 1; i < gridSize; i++) {
                    const pos = (i - gridSize / 2) * spacing;
                    ctx.beginPath();
                    ctx.moveTo(cx + pos * scale, 0);
                    ctx.lineTo(cx + pos * scale, h);
                    ctx.moveTo(0, cy - pos * scale);
                    ctx.lineTo(w, cy - pos * scale);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // Noisy symbols
                const numPoints = Math.min(500, qamOrder * 30);
                for (let i = 0; i < numPoints; i++) {
                    const sym = constellation[Math.floor(Math.random() * constellation.length)];
                    const noiseI = (Math.random() + Math.random() + Math.random() - 1.5) * noiseSigma * 2;
                    const noiseQ = (Math.random() + Math.random() + Math.random() - 1.5) * noiseSigma * 2;

                    const x = cx + (sym.i + noiseI) * scale;
                    const y = cy - (sym.q + noiseQ) * scale;

                    ctx.fillStyle = `hsla(${180 + (sym.i + sym.q) * 20}, 100%, 60%, 0.4)`;
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            // Ideal constellation points
            const pointRadius = withNoise ? 4 : (qamOrder <= 16 ? 10 : (qamOrder <= 64 ? 6 : 4));
            constellation.forEach((p, idx) => {
                const x = cx + p.i * scale;
                const y = cy - p.q * scale;

                ctx.fillStyle = `hsl(${180 + (p.i + p.q) * 20}, 100%, 50%)`;
                ctx.beginPath();
                ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
                ctx.fill();

                if (!withNoise && qamOrder <= 16) {
                    ctx.fillStyle = '#000';
                    ctx.font = '9px Courier New';
                    const bits = idx.toString(2).padStart(Math.log2(qamOrder), '0');
                    ctx.fillText(bits, x - 10, y + 3);
                }
            });
        }

        function estimateErrorRate() {
            const snrLinear = Math.pow(10, snr / 10);
            const M = qamOrder;
            const k = Math.log2(M);

            // Approximate symbol error rate for M-QAM
            const Pb = 2 * (1 - 1 / Math.sqrt(M)) * 0.5 * erfc(Math.sqrt(3 * snrLinear / (2 * (M - 1))));

            if (Pb < 1e-10) return '< 10⁻¹⁰';
            if (Pb < 1e-6) return '~10⁻' + Math.floor(-Math.log10(Pb));
            if (Pb < 0.001) return (Pb * 1000).toFixed(1) + '×10⁻³';
            return (Pb * 100).toFixed(1) + '%';
        }

        function erfc(x) {
            const t = 1 / (1 + 0.5 * Math.abs(x));
            const tau = t * Math.exp(-x * x - 1.26551223 +
                t * (1.00002368 + t * (0.37409196 + t * (0.09678418 +
                    t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 +
                        t * (1.48851587 + t * (-0.82215223 + t * 0.17087277)))))))));
            return x >= 0 ? tau : 2 - tau;
        }

        function draw() {
            snr = parseInt(document.getElementById('snr').value);
            document.getElementById('snrVal').textContent = snr + ' dB';
            document.getElementById('errorRate').textContent = estimateErrorRate();

            drawConstellation(document.getElementById('idealCanvas'), false);
            drawConstellation(document.getElementById('noisyCanvas'), true);
        }

        function init() {
            ['idealCanvas', 'noisyCanvas'].forEach(id => {
                resizeCanvas(document.getElementById(id));
            });
            constellation = generateConstellation(qamOrder);
            draw();
        }

        document.getElementById('snr').addEventListener('input', draw);
        window.addEventListener('resize', init);
        init();

    // Expose for enhance.js keyboard shortcuts
    window.reset = init;
    window.init = init;
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
