<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LDPC Codes - Sparse Parity Check Matrix</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #00aaff; min-height: 100vh; padding: 20px;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px; color: #00aaff;
            text-decoration: none; padding: 10px 20px;
            background: rgba(0,170,255,0.1); border: 1px solid #00aaff;
            border-radius: 5px; z-index: 100;
        }
        .container { max-width: 1100px; margin: 60px auto 0; }
        h1 { font-size: 2rem; margin-bottom: 10px; text-align: center; }
        .subtitle { color: #888; margin-bottom: 30px; text-align: center; }
        .main-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;
        }
        .panel {
            background: rgba(0,0,0,0.5); padding: 20px;
            border-radius: 15px; border: 1px solid #00aaff;
        }
        .panel h3 { color: #00ccff; margin-bottom: 15px; text-align: center; }
        canvas { width: 100%; height: 300px; background: rgba(0,20,40,0.5); border-radius: 10px; }
        .controls {
            display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;
            margin-bottom: 20px; background: rgba(0,170,255,0.05);
            padding: 20px; border-radius: 15px;
        }
        button {
            padding: 12px 25px; font-family: inherit;
            background: rgba(0,170,255,0.1); border: 1px solid #00aaff;
            color: #00aaff; border-radius: 5px; cursor: pointer;
        }
        button:hover { background: rgba(0,170,255,0.3); }
        .control-group label { color: #888; margin-right: 10px; }
        select {
            padding: 8px; font-family: inherit;
            background: rgba(0,170,255,0.1); border: 1px solid #00aaff;
            color: #00aaff; border-radius: 5px;
        }
        .info { background: rgba(0,170,255,0.05); padding: 20px; border-radius: 10px; }
        .info h3 { color: #00ccff; margin-bottom: 10px; }
        .info p { color: #aaa; line-height: 1.6; margin-bottom: 10px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div class="container">
        <h1>LDPC Codes</h1>
        <p class="subtitle">Low-Density Parity-Check codes - capacity-approaching performance</p>

        <div class="controls">
            <div class="control-group">
                <label>Matrix Size:</label>
                <select id="matrixSize">
                    <option value="8">8×16 (Rate 1/2)</option>
                    <option value="12" selected>12×24 (Rate 1/2)</option>
                    <option value="16">16×32 (Rate 1/2)</option>
                </select>
            </div>
            <button onclick="generateMatrix()">Generate New Matrix</button>
            <button onclick="runDecoding()">Simulate Decoding</button>
        </div>

        <div class="main-grid">
            <div class="panel">
                <h3>Parity Check Matrix H (Sparse)</h3>
                <canvas id="matrixCanvas"></canvas>
            </div>
            <div class="panel">
                <h3>Tanner Graph (Bipartite)</h3>
                <canvas id="graphCanvas"></canvas>
            </div>
        </div>

        <div class="info">
            <h3>Understanding LDPC Codes</h3>
            <p><strong>Sparse Matrix:</strong> H has very few 1s (low density). This enables efficient message-passing decoding!</p>
            <p><strong>Tanner Graph:</strong> Bipartite graph with variable nodes (bits) and check nodes (parity equations). Messages pass along edges.</p>
            <p><strong>Belief Propagation:</strong> Iteratively update beliefs about each bit based on parity check constraints.</p>
            <p><strong>Performance:</strong> Can achieve within 0.0045 dB of Shannon limit! Even better than Turbo codes for long blocks.</p>
            <p><strong>Applications:</strong> Wi-Fi 6 (802.11ax), 5G NR, DVB-S2, 10GBase-T Ethernet, SSD storage.</p>
        </div>
    </div>

    <script>
        let rows = 12;
        let cols = 24;
        let H = [];

        function resizeCanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.getContext('2d').scale(dpr, dpr);
        }

        function generateMatrix() {
            rows = parseInt(document.getElementById('matrixSize').value);
            cols = rows * 2;

            // Generate regular LDPC matrix
            H = [];
            const columnWeight = 3; // Each column has 3 ones
            const rowWeight = 6; // Each row has 6 ones

            // Initialize with zeros
            for (let i = 0; i < rows; i++) {
                H.push(new Array(cols).fill(0));
            }

            // Place ones with regular structure
            for (let c = 0; c < cols; c++) {
                const positions = [];
                while (positions.length < columnWeight) {
                    const r = Math.floor(Math.random() * rows);
                    if (!positions.includes(r)) {
                        positions.push(r);
                    }
                }
                positions.forEach(r => H[r][c] = 1);
            }

            draw();
        }

        function drawMatrix(canvas) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            if (H.length === 0) return;

            const padding = 40;
            const cellW = (w - 2 * padding) / cols;
            const cellH = (h - 2 * padding) / rows;
            const cellSize = Math.min(cellW, cellH, 15);

            const startX = (w - cols * cellSize) / 2;
            const startY = (h - rows * cellSize) / 2;

            // Draw matrix
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const x = startX + c * cellSize;
                    const y = startY + r * cellSize;

                    if (H[r][c] === 1) {
                        ctx.fillStyle = '#00ffff';
                        ctx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2);
                    } else {
                        ctx.fillStyle = 'rgba(0,170,255,0.1)';
                        ctx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2);
                    }
                }
            }

            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.fillText(`${rows}×${cols} matrix`, 10, 20);
            ctx.fillText('Check nodes (rows) →', 10, h - 10);

            // Count ones
            let ones = 0;
            H.forEach(row => row.forEach(v => ones += v));
            const density = (ones / (rows * cols) * 100).toFixed(1);
            ctx.fillText(`Density: ${density}% (${ones} ones)`, w - 150, 20);
        }

        function drawGraph(canvas) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            if (H.length === 0) return;

            const padding = 30;
            const varY = padding + 30;
            const checkY = h - padding - 30;

            // Draw only first 16 variable nodes and 8 check nodes for visibility
            const maxVars = Math.min(cols, 16);
            const maxChecks = Math.min(rows, 8);

            const varSpacing = (w - 2 * padding) / maxVars;
            const checkSpacing = (w - 2 * padding) / maxChecks;

            // Draw edges
            ctx.strokeStyle = 'rgba(0,170,255,0.3)';
            ctx.lineWidth = 1;

            for (let c = 0; c < maxVars; c++) {
                for (let r = 0; r < maxChecks; r++) {
                    if (H[r][c] === 1) {
                        const varX = padding + c * varSpacing + varSpacing / 2;
                        const checkX = padding + r * checkSpacing + checkSpacing / 2;

                        ctx.beginPath();
                        ctx.moveTo(varX, varY + 10);
                        ctx.lineTo(checkX, checkY - 10);
                        ctx.stroke();
                    }
                }
            }

            // Draw variable nodes (circles)
            ctx.fillStyle = '#00ff88';
            for (let c = 0; c < maxVars; c++) {
                const x = padding + c * varSpacing + varSpacing / 2;
                ctx.beginPath();
                ctx.arc(x, varY, 8, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Draw check nodes (squares)
            ctx.fillStyle = '#ff6688';
            for (let r = 0; r < maxChecks; r++) {
                const x = padding + r * checkSpacing + checkSpacing / 2;
                ctx.fillRect(x - 8, checkY - 8, 16, 16);

                // Plus sign
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x - 4, checkY);
                ctx.lineTo(x + 4, checkY);
                ctx.moveTo(x, checkY - 4);
                ctx.lineTo(x, checkY + 4);
                ctx.stroke();
            }

            // Labels
            ctx.fillStyle = '#00ff88';
            ctx.font = '11px Courier New';
            ctx.fillText('Variable Nodes (bits)', 10, varY - 15);
            ctx.fillStyle = '#ff6688';
            ctx.fillText('Check Nodes (parity equations)', 10, checkY + 25);
        }

        function runDecoding() {
            // Animate edges to show message passing
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            let iteration = 0;
            const maxIter = 5;

            function animateIteration() {
                if (iteration >= maxIter) return;

                drawGraph(canvas);

                // Highlight active edges for this iteration
                const padding = 30;
                const varY = padding + 30;
                const checkY = h - padding - 30;
                const maxVars = Math.min(cols, 16);
                const maxChecks = Math.min(rows, 8);
                const varSpacing = (w - 2 * padding) / maxVars;
                const checkSpacing = (w - 2 * padding) / maxChecks;

                ctx.strokeStyle = iteration % 2 === 0 ? '#00ffff' : '#ffaa00';
                ctx.lineWidth = 2;

                for (let c = 0; c < maxVars; c++) {
                    for (let r = 0; r < maxChecks; r++) {
                        if (H[r][c] === 1 && Math.random() < 0.3) {
                            const varX = padding + c * varSpacing + varSpacing / 2;
                            const checkX = padding + r * checkSpacing + checkSpacing / 2;

                            ctx.beginPath();
                            ctx.moveTo(varX, varY + 10);
                            ctx.lineTo(checkX, checkY - 10);
                            ctx.stroke();
                        }
                    }
                }

                ctx.fillStyle = '#ffaa00';
                ctx.font = '12px Courier New';
                ctx.fillText(`Iteration ${iteration + 1}: ${iteration % 2 === 0 ? 'Variable → Check' : 'Check → Variable'}`, w / 2 - 100, h / 2);

                iteration++;
                setTimeout(animateIteration, 500);
            }

            animateIteration();
        }

        function draw() {
            drawMatrix(document.getElementById('matrixCanvas'));
            drawGraph(document.getElementById('graphCanvas'));
        }

        function init() {
            ['matrixCanvas', 'graphCanvas'].forEach(id => {
                resizeCanvas(document.getElementById(id));
            });
            generateMatrix();
        }

        document.getElementById('matrixSize').addEventListener('change', generateMatrix);
        window.addEventListener('resize', init);
        init();

    // Expose for enhance.js keyboard shortcuts
    window.reset = init;
    window.init = init;
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
