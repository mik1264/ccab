<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QPSK Modulation - Quadrature Phase Shift Keying</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #00aaff; min-height: 100vh; padding: 20px;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px; color: #00aaff;
            text-decoration: none; padding: 10px 20px;
            background: rgba(0,170,255,0.1); border: 1px solid #00aaff;
            border-radius: 5px; z-index: 100;
        }
        .container { max-width: 1100px; margin: 60px auto 0; }
        h1 { font-size: 2rem; margin-bottom: 10px; text-align: center; }
        .subtitle { color: #888; margin-bottom: 30px; text-align: center; }
        .controls {
            display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;
            margin-bottom: 20px; background: rgba(0,170,255,0.05);
            padding: 20px; border-radius: 15px;
        }
        button {
            padding: 12px 25px; font-family: inherit;
            background: rgba(0,170,255,0.1); border: 1px solid #00aaff;
            color: #00aaff; border-radius: 5px; cursor: pointer;
        }
        button:hover { background: rgba(0,170,255,0.3); }
        .bit-display {
            font-size: 1.3rem; font-weight: bold;
            padding: 10px 20px; background: rgba(0,0,0,0.3);
            border-radius: 5px;
        }
        .main-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;
        }
        .panel {
            background: rgba(0,0,0,0.5); padding: 15px;
            border-radius: 15px; border: 1px solid #00aaff;
        }
        .panel h3 { color: #00ccff; margin-bottom: 10px; text-align: center; font-size: 0.95rem; }
        canvas { width: 100%; height: 280px; background: rgba(0,20,40,0.5); border-radius: 8px; }
        .signal-canvas { height: 120px; }
        .full-width { grid-column: span 2; }
        .mapping-table {
            display: grid; grid-template-columns: repeat(4, 1fr);
            gap: 10px; margin-top: 15px;
        }
        .map-cell {
            background: rgba(0,170,255,0.1); padding: 10px;
            border-radius: 8px; text-align: center;
        }
        .map-bits { font-size: 1.1rem; color: #00ffff; }
        .map-phase { color: #888; font-size: 0.85rem; }
        .info { background: rgba(0,170,255,0.05); padding: 20px; border-radius: 10px; }
        .info h3 { color: #00ccff; margin-bottom: 10px; }
        .info p { color: #aaa; line-height: 1.6; margin-bottom: 10px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div class="container">
        <h1>QPSK Modulation</h1>
        <p class="subtitle">Quadrature Phase Shift Keying - 2 bits per symbol</p>

        <div class="controls">
            <button onclick="generateBits()">New Random Bits</button>
            <div class="bit-display" id="bitDisplay">11 01 00 10</div>
        </div>

        <div class="main-grid">
            <div class="panel">
                <h3>QPSK Constellation</h3>
                <canvas id="constellationCanvas"></canvas>
                <div class="mapping-table">
                    <div class="map-cell" style="border: 2px solid #00ff88;">
                        <div class="map-bits">00</div>
                        <div class="map-phase">45°</div>
                    </div>
                    <div class="map-cell" style="border: 2px solid #00aaff;">
                        <div class="map-bits">01</div>
                        <div class="map-phase">135°</div>
                    </div>
                    <div class="map-cell" style="border: 2px solid #ff6688;">
                        <div class="map-bits">11</div>
                        <div class="map-phase">225°</div>
                    </div>
                    <div class="map-cell" style="border: 2px solid #ffaa00;">
                        <div class="map-bits">10</div>
                        <div class="map-phase">315°</div>
                    </div>
                </div>
            </div>
            <div class="panel">
                <h3>Received with AWGN Noise</h3>
                <canvas id="noisyCanvas"></canvas>
            </div>
            <div class="panel full-width">
                <h3>I/Q Components & QPSK Waveform</h3>
                <canvas id="waveformCanvas" class="signal-canvas"></canvas>
            </div>
        </div>

        <div class="info">
            <h3>How QPSK Works</h3>
            <p><strong>Symbol Mapping:</strong> Each pair of bits (dibit) maps to one of 4 phases: 45°, 135°, 225°, 315°.</p>
            <p><strong>Spectral Efficiency:</strong> 2 bits per symbol = double the bit rate of BPSK for same bandwidth!</p>
            <p><strong>Gray Coding:</strong> Adjacent symbols differ by only 1 bit, minimizing errors from noise.</p>
            <p><strong>I/Q Representation:</strong> s(t) = I·cos(ωt) - Q·sin(ωt) where I,Q ∈ {-1, +1}.</p>
            <p><strong>Applications:</strong> Wi-Fi, LTE, DVB-S, cable modems, satellite links.</p>
        </div>
    </div>

    <script>
        const symbols = [
            { bits: '00', i: 1, q: 1, phase: 45, color: '#00ff88' },
            { bits: '01', i: -1, q: 1, phase: 135, color: '#00aaff' },
            { bits: '11', i: -1, q: -1, phase: 225, color: '#ff6688' },
            { bits: '10', i: 1, q: -1, phase: 315, color: '#ffaa00' }
        ];

        let dibits = ['11', '01', '00', '10'];

        function resizeCanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.getContext('2d').scale(dpr, dpr);
        }

        function generateBits() {
            dibits = [];
            for (let i = 0; i < 4; i++) {
                const b1 = Math.random() < 0.5 ? '0' : '1';
                const b2 = Math.random() < 0.5 ? '0' : '1';
                dibits.push(b1 + b2);
            }
            document.getElementById('bitDisplay').textContent = dibits.join(' ');
            draw();
        }

        function drawConstellation(canvas, withNoise = false) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            const cx = w / 2;
            const cy = h / 2;
            const scale = Math.min(w, h) * 0.32;

            // Axes
            ctx.strokeStyle = 'rgba(0,170,255,0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, cy);
            ctx.lineTo(w, cy);
            ctx.moveTo(cx, 0);
            ctx.lineTo(cx, h);
            ctx.stroke();

            ctx.fillStyle = '#888';
            ctx.font = '12px Courier New';
            ctx.fillText('I (In-phase)', w - 90, cy - 10);
            ctx.fillText('Q (Quadrature)', cx + 10, 15);

            // Unit circle
            ctx.strokeStyle = 'rgba(0,170,255,0.2)';
            ctx.beginPath();
            ctx.arc(cx, cy, scale * Math.sqrt(2), 0, 2 * Math.PI);
            ctx.stroke();

            if (withNoise) {
                // Decision regions
                ctx.strokeStyle = 'rgba(255,170,0,0.3)';
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, cy);
                ctx.lineTo(w, cy);
                ctx.moveTo(cx, 0);
                ctx.lineTo(cx, h);
                ctx.stroke();
                ctx.setLineDash([]);

                // Noisy points
                for (let i = 0; i < 300; i++) {
                    const sym = symbols[Math.floor(Math.random() * 4)];
                    const noiseI = (Math.random() - 0.5) * 0.8;
                    const noiseQ = (Math.random() - 0.5) * 0.8;
                    const x = cx + (sym.i + noiseI) * scale;
                    const y = cy - (sym.q + noiseQ) * scale;

                    ctx.fillStyle = sym.color.replace(')', ',0.4)').replace('rgb', 'rgba').replace('#', 'rgba(');
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }

            // Constellation points
            symbols.forEach((sym, idx) => {
                const x = cx + sym.i * scale;
                const y = cy - sym.q * scale;

                ctx.fillStyle = sym.color;
                ctx.beginPath();
                ctx.arc(x, y, withNoise ? 8 : 15, 0, 2 * Math.PI);
                ctx.fill();

                if (!withNoise) {
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 12px Courier New';
                    ctx.fillText(sym.bits, x - 8, y + 4);
                }
            });

            // Highlight current symbols
            if (!withNoise) {
                dibits.forEach((dibit, idx) => {
                    const sym = symbols.find(s => s.bits === dibit);
                    const x = cx + sym.i * scale;
                    const y = cy - sym.q * scale;

                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x, y, 20, 0, 2 * Math.PI);
                    ctx.stroke();

                    ctx.fillStyle = '#fff';
                    ctx.font = '10px Courier New';
                    ctx.fillText(`[${idx + 1}]`, x + 18, y - 10);
                });
            }
        }

        function drawWaveform(canvas) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            const symbolWidth = w / dibits.length;
            const fc = 4;

            // I component
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            dibits.forEach((dibit, idx) => {
                const sym = symbols.find(s => s.bits === dibit);
                for (let x = 0; x < symbolWidth; x++) {
                    const globalX = idx * symbolWidth + x;
                    const t = x / symbolWidth;
                    const y = h * 0.25 - sym.i * Math.cos(2 * Math.PI * fc * t) * (h * 0.18);
                    if (globalX === 0) ctx.moveTo(globalX, y);
                    else ctx.lineTo(globalX, y);
                }
            });
            ctx.stroke();

            // Q component
            ctx.strokeStyle = '#ff6688';
            ctx.beginPath();
            dibits.forEach((dibit, idx) => {
                const sym = symbols.find(s => s.bits === dibit);
                for (let x = 0; x < symbolWidth; x++) {
                    const globalX = idx * symbolWidth + x;
                    const t = x / symbolWidth;
                    const y = h * 0.5 - sym.q * Math.sin(2 * Math.PI * fc * t) * (h * 0.18);
                    if (globalX === 0) ctx.moveTo(globalX, y);
                    else ctx.lineTo(globalX, y);
                }
            });
            ctx.stroke();

            // Combined QPSK
            ctx.strokeStyle = '#00aaff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            dibits.forEach((dibit, idx) => {
                const sym = symbols.find(s => s.bits === dibit);
                for (let x = 0; x < symbolWidth; x++) {
                    const globalX = idx * symbolWidth + x;
                    const t = x / symbolWidth;
                    const i_part = sym.i * Math.cos(2 * Math.PI * fc * t);
                    const q_part = sym.q * Math.sin(2 * Math.PI * fc * t);
                    const y = h * 0.8 - (i_part - q_part) / 2 * (h * 0.15);
                    if (globalX === 0) ctx.moveTo(globalX, y);
                    else ctx.lineTo(globalX, y);
                }
            });
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#00ff88';
            ctx.font = '11px Courier New';
            ctx.fillText('I(t)', 10, 20);
            ctx.fillStyle = '#ff6688';
            ctx.fillText('Q(t)', 10, h * 0.35 + 15);
            ctx.fillStyle = '#00aaff';
            ctx.fillText('QPSK', 10, h * 0.65 + 15);

            // Symbol boundaries
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.setLineDash([3, 3]);
            for (let i = 1; i < dibits.length; i++) {
                ctx.beginPath();
                ctx.moveTo(i * symbolWidth, 0);
                ctx.lineTo(i * symbolWidth, h);
                ctx.stroke();
            }
            ctx.setLineDash([]);
        }

        function draw() {
            drawConstellation(document.getElementById('constellationCanvas'), false);
            drawConstellation(document.getElementById('noisyCanvas'), true);
            drawWaveform(document.getElementById('waveformCanvas'));
        }

        function init() {
            ['constellationCanvas', 'noisyCanvas', 'waveformCanvas'].forEach(id => {
                resizeCanvas(document.getElementById(id));
            });
            draw();
        }

        window.addEventListener('resize', init);
        init();
    </script>
</body>
</html>
