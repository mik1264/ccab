<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turbo Codes - Iterative Decoding</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #00aaff; min-height: 100vh; padding: 20px;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px; color: #00aaff;
            text-decoration: none; padding: 10px 20px;
            background: rgba(0,170,255,0.1); border: 1px solid #00aaff;
            border-radius: 5px; z-index: 100;
        }
        .container { max-width: 1100px; margin: 60px auto 0; }
        h1 { font-size: 2rem; margin-bottom: 10px; text-align: center; }
        .subtitle { color: #888; margin-bottom: 30px; text-align: center; }
        .encoder-panel {
            background: rgba(0,0,0,0.5); padding: 25px;
            border-radius: 15px; border: 1px solid #00aaff;
            margin-bottom: 20px;
        }
        .encoder-panel h3 { color: #00ccff; margin-bottom: 15px; text-align: center; }
        canvas { width: 100%; background: rgba(0,20,40,0.5); border-radius: 10px; }
        .encoder-canvas { height: 300px; }
        .performance-canvas { height: 250px; }
        .controls {
            display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;
            margin-bottom: 20px; background: rgba(0,170,255,0.05);
            padding: 20px; border-radius: 15px;
        }
        .control-group { display: flex; align-items: center; gap: 10px; }
        .control-group label { color: #888; }
        input[type="range"] { width: 150px; }
        .value { color: #00ffff; min-width: 60px; }
        button {
            padding: 12px 25px; font-family: inherit;
            background: rgba(0,170,255,0.1); border: 1px solid #00aaff;
            color: #00aaff; border-radius: 5px; cursor: pointer;
        }
        button:hover { background: rgba(0,170,255,0.3); }
        .info { background: rgba(0,170,255,0.05); padding: 20px; border-radius: 10px; }
        .info h3 { color: #00ccff; margin-bottom: 10px; }
        .info p { color: #aaa; line-height: 1.6; margin-bottom: 10px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div class="container">
        <h1>Turbo Codes</h1>
        <p class="subtitle">Parallel concatenated codes with iterative decoding - near Shannon limit!</p>

        <div class="controls">
            <div class="control-group">
                <label>Iterations:</label>
                <input type="range" id="iterations" min="1" max="10" value="5">
                <span class="value" id="iterVal">5</span>
            </div>
            <div class="control-group">
                <label>SNR (dB):</label>
                <input type="range" id="snr" min="-2" max="5" value="1" step="0.5">
                <span class="value" id="snrVal">1.0 dB</span>
            </div>
            <button onclick="runSimulation()">Run Simulation</button>
        </div>

        <div class="encoder-panel">
            <h3>Turbo Encoder Structure</h3>
            <canvas id="encoderCanvas" class="encoder-canvas"></canvas>
        </div>

        <div class="encoder-panel">
            <h3>BER vs Iterations (Iterative Decoding Gain)</h3>
            <canvas id="performanceCanvas" class="performance-canvas"></canvas>
        </div>

        <div class="info">
            <h3>Why Turbo Codes are Revolutionary</h3>
            <p><strong>Structure:</strong> Two RSC encoders in parallel, connected by an interleaver. Third output is from interleaved data.</p>
            <p><strong>Interleaver:</strong> Scrambles bit order before second encoder. Creates statistical independence between parity checks.</p>
            <p><strong>Iterative Decoding:</strong> Two SISO decoders pass "extrinsic information" back and forth. Each iteration improves estimates!</p>
            <p><strong>Near Shannon Limit:</strong> At rate 1/3 with large interleaver, can achieve BER=10⁻⁵ at just 0.7 dB from capacity!</p>
            <p><strong>Applications:</strong> 3G/4G cellular, deep space (Mars missions), satellite, WiMAX.</p>
        </div>
    </div>

    <script>
        let iterations = 5;
        let snr = 1.0;
        let simulationResults = [];

        function resizeCanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.getContext('2d').scale(dpr, dpr);
        }

        function drawEncoder(canvas) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            const boxW = 120;
            const boxH = 50;
            const cx = w / 2;

            // Input
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 14px Courier New';
            ctx.fillText('Input Bits', 30, 50);
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(100, 45);
            ctx.lineTo(200, 45);
            ctx.stroke();

            // Split point
            ctx.beginPath();
            ctx.arc(200, 45, 5, 0, 2 * Math.PI);
            ctx.fill();

            // RSC Encoder 1
            const enc1X = cx - 60;
            const enc1Y = 80;
            ctx.strokeStyle = '#00aaff';
            ctx.strokeRect(enc1X, enc1Y, boxW, boxH);
            ctx.fillStyle = 'rgba(0,170,255,0.2)';
            ctx.fillRect(enc1X, enc1Y, boxW, boxH);
            ctx.fillStyle = '#00ccff';
            ctx.font = '12px Courier New';
            ctx.fillText('RSC Encoder 1', enc1X + 10, enc1Y + 30);

            // Connection to encoder 1
            ctx.strokeStyle = '#00ff88';
            ctx.beginPath();
            ctx.moveTo(200, 45);
            ctx.lineTo(200, enc1Y + boxH / 2);
            ctx.lineTo(enc1X, enc1Y + boxH / 2);
            ctx.stroke();

            // Interleaver
            const intX = cx - 60;
            const intY = 160;
            ctx.strokeStyle = '#ffaa00';
            ctx.strokeRect(intX, intY, boxW, boxH);
            ctx.fillStyle = 'rgba(255,170,0,0.2)';
            ctx.fillRect(intX, intY, boxW, boxH);
            ctx.fillStyle = '#ffaa00';
            ctx.fillText('Interleaver π', intX + 15, intY + 30);

            // Connection to interleaver
            ctx.strokeStyle = '#00ff88';
            ctx.beginPath();
            ctx.moveTo(200, 45);
            ctx.lineTo(200, intY + boxH / 2);
            ctx.lineTo(intX, intY + boxH / 2);
            ctx.stroke();

            // RSC Encoder 2
            const enc2X = cx - 60;
            const enc2Y = 230;
            ctx.strokeStyle = '#ff6688';
            ctx.strokeRect(enc2X, enc2Y, boxW, boxH);
            ctx.fillStyle = 'rgba(255,102,136,0.2)';
            ctx.fillRect(enc2X, enc2Y, boxW, boxH);
            ctx.fillStyle = '#ff6688';
            ctx.fillText('RSC Encoder 2', enc2X + 10, enc2Y + 30);

            // Connection from interleaver to encoder 2
            ctx.strokeStyle = '#ffaa00';
            ctx.beginPath();
            ctx.moveTo(intX + boxW, intY + boxH / 2);
            ctx.lineTo(intX + boxW + 40, intY + boxH / 2);
            ctx.lineTo(intX + boxW + 40, enc2Y + boxH / 2);
            ctx.lineTo(enc2X + boxW, enc2Y + boxH / 2);
            ctx.stroke();

            // Outputs
            const outX = w - 150;

            // Systematic output
            ctx.fillStyle = '#00ff88';
            ctx.fillText('Systematic (x)', outX, 55);
            ctx.strokeStyle = '#00ff88';
            ctx.beginPath();
            ctx.moveTo(200, 45);
            ctx.lineTo(outX - 20, 50);
            ctx.stroke();

            // Parity 1 output
            ctx.fillStyle = '#00aaff';
            ctx.fillText('Parity 1 (y1)', outX, enc1Y + boxH / 2 + 5);
            ctx.strokeStyle = '#00aaff';
            ctx.beginPath();
            ctx.moveTo(enc1X + boxW, enc1Y + boxH / 2);
            ctx.lineTo(outX - 20, enc1Y + boxH / 2);
            ctx.stroke();

            // Parity 2 output
            ctx.fillStyle = '#ff6688';
            ctx.fillText('Parity 2 (y2)', outX, enc2Y + boxH / 2 + 5);
            ctx.strokeStyle = '#ff6688';
            ctx.beginPath();
            ctx.moveTo(enc2X + boxW, enc2Y + boxH / 2);
            ctx.lineTo(outX - 20, enc2Y + boxH / 2);
            ctx.stroke();

            // Rate annotation
            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.fillText('Rate = 1/3', w - 80, h - 20);
            ctx.fillText('(1 input → 3 outputs)', w - 150, h - 5);
        }

        function simulateBER(snrDb, iters) {
            // Simplified simulation of turbo code performance
            const snrLinear = Math.pow(10, snrDb / 10);
            const Eb_N0 = snrLinear * (1/3); // Rate 1/3

            // Approximate BER curve for turbo codes with iteration
            let ber = 0.5 * Math.exp(-0.5 * Eb_N0);

            // Iterative decoding gain
            for (let i = 1; i < iters; i++) {
                ber *= 0.3; // Each iteration reduces BER significantly
            }

            // Waterfall effect
            if (snrDb > 1.5) {
                ber *= Math.pow(10, -(snrDb - 1.5) * 2);
            }

            return Math.max(ber, 1e-10);
        }

        function runSimulation() {
            iterations = parseInt(document.getElementById('iterations').value);
            snr = parseFloat(document.getElementById('snr').value);

            simulationResults = [];
            for (let i = 1; i <= 10; i++) {
                simulationResults.push({
                    iter: i,
                    ber: simulateBER(snr, i)
                });
            }

            drawPerformance(document.getElementById('performanceCanvas'));
        }

        function drawPerformance(canvas) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            if (simulationResults.length === 0) {
                ctx.fillStyle = '#888';
                ctx.font = '14px Courier New';
                ctx.fillText('Click "Run Simulation" to see iterative decoding performance', w/2 - 200, h/2);
                return;
            }

            const padding = 60;
            const plotW = w - 2 * padding;
            const plotH = h - 2 * padding;

            // Grid
            ctx.strokeStyle = 'rgba(0,170,255,0.1)';
            for (let i = 0; i <= 10; i++) {
                const x = padding + (i / 10) * plotW;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, h - padding);
                ctx.stroke();
            }

            // Axes
            ctx.strokeStyle = 'rgba(0,170,255,0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, h - padding);
            ctx.lineTo(w - padding, h - padding);
            ctx.moveTo(padding, h - padding);
            ctx.lineTo(padding, padding);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '12px Courier New';
            ctx.fillText('Iteration', w / 2 - 30, h - 10);
            ctx.save();
            ctx.translate(15, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('BER (log scale)', -40, 0);
            ctx.restore();

            // X axis labels
            for (let i = 1; i <= 10; i++) {
                const x = padding + (i / 10) * plotW;
                ctx.fillText(i.toString(), x - 3, h - padding + 20);
            }

            // Y axis labels (log scale)
            const logMin = -10;
            const logMax = 0;
            for (let log = 0; log >= -10; log -= 2) {
                const y = padding + ((logMax - log) / (logMax - logMin)) * plotH;
                ctx.fillText(`10^${log}`, 5, y + 4);
            }

            // Plot BER curve
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 3;
            ctx.beginPath();

            simulationResults.forEach((point, idx) => {
                const x = padding + (point.iter / 10) * plotW;
                const logBer = Math.log10(point.ber);
                const y = padding + ((logMax - logBer) / (logMax - logMin)) * plotH;

                if (idx === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Mark current iteration
            const currentPoint = simulationResults[iterations - 1];
            const cx = padding + (iterations / 10) * plotW;
            const cy = padding + ((logMax - Math.log10(currentPoint.ber)) / (logMax - logMin)) * plotH;

            ctx.fillStyle = '#ffaa00';
            ctx.beginPath();
            ctx.arc(cx, cy, 8, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = '#ffaa00';
            ctx.font = '11px Courier New';
            ctx.fillText(`Iter ${iterations}: BER ≈ ${currentPoint.ber.toExponential(1)}`, cx + 15, cy);

            // SNR label
            ctx.fillStyle = '#00ccff';
            ctx.fillText(`SNR = ${snr.toFixed(1)} dB`, w - 120, padding + 20);
        }

        function update() {
            iterations = parseInt(document.getElementById('iterations').value);
            snr = parseFloat(document.getElementById('snr').value);
            document.getElementById('iterVal').textContent = iterations;
            document.getElementById('snrVal').textContent = snr.toFixed(1) + ' dB';
        }

        function init() {
            ['encoderCanvas', 'performanceCanvas'].forEach(id => {
                resizeCanvas(document.getElementById(id));
            });
            drawEncoder(document.getElementById('encoderCanvas'));
            drawPerformance(document.getElementById('performanceCanvas'));
        }

        ['iterations', 'snr'].forEach(id => {
            document.getElementById(id).addEventListener('input', update);
        });

        window.addEventListener('resize', init);
        init();
    </script>
</body>
</html>
