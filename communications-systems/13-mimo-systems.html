<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIMO Systems - Multiple Input Multiple Output</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #00aaff; min-height: 100vh; padding: 20px;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px; color: #00aaff;
            text-decoration: none; padding: 10px 20px;
            background: rgba(0,170,255,0.1); border: 1px solid #00aaff;
            border-radius: 5px; z-index: 100;
        }
        .container { max-width: 1100px; margin: 60px auto 0; }
        h1 { font-size: 2rem; margin-bottom: 10px; text-align: center; }
        .subtitle { color: #888; margin-bottom: 30px; text-align: center; }
        .controls {
            display: grid; grid-template-columns: repeat(3, 1fr);
            gap: 20px; margin-bottom: 20px;
            background: rgba(0,170,255,0.05); padding: 20px; border-radius: 15px;
        }
        .control-group label { display: block; color: #888; margin-bottom: 8px; }
        input[type="range"] {
            width: 100%; height: 8px; background: rgba(0,170,255,0.2); border-radius: 4px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px;
            background: #00aaff; border-radius: 50%; cursor: pointer;
        }
        .value { color: #00ffff; font-size: 0.9rem; margin-top: 5px; }
        .main-panel {
            background: rgba(0,0,0,0.5); padding: 25px;
            border-radius: 15px; border: 1px solid #00aaff;
            margin-bottom: 20px;
        }
        .main-panel h3 { color: #00ccff; margin-bottom: 15px; text-align: center; }
        canvas { width: 100%; height: 350px; background: rgba(0,20,40,0.5); border-radius: 10px; }
        .stats {
            display: grid; grid-template-columns: repeat(4, 1fr);
            gap: 15px; margin-top: 20px;
        }
        .stat {
            background: rgba(0,170,255,0.1); padding: 15px;
            border-radius: 10px; text-align: center;
        }
        .stat-value { font-size: 1.5rem; color: #00ffff; }
        .stat-label { font-size: 0.8rem; color: #888; }
        .info { background: rgba(0,170,255,0.05); padding: 20px; border-radius: 10px; }
        .info h3 { color: #00ccff; margin-bottom: 10px; }
        .info p { color: #aaa; line-height: 1.6; margin-bottom: 10px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div class="container">
        <h1>MIMO Systems</h1>
        <p class="subtitle">Multiple Input Multiple Output - spatial multiplexing and diversity</p>

        <div class="controls">
            <div class="control-group">
                <label>Transmit Antennas (Nt)</label>
                <input type="range" id="txAntennas" min="1" max="8" value="4">
                <div class="value" id="txVal">4 antennas</div>
            </div>
            <div class="control-group">
                <label>Receive Antennas (Nr)</label>
                <input type="range" id="rxAntennas" min="1" max="8" value="4">
                <div class="value" id="rxVal">4 antennas</div>
            </div>
            <div class="control-group">
                <label>SNR (dB)</label>
                <input type="range" id="snr" min="0" max="30" value="15">
                <div class="value" id="snrVal">15 dB</div>
            </div>
        </div>

        <div class="main-panel">
            <h3>MIMO Channel Visualization</h3>
            <canvas id="mimoCanvas"></canvas>
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="streams">4</div>
                    <div class="stat-label">Parallel Streams</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="capacity">26.8</div>
                    <div class="stat-label">Capacity (bits/s/Hz)</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="multiplexGain">4×</div>
                    <div class="stat-label">Multiplexing Gain</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="diversityGain">16</div>
                    <div class="stat-label">Diversity Order</div>
                </div>
            </div>
        </div>

        <div class="info">
            <h3>MIMO Benefits</h3>
            <p><strong>Spatial Multiplexing:</strong> Send multiple data streams simultaneously using different spatial paths. Capacity scales with min(Nt, Nr)!</p>
            <p><strong>Diversity Gain:</strong> Combat fading by receiving signal through multiple independent paths. Diversity order = Nt × Nr.</p>
            <p><strong>Beamforming:</strong> Focus energy in specific directions for increased range or reduced interference.</p>
            <p><strong>Capacity Formula:</strong> C = log₂|I + (SNR/Nt)·H·H†| bits/s/Hz where H is the Nr×Nt channel matrix.</p>
            <p><strong>Applications:</strong> Wi-Fi 4/5/6 (up to 8×8), LTE-Advanced (up to 8×8), 5G NR (up to 256×256 massive MIMO).</p>
        </div>
    </div>

    <script>
        let nt = 4, nr = 4, snr = 15;

        function resizeCanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.getContext('2d').scale(dpr, dpr);
        }

        function generateChannel() {
            // Generate random complex channel matrix (simplified to real for visualization)
            const H = [];
            for (let i = 0; i < nr; i++) {
                H.push([]);
                for (let j = 0; j < nt; j++) {
                    // Rayleigh fading: complex Gaussian
                    const real = (Math.random() + Math.random() + Math.random() - 1.5) * 0.7;
                    const imag = (Math.random() + Math.random() + Math.random() - 1.5) * 0.7;
                    H[i].push({ re: real, im: imag, mag: Math.sqrt(real*real + imag*imag) });
                }
            }
            return H;
        }

        function computeCapacity(H, snrLinear) {
            // Simplified capacity calculation
            let capacity = 0;
            const minDim = Math.min(nt, nr);

            // Approximate eigenvalues based on channel gains
            for (let i = 0; i < minDim; i++) {
                let eigenValue = 0;
                for (let j = 0; j < H.length; j++) {
                    for (let k = 0; k < H[0].length; k++) {
                        eigenValue += H[j][k].mag * H[j][k].mag / (nt * nr);
                    }
                }
                eigenValue = eigenValue * (1 + 0.3 * (Math.random() - 0.5));
                capacity += Math.log2(1 + (snrLinear / nt) * eigenValue);
            }

            return capacity;
        }

        function drawMIMO(canvas) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            const H = generateChannel();

            // TX antennas
            const txX = 100;
            const rxX = w - 100;
            const txSpacing = (h - 100) / Math.max(nt, 1);
            const rxSpacing = (h - 100) / Math.max(nr, 1);

            // Draw channel paths
            for (let i = 0; i < nr; i++) {
                for (let j = 0; j < nt; j++) {
                    const txY = 50 + j * txSpacing + txSpacing / 2;
                    const rxY = 50 + i * rxSpacing + rxSpacing / 2;
                    const gain = H[i][j].mag;

                    ctx.strokeStyle = `rgba(0, 170, 255, ${Math.min(gain * 0.8, 0.8)})`;
                    ctx.lineWidth = Math.max(1, gain * 3);

                    ctx.beginPath();
                    ctx.moveTo(txX + 20, txY);

                    // Curved path
                    const midX = (txX + rxX) / 2;
                    const offset = (Math.random() - 0.5) * 50;
                    ctx.quadraticCurveTo(midX, (txY + rxY) / 2 + offset, rxX - 20, rxY);
                    ctx.stroke();
                }
            }

            // Draw TX antennas
            ctx.fillStyle = '#00ff88';
            for (let j = 0; j < nt; j++) {
                const y = 50 + j * txSpacing + txSpacing / 2;

                // Antenna icon
                ctx.beginPath();
                ctx.moveTo(txX - 15, y + 15);
                ctx.lineTo(txX, y - 15);
                ctx.lineTo(txX + 15, y + 15);
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(txX, y + 15);
                ctx.lineTo(txX, y - 15);
                ctx.stroke();

                // Radiation pattern
                ctx.strokeStyle = 'rgba(0,255,136,0.3)';
                for (let r = 1; r <= 3; r++) {
                    ctx.beginPath();
                    ctx.arc(txX, y, r * 10, -0.5, 0.5);
                    ctx.stroke();
                }
            }

            // Draw RX antennas
            ctx.fillStyle = '#ff6688';
            for (let i = 0; i < nr; i++) {
                const y = 50 + i * rxSpacing + rxSpacing / 2;

                // Antenna icon
                ctx.beginPath();
                ctx.moveTo(rxX - 15, y + 15);
                ctx.lineTo(rxX, y - 15);
                ctx.lineTo(rxX + 15, y + 15);
                ctx.strokeStyle = '#ff6688';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(rxX, y + 15);
                ctx.lineTo(rxX, y - 15);
                ctx.stroke();
            }

            // Labels
            ctx.fillStyle = '#00ff88';
            ctx.font = '14px Courier New';
            ctx.fillText('Transmitter', txX - 40, 30);
            ctx.fillStyle = '#ff6688';
            ctx.fillText('Receiver', rxX - 30, 30);

            // Channel matrix H
            ctx.fillStyle = '#888';
            ctx.font = '12px Courier New';
            ctx.fillText(`Channel Matrix H: ${nr}×${nt}`, w / 2 - 60, h - 20);

            // Update stats
            const snrLinear = Math.pow(10, snr / 10);
            const capacity = computeCapacity(H, snrLinear);

            document.getElementById('streams').textContent = Math.min(nt, nr);
            document.getElementById('capacity').textContent = capacity.toFixed(1);
            document.getElementById('multiplexGain').textContent = Math.min(nt, nr) + '×';
            document.getElementById('diversityGain').textContent = nt * nr;
        }

        function update() {
            nt = parseInt(document.getElementById('txAntennas').value);
            nr = parseInt(document.getElementById('rxAntennas').value);
            snr = parseInt(document.getElementById('snr').value);

            document.getElementById('txVal').textContent = nt + ' antennas';
            document.getElementById('rxVal').textContent = nr + ' antennas';
            document.getElementById('snrVal').textContent = snr + ' dB';

            drawMIMO(document.getElementById('mimoCanvas'));
        }

        function init() {
            resizeCanvas(document.getElementById('mimoCanvas'));
            update();
        }

        ['txAntennas', 'rxAntennas', 'snr'].forEach(id => {
            document.getElementById(id).addEventListener('input', update);
        });

        window.addEventListener('resize', init);
        setInterval(() => drawMIMO(document.getElementById('mimoCanvas')), 2000);
        init();
    </script>
</body>
</html>
