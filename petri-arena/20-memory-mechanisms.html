<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>20. Memory Mechanisms - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        .container {
            text-align: center;
        }
        canvas {
            border: 2px solid #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            background: #000;
        }
        h1 {
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
        }
        .info {
            margin-top: 15px;
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 700px;
            line-height: 1.6;
        }
        .stats {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 0.95rem;
            flex-wrap: wrap;
        }
        .stat {
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }
        .memory-display {
            margin-top: 15px;
            padding: 15px 25px;
            background: rgba(138, 43, 226, 0.1);
            border-radius: 8px;
            border: 2px solid rgba(138, 43, 226, 0.4);
            display: inline-block;
        }
        .memory-title {
            font-weight: bold;
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: #8a2be2;
        }
        .memory-channels {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 10px;
        }
        .memory-channel {
            text-align: center;
        }
        .memory-bar {
            width: 60px;
            height: 120px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            border: 1px solid rgba(138, 43, 226, 0.5);
            position: relative;
            overflow: hidden;
        }
        .memory-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(180deg, #8a2be2, #4b0082);
            transition: height 0.3s;
        }
        .memory-label {
            font-size: 0.85rem;
            margin-top: 5px;
            color: #8a2be2;
        }
        .memory-value {
            font-size: 0.75rem;
            opacity: 0.8;
        }
        .round-counter {
            font-size: 1.1rem;
            font-weight: bold;
            margin-top: 10px;
            color: #ffa500;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 8px 20px;
            font-size: 0.9rem;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ’¾ Memory Mechanisms</h1>
        <canvas id="canvas"></canvas>
        <div class="stats">
            <div class="stat">Step: <span id="step">0</span></div>
            <div class="stat">Territory: <span id="territory">0</span>%</div>
            <div class="stat">Attack: <span id="attack">1.00</span></div>
            <div class="stat">Defense: <span id="defense">1.00</span></div>
        </div>
        <div class="memory-display">
            <div class="memory-title">ðŸ§  Memory State</div>
            <div class="round-counter">Round: <span id="round">1</span> / 5</div>
            <div class="memory-channels">
                <div class="memory-channel">
                    <div class="memory-bar">
                        <div class="memory-fill" id="memoryFill1"></div>
                    </div>
                    <div class="memory-label">Memory 1</div>
                    <div class="memory-value" id="memoryValue1">0.00</div>
                </div>
                <div class="memory-channel">
                    <div class="memory-bar">
                        <div class="memory-fill" id="memoryFill2"></div>
                    </div>
                    <div class="memory-label">Memory 2</div>
                    <div class="memory-value" id="memoryValue2">0.00</div>
                </div>
                <div class="memory-channel">
                    <div class="memory-bar">
                        <div class="memory-fill" id="memoryFill3"></div>
                    </div>
                    <div class="memory-label">Memory 3</div>
                    <div class="memory-value" id="memoryValue3">0.00</div>
                </div>
            </div>
        </div>
        <div class="controls">
            <button onclick="togglePause()">Pause/Resume</button>
            <button onclick="reset()">Reset</button>
            <button onclick="nextRound()">Next Round â†’</button>
            <button onclick="location.href='index.html'">Back to Gallery</button>
        </div>
        <div class="info">
            Agent with persistent memory channels that retain information across multiple rounds. Memory channels store
            learned patterns and strategies, providing continuity between episodes. After each round (200 steps), the arena
            resets but memory persists, allowing the agent to apply accumulated knowledge. Watch how memory improves
            performance over successive rounds.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const gridSize = 128;
        const cellSize = 4;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;

        const tau = 0.5;
        const learningRate = 0.05;
        const memoryDecay = 0.95; // Memory retention factor
        const roundLength = 200; // Steps per round
        let step = 0;
        let paused = false;
        let round = 1;
        let roundStep = 0;

        let state = createState();
        let params = { attackMult: 1.0, defenseMult: 1.0 };
        let memory = [0, 0, 0]; // Persistent memory channels
        let prevTerritory = 0;

        function createState() {
            return {
                attack: [
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0)),
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ],
                defense: [
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0)),
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ],
                aliveness: [
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0)),
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ]
            };
        }

        function init() {
            state = createState();
            params = { attackMult: 1.0, defenseMult: 1.0 };
            memory = [0, 0, 0];
            round = 1;
            roundStep = 0;
            startRound();
            step = 0;
        }

        function startRound() {
            // Reset arena but keep memory and learned parameters
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    state.attack[0][y][x] = Math.random() * 0.3 - 0.15;
                    state.defense[0][y][x] = Math.random() * 0.3 - 0.15;
                    state.aliveness[0][y][x] = 0.5;
                    state.attack[1][y][x] = 0;
                    state.defense[1][y][x] = 0;
                    state.aliveness[1][y][x] = 0;
                }
            }

            // Agent - spawn with memory influence
            const cx = gridSize / 2, cy = gridSize / 2, r = 20;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                    if (dist < r) {
                        // Initialize with memory bias
                        state.attack[1][y][x] = Math.random() * 0.5 + 0.4 + memory[0] * 0.1;
                        state.defense[1][y][x] = Math.random() * 0.5 + 0.4 + memory[1] * 0.1;
                        state.aliveness[1][y][x] = 1.0;
                    }
                }
            }

            roundStep = 0;
            prevTerritory = 0;
        }

        function nextRound() {
            if (round < 5) {
                round++;
                updateMemory();
                startRound();
            }
        }

        function updateMemory() {
            // Store learned information in memory
            const territoryPerformance = calculateTerritory();
            memory[0] = memory[0] * memoryDecay + params.attackMult * 0.1;
            memory[1] = memory[1] * memoryDecay + params.defenseMult * 0.1;
            memory[2] = memory[2] * memoryDecay + territoryPerformance * 0.5;

            // Clamp memory values
            memory = memory.map(m => Math.max(-1, Math.min(1, m)));
        }

        function computeStrength(attacker, defender, y, x) {
            const a = state.attack[attacker][y][x] * (attacker === 1 ? params.attackMult : 1.0);
            const d = state.defense[defender][y][x] * (defender === 1 ? params.defenseMult : 1.0);
            return a * d;
        }

        function update() {
            const currentTerritory = calculateTerritory();
            const gradient = currentTerritory - prevTerritory;

            // Learning with memory influence
            const memoryBoost = (memory[0] + memory[1] + memory[2]) / 3;
            params.attackMult += (learningRate + memoryBoost * 0.02) * gradient + (Math.random() - 0.5) * 0.02;
            params.defenseMult += (learningRate + memoryBoost * 0.02) * gradient + (Math.random() - 0.5) * 0.02;
            params.attackMult = Math.max(0.5, Math.min(2.5, params.attackMult));
            params.defenseMult = Math.max(0.5, Math.min(2.5, params.defenseMult));

            prevTerritory = currentTerritory;

            // Update state
            const newState = {
                attack: state.attack.map(a => a.map(row => [...row])),
                defense: state.defense.map(d => d.map(row => [...row])),
                aliveness: state.aliveness.map(a => a.map(row => [...row]))
            };

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    const deltas = [0, 1].map(agent => {
                        let avgAttack = 0, avgDefense = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                avgAttack += state.attack[agent][y + dy][x + dx];
                                avgDefense += state.defense[agent][y + dy][x + dx];
                            }
                        }
                        return {
                            attack: (avgAttack / 9 - state.attack[agent][y][x]) * 0.1,
                            defense: (avgDefense / 9 - state.defense[agent][y][x]) * 0.1
                        };
                    });

                    const strengths = [
                        computeStrength(0, 1, y, x) + state.aliveness[0][y][x],
                        computeStrength(1, 0, y, x) + state.aliveness[1][y][x]
                    ];

                    const maxStrength = Math.max(...strengths);
                    const expStrengths = strengths.map(s => Math.exp((s - maxStrength) / tau));
                    const sumExp = expStrengths.reduce((a, b) => a + b, 0);
                    const weights = expStrengths.map(e => e / sumExp);

                    [0, 1].forEach(agent => {
                        newState.attack[agent][y][x] = Math.max(-1, Math.min(1,
                            state.attack[agent][y][x] + deltas[agent].attack * weights[agent]
                        ));
                        newState.defense[agent][y][x] = Math.max(-1, Math.min(1,
                            state.defense[agent][y][x] + deltas[agent].defense * weights[agent]
                        ));
                        newState.aliveness[agent][y][x] = weights[agent];
                    });
                }
            }

            state = newState;
            step++;
            roundStep++;

            // Auto-advance to next round
            if (roundStep >= roundLength && round < 5) {
                nextRound();
            }
        }

        function calculateTerritory() {
            let count = 0;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (state.aliveness[1][y][x] > state.aliveness[0][y][x]) count++;
                }
            }
            return count / (gridSize * gridSize);
        }

        function render() {
            const imageData = ctx.createImageData(gridSize, gridSize);
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const idx = (y * gridSize + x) * 4;
                    const winner = state.aliveness[1][y][x] > state.aliveness[0][y][x] ? 1 : 0;
                    const intensity = state.aliveness[winner][y][x];

                    if (winner === 1) {
                        imageData.data[idx] = 0;
                        imageData.data[idx + 1] = 245 * intensity;
                        imageData.data[idx + 2] = 255 * intensity;
                    } else {
                        imageData.data[idx] = 100 * intensity;
                        imageData.data[idx + 1] = 100 * intensity;
                        imageData.data[idx + 2] = 100 * intensity;
                    }
                    imageData.data[idx + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(canvas, 0, 0, gridSize, gridSize, 0, 0, canvas.width, canvas.height);

            document.getElementById('step').textContent = step;
            document.getElementById('territory').textContent = (calculateTerritory() * 100).toFixed(1);
            document.getElementById('attack').textContent = params.attackMult.toFixed(2);
            document.getElementById('defense').textContent = params.defenseMult.toFixed(2);
            document.getElementById('round').textContent = round;

            // Update memory visualization
            for (let i = 0; i < 3; i++) {
                const normalized = (memory[i] + 1) / 2; // Normalize to 0-1
                document.getElementById(`memoryFill${i + 1}`).style.height = (normalized * 100) + '%';
                document.getElementById(`memoryValue${i + 1}`).textContent = memory[i].toFixed(2);
            }
        }

        function animate() {
            if (!paused) {
                update();
                render();
            }
            requestAnimationFrame(animate);
        }

        function togglePause() {
            paused = !paused;
        }

        function reset() {
            init();
            render();
        }

        init();
        animate();
    </script>
</body>
</html>
