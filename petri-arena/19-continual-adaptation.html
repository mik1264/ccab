<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>19. Continual Adaptation - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        .container {
            text-align: center;
        }
        canvas {
            border: 2px solid #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            background: #000;
        }
        h1 {
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
        }
        .info {
            margin-top: 15px;
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 700px;
            line-height: 1.6;
        }
        .stats {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 0.95rem;
            flex-wrap: wrap;
        }
        .stat {
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }
        .environment-monitor {
            margin-top: 15px;
            padding: 15px 25px;
            background: rgba(255, 165, 0, 0.1);
            border-radius: 8px;
            border: 2px solid rgba(255, 165, 0, 0.4);
            display: inline-block;
        }
        .env-title {
            font-weight: bold;
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: #ffa500;
        }
        .env-metric {
            font-size: 0.95rem;
            margin: 5px 0;
        }
        .progress-bar {
            width: 300px;
            height: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            margin: 8px auto;
            overflow: hidden;
            border: 1px solid rgba(255, 165, 0, 0.3);
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffa500, #ff4444);
            transition: width 0.3s;
        }
        .adaptation-indicator {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 5px;
            font-size: 0.85rem;
            font-weight: bold;
            margin-left: 10px;
        }
        .adapting {
            background: #00ff00;
            color: #000;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        .controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 8px 20px;
            font-size: 0.9rem;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŒŠ Continual Adaptation</h1>
        <canvas id="canvas"></canvas>
        <div class="stats">
            <div class="stat">Step: <span id="step">0</span></div>
            <div class="stat">Territory: <span id="territory">0</span>%</div>
            <div class="stat">Attack: <span id="attack">1.00</span></div>
            <div class="stat">Defense: <span id="defense">1.00</span></div>
        </div>
        <div class="environment-monitor">
            <div class="env-title">
                Environment Drift
                <span class="adaptation-indicator adapting">âš¡ Adapting</span>
            </div>
            <div class="env-metric">Background Strength: <span id="bgStrength">0.50</span></div>
            <div class="progress-bar">
                <div class="progress-fill" id="driftProgress" style="width: 0%"></div>
            </div>
            <div class="env-metric">Difficulty increases gradually over time</div>
        </div>
        <div class="controls">
            <button onclick="togglePause()">Pause/Resume</button>
            <button onclick="reset()">Reset</button>
            <button onclick="location.href='index.html'">Back to Gallery</button>
        </div>
        <div class="info">
            The environment slowly drifts: background strength gradually increases from weak (0.5) to strong (2.0) over time.
            The agent must continually adapt its parameters to maintain territory control against evolving environmental pressure.
            This demonstrates lifelong learning where the agent never stops adapting to changing conditions.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const gridSize = 128;
        const cellSize = 4;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;

        const tau = 0.5;
        const learningRate = 0.04;
        const driftRate = 0.0005; // How fast environment changes
        let step = 0;
        let paused = false;

        let state = createState();
        let params = { attackMult: 1.0, defenseMult: 1.0 };
        let backgroundStrength = 0.5; // Starts weak, increases over time
        let prevTerritory = 0;

        function createState() {
            return {
                attack: [
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0)),
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ],
                defense: [
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0)),
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ],
                aliveness: [
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0)),
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ]
            };
        }

        function init() {
            state = createState();
            params = { attackMult: 1.0, defenseMult: 1.0 };
            backgroundStrength = 0.5;

            // Background - covers entire grid
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    state.attack[0][y][x] = Math.random() * 0.4 - 0.2;
                    state.defense[0][y][x] = Math.random() * 0.4 - 0.2;
                    state.aliveness[0][y][x] = 0.8;
                }
            }

            // Agent - starts in center
            const cx = gridSize / 2, cy = gridSize / 2, r = 22;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                    if (dist < r) {
                        state.attack[1][y][x] = Math.random() * 0.6 + 0.5;
                        state.defense[1][y][x] = Math.random() * 0.6 + 0.5;
                        state.aliveness[1][y][x] = 1.0;
                    }
                }
            }

            prevTerritory = 0;
            step = 0;
        }

        function computeStrength(attacker, defender, y, x) {
            const a = state.attack[attacker][y][x] * (attacker === 1 ? params.attackMult : backgroundStrength);
            const d = state.defense[defender][y][x] * (defender === 1 ? params.defenseMult : backgroundStrength);
            return a * d;
        }

        function update() {
            // Environment drift - background gets stronger over time
            backgroundStrength += driftRate;
            backgroundStrength = Math.min(2.0, backgroundStrength);

            const currentTerritory = calculateTerritory();
            const gradient = currentTerritory - prevTerritory;

            // Continual learning to adapt to changing environment
            params.attackMult += learningRate * gradient + (Math.random() - 0.5) * 0.025;
            params.defenseMult += learningRate * gradient + (Math.random() - 0.5) * 0.025;
            params.attackMult = Math.max(0.5, Math.min(3.0, params.attackMult));
            params.defenseMult = Math.max(0.5, Math.min(3.0, params.defenseMult));

            prevTerritory = currentTerritory;

            // Update state
            const newState = {
                attack: state.attack.map(a => a.map(row => [...row])),
                defense: state.defense.map(d => d.map(row => [...row])),
                aliveness: state.aliveness.map(a => a.map(row => [...row]))
            };

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    const deltas = [0, 1].map(agent => {
                        let avgAttack = 0, avgDefense = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                avgAttack += state.attack[agent][y + dy][x + dx];
                                avgDefense += state.defense[agent][y + dy][x + dx];
                            }
                        }
                        return {
                            attack: (avgAttack / 9 - state.attack[agent][y][x]) * 0.1,
                            defense: (avgDefense / 9 - state.defense[agent][y][x]) * 0.1
                        };
                    });

                    const strengths = [
                        computeStrength(0, 1, y, x) + state.aliveness[0][y][x],
                        computeStrength(1, 0, y, x) + state.aliveness[1][y][x]
                    ];

                    const maxStrength = Math.max(...strengths);
                    const expStrengths = strengths.map(s => Math.exp((s - maxStrength) / tau));
                    const sumExp = expStrengths.reduce((a, b) => a + b, 0);
                    const weights = expStrengths.map(e => e / sumExp);

                    [0, 1].forEach(agent => {
                        newState.attack[agent][y][x] = Math.max(-1, Math.min(1,
                            state.attack[agent][y][x] + deltas[agent].attack * weights[agent]
                        ));
                        newState.defense[agent][y][x] = Math.max(-1, Math.min(1,
                            state.defense[agent][y][x] + deltas[agent].defense * weights[agent]
                        ));
                        newState.aliveness[agent][y][x] = weights[agent];
                    });
                }
            }

            state = newState;
            step++;
        }

        function calculateTerritory() {
            let count = 0;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (state.aliveness[1][y][x] > state.aliveness[0][y][x]) count++;
                }
            }
            return count / (gridSize * gridSize);
        }

        function render() {
            const imageData = ctx.createImageData(gridSize, gridSize);
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const idx = (y * gridSize + x) * 4;
                    const winner = state.aliveness[1][y][x] > state.aliveness[0][y][x] ? 1 : 0;
                    const intensity = state.aliveness[winner][y][x];

                    if (winner === 1) {
                        imageData.data[idx] = 0;
                        imageData.data[idx + 1] = 245 * intensity;
                        imageData.data[idx + 2] = 255 * intensity;
                    } else {
                        // Background color intensity based on strength
                        const bgIntensity = Math.min(1, backgroundStrength / 2);
                        imageData.data[idx] = 255 * intensity * bgIntensity;
                        imageData.data[idx + 1] = 100 * intensity * bgIntensity;
                        imageData.data[idx + 2] = 50 * intensity * bgIntensity;
                    }
                    imageData.data[idx + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(canvas, 0, 0, gridSize, gridSize, 0, 0, canvas.width, canvas.height);

            document.getElementById('step').textContent = step;
            document.getElementById('territory').textContent = (calculateTerritory() * 100).toFixed(1);
            document.getElementById('attack').textContent = params.attackMult.toFixed(2);
            document.getElementById('defense').textContent = params.defenseMult.toFixed(2);
            document.getElementById('bgStrength').textContent = backgroundStrength.toFixed(2);

            const driftPercent = ((backgroundStrength - 0.5) / (2.0 - 0.5)) * 100;
            document.getElementById('driftProgress').style.width = driftPercent + '%';
        }

        function animate() {
            if (!paused) {
                update();
                render();
            }
            requestAnimationFrame(animate);
        }

        function togglePause() {
            paused = !paused;
        }

        function reset() {
            init();
            render();
        }

        init();
        animate();
    </script>
</body>
</html>
