<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Territory Control Heatmap - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
        }
        .description {
            max-width: 800px;
            text-align: center;
            margin-bottom: 20px;
            color: #aaa;
        }
        .canvases {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .canvas-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .canvas-label {
            margin-bottom: 8px;
            font-weight: bold;
        }
        canvas {
            border: 2px solid #667eea;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 10px 20px;
            background: #667eea;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        button:hover {
            background: #764ba2;
        }
        .stats {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-family: monospace;
            min-width: 600px;
        }
        .agent-bar {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            align-items: center;
        }
        .bar {
            height: 20px;
            border-radius: 3px;
            transition: width 0.3s;
        }
        .bar-r { background: rgb(255, 100, 100); }
        .bar-g { background: rgb(100, 255, 100); }
        .bar-b { background: rgb(100, 150, 255); }
    </style>
</head>
<body>
    <h1>Territory Control Heatmap</h1>
    <p class="description">
        Visualize territorial dominance over time. Left: current state. Right: accumulated control (heatmap showing which agents dominated which regions).
    </p>

    <div class="canvases">
        <div class="canvas-container">
            <div class="canvas-label">Current State</div>
            <canvas id="currentCanvas"></canvas>
        </div>
        <div class="canvas-container">
            <div class="canvas-label">Accumulated Control</div>
            <canvas id="heatmapCanvas"></canvas>
        </div>
    </div>

    <div class="controls">
        <button id="resetBtn">Reset</button>
        <button id="pauseBtn">Pause</button>
        <button id="clearHeatmapBtn">Clear Heatmap</button>
    </div>

    <div class="stats">
        <div>Step: <span id="step">0</span></div>
        <div style="margin-top: 10px;"><strong>Territory Control:</strong></div>
        <div class="agent-bar">
            <span style="width: 100px;">Red Agent:</span>
            <div class="bar bar-r" id="barR" style="width: 0%"></div>
            <span id="percR">0%</span>
        </div>
        <div class="agent-bar">
            <span style="width: 100px;">Green Agent:</span>
            <div class="bar bar-g" id="barG" style="width: 0%"></div>
            <span id="percG">0%</span>
        </div>
        <div class="agent-bar">
            <span style="width: 100px;">Blue Agent:</span>
            <div class="bar bar-b" id="barB" style="width: 0%"></div>
            <span id="percB">0%</span>
        </div>
    </div>

    <script>
        const currentCanvas = document.getElementById('currentCanvas');
        const heatmapCanvas = document.getElementById('heatmapCanvas');
        const currentCtx = currentCanvas.getContext('2d');
        const heatmapCtx = heatmapCanvas.getContext('2d');

        const gridSize = 128;
        const cellSize = 4;
        currentCanvas.width = heatmapCanvas.width = gridSize * cellSize;
        currentCanvas.height = heatmapCanvas.height = gridSize * cellSize;

        const numAgents = 3;
        let grid = new Float32Array(gridSize * gridSize * numAgents);
        let heatmap = new Float32Array(gridSize * gridSize * numAgents); // Accumulated control

        let stepCount = 0;
        let paused = false;

        function idx(x, y, agent) {
            const gx = ((x + gridSize) % gridSize);
            const gy = ((y + gridSize) % gridSize);
            return (gy * gridSize + gx) * numAgents + agent;
        }

        function reset() {
            grid.fill(0);
            heatmap.fill(0);
            stepCount = 0;

            // Three agents in different corners
            const regions = [
                {x: 30, y: 30, agent: 0, r: 15},
                {x: 98, y: 30, agent: 1, r: 15},
                {x: 64, y: 98, agent: 2, r: 15}
            ];

            regions.forEach(region => {
                for (let dy = -region.r; dy <= region.r; dy++) {
                    for (let dx = -region.r; dx <= region.r; dx++) {
                        if (dx*dx + dy*dy <= region.r * region.r) {
                            grid[idx(region.x + dx, region.y + dy, region.agent)] = 0.8;
                        }
                    }
                }
            });
        }

        function clearHeatmap() {
            heatmap.fill(0);
        }

        function step() {
            const next = new Float32Array(grid.length);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    for (let a = 0; a < numAgents; a++) {
                        let sum = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                sum += grid[idx(x + dx, y + dy, a)];
                            }
                        }

                        const current = grid[idx(x, y, a)];
                        const predator = (a + 1) % numAgents;
                        const prey = (a + 2) % numAgents;

                        let predatorSum = 0;
                        let preySum = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                predatorSum += grid[idx(x + dx, y + dy, predator)];
                                preySum += grid[idx(x + dx, y + dy, prey)];
                            }
                        }

                        let nextVal = current;

                        if (predatorSum > 4) {
                            nextVal = Math.max(0, current - 0.1);
                        } else if (sum > 3 || preySum > 3) {
                            nextVal = Math.min(1.0, current + 0.08);
                        } else {
                            nextVal = Math.max(0, current - 0.02);
                        }

                        next[idx(x, y, a)] = nextVal;
                    }

                    // Update heatmap: accumulate control
                    const dominantAgent = [0, 1, 2].reduce((max, a) =>
                        grid[idx(x, y, a)] > grid[idx(x, y, max)] ? a : max
                    );

                    if (grid[idx(x, y, dominantAgent)] > 0.4) {
                        heatmap[idx(x, y, dominantAgent)] += 0.1;
                        // Cap at 10 for visualization
                        if (heatmap[idx(x, y, dominantAgent)] > 10) {
                            heatmap[idx(x, y, dominantAgent)] = 10;
                        }
                    }
                }
            }

            grid = next;
            stepCount++;
        }

        function drawCurrent() {
            const imageData = currentCtx.createImageData(currentCanvas.width, currentCanvas.height);
            const data = imageData.data;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const r = grid[idx(x, y, 0)] * 255;
                    const g = grid[idx(x, y, 1)] * 255;
                    const b = grid[idx(x, y, 2)] * 255;

                    for (let dy = 0; dy < cellSize; dy++) {
                        for (let dx = 0; dx < cellSize; dx++) {
                            const px = x * cellSize + dx;
                            const py = y * cellSize + dy;
                            const pi = (py * currentCanvas.width + px) * 4;

                            data[pi] = r;
                            data[pi + 1] = g;
                            data[pi + 2] = b;
                            data[pi + 3] = 255;
                        }
                    }
                }
            }

            currentCtx.putImageData(imageData, 0, 0);
        }

        function drawHeatmap() {
            const imageData = heatmapCtx.createImageData(heatmapCanvas.width, heatmapCanvas.height);
            const data = imageData.data;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    // Normalize heatmap values
                    const vals = [
                        heatmap[idx(x, y, 0)] / 10,
                        heatmap[idx(x, y, 1)] / 10,
                        heatmap[idx(x, y, 2)] / 10
                    ];

                    const total = vals[0] + vals[1] + vals[2];

                    let r, g, b;
                    if (total < 0.1) {
                        r = g = b = 30; // Dark for never-controlled
                    } else {
                        r = vals[0] * 255;
                        g = vals[1] * 255;
                        b = vals[2] * 255;
                    }

                    for (let dy = 0; dy < cellSize; dy++) {
                        for (let dx = 0; dx < cellSize; dx++) {
                            const px = x * cellSize + dx;
                            const py = y * cellSize + dy;
                            const pi = (py * heatmapCanvas.width + px) * 4;

                            data[pi] = r;
                            data[pi + 1] = g;
                            data[pi + 2] = b;
                            data[pi + 3] = 255;
                        }
                    }
                }
            }

            heatmapCtx.putImageData(imageData, 0, 0);
        }

        function updateStats() {
            let counts = [0, 0, 0];

            for (let i = 0; i < gridSize * gridSize; i++) {
                const vals = [
                    grid[i * numAgents],
                    grid[i * numAgents + 1],
                    grid[i * numAgents + 2]
                ];
                const maxIdx = vals[0] > vals[1]
                    ? (vals[0] > vals[2] ? 0 : 2)
                    : (vals[1] > vals[2] ? 1 : 2);

                if (vals[maxIdx] > 0.3) {
                    counts[maxIdx]++;
                }
            }

            const total = gridSize * gridSize;
            const percs = counts.map(c => (c / total) * 100);

            document.getElementById('step').textContent = stepCount;
            document.getElementById('barR').style.width = percs[0] + '%';
            document.getElementById('barG').style.width = percs[1] + '%';
            document.getElementById('barB').style.width = percs[2] + '%';
            document.getElementById('percR').textContent = percs[0].toFixed(1) + '%';
            document.getElementById('percG').textContent = percs[1].toFixed(1) + '%';
            document.getElementById('percB').textContent = percs[2].toFixed(1) + '%';
        }

        function animate() {
            if (!paused) {
                step();
                updateStats();
            }
            drawCurrent();
            drawHeatmap();
            requestAnimationFrame(animate);
        }

        document.getElementById('resetBtn').addEventListener('click', reset);
        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('clearHeatmapBtn').addEventListener('click', clearHeatmap);

        reset();
        animate();
    </script>
</body>
</html>
