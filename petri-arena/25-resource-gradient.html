<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>25. Resource Gradient - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        .container {
            text-align: center;
        }
        canvas {
            border: 2px solid #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            background: #000;
        }
        h1 {
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
        }
        .info {
            margin-top: 15px;
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 600px;
            line-height: 1.6;
        }
        .stats {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 30px;
            font-size: 0.95rem;
            flex-wrap: wrap;
        }
        .stat {
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }
        .agent-label {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 3px;
            margin-right: 5px;
            vertical-align: middle;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 8px 20px;
            font-size: 0.9rem;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ“Š Resource Gradient</h1>
        <canvas id="canvas"></canvas>
        <div class="stats">
            <div class="stat">
                <span class="agent-label" style="background: #00f5ff;"></span>
                Agent 1: <span id="agent1">0</span>%
            </div>
            <div class="stat">
                <span class="agent-label" style="background: #ff00ff;"></span>
                Agent 2: <span id="agent2">0</span>%
            </div>
            <div class="stat">Step: <span id="step">0</span></div>
            <div class="stat">Gradient: Left (poor) â†’ Right (rich)</div>
        </div>
        <div class="controls">
            <button onclick="togglePause()">Pause/Resume</button>
            <button onclick="reset()">Reset</button>
            <button onclick="location.href='index.html'">Back to Gallery</button>
        </div>
        <div class="info">
            Resource quality varies across the grid from left (poor resources) to right (rich resources).
            Right side cells are more valuable and provide better growth conditions. Agents must decide whether
            to fight for the resource-rich right side or settle for the easier-to-control but poor left side.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const gridSize = 128;
        const cellSize = 4;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;

        const tau = 0.5;
        const alpha = 0.4;
        const numAgents = 2;

        let state = {
            attack: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            defense: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            hidden: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            aliveness: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            )
        };

        let step = 0;
        let paused = false;

        const agentColors = [
            [0, 245, 255],
            [0, 245, 255],
            [255, 0, 255]
        ];

        function getResourceQuality(x) {
            // Linear gradient from 0.5 (left) to 1.5 (right)
            return 0.5 + (x / gridSize);
        }

        function init() {
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    state.attack[0][y][x] = Math.random() * 0.2 - 0.1;
                    state.defense[0][y][x] = Math.random() * 0.2 - 0.1;
                    state.hidden[0][y][x] = Math.random() * 0.2 - 0.1;
                    state.aliveness[0][y][x] = 0.5;
                }
            }

            // Agent 1: left side (poor resources)
            const cx1 = gridSize * 0.25, cy1 = gridSize * 0.5, r1 = 15;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx1) ** 2 + (y - cy1) ** 2);
                    if (dist < r1) {
                        state.attack[1][y][x] = Math.random() * 0.5 + 0.5;
                        state.defense[1][y][x] = Math.random() * 0.5 + 0.5;
                        state.hidden[1][y][x] = Math.random() * 0.5;
                        state.aliveness[1][y][x] = 1.0;
                    }
                }
            }

            // Agent 2: right side (rich resources)
            const cx2 = gridSize * 0.75, cy2 = gridSize * 0.5, r2 = 15;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx2) ** 2 + (y - cy2) ** 2);
                    if (dist < r2) {
                        state.attack[2][y][x] = Math.random() * 0.5 + 0.5;
                        state.defense[2][y][x] = Math.random() * 0.5 + 0.5;
                        state.hidden[2][y][x] = Math.random() * 0.5;
                        state.aliveness[2][y][x] = 1.0;
                    }
                }
            }

            step = 0;
        }

        function computeStrength(attacker, defender, y, x) {
            const resourceBonus = getResourceQuality(x);
            return state.attack[attacker][y][x] * state.defense[defender][y][x] * resourceBonus;
        }

        function update() {
            const newState = {
                attack: state.attack.map(a => a.map(row => [...row])),
                defense: state.defense.map(d => d.map(row => [...row])),
                hidden: state.hidden.map(h => h.map(row => [...row])),
                aliveness: state.aliveness.map(a => a.map(row => [...row]))
            };

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    const deltas = [];
                    for (let agent = 0; agent <= numAgents; agent++) {
                        let avgAttack = 0, avgDefense = 0, avgHidden = 0;
                        let count = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                avgAttack += state.attack[agent][y + dy][x + dx];
                                avgDefense += state.defense[agent][y + dy][x + dx];
                                avgHidden += state.hidden[agent][y + dy][x + dx];
                                count++;
                            }
                        }
                        const resourceModifier = getResourceQuality(x) / 1.0;
                        deltas.push({
                            attack: (avgAttack / count - state.attack[agent][y][x]) * 0.1 * resourceModifier,
                            defense: (avgDefense / count - state.defense[agent][y][x]) * 0.1 * resourceModifier,
                            hidden: (avgHidden / count - state.hidden[agent][y][x]) * 0.1 * resourceModifier + Math.random() * 0.05 - 0.025
                        });
                    }

                    const strengths = [];
                    for (let i = 0; i <= numAgents; i++) {
                        let totalStrength = 0;
                        for (let j = 0; j <= numAgents; j++) {
                            if (i !== j) {
                                totalStrength += computeStrength(i, j, y, x);
                            }
                        }
                        strengths.push(totalStrength + state.aliveness[i][y][x]);
                    }

                    const maxStrength = Math.max(...strengths);
                    const expStrengths = strengths.map(s => Math.exp((s - maxStrength) / tau));
                    const sumExp = expStrengths.reduce((a, b) => a + b, 0);
                    const weights = expStrengths.map(e => e / sumExp);

                    for (let agent = 0; agent <= numAgents; agent++) {
                        const w = weights[agent];
                        newState.attack[agent][y][x] = Math.max(-1, Math.min(1,
                            state.attack[agent][y][x] + deltas[agent].attack * w
                        ));
                        newState.defense[agent][y][x] = Math.max(-1, Math.min(1,
                            state.defense[agent][y][x] + deltas[agent].defense * w
                        ));
                        newState.hidden[agent][y][x] = Math.max(-1, Math.min(1,
                            state.hidden[agent][y][x] + deltas[agent].hidden * w
                        ));
                        newState.aliveness[agent][y][x] = w;
                    }
                }
            }

            state = newState;
            step++;
        }

        function render() {
            const imageData = ctx.createImageData(gridSize, gridSize);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let maxAlive = 0;
                    let winner = 0;
                    for (let agent = 0; agent <= numAgents; agent++) {
                        if (state.aliveness[agent][y][x] > maxAlive) {
                            maxAlive = state.aliveness[agent][y][x];
                            winner = agent;
                        }
                    }

                    const idx = (y * gridSize + x) * 4;
                    const color = agentColors[winner];
                    const intensity = maxAlive;
                    const resourceGradient = getResourceQuality(x) / 1.5; // Normalize for display
                    imageData.data[idx] = color[0] * intensity * resourceGradient;
                    imageData.data[idx + 1] = color[1] * intensity * resourceGradient;
                    imageData.data[idx + 2] = color[2] * intensity * resourceGradient;
                    imageData.data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(canvas, 0, 0, gridSize, gridSize, 0, 0, canvas.width, canvas.height);

            updateStats();
        }

        function updateStats() {
            let territories = [0, 0, 0];
            let weightedTerritories = [0, 0, 0];

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let maxAlive = 0;
                    let winner = 0;
                    for (let agent = 0; agent <= numAgents; agent++) {
                        if (state.aliveness[agent][y][x] > maxAlive) {
                            maxAlive = state.aliveness[agent][y][x];
                            winner = agent;
                        }
                    }
                    territories[winner]++;
                    weightedTerritories[winner] += getResourceQuality(x);
                }
            }

            const total = gridSize * gridSize;
            document.getElementById('agent1').textContent = ((territories[1] / total) * 100).toFixed(1);
            document.getElementById('agent2').textContent = ((territories[2] / total) * 100).toFixed(1);
            document.getElementById('step').textContent = step;
        }

        function animate() {
            if (!paused) {
                update();
                render();
            }
            requestAnimationFrame(animate);
        }

        function togglePause() {
            paused = !paused;
        }

        function reset() {
            init();
            render();
        }

        init();
        animate();
    </script>
</body>
</html>
