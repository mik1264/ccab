<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>41. Temperature Sweep - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        .container {
            text-align: center;
        }
        h1 {
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
        }
        .arenas {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
        }
        .arena-wrapper {
            text-align: center;
        }
        .arena-label {
            margin-bottom: 8px;
            font-size: 0.95rem;
            color: #00f5ff;
        }
        canvas {
            border: 2px solid #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            background: #000;
        }
        .info {
            margin-top: 15px;
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 900px;
            line-height: 1.6;
        }
        .stats {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 0.9rem;
        }
        .stat {
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }
        .controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 8px 20px;
            font-size: 0.9rem;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üå°Ô∏è Temperature Sweep (œÑ Parameter)</h1>
        <div class="arenas">
            <div class="arena-wrapper">
                <div class="arena-label">œÑ = 0.1 (Sharp Competition)</div>
                <canvas id="canvas1"></canvas>
            </div>
            <div class="arena-wrapper">
                <div class="arena-label">œÑ = 0.5 (Balanced)</div>
                <canvas id="canvas2"></canvas>
            </div>
            <div class="arena-wrapper">
                <div class="arena-label">œÑ = 1.0 (Soft/Chaotic)</div>
                <canvas id="canvas3"></canvas>
            </div>
        </div>
        <div class="stats">
            <div class="stat">Step: <span id="step">0</span></div>
            <div class="stat">Winner (œÑ=0.1): <span id="winner1">-</span></div>
            <div class="stat">Winner (œÑ=0.5): <span id="winner2">-</span></div>
            <div class="stat">Winner (œÑ=1.0): <span id="winner3">-</span></div>
        </div>
        <div class="controls">
            <button onclick="togglePause()">Pause/Resume</button>
            <button onclick="reset()">Reset</button>
            <button onclick="location.href='index.html'">Back to Gallery</button>
        </div>
        <div class="info">
            <strong>Temperature (œÑ) Effect:</strong> The œÑ parameter controls competition sharpness via softmax.
            Low œÑ (0.1) creates winner-take-all dynamics with sharp boundaries. Medium œÑ (0.5) balances competition
            with coexistence. High œÑ (1.0) creates softer, more chaotic interactions where agents can coexist more easily.
            Watch how the same starting conditions evolve differently based solely on temperature!
        </div>
    </div>

    <script>
        const gridSize = 80;
        const cellSize = 3;
        const numAgents = 2;
        const tauValues = [0.1, 0.5, 1.0];
        const alpha = 0.4;

        // Create three simulation contexts
        const simulations = tauValues.map((tau, idx) => {
            const canvas = document.getElementById(`canvas${idx + 1}`);
            const ctx = canvas.getContext('2d');
            canvas.width = gridSize * cellSize;
            canvas.height = gridSize * cellSize;

            return {
                canvas,
                ctx,
                tau,
                state: createState(),
                seed: Math.random() * 1000 // Same seed for all
            };
        });

        let step = 0;
        let paused = false;

        // Agent colors
        const agentColors = [
            [20, 20, 20],     // Background
            [0, 245, 255],    // Agent 1 (cyan)
            [255, 0, 255]     // Agent 2 (magenta)
        ];

        function createState() {
            return {
                attack: Array(numAgents + 1).fill(null).map(() =>
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ),
                defense: Array(numAgents + 1).fill(null).map(() =>
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ),
                hidden: Array(numAgents + 1).fill(null).map(() =>
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ),
                aliveness: Array(numAgents + 1).fill(null).map(() =>
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                )
            };
        }

        // Seeded random for reproducibility
        function seededRandom(seed) {
            const x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        function initSimulation(sim) {
            let seedCounter = sim.seed;

            // Background
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    sim.state.attack[0][y][x] = seededRandom(seedCounter++) * 0.2 - 0.1;
                    sim.state.defense[0][y][x] = seededRandom(seedCounter++) * 0.2 - 0.1;
                    sim.state.hidden[0][y][x] = seededRandom(seedCounter++) * 0.2 - 0.1;
                    sim.state.aliveness[0][y][x] = 0.3;
                }
            }

            // Agent 1: left side
            const cx1 = gridSize * 0.3, cy1 = gridSize * 0.5, r1 = 12;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx1) ** 2 + (y - cy1) ** 2);
                    if (dist < r1) {
                        sim.state.attack[1][y][x] = seededRandom(seedCounter++) * 0.5 + 0.5;
                        sim.state.defense[1][y][x] = seededRandom(seedCounter++) * 0.5 + 0.5;
                        sim.state.hidden[1][y][x] = seededRandom(seedCounter++) * 0.5;
                        sim.state.aliveness[1][y][x] = 1.0;
                    }
                }
            }

            // Agent 2: right side
            const cx2 = gridSize * 0.7, cy2 = gridSize * 0.5, r2 = 12;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx2) ** 2 + (y - cy2) ** 2);
                    if (dist < r2) {
                        sim.state.attack[2][y][x] = seededRandom(seedCounter++) * 0.5 + 0.5;
                        sim.state.defense[2][y][x] = seededRandom(seedCounter++) * 0.5 + 0.5;
                        sim.state.hidden[2][y][x] = seededRandom(seedCounter++) * 0.5;
                        sim.state.aliveness[2][y][x] = 1.0;
                    }
                }
            }
        }

        function computeStrength(attacker, defender, state, y, x) {
            const a = state.attack[attacker][y][x];
            const d = state.defense[defender][y][x];
            return a * d;
        }

        function updateSimulation(sim) {
            const newState = {
                attack: sim.state.attack.map(a => a.map(row => [...row])),
                defense: sim.state.defense.map(d => d.map(row => [...row])),
                hidden: sim.state.hidden.map(h => h.map(row => [...row])),
                aliveness: sim.state.aliveness.map(a => a.map(row => [...row]))
            };

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    // Phase 1: Process neighbors
                    const deltas = [];
                    for (let agent = 0; agent <= numAgents; agent++) {
                        let avgAttack = 0, avgDefense = 0, avgHidden = 0;
                        let count = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                avgAttack += sim.state.attack[agent][y + dy][x + dx];
                                avgDefense += sim.state.defense[agent][y + dy][x + dx];
                                avgHidden += sim.state.hidden[agent][y + dy][x + dx];
                                count++;
                            }
                        }
                        deltas.push({
                            attack: (avgAttack / count - sim.state.attack[agent][y][x]) * 0.15,
                            defense: (avgDefense / count - sim.state.defense[agent][y][x]) * 0.15,
                            hidden: (avgHidden / count - sim.state.hidden[agent][y][x]) * 0.1
                        });
                    }

                    // Phase 2: Competition
                    const strengths = [];
                    for (let i = 0; i <= numAgents; i++) {
                        let totalStrength = 0;
                        for (let j = 0; j <= numAgents; j++) {
                            if (i !== j) {
                                totalStrength += computeStrength(i, j, sim.state, y, x);
                            }
                        }
                        strengths.push(totalStrength + sim.state.aliveness[i][y][x] * 0.8);
                    }

                    // Phase 3: Normalization (softmax with temperature tau)
                    const maxStrength = Math.max(...strengths);
                    const expStrengths = strengths.map(s => Math.exp((s - maxStrength) / sim.tau));
                    const sumExp = expStrengths.reduce((a, b) => a + b, 0);
                    const weights = expStrengths.map(e => e / sumExp);

                    // Phase 4: State update
                    for (let agent = 0; agent <= numAgents; agent++) {
                        const w = weights[agent];
                        newState.attack[agent][y][x] = Math.max(-1, Math.min(1,
                            sim.state.attack[agent][y][x] + deltas[agent].attack * w
                        ));
                        newState.defense[agent][y][x] = Math.max(-1, Math.min(1,
                            sim.state.defense[agent][y][x] + deltas[agent].defense * w
                        ));
                        newState.hidden[agent][y][x] = Math.max(-1, Math.min(1,
                            sim.state.hidden[agent][y][x] + deltas[agent].hidden * w
                        ));
                        newState.aliveness[agent][y][x] = w;
                    }
                }
            }

            sim.state = newState;
        }

        function renderSimulation(sim) {
            const imageData = sim.ctx.createImageData(gridSize, gridSize);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let maxAlive = 0;
                    let winner = 0;
                    for (let agent = 0; agent <= numAgents; agent++) {
                        if (sim.state.aliveness[agent][y][x] > maxAlive) {
                            maxAlive = sim.state.aliveness[agent][y][x];
                            winner = agent;
                        }
                    }

                    const idx = (y * gridSize + x) * 4;
                    const color = agentColors[winner];
                    const intensity = maxAlive;
                    imageData.data[idx] = color[0] * intensity;
                    imageData.data[idx + 1] = color[1] * intensity;
                    imageData.data[idx + 2] = color[2] * intensity;
                    imageData.data[idx + 3] = 255;
                }
            }

            sim.ctx.putImageData(imageData, 0, 0);
            sim.ctx.imageSmoothingEnabled = false;
            sim.ctx.drawImage(sim.canvas, 0, 0, gridSize, gridSize, 0, 0, sim.canvas.width, sim.canvas.height);
        }

        function getWinner(sim) {
            let territories = [0, 0, 0];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let maxAlive = 0;
                    let winner = 0;
                    for (let agent = 0; agent <= numAgents; agent++) {
                        if (sim.state.aliveness[agent][y][x] > maxAlive) {
                            maxAlive = sim.state.aliveness[agent][y][x];
                            winner = agent;
                        }
                    }
                    territories[winner]++;
                }
            }
            const total = gridSize * gridSize;
            const p1 = (territories[1] / total * 100).toFixed(1);
            const p2 = (territories[2] / total * 100).toFixed(1);
            return `A1:${p1}% A2:${p2}%`;
        }

        function animate() {
            if (!paused) {
                simulations.forEach(sim => {
                    updateSimulation(sim);
                    renderSimulation(sim);
                });
                step++;

                document.getElementById('step').textContent = step;
                document.getElementById('winner1').textContent = getWinner(simulations[0]);
                document.getElementById('winner2').textContent = getWinner(simulations[1]);
                document.getElementById('winner3').textContent = getWinner(simulations[2]);
            }
            requestAnimationFrame(animate);
        }

        function togglePause() {
            paused = !paused;
        }

        function reset() {
            step = 0;
            simulations.forEach(sim => {
                sim.state = createState();
                initSimulation(sim);
                renderSimulation(sim);
            });
        }

        // Initialize
        simulations.forEach(sim => {
            initSimulation(sim);
            renderSimulation(sim);
        });
        animate();
    </script>
</body>
</html>
