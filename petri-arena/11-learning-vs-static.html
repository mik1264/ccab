<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>11. Learning vs Static - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        .container {
            text-align: center;
        }
        .canvas-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 10px;
        }
        .canvas-wrapper {
            text-align: center;
        }
        .canvas-label {
            font-size: 1.1rem;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .learning-indicator {
            margin-top: 5px;
            padding: 5px 10px;
            background: rgba(0, 245, 255, 0.1);
            border-radius: 5px;
            font-size: 0.85rem;
        }
        canvas {
            border: 2px solid #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            background: #000;
        }
        h1 {
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
        }
        .info {
            margin-top: 15px;
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 800px;
            line-height: 1.6;
        }
        .stats {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 0.95rem;
            flex-wrap: wrap;
        }
        .stat {
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }
        .controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 8px 20px;
            font-size: 0.9rem;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
        .learning-on { color: #00ff00; }
        .learning-off { color: #ff4444; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§  Learning vs Static</h1>
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <div class="canvas-label">With Learning <span class="learning-on">âœ“</span></div>
                <canvas id="canvasLeft"></canvas>
                <div class="learning-indicator">
                    Attack: <span id="attackLeft">1.00</span> | Defense: <span id="defenseLeft">1.00</span>
                </div>
            </div>
            <div class="canvas-wrapper">
                <div class="canvas-label">Without Learning <span class="learning-off">âœ—</span></div>
                <canvas id="canvasRight"></canvas>
                <div class="learning-indicator">
                    Attack: <span id="attackRight">1.00</span> | Defense: <span id="defenseRight">1.00</span>
                </div>
            </div>
        </div>
        <div class="stats">
            <div class="stat">Step: <span id="step">0</span></div>
            <div class="stat">Learning Territory: <span id="learningTerritory">0</span>%</div>
            <div class="stat">Static Territory: <span id="staticTerritory">0</span>%</div>
            <div class="stat">Learning Rate: 0.05</div>
        </div>
        <div class="controls">
            <button onclick="togglePause()">Pause/Resume</button>
            <button onclick="reset()">Reset</button>
            <button onclick="location.href='index.html'">Back to Gallery</button>
        </div>
        <div class="info">
            Split-screen comparison: Left agent adapts its attack/defense parameters based on territorial success (gradient descent).
            Right agent maintains static parameters. Both start from identical initial conditions. The learning agent adjusts its
            strategy to maximize territory control, while the static agent remains unchanged. Watch how learning provides a
            competitive advantage over time.
        </div>
    </div>

    <script>
        const canvasLeft = document.getElementById('canvasLeft');
        const canvasRight = document.getElementById('canvasRight');
        const ctxLeft = canvasLeft.getContext('2d');
        const ctxRight = canvasRight.getContext('2d');

        const gridSize = 128;
        const cellSize = 4;
        canvasLeft.width = canvasRight.width = gridSize * cellSize;
        canvasLeft.height = canvasRight.height = gridSize * cellSize;

        const tau = 0.5;
        const learningRate = 0.05;
        let step = 0;
        let paused = false;

        // Separate states for left (learning) and right (static)
        let stateLeft = createState();
        let stateRight = createState();

        // Learning parameters
        let paramsLeft = { attackMult: 1.0, defenseMult: 1.0 };
        let paramsRight = { attackMult: 1.0, defenseMult: 1.0 };

        function createState() {
            return {
                attack: [
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0)),
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ],
                defense: [
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0)),
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ],
                aliveness: [
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0)),
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ]
            };
        }

        function init() {
            stateLeft = createState();
            stateRight = createState();
            paramsLeft = { attackMult: 1.0, defenseMult: 1.0 };
            paramsRight = { attackMult: 1.0, defenseMult: 1.0 };

            // Initialize both identically
            [stateLeft, stateRight].forEach(state => {
                // Background
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        state.attack[0][y][x] = Math.random() * 0.2 - 0.1;
                        state.defense[0][y][x] = Math.random() * 0.2 - 0.1;
                        state.aliveness[0][y][x] = 0.5;
                    }
                }

                // Agent (centered)
                const cx = gridSize / 2, cy = gridSize / 2, r = 20;
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                        if (dist < r) {
                            state.attack[1][y][x] = Math.random() * 0.5 + 0.5;
                            state.defense[1][y][x] = Math.random() * 0.5 + 0.5;
                            state.aliveness[1][y][x] = 1.0;
                        }
                    }
                }
            });

            step = 0;
        }

        function computeStrength(state, params, attacker, defender, y, x) {
            const a = state.attack[attacker][y][x] * (attacker === 1 ? params.attackMult : 1.0);
            const d = state.defense[defender][y][x] * (defender === 1 ? params.defenseMult : 1.0);
            return a * d;
        }

        function update() {
            // Update left (with learning)
            const territoryBefore = calculateTerritory(stateLeft, 1);
            stateLeft = updateState(stateLeft, paramsLeft);
            const territoryAfter = calculateTerritory(stateLeft, 1);

            // Gradient-based learning: adjust parameters based on territory change
            const gradient = territoryAfter - territoryBefore;
            paramsLeft.attackMult += learningRate * gradient * (Math.random() - 0.5);
            paramsLeft.defenseMult += learningRate * gradient * (Math.random() - 0.5);
            paramsLeft.attackMult = Math.max(0.5, Math.min(2.0, paramsLeft.attackMult));
            paramsLeft.defenseMult = Math.max(0.5, Math.min(2.0, paramsLeft.defenseMult));

            // Update right (static)
            stateRight = updateState(stateRight, paramsRight);

            step++;
        }

        function updateState(state, params) {
            const newState = {
                attack: state.attack.map(a => a.map(row => [...row])),
                defense: state.defense.map(d => d.map(row => [...row])),
                aliveness: state.aliveness.map(a => a.map(row => [...row]))
            };

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    const deltas = [0, 1].map(agent => {
                        let avgAttack = 0, avgDefense = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                avgAttack += state.attack[agent][y + dy][x + dx];
                                avgDefense += state.defense[agent][y + dy][x + dx];
                            }
                        }
                        return {
                            attack: (avgAttack / 9 - state.attack[agent][y][x]) * 0.1,
                            defense: (avgDefense / 9 - state.defense[agent][y][x]) * 0.1
                        };
                    });

                    const strengths = [
                        computeStrength(state, params, 0, 1, y, x) + state.aliveness[0][y][x],
                        computeStrength(state, params, 1, 0, y, x) + state.aliveness[1][y][x]
                    ];

                    const maxStrength = Math.max(...strengths);
                    const expStrengths = strengths.map(s => Math.exp((s - maxStrength) / tau));
                    const sumExp = expStrengths.reduce((a, b) => a + b, 0);
                    const weights = expStrengths.map(e => e / sumExp);

                    [0, 1].forEach(agent => {
                        newState.attack[agent][y][x] = Math.max(-1, Math.min(1,
                            state.attack[agent][y][x] + deltas[agent].attack * weights[agent]
                        ));
                        newState.defense[agent][y][x] = Math.max(-1, Math.min(1,
                            state.defense[agent][y][x] + deltas[agent].defense * weights[agent]
                        ));
                        newState.aliveness[agent][y][x] = weights[agent];
                    });
                }
            }

            return newState;
        }

        function calculateTerritory(state, agent) {
            let count = 0;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (state.aliveness[agent][y][x] > state.aliveness[1 - agent][y][x]) {
                        count++;
                    }
                }
            }
            return count / (gridSize * gridSize);
        }

        function render() {
            renderCanvas(ctxLeft, stateLeft);
            renderCanvas(ctxRight, stateRight);

            document.getElementById('attackLeft').textContent = paramsLeft.attackMult.toFixed(2);
            document.getElementById('defenseLeft').textContent = paramsLeft.defenseMult.toFixed(2);
            document.getElementById('attackRight').textContent = paramsRight.attackMult.toFixed(2);
            document.getElementById('defenseRight').textContent = paramsRight.defenseMult.toFixed(2);
            document.getElementById('step').textContent = step;
            document.getElementById('learningTerritory').textContent = (calculateTerritory(stateLeft, 1) * 100).toFixed(1);
            document.getElementById('staticTerritory').textContent = (calculateTerritory(stateRight, 1) * 100).toFixed(1);
        }

        function renderCanvas(ctx, state) {
            const imageData = ctx.createImageData(gridSize, gridSize);
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const idx = (y * gridSize + x) * 4;
                    const winner = state.aliveness[1][y][x] > state.aliveness[0][y][x] ? 1 : 0;
                    const intensity = state.aliveness[winner][y][x];
                    if (winner === 1) {
                        imageData.data[idx] = 0;
                        imageData.data[idx + 1] = 245 * intensity;
                        imageData.data[idx + 2] = 255 * intensity;
                    } else {
                        imageData.data[idx] = 100 * intensity;
                        imageData.data[idx + 1] = 100 * intensity;
                        imageData.data[idx + 2] = 100 * intensity;
                    }
                    imageData.data[idx + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(ctx.canvas, 0, 0, gridSize, gridSize, 0, 0, ctx.canvas.width, ctx.canvas.height);
        }

        function animate() {
            if (!paused) {
                update();
                render();
            }
            requestAnimationFrame(animate);
        }

        function togglePause() {
            paused = !paused;
        }

        function reset() {
            init();
            render();
        }

        init();
        animate();
    </script>
</body>
</html>
