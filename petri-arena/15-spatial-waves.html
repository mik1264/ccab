<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spatial Waves and Patterns - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
        }
        .description {
            max-width: 800px;
            text-align: center;
            margin-bottom: 20px;
            color: #aaa;
        }
        canvas {
            border: 2px solid #667eea;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }
        button {
            padding: 10px 20px;
            background: #667eea;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        button:hover {
            background: #764ba2;
        }
        label {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        select {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #667eea;
            border-radius: 5px;
            color: white;
            cursor: pointer;
        }
        option {
            background: #1a1a2e;
        }
        .stats {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-family: monospace;
            min-width: 500px;
        }
    </style>
</head>
<body>
    <h1>Spatial Waves and Patterns</h1>
    <p class="description">
        NCA agents can produce traveling waves, spirals, and other spatial patterns through local interactions.
        These patterns emerge from the interplay of diffusion-like growth and competitive inhibition.
    </p>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <button id="resetBtn">Reset</button>
        <button id="pauseBtn">Pause</button>
        <label>
            Pattern:
            <select id="patternSelect">
                <option value="waves">Traveling Waves</option>
                <option value="spiral">Spiral</option>
                <option value="target">Target Rings</option>
                <option value="turbulence">Turbulence</option>
            </select>
        </label>
    </div>
    <div class="stats">
        <div>Step: <span id="step">0</span></div>
        <div>Pattern: <span id="pattern">Traveling Waves</span></div>
        <div>Wave Speed: <span id="speed">-</span> cells/step</div>
        <div style="margin-top: 10px; font-size: 12px; color: #aaa;">
            Spatial patterns arise from reaction-diffusion-like dynamics in PD-NCA systems.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 160;
        const cellSize = 3;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;

        const numAgents = 3;
        let grid = new Float32Array(gridSize * gridSize * numAgents);
        let stepCount = 0;
        let paused = false;
        let patternType = 'waves';
        let previousCenter = null;

        function idx(x, y, agent) {
            const gx = ((x + gridSize) % gridSize);
            const gy = ((y + gridSize) % gridSize);
            return (gy * gridSize + gx) * numAgents + agent;
        }

        function reset() {
            grid.fill(0);
            stepCount = 0;
            previousCenter = null;

            switch(patternType) {
                case 'waves':
                    initWaves();
                    break;
                case 'spiral':
                    initSpiral();
                    break;
                case 'target':
                    initTarget();
                    break;
                case 'turbulence':
                    initTurbulence();
                    break;
            }
        }

        function initWaves() {
            // Horizontal wave sources on left
            for (let y = 30; y < 130; y += 30) {
                for (let a = 0; a < numAgents; a++) {
                    const yOffset = a * 10;
                    for (let dy = -3; dy <= 3; dy++) {
                        for (let dx = 0; dx < 10; dx++) {
                            grid[idx(dx, y + yOffset + dy, a)] = 0.8;
                        }
                    }
                }
            }
        }

        function initSpiral() {
            const cx = gridSize / 2;
            const cy = gridSize / 2;

            for (let a = 0; a < numAgents; a++) {
                const angleOffset = (a / numAgents) * Math.PI * 2;

                for (let i = 0; i < 50; i++) {
                    const r = 5 + i * 1.5;
                    const angle = angleOffset + i * 0.3;
                    const x = Math.floor(cx + Math.cos(angle) * r);
                    const y = Math.floor(cy + Math.sin(angle) * r);

                    for (let dy = -2; dy <= 2; dy++) {
                        for (let dx = -2; dx <= 2; dx++) {
                            if (dx*dx + dy*dy <= 4) {
                                grid[idx(x + dx, y + dy, a)] = 0.7;
                            }
                        }
                    }
                }
            }
        }

        function initTarget() {
            const cx = gridSize / 2;
            const cy = gridSize / 2;

            for (let r = 10; r < 70; r += 15) {
                const agent = Math.floor(((r - 10) / 15) % numAgents);

                for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
                    const x = Math.floor(cx + Math.cos(angle) * r);
                    const y = Math.floor(cy + Math.sin(angle) * r);

                    for (let dy = -2; dy <= 2; dy++) {
                        for (let dx = -2; dx <= 2; dx++) {
                            if (dx*dx + dy*dy <= 4) {
                                grid[idx(x + dx, y + dy, agent)] = 0.8;
                            }
                        }
                    }
                }
            }
        }

        function initTurbulence() {
            // Random scattered sources
            for (let s = 0; s < 30; s++) {
                const x = Math.floor(Math.random() * gridSize);
                const y = Math.floor(Math.random() * gridSize);
                const agent = s % numAgents;
                const r = 3 + Math.floor(Math.random() * 3);

                for (let dy = -r; dy <= r; dy++) {
                    for (let dx = -r; dx <= r; dx++) {
                        if (dx*dx + dy*dy <= r*r) {
                            grid[idx(x + dx, y + dy, agent)] = Math.random() * 0.5 + 0.5;
                        }
                    }
                }
            }
        }

        function step() {
            const next = new Float32Array(grid.length);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    for (let a = 0; a < numAgents; a++) {
                        // Laplacian (diffusion approximation)
                        let laplacian = -grid[idx(x, y, a)] * 8;
                        laplacian += grid[idx(x-1, y, a)];
                        laplacian += grid[idx(x+1, y, a)];
                        laplacian += grid[idx(x, y-1, a)];
                        laplacian += grid[idx(x, y+1, a)];
                        laplacian += grid[idx(x-1, y-1, a)] * 0.5;
                        laplacian += grid[idx(x+1, y-1, a)] * 0.5;
                        laplacian += grid[idx(x-1, y+1, a)] * 0.5;
                        laplacian += grid[idx(x+1, y+1, a)] * 0.5;

                        const current = grid[idx(x, y, a)];

                        // Reaction-diffusion like update
                        const diffusion = laplacian * 0.2;
                        const reaction = current * (1 - current) * 2.0; // Logistic growth

                        // Competitive inhibition
                        let inhibition = 0;
                        for (let other = 0; other < numAgents; other++) {
                            if (other !== a) {
                                inhibition += grid[idx(x, y, other)] * 0.3;
                            }
                        }

                        let nextVal = current + diffusion + reaction - inhibition;

                        // Add small noise
                        nextVal += (Math.random() - 0.5) * 0.01;

                        // Clamp
                        nextVal = Math.max(0, Math.min(1, nextVal));

                        next[idx(x, y, a)] = nextVal;
                    }
                }
            }

            grid = next;
            stepCount++;
        }

        function draw() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const r = grid[idx(x, y, 0)] * 255;
                    const g = grid[idx(x, y, 1)] * 255;
                    const b = grid[idx(x, y, 2)] * 255;

                    for (let dy = 0; dy < cellSize; dy++) {
                        for (let dx = 0; dx < cellSize; dx++) {
                            const px = x * cellSize + dx;
                            const py = y * cellSize + dy;
                            const pi = (py * canvas.width + px) * 4;

                            data[pi] = r;
                            data[pi + 1] = g;
                            data[pi + 2] = b;
                            data[pi + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function calculateWaveSpeed() {
            // Find center of mass for dominant agent
            let totalMass = 0;
            let centerX = 0;
            let centerY = 0;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const mass = grid[idx(x, y, 0)] + grid[idx(x, y, 1)] + grid[idx(x, y, 2)];
                    totalMass += mass;
                    centerX += x * mass;
                    centerY += y * mass;
                }
            }

            if (totalMass > 0) {
                centerX /= totalMass;
                centerY /= totalMass;
            }

            let speed = '-';
            if (previousCenter && stepCount > 10) {
                const dx = centerX - previousCenter.x;
                const dy = centerY - previousCenter.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                speed = distance.toFixed(2);
            }

            previousCenter = {x: centerX, y: centerY};
            return speed;
        }

        function updateStats() {
            const speed = calculateWaveSpeed();

            document.getElementById('step').textContent = stepCount;
            document.getElementById('pattern').textContent = document.getElementById('patternSelect').selectedOptions[0].text;
            document.getElementById('speed').textContent = speed;
        }

        function animate() {
            if (!paused) {
                step();
                updateStats();
            }
            draw();
            requestAnimationFrame(animate);
        }

        document.getElementById('resetBtn').addEventListener('click', reset);
        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('patternSelect').addEventListener('change', (e) => {
            patternType = e.target.value;
            reset();
        });

        reset();
        animate();
    </script>
</body>
</html>
