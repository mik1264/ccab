<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>14. Learning Rates - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        .container {
            text-align: center;
        }
        canvas {
            border: 2px solid #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            background: #000;
        }
        h1 {
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
        }
        .info {
            margin-top: 15px;
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 700px;
            line-height: 1.6;
        }
        .stats {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 0.95rem;
            flex-wrap: wrap;
        }
        .stat {
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }
        .agent-label {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 5px;
            vertical-align: middle;
        }
        .learning-display {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        .learning-box {
            padding: 12px;
            background: rgba(0, 245, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(0, 245, 255, 0.3);
            min-width: 140px;
        }
        .learning-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 0.95rem;
        }
        .learning-value {
            font-size: 0.85rem;
            opacity: 0.9;
        }
        .rate-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-top: 3px;
        }
        .slow { background: #ff6b6b; }
        .medium { background: #ffa500; }
        .fast { background: #00ff00; }
        .controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 8px 20px;
            font-size: 0.9rem;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>⚡ Learning Rates</h1>
        <canvas id="canvas"></canvas>
        <div class="stats">
            <div class="stat">
                <span class="agent-label" style="background: #ff6b6b;"></span>
                Slow (α=0.01): <span id="agent1">0</span>%
            </div>
            <div class="stat">
                <span class="agent-label" style="background: #ffa500;"></span>
                Medium (α=0.05): <span id="agent2">0</span>%
            </div>
            <div class="stat">
                <span class="agent-label" style="background: #00ff00;"></span>
                Fast (α=0.1): <span id="agent3">0</span>%
            </div>
            <div class="stat">Step: <span id="step">0</span></div>
        </div>
        <div class="learning-display">
            <div class="learning-box">
                <div class="learning-title">Slow Learner <span class="rate-badge slow">α=0.01</span></div>
                <div class="learning-value">Attack: <span id="attack1">1.00</span></div>
                <div class="learning-value">Defense: <span id="defense1">1.00</span></div>
            </div>
            <div class="learning-box">
                <div class="learning-title">Medium Learner <span class="rate-badge medium">α=0.05</span></div>
                <div class="learning-value">Attack: <span id="attack2">1.00</span></div>
                <div class="learning-value">Defense: <span id="defense2">1.00</span></div>
            </div>
            <div class="learning-box">
                <div class="learning-title">Fast Learner <span class="rate-badge fast">α=0.1</span></div>
                <div class="learning-value">Attack: <span id="attack3">1.00</span></div>
                <div class="learning-value">Defense: <span id="defense3">1.00</span></div>
            </div>
        </div>
        <div class="controls">
            <button onclick="togglePause()">Pause/Resume</button>
            <button onclick="reset()">Reset</button>
            <button onclick="location.href='index.html'">Back to Gallery</button>
        </div>
        <div class="info">
            Three agents with different learning rates (α) adapt their strategies simultaneously. Slow learner (0.01) adapts
            cautiously, medium learner (0.05) balances exploration and stability, fast learner (0.1) adapts rapidly but may
            overshoot. Watch how learning rate affects convergence speed and stability in competitive environments.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const gridSize = 128;
        const cellSize = 4;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;

        const tau = 0.5;
        const learningRates = [0, 0.01, 0.05, 0.1];
        const numAgents = 3;
        let step = 0;
        let paused = false;

        let state = createState();
        let params = [
            { attackMult: 1.0, defenseMult: 1.0 },
            { attackMult: 1.0, defenseMult: 1.0 },
            { attackMult: 1.0, defenseMult: 1.0 },
            { attackMult: 1.0, defenseMult: 1.0 }
        ];
        let prevTerritories = [0, 0, 0, 0];

        const agentColors = [
            [30, 30, 30],      // Background
            [255, 107, 107],   // Agent 1 (red)
            [255, 165, 0],     // Agent 2 (orange)
            [0, 255, 0]        // Agent 3 (green)
        ];

        function createState() {
            return {
                attack: Array(numAgents + 1).fill(null).map(() =>
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ),
                defense: Array(numAgents + 1).fill(null).map(() =>
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ),
                aliveness: Array(numAgents + 1).fill(null).map(() =>
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                )
            };
        }

        function init() {
            state = createState();
            params = [
                { attackMult: 1.0, defenseMult: 1.0 },
                { attackMult: 1.0, defenseMult: 1.0 },
                { attackMult: 1.0, defenseMult: 1.0 },
                { attackMult: 1.0, defenseMult: 1.0 }
            ];

            // Background
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    state.attack[0][y][x] = Math.random() * 0.2 - 0.1;
                    state.defense[0][y][x] = Math.random() * 0.2 - 0.1;
                    state.aliveness[0][y][x] = 0.5;
                }
            }

            // Three agents
            const positions = [
                { x: gridSize * 0.5, y: gridSize * 0.25 },
                { x: gridSize * 0.25, y: gridSize * 0.75 },
                { x: gridSize * 0.75, y: gridSize * 0.75 }
            ];

            positions.forEach((pos, i) => {
                const agent = i + 1;
                const r = 15;
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        const dist = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
                        if (dist < r) {
                            state.attack[agent][y][x] = Math.random() * 0.5 + 0.5;
                            state.defense[agent][y][x] = Math.random() * 0.5 + 0.5;
                            state.aliveness[agent][y][x] = 1.0;
                        }
                    }
                }
            });

            prevTerritories = [0, 0, 0, 0];
            step = 0;
        }

        function computeStrength(attacker, defender, y, x) {
            const a = state.attack[attacker][y][x] * params[attacker].attackMult;
            const d = state.defense[defender][y][x] * params[defender].defenseMult;
            return a * d;
        }

        function update() {
            const territories = calculateTerritories();

            // Update each agent with its learning rate
            for (let agent = 1; agent <= numAgents; agent++) {
                const gradient = territories[agent] - prevTerritories[agent];
                const lr = learningRates[agent];

                params[agent].attackMult += lr * gradient + (Math.random() - 0.5) * 0.02;
                params[agent].defenseMult += lr * gradient + (Math.random() - 0.5) * 0.02;

                params[agent].attackMult = Math.max(0.3, Math.min(2.5, params[agent].attackMult));
                params[agent].defenseMult = Math.max(0.3, Math.min(2.5, params[agent].defenseMult));
            }

            prevTerritories = territories;

            // Update state
            const newState = {
                attack: state.attack.map(a => a.map(row => [...row])),
                defense: state.defense.map(d => d.map(row => [...row])),
                aliveness: state.aliveness.map(a => a.map(row => [...row]))
            };

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    const deltas = [];
                    for (let agent = 0; agent <= numAgents; agent++) {
                        let avgAttack = 0, avgDefense = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                avgAttack += state.attack[agent][y + dy][x + dx];
                                avgDefense += state.defense[agent][y + dy][x + dx];
                            }
                        }
                        deltas.push({
                            attack: (avgAttack / 9 - state.attack[agent][y][x]) * 0.1,
                            defense: (avgDefense / 9 - state.defense[agent][y][x]) * 0.1
                        });
                    }

                    const strengths = [];
                    for (let i = 0; i <= numAgents; i++) {
                        let totalStrength = 0;
                        for (let j = 0; j <= numAgents; j++) {
                            if (i !== j) totalStrength += computeStrength(i, j, y, x);
                        }
                        strengths.push(totalStrength + state.aliveness[i][y][x]);
                    }

                    const maxStrength = Math.max(...strengths);
                    const expStrengths = strengths.map(s => Math.exp((s - maxStrength) / tau));
                    const sumExp = expStrengths.reduce((a, b) => a + b, 0);
                    const weights = expStrengths.map(e => e / sumExp);

                    for (let agent = 0; agent <= numAgents; agent++) {
                        newState.attack[agent][y][x] = Math.max(-1, Math.min(1,
                            state.attack[agent][y][x] + deltas[agent].attack * weights[agent]
                        ));
                        newState.defense[agent][y][x] = Math.max(-1, Math.min(1,
                            state.defense[agent][y][x] + deltas[agent].defense * weights[agent]
                        ));
                        newState.aliveness[agent][y][x] = weights[agent];
                    }
                }
            }

            state = newState;
            step++;
        }

        function calculateTerritories() {
            const territories = [0, 0, 0, 0];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let maxAlive = 0, winner = 0;
                    for (let agent = 0; agent <= numAgents; agent++) {
                        if (state.aliveness[agent][y][x] > maxAlive) {
                            maxAlive = state.aliveness[agent][y][x];
                            winner = agent;
                        }
                    }
                    territories[winner]++;
                }
            }
            return territories.map(t => t / (gridSize * gridSize));
        }

        function render() {
            const imageData = ctx.createImageData(gridSize, gridSize);
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let maxAlive = 0, winner = 0;
                    for (let agent = 0; agent <= numAgents; agent++) {
                        if (state.aliveness[agent][y][x] > maxAlive) {
                            maxAlive = state.aliveness[agent][y][x];
                            winner = agent;
                        }
                    }
                    const idx = (y * gridSize + x) * 4;
                    const color = agentColors[winner];
                    imageData.data[idx] = color[0] * maxAlive;
                    imageData.data[idx + 1] = color[1] * maxAlive;
                    imageData.data[idx + 2] = color[2] * maxAlive;
                    imageData.data[idx + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(canvas, 0, 0, gridSize, gridSize, 0, 0, canvas.width, canvas.height);

            const territories = calculateTerritories();
            document.getElementById('agent1').textContent = (territories[1] * 100).toFixed(1);
            document.getElementById('agent2').textContent = (territories[2] * 100).toFixed(1);
            document.getElementById('agent3').textContent = (territories[3] * 100).toFixed(1);
            document.getElementById('step').textContent = step;

            for (let i = 1; i <= numAgents; i++) {
                document.getElementById(`attack${i}`).textContent = params[i].attackMult.toFixed(2);
                document.getElementById(`defense${i}`).textContent = params[i].defenseMult.toFixed(2);
            }
        }

        function animate() {
            if (!paused) {
                update();
                render();
            }
            requestAnimationFrame(animate);
        }

        function togglePause() {
            paused = !paused;
        }

        function reset() {
            init();
            render();
        }

        init();
        animate();
    </script>
</body>
</html>
