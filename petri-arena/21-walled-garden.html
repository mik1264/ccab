<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>21. Walled Garden - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        .container {
            text-align: center;
        }
        canvas {
            border: 2px solid #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            background: #000;
        }
        h1 {
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
        }
        .info {
            margin-top: 15px;
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 600px;
            line-height: 1.6;
        }
        .stats {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 30px;
            font-size: 0.95rem;
            flex-wrap: wrap;
        }
        .stat {
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }
        .agent-label {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 3px;
            margin-right: 5px;
            vertical-align: middle;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 8px 20px;
            font-size: 0.9rem;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üè∞ Walled Garden</h1>
        <canvas id="canvas"></canvas>
        <div class="stats">
            <div class="stat">
                <span class="agent-label" style="background: #00f5ff;"></span>
                Agent 1: <span id="agent1">0</span>%
            </div>
            <div class="stat">
                <span class="agent-label" style="background: #ff00ff;"></span>
                Agent 2: <span id="agent2">0</span>%
            </div>
            <div class="stat">Step: <span id="step">0</span></div>
            <div class="stat">Walls: <span id="walls">0</span> cells</div>
        </div>
        <div class="controls">
            <button onclick="togglePause()">Pause/Resume</button>
            <button onclick="reset()">Reset</button>
            <button onclick="location.href='index.html'">Back to Gallery</button>
        </div>
        <div class="info">
            Grid with walls forming chambers and rooms. Agents must navigate around obstacles to control territory.
            Walls block cell updates and create strategic chokepoints. Watch how agents adapt to navigate the maze-like
            structure and compete for isolated chambers.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Grid parameters
        const gridSize = 128;
        const cellSize = 4;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;

        // PD-NCA parameters
        const tau = 0.5;
        const alpha = 0.4;
        const numAgents = 2;

        // Wall grid
        let walls = Array(gridSize).fill(null).map(() => Array(gridSize).fill(false));

        // State
        let state = {
            attack: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            defense: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            hidden: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            aliveness: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            )
        };

        let step = 0;
        let paused = false;

        const agentColors = [
            [0, 245, 255],
            [0, 245, 255],
            [255, 0, 255]
        ];

        function createWalls() {
            // Create room-like structure with walls
            // Outer walls
            for (let i = 0; i < gridSize; i++) {
                walls[0][i] = true;
                walls[gridSize - 1][i] = true;
                walls[i][0] = true;
                walls[i][gridSize - 1] = true;
            }

            // Vertical dividers with gaps
            for (let x = 32; x < gridSize; x += 32) {
                for (let y = 0; y < gridSize; y++) {
                    if (y < 20 || (y > 30 && y < 50) || (y > 60 && y < 80) || (y > 90 && y < 110)) {
                        walls[y][x] = true;
                    }
                }
            }

            // Horizontal dividers with gaps
            for (let y = 32; y < gridSize; y += 32) {
                for (let x = 0; x < gridSize; x++) {
                    if (x < 20 || (x > 30 && x < 50) || (x > 60 && x < 80) || (x > 90 && x < 110)) {
                        walls[y][x] = true;
                    }
                }
            }

            // Count walls
            let wallCount = 0;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (walls[y][x]) wallCount++;
                }
            }
            document.getElementById('walls').textContent = wallCount;
        }

        function init() {
            // Create walls
            walls = Array(gridSize).fill(null).map(() => Array(gridSize).fill(false));
            createWalls();

            // Initialize background
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (!walls[y][x]) {
                        state.attack[0][y][x] = Math.random() * 0.2 - 0.1;
                        state.defense[0][y][x] = Math.random() * 0.2 - 0.1;
                        state.hidden[0][y][x] = Math.random() * 0.2 - 0.1;
                        state.aliveness[0][y][x] = 0.5;
                    }
                }
            }

            // Agent 1: top-left chamber
            const cx1 = 16, cy1 = 16, r1 = 10;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (!walls[y][x]) {
                        const dist = Math.sqrt((x - cx1) ** 2 + (y - cy1) ** 2);
                        if (dist < r1) {
                            state.attack[1][y][x] = Math.random() * 0.5 + 0.5;
                            state.defense[1][y][x] = Math.random() * 0.5 + 0.5;
                            state.hidden[1][y][x] = Math.random() * 0.5;
                            state.aliveness[1][y][x] = 1.0;
                        }
                    }
                }
            }

            // Agent 2: bottom-right chamber
            const cx2 = gridSize - 16, cy2 = gridSize - 16, r2 = 10;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (!walls[y][x]) {
                        const dist = Math.sqrt((x - cx2) ** 2 + (y - cy2) ** 2);
                        if (dist < r2) {
                            state.attack[2][y][x] = Math.random() * 0.5 + 0.5;
                            state.defense[2][y][x] = Math.random() * 0.5 + 0.5;
                            state.hidden[2][y][x] = Math.random() * 0.5;
                            state.aliveness[2][y][x] = 1.0;
                        }
                    }
                }
            }

            step = 0;
        }

        function computeStrength(attacker, defender, y, x) {
            const a = state.attack[attacker][y][x];
            const d = state.defense[defender][y][x];
            return a * d;
        }

        function update() {
            const newState = {
                attack: state.attack.map(a => a.map(row => [...row])),
                defense: state.defense.map(d => d.map(row => [...row])),
                hidden: state.hidden.map(h => h.map(row => [...row])),
                aliveness: state.aliveness.map(a => a.map(row => [...row]))
            };

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    if (walls[y][x]) continue; // Skip walls

                    const deltas = [];
                    for (let agent = 0; agent <= numAgents; agent++) {
                        let avgAttack = 0, avgDefense = 0, avgHidden = 0;
                        let count = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (!walls[y + dy][x + dx]) {
                                    avgAttack += state.attack[agent][y + dy][x + dx];
                                    avgDefense += state.defense[agent][y + dy][x + dx];
                                    avgHidden += state.hidden[agent][y + dy][x + dx];
                                    count++;
                                }
                            }
                        }
                        if (count > 0) {
                            deltas.push({
                                attack: (avgAttack / count - state.attack[agent][y][x]) * 0.1,
                                defense: (avgDefense / count - state.defense[agent][y][x]) * 0.1,
                                hidden: (avgHidden / count - state.hidden[agent][y][x]) * 0.1 + Math.random() * 0.05 - 0.025
                            });
                        } else {
                            deltas.push({ attack: 0, defense: 0, hidden: 0 });
                        }
                    }

                    const strengths = [];
                    for (let i = 0; i <= numAgents; i++) {
                        let totalStrength = 0;
                        for (let j = 0; j <= numAgents; j++) {
                            if (i !== j) {
                                totalStrength += computeStrength(i, j, y, x);
                            }
                        }
                        strengths.push(totalStrength + state.aliveness[i][y][x]);
                    }

                    const maxStrength = Math.max(...strengths);
                    const expStrengths = strengths.map(s => Math.exp((s - maxStrength) / tau));
                    const sumExp = expStrengths.reduce((a, b) => a + b, 0);
                    const weights = expStrengths.map(e => e / sumExp);

                    for (let agent = 0; agent <= numAgents; agent++) {
                        const w = weights[agent];
                        newState.attack[agent][y][x] = Math.max(-1, Math.min(1,
                            state.attack[agent][y][x] + deltas[agent].attack * w
                        ));
                        newState.defense[agent][y][x] = Math.max(-1, Math.min(1,
                            state.defense[agent][y][x] + deltas[agent].defense * w
                        ));
                        newState.hidden[agent][y][x] = Math.max(-1, Math.min(1,
                            state.hidden[agent][y][x] + deltas[agent].hidden * w
                        ));
                        newState.aliveness[agent][y][x] = w;
                    }
                }
            }

            state = newState;
            step++;
        }

        function render() {
            const imageData = ctx.createImageData(gridSize, gridSize);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const idx = (y * gridSize + x) * 4;

                    if (walls[y][x]) {
                        // Draw walls as gray
                        imageData.data[idx] = 80;
                        imageData.data[idx + 1] = 80;
                        imageData.data[idx + 2] = 80;
                        imageData.data[idx + 3] = 255;
                    } else {
                        let maxAlive = 0;
                        let winner = 0;
                        for (let agent = 0; agent <= numAgents; agent++) {
                            if (state.aliveness[agent][y][x] > maxAlive) {
                                maxAlive = state.aliveness[agent][y][x];
                                winner = agent;
                            }
                        }

                        const color = agentColors[winner];
                        const intensity = maxAlive;
                        imageData.data[idx] = color[0] * intensity;
                        imageData.data[idx + 1] = color[1] * intensity;
                        imageData.data[idx + 2] = color[2] * intensity;
                        imageData.data[idx + 3] = 255;
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(canvas, 0, 0, gridSize, gridSize, 0, 0, canvas.width, canvas.height);

            updateStats();
        }

        function updateStats() {
            let territories = [0, 0, 0];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (!walls[y][x]) {
                        let maxAlive = 0;
                        let winner = 0;
                        for (let agent = 0; agent <= numAgents; agent++) {
                            if (state.aliveness[agent][y][x] > maxAlive) {
                                maxAlive = state.aliveness[agent][y][x];
                                winner = agent;
                            }
                        }
                        territories[winner]++;
                    }
                }
            }

            const total = territories.reduce((a, b) => a + b, 0);
            if (total > 0) {
                document.getElementById('agent1').textContent = ((territories[1] / total) * 100).toFixed(1);
                document.getElementById('agent2').textContent = ((territories[2] / total) * 100).toFixed(1);
            }
            document.getElementById('step').textContent = step;
        }

        function animate() {
            if (!paused) {
                update();
                render();
            }
            requestAnimationFrame(animate);
        }

        function togglePause() {
            paused = !paused;
        }

        function reset() {
            init();
            render();
        }

        init();
        animate();
    </script>
</body>
</html>
