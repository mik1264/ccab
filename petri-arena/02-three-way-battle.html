<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>02. Three-Way Battle - Petri Arena</title>
    <style>
        body {
            margin: 0; padding: 0; display: flex; justify-content: center; align-items: center;
            min-height: 100vh; background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white;
        }
        .container { text-align: center; }
        canvas {
            border: 2px solid #00f5ff; box-shadow: 0 0 20px rgba(0, 245, 255, 0.5); background: #000;
        }
        h1 { margin-bottom: 10px; font-size: 2rem; text-shadow: 0 0 10px rgba(0, 245, 255, 0.8); }
        .info {
            margin-top: 15px; font-size: 0.9rem; opacity: 0.8; max-width: 600px;
            line-height: 1.6; margin-left: auto; margin-right: auto;
        }
        .stats {
            margin-top: 10px; display: flex; justify-content: center; gap: 20px;
            flex-wrap: wrap; font-size: 0.9rem;
        }
        .stat {
            padding: 8px 15px; background: rgba(0, 245, 255, 0.1); border-radius: 5px;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }
        .agent-label {
            display: inline-block; width: 15px; height: 15px; border-radius: 3px;
            margin-right: 5px; vertical-align: middle;
        }
        .controls { margin-top: 15px; display: flex; justify-content: center; gap: 10px; }
        button {
            padding: 8px 20px; font-size: 0.9rem; background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5); color: white; border-radius: 5px;
            cursor: pointer; transition: all 0.3s;
        }
        button:hover {
            background: rgba(0, 245, 255, 0.4); box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>⚔️ Three-Way Battle</h1>
        <canvas id="canvas"></canvas>
        <div class="stats">
            <div class="stat"><span class="agent-label" style="background: #00f5ff;"></span>Agent 1: <span id="agent1">0</span>%</div>
            <div class="stat"><span class="agent-label" style="background: #ff00ff;"></span>Agent 2: <span id="agent2">0</span>%</div>
            <div class="stat"><span class="agent-label" style="background: #00ff88;"></span>Agent 3: <span id="agent3">0</span>%</div>
            <div class="stat">Step: <span id="step">0</span></div>
        </div>
        <div class="controls">
            <button onclick="togglePause()">Pause/Resume</button>
            <button onclick="reset()">Reset</button>
            <button onclick="location.href='index.html'">Back to Gallery</button>
        </div>
        <div class="info">
            Three-way competitive dynamics with potential for rock-paper-scissors patterns. Watch as agents
            form temporary alliances or create cyclic dominance patterns.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 128, cellSize = 4;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;

        const tau = 0.5, alpha = 0.4, numAgents = 3;
        let state = { attack: [], defense: [], hidden: [], aliveness: [] };
        let step = 0, paused = false;

        const agentColors = [[40, 40, 50], [0, 245, 255], [255, 0, 255], [0, 255, 136]];

        function initArrays() {
            for (let i = 0; i <= numAgents; i++) {
                state.attack[i] = Array(gridSize).fill(null).map(() => Array(gridSize).fill(0));
                state.defense[i] = Array(gridSize).fill(null).map(() => Array(gridSize).fill(0));
                state.hidden[i] = Array(gridSize).fill(null).map(() => Array(gridSize).fill(0));
                state.aliveness[i] = Array(gridSize).fill(null).map(() => Array(gridSize).fill(0));
            }
        }

        function init() {
            initArrays();

            // Background
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    state.attack[0][y][x] = Math.random() * 0.2 - 0.1;
                    state.defense[0][y][x] = Math.random() * 0.2 - 0.1;
                    state.aliveness[0][y][x] = 0.3;
                }
            }

            // Three agents in triangle formation
            const positions = [
                [gridSize * 0.5, gridSize * 0.25],
                [gridSize * 0.25, gridSize * 0.75],
                [gridSize * 0.75, gridSize * 0.75]
            ];

            for (let agent = 1; agent <= numAgents; agent++) {
                const [cx, cy] = positions[agent - 1];
                const r = 12;
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                        if (dist < r) {
                            state.attack[agent][y][x] = Math.random() * 0.5 + 0.5;
                            state.defense[agent][y][x] = Math.random() * 0.5 + 0.5;
                            state.hidden[agent][y][x] = Math.random() * 0.5;
                            state.aliveness[agent][y][x] = 1.0;
                        }
                    }
                }
            }
            step = 0;
        }

        function computeStrength(attacker, defender, y, x) {
            return state.attack[attacker][y][x] * state.defense[defender][y][x];
        }

        function update() {
            const newState = { attack: [], defense: [], hidden: [], aliveness: [] };
            for (let i = 0; i <= numAgents; i++) {
                newState.attack[i] = state.attack[i].map(row => [...row]);
                newState.defense[i] = state.defense[i].map(row => [...row]);
                newState.hidden[i] = state.hidden[i].map(row => [...row]);
                newState.aliveness[i] = state.aliveness[i].map(row => [...row]);
            }

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    const deltas = [];
                    for (let agent = 0; agent <= numAgents; agent++) {
                        let sum = [0, 0, 0], count = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                sum[0] += state.attack[agent][y + dy][x + dx];
                                sum[1] += state.defense[agent][y + dy][x + dx];
                                sum[2] += state.hidden[agent][y + dy][x + dx];
                                count++;
                            }
                        }
                        deltas.push({
                            attack: (sum[0] / count - state.attack[agent][y][x]) * 0.15,
                            defense: (sum[1] / count - state.defense[agent][y][x]) * 0.15,
                            hidden: (sum[2] / count - state.hidden[agent][y][x]) * 0.1 + (Math.random() - 0.5) * 0.05
                        });
                    }

                    const strengths = [];
                    for (let i = 0; i <= numAgents; i++) {
                        let s = 0;
                        for (let j = 0; j <= numAgents; j++) {
                            if (i !== j) s += computeStrength(i, j, y, x);
                        }
                        strengths.push(s + state.aliveness[i][y][x]);
                    }

                    const max = Math.max(...strengths);
                    const exp = strengths.map(s => Math.exp((s - max) / tau));
                    const sum = exp.reduce((a, b) => a + b, 0);
                    const weights = exp.map(e => e / sum);

                    for (let agent = 0; agent <= numAgents; agent++) {
                        const w = weights[agent];
                        newState.attack[agent][y][x] = Math.max(-1, Math.min(1, state.attack[agent][y][x] + deltas[agent].attack * w));
                        newState.defense[agent][y][x] = Math.max(-1, Math.min(1, state.defense[agent][y][x] + deltas[agent].defense * w));
                        newState.hidden[agent][y][x] = Math.max(-1, Math.min(1, state.hidden[agent][y][x] + deltas[agent].hidden * w));
                        newState.aliveness[agent][y][x] = w;
                    }
                }
            }
            state = newState;
            step++;
        }

        function render() {
            const imageData = ctx.createImageData(gridSize, gridSize);
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let maxAlive = 0, winner = 0;
                    for (let agent = 0; agent <= numAgents; agent++) {
                        if (state.aliveness[agent][y][x] > maxAlive) {
                            maxAlive = state.aliveness[agent][y][x];
                            winner = agent;
                        }
                    }
                    const idx = (y * gridSize + x) * 4;
                    const color = agentColors[winner];
                    imageData.data[idx] = color[0] * maxAlive;
                    imageData.data[idx + 1] = color[1] * maxAlive;
                    imageData.data[idx + 2] = color[2] * maxAlive;
                    imageData.data[idx + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(canvas, 0, 0, gridSize, gridSize, 0, 0, canvas.width, canvas.height);
            updateStats();
        }

        function updateStats() {
            let territories = Array(numAgents + 1).fill(0);
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let maxAlive = 0, winner = 0;
                    for (let agent = 0; agent <= numAgents; agent++) {
                        if (state.aliveness[agent][y][x] > maxAlive) {
                            maxAlive = state.aliveness[agent][y][x];
                            winner = agent;
                        }
                    }
                    territories[winner]++;
                }
            }
            const total = gridSize * gridSize;
            for (let i = 1; i <= numAgents; i++) {
                document.getElementById(`agent${i}`).textContent = ((territories[i] / total) * 100).toFixed(1);
            }
            document.getElementById('step').textContent = step;
        }

        function animate() {
            if (!paused) { update(); render(); }
            requestAnimationFrame(animate);
        }

        function togglePause() { paused = !paused; }
        function reset() { init(); render(); }

        init();
        animate();
    </script>
</body>
</html>
