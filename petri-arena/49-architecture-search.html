<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>49. Architecture Search - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        .container {
            text-align: center;
            max-width: 1200px;
        }
        h1 {
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
        }
        .arenas {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            justify-items: center;
            margin: 20px 0;
        }
        .arena-wrapper {
            text-align: center;
        }
        .arena-label {
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: #00f5ff;
        }
        canvas {
            border: 2px solid #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            background: #000;
        }
        .info {
            margin-top: 15px;
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 900px;
            line-height: 1.6;
            margin-left: auto;
            margin-right: auto;
        }
        .stats {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 15px;
            font-size: 0.85rem;
            flex-wrap: wrap;
        }
        .stat {
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }
        .controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 8px 20px;
            font-size: 0.9rem;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèóÔ∏è Architecture Search</h1>
        <div class="arenas">
            <div class="arena-wrapper">
                <div class="arena-label">Simple (3 Layers)</div>
                <canvas id="canvas1"></canvas>
            </div>
            <div class="arena-wrapper">
                <div class="arena-label">Medium (5 Layers)</div>
                <canvas id="canvas2"></canvas>
            </div>
            <div class="arena-wrapper">
                <div class="arena-label">Complex (7 Layers)</div>
                <canvas id="canvas3"></canvas>
            </div>
            <div class="arena-wrapper">
                <div class="arena-label">Very Complex (9 Layers)</div>
                <canvas id="canvas4"></canvas>
            </div>
        </div>
        <div class="stats">
            <div class="stat">Step: <span id="step">0</span></div>
            <div class="stat">3L: <span id="winner1">-</span></div>
            <div class="stat">5L: <span id="winner2">-</span></div>
            <div class="stat">7L: <span id="winner3">-</span></div>
            <div class="stat">9L: <span id="winner4">-</span></div>
        </div>
        <div class="controls">
            <button onclick="togglePause()">Pause/Resume</button>
            <button onclick="reset()">Reset</button>
            <button onclick="location.href='index.html'">Back to Gallery</button>
        </div>
        <div class="info">
            <strong>Neural Architecture Effect:</strong> Different "layer depths" simulate varying computational
            complexity. Simpler architectures (3 layers) are fast and stable but may lack expressiveness. Deeper
            architectures (9 layers) can learn more complex strategies but risk overfitting, slower convergence,
            and instability. This demonstrates the classic bias-variance tradeoff and the challenge of neural
            architecture search (NAS) in finding the optimal complexity!
        </div>
    </div>

    <script>
        const gridSize = 70;
        const cellSize = 3;
        const numAgents = 2;
        const architectures = [3, 5, 7, 9];
        const tau = 0.5;
        const alpha = 0.4;

        const simulations = architectures.map((layers, idx) => {
            const canvas = document.getElementById(`canvas${idx + 1}`);
            const ctx = canvas.getContext('2d');
            canvas.width = gridSize * cellSize;
            canvas.height = gridSize * cellSize;

            return {
                canvas,
                ctx,
                layers,
                state: createState(),
                seed: Math.random() * 1000
            };
        });

        let step = 0;
        let paused = false;

        const agentColors = [
            [20, 20, 20],
            [0, 245, 255],
            [255, 0, 255]
        ];

        function createState() {
            return {
                attack: Array(numAgents + 1).fill(null).map(() =>
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ),
                defense: Array(numAgents + 1).fill(null).map(() =>
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ),
                hidden: Array(numAgents + 1).fill(null).map(() =>
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ),
                aliveness: Array(numAgents + 1).fill(null).map(() =>
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                )
            };
        }

        function seededRandom(seed) {
            const x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        function initSimulation(sim) {
            let seedCounter = sim.seed;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    sim.state.attack[0][y][x] = seededRandom(seedCounter++) * 0.2 - 0.1;
                    sim.state.defense[0][y][x] = seededRandom(seedCounter++) * 0.2 - 0.1;
                    sim.state.hidden[0][y][x] = seededRandom(seedCounter++) * 0.2 - 0.1;
                    sim.state.aliveness[0][y][x] = 0.3;
                }
            }

            const cx1 = gridSize * 0.3, cy1 = gridSize * 0.5, r1 = 10;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx1) ** 2 + (y - cy1) ** 2);
                    if (dist < r1) {
                        sim.state.attack[1][y][x] = seededRandom(seedCounter++) * 0.5 + 0.5;
                        sim.state.defense[1][y][x] = seededRandom(seedCounter++) * 0.5 + 0.5;
                        sim.state.hidden[1][y][x] = seededRandom(seedCounter++) * 0.5;
                        sim.state.aliveness[1][y][x] = 1.0;
                    }
                }
            }

            const cx2 = gridSize * 0.7, cy2 = gridSize * 0.5, r2 = 10;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx2) ** 2 + (y - cy2) ** 2);
                    if (dist < r2) {
                        sim.state.attack[2][y][x] = seededRandom(seedCounter++) * 0.5 + 0.5;
                        sim.state.defense[2][y][x] = seededRandom(seedCounter++) * 0.5 + 0.5;
                        sim.state.hidden[2][y][x] = seededRandom(seedCounter++) * 0.5;
                        sim.state.aliveness[2][y][x] = 1.0;
                    }
                }
            }
        }

        function computeStrength(attacker, defender, state, y, x) {
            const a = state.attack[attacker][y][x];
            const d = state.defense[defender][y][x];
            return a * d;
        }

        function nonlinearity(x, layers) {
            // More layers = more nonlinear transformations
            let result = x;
            for (let i = 0; i < layers; i++) {
                result = Math.tanh(result);
            }
            return result;
        }

        function updateSimulation(sim) {
            const newState = {
                attack: sim.state.attack.map(a => a.map(row => [...row])),
                defense: sim.state.defense.map(d => d.map(row => [...row])),
                hidden: sim.state.hidden.map(h => h.map(row => [...row])),
                aliveness: sim.state.aliveness.map(a => a.map(row => [...row]))
            };

            // Learning rate decreases with architecture complexity
            const learningRate = 0.15 / Math.sqrt(sim.layers);

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    const deltas = [];
                    for (let agent = 0; agent <= numAgents; agent++) {
                        let avgAttack = 0, avgDefense = 0, avgHidden = 0;
                        let count = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                avgAttack += sim.state.attack[agent][y + dy][x + dx];
                                avgDefense += sim.state.defense[agent][y + dy][x + dx];
                                avgHidden += sim.state.hidden[agent][y + dy][x + dx];
                                count++;
                            }
                        }

                        // Apply nonlinearity based on architecture depth
                        const rawDeltaA = (avgAttack / count - sim.state.attack[agent][y][x]);
                        const rawDeltaD = (avgDefense / count - sim.state.defense[agent][y][x]);
                        const rawDeltaH = (avgHidden / count - sim.state.hidden[agent][y][x]);

                        deltas.push({
                            attack: nonlinearity(rawDeltaA, sim.layers) * learningRate,
                            defense: nonlinearity(rawDeltaD, sim.layers) * learningRate,
                            hidden: nonlinearity(rawDeltaH, sim.layers) * learningRate * 0.7
                        });
                    }

                    const strengths = [];
                    for (let i = 0; i <= numAgents; i++) {
                        let totalStrength = 0;
                        for (let j = 0; j <= numAgents; j++) {
                            if (i !== j) {
                                totalStrength += computeStrength(i, j, sim.state, y, x);
                            }
                        }
                        strengths.push(totalStrength + sim.state.aliveness[i][y][x] * 0.8);
                    }

                    const maxStrength = Math.max(...strengths);
                    const expStrengths = strengths.map(s => Math.exp((s - maxStrength) / tau));
                    const sumExp = expStrengths.reduce((a, b) => a + b, 0);
                    const weights = expStrengths.map(e => e / sumExp);

                    for (let agent = 0; agent <= numAgents; agent++) {
                        const w = weights[agent];
                        newState.attack[agent][y][x] = Math.max(-1, Math.min(1,
                            sim.state.attack[agent][y][x] + deltas[agent].attack * w
                        ));
                        newState.defense[agent][y][x] = Math.max(-1, Math.min(1,
                            sim.state.defense[agent][y][x] + deltas[agent].defense * w
                        ));
                        newState.hidden[agent][y][x] = Math.max(-1, Math.min(1,
                            sim.state.hidden[agent][y][x] + deltas[agent].hidden * w
                        ));
                        newState.aliveness[agent][y][x] = w;
                    }
                }
            }

            sim.state = newState;
        }

        function renderSimulation(sim) {
            const imageData = sim.ctx.createImageData(gridSize, gridSize);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let maxAlive = 0;
                    let winner = 0;
                    for (let agent = 0; agent <= numAgents; agent++) {
                        if (sim.state.aliveness[agent][y][x] > maxAlive) {
                            maxAlive = sim.state.aliveness[agent][y][x];
                            winner = agent;
                        }
                    }

                    const idx = (y * gridSize + x) * 4;
                    const color = agentColors[winner];
                    const intensity = maxAlive;
                    imageData.data[idx] = color[0] * intensity;
                    imageData.data[idx + 1] = color[1] * intensity;
                    imageData.data[idx + 2] = color[2] * intensity;
                    imageData.data[idx + 3] = 255;
                }
            }

            sim.ctx.putImageData(imageData, 0, 0);
            sim.ctx.imageSmoothingEnabled = false;
            sim.ctx.drawImage(sim.canvas, 0, 0, gridSize, gridSize, 0, 0, sim.canvas.width, sim.canvas.height);
        }

        function getWinner(sim) {
            let territories = [0, 0, 0];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let maxAlive = 0;
                    let winner = 0;
                    for (let agent = 0; agent <= numAgents; agent++) {
                        if (sim.state.aliveness[agent][y][x] > maxAlive) {
                            maxAlive = sim.state.aliveness[agent][y][x];
                            winner = agent;
                        }
                    }
                    territories[winner]++;
                }
            }
            const total = gridSize * gridSize;
            const p1 = (territories[1] / total * 100).toFixed(1);
            const p2 = (territories[2] / total * 100).toFixed(1);
            return `A1:${p1}% A2:${p2}%`;
        }

        function animate() {
            if (!paused) {
                simulations.forEach(sim => {
                    updateSimulation(sim);
                    renderSimulation(sim);
                });
                step++;

                document.getElementById('step').textContent = step;
                document.getElementById('winner1').textContent = getWinner(simulations[0]);
                document.getElementById('winner2').textContent = getWinner(simulations[1]);
                document.getElementById('winner3').textContent = getWinner(simulations[2]);
                document.getElementById('winner4').textContent = getWinner(simulations[3]);
            }
            requestAnimationFrame(animate);
        }

        function togglePause() {
            paused = !paused;
        }

        function reset() {
            step = 0;
            simulations.forEach(sim => {
                sim.state = createState();
                initSimulation(sim);
                renderSimulation(sim);
            });
        }

        simulations.forEach(sim => {
            initSimulation(sim);
            renderSimulation(sim);
        });
        animate();
    </script>
</body>
</html>
