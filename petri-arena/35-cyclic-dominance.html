<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>35. Cyclic Dominance - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        .container {
            text-align: center;
        }
        canvas {
            border: 2px solid #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            background: #000;
        }
        h1 {
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
        }
        .info {
            margin-top: 15px;
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 600px;
            line-height: 1.6;
        }
        .stats {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 30px;
            font-size: 0.95rem;
            flex-wrap: wrap;
        }
        .stat {
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }
        .agent-label {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 3px;
            margin-right: 5px;
            vertical-align: middle;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 8px 20px;
            font-size: 0.9rem;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>♻️ Cyclic Dominance</h1>
        <canvas id="canvas"></canvas>
        <div class="stats">
            <div class="stat">
                <span class="agent-label" style="background: #00f5ff;"></span>
                Rock: <span id="agent1">0</span>%
            </div>
            <div class="stat">
                <span class="agent-label" style="background: #ff00ff;"></span>
                Paper: <span id="agent2">0</span>%
            </div>
            <div class="stat">
                <span class="agent-label" style="background: #00ff88;"></span>
                Scissors: <span id="agent3">0</span>%
            </div>
            <div class="stat">Step: <span id="step">0</span></div>
            <div class="stat" style="background: rgba(255, 136, 0, 0.1); border-color: rgba(255, 136, 0, 0.3);">
                Wave Speed: <span id="wave">0.00</span>
            </div>
        </div>
        <div class="controls">
            <button onclick="togglePause()">Pause/Resume</button>
            <button onclick="reset()">Reset</button>
            <button onclick="location.href='index.html'">Back to Gallery</button>
        </div>
        <div class="info">
            Three agents in rock-paper-scissors dynamics: Rock (cyan) beats Scissors, Scissors (green) beats Paper, Paper (magenta) beats Rock.
            Watch traveling waves form at the boundaries where agents meet. The wave speed metric measures how fast
            dominance patterns propagate through space, creating dynamic spiral or circular waves.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const gridSize = 128;
        const cellSize = 4;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;

        const tau = 0.5;
        const alpha = 0.4;
        const numAgents = 3;

        let state = {
            attack: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            defense: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            hidden: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            aliveness: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            )
        };

        let prevAliveness = null;
        let step = 0;
        let paused = false;
        let waveSpeed = 0;

        const agentColors = [
            [0, 245, 255],
            [0, 245, 255],      // Rock
            [255, 0, 255],      // Paper
            [0, 255, 136]       // Scissors
        ];

        function init() {
            // Neutral background
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    state.attack[0][y][x] = Math.random() * 0.1 - 0.05;
                    state.defense[0][y][x] = Math.random() * 0.1 - 0.05;
                    state.hidden[0][y][x] = Math.random() * 0.1 - 0.05;
                    state.aliveness[0][y][x] = 0.2;
                }
            }

            // Agent 1: Rock (top-left)
            const cx1 = gridSize * 0.3, cy1 = gridSize * 0.3, r1 = 18;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx1) ** 2 + (y - cy1) ** 2);
                    if (dist < r1) {
                        state.attack[1][y][x] = Math.random() * 0.4 + 0.4;
                        state.defense[1][y][x] = Math.random() * 0.4 + 0.4;
                        state.hidden[1][y][x] = Math.random() * 0.3;
                        state.aliveness[1][y][x] = 1.0;
                    }
                }
            }

            // Agent 2: Paper (top-right)
            const cx2 = gridSize * 0.7, cy2 = gridSize * 0.3, r2 = 18;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx2) ** 2 + (y - cy2) ** 2);
                    if (dist < r2) {
                        state.attack[2][y][x] = Math.random() * 0.4 + 0.4;
                        state.defense[2][y][x] = Math.random() * 0.4 + 0.4;
                        state.hidden[2][y][x] = Math.random() * 0.3;
                        state.aliveness[2][y][x] = 1.0;
                    }
                }
            }

            // Agent 3: Scissors (bottom-center)
            const cx3 = gridSize * 0.5, cy3 = gridSize * 0.7, r3 = 18;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx3) ** 2 + (y - cy3) ** 2);
                    if (dist < r3) {
                        state.attack[3][y][x] = Math.random() * 0.4 + 0.4;
                        state.defense[3][y][x] = Math.random() * 0.4 + 0.4;
                        state.hidden[3][y][x] = Math.random() * 0.3;
                        state.aliveness[3][y][x] = 1.0;
                    }
                }
            }

            prevAliveness = state.aliveness.map(a => a.map(row => [...row]));
            step = 0;
        }

        function computeStrength(attacker, defender, y, x) {
            // Rock-Paper-Scissors dominance
            // 1=Rock, 2=Paper, 3=Scissors
            // Rock beats Scissors, Scissors beats Paper, Paper beats Rock

            let strength = state.attack[attacker][y][x] * state.defense[defender][y][x];

            // Amplify cyclic dominance
            if (attacker === 1 && defender === 3) strength *= 2.0;  // Rock > Scissors
            if (attacker === 3 && defender === 2) strength *= 2.0;  // Scissors > Paper
            if (attacker === 2 && defender === 1) strength *= 2.0;  // Paper > Rock

            // Weaken reverse interactions
            if (attacker === 3 && defender === 1) strength *= 0.3;  // Scissors < Rock
            if (attacker === 2 && defender === 3) strength *= 0.3;  // Paper < Scissors
            if (attacker === 1 && defender === 2) strength *= 0.3;  // Rock < Paper

            return strength;
        }

        function computeWaveSpeed() {
            if (!prevAliveness) return 0;

            let totalChange = 0;
            let count = 0;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    for (let agent = 1; agent <= numAgents; agent++) {
                        const change = Math.abs(state.aliveness[agent][y][x] - prevAliveness[agent][y][x]);
                        totalChange += change;
                        count++;
                    }
                }
            }

            prevAliveness = state.aliveness.map(a => a.map(row => [...row]));
            return count > 0 ? totalChange / count : 0;
        }

        function update() {
            const newState = {
                attack: state.attack.map(a => a.map(row => [...row])),
                defense: state.defense.map(d => d.map(row => [...row])),
                hidden: state.hidden.map(h => h.map(row => [...row])),
                aliveness: state.aliveness.map(a => a.map(row => [...row]))
            };

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    const deltas = [];
                    for (let agent = 0; agent <= numAgents; agent++) {
                        let avgAttack = 0, avgDefense = 0, avgHidden = 0;
                        let count = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                avgAttack += state.attack[agent][y + dy][x + dx];
                                avgDefense += state.defense[agent][y + dy][x + dx];
                                avgHidden += state.hidden[agent][y + dy][x + dx];
                                count++;
                            }
                        }

                        deltas.push({
                            attack: (avgAttack / count - state.attack[agent][y][x]) * 0.1,
                            defense: (avgDefense / count - state.defense[agent][y][x]) * 0.1,
                            hidden: (avgHidden / count - state.hidden[agent][y][x]) * 0.1 + Math.random() * 0.05 - 0.025
                        });
                    }

                    const strengths = [];
                    for (let i = 0; i <= numAgents; i++) {
                        let totalStrength = 0;
                        for (let j = 0; j <= numAgents; j++) {
                            if (i !== j) {
                                totalStrength += computeStrength(i, j, y, x);
                            }
                        }
                        strengths.push(totalStrength + state.aliveness[i][y][x]);
                    }

                    const maxStrength = Math.max(...strengths);
                    const expStrengths = strengths.map(s => Math.exp((s - maxStrength) / tau));
                    const sumExp = expStrengths.reduce((a, b) => a + b, 0);
                    const weights = expStrengths.map(e => e / sumExp);

                    for (let agent = 0; agent <= numAgents; agent++) {
                        const w = weights[agent];
                        newState.attack[agent][y][x] = Math.max(-1, Math.min(1,
                            state.attack[agent][y][x] + deltas[agent].attack * w
                        ));
                        newState.defense[agent][y][x] = Math.max(-1, Math.min(1,
                            state.defense[agent][y][x] + deltas[agent].defense * w
                        ));
                        newState.hidden[agent][y][x] = Math.max(-1, Math.min(1,
                            state.hidden[agent][y][x] + deltas[agent].hidden * w
                        ));
                        newState.aliveness[agent][y][x] = alpha * state.aliveness[agent][y][x] + (1 - alpha) * w;
                    }
                }
            }

            state = newState;
            waveSpeed = computeWaveSpeed();
            step++;
        }

        function render() {
            const imageData = ctx.createImageData(gridSize, gridSize);
            const data = imageData.data;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const idx = (y * gridSize + x) * 4;
                    let r = 0, g = 0, b = 0;

                    for (let agent = 0; agent <= numAgents; agent++) {
                        const weight = state.aliveness[agent][y][x];
                        r += agentColors[agent][0] * weight;
                        g += agentColors[agent][1] * weight;
                        b += agentColors[agent][2] * weight;
                    }

                    data[idx] = Math.min(255, r);
                    data[idx + 1] = Math.min(255, g);
                    data[idx + 2] = Math.min(255, b);
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
            ctx.drawImage(canvas, 0, 0, gridSize, gridSize, 0, 0, canvas.width, canvas.height);
        }

        function updateStats() {
            let totals = [0, 0, 0, 0];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    for (let agent = 0; agent <= numAgents; agent++) {
                        totals[agent] += state.aliveness[agent][y][x];
                    }
                }
            }

            const total = totals.reduce((a, b) => a + b, 0);
            document.getElementById('agent1').textContent = ((totals[1] / total) * 100).toFixed(1);
            document.getElementById('agent2').textContent = ((totals[2] / total) * 100).toFixed(1);
            document.getElementById('agent3').textContent = ((totals[3] / total) * 100).toFixed(1);
            document.getElementById('step').textContent = step;
            document.getElementById('wave').textContent = (waveSpeed * 100).toFixed(2);
        }

        function animate() {
            if (!paused) {
                update();
                render();
                updateStats();
            }
            requestAnimationFrame(animate);
        }

        function togglePause() {
            paused = !paused;
        }

        function reset() {
            init();
        }

        init();
        animate();
    </script>
</body>
</html>
