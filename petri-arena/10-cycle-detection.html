<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cycle Detection - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
        }
        .description {
            max-width: 800px;
            text-align: center;
            margin-bottom: 20px;
            color: #aaa;
        }
        .main-content {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        canvas {
            border: 2px solid #667eea;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .graph {
            width: 300px;
            height: 300px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #667eea;
            border-radius: 8px;
            position: relative;
        }
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 10px 20px;
            background: #667eea;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        button:hover {
            background: #764ba2;
        }
        .stats {
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-family: monospace;
            min-width: 300px;
        }
        .cycle-indicator {
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
            margin-top: 10px;
        }
        .cycle-yes {
            background: rgba(100, 255, 100, 0.3);
            color: #9fff9f;
        }
        .cycle-no {
            background: rgba(255, 100, 100, 0.2);
            color: #ff9f9f;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link" style="position:fixed;top:15px;left:15px;color:#fff;text-decoration:none;opacity:0.8;">‚Üê Back</a>
    <h1>Cycle Detection</h1>
    <p class="description">
        Cycles emerge in PD-NCA when agents create sustained oscillations or cooperative loops.
        The paper notes cycles appear more frequently on larger grids with learning enabled.
    </p>

    <div class="main-content">
        <canvas id="canvas"></canvas>
        <div class="side-panel">
            <div class="stats">
                <div>Step: <span id="step">0</span></div>
                <div>Period check: <span id="period">-</span></div>
                <div style="margin-top: 10px;">
                    <strong>Population:</strong><br>
                    R: <span id="popR">0</span><br>
                    G: <span id="popG">0</span><br>
                    B: <span id="popB">0</span>
                </div>
                <div id="cycleIndicator" class="cycle-indicator cycle-no">
                    No Cycle Detected
                </div>
            </div>
            <canvas id="graphCanvas" class="graph"></canvas>
        </div>
    </div>

    <div class="controls">
        <button id="resetBtn">Reset</button>
        <button id="pauseBtn">Pause</button>
        <button id="patternBtn">Try Pattern</button>
    </div>

    <script src="../assets/js/demo-utils.js"></script>
    <script>
        const fps = new FPSCounter({ position: 'top-right' });
        const errorMgr = new ErrorManager();
        setupGlobalErrorHandler((msg, details) => errorMgr.show(msg, details));
        fps.start();

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');

        const gridSize = 128;
        const cellSize = 4;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;
        graphCanvas.width = 300;
        graphCanvas.height = 300;

        const numAgents = 3;
        let grid = new Float32Array(gridSize * gridSize * numAgents);
        let popHistory = [];
        const maxHistory = 200;

        let stepCount = 0;
        let paused = false;
        let patternMode = 0;

        function idx(x, y, agent) {
            const gx = ((x + gridSize) % gridSize);
            const gy = ((y + gridSize) % gridSize);
            return (gy * gridSize + gx) * numAgents + agent;
        }

        function reset() {
            grid.fill(0);
            popHistory = [];
            stepCount = 0;

            applyPattern(patternMode);
        }

        function applyPattern(mode) {
            grid.fill(0);

            if (mode === 0) {
                // Rock-paper-scissors pattern
                const seeds = [
                    {x: 40, y: 64, agent: 0, r: 12},
                    {x: 64, y: 90, agent: 1, r: 12},
                    {x: 88, y: 64, agent: 2, r: 12}
                ];

                seeds.forEach(seed => {
                    for (let dy = -seed.r; dy <= seed.r; dy++) {
                        for (let dx = -seed.r; dx <= seed.r; dx++) {
                            if (dx*dx + dy*dy <= seed.r * seed.r) {
                                grid[idx(seed.x + dx, seed.y + dy, seed.agent)] = 0.8;
                            }
                        }
                    }
                });
            } else if (mode === 1) {
                // Spiral pattern
                for (let a = 0; a < numAgents; a++) {
                    const angle = (a / numAgents) * Math.PI * 2;
                    const cx = 64 + Math.cos(angle) * 30;
                    const cy = 64 + Math.sin(angle) * 30;

                    for (let i = 0; i < 20; i++) {
                        const spiralAngle = angle + i * 0.5;
                        const r = 5 + i * 2;
                        const x = Math.floor(cx + Math.cos(spiralAngle) * r);
                        const y = Math.floor(cy + Math.sin(spiralAngle) * r);

                        for (let dy = -2; dy <= 2; dy++) {
                            for (let dx = -2; dx <= 2; dx++) {
                                if (dx*dx + dy*dy <= 4) {
                                    grid[idx(x + dx, y + dy, a)] = 0.7;
                                }
                            }
                        }
                    }
                }
            } else {
                // Random scattered
                for (let s = 0; s < 12; s++) {
                    const x = Math.floor(Math.random() * gridSize);
                    const y = Math.floor(Math.random() * gridSize);
                    const a = s % numAgents;
                    const r = 5;

                    for (let dy = -r; dy <= r; dy++) {
                        for (let dx = -r; dx <= r; dx++) {
                            if (dx*dx + dy*dy <= r*r) {
                                grid[idx(x + dx, y + dy, a)] = 0.6 + Math.random() * 0.4;
                            }
                        }
                    }
                }
            }
        }

        function step() {
            const next = new Float32Array(grid.length);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    for (let a = 0; a < numAgents; a++) {
                        let sum = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                sum += grid[idx(x + dx, y + dy, a)];
                            }
                        }

                        const current = grid[idx(x, y, a)];
                        const predator = (a + 1) % numAgents;
                        const prey = (a + 2) % numAgents;

                        let predatorSum = 0;
                        let preySum = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                predatorSum += grid[idx(x + dx, y + dy, predator)];
                                preySum += grid[idx(x + dx, y + dy, prey)];
                            }
                        }

                        let nextVal = current;

                        if (predatorSum > 4) {
                            nextVal = Math.max(0, current - 0.1);
                        } else if (sum > 3 || preySum > 3) {
                            nextVal = Math.min(1.0, current + 0.08);
                        } else {
                            nextVal = Math.max(0, current - 0.02);
                        }

                        next[idx(x, y, a)] = nextVal;
                    }
                }
            }

            grid = next;
            stepCount++;
        }

        function calculatePopulations() {
            const pops = [0, 0, 0];
            for (let i = 0; i < gridSize * gridSize; i++) {
                for (let a = 0; a < numAgents; a++) {
                    if (grid[i * numAgents + a] > 0.4) {
                        pops[a]++;
                    }
                }
            }
            return pops;
        }

        function detectCycle() {
            if (popHistory.length < 60) return null;

            // Check for periodic patterns
            for (let period = 10; period <= 50; period++) {
                let matches = 0;
                const checkLen = Math.min(30, Math.floor(popHistory.length / period));

                for (let i = 0; i < checkLen; i++) {
                    const idx1 = popHistory.length - 1 - i;
                    const idx2 = idx1 - period;
                    if (idx2 < 0) break;

                    const diff = Math.abs(popHistory[idx1][0] - popHistory[idx2][0]) +
                                Math.abs(popHistory[idx1][1] - popHistory[idx2][1]) +
                                Math.abs(popHistory[idx1][2] - popHistory[idx2][2]);

                    if (diff < 100) matches++;
                }

                if (matches > checkLen * 0.7) {
                    return period;
                }
            }

            return null;
        }

        function draw() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const r = grid[idx(x, y, 0)] * 255;
                    const g = grid[idx(x, y, 1)] * 255;
                    const b = grid[idx(x, y, 2)] * 255;

                    for (let dy = 0; dy < cellSize; dy++) {
                        for (let dx = 0; dx < cellSize; dx++) {
                            const px = x * cellSize + dx;
                            const py = y * cellSize + dy;
                            const pi = (py * canvas.width + px) * 4;

                            data[pi] = r;
                            data[pi + 1] = g;
                            data[pi + 2] = b;
                            data[pi + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function drawGraph() {
            graphCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            graphCtx.fillRect(0, 0, graphCanvas.width, graphCanvas.height);

            if (popHistory.length < 2) return;

            const maxPop = gridSize * gridSize * 0.5;
            const colors = ['rgb(255, 100, 100)', 'rgb(100, 255, 100)', 'rgb(100, 150, 255)'];

            for (let a = 0; a < numAgents; a++) {
                graphCtx.strokeStyle = colors[a];
                graphCtx.lineWidth = 2;
                graphCtx.beginPath();

                popHistory.forEach((pops, i) => {
                    const x = (i / maxHistory) * graphCanvas.width;
                    const y = graphCanvas.height - (pops[a] / maxPop) * graphCanvas.height;
                    if (i === 0) {
                        graphCtx.moveTo(x, y);
                    } else {
                        graphCtx.lineTo(x, y);
                    }
                });

                graphCtx.stroke();
            }
        }

        function updateStats() {
            const pops = calculatePopulations();
            popHistory.push(pops);
            if (popHistory.length > maxHistory) popHistory.shift();

            const cycle = detectCycle();

            document.getElementById('step').textContent = stepCount;
            document.getElementById('period').textContent = cycle ? cycle + ' steps' : 'Checking...';
            document.getElementById('popR').textContent = pops[0];
            document.getElementById('popG').textContent = pops[1];
            document.getElementById('popB').textContent = pops[2];

            const indicator = document.getElementById('cycleIndicator');
            if (cycle) {
                indicator.className = 'cycle-indicator cycle-yes';
                indicator.textContent = `Cycle Detected! Period: ${cycle}`;
            } else if (stepCount > 100) {
                indicator.className = 'cycle-indicator cycle-no';
                indicator.textContent = 'No Stable Cycle Yet';
            }

            drawGraph();
        }

        function animate() {
            fps.update();
            if (!paused) {
                step();
                updateStats();
            }
            draw();
            requestAnimationFrame(animate);
        }

        document.getElementById('resetBtn').addEventListener('click', reset);
        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('patternBtn').addEventListener('click', () => {
            patternMode = (patternMode + 1) % 3;
            const patterns = ['RPS Triangle', 'Spiral', 'Random'];
            document.getElementById('patternBtn').textContent = 'Pattern: ' + patterns[patternMode];
            reset();
        });

        reset();
        animate();
    </script>
</body>
</html>
