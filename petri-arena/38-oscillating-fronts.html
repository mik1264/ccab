<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>38. Oscillating Fronts - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        .container {
            text-align: center;
        }
        canvas {
            border: 2px solid #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            background: #000;
        }
        h1 {
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
        }
        .info {
            margin-top: 15px;
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 600px;
            line-height: 1.6;
        }
        .stats {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 30px;
            font-size: 0.95rem;
            flex-wrap: wrap;
        }
        .stat {
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }
        .agent-label {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 3px;
            margin-right: 5px;
            vertical-align: middle;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 8px 20px;
            font-size: 0.9rem;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>〰️ Oscillating Fronts</h1>
        <canvas id="canvas"></canvas>
        <div class="stats">
            <div class="stat">
                <span class="agent-label" style="background: #00f5ff;"></span>
                Agent 1: <span id="agent1">0</span>%
            </div>
            <div class="stat">
                <span class="agent-label" style="background: #ff00ff;"></span>
                Agent 2: <span id="agent2">0</span>%
            </div>
            <div class="stat">Step: <span id="step">0</span></div>
            <div class="stat" style="background: rgba(255, 136, 0, 0.1); border-color: rgba(255, 136, 0, 0.3);">
                Osc. Freq: <span id="frequency">0.00</span>
            </div>
            <div class="stat" style="background: rgba(0, 255, 136, 0.1); border-color: rgba(0, 255, 136, 0.3);">
                Stability: <span id="stability">0.00</span>
            </div>
        </div>
        <div class="controls">
            <button onclick="togglePause()">Pause/Resume</button>
            <button onclick="reset()">Reset</button>
            <button onclick="location.href='index.html'">Back to Gallery</button>
        </div>
        <div class="info">
            Two evenly-matched agents create a boundary that oscillates rhythmically rather than stabilizing.
            The oscillation frequency measures how fast the boundary moves back and forth. Stability metric
            tracks whether oscillations are regular (high stability) or chaotic (low stability). Watch the
            hypnotic pulsing of territorial control.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const gridSize = 128;
        const cellSize = 4;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;

        const tau = 0.45;  // Slightly lower for more dynamic competition
        const alpha = 0.35; // Lower alpha for faster oscillations
        const numAgents = 2;

        let state = {
            attack: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            defense: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            hidden: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            aliveness: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            )
        };

        let step = 0;
        let paused = false;
        let oscillationFrequency = 0;
        let stabilityScore = 0;
        let boundaryPositions = [];

        const agentColors = [
            [0, 245, 255],
            [0, 245, 255],
            [255, 0, 255]
        ];

        function init() {
            // Minimal background
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    state.attack[0][y][x] = Math.random() * 0.05 - 0.025;
                    state.defense[0][y][x] = Math.random() * 0.05 - 0.025;
                    state.hidden[0][y][x] = Math.random() * 0.05 - 0.025;
                    state.aliveness[0][y][x] = 0.15;
                }
            }

            // Agent 1: Left half - balanced stats
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize / 2 + 5; x++) {
                    state.attack[1][y][x] = Math.random() * 0.3 + 0.5;
                    state.defense[1][y][x] = Math.random() * 0.3 + 0.5;
                    state.hidden[1][y][x] = Math.random() * 0.4 + 0.3;
                    state.aliveness[1][y][x] = 1.0;
                }
            }

            // Agent 2: Right half - balanced stats (nearly identical)
            for (let y = 0; y < gridSize; y++) {
                for (let x = gridSize / 2 - 5; x < gridSize; x++) {
                    state.attack[2][y][x] = Math.random() * 0.3 + 0.5;
                    state.defense[2][y][x] = Math.random() * 0.3 + 0.5;
                    state.hidden[2][y][x] = Math.random() * 0.4 + 0.3;
                    state.aliveness[2][y][x] = 1.0;
                }
            }

            boundaryPositions = [];
            step = 0;
        }

        function computeStrength(attacker, defender, y, x) {
            return state.attack[attacker][y][x] * state.defense[defender][y][x];
        }

        function computeBoundaryCenter() {
            // Find center of mass of boundary region
            let sumX = 0, count = 0;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const a1 = state.aliveness[1][y][x];
                    const a2 = state.aliveness[2][y][x];
                    // Boundary where both agents are present
                    if (a1 > 0.2 && a2 > 0.2) {
                        sumX += x;
                        count++;
                    }
                }
            }
            return count > 0 ? sumX / count : gridSize / 2;
        }

        function computeOscillationMetrics() {
            const pos = computeBoundaryCenter();
            boundaryPositions.push(pos);

            // Keep last 100 positions
            if (boundaryPositions.length > 100) {
                boundaryPositions.shift();
            }

            if (boundaryPositions.length < 20) {
                return { frequency: 0, stability: 0 };
            }

            // Compute oscillation frequency using zero crossings
            const mean = boundaryPositions.reduce((a, b) => a + b, 0) / boundaryPositions.length;
            let crossings = 0;
            for (let i = 1; i < boundaryPositions.length; i++) {
                if ((boundaryPositions[i - 1] < mean && boundaryPositions[i] >= mean) ||
                    (boundaryPositions[i - 1] >= mean && boundaryPositions[i] < mean)) {
                    crossings++;
                }
            }
            const frequency = crossings / boundaryPositions.length;

            // Compute stability (regularity of oscillation amplitude)
            const deviations = boundaryPositions.map(p => Math.abs(p - mean));
            const avgDeviation = deviations.reduce((a, b) => a + b, 0) / deviations.length;
            const variance = deviations.reduce((sum, d) => sum + (d - avgDeviation) ** 2, 0) / deviations.length;
            const stability = avgDeviation > 0 ? Math.exp(-variance / (avgDeviation ** 2)) : 0;

            return { frequency, stability };
        }

        function update() {
            const newState = {
                attack: state.attack.map(a => a.map(row => [...row])),
                defense: state.defense.map(d => d.map(row => [...row])),
                hidden: state.hidden.map(h => h.map(row => [...row])),
                aliveness: state.aliveness.map(a => a.map(row => [...row]))
            };

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    const deltas = [];
                    for (let agent = 0; agent <= numAgents; agent++) {
                        let avgAttack = 0, avgDefense = 0, avgHidden = 0;
                        let count = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                avgAttack += state.attack[agent][y + dy][x + dx];
                                avgDefense += state.defense[agent][y + dy][x + dx];
                                avgHidden += state.hidden[agent][y + dy][x + dx];
                                count++;
                            }
                        }

                        // Add temporal forcing to sustain oscillations
                        const timeForce = Math.sin(step * 0.05) * 0.015;

                        deltas.push({
                            attack: (avgAttack / count - state.attack[agent][y][x]) * 0.12 + timeForce,
                            defense: (avgDefense / count - state.defense[agent][y][x]) * 0.12,
                            hidden: (avgHidden / count - state.hidden[agent][y][x]) * 0.12 + Math.random() * 0.06 - 0.03
                        });
                    }

                    const strengths = [];
                    for (let i = 0; i <= numAgents; i++) {
                        let totalStrength = 0;
                        for (let j = 0; j <= numAgents; j++) {
                            if (i !== j) {
                                totalStrength += computeStrength(i, j, y, x);
                            }
                        }
                        strengths.push(totalStrength + state.aliveness[i][y][x]);
                    }

                    const maxStrength = Math.max(...strengths);
                    const expStrengths = strengths.map(s => Math.exp((s - maxStrength) / tau));
                    const sumExp = expStrengths.reduce((a, b) => a + b, 0);
                    const weights = expStrengths.map(e => e / sumExp);

                    for (let agent = 0; agent <= numAgents; agent++) {
                        const w = weights[agent];
                        newState.attack[agent][y][x] = Math.max(-1, Math.min(1,
                            state.attack[agent][y][x] + deltas[agent].attack * w
                        ));
                        newState.defense[agent][y][x] = Math.max(-1, Math.min(1,
                            state.defense[agent][y][x] + deltas[agent].defense * w
                        ));
                        newState.hidden[agent][y][x] = Math.max(-1, Math.min(1,
                            state.hidden[agent][y][x] + deltas[agent].hidden * w
                        ));
                        newState.aliveness[agent][y][x] = alpha * state.aliveness[agent][y][x] + (1 - alpha) * w;
                    }
                }
            }

            state = newState;

            const metrics = computeOscillationMetrics();
            oscillationFrequency = metrics.frequency;
            stabilityScore = metrics.stability;

            step++;
        }

        function render() {
            const imageData = ctx.createImageData(gridSize, gridSize);
            const data = imageData.data;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const idx = (y * gridSize + x) * 4;
                    let r = 0, g = 0, b = 0;

                    for (let agent = 0; agent <= numAgents; agent++) {
                        const weight = state.aliveness[agent][y][x];
                        r += agentColors[agent][0] * weight;
                        g += agentColors[agent][1] * weight;
                        b += agentColors[agent][2] * weight;
                    }

                    data[idx] = Math.min(255, r);
                    data[idx + 1] = Math.min(255, g);
                    data[idx + 2] = Math.min(255, b);
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
            ctx.drawImage(canvas, 0, 0, gridSize, gridSize, 0, 0, canvas.width, canvas.height);
        }

        function updateStats() {
            let totals = [0, 0, 0];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    for (let agent = 0; agent <= numAgents; agent++) {
                        totals[agent] += state.aliveness[agent][y][x];
                    }
                }
            }

            const total = totals.reduce((a, b) => a + b, 0);
            document.getElementById('agent1').textContent = ((totals[1] / total) * 100).toFixed(1);
            document.getElementById('agent2').textContent = ((totals[2] / total) * 100).toFixed(1);
            document.getElementById('step').textContent = step;
            document.getElementById('frequency').textContent = oscillationFrequency.toFixed(3);
            document.getElementById('stability').textContent = stabilityScore.toFixed(2);
        }

        function animate() {
            if (!paused) {
                update();
                render();
                updateStats();
            }
            requestAnimationFrame(animate);
        }

        function togglePause() {
            paused = !paused;
        }

        function reset() {
            init();
        }

        init();
        animate();
    </script>
</body>
</html>
