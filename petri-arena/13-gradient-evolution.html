<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>13. Gradient Evolution - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        .container {
            text-align: center;
        }
        .main-display {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: flex-start;
        }
        canvas {
            border: 2px solid #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            background: #000;
        }
        #trajectoryCanvas {
            border-color: #ff00ff;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }
        h1 {
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
        }
        .info {
            margin-top: 15px;
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 800px;
            line-height: 1.6;
        }
        .stats {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 0.95rem;
            flex-wrap: wrap;
        }
        .stat {
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }
        .controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 8px 20px;
            font-size: 0.9rem;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
        .graph-label {
            font-size: 0.9rem;
            margin-bottom: 5px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ“ˆ Gradient Evolution</h1>
        <div class="main-display">
            <div>
                <div class="graph-label">Arena</div>
                <canvas id="canvas"></canvas>
            </div>
            <div>
                <div class="graph-label">Parameter Trajectory</div>
                <canvas id="trajectoryCanvas"></canvas>
            </div>
        </div>
        <div class="stats">
            <div class="stat">Step: <span id="step">0</span></div>
            <div class="stat">Territory: <span id="territory">0</span>%</div>
            <div class="stat">Attack: <span id="attack">1.00</span></div>
            <div class="stat">Defense: <span id="defense">1.00</span></div>
            <div class="stat">Gradient: <span id="gradient">0.00</span></div>
        </div>
        <div class="controls">
            <button onclick="togglePause()">Pause/Resume</button>
            <button onclick="reset()">Reset</button>
            <button onclick="location.href='index.html'">Back to Gallery</button>
        </div>
        <div class="info">
            Visualizes how agent parameters evolve through gradient-based updates. The right graph shows the trajectory
            of attack (cyan) and defense (magenta) parameters over time as they adapt to maximize territory control.
            The gradient signal drives parameter updates, creating feedback loops that shape strategic evolution.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const trajCanvas = document.getElementById('trajectoryCanvas');
        const trajCtx = trajCanvas.getContext('2d');

        const gridSize = 128;
        const cellSize = 4;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;
        trajCanvas.width = 512;
        trajCanvas.height = 512;

        const tau = 0.5;
        const learningRate = 0.04;
        let step = 0;
        let paused = false;

        let state = createState();
        let params = { attackMult: 1.0, defenseMult: 1.0 };
        let prevTerritory = 0;
        let trajectory = [];

        function createState() {
            return {
                attack: [
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0)),
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ],
                defense: [
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0)),
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ],
                aliveness: [
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0)),
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ]
            };
        }

        function init() {
            state = createState();
            params = { attackMult: 1.0, defenseMult: 1.0 };
            trajectory = [{ attack: 1.0, defense: 1.0 }];

            // Background
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    state.attack[0][y][x] = Math.random() * 0.3 - 0.15;
                    state.defense[0][y][x] = Math.random() * 0.3 - 0.15;
                    state.aliveness[0][y][x] = 0.5;
                }
            }

            // Agent
            const cx = gridSize / 2, cy = gridSize / 2, r = 20;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                    if (dist < r) {
                        state.attack[1][y][x] = Math.random() * 0.6 + 0.4;
                        state.defense[1][y][x] = Math.random() * 0.6 + 0.4;
                        state.aliveness[1][y][x] = 1.0;
                    }
                }
            }

            prevTerritory = 0;
            step = 0;
        }

        function computeStrength(attacker, defender, y, x) {
            const a = state.attack[attacker][y][x] * (attacker === 1 ? params.attackMult : 1.0);
            const d = state.defense[defender][y][x] * (defender === 1 ? params.defenseMult : 1.0);
            return a * d;
        }

        function update() {
            const currentTerritory = calculateTerritory();
            const gradient = currentTerritory - prevTerritory;

            // Gradient descent with momentum
            const attackGrad = gradient + (Math.random() - 0.5) * 0.02;
            const defenseGrad = gradient + (Math.random() - 0.5) * 0.02;

            params.attackMult += learningRate * attackGrad;
            params.defenseMult += learningRate * defenseGrad;
            params.attackMult = Math.max(0.3, Math.min(2.5, params.attackMult));
            params.defenseMult = Math.max(0.3, Math.min(2.5, params.defenseMult));

            trajectory.push({ attack: params.attackMult, defense: params.defenseMult });
            if (trajectory.length > 500) trajectory.shift();

            prevTerritory = currentTerritory;

            // Update state
            const newState = {
                attack: state.attack.map(a => a.map(row => [...row])),
                defense: state.defense.map(d => d.map(row => [...row])),
                aliveness: state.aliveness.map(a => a.map(row => [...row]))
            };

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    const deltas = [0, 1].map(agent => {
                        let avgAttack = 0, avgDefense = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                avgAttack += state.attack[agent][y + dy][x + dx];
                                avgDefense += state.defense[agent][y + dy][x + dx];
                            }
                        }
                        return {
                            attack: (avgAttack / 9 - state.attack[agent][y][x]) * 0.1,
                            defense: (avgDefense / 9 - state.defense[agent][y][x]) * 0.1
                        };
                    });

                    const strengths = [
                        computeStrength(0, 1, y, x) + state.aliveness[0][y][x],
                        computeStrength(1, 0, y, x) + state.aliveness[1][y][x]
                    ];

                    const maxStrength = Math.max(...strengths);
                    const expStrengths = strengths.map(s => Math.exp((s - maxStrength) / tau));
                    const sumExp = expStrengths.reduce((a, b) => a + b, 0);
                    const weights = expStrengths.map(e => e / sumExp);

                    [0, 1].forEach(agent => {
                        newState.attack[agent][y][x] = Math.max(-1, Math.min(1,
                            state.attack[agent][y][x] + deltas[agent].attack * weights[agent]
                        ));
                        newState.defense[agent][y][x] = Math.max(-1, Math.min(1,
                            state.defense[agent][y][x] + deltas[agent].defense * weights[agent]
                        ));
                        newState.aliveness[agent][y][x] = weights[agent];
                    });
                }
            }

            state = newState;
            step++;
        }

        function calculateTerritory() {
            let count = 0;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (state.aliveness[1][y][x] > state.aliveness[0][y][x]) count++;
                }
            }
            return count / (gridSize * gridSize);
        }

        function render() {
            // Render arena
            const imageData = ctx.createImageData(gridSize, gridSize);
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const idx = (y * gridSize + x) * 4;
                    const winner = state.aliveness[1][y][x] > state.aliveness[0][y][x] ? 1 : 0;
                    const intensity = state.aliveness[winner][y][x];
                    if (winner === 1) {
                        imageData.data[idx] = 0;
                        imageData.data[idx + 1] = 245 * intensity;
                        imageData.data[idx + 2] = 255 * intensity;
                    } else {
                        imageData.data[idx] = 80 * intensity;
                        imageData.data[idx + 1] = 80 * intensity;
                        imageData.data[idx + 2] = 80 * intensity;
                    }
                    imageData.data[idx + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(canvas, 0, 0, gridSize, gridSize, 0, 0, canvas.width, canvas.height);

            // Render trajectory
            trajCtx.fillStyle = '#000';
            trajCtx.fillRect(0, 0, trajCanvas.width, trajCanvas.height);

            // Draw axes
            trajCtx.strokeStyle = '#444';
            trajCtx.lineWidth = 1;
            trajCtx.beginPath();
            trajCtx.moveTo(50, 50);
            trajCtx.lineTo(50, trajCanvas.height - 50);
            trajCtx.lineTo(trajCanvas.width - 50, trajCanvas.height - 50);
            trajCtx.stroke();

            // Labels
            trajCtx.fillStyle = '#aaa';
            trajCtx.font = '12px Arial';
            trajCtx.fillText('Attack', trajCanvas.width - 100, trajCanvas.height - 30);
            trajCtx.save();
            trajCtx.translate(20, trajCanvas.height / 2);
            trajCtx.rotate(-Math.PI / 2);
            trajCtx.fillText('Defense', 0, 0);
            trajCtx.restore();

            // Plot trajectory
            if (trajectory.length > 1) {
                const minX = 0.3, maxX = 2.5, minY = 0.3, maxY = 2.5;
                const scaleX = (trajCanvas.width - 100) / (maxX - minX);
                const scaleY = (trajCanvas.height - 100) / (maxY - minY);

                // Attack trajectory (cyan)
                trajCtx.strokeStyle = '#00f5ff';
                trajCtx.lineWidth = 2;
                trajCtx.beginPath();
                for (let i = 0; i < trajectory.length; i++) {
                    const x = 50 + (trajectory[i].attack - minX) * scaleX;
                    const y = trajCanvas.height - 50 - (trajectory[i].defense - minY) * scaleY;
                    if (i === 0) trajCtx.moveTo(x, y);
                    else trajCtx.lineTo(x, y);
                }
                trajCtx.stroke();

                // Current position
                const curr = trajectory[trajectory.length - 1];
                const currX = 50 + (curr.attack - minX) * scaleX;
                const currY = trajCanvas.height - 50 - (curr.defense - minY) * scaleY;
                trajCtx.fillStyle = '#00f5ff';
                trajCtx.beginPath();
                trajCtx.arc(currX, currY, 5, 0, Math.PI * 2);
                trajCtx.fill();
            }

            // Update stats
            const territory = calculateTerritory();
            const gradient = territory - prevTerritory;
            document.getElementById('step').textContent = step;
            document.getElementById('territory').textContent = (territory * 100).toFixed(1);
            document.getElementById('attack').textContent = params.attackMult.toFixed(2);
            document.getElementById('defense').textContent = params.defenseMult.toFixed(2);
            document.getElementById('gradient').textContent = gradient.toFixed(4);
        }

        function animate() {
            if (!paused) {
                update();
                render();
            }
            requestAnimationFrame(animate);
        }

        function togglePause() {
            paused = !paused;
        }

        function reset() {
            init();
            render();
        }

        init();
        animate();
    </script>
</body>
</html>
