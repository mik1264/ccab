<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>16. Meta-Learning - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        .container {
            text-align: center;
        }
        canvas {
            border: 2px solid #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            background: #000;
        }
        h1 {
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
        }
        .info {
            margin-top: 15px;
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 700px;
            line-height: 1.6;
        }
        .stats {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 0.95rem;
            flex-wrap: wrap;
        }
        .stat {
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }
        .meta-display {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        .meta-box {
            padding: 12px 20px;
            background: rgba(255, 0, 255, 0.1);
            border-radius: 8px;
            border: 2px solid rgba(255, 0, 255, 0.4);
            min-width: 150px;
        }
        .meta-title {
            font-weight: bold;
            font-size: 1rem;
            margin-bottom: 5px;
            color: #ff00ff;
        }
        .meta-value {
            font-size: 1.2rem;
            font-weight: bold;
        }
        .adaptive-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #00ff00;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 8px 20px;
            font-size: 0.9rem;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§© Meta-Learning</h1>
        <canvas id="canvas"></canvas>
        <div class="stats">
            <div class="stat">Step: <span id="step">0</span></div>
            <div class="stat">Territory: <span id="territory">0</span>%</div>
            <div class="stat">Performance Trend: <span id="trend">Stable</span></div>
        </div>
        <div class="meta-display">
            <div class="meta-box">
                <div class="meta-title"><span class="adaptive-indicator"></span> Learning Rate (Î±)</div>
                <div class="meta-value" id="learningRate">0.05</div>
            </div>
            <div class="meta-box">
                <div class="meta-title">Attack Parameter</div>
                <div class="meta-value" id="attack">1.00</div>
            </div>
            <div class="meta-box">
                <div class="meta-title">Defense Parameter</div>
                <div class="meta-value" id="defense">1.00</div>
            </div>
        </div>
        <div class="controls">
            <button onclick="togglePause()">Pause/Resume</button>
            <button onclick="reset()">Reset</button>
            <button onclick="location.href='index.html'">Back to Gallery</button>
        </div>
        <div class="info">
            Learning to learn: The agent adjusts its own learning rate based on performance trends. When territory is
            increasing (good progress), learning rate increases for faster adaptation. When territory is decreasing (poor
            progress), learning rate decreases for stability. This meta-learning creates adaptive optimization where the
            agent learns how to learn more effectively.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const gridSize = 128;
        const cellSize = 4;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;

        const tau = 0.5;
        const metaLearningRate = 0.005; // Rate at which learning rate changes
        let learningRate = 0.05;
        let step = 0;
        let paused = false;

        let state = createState();
        let params = { attackMult: 1.0, defenseMult: 1.0 };
        let performanceHistory = [];

        function createState() {
            return {
                attack: [
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0)),
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ],
                defense: [
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0)),
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ],
                aliveness: [
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0)),
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ]
            };
        }

        function init() {
            state = createState();
            params = { attackMult: 1.0, defenseMult: 1.0 };
            learningRate = 0.05;
            performanceHistory = [];

            // Background
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    state.attack[0][y][x] = Math.random() * 0.3 - 0.15;
                    state.defense[0][y][x] = Math.random() * 0.3 - 0.15;
                    state.aliveness[0][y][x] = 0.5;
                }
            }

            // Agent
            const cx = gridSize / 2, cy = gridSize / 2, r = 20;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                    if (dist < r) {
                        state.attack[1][y][x] = Math.random() * 0.6 + 0.4;
                        state.defense[1][y][x] = Math.random() * 0.6 + 0.4;
                        state.aliveness[1][y][x] = 1.0;
                    }
                }
            }

            step = 0;
        }

        function computeStrength(attacker, defender, y, x) {
            const a = state.attack[attacker][y][x] * (attacker === 1 ? params.attackMult : 1.0);
            const d = state.defense[defender][y][x] * (defender === 1 ? params.defenseMult : 1.0);
            return a * d;
        }

        function update() {
            const currentTerritory = calculateTerritory();
            performanceHistory.push(currentTerritory);
            if (performanceHistory.length > 20) performanceHistory.shift();

            // Meta-learning: Adjust learning rate based on performance trend
            if (performanceHistory.length >= 10) {
                const recent = performanceHistory.slice(-10);
                const older = performanceHistory.slice(-20, -10);
                const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
                const olderAvg = older.reduce((a, b) => a + b, 0) / older.length;
                const trend = recentAvg - olderAvg;

                // If improving, increase learning rate; if declining, decrease it
                learningRate += metaLearningRate * trend;
                learningRate = Math.max(0.01, Math.min(0.15, learningRate));
            }

            // Compute gradient
            const prevTerritory = performanceHistory.length > 1 ? performanceHistory[performanceHistory.length - 2] : currentTerritory;
            const gradient = currentTerritory - prevTerritory;

            // Update parameters with adaptive learning rate
            params.attackMult += learningRate * gradient + (Math.random() - 0.5) * 0.02;
            params.defenseMult += learningRate * gradient + (Math.random() - 0.5) * 0.02;
            params.attackMult = Math.max(0.5, Math.min(2.5, params.attackMult));
            params.defenseMult = Math.max(0.5, Math.min(2.5, params.defenseMult));

            // Update state
            const newState = {
                attack: state.attack.map(a => a.map(row => [...row])),
                defense: state.defense.map(d => d.map(row => [...row])),
                aliveness: state.aliveness.map(a => a.map(row => [...row]))
            };

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    const deltas = [0, 1].map(agent => {
                        let avgAttack = 0, avgDefense = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                avgAttack += state.attack[agent][y + dy][x + dx];
                                avgDefense += state.defense[agent][y + dy][x + dx];
                            }
                        }
                        return {
                            attack: (avgAttack / 9 - state.attack[agent][y][x]) * 0.1,
                            defense: (avgDefense / 9 - state.defense[agent][y][x]) * 0.1
                        };
                    });

                    const strengths = [
                        computeStrength(0, 1, y, x) + state.aliveness[0][y][x],
                        computeStrength(1, 0, y, x) + state.aliveness[1][y][x]
                    ];

                    const maxStrength = Math.max(...strengths);
                    const expStrengths = strengths.map(s => Math.exp((s - maxStrength) / tau));
                    const sumExp = expStrengths.reduce((a, b) => a + b, 0);
                    const weights = expStrengths.map(e => e / sumExp);

                    [0, 1].forEach(agent => {
                        newState.attack[agent][y][x] = Math.max(-1, Math.min(1,
                            state.attack[agent][y][x] + deltas[agent].attack * weights[agent]
                        ));
                        newState.defense[agent][y][x] = Math.max(-1, Math.min(1,
                            state.defense[agent][y][x] + deltas[agent].defense * weights[agent]
                        ));
                        newState.aliveness[agent][y][x] = weights[agent];
                    });
                }
            }

            state = newState;
            step++;
        }

        function calculateTerritory() {
            let count = 0;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (state.aliveness[1][y][x] > state.aliveness[0][y][x]) count++;
                }
            }
            return count / (gridSize * gridSize);
        }

        function render() {
            const imageData = ctx.createImageData(gridSize, gridSize);
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const idx = (y * gridSize + x) * 4;
                    const winner = state.aliveness[1][y][x] > state.aliveness[0][y][x] ? 1 : 0;
                    const intensity = state.aliveness[winner][y][x];
                    if (winner === 1) {
                        imageData.data[idx] = 0;
                        imageData.data[idx + 1] = 245 * intensity;
                        imageData.data[idx + 2] = 255 * intensity;
                    } else {
                        imageData.data[idx] = 100 * intensity;
                        imageData.data[idx + 1] = 100 * intensity;
                        imageData.data[idx + 2] = 100 * intensity;
                    }
                    imageData.data[idx + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(canvas, 0, 0, gridSize, gridSize, 0, 0, canvas.width, canvas.height);

            // Calculate trend
            let trendText = 'Stable';
            if (performanceHistory.length >= 10) {
                const recent = performanceHistory.slice(-10);
                const older = performanceHistory.slice(-20, -10);
                if (older.length > 0) {
                    const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
                    const olderAvg = older.reduce((a, b) => a + b, 0) / older.length;
                    const trend = recentAvg - olderAvg;
                    if (trend > 0.01) trendText = 'ðŸ“ˆ Improving';
                    else if (trend < -0.01) trendText = 'ðŸ“‰ Declining';
                }
            }

            document.getElementById('step').textContent = step;
            document.getElementById('territory').textContent = (calculateTerritory() * 100).toFixed(1);
            document.getElementById('trend').textContent = trendText;
            document.getElementById('learningRate').textContent = learningRate.toFixed(3);
            document.getElementById('attack').textContent = params.attackMult.toFixed(2);
            document.getElementById('defense').textContent = params.defenseMult.toFixed(2);
        }

        function animate() {
            if (!paused) {
                update();
                render();
            }
            requestAnimationFrame(animate);
        }

        function togglePause() {
            paused = !paused;
        }

        function reset() {
            init();
            render();
        }

        init();
        animate();
    </script>
</body>
</html>
