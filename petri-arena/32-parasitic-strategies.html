<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>32. Parasitic Strategies - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        .container {
            text-align: center;
        }
        canvas {
            border: 2px solid #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            background: #000;
        }
        h1 {
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
        }
        .info {
            margin-top: 15px;
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 600px;
            line-height: 1.6;
        }
        .stats {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 30px;
            font-size: 0.95rem;
            flex-wrap: wrap;
        }
        .stat {
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }
        .agent-label {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 3px;
            margin-right: 5px;
            vertical-align: middle;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 8px 20px;
            font-size: 0.9rem;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ¦  Parasitic Strategies</h1>
        <canvas id="canvas"></canvas>
        <div class="stats">
            <div class="stat">
                <span class="agent-label" style="background: #00f5ff;"></span>
                Host: <span id="agent1">0</span>%
            </div>
            <div class="stat">
                <span class="agent-label" style="background: #ff00ff;"></span>
                Parasite: <span id="agent2">0</span>%
            </div>
            <div class="stat">Step: <span id="step">0</span></div>
            <div class="stat" style="background: rgba(255, 0, 255, 0.1); border-color: rgba(255, 0, 255, 0.3);">
                Exploitation: <span id="exploitation">0.00</span>
            </div>
            <div class="stat" style="background: rgba(255, 136, 0, 0.1); border-color: rgba(255, 136, 0, 0.3);">
                Distance: <span id="distance">0</span>
            </div>
        </div>
        <div class="controls">
            <button onclick="togglePause()">Pause/Resume</button>
            <button onclick="reset()">Reset</button>
            <button onclick="location.href='index.html'">Back to Gallery</button>
        </div>
        <div class="info">
            A small parasitic agent (magenta) follows and exploits a larger host agent (cyan) without direct combat.
            The parasite benefits from staying near the host's boundaries, extracting resources through proximity.
            Watch how the parasite tracks the host's movements and maintains an optimal following distance.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const gridSize = 128;
        const cellSize = 4;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;

        const tau = 0.5;
        const alpha = 0.4;
        const numAgents = 2;

        let state = {
            attack: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            defense: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            hidden: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            aliveness: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            )
        };

        let step = 0;
        let paused = false;
        let exploitationLevel = 0;
        let hostParasiteDistance = 0;

        const agentColors = [
            [0, 245, 255],
            [0, 245, 255],
            [255, 0, 255]
        ];

        function init() {
            // Passive background
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    state.attack[0][y][x] = Math.random() * 0.1 - 0.05;
                    state.defense[0][y][x] = Math.random() * 0.1 - 0.05;
                    state.hidden[0][y][x] = Math.random() * 0.1 - 0.05;
                    state.aliveness[0][y][x] = 0.3;
                }
            }

            // Agent 1: Large host (starts in center-left)
            const cx1 = gridSize * 0.4, cy1 = gridSize * 0.5, r1 = 18;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx1) ** 2 + (y - cy1) ** 2);
                    if (dist < r1) {
                        state.attack[1][y][x] = Math.random() * 0.4 + 0.3;
                        state.defense[1][y][x] = Math.random() * 0.4 + 0.3;
                        state.hidden[1][y][x] = Math.random() * 0.3;
                        state.aliveness[1][y][x] = 1.0;
                    }
                }
            }

            // Agent 2: Small parasite (starts nearby)
            const cx2 = gridSize * 0.6, cy2 = gridSize * 0.5, r2 = 8;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx2) ** 2 + (y - cy2) ** 2);
                    if (dist < r2) {
                        state.attack[2][y][x] = Math.random() * 0.2 + 0.1;  // Weak attack
                        state.defense[2][y][x] = Math.random() * 0.5 + 0.5;  // Strong defense
                        state.hidden[2][y][x] = Math.random() * 0.5 + 0.5;   // High stealth
                        state.aliveness[2][y][x] = 1.0;
                    }
                }
            }

            step = 0;
        }

        function computeStrength(attacker, defender, y, x) {
            return state.attack[attacker][y][x] * state.defense[defender][y][x];
        }

        function computeCenterOfMass(agent) {
            let sumX = 0, sumY = 0, mass = 0;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const alive = state.aliveness[agent][y][x];
                    sumX += x * alive;
                    sumY += y * alive;
                    mass += alive;
                }
            }
            return mass > 0 ? { x: sumX / mass, y: sumY / mass } : { x: 0, y: 0 };
        }

        function computeExploitation() {
            // Measure parasite's proximity to host boundaries
            let exploitSum = 0;
            let count = 0;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const parasitePresence = state.aliveness[2][y][x];
                    if (parasitePresence > 0.3) {
                        // Check for nearby host cells
                        let hostProximity = 0;
                        for (let dy = -3; dy <= 3; dy++) {
                            for (let dx = -3; dx <= 3; dx++) {
                                const ny = y + dy;
                                const nx = x + dx;
                                if (ny >= 0 && ny < gridSize && nx >= 0 && nx < gridSize) {
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist > 0 && dist < 4) {
                                        hostProximity += state.aliveness[1][ny][nx] / dist;
                                    }
                                }
                            }
                        }
                        exploitSum += hostProximity * parasitePresence;
                        count++;
                    }
                }
            }

            return count > 0 ? exploitSum / count : 0;
        }

        function update() {
            const newState = {
                attack: state.attack.map(a => a.map(row => [...row])),
                defense: state.defense.map(d => d.map(row => [...row])),
                hidden: state.hidden.map(h => h.map(row => [...row])),
                aliveness: state.aliveness.map(a => a.map(row => [...row]))
            };

            // Compute center of mass for tracking
            const hostCenter = computeCenterOfMass(1);
            const parasiteCenter = computeCenterOfMass(2);

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    const deltas = [];
                    for (let agent = 0; agent <= numAgents; agent++) {
                        let avgAttack = 0, avgDefense = 0, avgHidden = 0;
                        let count = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                avgAttack += state.attack[agent][y + dy][x + dx];
                                avgDefense += state.defense[agent][y + dy][x + dx];
                                avgHidden += state.hidden[agent][y + dy][x + dx];
                                count++;
                            }
                        }

                        let bonus = 0;

                        // Parasite follows host
                        if (agent === 2) {
                            const dirToHost = {
                                x: hostCenter.x - x,
                                y: hostCenter.y - y
                            };
                            const distToHost = Math.sqrt(dirToHost.x ** 2 + dirToHost.y ** 2);

                            // Bias growth toward host, but maintain distance
                            if (distToHost > 10 && distToHost < 30) {
                                // Check if this cell is in the direction of the host
                                let hostInfluence = 0;
                                for (let dy = -2; dy <= 2; dy++) {
                                    for (let dx = -2; dx <= 2; dx++) {
                                        const ny = y + dy;
                                        const nx = x + dx;
                                        if (ny >= 0 && ny < gridSize && nx >= 0 && nx < gridSize) {
                                            hostInfluence += state.aliveness[1][ny][nx] * 0.02;
                                        }
                                    }
                                }
                                bonus = hostInfluence;
                            }
                        }

                        deltas.push({
                            attack: (avgAttack / count - state.attack[agent][y][x]) * 0.1,
                            defense: (avgDefense / count - state.defense[agent][y][x]) * 0.1 + bonus,
                            hidden: (avgHidden / count - state.hidden[agent][y][x]) * 0.1 + Math.random() * 0.05 - 0.025
                        });
                    }

                    const strengths = [];
                    for (let i = 0; i <= numAgents; i++) {
                        let totalStrength = 0;
                        for (let j = 0; j <= numAgents; j++) {
                            if (i !== j) {
                                // Parasite doesn't attack host directly
                                if (!(i === 2 && j === 1) && !(i === 1 && j === 2)) {
                                    totalStrength += computeStrength(i, j, y, x);
                                }
                            }
                        }
                        strengths.push(totalStrength + state.aliveness[i][y][x]);
                    }

                    const maxStrength = Math.max(...strengths);
                    const expStrengths = strengths.map(s => Math.exp((s - maxStrength) / tau));
                    const sumExp = expStrengths.reduce((a, b) => a + b, 0);
                    const weights = expStrengths.map(e => e / sumExp);

                    for (let agent = 0; agent <= numAgents; agent++) {
                        const w = weights[agent];
                        newState.attack[agent][y][x] = Math.max(-1, Math.min(1,
                            state.attack[agent][y][x] + deltas[agent].attack * w
                        ));
                        newState.defense[agent][y][x] = Math.max(-1, Math.min(1,
                            state.defense[agent][y][x] + deltas[agent].defense * w
                        ));
                        newState.hidden[agent][y][x] = Math.max(-1, Math.min(1,
                            state.hidden[agent][y][x] + deltas[agent].hidden * w
                        ));
                        newState.aliveness[agent][y][x] = alpha * state.aliveness[agent][y][x] + (1 - alpha) * w;
                    }
                }
            }

            state = newState;
            exploitationLevel = computeExploitation();

            const hostCenter2 = computeCenterOfMass(1);
            const parasiteCenter2 = computeCenterOfMass(2);
            hostParasiteDistance = Math.sqrt(
                (hostCenter2.x - parasiteCenter2.x) ** 2 + (hostCenter2.y - parasiteCenter2.y) ** 2
            );

            step++;
        }

        function render() {
            const imageData = ctx.createImageData(gridSize, gridSize);
            const data = imageData.data;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const idx = (y * gridSize + x) * 4;
                    let r = 0, g = 0, b = 0;

                    for (let agent = 0; agent <= numAgents; agent++) {
                        const weight = state.aliveness[agent][y][x];
                        r += agentColors[agent][0] * weight;
                        g += agentColors[agent][1] * weight;
                        b += agentColors[agent][2] * weight;
                    }

                    data[idx] = Math.min(255, r);
                    data[idx + 1] = Math.min(255, g);
                    data[idx + 2] = Math.min(255, b);
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
            ctx.drawImage(canvas, 0, 0, gridSize, gridSize, 0, 0, canvas.width, canvas.height);
        }

        function updateStats() {
            let totals = [0, 0, 0];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    for (let agent = 0; agent <= numAgents; agent++) {
                        totals[agent] += state.aliveness[agent][y][x];
                    }
                }
            }

            const total = totals.reduce((a, b) => a + b, 0);
            document.getElementById('agent1').textContent = ((totals[1] / total) * 100).toFixed(1);
            document.getElementById('agent2').textContent = ((totals[2] / total) * 100).toFixed(1);
            document.getElementById('step').textContent = step;
            document.getElementById('exploitation').textContent = exploitationLevel.toFixed(2);
            document.getElementById('distance').textContent = Math.round(hostParasiteDistance);
        }

        function animate() {
            if (!paused) {
                update();
                render();
                updateStats();
            }
            requestAnimationFrame(animate);
        }

        function togglePause() {
            paused = !paused;
        }

        function reset() {
            init();
        }

        init();
        animate();
    </script>
</body>
</html>
