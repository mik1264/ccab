<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>47. Update Frequency - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        .container {
            text-align: center;
        }
        h1 {
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
        }
        .arenas {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
        }
        .arena-wrapper {
            text-align: center;
        }
        .arena-label {
            margin-bottom: 8px;
            font-size: 0.95rem;
            color: #00f5ff;
        }
        canvas {
            border: 2px solid #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            background: #000;
        }
        .info {
            margin-top: 15px;
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 900px;
            line-height: 1.6;
        }
        .stats {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 0.9rem;
        }
        .stat {
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }
        .controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 8px 20px;
            font-size: 0.9rem;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>⏱️ Update Frequency</h1>
        <div class="arenas">
            <div class="arena-wrapper">
                <div class="arena-label">Synchronous (All at Once)</div>
                <canvas id="canvas1"></canvas>
            </div>
            <div class="arena-wrapper">
                <div class="arena-label">Asynchronous (Random Order)</div>
                <canvas id="canvas2"></canvas>
            </div>
            <div class="arena-wrapper">
                <div class="arena-label">Block Sequential (4x4 blocks)</div>
                <canvas id="canvas3"></canvas>
            </div>
        </div>
        <div class="stats">
            <div class="stat">Step: <span id="step">0</span></div>
            <div class="stat">Sync: <span id="winner1">-</span></div>
            <div class="stat">Async: <span id="winner2">-</span></div>
            <div class="stat">Block: <span id="winner3">-</span></div>
        </div>
        <div class="controls">
            <button onclick="togglePause()">Pause/Resume</button>
            <button onclick="reset()">Reset</button>
            <button onclick="location.href='index.html'">Back to Gallery</button>
        </div>
        <div class="info">
            <strong>Update Scheduling Effect:</strong> Synchronous updates (all cells at once) create deterministic,
            wave-like propagation patterns. Asynchronous updates (random order) introduce stochasticity and break
            symmetries, often creating more organic patterns. Block sequential updates compromise between the two,
            updating regions in sequence. Different schedules can favor different strategies!
        </div>
    </div>

    <script>
        const gridSize = 80;
        const cellSize = 3;
        const numAgents = 2;
        const tau = 0.5;
        const alpha = 0.4;

        const updateModes = ['sync', 'async', 'block'];
        const simulations = updateModes.map((mode, idx) => {
            const canvas = document.getElementById(`canvas${idx + 1}`);
            const ctx = canvas.getContext('2d');
            canvas.width = gridSize * cellSize;
            canvas.height = gridSize * cellSize;

            return {
                canvas,
                ctx,
                mode,
                state: createState(),
                seed: Math.random() * 1000
            };
        });

        let step = 0;
        let paused = false;

        const agentColors = [
            [20, 20, 20],
            [0, 245, 255],
            [255, 0, 255]
        ];

        function createState() {
            return {
                attack: Array(numAgents + 1).fill(null).map(() =>
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ),
                defense: Array(numAgents + 1).fill(null).map(() =>
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ),
                hidden: Array(numAgents + 1).fill(null).map(() =>
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ),
                aliveness: Array(numAgents + 1).fill(null).map(() =>
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                )
            };
        }

        function seededRandom(seed) {
            const x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        function initSimulation(sim) {
            let seedCounter = sim.seed;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    sim.state.attack[0][y][x] = seededRandom(seedCounter++) * 0.2 - 0.1;
                    sim.state.defense[0][y][x] = seededRandom(seedCounter++) * 0.2 - 0.1;
                    sim.state.hidden[0][y][x] = seededRandom(seedCounter++) * 0.2 - 0.1;
                    sim.state.aliveness[0][y][x] = 0.3;
                }
            }

            const cx1 = gridSize * 0.3, cy1 = gridSize * 0.5, r1 = 12;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx1) ** 2 + (y - cy1) ** 2);
                    if (dist < r1) {
                        sim.state.attack[1][y][x] = seededRandom(seedCounter++) * 0.5 + 0.5;
                        sim.state.defense[1][y][x] = seededRandom(seedCounter++) * 0.5 + 0.5;
                        sim.state.hidden[1][y][x] = seededRandom(seedCounter++) * 0.5;
                        sim.state.aliveness[1][y][x] = 1.0;
                    }
                }
            }

            const cx2 = gridSize * 0.7, cy2 = gridSize * 0.5, r2 = 12;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx2) ** 2 + (y - cy2) ** 2);
                    if (dist < r2) {
                        sim.state.attack[2][y][x] = seededRandom(seedCounter++) * 0.5 + 0.5;
                        sim.state.defense[2][y][x] = seededRandom(seedCounter++) * 0.5 + 0.5;
                        sim.state.hidden[2][y][x] = seededRandom(seedCounter++) * 0.5;
                        sim.state.aliveness[2][y][x] = 1.0;
                    }
                }
            }
        }

        function computeStrength(attacker, defender, state, y, x) {
            const a = state.attack[attacker][y][x];
            const d = state.defense[defender][y][x];
            return a * d;
        }

        function updateCell(sim, newState, y, x) {
            if (y === 0 || y === gridSize - 1 || x === 0 || x === gridSize - 1) return;

            const deltas = [];
            for (let agent = 0; agent <= numAgents; agent++) {
                let avgAttack = 0, avgDefense = 0, avgHidden = 0;
                let count = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        avgAttack += sim.state.attack[agent][y + dy][x + dx];
                        avgDefense += sim.state.defense[agent][y + dy][x + dx];
                        avgHidden += sim.state.hidden[agent][y + dy][x + dx];
                        count++;
                    }
                }
                deltas.push({
                    attack: (avgAttack / count - sim.state.attack[agent][y][x]) * 0.15,
                    defense: (avgDefense / count - sim.state.defense[agent][y][x]) * 0.15,
                    hidden: (avgHidden / count - sim.state.hidden[agent][y][x]) * 0.1
                });
            }

            const strengths = [];
            for (let i = 0; i <= numAgents; i++) {
                let totalStrength = 0;
                for (let j = 0; j <= numAgents; j++) {
                    if (i !== j) {
                        totalStrength += computeStrength(i, j, sim.state, y, x);
                    }
                }
                strengths.push(totalStrength + sim.state.aliveness[i][y][x] * 0.8);
            }

            const maxStrength = Math.max(...strengths);
            const expStrengths = strengths.map(s => Math.exp((s - maxStrength) / tau));
            const sumExp = expStrengths.reduce((a, b) => a + b, 0);
            const weights = expStrengths.map(e => e / sumExp);

            for (let agent = 0; agent <= numAgents; agent++) {
                const w = weights[agent];
                newState.attack[agent][y][x] = Math.max(-1, Math.min(1,
                    sim.state.attack[agent][y][x] + deltas[agent].attack * w
                ));
                newState.defense[agent][y][x] = Math.max(-1, Math.min(1,
                    sim.state.defense[agent][y][x] + deltas[agent].defense * w
                ));
                newState.hidden[agent][y][x] = Math.max(-1, Math.min(1,
                    sim.state.hidden[agent][y][x] + deltas[agent].hidden * w
                ));
                newState.aliveness[agent][y][x] = w;
            }
        }

        function updateSimulation(sim) {
            const newState = {
                attack: sim.state.attack.map(a => a.map(row => [...row])),
                defense: sim.state.defense.map(d => d.map(row => [...row])),
                hidden: sim.state.hidden.map(h => h.map(row => [...row])),
                aliveness: sim.state.aliveness.map(a => a.map(row => [...row]))
            };

            if (sim.mode === 'sync') {
                // Synchronous: update all cells at once
                for (let y = 1; y < gridSize - 1; y++) {
                    for (let x = 1; x < gridSize - 1; x++) {
                        updateCell(sim, newState, y, x);
                    }
                }
            } else if (sim.mode === 'async') {
                // Asynchronous: random order
                const cells = [];
                for (let y = 1; y < gridSize - 1; y++) {
                    for (let x = 1; x < gridSize - 1; x++) {
                        cells.push([y, x]);
                    }
                }
                // Shuffle
                for (let i = cells.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [cells[i], cells[j]] = [cells[j], cells[i]];
                }
                // Update in random order, applying changes immediately
                for (const [y, x] of cells) {
                    updateCell(sim, newState, y, x);
                    // Apply immediately for async
                    for (let agent = 0; agent <= numAgents; agent++) {
                        sim.state.attack[agent][y][x] = newState.attack[agent][y][x];
                        sim.state.defense[agent][y][x] = newState.defense[agent][y][x];
                        sim.state.hidden[agent][y][x] = newState.hidden[agent][y][x];
                        sim.state.aliveness[agent][y][x] = newState.aliveness[agent][y][x];
                    }
                }
            } else if (sim.mode === 'block') {
                // Block sequential: update in 4x4 blocks
                const blockSize = 4;
                for (let by = 0; by < gridSize; by += blockSize) {
                    for (let bx = 0; bx < gridSize; bx += blockSize) {
                        // Update this block
                        for (let y = by; y < Math.min(by + blockSize, gridSize); y++) {
                            for (let x = bx; x < Math.min(bx + blockSize, gridSize); x++) {
                                updateCell(sim, newState, y, x);
                            }
                        }
                        // Apply block immediately
                        for (let y = by; y < Math.min(by + blockSize, gridSize); y++) {
                            for (let x = bx; x < Math.min(bx + blockSize, gridSize); x++) {
                                for (let agent = 0; agent <= numAgents; agent++) {
                                    sim.state.attack[agent][y][x] = newState.attack[agent][y][x];
                                    sim.state.defense[agent][y][x] = newState.defense[agent][y][x];
                                    sim.state.hidden[agent][y][x] = newState.hidden[agent][y][x];
                                    sim.state.aliveness[agent][y][x] = newState.aliveness[agent][y][x];
                                }
                            }
                        }
                    }
                }
            }

            if (sim.mode === 'sync') {
                sim.state = newState;
            }
        }

        function renderSimulation(sim) {
            const imageData = sim.ctx.createImageData(gridSize, gridSize);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let maxAlive = 0;
                    let winner = 0;
                    for (let agent = 0; agent <= numAgents; agent++) {
                        if (sim.state.aliveness[agent][y][x] > maxAlive) {
                            maxAlive = sim.state.aliveness[agent][y][x];
                            winner = agent;
                        }
                    }

                    const idx = (y * gridSize + x) * 4;
                    const color = agentColors[winner];
                    const intensity = maxAlive;
                    imageData.data[idx] = color[0] * intensity;
                    imageData.data[idx + 1] = color[1] * intensity;
                    imageData.data[idx + 2] = color[2] * intensity;
                    imageData.data[idx + 3] = 255;
                }
            }

            sim.ctx.putImageData(imageData, 0, 0);
            sim.ctx.imageSmoothingEnabled = false;
            sim.ctx.drawImage(sim.canvas, 0, 0, gridSize, gridSize, 0, 0, sim.canvas.width, sim.canvas.height);
        }

        function getWinner(sim) {
            let territories = [0, 0, 0];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let maxAlive = 0;
                    let winner = 0;
                    for (let agent = 0; agent <= numAgents; agent++) {
                        if (sim.state.aliveness[agent][y][x] > maxAlive) {
                            maxAlive = sim.state.aliveness[agent][y][x];
                            winner = agent;
                        }
                    }
                    territories[winner]++;
                }
            }
            const total = gridSize * gridSize;
            const p1 = (territories[1] / total * 100).toFixed(1);
            const p2 = (territories[2] / total * 100).toFixed(1);
            return `A1:${p1}% A2:${p2}%`;
        }

        function animate() {
            if (!paused) {
                simulations.forEach(sim => {
                    updateSimulation(sim);
                    renderSimulation(sim);
                });
                step++;

                document.getElementById('step').textContent = step;
                document.getElementById('winner1').textContent = getWinner(simulations[0]);
                document.getElementById('winner2').textContent = getWinner(simulations[1]);
                document.getElementById('winner3').textContent = getWinner(simulations[2]);
            }
            requestAnimationFrame(animate);
        }

        function togglePause() {
            paused = !paused;
        }

        function reset() {
            step = 0;
            simulations.forEach(sim => {
                sim.state = createState();
                initSimulation(sim);
                renderSimulation(sim);
            });
        }

        simulations.forEach(sim => {
            initSimulation(sim);
            renderSimulation(sim);
        });
        animate();
    </script>
</body>
</html>
