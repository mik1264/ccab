<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>48. Batch Learning - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        .container {
            text-align: center;
        }
        canvas {
            border: 2px solid #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            background: #000;
        }
        h1 {
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
        }
        .info {
            margin-top: 15px;
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 700px;
            line-height: 1.6;
        }
        .stats {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 30px;
            font-size: 0.95rem;
        }
        .stat {
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }
        .agent-label {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 3px;
            margin-right: 5px;
            vertical-align: middle;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        button {
            padding: 8px 20px;
            font-size: 0.9rem;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
        .slider-control {
            margin-top: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        input[type="range"] {
            width: 200px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ“š Batch Learning</h1>
        <canvas id="canvas"></canvas>
        <div class="stats">
            <div class="stat">
                <span class="agent-label" style="background: #00f5ff;"></span>
                Agent 1: <span id="agent1">0</span>%
            </div>
            <div class="stat">
                <span class="agent-label" style="background: #ff00ff;"></span>
                Agent 2: <span id="agent2">0</span>%
            </div>
            <div class="stat">Step: <span id="step">0</span></div>
            <div class="stat">Batch: <span id="batch">1</span></div>
        </div>
        <div class="slider-control">
            <label>Batch Size:</label>
            <input type="range" id="batchSize" min="1" max="20" value="1" step="1">
            <span id="batchSizeValue">1 (Online)</span>
        </div>
        <div class="controls">
            <button onclick="togglePause()">Pause/Resume</button>
            <button onclick="reset()">Reset</button>
            <button onclick="location.href='index.html'">Back to Gallery</button>
        </div>
        <div class="info">
            <strong>Batch Learning Effect:</strong> Batch size = 1 (online learning) applies updates immediately,
            creating responsive but potentially noisy dynamics. Larger batches accumulate gradients over multiple
            steps before updating, leading to smoother, more stable learning but slower adaptation. This mirrors
            SGD vs mini-batch gradient descent in neural networks. Experiment with the slider to see the tradeoff
            between stability and responsiveness!
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const gridSize = 128;
        const cellSize = 4;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;

        const tau = 0.5;
        const alpha = 0.4;
        const numAgents = 2;

        let batchSize = 1;
        let batchCounter = 0;
        let gradientAccumulator = null;

        let state = {
            attack: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            defense: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            hidden: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            aliveness: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            )
        };

        let step = 0;
        let paused = false;

        const agentColors = [
            [20, 20, 20],
            [0, 245, 255],
            [255, 0, 255]
        ];

        document.getElementById('batchSize').addEventListener('input', (e) => {
            batchSize = parseInt(e.target.value);
            const label = batchSize === 1 ? '1 (Online)' : batchSize === 20 ? '20 (Full Batch)' : batchSize.toString();
            document.getElementById('batchSizeValue').textContent = label;
            batchCounter = 0;
            gradientAccumulator = null;
        });

        function init() {
            // Background
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    state.attack[0][y][x] = Math.random() * 0.2 - 0.1;
                    state.defense[0][y][x] = Math.random() * 0.2 - 0.1;
                    state.hidden[0][y][x] = Math.random() * 0.2 - 0.1;
                    state.aliveness[0][y][x] = 0.3;
                }
            }

            // Agent 1: top-left
            const cx1 = gridSize * 0.3, cy1 = gridSize * 0.3, r1 = 15;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx1) ** 2 + (y - cy1) ** 2);
                    if (dist < r1) {
                        state.attack[1][y][x] = Math.random() * 0.5 + 0.5;
                        state.defense[1][y][x] = Math.random() * 0.5 + 0.5;
                        state.hidden[1][y][x] = Math.random() * 0.5;
                        state.aliveness[1][y][x] = 1.0;
                    }
                }
            }

            // Agent 2: bottom-right
            const cx2 = gridSize * 0.7, cy2 = gridSize * 0.7, r2 = 15;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx2) ** 2 + (y - cy2) ** 2);
                    if (dist < r2) {
                        state.attack[2][y][x] = Math.random() * 0.5 + 0.5;
                        state.defense[2][y][x] = Math.random() * 0.5 + 0.5;
                        state.hidden[2][y][x] = Math.random() * 0.5;
                        state.aliveness[2][y][x] = 1.0;
                    }
                }
            }

            step = 0;
            batchCounter = 0;
            gradientAccumulator = null;
        }

        function computeStrength(attacker, defender, y, x) {
            const a = state.attack[attacker][y][x];
            const d = state.defense[defender][y][x];
            return a * d;
        }

        function update() {
            // Compute gradients
            const gradients = {
                attack: Array(numAgents + 1).fill(null).map(() =>
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ),
                defense: Array(numAgents + 1).fill(null).map(() =>
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                ),
                hidden: Array(numAgents + 1).fill(null).map(() =>
                    Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
                )
            };

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    const deltas = [];
                    for (let agent = 0; agent <= numAgents; agent++) {
                        let avgAttack = 0, avgDefense = 0, avgHidden = 0;
                        let count = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                avgAttack += state.attack[agent][y + dy][x + dx];
                                avgDefense += state.defense[agent][y + dy][x + dx];
                                avgHidden += state.hidden[agent][y + dy][x + dx];
                                count++;
                            }
                        }
                        deltas.push({
                            attack: (avgAttack / count - state.attack[agent][y][x]) * 0.15,
                            defense: (avgDefense / count - state.defense[agent][y][x]) * 0.15,
                            hidden: (avgHidden / count - state.hidden[agent][y][x]) * 0.1
                        });
                    }

                    const strengths = [];
                    for (let i = 0; i <= numAgents; i++) {
                        let totalStrength = 0;
                        for (let j = 0; j <= numAgents; j++) {
                            if (i !== j) {
                                totalStrength += computeStrength(i, j, y, x);
                            }
                        }
                        strengths.push(totalStrength + state.aliveness[i][y][x] * 0.8);
                    }

                    const maxStrength = Math.max(...strengths);
                    const expStrengths = strengths.map(s => Math.exp((s - maxStrength) / tau));
                    const sumExp = expStrengths.reduce((a, b) => a + b, 0);
                    const weights = expStrengths.map(e => e / sumExp);

                    for (let agent = 0; agent <= numAgents; agent++) {
                        const w = weights[agent];
                        gradients.attack[agent][y][x] = deltas[agent].attack * w;
                        gradients.defense[agent][y][x] = deltas[agent].defense * w;
                        gradients.hidden[agent][y][x] = deltas[agent].hidden * w;
                    }
                }
            }

            // Accumulate gradients
            if (gradientAccumulator === null) {
                gradientAccumulator = gradients;
            } else {
                for (let agent = 0; agent <= numAgents; agent++) {
                    for (let y = 0; y < gridSize; y++) {
                        for (let x = 0; x < gridSize; x++) {
                            gradientAccumulator.attack[agent][y][x] += gradients.attack[agent][y][x];
                            gradientAccumulator.defense[agent][y][x] += gradients.defense[agent][y][x];
                            gradientAccumulator.hidden[agent][y][x] += gradients.hidden[agent][y][x];
                        }
                    }
                }
            }

            batchCounter++;

            // Apply gradients when batch is full
            if (batchCounter >= batchSize) {
                const scale = 1.0 / batchSize;
                for (let agent = 0; agent <= numAgents; agent++) {
                    for (let y = 0; y < gridSize; y++) {
                        for (let x = 0; x < gridSize; x++) {
                            state.attack[agent][y][x] = Math.max(-1, Math.min(1,
                                state.attack[agent][y][x] + gradientAccumulator.attack[agent][y][x] * scale
                            ));
                            state.defense[agent][y][x] = Math.max(-1, Math.min(1,
                                state.defense[agent][y][x] + gradientAccumulator.defense[agent][y][x] * scale
                            ));
                            state.hidden[agent][y][x] = Math.max(-1, Math.min(1,
                                state.hidden[agent][y][x] + gradientAccumulator.hidden[agent][y][x] * scale
                            ));
                        }
                    }
                }

                // Reset accumulator
                gradientAccumulator = null;
                batchCounter = 0;
            }

            // Update aliveness independently
            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    const strengths = [];
                    for (let i = 0; i <= numAgents; i++) {
                        let totalStrength = 0;
                        for (let j = 0; j <= numAgents; j++) {
                            if (i !== j) {
                                totalStrength += computeStrength(i, j, y, x);
                            }
                        }
                        strengths.push(totalStrength + state.aliveness[i][y][x] * 0.8);
                    }

                    const maxStrength = Math.max(...strengths);
                    const expStrengths = strengths.map(s => Math.exp((s - maxStrength) / tau));
                    const sumExp = expStrengths.reduce((a, b) => a + b, 0);
                    const weights = expStrengths.map(e => e / sumExp);

                    for (let agent = 0; agent <= numAgents; agent++) {
                        state.aliveness[agent][y][x] = weights[agent];
                    }
                }
            }

            step++;
        }

        function render() {
            const imageData = ctx.createImageData(gridSize, gridSize);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let maxAlive = 0;
                    let winner = 0;
                    for (let agent = 0; agent <= numAgents; agent++) {
                        if (state.aliveness[agent][y][x] > maxAlive) {
                            maxAlive = state.aliveness[agent][y][x];
                            winner = agent;
                        }
                    }

                    const idx = (y * gridSize + x) * 4;
                    const color = agentColors[winner];
                    const intensity = maxAlive;
                    imageData.data[idx] = color[0] * intensity;
                    imageData.data[idx + 1] = color[1] * intensity;
                    imageData.data[idx + 2] = color[2] * intensity;
                    imageData.data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(canvas, 0, 0, gridSize, gridSize, 0, 0, canvas.width, canvas.height);

            updateStats();
        }

        function updateStats() {
            let territories = [0, 0, 0];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let maxAlive = 0;
                    let winner = 0;
                    for (let agent = 0; agent <= numAgents; agent++) {
                        if (state.aliveness[agent][y][x] > maxAlive) {
                            maxAlive = state.aliveness[agent][y][x];
                            winner = agent;
                        }
                    }
                    territories[winner]++;
                }
            }

            const total = gridSize * gridSize;
            document.getElementById('agent1').textContent = ((territories[1] / total) * 100).toFixed(1);
            document.getElementById('agent2').textContent = ((territories[2] / total) * 100).toFixed(1);
            document.getElementById('step').textContent = step;
            document.getElementById('batch').textContent = batchCounter + '/' + batchSize;
        }

        function animate() {
            if (!paused) {
                update();
                render();
            }
            requestAnimationFrame(animate);
        }

        function togglePause() {
            paused = !paused;
        }

        function reset() {
            init();
            render();
        }

        init();
        animate();
    </script>
</body>
</html>
