<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>30. Ecosystem Collapse - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        .container {
            text-align: center;
        }
        canvas {
            border: 2px solid #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            background: #000;
        }
        h1 {
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
        }
        .info {
            margin-top: 15px;
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 600px;
            line-height: 1.6;
        }
        .stats {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 30px;
            font-size: 0.95rem;
            flex-wrap: wrap;
        }
        .stat {
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }
        .agent-label {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 3px;
            margin-right: 5px;
            vertical-align: middle;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 8px 20px;
            font-size: 0.9rem;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ’¥ Ecosystem Collapse</h1>
        <canvas id="canvas"></canvas>
        <div class="stats">
            <div class="stat">
                <span class="agent-label" style="background: #00f5ff;"></span>
                Agent 1: <span id="agent1">0</span>%
            </div>
            <div class="stat">
                <span class="agent-label" style="background: #ff00ff;"></span>
                Agent 2: <span id="agent2">0</span>%
            </div>
            <div class="stat">
                <span class="agent-label" style="background: #00ff88;"></span>
                Agent 3: <span id="agent3">0</span>%
            </div>
            <div class="stat">Step: <span id="step">0</span></div>
            <div class="stat" style="background: rgba(255, 0, 0, 0.1); border-color: rgba(255, 0, 0, 0.3);">
                <span id="event">Stable</span>
            </div>
        </div>
        <div class="controls">
            <button onclick="togglePause()">Pause/Resume</button>
            <button onclick="reset()">Reset</button>
            <button onclick="location.href='index.html'">Back to Gallery</button>
        </div>
        <div class="info">
            Stable 3-agent ecosystem until a catastrophic event (toxic spill) at step 500 disrupts the balance.
            Watch the system maintain equilibrium initially, then observe how the catastrophe cascades through
            the ecosystem. Can any agents survive and rebuild, or does the system collapse entirely?
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const gridSize = 128;
        const cellSize = 4;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;

        const tau = 0.5;
        const alpha = 0.4;
        const numAgents = 3;
        const catastropheStep = 500;

        let toxicZones = Array(gridSize).fill(null).map(() => Array(gridSize).fill(0));

        let state = {
            attack: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            defense: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            hidden: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            aliveness: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            )
        };

        let step = 0;
        let paused = false;

        const agentColors = [
            [0, 245, 255],
            [0, 245, 255],
            [255, 0, 255],
            [0, 255, 136]
        ];

        function triggerCatastrophe() {
            // Toxic spill in center
            const cx = gridSize / 2;
            const cy = gridSize / 2;
            const spillRadius = 35;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                    if (dist < spillRadius) {
                        const toxicity = 1.0 - (dist / spillRadius);
                        toxicZones[y][x] = toxicity;

                        // Damage all agents in toxic zone
                        for (let agent = 1; agent <= numAgents; agent++) {
                            state.aliveness[agent][y][x] *= (1 - toxicity * 0.9);
                            state.attack[agent][y][x] *= (1 - toxicity * 0.7);
                            state.defense[agent][y][x] *= (1 - toxicity * 0.7);
                        }
                    }
                }
            }
        }

        function init() {
            toxicZones = Array(gridSize).fill(null).map(() => Array(gridSize).fill(0));

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    state.attack[0][y][x] = Math.random() * 0.2 - 0.1;
                    state.defense[0][y][x] = Math.random() * 0.2 - 0.1;
                    state.hidden[0][y][x] = Math.random() * 0.2 - 0.1;
                    state.aliveness[0][y][x] = 0.5;
                }
            }

            // Agent 1: top
            const cx1 = gridSize * 0.5, cy1 = gridSize * 0.25, r1 = 14;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx1) ** 2 + (y - cy1) ** 2);
                    if (dist < r1) {
                        state.attack[1][y][x] = Math.random() * 0.5 + 0.5;
                        state.defense[1][y][x] = Math.random() * 0.5 + 0.5;
                        state.hidden[1][y][x] = Math.random() * 0.5;
                        state.aliveness[1][y][x] = 1.0;
                    }
                }
            }

            // Agent 2: bottom-left
            const cx2 = gridSize * 0.25, cy2 = gridSize * 0.75, r2 = 14;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx2) ** 2 + (y - cy2) ** 2);
                    if (dist < r2) {
                        state.attack[2][y][x] = Math.random() * 0.5 + 0.5;
                        state.defense[2][y][x] = Math.random() * 0.5 + 0.5;
                        state.hidden[2][y][x] = Math.random() * 0.5;
                        state.aliveness[2][y][x] = 1.0;
                    }
                }
            }

            // Agent 3: bottom-right
            const cx3 = gridSize * 0.75, cy3 = gridSize * 0.75, r3 = 14;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dist = Math.sqrt((x - cx3) ** 2 + (y - cy3) ** 2);
                    if (dist < r3) {
                        state.attack[3][y][x] = Math.random() * 0.5 + 0.5;
                        state.defense[3][y][x] = Math.random() * 0.5 + 0.5;
                        state.hidden[3][y][x] = Math.random() * 0.5;
                        state.aliveness[3][y][x] = 1.0;
                    }
                }
            }

            step = 0;
        }

        function computeStrength(attacker, defender, y, x) {
            return state.attack[attacker][y][x] * state.defense[defender][y][x];
        }

        function update() {
            // Trigger catastrophe at step 500
            if (step === catastropheStep) {
                triggerCatastrophe();
            }

            const newState = {
                attack: state.attack.map(a => a.map(row => [...row])),
                defense: state.defense.map(d => d.map(row => [...row])),
                hidden: state.hidden.map(h => h.map(row => [...row])),
                aliveness: state.aliveness.map(a => a.map(row => [...row]))
            };

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    const deltas = [];
                    for (let agent = 0; agent <= numAgents; agent++) {
                        let avgAttack = 0, avgDefense = 0, avgHidden = 0;
                        let count = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                avgAttack += state.attack[agent][y + dy][x + dx];
                                avgDefense += state.defense[agent][y + dy][x + dx];
                                avgHidden += state.hidden[agent][y + dy][x + dx];
                                count++;
                            }
                        }
                        deltas.push({
                            attack: (avgAttack / count - state.attack[agent][y][x]) * 0.1,
                            defense: (avgDefense / count - state.defense[agent][y][x]) * 0.1,
                            hidden: (avgHidden / count - state.hidden[agent][y][x]) * 0.1 + Math.random() * 0.05 - 0.025
                        });
                    }

                    const strengths = [];
                    for (let i = 0; i <= numAgents; i++) {
                        let totalStrength = 0;
                        for (let j = 0; j <= numAgents; j++) {
                            if (i !== j) {
                                totalStrength += computeStrength(i, j, y, x);
                            }
                        }
                        // Toxic damage for non-background agents
                        const toxicDamage = (i > 0 && toxicZones[y][x] > 0) ? (1 - toxicZones[y][x] * 0.7) : 1.0;
                        strengths.push((totalStrength + state.aliveness[i][y][x]) * toxicDamage);
                    }

                    const maxStrength = Math.max(...strengths);
                    const expStrengths = strengths.map(s => Math.exp((s - maxStrength) / tau));
                    const sumExp = expStrengths.reduce((a, b) => a + b, 0);
                    const weights = expStrengths.map(e => e / sumExp);

                    for (let agent = 0; agent <= numAgents; agent++) {
                        const w = weights[agent];
                        newState.attack[agent][y][x] = Math.max(-1, Math.min(1,
                            state.attack[agent][y][x] + deltas[agent].attack * w
                        ));
                        newState.defense[agent][y][x] = Math.max(-1, Math.min(1,
                            state.defense[agent][y][x] + deltas[agent].defense * w
                        ));
                        newState.hidden[agent][y][x] = Math.max(-1, Math.min(1,
                            state.hidden[agent][y][x] + deltas[agent].hidden * w
                        ));
                        newState.aliveness[agent][y][x] = w;
                    }
                }
            }

            state = newState;
            step++;

            // Slowly decay toxicity over time
            if (step > catastropheStep) {
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        toxicZones[y][x] *= 0.998;
                    }
                }
            }
        }

        function render() {
            const imageData = ctx.createImageData(gridSize, gridSize);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let maxAlive = 0;
                    let winner = 0;
                    for (let agent = 0; agent <= numAgents; agent++) {
                        if (state.aliveness[agent][y][x] > maxAlive) {
                            maxAlive = state.aliveness[agent][y][x];
                            winner = agent;
                        }
                    }

                    const idx = (y * gridSize + x) * 4;
                    const color = agentColors[winner];
                    const intensity = maxAlive;

                    const toxicity = toxicZones[y][x];
                    imageData.data[idx] = color[0] * intensity * (1 - toxicity * 0.5) + toxicity * 120;
                    imageData.data[idx + 1] = color[1] * intensity * (1 - toxicity * 0.7);
                    imageData.data[idx + 2] = color[2] * intensity * (1 - toxicity * 0.5) + toxicity * 80;
                    imageData.data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(canvas, 0, 0, gridSize, gridSize, 0, 0, canvas.width, canvas.height);

            updateStats();
        }

        function updateStats() {
            let territories = [0, 0, 0, 0];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let maxAlive = 0;
                    let winner = 0;
                    for (let agent = 0; agent <= numAgents; agent++) {
                        if (state.aliveness[agent][y][x] > maxAlive) {
                            maxAlive = state.aliveness[agent][y][x];
                            winner = agent;
                        }
                    }
                    territories[winner]++;
                }
            }

            const total = gridSize * gridSize;
            document.getElementById('agent1').textContent = ((territories[1] / total) * 100).toFixed(1);
            document.getElementById('agent2').textContent = ((territories[2] / total) * 100).toFixed(1);
            document.getElementById('agent3').textContent = ((territories[3] / total) * 100).toFixed(1);
            document.getElementById('step').textContent = step;

            let eventText = 'Stable';
            if (step < catastropheStep) {
                eventText = `Stable (${catastropheStep - step} until catastrophe)`;
            } else if (step === catastropheStep) {
                eventText = 'â˜¢ï¸ TOXIC SPILL!';
            } else if (step < catastropheStep + 100) {
                eventText = 'Recovery Phase';
            } else {
                eventText = 'Post-Collapse';
            }
            document.getElementById('event').textContent = eventText;
        }

        function animate() {
            if (!paused) {
                update();
                render();
            }
            requestAnimationFrame(animate);
        }

        function togglePause() {
            paused = !paused;
        }

        function reset() {
            init();
            render();
        }

        init();
        animate();
    </script>
</body>
</html>
