<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>37. Territorial Waves - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        .container {
            text-align: center;
        }
        canvas {
            border: 2px solid #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            background: #000;
        }
        h1 {
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
        }
        .info {
            margin-top: 15px;
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 600px;
            line-height: 1.6;
        }
        .stats {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 30px;
            font-size: 0.95rem;
            flex-wrap: wrap;
        }
        .stat {
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }
        .agent-label {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 3px;
            margin-right: 5px;
            vertical-align: middle;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 8px 20px;
            font-size: 0.9rem;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.5);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŒŠ Territorial Waves</h1>
        <canvas id="canvas"></canvas>
        <div class="stats">
            <div class="stat">
                <span class="agent-label" style="background: #00f5ff;"></span>
                Agent 1: <span id="agent1">0</span>%
            </div>
            <div class="stat">
                <span class="agent-label" style="background: #ff00ff;"></span>
                Agent 2: <span id="agent2">0</span>%
            </div>
            <div class="stat">Step: <span id="step">0</span></div>
            <div class="stat" style="background: rgba(255, 136, 0, 0.1); border-color: rgba(255, 136, 0, 0.3);">
                Wave Amp: <span id="amplitude">0.00</span>
            </div>
            <div class="stat" style="background: rgba(0, 255, 136, 0.1); border-color: rgba(0, 255, 136, 0.3);">
                Period: <span id="period">0</span>
            </div>
        </div>
        <div class="controls">
            <button onclick="togglePause()">Pause/Resume</button>
            <button onclick="reset()">Reset</button>
            <button onclick="location.href='index.html'">Back to Gallery</button>
        </div>
        <div class="info">
            Periodic traveling waves form at the boundary between two competing agents. Watch as the territorial
            boundary creates rhythmic oscillating patterns that propagate through space. The wave amplitude
            measures boundary fluctuation intensity, while period tracks oscillation frequency.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const gridSize = 128;
        const cellSize = 4;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;

        const tau = 0.5;
        const alpha = 0.4;
        const numAgents = 2;

        let state = {
            attack: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            defense: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            hidden: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            ),
            aliveness: Array(numAgents + 1).fill(null).map(() =>
                Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))
            )
        };

        let step = 0;
        let paused = false;
        let waveAmplitude = 0;
        let wavePeriod = 0;
        let boundaryHistory = [];

        const agentColors = [
            [0, 245, 255],
            [0, 245, 255],
            [255, 0, 255]
        ];

        function init() {
            // Neutral background
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    state.attack[0][y][x] = Math.random() * 0.1 - 0.05;
                    state.defense[0][y][x] = Math.random() * 0.1 - 0.05;
                    state.hidden[0][y][x] = Math.random() * 0.1 - 0.05;
                    state.aliveness[0][y][x] = 0.2;
                }
            }

            // Agent 1: Left half with wave-inducing noise
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize / 2 + 10; x++) {
                    const waveNoise = Math.sin(y * 0.2) * 0.15;
                    state.attack[1][y][x] = Math.random() * 0.3 + 0.4 + waveNoise;
                    state.defense[1][y][x] = Math.random() * 0.3 + 0.4;
                    state.hidden[1][y][x] = Math.random() * 0.3 + waveNoise;
                    state.aliveness[1][y][x] = 0.9;
                }
            }

            // Agent 2: Right half with complementary wave
            for (let y = 0; y < gridSize; y++) {
                for (let x = gridSize / 2 - 10; x < gridSize; x++) {
                    const waveNoise = Math.sin(y * 0.2 + Math.PI) * 0.15;
                    state.attack[2][y][x] = Math.random() * 0.3 + 0.4 + waveNoise;
                    state.defense[2][y][x] = Math.random() * 0.3 + 0.4;
                    state.hidden[2][y][x] = Math.random() * 0.3 + waveNoise;
                    state.aliveness[2][y][x] = 0.9;
                }
            }

            boundaryHistory = [];
            step = 0;
        }

        function computeStrength(attacker, defender, y, x) {
            return state.attack[attacker][y][x] * state.defense[defender][y][x];
        }

        function computeBoundaryPosition() {
            // Find average x-position of boundary for each y
            const boundaryX = [];
            for (let y = 0; y < gridSize; y++) {
                let totalX = 0;
                let count = 0;
                for (let x = 0; x < gridSize; x++) {
                    const a1 = state.aliveness[1][y][x];
                    const a2 = state.aliveness[2][y][x];
                    // Boundary is where both agents are present
                    if (a1 > 0.3 && a2 > 0.3) {
                        totalX += x;
                        count++;
                    }
                }
                boundaryX.push(count > 0 ? totalX / count : gridSize / 2);
            }
            return boundaryX;
        }

        function computeWaveMetrics() {
            const boundary = computeBoundaryPosition();
            boundaryHistory.push(boundary);

            // Keep only last 100 steps
            if (boundaryHistory.length > 100) {
                boundaryHistory.shift();
            }

            if (boundaryHistory.length < 10) {
                return { amplitude: 0, period: 0 };
            }

            // Compute amplitude (spatial variation)
            let amplitude = 0;
            const recent = boundaryHistory[boundaryHistory.length - 1];
            const avgBoundary = recent.reduce((a, b) => a + b, 0) / recent.length;
            for (const bx of recent) {
                amplitude += Math.abs(bx - avgBoundary);
            }
            amplitude /= recent.length;

            // Estimate period (temporal oscillation)
            let period = 0;
            if (boundaryHistory.length >= 50) {
                // Sample middle position over time
                const midY = Math.floor(gridSize / 2);
                const timeSeries = boundaryHistory.map(b => b[midY]);

                // Simple zero-crossing detection
                const mean = timeSeries.reduce((a, b) => a + b, 0) / timeSeries.length;
                let crossings = 0;
                for (let i = 1; i < timeSeries.length; i++) {
                    if ((timeSeries[i - 1] < mean && timeSeries[i] >= mean) ||
                        (timeSeries[i - 1] >= mean && timeSeries[i] < mean)) {
                        crossings++;
                    }
                }
                period = crossings > 0 ? Math.round(timeSeries.length / (crossings / 2)) : 0;
            }

            return { amplitude, period };
        }

        function update() {
            const newState = {
                attack: state.attack.map(a => a.map(row => [...row])),
                defense: state.defense.map(d => d.map(row => [...row])),
                hidden: state.hidden.map(h => h.map(row => [...row])),
                aliveness: state.aliveness.map(a => a.map(row => [...row]))
            };

            for (let y = 1; y < gridSize - 1; y++) {
                for (let x = 1; x < gridSize - 1; x++) {
                    const deltas = [];
                    for (let agent = 0; agent <= numAgents; agent++) {
                        let avgAttack = 0, avgDefense = 0, avgHidden = 0;
                        let count = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                avgAttack += state.attack[agent][y + dy][x + dx];
                                avgDefense += state.defense[agent][y + dy][x + dx];
                                avgHidden += state.hidden[agent][y + dy][x + dx];
                                count++;
                            }
                        }

                        // Add periodic forcing to sustain waves
                        const waveForce = Math.sin(step * 0.1 + y * 0.2) * 0.01;

                        deltas.push({
                            attack: (avgAttack / count - state.attack[agent][y][x]) * 0.1 + waveForce,
                            defense: (avgDefense / count - state.defense[agent][y][x]) * 0.1,
                            hidden: (avgHidden / count - state.hidden[agent][y][x]) * 0.1 + Math.random() * 0.05 - 0.025
                        });
                    }

                    const strengths = [];
                    for (let i = 0; i <= numAgents; i++) {
                        let totalStrength = 0;
                        for (let j = 0; j <= numAgents; j++) {
                            if (i !== j) {
                                totalStrength += computeStrength(i, j, y, x);
                            }
                        }
                        strengths.push(totalStrength + state.aliveness[i][y][x]);
                    }

                    const maxStrength = Math.max(...strengths);
                    const expStrengths = strengths.map(s => Math.exp((s - maxStrength) / tau));
                    const sumExp = expStrengths.reduce((a, b) => a + b, 0);
                    const weights = expStrengths.map(e => e / sumExp);

                    for (let agent = 0; agent <= numAgents; agent++) {
                        const w = weights[agent];
                        newState.attack[agent][y][x] = Math.max(-1, Math.min(1,
                            state.attack[agent][y][x] + deltas[agent].attack * w
                        ));
                        newState.defense[agent][y][x] = Math.max(-1, Math.min(1,
                            state.defense[agent][y][x] + deltas[agent].defense * w
                        ));
                        newState.hidden[agent][y][x] = Math.max(-1, Math.min(1,
                            state.hidden[agent][y][x] + deltas[agent].hidden * w
                        ));
                        newState.aliveness[agent][y][x] = alpha * state.aliveness[agent][y][x] + (1 - alpha) * w;
                    }
                }
            }

            state = newState;

            const metrics = computeWaveMetrics();
            waveAmplitude = metrics.amplitude;
            wavePeriod = metrics.period;

            step++;
        }

        function render() {
            const imageData = ctx.createImageData(gridSize, gridSize);
            const data = imageData.data;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const idx = (y * gridSize + x) * 4;
                    let r = 0, g = 0, b = 0;

                    for (let agent = 0; agent <= numAgents; agent++) {
                        const weight = state.aliveness[agent][y][x];
                        r += agentColors[agent][0] * weight;
                        g += agentColors[agent][1] * weight;
                        b += agentColors[agent][2] * weight;
                    }

                    data[idx] = Math.min(255, r);
                    data[idx + 1] = Math.min(255, g);
                    data[idx + 2] = Math.min(255, b);
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
            ctx.drawImage(canvas, 0, 0, gridSize, gridSize, 0, 0, canvas.width, canvas.height);
        }

        function updateStats() {
            let totals = [0, 0, 0];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    for (let agent = 0; agent <= numAgents; agent++) {
                        totals[agent] += state.aliveness[agent][y][x];
                    }
                }
            }

            const total = totals.reduce((a, b) => a + b, 0);
            document.getElementById('agent1').textContent = ((totals[1] / total) * 100).toFixed(1);
            document.getElementById('agent2').textContent = ((totals[2] / total) * 100).toFixed(1);
            document.getElementById('step').textContent = step;
            document.getElementById('amplitude').textContent = waveAmplitude.toFixed(2);
            document.getElementById('period').textContent = wavePeriod;
        }

        function animate() {
            if (!paused) {
                update();
                render();
                updateStats();
            }
            requestAnimationFrame(animate);
        }

        function togglePause() {
            paused = !paused;
        }

        function reset() {
            init();
        }

        init();
        animate();
    </script>
</body>
</html>
