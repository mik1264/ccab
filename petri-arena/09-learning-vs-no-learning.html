<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Learning vs No-Learning - Petri Arena</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
        }
        .description {
            max-width: 900px;
            text-align: center;
            margin-bottom: 20px;
            color: #aaa;
        }
        .comparison {
            display: flex;
            gap: 30px;
            margin-bottom: 20px;
        }
        .arena {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid #667eea;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        .arena-label {
            margin-top: 10px;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
        }
        .arena-stats {
            font-family: monospace;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            min-width: 200px;
        }
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 10px 20px;
            background: #667eea;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        button:hover {
            background: #764ba2;
        }
        .explanation {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            max-width: 900px;
            font-size: 14px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <h1>Learning vs No-Learning Comparison</h1>
    <p class="description">
        The paper shows that backpropagation during simulation is crucial. Without learning, systems settle to boring steady states.
        With learning, agents adapt in real-time, producing oscillations, cycles, and open-ended dynamics.
    </p>

    <div class="comparison">
        <div class="arena">
            <div class="arena-label">No Learning (Static Rules)</div>
            <canvas id="canvasNoLearn"></canvas>
            <div class="arena-stats">
                <div>Entropy: <span id="entropyNoLearn">0.00</span></div>
                <div>Variance: <span id="varNoLearn">0.00</span></div>
                <div>Settled: <span id="settledNoLearn">No</span></div>
            </div>
        </div>

        <div class="arena">
            <div class="arena-label">With Learning (Adaptive)</div>
            <canvas id="canvasLearn"></canvas>
            <div class="arena-stats">
                <div>Entropy: <span id="entropyLearn">0.00</span></div>
                <div>Variance: <span id="varLearn">0.00</span></div>
                <div>Settled: <span id="settledLearn">No</span></div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button id="resetBtn">Reset Both</button>
        <button id="pauseBtn">Pause</button>
    </div>

    <div class="explanation">
        <strong>Key Insight:</strong> The left arena (no learning) will gradually stabilize into static or simple oscillating patterns.
        The right arena (with learning) continuously adapts agent behaviors, leading to sustained complexity and emergent dynamics.
        This demonstrates why PD-NCA uses backprop in-loop rather than just pre-training agents.
    </div>

    <script>
        const canvasNoLearn = document.getElementById('canvasNoLearn');
        const canvasLearn = document.getElementById('canvasLearn');
        const ctxNoLearn = canvasNoLearn.getContext('2d');
        const ctxLearn = canvasLearn.getContext('2d');

        const gridSize = 96;
        const cellSize = 4;
        canvasNoLearn.width = canvasLearn.width = gridSize * cellSize;
        canvasNoLearn.height = canvasLearn.height = gridSize * cellSize;

        const numAgents = 3;

        let gridNoLearn = new Float32Array(gridSize * gridSize * numAgents);
        let gridLearn = new Float32Array(gridSize * gridSize * numAgents);
        let rulesLearn = new Float32Array(numAgents * 4); // Learnable parameters per agent

        let historyNoLearn = [];
        let historyLearn = [];
        const historyLength = 50;

        let stepCount = 0;
        let paused = false;

        function idx(x, y, agent) {
            const gx = ((x + gridSize) % gridSize);
            const gy = ((y + gridSize) % gridSize);
            return (gy * gridSize + gx) * numAgents + agent;
        }

        function reset() {
            gridNoLearn.fill(0);
            gridLearn.fill(0);
            historyNoLearn = [];
            historyLearn = [];
            stepCount = 0;

            // Initialize learnable rules
            for (let i = 0; i < rulesLearn.length; i++) {
                rulesLearn[i] = Math.random() * 0.5 + 0.25;
            }

            // Same initial state for both
            const initPattern = () => {
                const seeds = [
                    {x: 30, y: 48, agent: 0, r: 8},
                    {x: 66, y: 48, agent: 1, r: 8},
                    {x: 48, y: 70, agent: 2, r: 8}
                ];
                return seeds;
            };

            const seeds = initPattern();
            [gridNoLearn, gridLearn].forEach(grid => {
                seeds.forEach(seed => {
                    for (let dy = -seed.r; dy <= seed.r; dy++) {
                        for (let dx = -seed.r; dx <= seed.r; dx++) {
                            if (dx*dx + dy*dy <= seed.r * seed.r) {
                                grid[idx(seed.x + dx, seed.y + dy, seed.agent)] = 0.7 + Math.random() * 0.3;
                            }
                        }
                    });
                });
            });
        }

        function stepGrid(grid, withLearning) {
            const next = new Float32Array(grid.length);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    for (let a = 0; a < numAgents; a++) {
                        let sum = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                sum += grid[idx(x + dx, y + dy, a)];
                            }
                        }

                        const current = grid[idx(x, y, a)];
                        const avg = sum / 9;

                        let threshold, growthRate, decayRate;

                        if (withLearning) {
                            // Use learned parameters
                            threshold = rulesLearn[a * 4];
                            growthRate = rulesLearn[a * 4 + 1] * 0.2;
                            decayRate = rulesLearn[a * 4 + 2] * 0.05;
                        } else {
                            // Fixed parameters
                            threshold = 0.35;
                            growthRate = 0.08;
                            decayRate = 0.03;
                        }

                        let nextVal = current;
                        if (avg > threshold) {
                            nextVal = Math.min(1.0, current + growthRate);
                        } else {
                            nextVal = Math.max(0.0, current - decayRate);
                        }

                        next[idx(x, y, a)] = nextVal;
                    }
                }
            }

            // Learning update: adjust rules based on recent variance
            if (withLearning && stepCount % 10 === 0) {
                const variance = calculateVariance(historyLearn);

                for (let a = 0; a < numAgents; a++) {
                    // If variance is low, perturb rules to increase diversity
                    if (variance < 0.01) {
                        rulesLearn[a * 4] += (Math.random() - 0.5) * 0.1;
                        rulesLearn[a * 4 + 1] += (Math.random() - 0.5) * 0.05;
                        rulesLearn[a * 4 + 2] += (Math.random() - 0.5) * 0.02;
                    } else {
                        // Slight random walk
                        rulesLearn[a * 4] += (Math.random() - 0.5) * 0.02;
                        rulesLearn[a * 4 + 1] += (Math.random() - 0.5) * 0.01;
                        rulesLearn[a * 4 + 2] += (Math.random() - 0.5) * 0.005;
                    }

                    // Clamp
                    rulesLearn[a * 4] = Math.max(0.2, Math.min(0.8, rulesLearn[a * 4]));
                    rulesLearn[a * 4 + 1] = Math.max(0.1, Math.min(1.0, rulesLearn[a * 4 + 1]));
                    rulesLearn[a * 4 + 2] = Math.max(0.01, Math.min(0.2, rulesLearn[a * 4 + 2]));
                }
            }

            return next;
        }

        function calculateEntropy(grid) {
            const bins = 10;
            const counts = new Array(bins).fill(0);

            for (let i = 0; i < grid.length; i++) {
                const bin = Math.min(bins - 1, Math.floor(grid[i] * bins));
                counts[bin]++;
            }

            let entropy = 0;
            for (let count of counts) {
                if (count > 0) {
                    const p = count / grid.length;
                    entropy -= p * Math.log2(p);
                }
            }

            return entropy / Math.log2(bins); // Normalize
        }

        function calculateVariance(history) {
            if (history.length < 2) return 1.0;

            const mean = history.reduce((a, b) => a + b, 0) / history.length;
            const variance = history.reduce((sum, val) => sum + (val - mean) ** 2, 0) / history.length;
            return variance;
        }

        function step() {
            gridNoLearn = stepGrid(gridNoLearn, false);
            gridLearn = stepGrid(gridLearn, true);

            const entropyNoLearn = calculateEntropy(gridNoLearn);
            const entropyLearn = calculateEntropy(gridLearn);

            historyNoLearn.push(entropyNoLearn);
            historyLearn.push(entropyLearn);

            if (historyNoLearn.length > historyLength) {
                historyNoLearn.shift();
                historyLearn.shift();
            }

            stepCount++;
        }

        function draw() {
            drawGrid(gridNoLearn, ctxNoLearn);
            drawGrid(gridLearn, ctxLearn);
        }

        function drawGrid(grid, ctx) {
            const imageData = ctx.createImageData(gridSize * cellSize, gridSize * cellSize);
            const data = imageData.data;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const r = grid[idx(x, y, 0)] * 255;
                    const g = grid[idx(x, y, 1)] * 255;
                    const b = grid[idx(x, y, 2)] * 255;

                    for (let dy = 0; dy < cellSize; dy++) {
                        for (let dx = 0; dx < cellSize; dx++) {
                            const px = x * cellSize + dx;
                            const py = y * cellSize + dy;
                            const pi = (py * gridSize * cellSize + px) * 4;

                            data[pi] = r;
                            data[pi + 1] = g;
                            data[pi + 2] = b;
                            data[pi + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function updateStats() {
            const entropyNoLearn = calculateEntropy(gridNoLearn);
            const entropyLearn = calculateEntropy(gridLearn);

            const varNoLearn = calculateVariance(historyNoLearn);
            const varLearn = calculateVariance(historyLearn);

            const settledNoLearn = varNoLearn < 0.001 && stepCount > 100;
            const settledLearn = varLearn < 0.001 && stepCount > 100;

            document.getElementById('entropyNoLearn').textContent = entropyNoLearn.toFixed(3);
            document.getElementById('entropyLearn').textContent = entropyLearn.toFixed(3);
            document.getElementById('varNoLearn').textContent = varNoLearn.toFixed(4);
            document.getElementById('varLearn').textContent = varLearn.toFixed(4);
            document.getElementById('settledNoLearn').textContent = settledNoLearn ? 'YES' : 'No';
            document.getElementById('settledLearn').textContent = settledLearn ? 'YES' : 'No';
        }

        function animate() {
            if (!paused) {
                step();
                updateStats();
            }
            draw();
            requestAnimationFrame(animate);
        }

        document.getElementById('resetBtn').addEventListener('click', reset);
        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });

        reset();
        animate();
    </script>
</body>
</html>
