<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1v1 Territorial Duel - Petri Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        h1 {
            font-size: 32px;
            color: #667eea;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 14px;
            color: #b0b0b0;
            margin-bottom: 30px;
        }

        #canvas {
            border: 3px solid #667eea;
            box-shadow: 0 0 30px rgba(102, 126, 234, 0.4);
            margin-bottom: 20px;
        }

        .scoreboard {
            display: flex;
            gap: 40px;
            margin-bottom: 20px;
        }

        .score-panel {
            background: rgba(102, 126, 234, 0.1);
            padding: 20px 40px;
            border-radius: 10px;
            text-align: center;
            min-width: 200px;
        }

        .score-panel h2 {
            font-size: 18px;
            margin-bottom: 10px;
        }

        .score-panel.red h2 {
            color: #ff6b6b;
        }

        .score-panel.blue h2 {
            color: #6b9fff;
        }

        .score {
            font-size: 48px;
            font-weight: bold;
            margin: 10px 0;
        }

        .score-panel.red .score {
            color: #ff6b6b;
        }

        .score-panel.blue .score {
            color: #6b9fff;
        }

        .stat {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .winner-banner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #667eea;
            border-radius: 15px;
            padding: 40px 60px;
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 1000;
        }

        .winner-banner.red {
            border-color: #ff6b6b;
            color: #ff6b6b;
        }

        .winner-banner.blue {
            border-color: #6b9fff;
            color: #6b9fff;
        }

        .info {
            max-width: 600px;
            text-align: center;
            font-size: 12px;
            color: #888;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <h1>‚öîÔ∏è 1v1 Territorial Duel</h1>
    <p class="subtitle">Two agents compete for dominance. First to control 80% of the dish wins!</p>

    <div class="scoreboard">
        <div class="score-panel red">
            <h2>üî¥ Red Agent</h2>
            <div class="score" id="scoreRed">0%</div>
            <div class="stat">Aggressive strategy</div>
        </div>

        <div class="score-panel blue">
            <h2>üîµ Blue Agent</h2>
            <div class="score" id="scoreBlue">0%</div>
            <div class="stat">Defensive strategy</div>
        </div>
    </div>

    <canvas id="canvas" width="600" height="600"></canvas>

    <div class="controls">
        <button id="btnReset">üîÑ New Match</button>
        <button id="btnPlayPause">‚è∏Ô∏è Pause</button>
        <button id="btnSpeed">üöÄ Speed: 1x</button>
    </div>

    <div class="info">
        Watch as the two agents battle for territory using attack and defense strategies.
        The battlefield updates in real-time as agents learn and adapt. Territory changes are driven by
        the PD-NCA competition phase (attack¬∑defense cosine similarity).
    </div>

    <div id="winnerBanner" class="winner-banner"></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const W = 96;
        const H = 96;
        const CELL_SIZE = canvas.width / W;

        let running = true;
        let speed = 1;
        let epoch = 0;
        let winner = null;

        const RED = [255, 107, 107];
        const BLUE = [107, 159, 255];
        const NEUTRAL = [60, 60, 60];

        class DuelNCA {
            constructor() {
                // State: aliveness for 2 agents + environment
                this.aliveness = new Float32Array(W * H * 3);

                // Attack/defense values (simplified)
                this.attack = new Float32Array(W * H * 3);
                this.defense = new Float32Array(W * H * 3);

                // Agent strategies
                this.redWeights = new Float32Array(9).map(() => Math.random() * 0.3 - 0.15);
                this.blueWeights = new Float32Array(9).map(() => Math.random() * 0.3 - 0.15);
                this.envWeights = new Float32Array(9).map(() => Math.random() * 0.1 - 0.05);

                // Red: aggressive (high attack)
                this.redWeights[4] += 0.3; // Center weight

                // Blue: defensive (high defense)
                this.blueWeights[4] += 0.25;

                this.initialize();
            }

            initialize() {
                // Start with vertical split
                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        const idx = (y * W + x) * 3;

                        if (x < W / 2) {
                            // Red territory
                            this.aliveness[idx] = 0.7;
                            this.aliveness[idx + 1] = 0.1;
                            this.aliveness[idx + 2] = 0.2;

                            this.attack[idx] = 0.8;
                            this.defense[idx] = 0.3;
                        } else {
                            // Blue territory
                            this.aliveness[idx] = 0.1;
                            this.aliveness[idx + 1] = 0.7;
                            this.aliveness[idx + 2] = 0.2;

                            this.attack[idx + 1] = 0.5;
                            this.defense[idx + 1] = 0.9;
                        }

                        // Environment
                        this.attack[idx + 2] = 0.2;
                        this.defense[idx + 2] = 0.5;
                    }
                }
            }

            step() {
                const newAlive = new Float32Array(this.aliveness.length);
                const newAttack = new Float32Array(this.attack.length);
                const newDefense = new Float32Array(this.defense.length);

                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        const idx = (y * W + x) * 3;

                        // Process each agent
                        for (let agent = 0; agent < 3; agent++) {
                            const weights = agent === 0 ? this.redWeights :
                                          agent === 1 ? this.blueWeights :
                                          this.envWeights;

                            // Compute neighborhood influence
                            let influence = 0;
                            let wIdx = 0;

                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    const nx = (x + dx + W) % W;
                                    const ny = (y + dy + H) % H;
                                    const nIdx = (ny * W + nx) * 3 + agent;

                                    influence += this.aliveness[nIdx] * weights[wIdx];
                                    wIdx++;
                                }
                            }

                            newAlive[idx + agent] = Math.max(0, Math.tanh(influence) * 0.5 + 0.5);
                        }

                        // Competition phase: attack vs defense
                        const redAttack = this.attack[idx];
                        const blueAttack = this.attack[idx + 1];
                        const redDefense = this.defense[idx];
                        const blueDefense = this.defense[idx + 1];

                        // Strength: attack_i * (1 - defense_j)
                        const redStrength = redAttack * (1 - blueDefense) + 0.1;
                        const blueStrength = blueAttack * (1 - redDefense) + 0.1;
                        const envStrength = 0.2;

                        // Softmax normalization (temperature œÑ = 0.1)
                        const tau = 0.1;
                        const expRed = Math.exp(redStrength / tau);
                        const expBlue = Math.exp(blueStrength / tau);
                        const expEnv = Math.exp(envStrength / tau);
                        const sumExp = expRed + expBlue + expEnv;

                        const weightRed = expRed / sumExp;
                        const weightBlue = expBlue / sumExp;
                        const weightEnv = expEnv / sumExp;

                        // Update aliveness with competition weights
                        newAlive[idx] = newAlive[idx] * weightRed;
                        newAlive[idx + 1] = newAlive[idx + 1] * weightBlue;
                        newAlive[idx + 2] = newAlive[idx + 2] * weightEnv;

                        // Update attack/defense based on local dominance
                        newAttack[idx] = this.attack[idx] + (weightRed - 0.33) * 0.1;
                        newAttack[idx + 1] = this.attack[idx + 1] + (weightBlue - 0.33) * 0.1;

                        newDefense[idx] = this.defense[idx] + (1 - weightRed) * 0.05;
                        newDefense[idx + 1] = this.defense[idx + 1] + (1 - weightBlue) * 0.05;

                        // Clamp
                        for (let a = 0; a < 3; a++) {
                            newAttack[idx + a] = Math.max(0, Math.min(1, newAttack[idx + a]));
                            newDefense[idx + a] = Math.max(0, Math.min(1, newDefense[idx + a]));
                        }
                    }
                }

                this.aliveness = newAlive;
                this.attack = newAttack;
                this.defense = newDefense;
                this.normalize();
            }

            normalize() {
                for (let i = 0; i < W * H; i++) {
                    const idx = i * 3;
                    const sum = this.aliveness[idx] + this.aliveness[idx + 1] + this.aliveness[idx + 2];
                    if (sum > 0) {
                        this.aliveness[idx] /= sum;
                        this.aliveness[idx + 1] /= sum;
                        this.aliveness[idx + 2] /= sum;
                    }
                }
            }

            getScores() {
                let redScore = 0;
                let blueScore = 0;

                for (let i = 0; i < W * H; i++) {
                    redScore += this.aliveness[i * 3];
                    blueScore += this.aliveness[i * 3 + 1];
                }

                return {
                    red: (redScore / (W * H) * 100).toFixed(1),
                    blue: (blueScore / (W * H) * 100).toFixed(1)
                };
            }

            render() {
                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        const idx = (y * W + x) * 3;

                        const r = this.aliveness[idx];
                        const b = this.aliveness[idx + 1];
                        const e = this.aliveness[idx + 2];

                        // Blend colors based on aliveness
                        const color = [
                            RED[0] * r + BLUE[0] * b + NEUTRAL[0] * e,
                            RED[1] * r + BLUE[1] * b + NEUTRAL[1] * e,
                            RED[2] * r + BLUE[2] * b + NEUTRAL[2] * e
                        ];

                        ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
        }

        let nca = new DuelNCA();

        function animate() {
            if (running && !winner) {
                for (let i = 0; i < speed; i++) {
                    nca.step();
                    epoch++;
                }

                const scores = nca.getScores();
                document.getElementById('scoreRed').textContent = scores.red + '%';
                document.getElementById('scoreBlue').textContent = scores.blue + '%';

                // Check for winner
                if (parseFloat(scores.red) >= 80) {
                    winner = 'red';
                    showWinner('Red Agent Wins!', 'red');
                } else if (parseFloat(scores.blue) >= 80) {
                    winner = 'blue';
                    showWinner('Blue Agent Wins!', 'blue');
                }
            }

            nca.render();
            requestAnimationFrame(animate);
        }

        function showWinner(message, color) {
            const banner = document.getElementById('winnerBanner');
            banner.textContent = message;
            banner.className = 'winner-banner ' + color;
            banner.style.display = 'block';

            setTimeout(() => {
                banner.style.display = 'none';
            }, 5000);
        }

        document.getElementById('btnReset').addEventListener('click', () => {
            nca = new DuelNCA();
            epoch = 0;
            winner = null;
            document.getElementById('winnerBanner').style.display = 'none';
        });

        document.getElementById('btnPlayPause').addEventListener('click', function() {
            running = !running;
            this.textContent = running ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
        });

        document.getElementById('btnSpeed').addEventListener('click', function() {
            speed = speed === 1 ? 3 : speed === 3 ? 5 : 1;
            this.textContent = `üöÄ Speed: ${speed}x`;
        });

        animate();
    </script>
</body>
</html>
