<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Percolation Probability Curve - Fire Percolation</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #1a2a6c 0%, #b21f1f 50%, #fdbb2d 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            min-height: 100vh;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .description {
            text-align: center;
            max-width: 900px;
            margin-bottom: 20px;
            line-height: 1.6;
            opacity: 0.9;
        }
        .controls {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            backdrop-filter: blur(10px);
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        input[type="range"] {
            width: 150px;
        }
        button {
            background: #c0392b;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background 0.3s;
        }
        button:hover {
            background: #e74c3c;
        }
        button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }
        .main-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .chart-container {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        canvas {
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            background: white;
        }
        .info-panel {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }
        .info-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }
        .progress-bar {
            width: 100%;
            height: 30px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2ecc71, #27ae60);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Percolation Probability vs Density</h1>
    <div class="description">
        Run multiple simulations across different densities to empirically measure the percolation probability curve.
        Watch as the S-shaped sigmoid curve emerges, showing the sharp phase transition around 59% density.
        Below threshold: nearly 0% crossing. Above threshold: nearly 100% crossing.
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Density Range:</label>
            <div style="display: flex; gap: 10px;">
                <input type="number" id="minDensity" value="40" min="0" max="100" style="width: 60px;">
                to
                <input type="number" id="maxDensity" value="75" min="0" max="100" style="width: 60px;">%
            </div>
        </div>
        <div class="control-group">
            <label>Runs per Density: <span id="runsValue">20</span></label>
            <input type="range" id="runsPerDensity" min="5" max="50" value="20">
        </div>
        <button id="runBtn">Run Experiment</button>
        <button id="clearBtn">Clear Data</button>
    </div>

    <div class="main-container">
        <div class="chart-container">
            <canvas id="chart" width="700" height="500"></canvas>
        </div>

        <div class="info-panel">
            <div class="info-title">Experiment Progress</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress" style="width: 0%;">0%</div>
            </div>
            <div class="stat-row">
                <span>Current Density:</span>
                <span id="currentDensity">-</span>
            </div>
            <div class="stat-row">
                <span>Runs Completed:</span>
                <span id="runsCompleted">0</span>
            </div>
            <div class="stat-row">
                <span>Total Simulations:</span>
                <span id="totalSims">0</span>
            </div>

            <div style="margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 5px; font-size: 0.9em;">
                <strong>Theory:</strong><br><br>
                Percolation probability P(p) follows a sigmoid curve:<br><br>
                • p &lt; p_c: P ≈ 0 (subcritical)<br>
                • p = p_c: P ≈ 0.5 (critical)<br>
                • p &gt; p_c: P ≈ 1 (supercritical)<br><br>
                Critical point p_c ≈ 0.59 for Von Neumann lattice
            </div>
        </div>
    </div>

    <script>
        const chart = document.getElementById('chart');
        const ctx = chart.getContext('2d');

        const runsSlider = document.getElementById('runsPerDensity');
        const runsValue = document.getElementById('runsValue');
        const minDensityInput = document.getElementById('minDensity');
        const maxDensityInput = document.getElementById('maxDensity');

        let data = {}; // density -> {total, crossed}
        let running = false;
        const gridSize = 80;

        function drawChart() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, chart.width, chart.height);

            const margin = {top: 40, right: 40, bottom: 60, left: 60};
            const width = chart.width - margin.left - margin.right;
            const height = chart.height - margin.top - margin.bottom;

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + height);
            ctx.lineTo(margin.left + width, margin.top + height);
            ctx.stroke();

            // Draw grid
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (height * i / 10);
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(margin.left + width, y);
                ctx.stroke();
            }

            // Draw labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Forest Density (%)', margin.left + width / 2, chart.height - 10);

            ctx.save();
            ctx.translate(15, margin.top + height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Percolation Probability', 0, 0);
            ctx.restore();

            // Draw axis labels
            ctx.font = '12px Arial';
            ctx.fillStyle = '#666';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + height - (height * i / 10);
                ctx.fillText((i * 10) + '%', margin.left - 10, y + 4);
            }

            ctx.textAlign = 'center';
            for (let i = 0; i <= 10; i++) {
                const x = margin.left + (width * i / 10);
                const density = (i * 10);
                ctx.fillText(density, x, margin.top + height + 20);
            }

            // Draw critical threshold line
            ctx.strokeStyle = 'rgba(231, 76, 60, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            const criticalX = margin.left + (width * 0.59);
            ctx.beginPath();
            ctx.moveTo(criticalX, margin.top);
            ctx.lineTo(criticalX, margin.top + height);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#e74c3c';
            ctx.font = 'bold 12px Arial';
            ctx.fillText('Critical (59%)', criticalX, margin.top - 10);

            // Plot data points
            const densities = Object.keys(data).map(Number).sort((a, b) => a - b);

            if (densities.length > 0) {
                ctx.fillStyle = '#3498db';

                densities.forEach(density => {
                    const {total, crossed} = data[density];
                    const prob = total > 0 ? crossed / total : 0;

                    const x = margin.left + (width * density / 100);
                    const y = margin.top + height - (height * prob);

                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw curve
                if (densities.length > 1) {
                    ctx.strokeStyle = '#2980b9';
                    ctx.lineWidth = 3;
                    ctx.beginPath();

                    densities.forEach((density, i) => {
                        const {total, crossed} = data[density];
                        const prob = total > 0 ? crossed / total : 0;

                        const x = margin.left + (width * density / 100);
                        const y = margin.top + height - (height * prob);

                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });

                    ctx.stroke();
                }
            }
        }

        function runSimulation(density) {
            return new Promise(resolve => {
                const grid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));

                // Create forest
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        if (Math.random() < density / 100) {
                            grid[y][x] = 1;
                        }
                    }
                }

                // Ignite left edge
                const fires = [];
                for (let y = 0; y < gridSize; y++) {
                    if (grid[y][0] === 1) {
                        grid[y][0] = 2;
                        fires.push({x: 0, y});
                    }
                }

                let reachedEdge = false;
                let currentFires = [...fires];

                // Run simulation
                while (currentFires.length > 0 && !reachedEdge) {
                    const newFires = [];

                    for (const {x, y} of currentFires) {
                        const neighbors = [
                            {x, y: y - 1},
                            {x, y: y + 1},
                            {x: x - 1, y},
                            {x: x + 1, y}
                        ];

                        for (const n of neighbors) {
                            if (n.x >= 0 && n.x < gridSize && n.y >= 0 && n.y < gridSize) {
                                if (grid[n.y][n.x] === 1) {
                                    grid[n.y][n.x] = 2;
                                    newFires.push(n);

                                    if (n.x === gridSize - 1) {
                                        reachedEdge = true;
                                    }
                                }
                            }
                        }
                    }

                    currentFires = newFires;
                }

                resolve(reachedEdge);
            });
        }

        async function runExperiment() {
            if (running) return;
            running = true;

            const minDensity = parseInt(minDensityInput.value);
            const maxDensity = parseInt(maxDensityInput.value);
            const runsPerDensity = parseInt(runsSlider.value);

            document.getElementById('runBtn').disabled = true;

            const densities = [];
            for (let d = minDensity; d <= maxDensity; d += 2) {
                densities.push(d);
            }

            let totalRuns = 0;
            const maxRuns = densities.length * runsPerDensity;

            for (const density of densities) {
                document.getElementById('currentDensity').textContent = density + '%';

                if (!data[density]) {
                    data[density] = {total: 0, crossed: 0};
                }

                for (let run = 0; run < runsPerDensity; run++) {
                    const crossed = await runSimulation(density);

                    data[density].total++;
                    if (crossed) data[density].crossed++;

                    totalRuns++;
                    const progress = (totalRuns / maxRuns * 100).toFixed(0);
                    document.getElementById('progress').style.width = progress + '%';
                    document.getElementById('progress').textContent = progress + '%';
                    document.getElementById('runsCompleted').textContent = totalRuns;
                    document.getElementById('totalSims').textContent = maxRuns;

                    drawChart();

                    await new Promise(r => setTimeout(r, 10));
                }
            }

            running = false;
            document.getElementById('runBtn').disabled = false;
            document.getElementById('currentDensity').textContent = 'Complete';
        }

        function clearData() {
            data = {};
            drawChart();
            document.getElementById('progress').style.width = '0%';
            document.getElementById('progress').textContent = '0%';
            document.getElementById('currentDensity').textContent = '-';
            document.getElementById('runsCompleted').textContent = '0';
            document.getElementById('totalSims').textContent = '0';
        }

        runsSlider.addEventListener('input', (e) => {
            runsValue.textContent = e.target.value;
        });

        document.getElementById('runBtn').addEventListener('click', runExperiment);
        document.getElementById('clearBtn').addEventListener('click', clearData);

        drawChart();
    </script>
</body>
</html>
