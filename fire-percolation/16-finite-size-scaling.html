<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Finite-Size Scaling Effects - Fire Percolation</title>
    <style>
        body {
            margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center;
            background: linear-gradient(135deg, #1e130c 0%, #9a8478 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white; min-height: 100vh;
        }
        h1 {margin: 0 0 10px 0; font-size: 2em; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);}
        .description {text-align: center; max-width: 900px; margin-bottom: 20px; line-height: 1.6; opacity: 0.9;}
        .controls {
            background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px;
            display: flex; gap: 15px; align-items: center; backdrop-filter: blur(10px);
        }
        button {background: #d35400; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;}
        button:hover {background: #e67e22;}
        .grid-container {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; max-width: 1200px;
        }
        .sim-panel {
            background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; backdrop-filter: blur(10px);
            display: flex; flex-direction: column; align-items: center;
        }
        .sim-title {font-weight: bold; margin-bottom: 10px; font-size: 1.1em;}
        canvas {border: 2px solid rgba(255,255,255,0.3); border-radius: 5px; background: black;}
        .stat {font-size: 0.9em; margin-top: 8px;}
    </style>
</head>
<body>
    <h1>Finite-Size Scaling Effects</h1>
    <div class="description">
        Compare percolation behavior across different grid sizes (50×50, 100×100, 200×200) at critical density.
        Critical phenomena become sharper with larger grids. Small grids show more variation; large grids
        reveal true phase transition. Demonstrates finite-size scaling theory.
    </div>

    <div class="controls">
        <button id="runBtn">Run All Grids</button>
        <button id="resetBtn">Reset</button>
        <button id="run10Btn">Run 10 Trials Each</button>
    </div>

    <div class="grid-container" id="container"></div>

    <script>
        const sizes = [50, 100, 200];
        const criticalDensity = 0.59;
        let simulations = [];

        class Simulation {
            constructor(gridSize, index) {
                this.gridSize = gridSize;
                this.cellSize = Math.floor(300 / gridSize);
                this.canvasSize = gridSize * this.cellSize;
                this.index = index;

                const panel = document.createElement('div');
                panel.className = 'sim-panel';

                const title = document.createElement('div');
                title.className = 'sim-title';
                title.textContent = `${gridSize}×${gridSize} Grid`;
                panel.appendChild(title);

                this.canvas = document.createElement('canvas');
                this.canvas.width = this.canvas.height = this.canvasSize;
                this.ctx = this.canvas.getContext('2d');
                panel.appendChild(this.canvas);

                this.stat = document.createElement('div');
                this.stat.className = 'stat';
                panel.appendChild(this.stat);

                document.getElementById('container').appendChild(panel);
                this.reset();
            }

            reset() {
                this.grid = Array(this.gridSize).fill(0).map(() => Array(this.gridSize).fill(0));
                this.fires = [];
                this.ticks = 0;
                this.reachedEdge = false;
                this.finished = false;

                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        if (Math.random() < criticalDensity) this.grid[y][x] = 1;
                    }
                }

                this.stat.textContent = 'Ready';
                this.draw();
            }

            start() {
                for (let y = 0; y < this.gridSize; y++) {
                    if (this.grid[y][0] === 1) {
                        this.grid[y][0] = 2;
                        this.fires.push({x: 0, y});
                    }
                }
            }

            update() {
                if (this.finished || this.fires.length === 0) {
                    if (!this.finished) {
                        this.finished = true;
                        this.stat.textContent = this.reachedEdge ? `✓ CROSSED (${this.ticks} ticks)` : '✗ BLOCKED';
                        this.stat.style.color = this.reachedEdge ? '#2ecc71' : '#e74c3c';
                    }
                    return false;
                }

                const newFires = [];
                for (const {x, y} of this.fires) {
                    [[x,y-1],[x,y+1],[x-1,y],[x+1,y]].forEach(([nx, ny]) => {
                        if (nx >= 0 && nx < this.gridSize && ny >= 0 && ny < this.gridSize && this.grid[ny][nx] === 1) {
                            this.grid[ny][nx] = 2;
                            newFires.push({x: nx, y: ny});
                            if (nx === this.gridSize - 1) this.reachedEdge = true;
                        }
                    });
                    this.grid[y][x] = 0;
                }

                this.fires = newFires;
                this.ticks++;
                return true;
            }

            draw() {
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);

                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        const state = this.grid[y][x];

                        if (state === 1) this.ctx.fillStyle = '#00ff00';
                        else if (state === 2) this.ctx.fillStyle = '#ff0000';
                        else continue;

                        this.ctx.fillRect(x * this.cellSize, y * this.cellSize, this.cellSize, this.cellSize);
                    }
                }
            }
        }

        function init() {
            document.getElementById('container').innerHTML = '';
            simulations = [];
            sizes.forEach((size, i) => {
                simulations.push(new Simulation(size, i));
            });
        }

        function runAll() {
            simulations.forEach(sim => sim.start());

            function animate() {
                let anyActive = false;
                simulations.forEach(sim => {
                    if (sim.update()) anyActive = true;
                    sim.draw();
                });

                if (anyActive) {
                    setTimeout(animate, 20);
                }
            }

            animate();
        }

        async function run10Trials() {
            const results = sizes.map(() => ({total: 0, crossed: 0, avgTicks: []}));

            for (let trial = 0; trial < 10; trial++) {
                simulations.forEach(sim => sim.reset());
                simulations.forEach(sim => sim.start());

                let done = false;
                while (!done) {
                    done = true;
                    simulations.forEach(sim => {
                        if (sim.update()) done = false;
                    });
                    await new Promise(r => setTimeout(r, 5));
                }

                simulations.forEach((sim, i) => {
                    results[i].total++;
                    if (sim.reachedEdge) {
                        results[i].crossed++;
                        results[i].avgTicks.push(sim.ticks);
                    }
                });
            }

            let msg = 'Finite-Size Scaling Results (10 trials each):\n\n';
            results.forEach((r, i) => {
                const successRate = ((r.crossed / r.total) * 100).toFixed(1);
                const avgTicks = r.avgTicks.length > 0 ? (r.avgTicks.reduce((a,b) => a+b, 0) / r.avgTicks.length).toFixed(1) : 'N/A';
                msg += `${sizes[i]}×${sizes[i]}: ${r.crossed}/10 crossed (${successRate}%), avg ${avgTicks} ticks\n`;
            });

            alert(msg);
            init();
        }

        document.getElementById('runBtn').addEventListener('click', runAll);
        document.getElementById('resetBtn').addEventListener('click', init);
        document.getElementById('run10Btn').addEventListener('click', run10Trials);

        init();
    </script>
</body>
</html>
