<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Statistical Ensemble Viewer - Fire Percolation</title>
    <style>
        body {
            margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center;
            background: linear-gradient(135deg, #000428 0%, #004e92 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white; min-height: 100vh;
        }
        h1 {margin: 0 0 10px 0; font-size: 2em; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);}
        .description {text-align: center; max-width: 900px; margin-bottom: 20px; line-height: 1.6; opacity: 0.9;}
        .controls {
            background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px;
            display: flex; gap: 15px; align-items: center; backdrop-filter: blur(10px);
        }
        button {background: #3498db; color: white; border: none; padding: 12px 24px; border-radius: 5px; cursor: pointer;}
        button:hover {background: #2980b9;}
        button:disabled {background: #7f8c8d; cursor: not-allowed;}
        .panel {background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; backdrop-filter: blur(10px);}
        .mini-grid {
            display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin-bottom: 20px;
        }
        .mini-canvas {border: 1px solid rgba(255,255,255,0.3); border-radius: 3px;}
        .chart {background: white; border-radius: 5px;}
        .progress {
            width: 100%; height: 30px; background: rgba(0,0,0,0.3); border-radius: 5px;
            overflow: hidden; margin: 10px 0;
        }
        .progress-fill {
            height: 100%; background: linear-gradient(90deg, #3498db, #2ecc71);
            transition: width 0.3s; display: flex; align-items: center; justify-content: center; font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Statistical Ensemble Viewer</h1>
    <div class="description">
        Run an ensemble of 25 simulations simultaneously to gather statistics. Visualize distribution of outcomes,
        measure percolation probability, and observe stochastic variation. Perfect for understanding phase transition
        as emergent statistical phenomenon.
    </div>

    <div class="controls">
        <div>
            <label>Density: <span id="densityVal">59</span>%</label><br>
            <input type="range" id="density" min="50" max="70" value="59" style="width: 150px;">
        </div>
        <button id="runBtn">Run Ensemble (25)</button>
        <button id="clearBtn">Clear</button>
    </div>

    <div class="panel" style="max-width: 1200px;">
        <div class="progress">
            <div class="progress-fill" id="progress" style="width: 0%;">0/25</div>
        </div>
        <div class="mini-grid" id="grid"></div>
        <canvas id="chart" width="800" height="250" class="chart"></canvas>
    </div>

    <script>
        const chart = document.getElementById('chart');
        const chartCtx = chart.getContext('2d');
        const grid = document.getElementById('grid');

        let density = 0.59;
        const gridSize = 60;
        const canvasSize = 120;
        const numSims = 25;
        let results = [];

        function init() {
            grid.innerHTML = '';
            results = [];
            updateProgress(0);
            drawChart();
        }

        class MiniSim {
            constructor(index) {
                this.index = index;
                this.canvas = document.createElement('canvas');
                this.canvas.className = 'mini-canvas';
                this.canvas.width = canvasSize;
                this.canvas.height = canvasSize;
                this.ctx = this.canvas.getContext('2d');
                this.cellSize = canvasSize / gridSize;

                this.grid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        if (Math.random() < density) this.grid[y][x] = 1;
                    }
                }

                grid.appendChild(this.canvas);
                this.draw();
            }

            async run() {
                let fires = [];
                for (let y = 0; y < gridSize; y++) {
                    if (this.grid[y][0] === 1) {
                        this.grid[y][0] = 2;
                        fires.push({x: 0, y});
                    }
                }

                let reachedEdge = false;
                let ticks = 0;
                let burned = fires.length;

                while (fires.length > 0 && ticks < 200) {
                    const newFires = [];

                    for (const {x, y} of fires) {
                        [[x,y-1],[x,y+1],[x-1,y],[x+1,y]].forEach(([nx, ny]) => {
                            if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && this.grid[ny][nx] === 1) {
                                this.grid[ny][nx] = 2;
                                newFires.push({x: nx, y: ny});
                                burned++;
                                if (nx === gridSize - 1) reachedEdge = true;
                            }
                        });
                        this.grid[y][x] = 0;
                    }

                    fires = newFires;
                    ticks++;

                    if (ticks % 5 === 0) {
                        this.draw();
                        await new Promise(r => setTimeout(r, 10));
                    }
                }

                this.draw();

                // Draw border based on result
                this.ctx.strokeStyle = reachedEdge ? '#2ecc71' : '#e74c3c';
                this.ctx.lineWidth = 3;
                this.ctx.strokeRect(0, 0, canvasSize, canvasSize);

                return {reachedEdge, ticks, burned};
            }

            draw() {
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, canvasSize, canvasSize);

                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        const state = this.grid[y][x];

                        if (state === 1) this.ctx.fillStyle = '#00ff00';
                        else if (state === 2) this.ctx.fillStyle = '#ff0000';
                        else continue;

                        this.ctx.fillRect(
                            x * this.cellSize,
                            y * this.cellSize,
                            this.cellSize,
                            this.cellSize
                        );
                    }
                }
            }
        }

        async function runEnsemble() {
            document.getElementById('runBtn').disabled = true;
            init();

            const sims = Array(numSims).fill(0).map((_, i) => new MiniSim(i));

            for (let i = 0; i < numSims; i++) {
                const result = await sims[i].run();
                results.push(result);
                updateProgress(i + 1);
                drawChart();
            }

            document.getElementById('runBtn').disabled = false;
        }

        function updateProgress(count) {
            const percent = (count / numSims * 100).toFixed(0);
            document.getElementById('progress').style.width = percent + '%';
            document.getElementById('progress').textContent = `${count}/${numSims}`;
        }

        function drawChart() {
            chartCtx.fillStyle = 'white';
            chartCtx.fillRect(0, 0, chart.width, chart.height);

            if (results.length === 0) return;

            const margin = {top: 40, right: 40, bottom: 50, left: 60};
            const width = chart.width - margin.left - margin.right;
            const height = chart.height - margin.top - margin.bottom;

            // Axes
            chartCtx.strokeStyle = '#333';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();
            chartCtx.moveTo(margin.left, margin.top);
            chartCtx.lineTo(margin.left, margin.top + height);
            chartCtx.lineTo(margin.left + width, margin.top + height);
            chartCtx.stroke();

            // Title
            chartCtx.fillStyle = '#333';
            chartCtx.font = 'bold 16px Arial';
            chartCtx.textAlign = 'center';
            chartCtx.fillText('Ensemble Results', chart.width / 2, 25);

            // Stats
            const crossed = results.filter(r => r.reachedEdge).length;
            const successRate = ((crossed / results.length) * 100).toFixed(1);

            chartCtx.font = '14px Arial';
            chartCtx.fillText(
                `${crossed}/${results.length} crossed (${successRate}%) at density ${(density * 100).toFixed(0)}%`,
                chart.width / 2,
                margin.top - 10
            );

            // Bar chart
            const barWidth = width / 2 / 2;
            const crossedHeight = (crossed / results.length) * height;
            const blockedHeight = ((results.length - crossed) / results.length) * height;

            chartCtx.fillStyle = '#2ecc71';
            chartCtx.fillRect(
                margin.left + width / 4 - barWidth / 2,
                margin.top + height - crossedHeight,
                barWidth,
                crossedHeight
            );

            chartCtx.fillStyle = '#e74c3c';
            chartCtx.fillRect(
                margin.left + 3 * width / 4 - barWidth / 2,
                margin.top + height - blockedHeight,
                barWidth,
                blockedHeight
            );

            // Labels
            chartCtx.fillStyle = '#333';
            chartCtx.font = '12px Arial';
            chartCtx.textAlign = 'center';
            chartCtx.fillText('Crossed', margin.left + width / 4, chart.height - 20);
            chartCtx.fillText('Blocked', margin.left + 3 * width / 4, chart.height - 20);

            // Count labels
            chartCtx.font = 'bold 14px Arial';
            chartCtx.fillStyle = 'white';
            if (crossedHeight > 20) {
                chartCtx.fillText(crossed, margin.left + width / 4, margin.top + height - crossedHeight / 2);
            }
            if (blockedHeight > 20) {
                chartCtx.fillText(results.length - crossed, margin.left + 3 * width / 4, margin.top + height - blockedHeight / 2);
            }

            // Y-axis labels
            chartCtx.fillStyle = '#666';
            chartCtx.font = '10px Arial';
            chartCtx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const val = Math.floor(results.length * i / 5);
                const y = margin.top + height - (i / 5 * height);
                chartCtx.fillText(val, margin.left - 10, y + 4);
            }
        }

        document.getElementById('density').addEventListener('input', (e) => {
            document.getElementById('densityVal').textContent = e.target.value;
            density = e.target.value / 100;
        });

        document.getElementById('runBtn').addEventListener('click', runEnsemble);
        document.getElementById('clearBtn').addEventListener('click', init);

        drawChart();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
