<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiple Simultaneous Runs - Fire Percolation</title>
    <style>
        body {
            margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center;
            background: linear-gradient(135deg, #FC466B 0%, #3F5EFB 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white; min-height: 100vh;
        }
        h1 {margin: 0 0 10px 0; font-size: 2em; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);}
        .description {text-align: center; max-width: 900px; margin-bottom: 20px; line-height: 1.6; opacity: 0.9;}
        .controls {
            background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px;
            display: flex; gap: 20px; align-items: center; backdrop-filter: blur(10px);
        }
        button {background: #f39c12; color: white; border: none; padding: 12px 24px; border-radius: 5px; cursor: pointer;}
        button:hover {background: #e67e22;}
        .grid-container {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px; max-width: 1400px;
        }
        .sim-box {
            background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; backdrop-filter: blur(10px);
            display: flex; flex-direction: column; align-items: center;
        }
        .sim-title {font-weight: bold; margin-bottom: 10px;}
        canvas {border: 2px solid rgba(255,255,255,0.3); border-radius: 5px; background: black;}
        .sim-status {margin-top: 10px; text-align: center; font-size: 0.9em;}
    </style>
</head>
<body>
    <h1>Multiple Simultaneous Runs</h1>
    <div class="description">
        Run 9 simulations simultaneously at the same density to visualize stochastic variation.
        At critical threshold (~59%), some runs cross while others are blocked by gaps - demonstrating
        the probabilistic nature of percolation at the phase transition.
    </div>

    <div class="controls">
        <div>
            <label>Density: <span id="densityVal">59</span>%</label><br>
            <input type="range" id="density" min="40" max="80" value="59" style="width: 150px;">
        </div>
        <button id="runBtn">Run All 9</button>
        <button id="resetBtn">Reset</button>
    </div>

    <div class="grid-container" id="container"></div>

    <script>
        const gridSize = 80, cellSize = 3;
        let density = 0.59;
        const numSims = 9;
        let simulations = [];

        class Simulation {
            constructor(index) {
                this.index = index;
                this.grid = [];
                this.fires = [];
                this.ticks = 0;
                this.reachedEdge = false;
                this.finished = false;

                const box = document.createElement('div');
                box.className = 'sim-box';
                const title = document.createElement('div');
                title.className = 'sim-title';
                title.textContent = `Run ${index + 1}`;
                box.appendChild(title);

                this.canvas = document.createElement('canvas');
                this.canvas.width = this.canvas.height = gridSize * cellSize;
                this.ctx = this.canvas.getContext('2d');
                box.appendChild(this.canvas);

                this.status = document.createElement('div');
                this.status.className = 'sim-status';
                box.appendChild(this.status);

                document.getElementById('container').appendChild(box);
                this.reset();
            }

            reset() {
                this.grid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
                this.fires = [];
                this.ticks = 0;
                this.reachedEdge = false;
                this.finished = false;

                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        if (Math.random() < density) this.grid[y][x] = 1;
                    }
                }
                this.status.textContent = 'Ready';
                this.draw();
            }

            start() {
                for (let y = 0; y < gridSize; y++) {
                    if (this.grid[y][0] === 1) {
                        this.grid[y][0] = 2;
                        this.fires.push({x: 0, y});
                    }
                }
            }

            update() {
                if (this.finished || this.fires.length === 0) {
                    if (!this.finished) {
                        this.finished = true;
                        this.status.textContent = this.reachedEdge ? '✓ CROSSED' : '✗ BLOCKED';
                        this.status.style.color = this.reachedEdge ? '#2ecc71' : '#e74c3c';
                    }
                    return false;
                }

                const newFires = [];
                for (const {x, y} of this.fires) {
                    [[x,y-1],[x,y+1],[x-1,y],[x+1,y]].forEach(([nx, ny]) => {
                        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && this.grid[ny][nx] === 1) {
                            this.grid[ny][nx] = 2;
                            newFires.push({x: nx, y: ny});
                            if (nx === gridSize - 1) this.reachedEdge = true;
                        }
                    });
                    this.grid[y][x] = 3;
                }

                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        if (this.grid[y][x] >= 3 && this.grid[y][x] < 15) this.grid[y][x]++;
                        else if (this.grid[y][x] >= 15) this.grid[y][x] = 0;
                    }
                }

                this.fires = newFires;
                this.ticks++;
                this.status.textContent = `Tick ${this.ticks}`;
                return true;
            }

            draw() {
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        const state = this.grid[y][x];
                        if (state === 1) this.ctx.fillStyle = '#00ff00';
                        else if (state === 2) this.ctx.fillStyle = '#ff0000';
                        else if (state >= 3) {
                            const fade = (state - 3) / 12;
                            const intensity = Math.floor(255 * (1 - fade));
                            this.ctx.fillStyle = `rgb(${intensity}, ${intensity * 0.4}, 0)`;
                        } else continue;

                        this.ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }
        }

        function init() {
            document.getElementById('container').innerHTML = '';
            simulations = [];
            for (let i = 0; i < numSims; i++) {
                simulations.push(new Simulation(i));
            }
        }

        function runAll() {
            simulations.forEach(sim => sim.start());

            let frameCount = 0;
            function animate() {
                let anyActive = false;
                if (frameCount++ % 3 === 0) {
                    simulations.forEach(sim => {
                        if (sim.update()) anyActive = true;
                        sim.draw();
                    });
                }

                if (anyActive) requestAnimationFrame(animate);
                else {
                    const crossed = simulations.filter(s => s.reachedEdge).length;
                    setTimeout(() => alert(`Results: ${crossed}/9 runs crossed forest (${(crossed/9*100).toFixed(1)}%)`), 500);
                }
            }
            animate();
        }

        document.getElementById('density').addEventListener('input', (e) => {
            document.getElementById('densityVal').textContent = e.target.value;
            density = e.target.value / 100;
        });

        document.getElementById('runBtn').addEventListener('click', runAll);
        document.getElementById('resetBtn').addEventListener('click', init);

        init();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
