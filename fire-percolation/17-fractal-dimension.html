<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Dimension of Burn Patterns - Fire Percolation</title>
    <style>
        body {
            margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center;
            background: linear-gradient(135deg, #4b79a1 0%, #283e51 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white; min-height: 100vh;
        }
        h1 {margin: 0 0 10px 0; font-size: 2em; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);}
        .description {text-align: center; max-width: 900px; margin-bottom: 20px; line-height: 1.6; opacity: 0.9;}
        .controls {
            background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px;
            display: flex; gap: 15px; align-items: center; backdrop-filter: blur(10px); flex-wrap: wrap; justify-content: center;
        }
        button {background: #9b59b6; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;}
        button:hover {background: #8e44ad;}
        canvas {border: 2px solid rgba(255,255,255,0.3); border-radius: 5px;}
        .panel {background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; backdrop-filter: blur(10px);}
    </style>
</head>
<body>
    <h1>Fractal Dimension of Burn Patterns</h1>
    <div class="description">
        At the critical threshold, burn patterns exhibit fractal geometry - self-similar at all scales.
        Use box-counting method to estimate fractal dimension. D ≈ 91/48 ≈ 1.896 for 2D percolation.
        Below critical: D → 1 (linear). Above: D → 2 (filled). At critical: fractal!
    </div>

    <div class="controls">
        <div>
            <label>Density: <span id="densityVal">59</span>%</label><br>
            <input type="range" id="density" min="50" max="70" value="59" style="width: 150px;">
        </div>
        <button id="runBtn">Run & Analyze</button>
        <button id="resetBtn">Reset</button>
    </div>

    <div style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;">
        <div class="panel">
            <h3 style="margin-top: 0;">Burn Pattern</h3>
            <canvas id="canvas" width="600" height="600" style="background: black;"></canvas>
        </div>
        <div class="panel" style="max-width: 350px;">
            <h3 style="margin-top: 0;">Box-Counting Analysis</h3>
            <canvas id="chart" width="350" height="300" style="background: white;"></canvas>
            <div style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px;">
                <div><strong>Fractal Dimension:</strong> <span id="fractalDim">-</span></div>
                <div><strong>Burned Cells:</strong> <span id="burnedCount">-</span></div>
                <div><strong>Reached Edge:</strong> <span id="reached">-</span></div>
            </div>
            <div style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 5px; font-size: 0.9em;">
                <strong>Theory:</strong><br>
                2D Percolation at p_c:<br>
                D_fractal ≈ 91/48 ≈ 1.896<br>
                Box-counting: log(N) vs log(1/ε)
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const chart = document.getElementById('chart');
        const chartCtx = chart.getContext('2d');

        const gridSize = 150;
        const cellSize = 4;
        let density = 0.59;
        let grid, burnedCells;

        function init() {
            grid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
            burnedCells = new Set();

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (Math.random() < density) grid[y][x] = 1;
                }
            }

            draw();
            chartCtx.fillStyle = 'white';
            chartCtx.fillRect(0, 0, chart.width, chart.height);
        }

        function runSimulation() {
            let fires = [];
            let reachedEdge = false;

            for (let y = 0; y < gridSize; y++) {
                if (grid[y][0] === 1) {
                    grid[y][0] = 2;
                    fires.push({x: 0, y});
                    burnedCells.add(`${0},${y}`);
                }
            }

            while (fires.length > 0) {
                const newFires = [];
                for (const {x, y} of fires) {
                    [[x,y-1],[x,y+1],[x-1,y],[x+1,y]].forEach(([nx, ny]) => {
                        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && grid[ny][nx] === 1) {
                            grid[ny][nx] = 2;
                            newFires.push({x: nx, y: ny});
                            burnedCells.add(`${nx},${ny}`);
                            if (nx === gridSize - 1) reachedEdge = true;
                        }
                    });
                }
                fires = newFires;
            }

            draw();
            analyzeFractalDimension();

            document.getElementById('burnedCount').textContent = burnedCells.size;
            document.getElementById('reached').textContent = reachedEdge ? 'Yes' : 'No';
        }

        function draw() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x] === 1) ctx.fillStyle = '#00ff00';
                    else if (grid[y][x] === 2) ctx.fillStyle = '#ff0000';
                    else continue;

                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }

        function analyzeFractalDimension() {
            if (burnedCells.size === 0) return;

            const boxSizes = [1, 2, 3, 5, 8, 12, 20, 30];
            const counts = [];

            boxSizes.forEach(boxSize => {
                const boxes = new Set();
                burnedCells.forEach(key => {
                    const [x, y] = key.split(',').map(Number);
                    const bx = Math.floor(x / boxSize);
                    const by = Math.floor(y / boxSize);
                    boxes.add(`${bx},${by}`);
                });
                counts.push(boxes.size);
            });

            // Log-log regression
            const logSizes = boxSizes.map(s => Math.log(1 / s));
            const logCounts = counts.map(c => Math.log(c));

            // Simple linear regression
            const n = logSizes.length;
            const sumX = logSizes.reduce((a, b) => a + b, 0);
            const sumY = logCounts.reduce((a, b) => a + b, 0);
            const sumXY = logSizes.reduce((sum, x, i) => sum + x * logCounts[i], 0);
            const sumX2 = logSizes.reduce((sum, x) => sum + x * x, 0);

            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            document.getElementById('fractalDim').textContent = slope.toFixed(3);

            // Draw chart
            chartCtx.fillStyle = 'white';
            chartCtx.fillRect(0, 0, chart.width, chart.height);

            const margin = {top: 30, right: 30, bottom: 50, left: 50};
            const width = chart.width - margin.left - margin.right;
            const height = chart.height - margin.top - margin.bottom;

            // Axes
            chartCtx.strokeStyle = '#333';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();
            chartCtx.moveTo(margin.left, margin.top);
            chartCtx.lineTo(margin.left, margin.top + height);
            chartCtx.lineTo(margin.left + width, margin.top + height);
            chartCtx.stroke();

            // Labels
            chartCtx.fillStyle = '#333';
            chartCtx.font = 'bold 12px Arial';
            chartCtx.textAlign = 'center';
            chartCtx.fillText('log(1/ε)', margin.left + width / 2, chart.height - 10);

            chartCtx.save();
            chartCtx.translate(15, margin.top + height / 2);
            chartCtx.rotate(-Math.PI / 2);
            chartCtx.fillText('log(N)', 0, 0);
            chartCtx.restore();

            // Plot points
            const xRange = [Math.min(...logSizes), Math.max(...logSizes)];
            const yRange = [Math.min(...logCounts), Math.max(...logCounts)];

            chartCtx.fillStyle = '#3498db';
            logSizes.forEach((x, i) => {
                const px = margin.left + ((x - xRange[0]) / (xRange[1] - xRange[0])) * width;
                const py = margin.top + height - ((logCounts[i] - yRange[0]) / (yRange[1] - yRange[0])) * height;

                chartCtx.beginPath();
                chartCtx.arc(px, py, 4, 0, Math.PI * 2);
                chartCtx.fill();
            });

            // Fit line
            chartCtx.strokeStyle = '#e74c3c';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();
            const x1 = xRange[0];
            const y1 = slope * x1 + intercept;
            const x2 = xRange[1];
            const y2 = slope * x2 + intercept;

            const px1 = margin.left + ((x1 - xRange[0]) / (xRange[1] - xRange[0])) * width;
            const py1 = margin.top + height - ((y1 - yRange[0]) / (yRange[1] - yRange[0])) * height;
            const px2 = margin.left + ((x2 - xRange[0]) / (xRange[1] - xRange[0])) * width;
            const py2 = margin.top + height - ((y2 - yRange[0]) / (yRange[1] - yRange[0])) * height;

            chartCtx.moveTo(px1, py1);
            chartCtx.lineTo(px2, py2);
            chartCtx.stroke();

            chartCtx.fillStyle = '#e74c3c';
            chartCtx.font = '12px Arial';
            chartCtx.fillText(`D = ${slope.toFixed(3)}`, margin.left + width - 50, margin.top + 20);
        }

        document.getElementById('density').addEventListener('input', (e) => {
            document.getElementById('densityVal').textContent = e.target.value;
            density = e.target.value / 100;
        });

        document.getElementById('runBtn').addEventListener('click', () => {
            init();
            runSimulation();
        });

        document.getElementById('resetBtn').addEventListener('click', init);

        init();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
