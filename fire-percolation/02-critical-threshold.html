<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Critical Threshold Explorer - Fire Percolation</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            min-height: 100vh;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .description {
            text-align: center;
            max-width: 900px;
            margin-bottom: 20px;
            line-height: 1.6;
            opacity: 0.9;
        }
        .controls {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
            backdrop-filter: blur(10px);
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        input[type="range"] {
            width: 200px;
        }
        button {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background 0.3s;
        }
        button:hover {
            background: #c0392b;
        }
        .comparison-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .simulation-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        .simulation-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        canvas {
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            background: black;
        }
        .sim-stats {
            margin-top: 10px;
            font-size: 0.9em;
            text-align: center;
        }
        .critical-indicator {
            font-size: 1.5em;
            margin-top: 5px;
            font-weight: bold;
        }
        .reached {
            color: #2ecc71;
        }
        .not-reached {
            color: #e74c3c;
        }
    </style>
</head>
<body>
    <h1>Critical Threshold Explorer (59%)</h1>
    <div class="description">
        Explore the critical percolation threshold at 59% forest density. At this critical point,
        approximately 50% of runs will have fire reach the right edge. Below threshold: isolated clusters.
        Above threshold: spanning clusters. Run multiple times to see the phase transition!
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Center Density: <span id="densityValue">59</span>%</label>
            <input type="range" id="density" min="50" max="70" value="59" step="1">
        </div>
        <div class="control-group">
            <label>Spread (±): <span id="spreadValue">3</span>%</label>
            <input type="range" id="spread" min="1" max="10" value="3">
        </div>
        <button id="runBtn">Run All Simulations</button>
        <button id="runMultipleBtn">Run 10 Times</button>
    </div>

    <div class="comparison-container" id="container"></div>

    <script>
        const densitySlider = document.getElementById('density');
        const densityValue = document.getElementById('densityValue');
        const spreadSlider = document.getElementById('spread');
        const spreadValue = document.getElementById('spreadValue');
        const runBtn = document.getElementById('runBtn');
        const runMultipleBtn = document.getElementById('runMultipleBtn');
        const container = document.getElementById('container');

        let centerDensity = 59;
        let spread = 3;
        const gridSize = 120;
        const cellSize = 3;
        const canvasSize = gridSize * cellSize;

        let simulations = [];
        let running = false;
        let multipleRunStats = {total: 0, reached: 0};

        class Simulation {
            constructor(density, index) {
                this.density = density;
                this.index = index;
                this.grid = [];
                this.fires = [];
                this.totalTrees = 0;
                this.burnedTrees = 0;
                this.tickCount = 0;
                this.reachedEdge = false;
                this.finished = false;

                this.createDOM();
                this.initGrid();
            }

            createDOM() {
                const box = document.createElement('div');
                box.className = 'simulation-box';

                const title = document.createElement('div');
                title.className = 'simulation-title';
                title.textContent = `${this.density.toFixed(1)}% Density`;
                box.appendChild(title);

                this.canvas = document.createElement('canvas');
                this.canvas.width = canvasSize;
                this.canvas.height = canvasSize;
                this.ctx = this.canvas.getContext('2d');
                box.appendChild(this.canvas);

                this.statsDiv = document.createElement('div');
                this.statsDiv.className = 'sim-stats';
                box.appendChild(this.statsDiv);

                this.indicatorDiv = document.createElement('div');
                this.indicatorDiv.className = 'critical-indicator';
                box.appendChild(this.indicatorDiv);

                container.appendChild(box);
            }

            initGrid() {
                this.grid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
                this.fires = [];
                this.totalTrees = 0;
                this.burnedTrees = 0;
                this.tickCount = 0;
                this.reachedEdge = false;
                this.finished = false;

                // Create forest
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        if (Math.random() < this.density / 100) {
                            this.grid[y][x] = 1;
                            this.totalTrees++;
                        }
                    }
                }

                // Ignite left edge
                for (let y = 0; y < gridSize; y++) {
                    if (this.grid[y][0] === 1) {
                        this.grid[y][0] = 2;
                        this.fires.push({x: 0, y: y});
                        this.burnedTrees++;
                    }
                }

                this.updateStats();
                this.draw();
            }

            update() {
                if (this.finished || this.fires.length === 0) {
                    if (!this.finished) {
                        this.finished = true;
                        this.updateStats();
                    }
                    return false;
                }

                const newFires = [];

                for (const fire of this.fires) {
                    const {x, y} = fire;

                    const neighbors = [
                        {x: x, y: y - 1},
                        {x: x, y: y + 1},
                        {x: x - 1, y: y},
                        {x: x + 1, y: y}
                    ];

                    for (const n of neighbors) {
                        if (n.x >= 0 && n.x < gridSize && n.y >= 0 && n.y < gridSize) {
                            if (this.grid[n.y][n.x] === 1) {
                                this.grid[n.y][n.x] = 2;
                                newFires.push({x: n.x, y: n.y});
                                this.burnedTrees++;

                                if (n.x === gridSize - 1) {
                                    this.reachedEdge = true;
                                }
                            }
                        }
                    }

                    this.grid[y][x] = 3;
                }

                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        if (this.grid[y][x] >= 3 && this.grid[y][x] < 15) {
                            this.grid[y][x]++;
                        } else if (this.grid[y][x] >= 15) {
                            this.grid[y][x] = 0;
                        }
                    }
                }

                this.fires = newFires;
                this.tickCount++;
                this.updateStats();

                return true;
            }

            draw() {
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, canvasSize, canvasSize);

                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        const state = this.grid[y][x];

                        if (state === 1) {
                            this.ctx.fillStyle = '#00ff00';
                        } else if (state === 2) {
                            this.ctx.fillStyle = '#ff0000';
                        } else if (state >= 3) {
                            const fade = (state - 3) / 12;
                            const intensity = Math.floor(255 * (1 - fade));
                            this.ctx.fillStyle = `rgb(${intensity}, ${intensity * 0.3}, 0)`;
                        } else {
                            continue;
                        }

                        this.ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }

            updateStats() {
                const percent = this.totalTrees > 0 ? ((this.burnedTrees / this.totalTrees) * 100).toFixed(1) : 0;
                this.statsDiv.innerHTML = `
                    Burned: ${this.burnedTrees}/${this.totalTrees} (${percent}%)<br>
                    Ticks: ${this.tickCount}
                `;

                if (this.finished) {
                    this.indicatorDiv.textContent = this.reachedEdge ? '✓ CROSSED' : '✗ BLOCKED';
                    this.indicatorDiv.className = 'critical-indicator ' + (this.reachedEdge ? 'reached' : 'not-reached');
                }
            }
        }

        function createSimulations() {
            container.innerHTML = '';
            simulations = [];

            const densities = [
                centerDensity - spread,
                centerDensity,
                centerDensity + spread
            ];

            densities.forEach((d, i) => {
                simulations.push(new Simulation(d, i));
            });
        }

        function runSimulations() {
            if (running) return;
            running = true;
            runBtn.disabled = true;
            runMultipleBtn.disabled = true;

            let tickCount = 0;
            const maxTicks = 300;

            function tick() {
                let anyActive = false;

                simulations.forEach(sim => {
                    if (sim.update()) {
                        anyActive = true;
                        sim.draw();
                    }
                });

                tickCount++;

                if (anyActive && tickCount < maxTicks) {
                    setTimeout(tick, 50);
                } else {
                    running = false;
                    runBtn.disabled = false;
                    runMultipleBtn.disabled = false;
                }
            }

            tick();
        }

        function runMultipleTimes() {
            let runsCompleted = 0;
            const totalRuns = 10;
            multipleRunStats = {total: 0, reached: 0};

            function runOnce() {
                createSimulations();

                let tickCount = 0;
                const maxTicks = 300;

                function tick() {
                    let anyActive = false;

                    simulations.forEach(sim => {
                        if (sim.update()) {
                            anyActive = true;
                        }
                    });

                    tickCount++;

                    if (anyActive && tickCount < maxTicks) {
                        setTimeout(tick, 10);
                    } else {
                        // Record center simulation (critical point)
                        const centerSim = simulations[1];
                        multipleRunStats.total++;
                        if (centerSim.reachedEdge) {
                            multipleRunStats.reached++;
                        }

                        runsCompleted++;
                        if (runsCompleted < totalRuns) {
                            setTimeout(runOnce, 100);
                        } else {
                            const successRate = ((multipleRunStats.reached / multipleRunStats.total) * 100).toFixed(1);
                            alert(`Critical Point (${centerDensity}%) Results:\n${multipleRunStats.reached}/${multipleRunStats.total} runs crossed (${successRate}%)\n\nExpected: ~50% at true critical threshold`);
                            runMultipleBtn.disabled = false;
                            createSimulations();
                        }
                    }
                }

                tick();
            }

            runMultipleBtn.disabled = true;
            runOnce();
        }

        densitySlider.addEventListener('input', (e) => {
            centerDensity = parseInt(e.target.value);
            densityValue.textContent = centerDensity;
        });

        spreadSlider.addEventListener('input', (e) => {
            spread = parseInt(e.target.value);
            spreadValue.textContent = spread;
        });

        runBtn.addEventListener('click', () => {
            createSimulations();
            runSimulations();
        });

        runMultipleBtn.addEventListener('click', runMultipleTimes);

        // Initialize
        createSimulations();
    </script>
</body>
</html>
