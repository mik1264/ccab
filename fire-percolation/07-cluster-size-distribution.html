<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cluster Size Distribution - Fire Percolation</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #232526 0%, #414345 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            min-height: 100vh;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .description {
            text-align: center;
            max-width: 900px;
            margin-bottom: 20px;
            line-height: 1.6;
            opacity: 0.9;
        }
        .controls {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
            backdrop-filter: blur(10px);
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        input[type="range"] {
            width: 150px;
        }
        button {
            background: #27ae60;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background 0.3s;
        }
        button:hover {
            background: #2ecc71;
        }
        .main-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .panel {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        canvas {
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 5px;
        }
        .stats-panel {
            max-width: 300px;
        }
        .stat-item {
            padding: 10px;
            margin: 10px 0;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
        }
        .stat-label {
            opacity: 0.8;
            font-size: 0.9em;
        }
        .stat-value {
            font-size: 1.3em;
            font-weight: bold;
            margin-top: 5px;
        }
        .cluster-legend {
            margin-top: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .color-box {
            width: 25px;
            height: 25px;
            margin-right: 10px;
            border: 1px solid rgba(255,255,255,0.5);
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>Cluster Size Distribution Analysis</h1>
    <div class="description">
        Visualize all connected tree clusters before ignition. Each cluster is colored uniquely. The largest
        cluster determines if fire can percolate. Near critical threshold (~59%), largest cluster size
        shows power-law distribution. Below threshold: small isolated clusters. Above: one giant spanning cluster.
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Forest Density: <span id="densityValue">59</span>%</label>
            <input type="range" id="density" min="30" max="90" value="59">
        </div>
        <div class="control-group">
            <label>Grid Size: <span id="sizeValue">120</span></label>
            <input type="range" id="gridSize" min="80" max="150" value="120">
        </div>
        <button id="analyzeBtn">Analyze Clusters</button>
        <button id="burnBtn" disabled>Burn Largest Cluster</button>
    </div>

    <div class="main-container">
        <div class="panel">
            <canvas id="canvas"></canvas>
        </div>

        <div class="panel stats-panel">
            <h3>Cluster Statistics</h3>
            <div class="stat-item">
                <div class="stat-label">Total Clusters</div>
                <div class="stat-value" id="clusterCount">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Largest Cluster</div>
                <div class="stat-value" id="largestSize">0 trees</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Spans Left-Right</div>
                <div class="stat-value" id="spanStatus">No</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Avg Cluster Size</div>
                <div class="stat-value" id="avgSize">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Total Trees</div>
                <div class="stat-value" id="totalTrees">0</div>
            </div>

            <div class="cluster-legend">
                <strong>Top 5 Clusters:</strong>
                <div id="legendContainer"></div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const densitySlider = document.getElementById('density');
        const densityValue = document.getElementById('densityValue');
        const sizeSlider = document.getElementById('gridSize');
        const sizeValue = document.getElementById('sizeValue');

        let gridSize = 120;
        let cellSize = 4;
        let density = 0.59;

        let grid = [];
        let clusters = [];
        let clusterMap = [];
        let largestCluster = null;

        function initCanvas() {
            const canvasSize = gridSize * cellSize;
            canvas.width = canvasSize;
            canvas.height = canvasSize;
        }

        function generateForest() {
            grid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
            clusterMap = Array(gridSize).fill(0).map(() => Array(gridSize).fill(-1));

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (Math.random() < density) {
                        grid[y][x] = 1;
                    }
                }
            }

            drawForest();
        }

        function findClusters() {
            clusters = [];
            let clusterID = 0;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x] === 1 && clusterMap[y][x] === -1) {
                        const cluster = floodFill(x, y, clusterID);
                        clusters.push(cluster);
                        clusterID++;
                    }
                }
            }

            // Sort by size
            clusters.sort((a, b) => b.size - a.size);

            // Check if largest cluster spans
            if (clusters.length > 0) {
                largestCluster = clusters[0];
                const leftmost = Math.min(...largestCluster.cells.map(c => c.x));
                const rightmost = Math.max(...largestCluster.cells.map(c => c.x));
                largestCluster.spans = (leftmost === 0 && rightmost === gridSize - 1);
            }

            updateStats();
            drawClusters();
        }

        function floodFill(startX, startY, clusterID) {
            const queue = [{x: startX, y: startY}];
            const cells = [];
            clusterMap[startY][startX] = clusterID;

            while (queue.length > 0) {
                const {x, y} = queue.shift();
                cells.push({x, y});

                const neighbors = [
                    {x, y: y - 1},
                    {x, y: y + 1},
                    {x: x - 1, y},
                    {x: x + 1, y}
                ];

                for (const n of neighbors) {
                    if (n.x >= 0 && n.x < gridSize && n.y >= 0 && n.y < gridSize) {
                        if (grid[n.y][n.x] === 1 && clusterMap[n.y][n.x] === -1) {
                            clusterMap[n.y][n.x] = clusterID;
                            queue.push(n);
                        }
                    }
                }
            }

            return {
                id: clusterID,
                size: cells.length,
                cells: cells,
                color: `hsl(${(clusterID * 137) % 360}, 70%, 60%)`,
                spans: false
            };
        }

        function drawForest() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x] === 1) {
                        ctx.fillStyle = '#00ff00';
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }
        }

        function drawClusters() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (const cluster of clusters) {
                ctx.fillStyle = cluster.color;
                for (const {x, y} of cluster.cells) {
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }

            // Highlight largest cluster
            if (largestCluster) {
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                for (const {x, y} of largestCluster.cells) {
                    ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }

        function updateStats() {
            const totalTrees = clusters.reduce((sum, c) => sum + c.size, 0);

            document.getElementById('clusterCount').textContent = clusters.length;
            document.getElementById('totalTrees').textContent = totalTrees;

            if (clusters.length > 0) {
                document.getElementById('largestSize').textContent = largestCluster.size + ' trees';
                document.getElementById('spanStatus').textContent = largestCluster.spans ? 'Yes ✓' : 'No ✗';
                document.getElementById('spanStatus').style.color = largestCluster.spans ? '#2ecc71' : '#e74c3c';

                const avgSize = (totalTrees / clusters.length).toFixed(1);
                document.getElementById('avgSize').textContent = avgSize;

                document.getElementById('burnBtn').disabled = false;
            } else {
                document.getElementById('largestSize').textContent = '0 trees';
                document.getElementById('spanStatus').textContent = 'N/A';
                document.getElementById('avgSize').textContent = '0';
                document.getElementById('burnBtn').disabled = true;
            }

            // Update legend
            const legendContainer = document.getElementById('legendContainer');
            legendContainer.innerHTML = '';

            clusters.slice(0, 5).forEach((cluster, i) => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="color-box" style="background: ${cluster.color};"></div>
                    <div>${i + 1}. ${cluster.size} trees${cluster.spans ? ' (spans)' : ''}</div>
                `;
                legendContainer.appendChild(item);
            });
        }

        function burnLargestCluster() {
            if (!largestCluster) return;

            // Find leftmost cells in largest cluster
            const leftmost = largestCluster.cells.filter(c => c.x === 0);

            if (leftmost.length === 0) {
                alert('Largest cluster does not touch left edge - fire cannot start!');
                return;
            }

            // Simulate fire spread
            let fires = leftmost.map(c => ({...c}));
            const burned = new Set(leftmost.map(c => `${c.x},${c.y}`));

            function tick() {
                if (fires.length === 0) return;

                const newFires = [];

                for (const {x, y} of fires) {
                    const neighbors = [
                        {x, y: y - 1},
                        {x, y: y + 1},
                        {x: x - 1, y},
                        {x: x + 1, y}
                    ];

                    for (const n of neighbors) {
                        const key = `${n.x},${n.y}`;
                        if (n.x >= 0 && n.x < gridSize && n.y >= 0 && n.y < gridSize) {
                            if (clusterMap[n.y][n.x] === largestCluster.id && !burned.has(key)) {
                                burned.add(key);
                                newFires.push(n);
                            }
                        }
                    }

                    // Draw burned cell
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }

                fires = newFires;

                if (fires.length > 0) {
                    setTimeout(tick, 30);
                }
            }

            tick();
        }

        densitySlider.addEventListener('input', (e) => {
            densityValue.textContent = e.target.value;
            density = e.target.value / 100;
        });

        sizeSlider.addEventListener('input', (e) => {
            sizeValue.textContent = e.target.value;
            gridSize = parseInt(e.target.value);
            initCanvas();
            generateForest();
        });

        document.getElementById('analyzeBtn').addEventListener('click', findClusters);
        document.getElementById('burnBtn').addEventListener('click', burnLargestCluster);

        initCanvas();
        generateForest();
    </script>
</body>
</html>
