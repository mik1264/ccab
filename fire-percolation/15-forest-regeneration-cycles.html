<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forest Regeneration Cycles - Fire Percolation</title>
    <style>
        body {
            margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center;
            background: linear-gradient(135deg, #52c234 0%, #061700 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white; min-height: 100vh;
        }
        h1 {margin: 0 0 10px 0; font-size: 2em; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);}
        .description {text-align: center; max-width: 900px; margin-bottom: 20px; line-height: 1.6; opacity: 0.9;}
        .controls {
            background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px;
            display: flex; gap: 15px; align-items: center; backdrop-filter: blur(10px); flex-wrap: wrap; justify-content: center;
        }
        button {background: #27ae60; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;}
        button:hover {background: #2ecc71;}
        canvas {border: 2px solid rgba(255,255,255,0.3); border-radius: 5px; background: black;}
        .panel {background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; backdrop-filter: blur(10px);}
        .chart {background: white; border-radius: 5px;}
    </style>
</head>
<body>
    <h1>Forest Regeneration Cycles</h1>
    <div class="description">
        Continuous fire-regrowth cycles! After fire burns out, burned areas regenerate new trees probabilistically.
        Watch cycles of burning and regrowth, creating dynamic equilibrium. Track forest coverage and burn
        statistics over multiple fire events.
    </div>

    <div class="controls">
        <div>
            <label>Growth Rate: <span id="growthVal">5</span>%</label><br>
            <input type="range" id="growth" min="1" max="20" value="5" style="width: 150px;">
        </div>
        <div>
            <label>Ignition Prob: <span id="ignitionVal">1</span>%</label><br>
            <input type="range" id="ignition" min="1" max="10" value="1" style="width: 150px;">
        </div>
        <button id="startBtn">Start Cycles</button>
        <button id="pauseBtn">Pause</button>
        <button id="resetBtn">Reset</button>
    </div>

    <div style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;">
        <div class="panel">
            <canvas id="canvas"></canvas>
        </div>
        <div class="panel" style="max-width: 300px;">
            <h3 style="margin-top: 0;">Statistics</h3>
            <div style="padding: 8px; margin: 5px 0; background: rgba(0,0,0,0.3); border-radius: 5px;">
                <div>Cycle: <strong id="cycle">0</strong></div>
                <div>Trees: <strong id="trees">0</strong></div>
                <div>Coverage: <strong id="coverage">0</strong>%</div>
                <div>Active Fires: <strong id="fires">0</strong></div>
            </div>
            <canvas id="chart" width="260" height="200" class="chart"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const chart = document.getElementById('chart');
        const chartCtx = chart.getContext('2d');

        const gridSize = 150, cellSize = 4;
        canvas.width = canvas.height = gridSize * cellSize;

        let growthRate = 0.05, ignitionProb = 0.01;
        let grid = [], fires = [];
        let running = false, paused = false;
        let cycle = 0;
        let history = [];

        function init() {
            grid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
            fires = [];
            cycle = 0;
            history = [];

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (Math.random() < 0.5) grid[y][x] = 1;
                }
            }

            updateStats();
            draw();
            drawChart();
        }

        function start() {
            running = true;
            paused = false;
        }

        function update() {
            if (!running || paused) return;

            // Growth phase
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x] === 0 && Math.random() < growthRate / 100) {
                        grid[y][x] = 1;
                    }
                }
            }

            // Random ignition
            if (fires.length === 0 && Math.random() < ignitionProb / 100) {
                for (let i = 0; i < 3; i++) {
                    const x = Math.floor(Math.random() * gridSize);
                    const y = Math.floor(Math.random() * gridSize);
                    if (grid[y][x] === 1) {
                        grid[y][x] = 2;
                        fires.push({x, y});
                        cycle++;
                    }
                }
            }

            // Fire spread
            if (fires.length > 0) {
                const newFires = [];
                for (const {x, y} of fires) {
                    [[x,y-1],[x,y+1],[x-1,y],[x+1,y]].forEach(([nx, ny]) => {
                        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && grid[ny][nx] === 1) {
                            grid[ny][nx] = 2;
                            newFires.push({x: nx, y: ny});
                        }
                    });
                    grid[y][x] = 3;
                }

                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        if (grid[y][x] >= 3 && grid[y][x] < 15) grid[y][x]++;
                        else if (grid[y][x] >= 15) grid[y][x] = 0;
                    }
                }

                fires = newFires;
            }

            updateStats();
        }

        function draw() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const state = grid[y][x];

                    if (state === 1) {
                        ctx.fillStyle = '#00ff00';
                    } else if (state === 2) {
                        ctx.fillStyle = '#ff0000';
                    } else if (state >= 3) {
                        const fade = (state - 3) / 12;
                        const intensity = Math.floor(255 * (1 - fade));
                        ctx.fillStyle = `rgb(${intensity}, ${intensity * 0.3}, 0)`;
                    } else {
                        continue;
                    }

                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }

        function updateStats() {
            const trees = grid.flat().filter(c => c === 1).length;
            const coverage = ((trees / (gridSize * gridSize)) * 100).toFixed(1);

            document.getElementById('cycle').textContent = cycle;
            document.getElementById('trees').textContent = trees;
            document.getElementById('coverage').textContent = coverage;
            document.getElementById('fires').textContent = fires.length;

            history.push(trees);
            if (history.length > 100) history.shift();

            drawChart();
        }

        function drawChart() {
            chartCtx.fillStyle = 'white';
            chartCtx.fillRect(0, 0, chart.width, chart.height);

            if (history.length < 2) return;

            const max = Math.max(...history, 1);
            const min = Math.min(...history);

            chartCtx.strokeStyle = '#27ae60';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();

            history.forEach((val, i) => {
                const x = (i / history.length) * chart.width;
                const y = chart.height - ((val - min) / (max - min) * chart.height);
                if (i === 0) chartCtx.moveTo(x, y);
                else chartCtx.lineTo(x, y);
            });

            chartCtx.stroke();

            chartCtx.fillStyle = '#333';
            chartCtx.font = '12px Arial';
            chartCtx.fillText('Tree Population Over Time', 10, 20);
        }

        document.getElementById('growth').addEventListener('input', (e) => {
            document.getElementById('growthVal').textContent = e.target.value;
            growthRate = e.target.value;
        });

        document.getElementById('ignition').addEventListener('input', (e) => {
            document.getElementById('ignitionVal').textContent = e.target.value;
            ignitionProb = e.target.value;
        });

        document.getElementById('startBtn').addEventListener('click', start);
        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('resetBtn').addEventListener('click', init);

        let frameCount = 0;
        function animate() {
            if (frameCount++ % 3 === 0) {
                update();
                draw();
            }
            requestAnimationFrame(animate);
        }

        init();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
