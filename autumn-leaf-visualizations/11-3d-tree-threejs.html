<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Autumn Tree - Autumn Leaf Visualizations</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }
        h3 {
            margin-top: 0;
            color: #2a5298;
        }
        .info {
            font-size: 12px;
            color: #666;
            margin: 10px 0;
        }
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 5px;
            background: #667eea;
            color: white;
            font-weight: bold;
            cursor: pointer;
        }
        button:hover {
            background: #5568d3;
        }
    </style>
</head>
<body>
<!--
# Goal
Create a fully 3D autumn tree using Three.js, with realistic falling leaves,
camera controls, and dynamic lighting showing autumn colors in 3D space.

# Approach
- Three.js for full 3D rendering
- Procedural 3D tree generation using cylinders for branches
- Instanced leaf geometry for performance
- Leaves fall in 3D space with realistic tumbling
- OrbitControls for camera manipulation
- Directional lighting to enhance depth
- Autumn color gradient applied to 3D leaf meshes
- Particle system for falling leaves

# Technical Implementation
- Three.js r149+
- InstancedMesh for efficient leaf rendering
- CylinderGeometry for tree branches
- OrbitControls for user interaction
- Custom shaders for leaf color variation (optional)
- Physics simulation in 3D space
-->

<div class="controls">
    <h3>3D Autumn Tree</h3>
    <div class="info">Use mouse to rotate camera<br>Scroll to zoom</div>
    <button id="btn-toggle-fall">Toggle Leaf Fall</button>
    <button id="btn-reset-camera">Reset Camera</button>
</div>

<script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>

<script>
// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(15, 10, 15);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Controls
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.maxPolarAngle = Math.PI / 2;

// Lighting
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(10, 20, 10);
directionalLight.castShadow = true;
directionalLight.shadow.camera.left = -20;
directionalLight.shadow.camera.right = 20;
directionalLight.shadow.camera.top = 20;
directionalLight.shadow.camera.bottom = -20;
scene.add(directionalLight);

// Ground
const groundGeometry = new THREE.PlaneGeometry(50, 50);
const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x8B7355 });
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// Autumn colors
const autumnColors = [
    0x228B22, // Green
    0x9ACD32, // Yellow-green
    0xFFD700, // Gold
    0xFFA500, // Orange
    0xFF8C00, // Dark orange
    0xFF6347, // Tomato red
    0xDC143C, // Crimson
    0x8B0000  // Dark red
];

// Tree class
class Tree3D {
    constructor() {
        this.branches = [];
        this.leaves = [];
        this.group = new THREE.Group();
        scene.add(this.group);
    }

    createBranch(startPos, direction, length, thickness, depth) {
        if (depth > 8 || length < 0.3) return;

        const endPos = startPos.clone().add(direction.clone().multiplyScalar(length));

        // Create branch cylinder
        const geometry = new THREE.CylinderGeometry(thickness, thickness * 0.7, length, 8);
        const material = new THREE.MeshLambertMaterial({ color: 0x3e2723 });
        const branch = new THREE.Mesh(geometry, material);

        // Position and orient branch
        branch.position.copy(startPos).add(endPos).multiplyScalar(0.5);
        const axis = new THREE.Vector3(0, 1, 0);
        branch.quaternion.setFromUnitVectors(axis, direction.clone().normalize());

        branch.castShadow = true;
        this.group.add(branch);
        this.branches.push(branch);

        // Add leaves at branch ends
        if (depth > 5) {
            for (let i = 0; i < 3; i++) {
                const leafPos = endPos.clone().add(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                ));

                const leaf = {
                    position: leafPos.clone(),
                    basePosition: leafPos.clone(),
                    color: autumnColors[Math.floor(Math.random() * autumnColors.length)],
                    size: 0.3 + Math.random() * 0.2,
                    rotation: new THREE.Euler(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    ),
                    rotationSpeed: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1
                    ),
                    velocity: new THREE.Vector3(0, 0, 0),
                    falling: false
                };

                this.leaves.push(leaf);
            }
        }

        // Create child branches
        if (depth < 8) {
            const numBranches = depth < 2 ? 2 : (Math.random() > 0.6 ? 2 : 1);

            for (let i = 0; i < numBranches; i++) {
                const angleY = (Math.random() - 0.5) * Math.PI / 2;
                const angleZ = (Math.random() - 0.5) * Math.PI / 2;

                const newDirection = direction.clone();
                newDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), angleY);
                newDirection.applyAxisAngle(new THREE.Vector3(0, 0, 1), angleZ);
                newDirection.normalize();

                const newLength = length * (0.6 + Math.random() * 0.2);
                const newThickness = thickness * 0.7;

                this.createBranch(endPos, newDirection, newLength, newThickness, depth + 1);
            }
        }
    }

    generate() {
        // Clear existing
        this.branches = [];
        this.leaves = [];
        while (this.group.children.length > 0) {
            this.group.remove(this.group.children[0]);
        }

        // Generate trunk and branches
        const startPos = new THREE.Vector3(0, 0, 0);
        const startDir = new THREE.Vector3(0, 1, 0);
        this.createBranch(startPos, startDir, 5, 0.4, 0);
    }

    updateLeaves(leavesAreFalling) {
        this.leaves.forEach((leaf, index) => {
            if (leavesAreFalling && !leaf.falling && Math.random() < 0.001) {
                leaf.falling = true;
            }

            if (leaf.falling) {
                // Apply gravity
                leaf.velocity.y -= 0.002;

                // Apply wind
                leaf.velocity.x += (Math.random() - 0.5) * 0.002;
                leaf.velocity.z += (Math.random() - 0.5) * 0.002;

                // Air resistance
                leaf.velocity.multiplyScalar(0.98);

                // Update position
                leaf.position.add(leaf.velocity);

                // Update rotation
                leaf.rotation.x += leaf.rotationSpeed.x;
                leaf.rotation.y += leaf.rotationSpeed.y;
                leaf.rotation.z += leaf.rotationSpeed.z;

                // Reset if hit ground
                if (leaf.position.y < 0.1) {
                    leaf.position.copy(leaf.basePosition);
                    leaf.velocity.set(0, 0, 0);
                    leaf.falling = false;
                }
            }
        });
    }

    renderLeaves() {
        this.leaves.forEach(leaf => {
            // Draw leaf (simple quad)
            const geometry = new THREE.PlaneGeometry(leaf.size, leaf.size * 1.3);
            const material = new THREE.MeshLambertMaterial({
                color: leaf.color,
                side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(geometry, material);

            mesh.position.copy(leaf.position);
            mesh.rotation.copy(leaf.rotation);

            this.group.add(mesh);
        });
    }
}

// Create tree
const tree = new Tree3D();
tree.generate();

// State
let leavesAreFalling = true;

// Controls
document.getElementById('btn-toggle-fall').addEventListener('click', () => {
    leavesAreFalling = !leavesAreFalling;
});

document.getElementById('btn-reset-camera').addEventListener('click', () => {
    camera.position.set(15, 10, 15);
    controls.reset();
});

// Animation
function animate() {
    requestAnimationFrame(animate);

    // Update tree
    tree.updateLeaves(leavesAreFalling);

    // Clear old leaf meshes
    const leavesToRemove = [];
    tree.group.children.forEach(child => {
        if (child.geometry && child.geometry.type === 'PlaneGeometry') {
            leavesToRemove.push(child);
        }
    });
    leavesToRemove.forEach(leaf => {
        tree.group.remove(leaf);
        leaf.geometry.dispose();
        leaf.material.dispose();
    });

    // Render leaves
    tree.renderLeaves();

    // Update controls
    controls.update();

    // Render scene
    renderer.render(scene, camera);
}

animate();

// Handle window resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
