<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Shader Leaves - Autumn Leaf Visualizations</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            border: 2px solid #ff6347;
        }
        h3 {
            margin-top: 0;
            color: #ff6347;
        }
        .control-group {
            margin: 10px 0;
        }
        label {
            display: block;
            margin-bottom: 5px;
        }
        input[type="range"] {
            width: 180px;
        }
        .value {
            display: inline-block;
            width: 50px;
            text-align: right;
            color: #ffa500;
        }
    </style>
</head>
<body>
<!--
# Goal
Use WebGL shaders to create stunning visual effects showing autumn leaf color
transitions with GPU-accelerated rendering and procedural patterns.

# Approach
- Raw WebGL with custom GLSL shaders
- Fragment shader calculates leaf color based on position and time
- Vertex shader animates leaf movement
- Procedural noise for natural color variation
- GPU-based particle effects
- Color mixing algorithms in shader code
- Real-time parameter adjustment

# Technical Implementation
- WebGL 2.0 API
- GLSL ES 3.0 shaders
- Uniforms for user control
- Time-based animations
- Perlin noise implementation in GLSL
- Efficient GPU computation
-->

<canvas id="canvas"></canvas>
<div class="controls">
    <h3>Shader-Based Leaves</h3>
    <div class="control-group">
        <label>Chlorophyll: <span class="value" id="chloro-value">0.5</span></label>
        <input type="range" id="chlorophyll" min="0" max="1" value="0.5" step="0.01">
    </div>
    <div class="control-group">
        <label>Temperature: <span class="value" id="temp-value">10</span>Â°C</label>
        <input type="range" id="temperature" min="0" max="30" value="10" step="1">
    </div>
    <div class="control-group">
        <label>Time Speed: <span class="value" id="speed-value">1.0</span>x</label>
        <input type="range" id="speed" min="0.1" max="5" value="1" step="0.1">
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl2');

if (!gl) {
    alert('WebGL 2.0 not supported');
    throw new Error('WebGL 2.0 not supported');
}

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
gl.viewport(0, 0, canvas.width, canvas.height);

// Vertex shader
const vertexShaderSource = `#version 300 es
in vec2 a_position;
in vec2 a_texCoord;
in float a_index;

uniform float u_time;
uniform vec2 u_resolution;

out vec2 v_texCoord;
out float v_index;

void main() {
    v_texCoord = a_texCoord;
    v_index = a_index;

    // Apply wave motion
    vec2 pos = a_position;
    float wave = sin(u_time * 0.5 + a_index * 0.1) * 0.02;
    pos.x += wave;

    gl_Position = vec4(pos, 0.0, 1.0);
}
`;

// Fragment shader
const fragmentShaderSource = `#version 300 es
precision highp float;

in vec2 v_texCoord;
in float v_index;

uniform float u_time;
uniform float u_chlorophyll;
uniform float u_temperature;
uniform vec2 u_resolution;

out vec4 fragColor;

// Simplex noise function (simplified)
vec3 mod289(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
    return mod289(((x * 34.0) + 1.0) * x);
}

float snoise(vec2 v) {
    const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                       -0.577350269189626, 0.024390243902439);
    vec2 i  = floor(v + dot(v, C.yy));
    vec2 x0 = v -   i + dot(i, C.xx);
    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod289(i);
    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))
        + i.x + vec3(0.0, i1.x, 1.0));
    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),
        dot(x12.zw, x12.zw)), 0.0);
    m = m * m;
    m = m * m;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
    vec3 g;
    g.x = a0.x * x0.x + h.x * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

// Leaf color calculation
vec3 calculateLeafColor(vec2 pos, float chloro, float temp, float time) {
    // Add noise for variation
    float noise = snoise(pos * 5.0 + time * 0.1) * 0.5 + 0.5;

    // Carotene (constant yellow base)
    float carotene = 0.6 + noise * 0.3;

    // Anthocyanin production (cold + time)
    float coldFactor = clamp((15.0 - temp) / 15.0, 0.0, 1.0);
    float anthocyanin = coldFactor * (0.3 + noise * 0.4) + sin(time * 0.3 + v_index) * 0.1;
    anthocyanin = clamp(anthocyanin, 0.0, 1.0);

    vec3 color;

    if (chloro > 0.5) {
        // Green dominates
        float greenIntensity = 0.3 + chloro * 0.7;
        color = vec3(greenIntensity * 0.3, greenIntensity, greenIntensity * 0.3);
    } else {
        // Autumn colors
        float yellowInfluence = (1.0 - chloro) * carotene;
        float redInfluence = anthocyanin;

        if (redInfluence > yellowInfluence + 0.2) {
            // Red
            color = vec3(0.7 + redInfluence * 0.3, 0.1 + yellowInfluence * 0.4, 0.08);
        } else if (yellowInfluence > redInfluence + 0.2) {
            // Yellow
            color = vec3(0.8 + yellowInfluence * 0.2, 0.7 + yellowInfluence * 0.3, 0.1);
        } else {
            // Orange
            color = vec3(1.0, 0.4 + yellowInfluence * 0.4, 0.08);
        }
    }

    return color;
}

// Leaf shape (using distance field)
float leafShape(vec2 p) {
    // Transform to leaf coordinates
    p = p * 2.0 - 1.0;

    // Rotate
    float angle = v_index * 0.5 + u_time * 0.2;
    float c = cos(angle);
    float s = sin(angle);
    p = vec2(p.x * c - p.y * s, p.x * s + p.y * c);

    // Ellipse with pointed tip
    float d = length(vec2(p.x, p.y * 1.4)) - 0.6;

    // Add vein detail
    float vein = abs(p.x) < 0.02 ? 0.8 : 1.0;

    return d < 0.0 ? vein : 0.0;
}

void main() {
    vec2 pos = v_texCoord;

    // Calculate if we're inside the leaf shape
    float inLeaf = leafShape(pos);

    if (inLeaf < 0.1) {
        discard;
    }

    // Calculate leaf color
    vec3 color = calculateLeafColor(pos, u_chlorophyll, u_temperature, u_time);

    // Apply vein darkening
    color *= inLeaf;

    // Add subtle gradient from center
    float distFromCenter = length(pos - 0.5) * 2.0;
    color *= 1.0 - distFromCenter * 0.2;

    fragColor = vec4(color, 1.0);
}
`;

// Compile shader
function compileShader(gl, source, type) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }

    return shader;
}

// Create program
const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);

const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
}

gl.useProgram(program);

// Create leaf grid
const numLeaves = 100;
const vertices = [];
const texCoords = [];
const indices = [];
const leafIndices = [];

for (let i = 0; i < numLeaves; i++) {
    const x = (Math.random() * 2 - 1);
    const y = (Math.random() * 2 - 1);
    const size = 0.08 + Math.random() * 0.08;

    const baseIndex = i * 4;

    // Four vertices per leaf
    vertices.push(
        x - size, y - size,
        x + size, y - size,
        x + size, y + size,
        x - size, y + size
    );

    texCoords.push(
        0, 0,
        1, 0,
        1, 1,
        0, 1
    );

    leafIndices.push(i, i, i, i);

    // Two triangles per leaf
    indices.push(
        baseIndex, baseIndex + 1, baseIndex + 2,
        baseIndex, baseIndex + 2, baseIndex + 3
    );
}

// Create buffers
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

const texCoordBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);

const indexBufferData = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, indexBufferData);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(leafIndices), gl.STATIC_DRAW);

const elementBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

// Set up attributes
const a_position = gl.getAttribLocation(program, 'a_position');
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.enableVertexAttribArray(a_position);
gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

const a_texCoord = gl.getAttribLocation(program, 'a_texCoord');
gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
gl.enableVertexAttribArray(a_texCoord);
gl.vertexAttribPointer(a_texCoord, 2, gl.FLOAT, false, 0, 0);

const a_index = gl.getAttribLocation(program, 'a_index');
gl.bindBuffer(gl.ARRAY_BUFFER, indexBufferData);
gl.enableVertexAttribArray(a_index);
gl.vertexAttribPointer(a_index, 1, gl.FLOAT, false, 0, 0);

// Get uniform locations
const u_time = gl.getUniformLocation(program, 'u_time');
const u_chlorophyll = gl.getUniformLocation(program, 'u_chlorophyll');
const u_temperature = gl.getUniformLocation(program, 'u_temperature');
const u_resolution = gl.getUniformLocation(program, 'u_resolution');

// Parameters
let chlorophyll = 0.5;
let temperature = 10;
let timeSpeed = 1.0;

// Controls
document.getElementById('chlorophyll').addEventListener('input', (e) => {
    chlorophyll = parseFloat(e.target.value);
    document.getElementById('chloro-value').textContent = chlorophyll.toFixed(2);
});

document.getElementById('temperature').addEventListener('input', (e) => {
    temperature = parseFloat(e.target.value);
    document.getElementById('temp-value').textContent = temperature;
});

document.getElementById('speed').addEventListener('input', (e) => {
    timeSpeed = parseFloat(e.target.value);
    document.getElementById('speed-value').textContent = timeSpeed.toFixed(1);
});

// Render loop
let startTime = Date.now();

function render() {
    const time = (Date.now() - startTime) * 0.001 * timeSpeed;

    // Set uniforms
    gl.uniform1f(u_time, time);
    gl.uniform1f(u_chlorophyll, chlorophyll);
    gl.uniform1f(u_temperature, temperature);
    gl.uniform2f(u_resolution, canvas.width, canvas.height);

    // Clear
    gl.clearColor(0.05, 0.05, 0.1, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Enable blending for smooth leaves
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    // Draw
    gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

    requestAnimationFrame(render);
}

render();

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
});
</script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
