<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wind and Rain Effects - Autumn Leaf Visualizations</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #2c3e50;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
        }
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }
        input[type="range"] {
            width: 200px;
        }
        .value {
            display: inline-block;
            width: 50px;
            text-align: right;
            color: #666;
        }
        h3 {
            margin-top: 0;
            color: #2980b9;
        }
        .weather-icon {
            font-size: 40px;
            text-align: center;
            margin: 10px 0;
        }
    </style>
</head>
<body>
<!--
# Goal
Simulate the effects of wind and rain on autumn leaves, showing how weather
affects leaf attachedness, water absorption, and eventual leaf fall.

# Approach
- Create a tree with leaves that respond to environmental forces
- Wind: horizontal force affecting leaf position and reducing attachedness
- Rain: droplets that travel from sky ‚Üí ground ‚Üí roots ‚Üí trunk ‚Üí leaves
- Water absorption when raindrops contact leaves
- Attachedness decreases with wind strength
- Leaves shake and sway in wind before eventually falling
- Visual feedback: tree bending, leaves trembling, rain visible

# Technical Implementation
- Canvas 2D with physics simulation
- Raindrop particle system with state machine (falling/ground/roots/trunk/leaves)
- Wind as continuous force vector affecting leaf positions
- Leaf attachedness tracked and decremented by wind
- Water level increases when leaves contact raindrops
- Tree branch swaying animation based on wind strength
-->

<canvas id="canvas"></canvas>
<div class="controls">
    <h3>Weather Effects</h3>
    <div class="weather-icon" id="weather-icon">üå¶Ô∏è</div>
    <div class="control-group">
        <label>Wind Speed: <span class="value" id="wind-value">1.0</span></label>
        <input type="range" id="wind" min="0" max="5" value="1" step="0.1">
    </div>
    <div class="control-group">
        <label>Rain Intensity: <span class="value" id="rain-value">5</span></label>
        <input type="range" id="rain" min="0" max="20" value="5" step="1">
    </div>
    <div class="control-group">
        <label>Temperature: <span class="value" id="temp-value">12</span>¬∞C</label>
        <input type="range" id="temperature" min="0" max="30" value="12" step="1">
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Raindrop class
class Raindrop {
    constructor() {
        this.x = Math.random() * canvas.width;
        this.y = -10;
        this.speed = 5 + Math.random() * 5;
        this.size = 2 + Math.random() * 2;
        this.state = 'falling'; // falling, ground, roots, trunk, leaves
        this.waterAmount = 10;
        this.targetLeaf = null;
    }

    update(windSpeed) {
        switch (this.state) {
            case 'falling':
                this.y += this.speed;
                this.x += windSpeed * 0.5; // Wind affects falling rain

                // Check if hit ground
                if (this.y >= canvas.height - 100) {
                    this.state = 'ground';
                    this.y = canvas.height - 100;
                }

                // Check if hit a leaf directly while falling
                for (const leaf of leaves) {
                    if (!leaf.fallen && this.distanceTo(leaf) < leaf.size + 5) {
                        leaf.water += this.waterAmount * 0.3;
                        this.waterAmount *= 0.7;
                        if (this.waterAmount < 1) return false;
                    }
                }
                break;

            case 'ground':
                // Move toward trunk
                const trunkX = canvas.width / 2;
                this.x += (trunkX - this.x) * 0.1;
                if (Math.abs(this.x - trunkX) < 5) {
                    this.state = 'roots';
                }
                break;

            case 'roots':
                // Move up trunk
                this.y -= 2;
                if (this.y < canvas.height - 200) {
                    this.state = 'trunk';
                }
                break;

            case 'trunk':
                // Move toward a random leaf
                if (!this.targetLeaf || this.targetLeaf.fallen) {
                    const availableLeaves = leaves.filter(l => !l.fallen);
                    if (availableLeaves.length === 0) return false;
                    this.targetLeaf = availableLeaves[Math.floor(Math.random() * availableLeaves.length)];
                }

                const dx = this.targetLeaf.x - this.x;
                const dy = this.targetLeaf.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 5) {
                    this.state = 'leaves';
                } else {
                    this.x += (dx / dist) * 2;
                    this.y += (dy / dist) * 2;
                }
                break;

            case 'leaves':
                // Transfer water to leaf
                if (this.targetLeaf && !this.targetLeaf.fallen) {
                    this.targetLeaf.water += this.waterAmount * 0.05;
                    this.waterAmount *= 0.95;
                }

                if (this.waterAmount < 0.5) return false;
                break;
        }

        return true; // Continue existing
    }

    distanceTo(leaf) {
        const dx = this.x - leaf.x;
        const dy = this.y - leaf.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    draw() {
        ctx.fillStyle = this.state === 'falling' ? 'rgba(174, 214, 241, 0.8)' : 'rgba(52, 152, 219, 0.6)';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Leaf class
class Leaf {
    constructor(x, y, branchAngle) {
        this.baseX = x;
        this.baseY = y;
        this.x = x;
        this.y = y;
        this.size = 6 + Math.random() * 4;
        this.angle = branchAngle;
        this.chlorophyll = 30 + Math.random() * 40;
        this.carotene = 60 + Math.random() * 30;
        this.anthocyanin = 20 + Math.random() * 40;
        this.water = 50 + Math.random() * 30;
        this.attachedness = 80 + Math.random() * 20;
        this.fallen = false;
        this.fallVY = 0;
        this.wobblePhase = Math.random() * Math.PI * 2;
        this.wobbleSpeed = 0.05 + Math.random() * 0.05;
    }

    update(windSpeed, temperature) {
        if (this.fallen) {
            this.fallVY += 0.2;
            this.y += this.fallVY;
            this.x += windSpeed * 0.5;
            return;
        }

        // Wind reduces attachedness
        this.attachedness -= windSpeed * 0.05;

        // Low water reduces attachedness
        if (this.water < 25) {
            this.attachedness -= 0.1;
        }

        // Water helps attachedness
        if (this.water > 50) {
            this.attachedness += 0.05;
        }

        // Temperature affects chlorophyll and thus attachedness
        if (temperature < 10) {
            this.chlorophyll -= 0.1;
            this.attachedness -= 0.05;
        }

        // Water evaporates
        if (temperature > 20) {
            this.water -= 0.1;
        }

        // Wind makes leaves wobble
        this.wobblePhase += this.wobbleSpeed * (1 + windSpeed);
        const wobbleX = Math.sin(this.wobblePhase) * windSpeed * 3;
        const wobbleY = Math.cos(this.wobblePhase * 0.5) * windSpeed * 2;

        this.x = this.baseX + wobbleX;
        this.y = this.baseY + wobbleY;

        // Clamp values
        this.attachedness = Math.max(0, Math.min(100, this.attachedness));
        this.water = Math.max(0, Math.min(100, this.water));
        this.chlorophyll = Math.max(0, Math.min(100, this.chlorophyll));

        // Check if should fall
        if (this.attachedness <= 0) {
            this.fallen = true;
        }
    }

    getColor() {
        const chloroRatio = this.chlorophyll / 100;
        const caroteRatio = this.carotene / 100;
        const anthocRatio = this.anthocyanin / 100;

        if (anthocRatio > 0.5) {
            const r = 180 + anthocRatio * 75;
            const g = 20 + (1 - anthocRatio) * 100;
            return `rgb(${r}, ${g}, 20)`;
        } else if (caroteRatio > 0.5) {
            const r = 200 + caroteRatio * 55;
            const g = 180 + caroteRatio * 75;
            return `rgb(${r}, ${g}, 20)`;
        } else {
            const g = 100 + chloroRatio * 100;
            return `rgb(${g * 0.4}, ${g}, ${g * 0.4})`;
        }
    }

    draw() {
        ctx.fillStyle = this.getColor();
        ctx.beginPath();
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.ellipse(0, 0, this.size, this.size * 1.4, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Water level indicator (small blue dot if high water)
        if (!this.fallen && this.water > 70) {
            ctx.fillStyle = 'rgba(52, 152, 219, 0.7)';
            ctx.beginPath();
            ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

// Create tree structure
const leaves = [];
const branches = [];

function createBranch(x, y, angle, length, depth) {
    if (depth > 7) return;

    const endX = x + Math.cos(angle) * length;
    const endY = y + Math.sin(angle) * length;

    branches.push({ x1: x, y1: y, x2: endX, y2: endY, depth });

    // Add leaves at branch tips
    if (depth > 4) {
        for (let i = 0; i < 2; i++) {
            const leafX = endX + (Math.random() - 0.5) * 15;
            const leafY = endY + (Math.random() - 0.5) * 15;
            leaves.push(new Leaf(leafX, leafY, angle));
        }
    }

    // Create child branches
    if (depth < 7) {
        const numChildren = depth < 3 ? 2 : (Math.random() > 0.4 ? 2 : 1);
        for (let i = 0; i < numChildren; i++) {
            const newAngle = angle + (Math.random() - 0.5) * Math.PI / 2.5;
            const newLength = length * (0.65 + Math.random() * 0.15);
            createBranch(endX, endY, newAngle, newLength, depth + 1);
        }
    }
}

createBranch(canvas.width / 2, canvas.height - 100, -Math.PI / 2, 140, 0);

// Raindrops
const raindrops = [];

// Controls
let windSpeed = 1.0;
let rainIntensity = 5;
let temperature = 12;

document.getElementById('wind').addEventListener('input', (e) => {
    windSpeed = parseFloat(e.target.value);
    document.getElementById('wind-value').textContent = windSpeed.toFixed(1);
    updateWeatherIcon();
});

document.getElementById('rain').addEventListener('input', (e) => {
    rainIntensity = parseInt(e.target.value);
    document.getElementById('rain-value').textContent = rainIntensity;
    updateWeatherIcon();
});

document.getElementById('temperature').addEventListener('input', (e) => {
    temperature = parseInt(e.target.value);
    document.getElementById('temp-value').textContent = temperature;
});

function updateWeatherIcon() {
    let icon = '‚òÄÔ∏è';
    if (rainIntensity > 10 && windSpeed > 3) {
        icon = '‚õàÔ∏è'; // Storm
    } else if (rainIntensity > 10) {
        icon = 'üåßÔ∏è'; // Heavy rain
    } else if (rainIntensity > 0 && windSpeed > 2) {
        icon = 'üå¶Ô∏è'; // Rainy and windy
    } else if (rainIntensity > 0) {
        icon = 'üå¶Ô∏è'; // Light rain
    } else if (windSpeed > 3) {
        icon = 'üí®'; // Windy
    } else if (windSpeed > 0) {
        icon = 'üçÉ'; // Breezy
    }
    document.getElementById('weather-icon').textContent = icon;
}

updateWeatherIcon();

let frameCount = 0;

function animate() {
    frameCount++;

    // Sky color based on weather
    const skyBrightness = Math.max(50, 150 - rainIntensity * 5);
    ctx.fillStyle = `rgb(${skyBrightness}, ${skyBrightness + 30}, ${skyBrightness + 50})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Ground
    ctx.fillStyle = '#8B7355';
    ctx.fillRect(0, canvas.height - 100, canvas.width, 100);

    // Spawn raindrops
    if (frameCount % Math.max(1, 10 - rainIntensity) === 0 && rainIntensity > 0) {
        raindrops.push(new Raindrop());
    }

    // Update and draw raindrops
    for (let i = raindrops.length - 1; i >= 0; i--) {
        if (!raindrops[i].update(windSpeed)) {
            raindrops.splice(i, 1);
        } else {
            raindrops[i].draw();
        }
    }

    // Draw branches with wind sway
    ctx.strokeStyle = '#4A3728';
    ctx.lineCap = 'round';
    const windSway = Math.sin(Date.now() * 0.001 * windSpeed) * windSpeed * 2;

    branches.forEach(branch => {
        ctx.lineWidth = Math.max(1, 12 - branch.depth * 1.5);
        ctx.beginPath();

        // Apply wind sway to branch tips
        const swayFactor = branch.depth / 7;
        const x2 = branch.x2 + windSway * swayFactor;

        ctx.moveTo(branch.x1, branch.y1);
        ctx.lineTo(x2, branch.y2);
        ctx.stroke();
    });

    // Update and draw leaves
    leaves.forEach(leaf => {
        leaf.update(windSpeed, temperature);
        leaf.draw();
    });

    // Draw stats
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.font = '14px Arial';
    ctx.textAlign = 'left';
    const attachedLeaves = leaves.filter(l => !l.fallen).length;
    ctx.fillText(`Attached: ${attachedLeaves}/${leaves.length}`, 20, canvas.height - 60);
    ctx.fillText(`Raindrops: ${raindrops.length}`, 20, canvas.height - 40);

    requestAnimationFrame(animate);
}

animate();

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});
</script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
