<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Autumn Tree - Autumn Leaf Visualizations</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(180deg, #89CFF0 0%, #C4A582 100%);
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        h3 {
            margin-top: 0;
            color: #2a5298;
        }
        .control-group {
            margin: 12px 0;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
            font-size: 13px;
        }
        input[type="range"] {
            width: 200px;
        }
        .value {
            display: inline-block;
            width: 40px;
            text-align: right;
            color: #666;
            font-weight: bold;
        }
        button {
            width: 100%;
            padding: 10px;
            margin: 8px 0;
            border: none;
            border-radius: 5px;
            background: #667eea;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
<!--
# Goal
Create a beautiful fractal tree using recursive branching algorithms,
with leaves that change color based on their position and environmental factors.

# Approach
- Recursive fractal generation for natural-looking tree structure
- Each branch spawns child branches with varying angles and lengths
- Leaves generated at terminal branches
- Leaf color varies by: height (colder higher up), distance from trunk, branch generation
- Real-time regeneration with adjustable parameters
- Depth control for tree complexity
- Angle variation for different tree shapes
- Length ratio affects bushiness vs. height

# Technical Implementation
- Canvas 2D with recursive rendering
- L-system inspired branching rules
- Fibonacci-like angle variations for natural appearance
- Color gradient based on multiple environmental factors
- Performance optimization: limit recursion depth
- Interactive controls for tree morphology
-->

<canvas id="canvas"></canvas>
<div class="controls">
    <h3>Fractal Tree Generator</h3>

    <div class="control-group">
        <label>Branch Depth: <span class="value" id="depth-value">9</span></label>
        <input type="range" id="depth" min="5" max="12" value="9" step="1">
    </div>

    <div class="control-group">
        <label>Angle: <span class="value" id="angle-value">25</span>¬∞</label>
        <input type="range" id="angle" min="10" max="45" value="25" step="1">
    </div>

    <div class="control-group">
        <label>Length Ratio: <span class="value" id="length-value">0.7</span></label>
        <input type="range" id="length-ratio" min="0.5" max="0.85" value="0.7" step="0.05">
    </div>

    <div class="control-group">
        <label>Temperature: <span class="value" id="temp-value">10</span>¬∞C</label>
        <input type="range" id="temperature" min="0" max="25" value="10" step="1">
    </div>

    <button id="btn-regenerate">üå≥ Regenerate Tree</button>
    <button id="btn-animate" style="background: #e74c3c;">üçÇ Animate Color Change</button>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Tree parameters
let maxDepth = 9;
let branchAngle = 25 * Math.PI / 180;
let lengthRatio = 0.7;
let temperature = 10;
let animating = false;
let animationTime = 0;

class TreeLeaf {
    constructor(x, y, generation, distanceFromTrunk) {
        this.x = x;
        this.y = y;
        this.generation = generation;
        this.distanceFromTrunk = distanceFromTrunk;
        this.height = canvas.height - y;
        this.size = 4 + Math.random() * 4;

        // Chemistry based on position
        this.baseChlorophyll = 80 - (generation * 5) - (this.height / canvas.height * 30);
        this.chlorophyll = this.baseChlorophyll;
        this.carotene = 50 + Math.random() * 40;
        this.anthocyanin = generation * 3 + this.height / canvas.height * 20;

        this.phaseOffset = Math.random() * Math.PI * 2;
    }

    update(globalTemp, animTime) {
        if (animating) {
            // Animate color change with wave effect
            const wave = Math.sin(animTime + this.phaseOffset + this.y * 0.01) * 0.5 + 0.5;
            this.chlorophyll = this.baseChlorophyll * (1 - wave * 0.7);
            this.anthocyanin += wave * 2;
        } else {
            // Base on temperature and position
            const heightFactor = this.height / canvas.height;
            const coldnessAtHeight = (15 - globalTemp) + heightFactor * 10;

            if (coldnessAtHeight > 0) {
                this.chlorophyll = Math.max(0, this.baseChlorophyll - coldnessAtHeight * 3);
                this.anthocyanin = Math.min(100, this.anthocyanin + coldnessAtHeight * 2);
            }
        }

        this.chlorophyll = Math.max(0, Math.min(100, this.chlorophyll));
        this.anthocyanin = Math.max(0, Math.min(100, this.anthocyanin));
    }

    getColor() {
        const chloroRatio = this.chlorophyll / 100;
        const caroteRatio = this.carotene / 100;
        const anthocRatio = this.anthocyanin / 100;

        if (chloroRatio > 0.5) {
            const intensity = 50 + chloroRatio * 150;
            return `rgb(${intensity * 0.3}, ${intensity}, ${intensity * 0.3})`;
        } else {
            const yellowInfluence = (1 - chloroRatio) * caroteRatio;
            const redInfluence = anthocRatio;

            let r, g, b;
            if (redInfluence > yellowInfluence + 0.2) {
                r = 180 + redInfluence * 75;
                g = 20 + yellowInfluence * 100;
                b = 20;
            } else if (yellowInfluence > redInfluence + 0.2) {
                r = 200 + yellowInfluence * 55;
                g = 180 + yellowInfluence * 75;
                b = 20;
            } else {
                r = 255;
                g = 100 + yellowInfluence * 100;
                b = 20;
            }
            return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
        }
    }

    draw() {
        ctx.fillStyle = this.getColor();
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();

        // Subtle outline
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.lineWidth = 0.5;
        ctx.stroke();
    }
}

let leaves = [];

function drawBranch(x, y, angle, length, depth, generation, distanceFromTrunk) {
    if (depth === 0) return;

    // Calculate end point
    const endX = x + Math.cos(angle) * length;
    const endY = y + Math.sin(angle) * length;

    // Draw branch
    ctx.strokeStyle = depth > 2 ? '#3e2723' : '#5d4e37';
    ctx.lineWidth = depth * 1.2;
    ctx.lineCap = 'round';

    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(endX, endY);
    ctx.stroke();

    // Add leaves at terminal branches or small branches
    if (depth <= 3 || (depth <= 5 && Math.random() > 0.5)) {
        const numLeaves = depth === 1 ? 3 : 2;
        for (let i = 0; i < numLeaves; i++) {
            const leafX = endX + (Math.random() - 0.5) * 8;
            const leafY = endY + (Math.random() - 0.5) * 8;
            leaves.push(new TreeLeaf(leafX, leafY, generation, distanceFromTrunk + length));
        }
    }

    // Recursive branching
    const newLength = length * lengthRatio;
    const angleVariation = (Math.random() - 0.5) * 0.3;

    // Left branch
    drawBranch(
        endX, endY,
        angle - branchAngle + angleVariation,
        newLength,
        depth - 1,
        generation + 1,
        distanceFromTrunk + length
    );

    // Right branch
    drawBranch(
        endX, endY,
        angle + branchAngle + angleVariation,
        newLength,
        depth - 1,
        generation + 1,
        distanceFromTrunk + length
    );

    // Sometimes add a third branch for bushiness
    if (depth > 3 && Math.random() > 0.7) {
        drawBranch(
            endX, endY,
            angle + (Math.random() - 0.5) * branchAngle,
            newLength * 0.8,
            depth - 2,
            generation + 1,
            distanceFromTrunk + length
        );
    }
}

function generateTree() {
    leaves = [];
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw background
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#89CFF0');
    gradient.addColorStop(1, '#C4A582');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Ground
    ctx.fillStyle = '#8B7355';
    ctx.fillRect(0, canvas.height - 100, canvas.width, 100);

    // Draw tree starting from bottom center
    const startX = canvas.width / 2;
    const startY = canvas.height - 100;
    const initialLength = 120;

    drawBranch(startX, startY, -Math.PI / 2, initialLength, maxDepth, 0, 0);
}

// Controls
document.getElementById('depth').addEventListener('input', (e) => {
    maxDepth = parseInt(e.target.value);
    document.getElementById('depth-value').textContent = maxDepth;
    generateTree();
});

document.getElementById('angle').addEventListener('input', (e) => {
    branchAngle = parseInt(e.target.value) * Math.PI / 180;
    document.getElementById('angle-value').textContent = e.target.value;
    generateTree();
});

document.getElementById('length-ratio').addEventListener('input', (e) => {
    lengthRatio = parseFloat(e.target.value);
    document.getElementById('length-value').textContent = lengthRatio.toFixed(2);
    generateTree();
});

document.getElementById('temperature').addEventListener('input', (e) => {
    temperature = parseInt(e.target.value);
    document.getElementById('temp-value').textContent = temperature;
});

document.getElementById('btn-regenerate').addEventListener('click', () => {
    generateTree();
});

document.getElementById('btn-animate').addEventListener('click', function() {
    animating = !animating;
    this.textContent = animating ? '‚è∏ Pause Animation' : 'üçÇ Animate Color Change';
    if (animating) {
        animationTime = 0;
    }
});

// Initial generation
generateTree();

// Animation loop
function animate() {
    if (animating) {
        animationTime += 0.02;
    }

    // Redraw everything
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#89CFF0');
    gradient.addColorStop(1, '#C4A582');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Ground
    ctx.fillStyle = '#8B7355';
    ctx.fillRect(0, canvas.height - 100, canvas.width, 100);

    // Redraw branches (they don't change)
    const startX = canvas.width / 2;
    const startY = canvas.height - 100;
    const initialLength = 120;

    function redrawBranch(x, y, angle, length, depth) {
        if (depth === 0) return;

        const endX = x + Math.cos(angle) * length;
        const endY = y + Math.sin(angle) * length;

        ctx.strokeStyle = depth > 2 ? '#3e2723' : '#5d4e37';
        ctx.lineWidth = depth * 1.2;
        ctx.lineCap = 'round';

        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(endX, endY);
        ctx.stroke();

        const newLength = length * lengthRatio;
        const angleVariation = 0; // No variation on redraw for consistency

        redrawBranch(endX, endY, angle - branchAngle, newLength, depth - 1);
        redrawBranch(endX, endY, angle + branchAngle, newLength, depth - 1);
    }

    redrawBranch(startX, startY, -Math.PI / 2, initialLength, maxDepth);

    // Update and draw leaves
    leaves.forEach(leaf => {
        leaf.update(temperature, animationTime);
        leaf.draw();
    });

    // Draw title
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.font = 'bold 28px Arial';
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
    ctx.shadowBlur = 10;
    ctx.fillText('Fractal Autumn Tree', canvas.width / 2, 40);
    ctx.shadowBlur = 0;

    ctx.font = '14px Arial';
    ctx.fillText(`Leaves: ${leaves.length}`, canvas.width / 2, 65);

    requestAnimationFrame(animate);
}

animate();

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    generateTree();
});
</script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
