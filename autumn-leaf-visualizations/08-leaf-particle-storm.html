<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leaf Particle Storm - Autumn Leaf Visualizations</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a2e;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 100, 0, 0.5);
            color: white;
            border: 2px solid #ff6b35;
        }
        h3 {
            margin-top: 0;
            color: #ff6b35;
        }
        .stat {
            margin: 10px 0;
            font-size: 14px;
        }
        .stat-value {
            font-weight: bold;
            color: #ffa500;
        }
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 5px;
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }
        button:hover {
            transform: scale(1.05);
        }
    </style>
</head>
<body>
<!--
# Goal
Create a mesmerizing particle system of thousands of falling autumn leaves,
each with unique colors, rotations, and physics, creating a beautiful storm effect.

# Approach
- Mass particle system with 1000+ individual leaf particles
- Each particle has unique properties: color, size, rotation, fall speed
- Turbulent wind patterns using Perlin-like noise
- Spiral/vortex effects creating swirling leaf patterns
- Mouse interaction creating wind gusts
- Performance-optimized rendering for smooth 60fps with many particles
- Color distribution following autumn palette

# Technical Implementation
- Canvas 2D with optimized draw calls
- Efficient particle pooling and recycling
- Simplex noise function for natural wind patterns
- Vector math for physics simulation
- Mouse position as force attractor/repeller
- requestAnimationFrame with delta time
-->

<canvas id="canvas"></canvas>
<div class="controls">
    <h3>Leaf Particle Storm</h3>
    <div class="stat">Particles: <span class="stat-value" id="particle-count">0</span></div>
    <div class="stat">FPS: <span class="stat-value" id="fps">60</span></div>
    <button id="btn-add">Add 100 Leaves</button>
    <button id="btn-clear">Clear All</button>
    <button id="btn-vortex">Toggle Vortex</button>
    <div class="stat" style="margin-top: 15px; font-size: 12px; color: #999;">
        Move your mouse to create wind gusts!
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Autumn color palette
const autumnColors = [
    '#228B22', '#9ACD32', '#FFD700', '#FFA500',
    '#FF8C00', '#FF6347', '#DC143C', '#8B0000',
    '#DAA520', '#CD853F', '#D2691E'
];

// Simple noise function for wind
class Noise {
    constructor() {
        this.seed = Math.random() * 1000;
    }

    get(x, y) {
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);

        const u = x * x * x * (x * (x * 6 - 15) + 10);
        const v = y * y * y * (y * (y * 6 - 15) + 10);

        const a = this.hash(X + this.hash(Y));
        const b = this.hash(X + 1 + this.hash(Y));
        const c = this.hash(X + this.hash(Y + 1));
        const d = this.hash(X + 1 + this.hash(Y + 1));

        return this.lerp(v,
            this.lerp(u, this.grad(a, x, y), this.grad(b, x - 1, y)),
            this.lerp(u, this.grad(c, x, y - 1), this.grad(d, x - 1, y - 1))
        );
    }

    hash(i) {
        i = (i ^ (i >> 16)) * 0x85ebca6b;
        i = (i ^ (i >> 13)) * 0xc2b2ae35;
        return (i ^ (i >> 16)) & 255;
    }

    grad(hash, x, y) {
        const h = hash & 3;
        return ((h & 1) === 0 ? x : -x) + ((h & 2) === 0 ? y : -y);
    }

    lerp(t, a, b) {
        return a + t * (b - a);
    }
}

const noise = new Noise();

class LeafParticle {
    constructor() {
        this.reset();
    }

    reset() {
        this.x = Math.random() * canvas.width;
        this.y = -20 - Math.random() * 100;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = 1 + Math.random() * 2;
        this.size = 3 + Math.random() * 6;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.15;
        this.color = autumnColors[Math.floor(Math.random() * autumnColors.length)];
        this.opacity = 0.7 + Math.random() * 0.3;
        this.wobblePhase = Math.random() * Math.PI * 2;
        this.wobbleSpeed = 0.02 + Math.random() * 0.03;
        this.wobbleAmount = 0.5 + Math.random() * 1.5;
    }

    update(deltaTime, mouseX, mouseY, vortexMode) {
        // Wind from noise
        const windX = noise.get(this.x * 0.002, this.y * 0.002 + performance.now() * 0.0001) * 3;
        const windY = noise.get(this.x * 0.002 + 100, this.y * 0.002 + performance.now() * 0.0001) * 0.5;

        this.vx += windX * 0.1;
        this.vy += windY * 0.1;

        // Gravity
        this.vy += 0.05;

        // Mouse interaction
        const dx = mouseX - this.x;
        const dy = mouseY - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 150 && dist > 0) {
            const force = (150 - dist) / 150;
            this.vx += (dx / dist) * force * 0.5;
            this.vy += (dy / dist) * force * 0.5;
        }

        // Vortex mode
        if (vortexMode) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const dcx = this.x - centerX;
            const dcy = this.y - centerY;
            const distFromCenter = Math.sqrt(dcx * dcx + dcy * dcy);

            if (distFromCenter > 0) {
                // Tangential force for spiral
                const angle = Math.atan2(dcy, dcx);
                const tangentialAngle = angle + Math.PI / 2;
                const spiralForce = 2;

                this.vx += Math.cos(tangentialAngle) * spiralForce * 0.1;
                this.vy += Math.sin(tangentialAngle) * spiralForce * 0.1;

                // Slight inward pull
                this.vx -= (dcx / distFromCenter) * 0.05;
                this.vy -= (dcy / distFromCenter) * 0.05;
            }
        }

        // Air resistance
        this.vx *= 0.98;
        this.vy *= 0.98;

        // Wobble
        this.wobblePhase += this.wobbleSpeed;
        const wobble = Math.sin(this.wobblePhase) * this.wobbleAmount;

        // Update position
        this.x += this.vx + wobble;
        this.y += this.vy;

        // Rotation
        this.rotation += this.rotationSpeed;

        // Reset if off screen
        if (this.y > canvas.height + 20) {
            this.reset();
        }
        if (this.x < -20) this.x = canvas.width + 20;
        if (this.x > canvas.width + 20) this.x = -20;
    }

    draw() {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        ctx.fillStyle = this.color;
        ctx.beginPath();

        // Simple leaf shape
        ctx.moveTo(0, -this.size);
        ctx.quadraticCurveTo(this.size * 0.8, -this.size * 0.5, this.size * 0.6, 0);
        ctx.quadraticCurveTo(this.size * 0.4, this.size * 0.5, 0, this.size);
        ctx.quadraticCurveTo(-this.size * 0.4, this.size * 0.5, -this.size * 0.6, 0);
        ctx.quadraticCurveTo(-this.size * 0.8, -this.size * 0.5, 0, -this.size);
        ctx.closePath();
        ctx.fill();

        // Vein
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(0, -this.size);
        ctx.lineTo(0, this.size);
        ctx.stroke();

        ctx.restore();
    }
}

// Particle array
const particles = [];

// Spawn initial particles
for (let i = 0; i < 300; i++) {
    particles.push(new LeafParticle());
}

// Mouse tracking
let mouseX = canvas.width / 2;
let mouseY = canvas.height / 2;
let vortexMode = false;

canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
});

// Controls
document.getElementById('btn-add').addEventListener('click', () => {
    for (let i = 0; i < 100; i++) {
        particles.push(new LeafParticle());
    }
});

document.getElementById('btn-clear').addEventListener('click', () => {
    particles.length = 0;
});

document.getElementById('btn-vortex').addEventListener('click', () => {
    vortexMode = !vortexMode;
});

// FPS tracking
let lastTime = performance.now();
let frameCount = 0;
let fps = 60;

function animate(currentTime) {
    const deltaTime = (currentTime - lastTime) / 16.67; // Normalize to 60fps
    lastTime = currentTime;

    frameCount++;
    if (frameCount % 30 === 0) {
        fps = Math.round(1000 / (currentTime - lastTime) * 30) / 30;
        document.getElementById('fps').textContent = fps.toFixed(0);
    }

    // Background with slight gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#0f0f1e');
    gradient.addColorStop(1, '#1a1a2e');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw vortex center if active
    if (vortexMode) {
        ctx.save();
        ctx.globalAlpha = 0.2;
        ctx.strokeStyle = '#ff6b35';
        ctx.lineWidth = 2;
        for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, 50 + i * 30, 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.restore();
    }

    // Update and draw particles
    particles.forEach(particle => {
        particle.update(deltaTime, mouseX, mouseY, vortexMode);
        particle.draw();
    });

    // Update UI
    document.getElementById('particle-count').textContent = particles.length;

    // Draw title
    ctx.fillStyle = 'rgba(255, 107, 53, 0.8)';
    ctx.font = 'bold 32px Arial';
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
    ctx.shadowBlur = 15;
    ctx.fillText('Autumn Leaf Storm', canvas.width / 2, 50);
    ctx.shadowBlur = 0;

    requestAnimationFrame(animate);
}

animate(performance.now());

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});
</script>
</body>
</html>
