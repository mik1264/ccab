<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ground Accumulation - Autumn Leaf Visualizations</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(180deg, #6B8E9F 0%, #A67C52 100%);
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        h3 {
            margin-top: 0;
            color: #8B4513;
        }
        .stat {
            margin: 8px 0;
            font-size: 14px;
        }
        .stat-value {
            font-weight: bold;
            color: #D2691E;
        }
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 5px;
            background: linear-gradient(135deg, #D2691E, #8B4513);
            color: white;
            font-weight: bold;
            cursor: pointer;
        }
        button:hover {
            opacity: 0.9;
        }
    </style>
</head>
<body>
<!--
# Goal
Simulate autumn leaves falling and accumulating on the ground, creating
realistic piles with physics-based stacking and color mixing effects.

# Approach
- Continuous leaf fall from tree canopy
- Physics simulation for falling and landing
- Ground collision detection
- Realistic stacking behavior (leaves pile up)
- Color variation in fallen leaves (decomposition over time)
- Visual depth through layering
- Leaves slowly fade/brown as they age on ground
- Wind occasionally disturbs ground leaves

# Technical Implementation
- Canvas 2D with physics engine
- Two-layer system: falling leaves + ground leaves
- Spatial grid for efficient collision detection
- Height map for ground accumulation
- Color aging system (vibrant ‚Üí brown ‚Üí decomposed)
- Particle count optimization
-->

<canvas id="canvas"></canvas>
<div class="controls">
    <h3>Leaf Accumulation</h3>
    <div class="stat">Falling: <span class="stat-value" id="falling-count">0</span></div>
    <div class="stat">On Ground: <span class="stat-value" id="ground-count">0</span></div>
    <div class="stat">Total: <span class="stat-value" id="total-count">0</span></div>
    <button id="btn-wind">üí® Wind Gust</button>
    <button id="btn-clear">üßπ Clear Ground</button>
    <button id="btn-pause">‚è∏ Pause</button>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const GROUND_Y = canvas.height - 100;

// Autumn color palette
const autumnColors = [
    '#228B22', '#9ACD32', '#FFD700', '#FFA500',
    '#FF8C00', '#FF6347', '#DC143C', '#8B0000'
];

class FallingLeaf {
    constructor() {
        this.x = Math.random() * canvas.width;
        this.y = -20;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = 1 + Math.random() * 2;
        this.size = 4 + Math.random() * 6;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.1;
        this.color = autumnColors[Math.floor(Math.random() * autumnColors.length)];
        this.wobblePhase = Math.random() * Math.PI * 2;
        this.wobbleSpeed = 0.02 + Math.random() * 0.03;
        this.wobbleAmount = 1 + Math.random() * 2;
    }

    update(wind = 0) {
        // Physics
        this.vy += 0.05; // Gravity
        this.vx += wind * 0.1;
        this.vx *= 0.98; // Air resistance
        this.vy *= 0.98;

        // Wobble
        this.wobblePhase += this.wobbleSpeed;
        const wobble = Math.sin(this.wobblePhase) * this.wobbleAmount;

        this.x += this.vx + wobble;
        this.y += this.vy;
        this.rotation += this.rotationSpeed;

        // Wrap around horizontally
        if (this.x < -20) this.x = canvas.width + 20;
        if (this.x > canvas.width + 20) this.x = -20;

        // Check if hit ground
        return this.y >= GROUND_Y;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        ctx.fillStyle = this.color;
        ctx.beginPath();
        // Maple leaf shape
        ctx.moveTo(0, -this.size);
        ctx.quadraticCurveTo(this.size * 0.8, -this.size * 0.5, this.size * 0.6, 0);
        ctx.quadraticCurveTo(this.size * 0.4, this.size * 0.5, 0, this.size);
        ctx.quadraticCurveTo(-this.size * 0.4, this.size * 0.5, -this.size * 0.6, 0);
        ctx.quadraticCurveTo(-this.size * 0.8, -this.size * 0.5, 0, -this.size);
        ctx.closePath();
        ctx.fill();

        // Vein
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, -this.size);
        ctx.lineTo(0, this.size);
        ctx.stroke();

        ctx.restore();
    }
}

class GroundLeaf {
    constructor(x, y, color, size, rotation) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.size = size;
        this.rotation = rotation;
        this.age = 0;
        this.settled = false;
        this.depth = 0; // How many leaves are on top
    }

    update() {
        this.age += 0.01;

        // Color fades to brown over time
        if (this.age > 2) {
            this.color = this.ageColor(this.color, this.age);
        }
    }

    ageColor(originalColor, age) {
        // Extract RGB from hex
        let r, g, b;
        if (originalColor.startsWith('#')) {
            const hex = originalColor.slice(1);
            r = parseInt(hex.slice(0, 2), 16);
            g = parseInt(hex.slice(2, 4), 16);
            b = parseInt(hex.slice(4, 6), 16);
        } else {
            const match = originalColor.match(/\d+/g);
            r = parseInt(match[0]);
            g = parseInt(match[1]);
            b = parseInt(match[2]);
        }

        // Fade toward brown
        const brownR = 101;
        const brownG = 67;
        const brownB = 33;

        const ageFactor = Math.min((age - 2) / 10, 1);

        r = Math.floor(r + (brownR - r) * ageFactor);
        g = Math.floor(g + (brownG - g) * ageFactor);
        b = Math.floor(b + (brownB - b) * ageFactor);

        return `rgb(${r}, ${g}, ${b})`;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        // Darken if buried
        ctx.globalAlpha = Math.max(0.3, 1 - this.depth * 0.1);

        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(0, -this.size);
        ctx.quadraticCurveTo(this.size * 0.8, -this.size * 0.5, this.size * 0.6, 0);
        ctx.quadraticCurveTo(this.size * 0.4, this.size * 0.5, 0, this.size);
        ctx.quadraticCurveTo(-this.size * 0.4, this.size * 0.5, -this.size * 0.6, 0);
        ctx.quadraticCurveTo(-this.size * 0.8, -this.size * 0.5, 0, -this.size);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
        ctx.globalAlpha = 1.0;
    }
}

// State
const fallingLeaves = [];
const groundLeaves = [];
let windForce = 0;
let isPaused = false;
let frameCount = 0;

// Spawn leaves from tree
function spawnLeaf() {
    if (fallingLeaves.length < 100) { // Limit falling leaves
        fallingLeaves.push(new FallingLeaf());
    }
}

// Wind gust
function createWindGust() {
    windForce = (Math.random() - 0.5) * 4;

    // Disturb some ground leaves
    for (let i = 0; i < Math.min(20, groundLeaves.length); i++) {
        const leaf = groundLeaves[Math.floor(Math.random() * groundLeaves.length)];
        if (Math.random() < 0.3) {
            // Lift leaf back into air
            const newLeaf = new FallingLeaf();
            newLeaf.x = leaf.x;
            newLeaf.y = leaf.y;
            newLeaf.color = leaf.color;
            newLeaf.size = leaf.size;
            fallingLeaves.push(newLeaf);

            // Remove from ground
            const index = groundLeaves.indexOf(leaf);
            if (index > -1) groundLeaves.splice(index, 1);
        }
    }

    // Wind decays
    setTimeout(() => {
        windForce *= 0.8;
    }, 100);
}

// Controls
document.getElementById('btn-wind').addEventListener('click', createWindGust);

document.getElementById('btn-clear').addEventListener('click', () => {
    groundLeaves.length = 0;
});

document.getElementById('btn-pause').addEventListener('click', function() {
    isPaused = !isPaused;
    this.textContent = isPaused ? '‚ñ∂ Resume' : '‚è∏ Pause';
});

// Draw tree silhouette
function drawTree() {
    ctx.fillStyle = '#2C1810';
    // Trunk
    ctx.fillRect(canvas.width / 2 - 20, GROUND_Y - 150, 40, 150);

    // Canopy (simple)
    ctx.beginPath();
    ctx.ellipse(canvas.width / 2, GROUND_Y - 150, 100, 80, 0, 0, Math.PI * 2);
    ctx.fill();
}

// Animation
function animate() {
    frameCount++;

    // Background
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#6B8E9F');
    gradient.addColorStop(1, '#A67C52');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Ground
    ctx.fillStyle = '#654321';
    ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);

    // Tree
    drawTree();

    if (!isPaused) {
        // Spawn new leaves
        if (frameCount % 15 === 0) {
            spawnLeaf();
        }

        // Wind decay
        windForce *= 0.95;

        // Update falling leaves
        for (let i = fallingLeaves.length - 1; i >= 0; i--) {
            const leaf = fallingLeaves[i];
            const landed = leaf.update(windForce);

            if (landed) {
                // Transfer to ground
                groundLeaves.push(new GroundLeaf(
                    leaf.x,
                    GROUND_Y + Math.random() * 5, // Slight variation for depth
                    leaf.color,
                    leaf.size,
                    leaf.rotation
                ));

                fallingLeaves.splice(i, 1);
            }
        }

        // Update ground leaves
        groundLeaves.forEach(leaf => leaf.update());

        // Calculate depth (simple approximation)
        groundLeaves.forEach((leaf, i) => {
            leaf.depth = 0;
            for (let j = i + 1; j < groundLeaves.length; j++) {
                const other = groundLeaves[j];
                const dx = leaf.x - other.x;
                const dy = leaf.y - other.y;
                if (Math.sqrt(dx * dx + dy * dy) < leaf.size + other.size) {
                    leaf.depth++;
                }
            }
        });
    }

    // Draw ground leaves (bottom to top)
    groundLeaves.sort((a, b) => a.y - b.y).forEach(leaf => leaf.draw());

    // Draw falling leaves
    fallingLeaves.forEach(leaf => leaf.draw());

    // Update UI
    document.getElementById('falling-count').textContent = fallingLeaves.length;
    document.getElementById('ground-count').textContent = groundLeaves.length;
    document.getElementById('total-count').textContent = fallingLeaves.length + groundLeaves.length;

    requestAnimationFrame(animate);
}

animate();

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});
</script>
</body>
</html>
