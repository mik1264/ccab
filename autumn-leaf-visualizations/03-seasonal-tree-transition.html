<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seasonal Tree Transition - Autumn Leaf Visualizations</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #87CEEB;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            max-width: 250px;
        }
        h3 {
            margin-top: 0;
            color: #2a5298;
        }
        .season-info {
            margin: 15px 0;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 5px;
        }
        .season-name {
            font-weight: bold;
            font-size: 18px;
            color: #333;
        }
        .season-day {
            color: #666;
            font-size: 14px;
        }
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 5px;
            background: #667eea;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #5568d3;
        }
    </style>
</head>
<body>
<!--
# Goal
Visualize the complete seasonal transition of a tree from summer through autumn to winter,
showing the gradual color change and leaf loss based on environmental conditions.

# Approach
- Represent a tree as a collection of leaves positioned on branches
- Simulate seasonal progression: summer (green) → early autumn (yellow-green) →
  peak autumn (orange-red) → late autumn (mostly bare) → winter (bare)
- Each leaf has individual chlorophyll, carotene, anthocyanin levels
- Environmental factors (temperature, daylight) change with season
- Leaves gradually detach and fall based on weather conditions
- Time-lapse animation with adjustable speed

# Technical Implementation
- Canvas 2D with fractal branch generation
- Seasonal state machine driving environmental parameters
- Individual leaf agents with chemical properties
- Procedural tree generation for natural appearance
- Real-time color calculation based on pigment levels
-->

<canvas id="canvas"></canvas>
<div class="controls">
    <h3>Seasonal Transition</h3>
    <div class="season-info">
        <div class="season-name" id="season-name">Summer</div>
        <div class="season-day" id="season-day">Day 1 of 90</div>
    </div>
    <button id="btn-play-pause">Pause</button>
    <button id="btn-speed-up">Speed Up (2x)</button>
    <button id="btn-slow-down">Slow Down (0.5x)</button>
    <button id="btn-reset">Reset to Summer</button>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Seasons configuration
const SEASONS = {
    SUMMER: {
        name: 'Summer',
        duration: 90,
        temperature: 25,
        sunIntensity: 70,
        color: '#87CEEB'
    },
    EARLY_AUTUMN: {
        name: 'Early Autumn',
        duration: 30,
        temperature: 18,
        sunIntensity: 60,
        color: '#9DB4C8'
    },
    PEAK_AUTUMN: {
        name: 'Peak Autumn',
        duration: 30,
        temperature: 10,
        sunIntensity: 50,
        color: '#B8C5D6'
    },
    LATE_AUTUMN: {
        name: 'Late Autumn',
        duration: 30,
        temperature: 5,
        sunIntensity: 40,
        color: '#C9D5E0'
    },
    WINTER: {
        name: 'Winter',
        duration: 90,
        temperature: 0,
        sunIntensity: 30,
        color: '#D5E1EC'
    }
};

class Leaf {
    constructor(x, y, branchAngle) {
        this.x = x;
        this.y = y;
        this.size = 6 + Math.random() * 4;
        this.chlorophyll = 80 + Math.random() * 20;
        this.carotene = 50 + Math.random() * 30;
        this.anthocyanin = 0;
        this.sugar = 20 + Math.random() * 30;
        this.water = 80 + Math.random() * 20;
        this.attachedness = 100;
        this.angle = branchAngle + (Math.random() - 0.5) * 0.5;
        this.fallen = false;
        this.fallY = 0;
        this.fallX = 0;
        this.fallRotation = 0;
        this.fallSpeed = 0;
    }

    update(temperature, sunIntensity, deltaTime) {
        if (this.fallen) {
            this.fallY += this.fallSpeed;
            this.fallSpeed += 0.2;
            this.fallRotation += 0.05;
            return;
        }

        // Chlorophyll degradation
        if (temperature < 15) {
            this.chlorophyll -= (15 - temperature) * 0.1 * deltaTime;
        }
        if (sunIntensity > 75) {
            this.chlorophyll -= (sunIntensity - 75) * 0.05 * deltaTime;
        }

        // Chlorophyll production
        if (temperature > 15 && sunIntensity > 20 && sunIntensity < 75) {
            this.chlorophyll += 0.3 * deltaTime;
        }

        // Anthocyanin production (when cold and sugar present)
        if (temperature < 15 && this.sugar > 10 && this.water > 10) {
            const production = Math.min(this.sugar, this.water) * 0.05 * deltaTime;
            this.anthocyanin += production;
            this.sugar -= production * 0.5;
            this.water -= production * 0.5;
        }

        // Attachedness decreases with low chlorophyll and low temperature
        if (this.chlorophyll < 30) {
            this.attachedness -= 0.5 * deltaTime;
        }
        if (temperature < 10) {
            this.attachedness -= 0.3 * deltaTime;
        }

        // Clamp values
        this.chlorophyll = Math.max(0, Math.min(100, this.chlorophyll));
        this.anthocyanin = Math.max(0, Math.min(100, this.anthocyanin));
        this.attachedness = Math.max(0, Math.min(100, this.attachedness));

        // Check if leaf should fall
        if (this.attachedness <= 0) {
            this.fallen = true;
            this.fallY = this.y;
            this.fallX = this.x;
            this.fallSpeed = 1 + Math.random() * 2;
        }
    }

    getColor() {
        const chloroRatio = this.chlorophyll / 100;
        const caroteRatio = this.carotene / 100;
        const anthocRatio = this.anthocyanin / 100;

        if (chloroRatio > 0.5) {
            // Green dominates
            const intensity = 50 + chloroRatio * 150;
            return `rgb(${intensity * 0.3}, ${intensity}, ${intensity * 0.3})`;
        } else {
            // Mix of yellow (carotene) and red (anthocyanin)
            const yellowInfluence = (1 - chloroRatio) * caroteRatio;
            const redInfluence = anthocRatio;

            let r, g, b;
            if (redInfluence > yellowInfluence) {
                // More red
                r = 180 + redInfluence * 75;
                g = 20 + yellowInfluence * 100;
                b = 20;
            } else if (yellowInfluence > redInfluence * 1.5) {
                // More yellow
                r = 200 + yellowInfluence * 55;
                g = 180 + yellowInfluence * 75;
                b = 20;
            } else {
                // Orange
                r = 255;
                g = 140 + yellowInfluence * 60;
                b = 20;
            }

            return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
        }
    }

    draw() {
        if (this.fallen) {
            if (this.fallY > canvas.height) return;

            ctx.save();
            ctx.translate(this.fallX, this.fallY);
            ctx.rotate(this.fallRotation);
            ctx.fillStyle = this.getColor();
            ctx.beginPath();
            ctx.ellipse(0, 0, this.size, this.size * 1.3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        } else {
            ctx.fillStyle = this.getColor();
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

// Generate tree structure
const branches = [];
const leaves = [];

function generateTree() {
    const trunkBase = { x: canvas.width / 2, y: canvas.height - 100 };
    const trunkHeight = 150;

    // Draw trunk later, but generate branches
    drawBranch(trunkBase.x, trunkBase.y, -Math.PI / 2, trunkHeight, 15, 0);
}

function drawBranch(x, y, angle, length, thickness, depth) {
    if (depth > 8) return;
    if (length < 5) return;

    const endX = x + Math.cos(angle) * length;
    const endY = y + Math.sin(angle) * length;

    branches.push({ x1: x, y1: y, x2: endX, y2: endY, thickness });

    // Add leaves at the tips
    if (depth > 4) {
        const numLeaves = Math.floor(Math.random() * 3) + 1;
        for (let i = 0; i < numLeaves; i++) {
            const leafX = endX + (Math.random() - 0.5) * 10;
            const leafY = endY + (Math.random() - 0.5) * 10;
            leaves.push(new Leaf(leafX, leafY, angle));
        }
    }

    // Generate child branches
    if (depth < 8) {
        const numBranches = depth < 3 ? 2 : (Math.random() > 0.5 ? 2 : 1);
        for (let i = 0; i < numBranches; i++) {
            const newAngle = angle + (Math.random() - 0.5) * Math.PI / 3;
            const newLength = length * (0.6 + Math.random() * 0.2);
            const newThickness = thickness * 0.7;
            drawBranch(endX, endY, newAngle, newLength, newThickness, depth + 1);
        }
    }
}

generateTree();

// Simulation state
let currentSeasonKey = 'SUMMER';
let dayInSeason = 0;
let isPlaying = true;
let timeSpeed = 1.0;

function getCurrentSeason() {
    return SEASONS[currentSeasonKey];
}

function advanceDay() {
    dayInSeason++;
    const season = getCurrentSeason();

    if (dayInSeason > season.duration) {
        // Move to next season
        const seasonKeys = Object.keys(SEASONS);
        const currentIndex = seasonKeys.indexOf(currentSeasonKey);
        const nextIndex = (currentIndex + 1) % seasonKeys.length;
        currentSeasonKey = seasonKeys[nextIndex];
        dayInSeason = 1;
    }
}

// Controls
document.getElementById('btn-play-pause').addEventListener('click', function() {
    isPlaying = !isPlaying;
    this.textContent = isPlaying ? 'Pause' : 'Play';
});

document.getElementById('btn-speed-up').addEventListener('click', () => {
    timeSpeed *= 2;
    timeSpeed = Math.min(timeSpeed, 8);
});

document.getElementById('btn-slow-down').addEventListener('click', () => {
    timeSpeed *= 0.5;
    timeSpeed = Math.max(timeSpeed, 0.25);
});

document.getElementById('btn-reset').addEventListener('click', () => {
    currentSeasonKey = 'SUMMER';
    dayInSeason = 0;
    leaves.length = 0;
    branches.length = 0;
    generateTree();
});

let lastTime = Date.now();
let dayProgress = 0;

function animate() {
    const now = Date.now();
    const deltaTime = (now - lastTime) / 1000;
    lastTime = now;

    if (isPlaying) {
        dayProgress += deltaTime * timeSpeed;
        if (dayProgress >= 0.1) { // Advance day every 0.1 seconds at 1x speed
            advanceDay();
            dayProgress = 0;
        }
    }

    const season = getCurrentSeason();

    // Background
    ctx.fillStyle = season.color;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Ground
    ctx.fillStyle = '#8B7355';
    ctx.fillRect(0, canvas.height - 100, canvas.width, 100);

    // Draw branches
    ctx.strokeStyle = '#4A3728';
    ctx.lineCap = 'round';
    branches.forEach(branch => {
        ctx.lineWidth = branch.thickness;
        ctx.beginPath();
        ctx.moveTo(branch.x1, branch.y1);
        ctx.lineTo(branch.x2, branch.y2);
        ctx.stroke();
    });

    // Update and draw leaves
    leaves.forEach(leaf => {
        leaf.update(season.temperature, season.sunIntensity, deltaTime * timeSpeed);
        leaf.draw();
    });

    // Update UI
    document.getElementById('season-name').textContent = season.name;
    document.getElementById('season-day').textContent = `Day ${dayInSeason} of ${season.duration}`;

    requestAnimationFrame(animate);
}

animate();

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    leaves.length = 0;
    branches.length = 0;
    generateTree();
});
</script>
</body>
</html>
