<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPH Water Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c1e 0%, #1a1a3a 50%, #0d0d20 100%);
            min-height: 100vh;
            color: #e0e0ff;
            overflow: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00aaff;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
            opacity: 0.8;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .back-link:hover {
            opacity: 1;
        }

        canvas {
            display: block;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 40, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(0, 170, 255, 0.3);
            width: 280px;
            z-index: 100;
            max-height: 90vh;
            overflow-y: auto;
        }

        .controls h2 {
            color: #00aaff;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #888;
            font-size: 0.85rem;
        }

        .control-group input[type="range"] {
            width: 100%;
        }

        .range-value {
            text-align: right;
            font-size: 0.8rem;
            color: #00aaff;
        }

        button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #00aaff, #0066cc);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 8px;
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
        }

        button.secondary {
            background: rgba(0, 170, 255, 0.2);
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .stat {
            text-align: center;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }

        .stat-value {
            font-size: 1.2rem;
            color: #00aaff;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #666;
        }

        .info-panel {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 100, 150, 0.2);
            border-radius: 8px;
            font-size: 0.8rem;
            line-height: 1.4;
        }

        .toggle-controls {
            position: fixed;
            top: 20px;
            right: 320px;
            background: rgba(20, 20, 40, 0.9);
            border: 1px solid rgba(0, 170, 255, 0.3);
            border-radius: 8px;
            padding: 8px 15px;
            color: #00aaff;
            cursor: pointer;
            z-index: 100;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">
        <span>‚Üê</span> Back to Gallery
    </a>

    <button class="toggle-controls" onclick="toggleControls()">Toggle Panel</button>

    <canvas id="canvas"></canvas>

    <div class="controls" id="controls">
        <h2>SPH Water Simulation</h2>

        <div class="control-group">
            <label>Particle Count: <span id="particleValue">500</span></label>
            <input type="range" id="particleCount" min="100" max="2000" step="100" value="500">
        </div>

        <div class="control-group">
            <label>Gravity: <span id="gravityValue">9.8</span></label>
            <input type="range" id="gravity" min="0" max="30" step="0.5" value="9.8">
        </div>

        <div class="control-group">
            <label>Viscosity: <span id="viscValue">200</span></label>
            <input type="range" id="viscosity" min="50" max="1000" step="50" value="200">
        </div>

        <div class="control-group">
            <label>Pressure Stiffness: <span id="stiffValue">500</span></label>
            <input type="range" id="stiffness" min="100" max="2000" step="100" value="500">
        </div>

        <div class="control-group">
            <label>Rest Density: <span id="restDensValue">1000</span></label>
            <input type="range" id="restDensity" min="500" max="2000" step="50" value="1000">
        </div>

        <div class="control-group">
            <label>Smoothing Radius: <span id="radiusValue">20</span></label>
            <input type="range" id="smoothingRadius" min="10" max="40" step="2" value="20">
        </div>

        <button onclick="reset()">Reset Simulation</button>
        <button class="secondary" onclick="addWaterDrop()">Add Water Drop</button>
        <button class="secondary" onclick="togglePause()">Pause/Resume</button>

        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="fps">0</div>
                <div class="stat-label">FPS</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="numParticles">0</div>
                <div class="stat-label">Particles</div>
            </div>
        </div>

        <div class="info-panel">
            <strong>SPH</strong> (Smoothed Particle Hydrodynamics) simulates fluid using particles that interact through kernel-weighted calculations of density, pressure, and viscosity forces.
            <br><br>
            <em>Click and drag to push water!</em>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // SPH Parameters
        let H = 20;          // Smoothing radius
        let MASS = 1;        // Particle mass
        let REST_DENSITY = 1000;
        let GAS_CONSTANT = 500;  // Pressure stiffness
        let VISCOSITY = 200;
        let GRAVITY = 9.8;
        let DT = 0.0008;     // Time step
        let BOUNDARY_DAMPING = 0.3;

        // Kernel coefficients (precomputed for efficiency)
        let POLY6, SPIKY_GRAD, VISC_LAP;

        function computeKernelCoeffs() {
            POLY6 = 315 / (64 * Math.PI * Math.pow(H, 9));
            SPIKY_GRAD = -45 / (Math.PI * Math.pow(H, 6));
            VISC_LAP = 45 / (Math.PI * Math.pow(H, 6));
        }

        // Particle class
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.fx = 0;
                this.fy = 0;
                this.density = 0;
                this.pressure = 0;
            }
        }

        let particles = [];
        let paused = false;
        let frameCount = 0;
        let lastFpsTime = performance.now();
        let mouseDown = false;
        let mouseX = 0, mouseY = 0;
        let lastMouseX = 0, lastMouseY = 0;

        // Spatial hash grid for optimization
        let grid = {};
        let cellSize = H;

        function hashCell(x, y) {
            return `${Math.floor(x / cellSize)},${Math.floor(y / cellSize)}`;
        }

        function buildSpatialGrid() {
            grid = {};
            for (const p of particles) {
                const key = hashCell(p.x, p.y);
                if (!grid[key]) grid[key] = [];
                grid[key].push(p);
            }
        }

        function getNeighbors(p) {
            const neighbors = [];
            const cellX = Math.floor(p.x / cellSize);
            const cellY = Math.floor(p.y / cellSize);

            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const key = `${cellX + dx},${cellY + dy}`;
                    if (grid[key]) {
                        for (const other of grid[key]) {
                            if (other !== p) {
                                const distSq = (p.x - other.x) ** 2 + (p.y - other.y) ** 2;
                                if (distSq < H * H) {
                                    neighbors.push(other);
                                }
                            }
                        }
                    }
                }
            }
            return neighbors;
        }

        function initParticles(count) {
            particles = [];
            const startX = canvas.width * 0.2;
            const startY = canvas.height * 0.2;
            const spacing = H * 0.5;

            const cols = Math.floor(Math.sqrt(count * 1.5));
            const rows = Math.ceil(count / cols);

            for (let i = 0; i < count; i++) {
                const row = Math.floor(i / cols);
                const col = i % cols;
                const x = startX + col * spacing + (Math.random() - 0.5) * 2;
                const y = startY + row * spacing + (Math.random() - 0.5) * 2;
                particles.push(new Particle(x, y));
            }
        }

        function addWaterDrop() {
            const dropX = canvas.width * 0.5 + (Math.random() - 0.5) * 100;
            const dropY = 50;
            const dropRadius = 40;
            const count = 50;

            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const r = Math.sqrt(Math.random()) * dropRadius;
                const x = dropX + Math.cos(angle) * r;
                const y = dropY + Math.sin(angle) * r;
                particles.push(new Particle(x, y));
            }
        }

        function computeDensityPressure() {
            for (const p of particles) {
                p.density = 0;

                // Self-contribution
                p.density += MASS * POLY6 * Math.pow(H * H, 3);

                // Neighbor contributions
                const neighbors = getNeighbors(p);
                for (const other of neighbors) {
                    const dx = other.x - p.x;
                    const dy = other.y - p.y;
                    const r2 = dx * dx + dy * dy;
                    if (r2 < H * H) {
                        const h2_r2 = H * H - r2;
                        p.density += MASS * POLY6 * h2_r2 * h2_r2 * h2_r2;
                    }
                }

                // Compute pressure using equation of state
                p.pressure = GAS_CONSTANT * (p.density - REST_DENSITY);
            }
        }

        function computeForces() {
            for (const p of particles) {
                p.fx = 0;
                p.fy = GRAVITY * p.density; // Gravity

                const neighbors = getNeighbors(p);
                for (const other of neighbors) {
                    const dx = other.x - p.x;
                    const dy = other.y - p.y;
                    const r = Math.sqrt(dx * dx + dy * dy);

                    if (r < H && r > 0.001) {
                        // Pressure force (Spiky kernel gradient)
                        const h_r = H - r;
                        const pressureForce = -MASS * (p.pressure + other.pressure) / (2 * other.density) *
                                              SPIKY_GRAD * h_r * h_r;
                        p.fx += (dx / r) * pressureForce;
                        p.fy += (dy / r) * pressureForce;

                        // Viscosity force (Laplacian of viscosity kernel)
                        const viscForce = VISCOSITY * MASS * (1 / other.density) *
                                         VISC_LAP * (H - r);
                        p.fx += viscForce * (other.vx - p.vx);
                        p.fy += viscForce * (other.vy - p.vy);
                    }
                }
            }
        }

        function integrate() {
            for (const p of particles) {
                // Apply forces
                if (p.density > 0) {
                    p.vx += DT * p.fx / p.density;
                    p.vy += DT * p.fy / p.density;
                }

                // Update position
                p.x += DT * p.vx;
                p.y += DT * p.vy;

                // Boundary conditions
                const margin = 5;
                if (p.x < margin) {
                    p.x = margin;
                    p.vx *= -BOUNDARY_DAMPING;
                }
                if (p.x > canvas.width - margin) {
                    p.x = canvas.width - margin;
                    p.vx *= -BOUNDARY_DAMPING;
                }
                if (p.y < margin) {
                    p.y = margin;
                    p.vy *= -BOUNDARY_DAMPING;
                }
                if (p.y > canvas.height - margin) {
                    p.y = canvas.height - margin;
                    p.vy *= -BOUNDARY_DAMPING;
                }
            }
        }

        function applyMouseForce() {
            if (!mouseDown) return;

            const forceMult = 50000;
            const forceRadius = 100;

            for (const p of particles) {
                const dx = p.x - mouseX;
                const dy = p.y - mouseY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < forceRadius && dist > 0.01) {
                    const force = forceMult / (dist * dist);
                    p.vx += (dx / dist) * force * DT;
                    p.vy += (dy / dist) * force * DT;
                }
            }
        }

        function update() {
            buildSpatialGrid();
            computeDensityPressure();
            computeForces();
            applyMouseForce();
            integrate();
        }

        function draw() {
            // Clear with gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0a0a1e');
            gradient.addColorStop(1, '#1a1a3a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw particles
            for (const p of particles) {
                // Color based on velocity
                const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                const colorIntensity = Math.min(1, speed / 500);

                const r = Math.floor(50 + colorIntensity * 100);
                const g = Math.floor(150 + colorIntensity * 50);
                const b = 255;
                const alpha = 0.6 + (p.density / (REST_DENSITY * 2)) * 0.4;

                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw mouse interaction circle
            if (mouseDown) {
                ctx.strokeStyle = 'rgba(0, 170, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 100, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function animate() {
            if (!paused) {
                // Multiple substeps for stability
                for (let i = 0; i < 4; i++) {
                    update();
                }
            }

            draw();

            // Update FPS
            frameCount++;
            const now = performance.now();
            if (now - lastFpsTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                document.getElementById('numParticles').textContent = particles.length;
                frameCount = 0;
                lastFpsTime = now;
            }

            requestAnimationFrame(animate);
        }

        function reset() {
            H = parseInt(document.getElementById('smoothingRadius').value);
            GRAVITY = parseFloat(document.getElementById('gravity').value);
            VISCOSITY = parseFloat(document.getElementById('viscosity').value);
            GAS_CONSTANT = parseFloat(document.getElementById('stiffness').value);
            REST_DENSITY = parseFloat(document.getElementById('restDensity').value);
            cellSize = H;

            computeKernelCoeffs();

            const count = parseInt(document.getElementById('particleCount').value);
            initParticles(count);
        }

        function togglePause() {
            paused = !paused;
        }

        function toggleControls() {
            document.getElementById('controls').classList.toggle('hidden');
        }

        // Event listeners
        document.getElementById('particleCount').addEventListener('input', (e) => {
            document.getElementById('particleValue').textContent = e.target.value;
        });
        document.getElementById('gravity').addEventListener('input', (e) => {
            document.getElementById('gravityValue').textContent = e.target.value;
            GRAVITY = parseFloat(e.target.value);
        });
        document.getElementById('viscosity').addEventListener('input', (e) => {
            document.getElementById('viscValue').textContent = e.target.value;
            VISCOSITY = parseFloat(e.target.value);
        });
        document.getElementById('stiffness').addEventListener('input', (e) => {
            document.getElementById('stiffValue').textContent = e.target.value;
            GAS_CONSTANT = parseFloat(e.target.value);
        });
        document.getElementById('restDensity').addEventListener('input', (e) => {
            document.getElementById('restDensValue').textContent = e.target.value;
            REST_DENSITY = parseFloat(e.target.value);
        });
        document.getElementById('smoothingRadius').addEventListener('input', (e) => {
            document.getElementById('radiusValue').textContent = e.target.value;
        });

        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        canvas.addEventListener('mouseleave', () => {
            mouseDown = false;
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Initialize
        window.reset = reset;
        computeKernelCoeffs();
        initParticles(500);
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
