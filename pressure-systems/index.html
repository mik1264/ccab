<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Atmospheric Pressure Systems</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Nunito', sans-serif; }
canvas { display: block; }
.title-overlay {
    position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
    color: #fff; font-size: 1.4rem; font-weight: 600;
    text-shadow: 0 2px 10px rgba(0,0,0,0.7);
    pointer-events: none; z-index: 10; text-align: center;
}
.title-overlay .subtitle {
    font-size: 0.8rem; opacity: 0.7; margin-top: 4px; font-weight: 300;
}
.organic-back-link {
    position: fixed; top: 20px; left: 20px; z-index: 100;
    display: flex; align-items: center; gap: 8px;
    padding: 8px 16px; border-radius: 20px;
    background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);
    color: #fff; text-decoration: none; font-size: 0.9rem;
    transition: background 0.3s;
}
.organic-back-link:hover { background: rgba(255,255,255,0.2); }
.controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 15px; align-items: center; z-index: 10; flex-wrap: wrap; justify-content: center;
    background: rgba(0,0,0,0.6); backdrop-filter: blur(10px);
    padding: 12px 24px; border-radius: 20px; color: #fff; font-size: 0.85rem;
}
.controls label { display: flex; align-items: center; gap: 8px; white-space: nowrap; }
.controls input[type="range"] { width: 100px; }
.controls button {
    padding: 6px 14px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.1); color: #fff; cursor: pointer;
    font-size: 0.8rem; transition: all 0.3s;
}
.controls button:hover { background: rgba(255,255,255,0.2); }
.legend {
    position: fixed; top: 80px; right: 20px; z-index: 10;
    background: rgba(0,0,0,0.5); backdrop-filter: blur(10px);
    padding: 12px 16px; border-radius: 12px; color: #fff; font-size: 0.7rem;
    line-height: 2;
}
.legend-item { display: flex; align-items: center; gap: 8px; }
.legend-dot {
    width: 10px; height: 10px; border-radius: 50%; display: inline-block;
}
</style>
</head>
<body>
<a href="../index.html" class="organic-back-link">
    <span class="back-arrow">&larr;</span>
    <span class="back-text">Gallery</span>
</a>
<div class="title-overlay">
    Atmospheric Pressure Systems
    <div class="subtitle">High and low pressure systems with isobars and wind flow</div>
</div>
<div class="legend">
    <div class="legend-item"><span class="legend-dot" style="background:#ff4040"></span> Low Pressure (L)</div>
    <div class="legend-item"><span class="legend-dot" style="background:#4080ff"></span> High Pressure (H)</div>
    <div class="legend-item"><span class="legend-dot" style="background:rgba(255,255,255,0.3)"></span> Isobars</div>
    <div class="legend-item"><span class="legend-dot" style="background:#ffaa30"></span> Warm Front</div>
    <div class="legend-item"><span class="legend-dot" style="background:#3090ff"></span> Cold Front</div>
    <div style="margin-top:8px; opacity:0.6; font-size:0.65rem;">
        NH: CCW around Low<br>
        NH: CW around High
    </div>
</div>
<div class="controls">
    <label>Wind Speed: <input type="range" id="windSlider" min="0.5" max="4" step="0.1" value="1.5"> <span id="windVal">1.5</span></label>
    <label>Isobars: <input type="range" id="isobarSlider" min="3" max="10" step="1" value="6"> <span id="isobarVal">6</span></label>
    <button onclick="randomizeSystems()">Randomize</button>
    <button onclick="toggleFronts()">Toggle Fronts</button>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

let showFronts = true;

function toggleFronts() {
    showFronts = !showFronts;
}

// Pressure systems
let systems = [];

function createSystem(x, y, type, strength) {
    return {
        x, y,
        type, // 'high' or 'low'
        strength, // 0-1
        radius: 100 + strength * 150,
        vx: (Math.random() - 0.5) * 0.3,
        vy: (Math.random() - 0.5) * 0.2
    };
}

function randomizeSystems() {
    systems = [];
    const numSystems = 3 + Math.floor(Math.random() * 3);
    for (let i = 0; i < numSystems; i++) {
        const type = i % 2 === 0 ? 'low' : 'high';
        systems.push(createSystem(
            W * 0.15 + Math.random() * W * 0.7,
            H * 0.15 + Math.random() * H * 0.6,
            type,
            0.4 + Math.random() * 0.6
        ));
    }
}

// Initialize with default systems
systems.push(createSystem(W * 0.3, H * 0.4, 'low', 0.8));
systems.push(createSystem(W * 0.7, H * 0.35, 'high', 0.7));
systems.push(createSystem(W * 0.5, H * 0.65, 'low', 0.5));
systems.push(createSystem(W * 0.2, H * 0.7, 'high', 0.6));

// Wind particles
const NUM_PARTICLES = 4000;
const particles = [];

class WindParticle {
    constructor() {
        this.reset();
    }
    reset() {
        this.x = Math.random() * W;
        this.y = Math.random() * H;
        this.vx = 0;
        this.vy = 0;
        this.life = 0.5 + Math.random() * 0.5;
        this.size = 1 + Math.random() * 1;
        this.speed = 0;
    }
    update(windMult) {
        let totalFx = 0, totalFy = 0;

        for (const sys of systems) {
            const dx = this.x - sys.x;
            const dy = this.y - sys.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 1) continue;

            const influence = sys.strength * Math.exp(-dist * dist / (sys.radius * sys.radius * 2));

            // Normalize direction
            const nx = dx / dist;
            const ny = dy / dist;

            // Tangential component (perpendicular to radial)
            let tx, ty;
            if (sys.type === 'low') {
                // Counter-clockwise (NH) around low + inward
                tx = ny;   // tangential
                ty = -nx;
                // Add inward component
                tx -= nx * 0.3;
                ty -= ny * 0.3;
            } else {
                // Clockwise (NH) around high + outward
                tx = -ny;
                ty = nx;
                // Add outward component
                tx += nx * 0.3;
                ty += ny * 0.3;
            }

            totalFx += tx * influence * windMult;
            totalFy += ty * influence * windMult;
        }

        // Background westerly flow
        totalFx += 0.05 * windMult;

        this.vx = this.vx * 0.9 + totalFx * 0.3;
        this.vy = this.vy * 0.9 + totalFy * 0.3;

        this.speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);

        this.x += this.vx;
        this.y += this.vy;

        this.life -= 0.003;

        if (this.x < -10 || this.x > W + 10 || this.y < -10 || this.y > H + 10 || this.life <= 0) {
            this.reset();
        }
    }
    draw() {
        const s = Math.min(1, this.speed / 3);
        let r, g, b;
        if (s < 0.33) {
            r = 60; g = 100 + s * 3 * 155; b = 200;
        } else if (s < 0.66) {
            const t = (s - 0.33) / 0.33;
            r = 60 + t * 195; g = 255 - t * 55; b = 200 - t * 100;
        } else {
            const t = (s - 0.66) / 0.34;
            r = 255; g = 200 - t * 130; b = 100 - t * 70;
        }

        ctx.fillStyle = `rgba(${Math.floor(r)},${Math.floor(g)},${Math.floor(b)},${this.life * 0.5})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

for (let i = 0; i < NUM_PARTICLES; i++) {
    particles.push(new WindParticle());
}

function getPressureAt(x, y) {
    // Base pressure
    let pressure = 1013; // hPa
    for (const sys of systems) {
        const dx = x - sys.x;
        const dy = y - sys.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const influence = sys.strength * Math.exp(-dist * dist / (sys.radius * sys.radius * 2));
        if (sys.type === 'low') {
            pressure -= influence * 30;
        } else {
            pressure += influence * 25;
        }
    }
    return pressure;
}

function drawIsobars(numIsobars) {
    // Use marching squares-like approach: sample pressure on grid and draw contours
    const step = 8;
    const cols = Math.ceil(W / step);
    const rows = Math.ceil(H / step);

    // Sample pressure field
    const pressureField = [];
    let minP = 1100, maxP = 900;
    for (let j = 0; j < rows; j++) {
        pressureField[j] = [];
        for (let i = 0; i < cols; i++) {
            const p = getPressureAt(i * step, j * step);
            pressureField[j][i] = p;
            if (p < minP) minP = p;
            if (p > maxP) maxP = p;
        }
    }

    // Draw contours at regular intervals
    const range = maxP - minP;
    const interval = range / (numIsobars + 1);

    ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
    ctx.lineWidth = 1;

    for (let level = 1; level <= numIsobars; level++) {
        const targetP = minP + level * interval;
        ctx.beginPath();

        for (let j = 0; j < rows - 1; j++) {
            for (let i = 0; i < cols - 1; i++) {
                const p00 = pressureField[j][i];
                const p10 = pressureField[j][i + 1];
                const p01 = pressureField[j + 1][i];
                const p11 = pressureField[j + 1][i + 1];

                const x0 = i * step, y0 = j * step;

                // Find contour crossings on edges
                const edges = [];

                if ((p00 - targetP) * (p10 - targetP) < 0) {
                    const t = (targetP - p00) / (p10 - p00);
                    edges.push({ x: x0 + t * step, y: y0 });
                }
                if ((p10 - targetP) * (p11 - targetP) < 0) {
                    const t = (targetP - p10) / (p11 - p10);
                    edges.push({ x: x0 + step, y: y0 + t * step });
                }
                if ((p01 - targetP) * (p11 - targetP) < 0) {
                    const t = (targetP - p01) / (p11 - p01);
                    edges.push({ x: x0 + t * step, y: y0 + step });
                }
                if ((p00 - targetP) * (p01 - targetP) < 0) {
                    const t = (targetP - p00) / (p01 - p00);
                    edges.push({ x: x0, y: y0 + t * step });
                }

                if (edges.length >= 2) {
                    ctx.moveTo(edges[0].x, edges[0].y);
                    ctx.lineTo(edges[1].x, edges[1].y);
                }
            }
        }
        ctx.stroke();

        // Label some isobars
        const labelX = W * 0.5 + level * 30;
        const labelY = H * 0.1;
        const pAtLabel = getPressureAt(labelX, labelY);
        // Find a good spot to label
        for (let j = Math.floor(rows * 0.3); j < Math.floor(rows * 0.7); j += 20) {
            for (let i = Math.floor(cols * 0.2); i < Math.floor(cols * 0.8); i += 30) {
                if (Math.abs(pressureField[j][i] - targetP) < interval * 0.2) {
                    ctx.fillStyle = 'rgba(255,255,255,0.15)';
                    ctx.font = '9px sans-serif';
                    ctx.fillText(Math.round(targetP) + ' hPa', i * step, j * step - 3);
                    j = rows; // break outer
                    break;
                }
            }
        }
    }
}

function drawSystemLabels() {
    for (const sys of systems) {
        const label = sys.type === 'low' ? 'L' : 'H';
        const color = sys.type === 'low' ? 'rgba(255, 80, 80, 0.7)' : 'rgba(80, 140, 255, 0.7)';

        // Center glow
        const grad = ctx.createRadialGradient(sys.x, sys.y, 0, sys.x, sys.y, sys.radius * 0.3);
        grad.addColorStop(0, sys.type === 'low' ? 'rgba(255,50,50,0.08)' : 'rgba(50,100,255,0.08)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(sys.x, sys.y, sys.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();

        // Label
        ctx.fillStyle = color;
        ctx.font = 'bold 28px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, sys.x, sys.y);

        // Pressure value
        const pressure = getPressureAt(sys.x, sys.y);
        ctx.font = '11px sans-serif';
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillText(Math.round(pressure) + ' hPa', sys.x, sys.y + 22);

        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
    }
}

function drawWeatherFronts() {
    if (!showFronts || systems.length < 2) return;

    // Draw fronts between adjacent low and high pressure systems
    for (let i = 0; i < systems.length; i++) {
        if (systems[i].type !== 'low') continue;

        // Find nearest high
        let nearestHigh = null;
        let minDist = Infinity;
        for (let j = 0; j < systems.length; j++) {
            if (systems[j].type !== 'high') continue;
            const dx = systems[j].x - systems[i].x;
            const dy = systems[j].y - systems[i].y;
            const d = Math.sqrt(dx * dx + dy * dy);
            if (d < minDist) { minDist = d; nearestHigh = systems[j]; }
        }

        if (!nearestHigh || minDist > W * 0.6) continue;

        const low = systems[i];
        const high = nearestHigh;

        // Warm front (semicircles, red)
        const warmAngle = Math.atan2(high.y - low.y, high.x - low.x) - Math.PI / 4;
        drawFrontLine(low.x, low.y, warmAngle, low.radius * 0.8, 'warm');

        // Cold front (triangles, blue)
        const coldAngle = Math.atan2(high.y - low.y, high.x - low.x) + Math.PI / 4;
        drawFrontLine(low.x, low.y, coldAngle, low.radius * 0.7, 'cold');
    }
}

function drawFrontLine(startX, startY, angle, length, type) {
    const segments = 15;
    const segLen = length / segments;
    const time = Date.now() * 0.0005;

    ctx.lineWidth = 3;

    for (let i = 0; i < segments; i++) {
        const t = i / segments;
        const x = startX + Math.cos(angle) * t * length;
        const y = startY + Math.sin(angle) * t * length;
        const curve = Math.sin(t * Math.PI * 2 + time) * 15;
        const perpX = -Math.sin(angle) * curve;
        const perpY = Math.cos(angle) * curve;

        const px = x + perpX;
        const py = y + perpY;

        if (type === 'warm') {
            ctx.strokeStyle = 'rgba(255, 170, 50, 0.4)';
            ctx.fillStyle = 'rgba(255, 170, 50, 0.3)';
            if (i > 0) {
                const prevT = (i - 1) / segments;
                const prevX = startX + Math.cos(angle) * prevT * length;
                const prevY = startY + Math.sin(angle) * prevT * length;
                const prevCurve = Math.sin(prevT * Math.PI * 2 + time) * 15;
                ctx.beginPath();
                ctx.moveTo(prevX + (-Math.sin(angle) * prevCurve), prevY + (Math.cos(angle) * prevCurve));
                ctx.lineTo(px, py);
                ctx.stroke();
            }
            // Semicircles on warm front
            if (i % 3 === 0) {
                ctx.beginPath();
                const normAngle = angle + Math.PI / 2;
                ctx.arc(px, py, 5, normAngle, normAngle + Math.PI);
                ctx.fill();
            }
        } else {
            ctx.strokeStyle = 'rgba(50, 150, 255, 0.4)';
            ctx.fillStyle = 'rgba(50, 150, 255, 0.3)';
            if (i > 0) {
                const prevT = (i - 1) / segments;
                const prevX = startX + Math.cos(angle) * prevT * length;
                const prevY = startY + Math.sin(angle) * prevT * length;
                const prevCurve = Math.sin(prevT * Math.PI * 2 + time) * 15;
                ctx.beginPath();
                ctx.moveTo(prevX + (-Math.sin(angle) * prevCurve), prevY + (Math.cos(angle) * prevCurve));
                ctx.lineTo(px, py);
                ctx.stroke();
            }
            // Triangles on cold front
            if (i % 3 === 0) {
                const normAngle = angle + Math.PI / 2;
                ctx.beginPath();
                ctx.moveTo(px + Math.cos(normAngle) * 7, py + Math.sin(normAngle) * 7);
                ctx.lineTo(px + Math.cos(normAngle + 2.5) * 7, py + Math.sin(normAngle + 2.5) * 7);
                ctx.lineTo(px + Math.cos(normAngle - 2.5) * 7, py + Math.sin(normAngle - 2.5) * 7);
                ctx.closePath();
                ctx.fill();
            }
        }
    }
    ctx.lineWidth = 1;
}

function drawMapBackground() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    // Subtle grid
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 1;
    const gridSize = 80;
    for (let x = 0; x < W; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
    }
    for (let y = 0; y < H; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
    }

    // Latitude labels
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.font = '10px sans-serif';
    for (let i = 0; i < 5; i++) {
        const y = H * 0.1 + i * H * 0.2;
        const lat = 60 - i * 15;
        ctx.fillText(lat + '\u00b0N', 5, y);
    }
}

function updateSystems() {
    for (const sys of systems) {
        sys.x += sys.vx;
        sys.y += sys.vy;

        // Bounce off edges
        if (sys.x < W * 0.05 || sys.x > W * 0.95) sys.vx *= -1;
        if (sys.y < H * 0.05 || sys.y > H * 0.9) sys.vy *= -1;

        sys.x = Math.max(W * 0.05, Math.min(W * 0.95, sys.x));
        sys.y = Math.max(H * 0.05, Math.min(H * 0.9, sys.y));
    }
}

function animate() {
    const windMult = parseFloat(document.getElementById('windSlider').value);
    const numIsobars = parseInt(document.getElementById('isobarSlider').value);
    document.getElementById('windVal').textContent = windMult.toFixed(1);
    document.getElementById('isobarVal').textContent = numIsobars;

    drawMapBackground();
    updateSystems();

    // Draw pressure field as subtle heatmap
    const imgData = ctx.getImageData(0, 0, W, H);
    const data = imgData.data;
    const sampleStep = 4;
    for (let y = 0; y < H; y += sampleStep) {
        for (let x = 0; x < W; x += sampleStep) {
            const p = getPressureAt(x, y);
            const normalized = (p - 980) / 60; // 980-1040 range
            let r = 0, g = 0, b = 0;
            if (normalized < 0.5) {
                // Low pressure: warm tint
                r = Math.floor((0.5 - normalized) * 40);
                g = 0;
                b = Math.floor((0.5 - normalized) * 20);
            } else {
                // High pressure: cool tint
                r = 0;
                g = 0;
                b = Math.floor((normalized - 0.5) * 40);
            }
            for (let dy = 0; dy < sampleStep && y + dy < H; dy++) {
                for (let dx = 0; dx < sampleStep && x + dx < W; dx++) {
                    const idx = ((y + dy) * W + (x + dx)) * 4;
                    data[idx] += r;
                    data[idx + 1] += g;
                    data[idx + 2] += b;
                }
            }
        }
    }
    ctx.putImageData(imgData, 0, 0);

    drawIsobars(numIsobars);
    drawWeatherFronts();
    drawSystemLabels();

    for (const p of particles) {
        p.update(windMult);
        p.draw();
    }

    requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
