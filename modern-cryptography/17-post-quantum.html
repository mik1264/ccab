<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Post-Quantum Cryptography - Lattice-Based Security</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #00ff88;
            min-height: 100vh;
            padding: 20px;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00ff88;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(0,255,136,0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            z-index: 100;
        }
        .back-link:hover { background: rgba(0,255,136,0.2); }
        .container {
            max-width: 1100px;
            margin: 60px auto 0;
        }
        h1 { font-size: 2rem; margin-bottom: 10px; text-align: center; }
        .subtitle { color: #888; margin-bottom: 30px; text-align: center; }
        .threat-banner {
            background: rgba(255,68,68,0.1);
            border: 1px solid #ff4444;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }
        .threat-banner h3 { color: #ff4444; margin-bottom: 10px; }
        .threat-banner p { color: #aaa; }
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        .crypto-box {
            background: rgba(0,0,0,0.5);
            padding: 25px;
            border-radius: 15px;
            border: 2px solid;
        }
        .crypto-box.classical { border-color: #ff4444; }
        .crypto-box.quantum { border-color: #00ff88; }
        .crypto-box h3 { margin-bottom: 15px; text-align: center; }
        .crypto-box.classical h3 { color: #ff4444; }
        .crypto-box.quantum h3 { color: #00ff88; }
        .algo-list {
            margin: 15px 0;
        }
        .algo-item {
            padding: 15px;
            background: rgba(0,255,136,0.05);
            border-radius: 10px;
            margin: 10px 0;
        }
        .algo-item h4 { color: #00ccff; margin-bottom: 5px; }
        .algo-item p { color: #888; font-size: 0.85rem; }
        .algo-item .status {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 0.75rem;
            margin-top: 5px;
        }
        .status.broken { background: rgba(255,68,68,0.2); color: #ff4444; }
        .status.secure { background: rgba(0,255,136,0.2); color: #00ff88; }
        .status.nist { background: rgba(0,204,255,0.2); color: #00ccff; }
        .lattice-demo {
            background: rgba(0,0,0,0.5);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid #00ff88;
            margin-bottom: 30px;
        }
        .lattice-demo h3 { color: #00ccff; margin-bottom: 15px; text-align: center; }
        #latticeCanvas {
            display: block;
            margin: 0 auto 20px;
            border-radius: 10px;
            background: rgba(0,0,0,0.3);
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        button {
            padding: 12px 25px;
            font-size: 1rem;
            font-family: inherit;
            background: rgba(0,255,136,0.1);
            border: 1px solid #00ff88;
            color: #00ff88;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover { background: rgba(0,255,136,0.3); }
        .problem-explanation {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 30px 0;
        }
        .problem-box {
            background: rgba(0,255,136,0.05);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        .problem-box .icon { font-size: 2rem; margin-bottom: 10px; }
        .problem-box h4 { color: #00ccff; margin-bottom: 10px; }
        .problem-box p { color: #888; font-size: 0.85rem; }
        .info {
            padding: 20px;
            background: rgba(0,255,136,0.05);
            border-radius: 10px;
        }
        .info h3 { color: #00ccff; margin-bottom: 10px; }
        .info p { color: #aaa; line-height: 1.6; margin-bottom: 10px; }
        .timeline {
            margin: 20px 0;
            padding: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }
        .timeline-item {
            display: flex;
            gap: 15px;
            margin: 15px 0;
            align-items: center;
        }
        .timeline-year {
            background: rgba(0,255,136,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            min-width: 80px;
            text-align: center;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <div class="container">
        <h1>Post-Quantum Cryptography</h1>
        <p class="subtitle">Preparing for the Quantum Computing Era</p>

        <div class="threat-banner">
            <h3>‚ö†Ô∏è The Quantum Threat</h3>
            <p>Quantum computers running Shor's algorithm can break RSA, ECC, and Diffie-Hellman.<br>
            "Harvest now, decrypt later" attacks are already happening.</p>
        </div>

        <div class="comparison">
            <div class="crypto-box classical">
                <h3>‚ùå Broken by Quantum</h3>
                <div class="algo-list">
                    <div class="algo-item">
                        <h4>RSA</h4>
                        <p>Based on integer factorization</p>
                        <span class="status broken">Broken by Shor's algorithm</span>
                    </div>
                    <div class="algo-item">
                        <h4>ECC / ECDSA</h4>
                        <p>Based on elliptic curve discrete log</p>
                        <span class="status broken">Broken by Shor's algorithm</span>
                    </div>
                    <div class="algo-item">
                        <h4>Diffie-Hellman</h4>
                        <p>Based on discrete logarithm</p>
                        <span class="status broken">Broken by Shor's algorithm</span>
                    </div>
                </div>
            </div>

            <div class="crypto-box quantum">
                <h3>‚úÖ Quantum-Resistant</h3>
                <div class="algo-list">
                    <div class="algo-item">
                        <h4>ML-KEM (Kyber)</h4>
                        <p>Lattice-based key encapsulation</p>
                        <span class="status nist">NIST Standard 2024</span>
                    </div>
                    <div class="algo-item">
                        <h4>ML-DSA (Dilithium)</h4>
                        <p>Lattice-based digital signatures</p>
                        <span class="status nist">NIST Standard 2024</span>
                    </div>
                    <div class="algo-item">
                        <h4>SLH-DSA (SPHINCS+)</h4>
                        <p>Hash-based signatures</p>
                        <span class="status nist">NIST Standard 2024</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="lattice-demo">
            <h3>Lattice Problem Visualization</h3>
            <canvas id="latticeCanvas" width="600" height="400"></canvas>
            <p style="text-align:center;color:#888;margin-bottom:15px;">
                Finding the shortest vector in high-dimensional lattices is hard even for quantum computers
            </p>
            <div class="controls">
                <button onclick="generateLattice()">New Lattice</button>
                <button onclick="showShortestVector()">Show SVP</button>
                <button onclick="showTarget()">Show CVP Target</button>
            </div>
        </div>

        <div class="problem-explanation">
            <div class="problem-box">
                <div class="icon">üìê</div>
                <h4>SVP (Shortest Vector)</h4>
                <p>Find the shortest non-zero vector in the lattice. Computationally hard in high dimensions.</p>
            </div>
            <div class="problem-box">
                <div class="icon">üéØ</div>
                <h4>CVP (Closest Vector)</h4>
                <p>Find the lattice point closest to a given target point. No known quantum speedup.</p>
            </div>
            <div class="problem-box">
                <div class="icon">üîê</div>
                <h4>LWE (Learning With Errors)</h4>
                <p>Recover secret from noisy linear equations. Basis for Kyber and Dilithium.</p>
            </div>
        </div>

        <div class="timeline">
            <h3 style="color:#00ccff;margin-bottom:15px;">PQC Timeline</h3>
            <div class="timeline-item">
                <span class="timeline-year">2016</span>
                <span style="color:#888;">NIST begins Post-Quantum Cryptography standardization</span>
            </div>
            <div class="timeline-item">
                <span class="timeline-year">2022</span>
                <span style="color:#888;">NIST selects Kyber, Dilithium, Falcon, SPHINCS+</span>
            </div>
            <div class="timeline-item">
                <span class="timeline-year">2024</span>
                <span style="color:#888;">NIST publishes ML-KEM, ML-DSA, SLH-DSA standards</span>
            </div>
            <div class="timeline-item">
                <span class="timeline-year">2030+</span>
                <span style="color:#888;">Expected migration deadline for critical systems</span>
            </div>
        </div>

        <div class="info">
            <h3>Why Lattices?</h3>
            <p>Lattice problems have been studied for centuries and remain hard even for quantum computers.
            Unlike factoring (which Shor's algorithm solves efficiently), no quantum algorithm provides
            significant speedup for lattice problems.</p>
            <p><strong>Key advantages:</strong> Fast operations, reasonable key sizes, well-understood security reductions.</p>
            <p><strong>Trade-off:</strong> Larger keys than ECC (but smaller than RSA at equivalent security).</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('latticeCanvas');
        const ctx = canvas.getContext('2d');

        let basis = [[40, 10], [15, 35]];
        let latticePoints = [];
        let shortestVector = null;
        let targetPoint = null;

        function generateLattice() {
            // Random 2D basis
            basis = [
                [30 + Math.random() * 30, -10 + Math.random() * 20],
                [-10 + Math.random() * 20, 30 + Math.random() * 30]
            ];
            shortestVector = null;
            targetPoint = null;
            drawLattice();
        }

        function drawLattice() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Draw basis vectors
            ctx.strokeStyle = '#00ccff';
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + basis[0][0] * 3, centerY - basis[0][1] * 3);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + basis[1][0] * 3, centerY - basis[1][1] * 3);
            ctx.stroke();

            // Draw lattice points
            latticePoints = [];
            ctx.fillStyle = '#00ff88';

            for (let i = -5; i <= 5; i++) {
                for (let j = -5; j <= 5; j++) {
                    const x = centerX + (i * basis[0][0] + j * basis[1][0]);
                    const y = centerY - (i * basis[0][1] + j * basis[1][1]);

                    if (x > 0 && x < canvas.width && y > 0 && y < canvas.height) {
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, Math.PI * 2);
                        ctx.fill();
                        latticePoints.push({x, y, i, j});
                    }
                }
            }

            // Draw origin
            ctx.fillStyle = '#ffaa00';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 6, 0, Math.PI * 2);
            ctx.fill();

            // Draw shortest vector if shown
            if (shortestVector) {
                ctx.strokeStyle = '#ff66aa';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(shortestVector.x, shortestVector.y);
                ctx.stroke();

                ctx.fillStyle = '#ff66aa';
                ctx.beginPath();
                ctx.arc(shortestVector.x, shortestVector.y, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#ff66aa';
                ctx.font = '14px Courier New';
                ctx.fillText('Shortest Vector', shortestVector.x + 10, shortestVector.y);
            }

            // Draw target point if shown
            if (targetPoint) {
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(targetPoint.x, targetPoint.y, 8, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#ffff00';
                ctx.font = '14px Courier New';
                ctx.fillText('Target (CVP)', targetPoint.x + 10, targetPoint.y);

                // Find and draw closest lattice point
                let closest = null;
                let minDist = Infinity;

                latticePoints.forEach(p => {
                    const dist = Math.hypot(p.x - targetPoint.x, p.y - targetPoint.y);
                    if (dist < minDist) {
                        minDist = dist;
                        closest = p;
                    }
                });

                if (closest) {
                    ctx.strokeStyle = 'rgba(255,255,0,0.5)';
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(targetPoint.x, targetPoint.y);
                    ctx.lineTo(closest.x, closest.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }

        function showShortestVector() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Find shortest non-zero vector
            let minLen = Infinity;

            latticePoints.forEach(p => {
                if (p.i === 0 && p.j === 0) return;

                const len = Math.hypot(p.x - centerX, p.y - centerY);
                if (len < minLen) {
                    minLen = len;
                    shortestVector = {x: p.x, y: p.y};
                }
            });

            drawLattice();
        }

        function showTarget() {
            targetPoint = {
                x: 100 + Math.random() * (canvas.width - 200),
                y: 100 + Math.random() * (canvas.height - 200)
            };
            drawLattice();
        }

        // Initialize
        generateLattice();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
