<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elliptic Curve Cryptography - Point Addition Visualization</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #00ff88;
            min-height: 100vh;
            padding: 20px;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00ff88;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(0,255,136,0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            z-index: 100;
        }
        .back-link:hover { background: rgba(0,255,136,0.2); }
        .container {
            max-width: 1200px;
            margin: 60px auto 0;
            text-align: center;
        }
        h1 { font-size: 2rem; margin-bottom: 10px; }
        .subtitle { color: #888; margin-bottom: 30px; }
        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 30px;
        }
        #canvas {
            background: rgba(0,0,0,0.5);
            border: 1px solid #00ff88;
            border-radius: 10px;
            cursor: crosshair;
        }
        .controls {
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #00ff88;
            text-align: left;
        }
        .controls h3 {
            color: #00ccff;
            margin-bottom: 15px;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #888;
        }
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        .value-display {
            font-size: 0.9rem;
            color: #00ff88;
            margin-top: 5px;
        }
        button {
            width: 100%;
            padding: 12px;
            font-size: 1rem;
            font-family: inherit;
            background: rgba(0,255,136,0.1);
            border: 1px solid #00ff88;
            color: #00ff88;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }
        button:hover { background: rgba(0,255,136,0.3); }
        .point-info {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0,255,136,0.05);
            border-radius: 5px;
            font-size: 0.9rem;
        }
        .point-info div { margin: 5px 0; }
        .point-p { color: #ff6666; }
        .point-q { color: #6666ff; }
        .point-r { color: #00ff88; }
        .equation {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0,255,136,0.1);
            border-radius: 5px;
            font-size: 1.1rem;
        }
        .info {
            margin-top: 30px;
            padding: 20px;
            background: rgba(0,255,136,0.05);
            border-radius: 10px;
            text-align: left;
        }
        .info h3 { color: #00ccff; margin-bottom: 10px; }
        .info p { color: #aaa; line-height: 1.6; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div class="container">
        <h1>Elliptic Curve Cryptography</h1>
        <p class="subtitle">Visualizing point addition on elliptic curves</p>

        <div class="equation">y² = x³ + <span id="aVal">-3</span>x + <span id="bVal">5</span></div>

        <div class="main-content">
            <canvas id="canvas" width="700" height="600"></canvas>

            <div class="controls">
                <h3>Curve Parameters</h3>

                <div class="control-group">
                    <label>Coefficient a:</label>
                    <input type="range" id="coeffA" min="-10" max="10" value="-3" step="0.5">
                    <div class="value-display" id="displayA">a = -3</div>
                </div>

                <div class="control-group">
                    <label>Coefficient b:</label>
                    <input type="range" id="coeffB" min="-10" max="10" value="5" step="0.5">
                    <div class="value-display" id="displayB">b = 5</div>
                </div>

                <button onclick="randomPoints()">Random Points P, Q</button>
                <button onclick="showAddition()">Show P + Q = R</button>
                <button onclick="showDoubling()">Show 2P</button>
                <button onclick="showScalarMult()">Scalar Multiplication</button>

                <div class="point-info">
                    <div class="point-p">P: (<span id="px">-</span>, <span id="py">-</span>)</div>
                    <div class="point-q">Q: (<span id="qx">-</span>, <span id="qy">-</span>)</div>
                    <div class="point-r">R: (<span id="rx">-</span>, <span id="ry">-</span>)</div>
                </div>
            </div>
        </div>

        <div class="info">
            <h3>About Elliptic Curve Cryptography</h3>
            <p>ECC provides the same security as RSA with much smaller key sizes (256-bit ECC ≈ 3072-bit RSA).
            The curve equation y² = x³ + ax + b defines a set of points. Point addition (P + Q) is done by drawing a line
            through P and Q, finding where it intersects the curve, then reflecting across the x-axis.
            The discrete logarithm problem on elliptic curves (finding n from nP) is computationally hard,
            forming the basis of ECDSA and ECDH used in Bitcoin, TLS, and secure messaging.</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let a = -3;
        let b = 5;
        let pointP = null;
        let pointQ = null;
        let pointR = null;

        const scale = 40;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        function toCanvas(x, y) {
            return [centerX + x * scale, centerY - y * scale];
        }

        function fromCanvas(cx, cy) {
            return [(cx - centerX) / scale, (centerY - cy) / scale];
        }

        function curveY(x) {
            const val = x * x * x + a * x + b;
            if (val < 0) return null;
            return Math.sqrt(val);
        }

        function drawGrid() {
            ctx.strokeStyle = 'rgba(0,255,136,0.1)';
            ctx.lineWidth = 1;

            // Grid lines
            for (let i = -10; i <= 10; i++) {
                const [x1, y1] = toCanvas(i, -10);
                const [x2, y2] = toCanvas(i, 10);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                const [x3, y3] = toCanvas(-10, i);
                const [x4, y4] = toCanvas(10, i);
                ctx.beginPath();
                ctx.moveTo(x3, y3);
                ctx.lineTo(x4, y4);
                ctx.stroke();
            }

            // Axes
            ctx.strokeStyle = 'rgba(0,255,136,0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
        }

        function drawCurve() {
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;

            ctx.beginPath();
            let started = false;

            for (let cx = 0; cx < canvas.width; cx++) {
                const [x, _] = fromCanvas(cx, 0);
                const y = curveY(x);

                if (y !== null) {
                    const [_, cy1] = toCanvas(x, y);
                    const [__, cy2] = toCanvas(x, -y);

                    if (!started) {
                        ctx.moveTo(cx, cy1);
                        started = true;
                    } else {
                        ctx.lineTo(cx, cy1);
                    }
                }
            }
            ctx.stroke();

            // Lower half
            ctx.beginPath();
            started = false;
            for (let cx = 0; cx < canvas.width; cx++) {
                const [x, _] = fromCanvas(cx, 0);
                const y = curveY(x);

                if (y !== null) {
                    const [_, cy2] = toCanvas(x, -y);

                    if (!started) {
                        ctx.moveTo(cx, cy2);
                        started = true;
                    } else {
                        ctx.lineTo(cx, cy2);
                    }
                }
            }
            ctx.stroke();
        }

        function drawPoint(x, y, color, label) {
            const [cx, cy] = toCanvas(x, y);

            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(cx, cy, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Courier New';
            ctx.fillText(label, cx + 12, cy - 5);
        }

        function drawLine(x1, y1, x2, y2, color = 'rgba(255,255,0,0.5)') {
            // Extend line to canvas edges
            const slope = (y2 - y1) / (x2 - x1);
            const intercept = y1 - slope * x1;

            const leftY = slope * -10 + intercept;
            const rightY = slope * 10 + intercept;

            const [cx1, cy1] = toCanvas(-10, leftY);
            const [cx2, cy2] = toCanvas(10, rightY);

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(cx1, cy1);
            ctx.lineTo(cx2, cy2);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawCurve();

            if (pointP) drawPoint(pointP.x, pointP.y, '#ff6666', 'P');
            if (pointQ) drawPoint(pointQ.x, pointQ.y, '#6666ff', 'Q');
            if (pointR) drawPoint(pointR.x, pointR.y, '#00ff88', 'R');
        }

        function randomPoints() {
            // Find random points on the curve
            for (let attempts = 0; attempts < 100; attempts++) {
                const x = (Math.random() - 0.5) * 8;
                const y = curveY(x);
                if (y !== null) {
                    pointP = { x: x, y: Math.random() > 0.5 ? y : -y };
                    break;
                }
            }

            for (let attempts = 0; attempts < 100; attempts++) {
                const x = (Math.random() - 0.5) * 8;
                const y = curveY(x);
                if (y !== null && Math.abs(x - pointP.x) > 0.5) {
                    pointQ = { x: x, y: Math.random() > 0.5 ? y : -y };
                    break;
                }
            }

            pointR = null;
            updatePointInfo();
            draw();
        }

        function addPoints(p1, p2) {
            if (!p1 || !p2) return null;

            let slope;
            if (Math.abs(p1.x - p2.x) < 0.001) {
                // Point doubling
                slope = (3 * p1.x * p1.x + a) / (2 * p1.y);
            } else {
                slope = (p2.y - p1.y) / (p2.x - p1.x);
            }

            const x3 = slope * slope - p1.x - p2.x;
            const y3 = slope * (p1.x - x3) - p1.y;

            return { x: x3, y: y3 };
        }

        function showAddition() {
            if (!pointP || !pointQ) {
                randomPoints();
            }

            pointR = addPoints(pointP, pointQ);
            updatePointInfo();

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawCurve();

            // Draw construction line
            drawLine(pointP.x, pointP.y, pointQ.x, pointQ.y);

            // Draw vertical line through intersection
            if (pointR) {
                const [cx, cy1] = toCanvas(pointR.x, -pointR.y);
                const [_, cy2] = toCanvas(pointR.x, pointR.y);
                ctx.strokeStyle = 'rgba(0,255,136,0.5)';
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(cx, cy1);
                ctx.lineTo(_, cy2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw intermediate point
                drawPoint(pointR.x, -pointR.y, 'rgba(0,255,136,0.5)', '-R');
            }

            drawPoint(pointP.x, pointP.y, '#ff6666', 'P');
            drawPoint(pointQ.x, pointQ.y, '#6666ff', 'Q');
            if (pointR) drawPoint(pointR.x, pointR.y, '#00ff88', 'R');
        }

        function showDoubling() {
            if (!pointP) randomPoints();
            pointQ = { x: pointP.x, y: pointP.y };
            showAddition();
        }

        function showScalarMult() {
            if (!pointP) randomPoints();

            // Show nP for n = 1 to 5
            let current = { x: pointP.x, y: pointP.y };

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawCurve();

            drawPoint(pointP.x, pointP.y, '#ff6666', '1P');

            const colors = ['#ff8866', '#ffaa66', '#ffcc66', '#ffee66'];
            for (let i = 2; i <= 5; i++) {
                current = addPoints(current, pointP);
                if (current && Math.abs(current.y) < 10) {
                    drawPoint(current.x, current.y, colors[i-2], i + 'P');
                }
            }
        }

        function updatePointInfo() {
            document.getElementById('px').textContent = pointP ? pointP.x.toFixed(2) : '-';
            document.getElementById('py').textContent = pointP ? pointP.y.toFixed(2) : '-';
            document.getElementById('qx').textContent = pointQ ? pointQ.x.toFixed(2) : '-';
            document.getElementById('qy').textContent = pointQ ? pointQ.y.toFixed(2) : '-';
            document.getElementById('rx').textContent = pointR ? pointR.x.toFixed(2) : '-';
            document.getElementById('ry').textContent = pointR ? pointR.y.toFixed(2) : '-';
        }

        // Event listeners
        document.getElementById('coeffA').addEventListener('input', (e) => {
            a = parseFloat(e.target.value);
            document.getElementById('displayA').textContent = 'a = ' + a;
            document.getElementById('aVal').textContent = a;
            draw();
        });

        document.getElementById('coeffB').addEventListener('input', (e) => {
            b = parseFloat(e.target.value);
            document.getElementById('displayB').textContent = 'b = ' + b;
            document.getElementById('bVal').textContent = b;
            draw();
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const [x, y] = fromCanvas(e.clientX - rect.left, e.clientY - rect.top);

            // Find closest point on curve
            const curveYVal = curveY(x);
            if (curveYVal !== null) {
                const closestY = Math.abs(y - curveYVal) < Math.abs(y + curveYVal) ? curveYVal : -curveYVal;

                if (!pointP) {
                    pointP = { x, y: closestY };
                } else if (!pointQ) {
                    pointQ = { x, y: closestY };
                } else {
                    pointP = { x, y: closestY };
                    pointQ = null;
                }
                pointR = null;
                updatePointInfo();
                draw();
            }
        });

        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
