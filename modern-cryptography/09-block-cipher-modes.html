<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Cipher Modes - ECB, CBC, CTR Comparison</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #00ff88;
            min-height: 100vh;
            padding: 20px;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00ff88;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(0,255,136,0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            z-index: 100;
        }
        .back-link:hover { background: rgba(0,255,136,0.2); }
        .container {
            max-width: 1200px;
            margin: 60px auto 0;
        }
        h1 { font-size: 2rem; margin-bottom: 10px; text-align: center; }
        .subtitle { color: #888; margin-bottom: 30px; text-align: center; }
        .modes-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }
        .mode-box {
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #00ff88;
        }
        .mode-box h3 {
            color: #00ccff;
            margin-bottom: 15px;
            text-align: center;
        }
        .mode-diagram {
            height: 200px;
            position: relative;
            margin-bottom: 15px;
        }
        .block {
            position: absolute;
            width: 60px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 5px;
            font-size: 0.75rem;
            font-weight: bold;
        }
        .block.plaintext { background: rgba(0,255,136,0.3); border: 1px solid #00ff88; }
        .block.ciphertext { background: rgba(255,136,0,0.3); border: 1px solid #ff8800; }
        .block.key { background: rgba(136,0,255,0.3); border: 1px solid #8800ff; }
        .block.iv { background: rgba(0,136,255,0.3); border: 1px solid #0088ff; }
        .block.xor { background: rgba(255,255,0,0.3); border: 1px solid #ffff00; border-radius: 50%; width: 30px; height: 30px; }
        .block.encrypt { background: rgba(255,0,136,0.3); border: 1px solid #ff0088; }
        .arrow {
            position: absolute;
            color: #666;
            font-size: 1rem;
        }
        .mode-desc {
            font-size: 0.85rem;
            color: #888;
            line-height: 1.5;
        }
        .security-rating {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .security-rating.bad { background: rgba(255,68,68,0.2); color: #ff4444; }
        .security-rating.good { background: rgba(0,255,136,0.2); color: #00ff88; }
        .demo-section {
            background: rgba(0,255,136,0.05);
            padding: 20px;
            border-radius: 10px;
            margin-top: 30px;
        }
        .demo-section h3 { color: #00ccff; margin-bottom: 15px; text-align: center; }
        .image-demo {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        .image-box {
            text-align: center;
        }
        .image-box canvas {
            border: 1px solid #00ff88;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        .image-box .label {
            font-size: 0.85rem;
            color: #888;
        }
        button {
            display: block;
            margin: 20px auto;
            padding: 12px 30px;
            font-size: 1rem;
            font-family: inherit;
            background: rgba(0,255,136,0.1);
            border: 1px solid #00ff88;
            color: #00ff88;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover { background: rgba(0,255,136,0.3); }
        .info { margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px; }
        .info p { color: #aaa; font-size: 0.9rem; line-height: 1.6; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div class="container">
        <h1>Block Cipher Modes</h1>
        <p class="subtitle">Comparing ECB, CBC, and CTR modes of operation</p>

        <div class="modes-grid">
            <div class="mode-box">
                <h3>ECB (Electronic Codebook)</h3>
                <div class="mode-diagram" id="ecbDiagram">
                    <div class="block plaintext" style="left:10px;top:10px;">P1</div>
                    <div class="block plaintext" style="left:80px;top:10px;">P2</div>
                    <div class="block plaintext" style="left:150px;top:10px;">P3</div>
                    <div class="arrow" style="left:30px;top:55px;">↓</div>
                    <div class="arrow" style="left:100px;top:55px;">↓</div>
                    <div class="arrow" style="left:170px;top:55px;">↓</div>
                    <div class="block encrypt" style="left:10px;top:70px;">E(K)</div>
                    <div class="block encrypt" style="left:80px;top:70px;">E(K)</div>
                    <div class="block encrypt" style="left:150px;top:70px;">E(K)</div>
                    <div class="arrow" style="left:30px;top:115px;">↓</div>
                    <div class="arrow" style="left:100px;top:115px;">↓</div>
                    <div class="arrow" style="left:170px;top:115px;">↓</div>
                    <div class="block ciphertext" style="left:10px;top:130px;">C1</div>
                    <div class="block ciphertext" style="left:80px;top:130px;">C2</div>
                    <div class="block ciphertext" style="left:150px;top:130px;">C3</div>
                </div>
                <div class="mode-desc">
                    Each block encrypted independently with same key. Identical plaintext blocks produce identical ciphertext blocks.
                </div>
                <div class="security-rating bad">⚠️ INSECURE - Patterns preserved</div>
            </div>

            <div class="mode-box">
                <h3>CBC (Cipher Block Chaining)</h3>
                <div class="mode-diagram" id="cbcDiagram">
                    <div class="block iv" style="left:10px;top:5px;">IV</div>
                    <div class="block plaintext" style="left:10px;top:35px;">P1</div>
                    <div class="block plaintext" style="left:80px;top:35px;">P2</div>
                    <div class="block plaintext" style="left:150px;top:35px;">P3</div>
                    <div class="block xor" style="left:25px;top:80px;">⊕</div>
                    <div class="block xor" style="left:95px;top:80px;">⊕</div>
                    <div class="block xor" style="left:165px;top:80px;">⊕</div>
                    <div class="block encrypt" style="left:10px;top:115px;">E(K)</div>
                    <div class="block encrypt" style="left:80px;top:115px;">E(K)</div>
                    <div class="block encrypt" style="left:150px;top:115px;">E(K)</div>
                    <div class="block ciphertext" style="left:10px;top:160px;">C1</div>
                    <div class="block ciphertext" style="left:80px;top:160px;">C2</div>
                    <div class="block ciphertext" style="left:150px;top:160px;">C3</div>
                </div>
                <div class="mode-desc">
                    Each block XORed with previous ciphertext before encryption. IV provides randomization.
                </div>
                <div class="security-rating good">✓ Secure - Patterns hidden</div>
            </div>

            <div class="mode-box">
                <h3>CTR (Counter Mode)</h3>
                <div class="mode-diagram" id="ctrDiagram">
                    <div class="block iv" style="left:10px;top:5px;">N|1</div>
                    <div class="block iv" style="left:80px;top:5px;">N|2</div>
                    <div class="block iv" style="left:150px;top:5px;">N|3</div>
                    <div class="arrow" style="left:30px;top:50px;">↓</div>
                    <div class="arrow" style="left:100px;top:50px;">↓</div>
                    <div class="arrow" style="left:170px;top:50px;">↓</div>
                    <div class="block encrypt" style="left:10px;top:60px;">E(K)</div>
                    <div class="block encrypt" style="left:80px;top:60px;">E(K)</div>
                    <div class="block encrypt" style="left:150px;top:60px;">E(K)</div>
                    <div class="block xor" style="left:25px;top:110px;">⊕</div>
                    <div class="block xor" style="left:95px;top:110px;">⊕</div>
                    <div class="block xor" style="left:165px;top:110px;">⊕</div>
                    <div class="block plaintext" style="left:70px;top:100px;width:40px;height:25px;font-size:0.6rem;">P</div>
                    <div class="block ciphertext" style="left:10px;top:150px;">C1</div>
                    <div class="block ciphertext" style="left:80px;top:150px;">C2</div>
                    <div class="block ciphertext" style="left:150px;top:150px;">C3</div>
                </div>
                <div class="mode-desc">
                    Encrypts counter values, XORs with plaintext. Parallelizable and allows random access.
                </div>
                <div class="security-rating good">✓ Secure - Stream cipher mode</div>
            </div>
        </div>

        <div class="demo-section">
            <h3>ECB Penguin Demo - Why Patterns Matter</h3>
            <p style="color:#888;text-align:center;margin-bottom:20px;">
                The famous "ECB Penguin" demonstrates why ECB mode is dangerous for images
            </p>
            <button onclick="generateDemo()">Generate Demo Image</button>
            <div class="image-demo">
                <div class="image-box">
                    <canvas id="original" width="128" height="128"></canvas>
                    <div class="label">Original Image</div>
                </div>
                <div class="image-box">
                    <canvas id="ecb" width="128" height="128"></canvas>
                    <div class="label">ECB Encrypted</div>
                </div>
                <div class="image-box">
                    <canvas id="cbc" width="128" height="128"></canvas>
                    <div class="label">CBC Encrypted</div>
                </div>
                <div class="image-box">
                    <canvas id="ctr" width="128" height="128"></canvas>
                    <div class="label">CTR Encrypted</div>
                </div>
            </div>
            <div class="info">
                <p>Notice how ECB preserves the image patterns because identical blocks produce identical ciphertext.
                CBC and CTR produce random-looking output that hides all patterns. This is why ECB should never be used
                for encrypting data with patterns or structure.</p>
            </div>
        </div>
    </div>

    <script>
        function generateDemo() {
            const original = document.getElementById('original');
            const ecb = document.getElementById('ecb');
            const cbc = document.getElementById('cbc');
            const ctr = document.getElementById('ctr');

            const ctxOrig = original.getContext('2d');
            const ctxEcb = ecb.getContext('2d');
            const ctxCbc = cbc.getContext('2d');
            const ctxCtr = ctr.getContext('2d');

            const size = 128;

            // Generate original image with patterns (simple shape)
            ctxOrig.fillStyle = '#1a1a2e';
            ctxOrig.fillRect(0, 0, size, size);

            // Draw a simple penguin-like shape
            ctxOrig.fillStyle = '#ffffff';
            ctxOrig.beginPath();
            ctxOrig.ellipse(64, 50, 30, 35, 0, 0, Math.PI * 2);
            ctxOrig.fill();

            ctxOrig.fillStyle = '#000000';
            ctxOrig.beginPath();
            ctxOrig.ellipse(64, 45, 25, 30, 0, 0, Math.PI * 2);
            ctxOrig.fill();

            ctxOrig.fillStyle = '#ffffff';
            ctxOrig.beginPath();
            ctxOrig.ellipse(64, 55, 15, 20, 0, 0, Math.PI * 2);
            ctxOrig.fill();

            // Eyes
            ctxOrig.fillStyle = '#ffffff';
            ctxOrig.beginPath();
            ctxOrig.arc(55, 35, 5, 0, Math.PI * 2);
            ctxOrig.arc(73, 35, 5, 0, Math.PI * 2);
            ctxOrig.fill();

            ctxOrig.fillStyle = '#000000';
            ctxOrig.beginPath();
            ctxOrig.arc(55, 35, 2, 0, Math.PI * 2);
            ctxOrig.arc(73, 35, 2, 0, Math.PI * 2);
            ctxOrig.fill();

            // Beak
            ctxOrig.fillStyle = '#ff8800';
            ctxOrig.beginPath();
            ctxOrig.moveTo(64, 45);
            ctxOrig.lineTo(58, 55);
            ctxOrig.lineTo(70, 55);
            ctxOrig.closePath();
            ctxOrig.fill();

            // Body
            ctxOrig.fillStyle = '#000000';
            ctxOrig.beginPath();
            ctxOrig.ellipse(64, 95, 25, 30, 0, 0, Math.PI * 2);
            ctxOrig.fill();

            ctxOrig.fillStyle = '#ffffff';
            ctxOrig.beginPath();
            ctxOrig.ellipse(64, 100, 15, 20, 0, 0, Math.PI * 2);
            ctxOrig.fill();

            // Get image data
            const origData = ctxOrig.getImageData(0, 0, size, size);

            // Simple "encryption" simulation
            const blockSize = 8;
            const key = Math.random() * 1000000;

            // ECB - same blocks produce same output
            const ecbData = ctxEcb.createImageData(size, size);
            for (let by = 0; by < size; by += blockSize) {
                for (let bx = 0; bx < size; bx += blockSize) {
                    let blockHash = 0;
                    for (let y = by; y < by + blockSize && y < size; y++) {
                        for (let x = bx; x < bx + blockSize && x < size; x++) {
                            const i = (y * size + x) * 4;
                            blockHash += origData.data[i] + origData.data[i+1] + origData.data[i+2];
                        }
                    }
                    // Hash determines color (same input = same output)
                    const hue = (blockHash * key) % 360;
                    const rgb = hslToRgb(hue / 360, 0.7, 0.5);

                    for (let y = by; y < by + blockSize && y < size; y++) {
                        for (let x = bx; x < bx + blockSize && x < size; x++) {
                            const i = (y * size + x) * 4;
                            ecbData.data[i] = rgb[0];
                            ecbData.data[i+1] = rgb[1];
                            ecbData.data[i+2] = rgb[2];
                            ecbData.data[i+3] = 255;
                        }
                    }
                }
            }
            ctxEcb.putImageData(ecbData, 0, 0);

            // CBC - chained, random looking
            const cbcData = ctxCbc.createImageData(size, size);
            let prevBlock = Math.random() * 1000;
            for (let by = 0; by < size; by += blockSize) {
                for (let bx = 0; bx < size; bx += blockSize) {
                    let blockHash = prevBlock;
                    for (let y = by; y < by + blockSize && y < size; y++) {
                        for (let x = bx; x < bx + blockSize && x < size; x++) {
                            const i = (y * size + x) * 4;
                            blockHash += origData.data[i] + origData.data[i+1] + origData.data[i+2];
                        }
                    }
                    const hue = (blockHash * key) % 360;
                    const rgb = hslToRgb(hue / 360, 0.7, 0.5);
                    prevBlock = blockHash;

                    for (let y = by; y < by + blockSize && y < size; y++) {
                        for (let x = bx; x < bx + blockSize && x < size; x++) {
                            const i = (y * size + x) * 4;
                            cbcData.data[i] = rgb[0];
                            cbcData.data[i+1] = rgb[1];
                            cbcData.data[i+2] = rgb[2];
                            cbcData.data[i+3] = 255;
                        }
                    }
                }
            }
            ctxCbc.putImageData(cbcData, 0, 0);

            // CTR - counter based, random looking
            const ctrData = ctxCtr.createImageData(size, size);
            let counter = 0;
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const i = (y * size + x) * 4;
                    counter++;
                    const stream = pseudoRandom(counter + key);
                    ctrData.data[i] = (origData.data[i] + stream * 256) % 256;
                    ctrData.data[i+1] = (origData.data[i+1] + stream * 512) % 256;
                    ctrData.data[i+2] = (origData.data[i+2] + stream * 768) % 256;
                    ctrData.data[i+3] = 255;
                }
            }
            ctxCtr.putImageData(ctrData, 0, 0);
        }

        function pseudoRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        // Generate on load
        generateDemo();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
