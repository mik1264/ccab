<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AES Step Visualization - SubBytes, ShiftRows, MixColumns</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #00ff88;
            min-height: 100vh;
            padding: 20px;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00ff88;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(0,255,136,0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            z-index: 100;
        }
        .back-link:hover { background: rgba(0,255,136,0.2); }
        .container {
            max-width: 1200px;
            margin: 60px auto 0;
            text-align: center;
        }
        h1 { font-size: 2rem; margin-bottom: 10px; }
        .subtitle { color: #888; margin-bottom: 30px; }
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        button {
            padding: 12px 25px;
            font-size: 1rem;
            font-family: inherit;
            background: rgba(0,255,136,0.1);
            border: 1px solid #00ff88;
            color: #00ff88;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover { background: rgba(0,255,136,0.3); }
        button.active { background: rgba(0,255,136,0.4); }
        .state-display {
            display: flex;
            justify-content: center;
            gap: 60px;
            flex-wrap: wrap;
            margin-bottom: 30px;
        }
        .state-box {
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #00ff88;
        }
        .state-box h3 {
            margin-bottom: 15px;
            color: #00ccff;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(4, 50px);
            gap: 5px;
        }
        .cell {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,255,136,0.1);
            border: 1px solid #00ff88;
            font-size: 0.9rem;
            transition: all 0.3s;
        }
        .cell.highlight { background: rgba(255,255,0,0.3); border-color: #ffff00; }
        .cell.row-0 { background: rgba(255,0,0,0.2); }
        .cell.row-1 { background: rgba(0,255,0,0.2); }
        .cell.row-2 { background: rgba(0,0,255,0.2); }
        .cell.row-3 { background: rgba(255,0,255,0.2); }
        .step-info {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: rgba(0,255,136,0.05);
            border-radius: 10px;
            text-align: left;
        }
        .step-info h3 { color: #00ccff; margin-bottom: 10px; }
        .step-info p { color: #aaa; line-height: 1.6; }
        .round-indicator {
            font-size: 1.2rem;
            margin-bottom: 20px;
            color: #00ccff;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div class="container">
        <h1>AES Step Visualization</h1>
        <p class="subtitle">Advanced Encryption Standard - 128-bit Block Cipher</p>

        <div class="round-indicator">Round: <span id="round">0</span>/10</div>

        <div class="controls">
            <button onclick="reset()">Reset</button>
            <button onclick="doSubBytes()">SubBytes</button>
            <button onclick="doShiftRows()">ShiftRows</button>
            <button onclick="doMixColumns()">MixColumns</button>
            <button onclick="doAddRoundKey()">AddRoundKey</button>
            <button onclick="autoRun()">Auto Run</button>
        </div>

        <div class="state-display">
            <div class="state-box">
                <h3>Current State</h3>
                <div class="grid" id="stateGrid"></div>
            </div>
            <div class="state-box">
                <h3>Round Key</h3>
                <div class="grid" id="keyGrid"></div>
            </div>
        </div>

        <div class="step-info" id="stepInfo">
            <h3>AES Overview</h3>
            <p>AES operates on a 4×4 matrix of bytes called the "state". Each round applies four transformations:
            SubBytes (byte substitution using S-box), ShiftRows (row rotation), MixColumns (column mixing),
            and AddRoundKey (XOR with round key). AES-128 uses 10 rounds with a 128-bit key.</p>
        </div>
    </div>

    <script>
        // AES S-Box (first two rows for demo)
        const SBOX = [
            0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
            0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0
        ];

        let state = [];
        let roundKey = [];
        let currentRound = 0;
        let isAnimating = false;

        function init() {
            // Initialize with sample plaintext
            state = [
                [0x32, 0x88, 0x31, 0xe0],
                [0x43, 0x5a, 0x31, 0x37],
                [0xf6, 0x30, 0x98, 0x07],
                [0xa8, 0x8d, 0xa2, 0x34]
            ];

            // Sample round key
            roundKey = [
                [0x2b, 0x28, 0xab, 0x09],
                [0x7e, 0xae, 0xf7, 0xcf],
                [0x15, 0xd2, 0x15, 0x4f],
                [0x16, 0xa6, 0x88, 0x3c]
            ];

            currentRound = 0;
            renderGrids();
            updateRound();
        }

        function renderGrids() {
            const stateGrid = document.getElementById('stateGrid');
            const keyGrid = document.getElementById('keyGrid');

            stateGrid.innerHTML = '';
            keyGrid.innerHTML = '';

            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const stateCell = document.createElement('div');
                    stateCell.className = `cell row-${row}`;
                    stateCell.textContent = state[row][col].toString(16).padStart(2, '0').toUpperCase();
                    stateCell.id = `state-${row}-${col}`;
                    stateGrid.appendChild(stateCell);

                    const keyCell = document.createElement('div');
                    keyCell.className = 'cell';
                    keyCell.textContent = roundKey[row][col].toString(16).padStart(2, '0').toUpperCase();
                    keyGrid.appendChild(keyCell);
                }
            }
        }

        function updateRound() {
            document.getElementById('round').textContent = currentRound;
        }

        function reset() {
            init();
            document.getElementById('stepInfo').innerHTML = `
                <h3>AES Overview</h3>
                <p>AES operates on a 4×4 matrix of bytes called the "state". Each round applies four transformations:
                SubBytes (byte substitution using S-box), ShiftRows (row rotation), MixColumns (column mixing),
                and AddRoundKey (XOR with round key). AES-128 uses 10 rounds with a 128-bit key.</p>
            `;
        }

        function doSubBytes() {
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const val = state[row][col];
                    state[row][col] = SBOX[val % SBOX.length];
                }
            }
            renderGrids();

            document.getElementById('stepInfo').innerHTML = `
                <h3>SubBytes Transformation</h3>
                <p>Each byte in the state is replaced with its corresponding value from the S-Box (Substitution Box).
                The S-Box is a 16×16 lookup table designed to be resistant to linear and differential cryptanalysis.
                It provides non-linearity to the cipher, which is crucial for security.</p>
            `;
        }

        function doShiftRows() {
            // Row 0: no shift
            // Row 1: shift left by 1
            state[1] = [state[1][1], state[1][2], state[1][3], state[1][0]];
            // Row 2: shift left by 2
            state[2] = [state[2][2], state[2][3], state[2][0], state[2][1]];
            // Row 3: shift left by 3
            state[3] = [state[3][3], state[3][0], state[3][1], state[3][2]];

            renderGrids();

            document.getElementById('stepInfo').innerHTML = `
                <h3>ShiftRows Transformation</h3>
                <p>Each row of the state is cyclically shifted to the left by a different offset:
                Row 0 stays unchanged, Row 1 shifts by 1 byte, Row 2 shifts by 2 bytes, and Row 3 shifts by 3 bytes.
                This step provides diffusion by spreading the influence of each byte across columns.</p>
            `;
        }

        function doMixColumns() {
            // Simplified MixColumns (demonstration)
            const newState = [];
            for (let row = 0; row < 4; row++) {
                newState[row] = [];
                for (let col = 0; col < 4; col++) {
                    // Simplified mixing
                    let sum = 0;
                    for (let k = 0; k < 4; k++) {
                        sum ^= state[k][col];
                    }
                    newState[row][col] = sum ^ state[row][col];
                }
            }
            state = newState;
            renderGrids();

            document.getElementById('stepInfo').innerHTML = `
                <h3>MixColumns Transformation</h3>
                <p>Each column is treated as a polynomial over GF(2^8) and multiplied by a fixed polynomial.
                This step mixes the bytes within each column, providing diffusion across the entire state.
                It's mathematically equivalent to matrix multiplication in Galois Field arithmetic.</p>
            `;
        }

        function doAddRoundKey() {
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    state[row][col] ^= roundKey[row][col];
                }
            }

            // Generate new round key (simplified)
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    roundKey[row][col] = (roundKey[row][col] * 2 + row + col) % 256;
                }
            }

            currentRound++;
            renderGrids();
            updateRound();

            document.getElementById('stepInfo').innerHTML = `
                <h3>AddRoundKey Transformation</h3>
                <p>The state is XORed with the current round key. This is the only step that introduces the key material.
                Round keys are derived from the original key through a key expansion algorithm.
                This simple XOR operation is reversible and provides the connection to the secret key.</p>
            `;
        }

        async function autoRun() {
            if (isAnimating) return;
            isAnimating = true;

            reset();
            await sleep(500);

            for (let round = 0; round < 10; round++) {
                doSubBytes();
                await sleep(400);
                doShiftRows();
                await sleep(400);
                if (round < 9) {
                    doMixColumns();
                    await sleep(400);
                }
                doAddRoundKey();
                await sleep(600);
            }

            isAnimating = false;
            document.getElementById('stepInfo').innerHTML = `
                <h3>Encryption Complete!</h3>
                <p>All 10 rounds of AES-128 have been completed. The final state represents the encrypted ciphertext.
                Note that the last round omits MixColumns as specified in the AES standard.
                To decrypt, the inverse operations are applied in reverse order.</p>
            `;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        init();
    </script>
</body>
</html>
