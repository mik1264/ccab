<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Instanced Geometry - 100k+ Cubes</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(76, 201, 240, 0.8);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-family: Arial;
            z-index: 10;
        }
        .info {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: Arial;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10;
        }
        .info div { margin: 5px 0; }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">‚Üê Back</a>
    <div class="info">
        <div><strong>Instanced Geometry</strong></div>
        <div id="count">Instances: 100,000</div>
        <div>Mouse: Rotate camera</div>
        <div>Scroll: Zoom</div>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.149.0/build/three.module.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.149.0/examples/jsm/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.Fog(0x0a0a0a, 50, 200);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(50, 50, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Create instanced mesh with 100,000 cubes
        const instanceCount = 100000;
        const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const material = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            shininess: 100,
            specular: 0x222222
        });

        const mesh = new THREE.InstancedMesh(geometry, material, instanceCount);

        // Create a color attribute for each instance
        const colors = new Float32Array(instanceCount * 3);

        // Position instances in a dynamic formation
        const dummy = new THREE.Object3D();
        const radius = 40;

        for (let i = 0; i < instanceCount; i++) {
            // Spherical distribution with some noise
            const phi = Math.acos(2 * Math.random() - 1);
            const theta = Math.random() * Math.PI * 2;

            const r = radius * (0.5 + Math.random() * 0.5);

            dummy.position.x = r * Math.sin(phi) * Math.cos(theta);
            dummy.position.y = r * Math.sin(phi) * Math.sin(theta);
            dummy.position.z = r * Math.cos(phi);

            dummy.rotation.x = Math.random() * Math.PI;
            dummy.rotation.y = Math.random() * Math.PI;
            dummy.rotation.z = Math.random() * Math.PI;

            const scale = 0.5 + Math.random() * 0.5;
            dummy.scale.set(scale, scale, scale);

            dummy.updateMatrix();
            mesh.setMatrixAt(i, dummy.matrix);

            // Set instance color based on position
            const hue = (Math.atan2(dummy.position.y, dummy.position.x) + Math.PI) / (Math.PI * 2);
            const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
        }

        geometry.setAttribute('color', new THREE.InstancedBufferAttribute(colors, 3));
        material.vertexColors = true;

        scene.add(mesh);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0xff0040, 1, 200);
        pointLight1.position.set(50, 50, 50);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0x0040ff, 1, 200);
        pointLight2.position.set(-50, -50, 50);
        scene.add(pointLight2);

        const pointLight3 = new THREE.PointLight(0x40ff00, 1, 200);
        pointLight3.position.set(0, 50, -50);
        scene.add(pointLight3);

        // Animation
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.0001;

            // Animate instances
            for (let i = 0; i < instanceCount; i++) {
                mesh.getMatrixAt(i, dummy.matrix);
                dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);

                // Gentle rotation
                dummy.rotation.x += 0.001;
                dummy.rotation.y += 0.001;

                // Pulsing wave effect
                const distance = Math.sqrt(
                    dummy.position.x ** 2 +
                    dummy.position.y ** 2 +
                    dummy.position.z ** 2
                );
                const wave = Math.sin(distance * 0.1 - time * 2) * 0.02;
                const scale = dummy.scale.x + wave;
                dummy.scale.set(scale, scale, scale);

                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            }

            mesh.instanceMatrix.needsUpdate = true;

            // Rotate lights
            pointLight1.position.x = Math.cos(time * 0.7) * 50;
            pointLight1.position.z = Math.sin(time * 0.7) * 50;

            pointLight2.position.x = Math.cos(time * 0.5 + Math.PI) * 50;
            pointLight2.position.y = Math.sin(time * 0.5 + Math.PI) * 50;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
