<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Constellation 100 - Grand Finale</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: linear-gradient(135deg, #ff0000, #ff7700, #ffff00, #00ff00, #0077ff, #7700ff);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-family: Arial;
            font-weight: bold;
        }
        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #fff;
            font-family: Arial;
            font-size: 14px;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">‚Üê Back</a>
    <div class="info">100 - Grand Finale: Multi-Effect Showcase</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.008);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Multiple particle systems for layered effect
        const systems = [];

        // System 1: Central sphere with color waves
        const count1 = 300;
        const geo1 = new THREE.BufferGeometry();
        const pos1 = new Float32Array(count1 * 3);
        const col1 = new Float32Array(count1 * 3);
        const data1 = [];

        for (let i = 0; i < count1; i++) {
            const phi = Math.acos(2 * Math.random() - 1);
            const theta = Math.random() * Math.PI * 2;
            const r = 10;
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            data1.push({ x, y, z, phi, theta, r });
            pos1[i * 3] = x;
            pos1[i * 3 + 1] = y;
            pos1[i * 3 + 2] = z;
        }

        geo1.setAttribute('position', new THREE.BufferAttribute(pos1, 3));
        geo1.setAttribute('color', new THREE.BufferAttribute(col1, 3));

        const mat1 = new THREE.PointsMaterial({
            size: 0.5,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending
        });

        const sys1 = new THREE.Points(geo1, mat1);
        scene.add(sys1);
        systems.push({ system: sys1, geo: geo1, data: data1, type: 'sphere' });

        // System 2: Orbiting ring
        const count2 = 200;
        const geo2 = new THREE.BufferGeometry();
        const pos2 = new Float32Array(count2 * 3);
        const col2 = new Float32Array(count2 * 3);
        const data2 = [];

        for (let i = 0; i < count2; i++) {
            const angle = (i / count2) * Math.PI * 2;
            const r = 20 + Math.random() * 2;
            data2.push({ angle, r, offsetY: (Math.random() - 0.5) * 2 });
        }

        geo2.setAttribute('position', new THREE.BufferAttribute(pos2, 3));
        geo2.setAttribute('color', new THREE.BufferAttribute(col2, 3));

        const mat2 = new THREE.PointsMaterial({
            size: 0.4,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        const sys2 = new THREE.Points(geo2, mat2);
        scene.add(sys2);
        systems.push({ system: sys2, geo: geo2, data: data2, type: 'ring' });

        // System 3: Starfield background
        const count3 = 500;
        const geo3 = new THREE.BufferGeometry();
        const pos3 = new Float32Array(count3 * 3);
        const col3 = new Float32Array(count3 * 3);
        const data3 = [];

        for (let i = 0; i < count3; i++) {
            const x = (Math.random() - 0.5) * 100;
            const y = (Math.random() - 0.5) * 100;
            const z = -20 - Math.random() * 40;

            data3.push({ x, y, z, twinkle: Math.random() * Math.PI * 2 });
            pos3[i * 3] = x;
            pos3[i * 3 + 1] = y;
            pos3[i * 3 + 2] = z;

            col3[i * 3] = 1;
            col3[i * 3 + 1] = 1;
            col3[i * 3 + 2] = 1;
        }

        geo3.setAttribute('position', new THREE.BufferAttribute(pos3, 3));
        geo3.setAttribute('color', new THREE.BufferAttribute(col3, 3));

        const mat3 = new THREE.PointsMaterial({
            size: 0.2,
            vertexColors: true,
            transparent: true,
            opacity: 0.6
        });

        const sys3 = new THREE.Points(geo3, mat3);
        scene.add(sys3);
        systems.push({ system: sys3, geo: geo3, data: data3, type: 'stars' });

        // Connection lines for central sphere
        const lineGeo = new THREE.BufferGeometry();
        const linePositions = new Float32Array(count1 * count1 * 6);
        const lineMat = new THREE.LineBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.15,
            blending: THREE.AdditiveBlending
        });
        const lines = new THREE.LineSegments(lineGeo, lineMat);
        scene.add(lines);

        camera.position.z = 40;

        let time = 0;

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) { r = g = b = l; }
            else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [r, g, b];
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.02;

            // Update central sphere with pulsing and color waves
            const pulse = 1 + 0.2 * Math.sin(time);
            const spherePos = systems[0].geo.attributes.position.array;
            const sphereCol = systems[0].geo.attributes.color.array;

            for (let i = 0; i < count1; i++) {
                const d = data1[i];
                const r = d.r * pulse + Math.sin(d.phi * 5 + time * 2) * 0.5;

                spherePos[i * 3] = r * Math.sin(d.phi) * Math.cos(d.theta + time * 0.5);
                spherePos[i * 3 + 1] = r * Math.sin(d.phi) * Math.sin(d.theta + time * 0.5);
                spherePos[i * 3 + 2] = r * Math.cos(d.phi);

                const hue = (d.phi / Math.PI + time * 0.1) % 1;
                const [cr, cg, cb] = hslToRgb(hue, 1, 0.5);
                sphereCol[i * 3] = cr;
                sphereCol[i * 3 + 1] = cg;
                sphereCol[i * 3 + 2] = cb;
            }
            systems[0].geo.attributes.position.needsUpdate = true;
            systems[0].geo.attributes.color.needsUpdate = true;

            // Update orbiting ring
            const ringPos = systems[1].geo.attributes.position.array;
            const ringCol = systems[1].geo.attributes.color.array;

            for (let i = 0; i < count2; i++) {
                const d = data2[i];
                const angle = d.angle + time;

                ringPos[i * 3] = Math.cos(angle) * d.r;
                ringPos[i * 3 + 1] = d.offsetY + Math.sin(time * 3 + d.angle * 5) * 0.5;
                ringPos[i * 3 + 2] = Math.sin(angle) * d.r;

                const hue = (d.angle / (Math.PI * 2) + time * 0.2) % 1;
                const [cr, cg, cb] = hslToRgb(hue, 1, 0.6);
                ringCol[i * 3] = cr;
                ringCol[i * 3 + 1] = cg;
                ringCol[i * 3 + 2] = cb;
            }
            systems[1].geo.attributes.position.needsUpdate = true;
            systems[1].geo.attributes.color.needsUpdate = true;

            // Update twinkling stars
            const starsCol = systems[2].geo.attributes.color.array;
            for (let i = 0; i < count3; i++) {
                const twinkle = 0.3 + 0.7 * Math.pow((Math.sin(time * 3 + data3[i].twinkle) + 1) / 2, 2);
                starsCol[i * 3] = twinkle;
                starsCol[i * 3 + 1] = twinkle;
                starsCol[i * 3 + 2] = twinkle;
            }
            systems[2].geo.attributes.color.needsUpdate = true;

            // Update connection lines
            const linePos = [];
            for (let i = 0; i < count1; i++) {
                for (let j = i + 1; j < count1; j++) {
                    const x1 = spherePos[i * 3], y1 = spherePos[i * 3 + 1], z1 = spherePos[i * 3 + 2];
                    const x2 = spherePos[j * 3], y2 = spherePos[j * 3 + 1], z2 = spherePos[j * 3 + 2];
                    const dist = Math.sqrt((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2);

                    if (dist < 3) {
                        linePos.push(x1, y1, z1, x2, y2, z2);
                    }
                }
            }
            lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePos, 3));

            // Camera movement
            camera.position.x = Math.sin(time * 0.3) * 5;
            camera.position.y = Math.cos(time * 0.2) * 3;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
