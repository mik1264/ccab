<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projective Plane Crosscap Viewer - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0e1a;
            color: #e8e6e1;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            color: #fbbf24;
            text-decoration: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 500;
            z-index: 1000;
            transition: all 0.3s ease;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .back-link:hover {
            background: rgba(251, 191, 36, 0.2);
            transform: translateX(-5px);
        }

        .controls {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            z-index: 1000;
            max-width: 300px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls h2 {
            font-size: 16px;
            color: #fbbf24;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 5px;
        }

        .control-group select,
        .control-group input[type="range"] {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-size: 13px;
        }

        .control-group select option {
            background: #1a1a2e;
        }

        .control-group input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            padding: 0;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #fbbf24;
            border-radius: 50%;
            cursor: pointer;
        }

        .checkbox-group {
            display: flex;
            gap: 10px;
            flex-direction: column;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 12px;
            color: #ccc;
        }

        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #fbbf24;
        }

        .info-panel {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px 20px;
            z-index: 1000;
            max-width: 420px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-panel h3 {
            color: #fbbf24;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .info-panel p {
            font-size: 11px;
            color: #aaa;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .formula {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            margin-top: 10px;
        }

        .feature-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 12px;
        }

        .feature {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 10px;
            color: #fbbf24;
        }

        .legend {
            display: flex;
            gap: 15px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: #aaa;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        @media (max-width: 768px) {
            .controls {
                max-width: 260px;
                padding: 15px;
            }

            .info-panel {
                max-width: calc(100% - 30px);
                bottom: 10px;
                left: 10px;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <div id="container"></div>

    <div class="controls">
        <h2>Crosscap Explorer</h2>

        <div class="control-group">
            <label>Color Mode</label>
            <select id="colorMode">
                <option value="sides">Two-Sided Color</option>
                <option value="orientation">Orientation Flow</option>
                <option value="uv">Parameter Space</option>
                <option value="distance">Distance from Origin</option>
                <option value="wireframe">Wireframe</option>
            </select>
        </div>

        <div class="control-group">
            <label>Scale: <span id="scaleVal">1.0</span></label>
            <input type="range" id="scale" min="0.5" max="2" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>Resolution: <span id="resVal">80</span></label>
            <input type="range" id="resolution" min="20" max="150" step="10" value="80">
        </div>

        <div class="control-group">
            <label>Rotation Speed: <span id="speedVal">0.5</span></label>
            <input type="range" id="speed" min="0" max="20" value="5">
        </div>

        <div class="control-group checkbox-group">
            <label>
                <input type="checkbox" id="showSelfIntersection" checked>
                Highlight Self-Intersection
            </label>
            <label>
                <input type="checkbox" id="showLoop">
                Show Orientation Loop
            </label>
            <label>
                <input type="checkbox" id="showPinchPoints">
                Show Pinch Points
            </label>
        </div>
    </div>

    <div class="info-panel">
        <h3>Projective Plane: Crosscap Immersion</h3>
        <p>
            The real projective plane RP² cannot be embedded in 3D without self-intersection.
            The crosscap is an immersion showing its non-orientable nature - a path along
            the surface can reverse orientation (like a Möbius strip).
        </p>
        <div class="formula">
            x = ½·cos(u)·sin(2v) &nbsp;&nbsp; y = ½·sin(u)·sin(2v) &nbsp;&nbsp; z = ½·(cos²v - cos²u·sin²v)
        </div>

        <div class="feature-list">
            <span class="feature">Non-orientable</span>
            <span class="feature">Self-intersecting</span>
            <span class="feature">Two Pinch Points</span>
            <span class="feature">RP²</span>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #ff6b6b;"></div>
                Self-intersection line
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #fbbf24;"></div>
                Pinch points (Whitney umbrella)
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let crosscapMesh, selfIntersectionLine, orientationLoop, pinchPointMarkers;
        let surfaceScale = 1.0;
        let resolution = 80;
        let rotationSpeed = 0.005;
        let colorMode = 'sides';
        let showSelfIntersection = true;
        let showLoop = false;
        let showPinchPoints = false;

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0e1a);

            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(2, 1.5, 2);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1;

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0x8888ff, 0.4);
            directionalLight2.position.set(-5, -5, -5);
            scene.add(directionalLight2);

            const pointLight = new THREE.PointLight(0xffffff, 0.5, 10);
            pointLight.position.set(0, 2, 0);
            scene.add(pointLight);

            // Create surface
            createCrosscapSurface();
            createSelfIntersectionLine();
            createPinchPointMarkers();

            // Handle resize
            window.addEventListener('resize', onWindowResize);

            // Setup controls
            setupControls();

            // Start animation
            animate();
        }

        // Crosscap parametric equations (Pinkall form)
        function crosscapX(u, v) {
            return 0.5 * Math.cos(u) * Math.sin(2 * v) * surfaceScale;
        }

        function crosscapY(u, v) {
            return 0.5 * Math.sin(u) * Math.sin(2 * v) * surfaceScale;
        }

        function crosscapZ(u, v) {
            return 0.5 * (Math.cos(v) * Math.cos(v) - Math.cos(u) * Math.cos(u) * Math.sin(v) * Math.sin(v)) * surfaceScale;
        }

        // Create crosscap surface mesh
        function createCrosscapSurface() {
            if (crosscapMesh) {
                scene.remove(crosscapMesh);
                crosscapMesh.geometry.dispose();
                crosscapMesh.material.dispose();
            }

            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            const indices = [];
            const normals = [];

            const segments = resolution;

            // Generate vertices
            for (let i = 0; i <= segments; i++) {
                for (let j = 0; j <= segments; j++) {
                    const u = (i / segments) * 2 * Math.PI;
                    const v = (j / segments) * Math.PI / 2;

                    const x = crosscapX(u, v);
                    const y = crosscapY(u, v);
                    const z = crosscapZ(u, v);

                    vertices.push(x, y, z);

                    // Calculate color based on mode
                    const color = getVertexColor(u, v, x, y, z, i, j, segments);
                    colors.push(color.r, color.g, color.b);

                    // Calculate normals (approximate)
                    const eps = 0.01;
                    const dx_du = (crosscapX(u + eps, v) - crosscapX(u - eps, v)) / (2 * eps);
                    const dy_du = (crosscapY(u + eps, v) - crosscapY(u - eps, v)) / (2 * eps);
                    const dz_du = (crosscapZ(u + eps, v) - crosscapZ(u - eps, v)) / (2 * eps);

                    const dx_dv = (crosscapX(u, v + eps) - crosscapX(u, v - eps)) / (2 * eps);
                    const dy_dv = (crosscapY(u, v + eps) - crosscapY(u, v - eps)) / (2 * eps);
                    const dz_dv = (crosscapZ(u, v + eps) - crosscapZ(u, v - eps)) / (2 * eps);

                    // Cross product for normal
                    let nx = dy_du * dz_dv - dz_du * dy_dv;
                    let ny = dz_du * dx_dv - dx_du * dz_dv;
                    let nz = dx_du * dy_dv - dy_du * dx_dv;
                    const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;

                    normals.push(nx / len, ny / len, nz / len);
                }
            }

            // Generate indices
            for (let i = 0; i < segments; i++) {
                for (let j = 0; j < segments; j++) {
                    const a = i * (segments + 1) + j;
                    const b = a + segments + 1;
                    const c = a + 1;
                    const d = b + 1;

                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setIndex(indices);

            let material;
            if (colorMode === 'wireframe') {
                material = new THREE.MeshBasicMaterial({
                    color: 0xfbbf24,
                    wireframe: true
                });
            } else {
                material = new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    side: THREE.DoubleSide,
                    shininess: 50,
                    flatShading: false,
                    transparent: true,
                    opacity: 0.9
                });
            }

            crosscapMesh = new THREE.Mesh(geometry, material);
            scene.add(crosscapMesh);
        }

        function getVertexColor(u, v, x, y, z, i, j, segments) {
            const color = new THREE.Color();

            switch (colorMode) {
                case 'sides': {
                    // Show two-sided nature
                    const side = Math.sin(u) > 0 ? 0.55 : 0.15;
                    color.setHSL(side, 0.8, 0.5);
                    break;
                }

                case 'orientation': {
                    // Show orientation flow - how orientation reverses
                    const t = (u / (2 * Math.PI) + v / (Math.PI / 2)) % 1;
                    color.setHSL(t * 0.8, 0.9, 0.5);
                    break;
                }

                case 'uv': {
                    // Parameter space coloring
                    color.setRGB(
                        i / segments,
                        j / segments,
                        0.5
                    );
                    break;
                }

                case 'distance': {
                    // Distance from origin
                    const dist = Math.sqrt(x * x + y * y + z * z);
                    const maxDist = surfaceScale * 0.7;
                    const t = Math.min(1, dist / maxDist);
                    color.setHSL(0.6 - t * 0.4, 0.8, 0.5);
                    break;
                }

                default:
                    color.setHex(0xfbbf24);
            }

            return color;
        }

        // Create self-intersection line visualization
        function createSelfIntersectionLine() {
            if (selfIntersectionLine) {
                scene.remove(selfIntersectionLine);
                selfIntersectionLine.geometry.dispose();
                selfIntersectionLine.material.dispose();
            }

            if (!showSelfIntersection) return;

            // The self-intersection occurs where different (u,v) pairs map to the same (x,y,z)
            // For the crosscap, this is along a segment
            const points = [];
            const numPoints = 50;

            // Self-intersection occurs at v = π/4 for various u values
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                // Approximate the self-intersection curve
                const u = t * Math.PI;
                const v = Math.PI / 4;
                const x = crosscapX(u, v);
                const y = crosscapY(u, v);
                const z = crosscapZ(u, v);
                points.push(new THREE.Vector3(x, y, z));
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0xff6b6b,
                linewidth: 3
            });

            selfIntersectionLine = new THREE.Line(geometry, material);
            scene.add(selfIntersectionLine);
        }

        // Create orientation loop to show non-orientability
        function createOrientationLoop() {
            if (orientationLoop) {
                scene.remove(orientationLoop);
                orientationLoop.geometry.dispose();
                orientationLoop.material.dispose();
            }

            if (!showLoop) return;

            // Create a path that demonstrates orientation reversal
            const points = [];
            const numPoints = 100;

            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                // Path that loops around and shows orientation reversal
                const u = t * 2 * Math.PI;
                const v = Math.PI / 4 + Math.sin(t * 4 * Math.PI) * 0.15;
                const x = crosscapX(u, v);
                const y = crosscapY(u, v);
                const z = crosscapZ(u, v);
                points.push(new THREE.Vector3(x, y, z));
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0x10b981,
                linewidth: 2
            });

            orientationLoop = new THREE.Line(geometry, material);
            scene.add(orientationLoop);
        }

        // Create pinch point markers (Whitney umbrellas)
        function createPinchPointMarkers() {
            if (pinchPointMarkers) {
                pinchPointMarkers.forEach(marker => {
                    scene.remove(marker);
                    marker.geometry.dispose();
                    marker.material.dispose();
                });
            }

            pinchPointMarkers = [];

            if (!showPinchPoints) return;

            // Pinch points occur at v = 0 and v = π/2
            const pinchPositions = [
                { u: 0, v: 0 },
                { u: 0, v: Math.PI / 2 }
            ];

            pinchPositions.forEach(pos => {
                const x = crosscapX(pos.u, pos.v);
                const y = crosscapY(pos.u, pos.v);
                const z = crosscapZ(pos.u, pos.v);

                const geometry = new THREE.SphereGeometry(0.04, 16, 16);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xfbbf24,
                    transparent: true,
                    opacity: 0.9
                });
                const marker = new THREE.Mesh(geometry, material);
                marker.position.set(x, y, z);
                scene.add(marker);
                pinchPointMarkers.push(marker);

                // Add glow effect
                const glowGeometry = new THREE.SphereGeometry(0.06, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xfbbf24,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.set(x, y, z);
                scene.add(glow);
                pinchPointMarkers.push(glow);
            });
        }

        function setupControls() {
            document.getElementById('colorMode').addEventListener('change', (e) => {
                colorMode = e.target.value;
                createCrosscapSurface();
            });

            document.getElementById('scale').addEventListener('input', (e) => {
                surfaceScale = parseFloat(e.target.value);
                document.getElementById('scaleVal').textContent = surfaceScale.toFixed(1);
                createCrosscapSurface();
                createSelfIntersectionLine();
                createOrientationLoop();
                createPinchPointMarkers();
            });

            document.getElementById('resolution').addEventListener('input', (e) => {
                resolution = parseInt(e.target.value);
                document.getElementById('resVal').textContent = resolution;
                createCrosscapSurface();
            });

            document.getElementById('speed').addEventListener('input', (e) => {
                rotationSpeed = e.target.value / 1000;
                controls.autoRotateSpeed = e.target.value / 5;
                document.getElementById('speedVal').textContent = (e.target.value / 10).toFixed(1);
            });

            document.getElementById('showSelfIntersection').addEventListener('change', (e) => {
                showSelfIntersection = e.target.checked;
                createSelfIntersectionLine();
            });

            document.getElementById('showLoop').addEventListener('change', (e) => {
                showLoop = e.target.checked;
                createOrientationLoop();
            });

            document.getElementById('showPinchPoints').addEventListener('change', (e) => {
                showPinchPoints = e.target.checked;
                createPinchPointMarkers();
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Animate pinch point glow
            if (pinchPointMarkers) {
                const time = performance.now() * 0.002;
                pinchPointMarkers.forEach((marker, i) => {
                    if (i % 2 === 1) { // Glow markers
                        marker.scale.setScalar(1 + Math.sin(time * 2) * 0.3);
                    }
                });
            }

            renderer.render(scene, camera);
        }

        // Initialize
        init();
    </script>
</body>
</html>
