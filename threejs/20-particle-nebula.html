<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nebula Cloud - TSL Volumetric</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(76, 201, 240, 0.8);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-family: Arial;
            z-index: 10;
        }
        .tech-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">← Back</a>
    <div class="tech-badge">TSL Volumetric Nebula • MaterialX Noise • 30K Particles</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
            "three/nodes": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import {
            color,
            attribute,
            positionLocal,
            timerLocal,
            mul,
            add,
            sin,
            cos,
            mix,
            smoothstep,
            pow,
            vec3,
            vec4,
            float,
            length,
            clamp,
            fract
        } from 'three/nodes';
        import { mx_fractal_noise_vec3, mx_worley_noise_float } from 'three/nodes';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000510);
        scene.fog = new THREE.FogExp2(0x000510, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(10, 10, 25);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 60;

        // Create volumetric nebula particles
        const particleCount = 30000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        const densities = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
            // Volumetric cloud distribution using spherical coordinates
            const radius = Math.pow(Math.random(), 0.6) * 15;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(Math.random() * 2 - 1);

            // Add noise to position for wispy clouds
            const noise = (Math.random() - 0.5) * 6;
            positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta) + noise;
            positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta) + noise * 0.5;
            positions[i * 3 + 2] = radius * Math.cos(phi) + noise;

            // Nebula color palette: purple, blue, pink
            const colorType = Math.random();
            let r, g, b;
            if (colorType < 0.4) {
                // Blue
                r = 0.2; g = 0.4; b = 1.0;
            } else if (colorType < 0.7) {
                // Purple
                r = 0.6; g = 0.3; b = 1.0;
            } else {
                // Pink
                r = 1.0; g = 0.4; b = 0.7;
            }

            colors[i * 3] = r;
            colors[i * 3 + 1] = g;
            colors[i * 3 + 2] = b;

            // Varying sizes for depth perception
            sizes[i] = Math.random() * 0.3 + 0.1;

            // Density for opacity variation
            densities[i] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('aDensity', new THREE.BufferAttribute(densities, 1));

        // TSL volumetric material
        const particleColor = attribute('color', 'vec3');
        const particleSize = attribute('aSize', 'float');
        const particleDensity = attribute('aDensity', 'float');

        const time = timerLocal();
        const pos = positionLocal;

        // Volumetric noise for nebula swirls
        const noiseScale = float(0.1);
        const noiseTime = mul(time, float(0.1));
        const noisePos = add(mul(pos, noiseScale), vec3(noiseTime, noiseTime, mul(noiseTime, 0.5)));

        // Fractal noise for large-scale structure
        const fractalNoise = mx_fractal_noise_vec3(noisePos, float(3), float(2.0), float(0.5));

        // Worley noise for cellular structure
        const worleyPos = mul(pos, float(0.15));
        const worleyNoise = mx_worley_noise_float(worleyPos, float(1.0));

        // Combine noises for volumetric density
        const volumeDensity = mul(
            add(
                mul(fractalNoise.x, float(0.6)),
                mul(worleyNoise, float(0.4))
            ),
            particleDensity
        );

        // Pulsing glow effect
        const pulse = add(mul(sin(add(mul(time, float(0.5)), mul(particleDensity, float(6.28)))), float(0.3)), float(1));

        // Dynamic sizing based on density and distance
        const distFromCenter = length(pos);
        const distFactor = smoothstep(float(0), float(15), distFromCenter);
        const finalSize = mul(particleSize, pulse, add(float(0.7), mul(volumeDensity, float(0.5))));

        const material = new THREE.PointsNodeMaterial({
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        material.sizeNode = mul(finalSize, float(window.innerHeight * 0.015));

        // Color modulation with volumetric density
        const densityBoost = add(float(0.5), mul(volumeDensity, float(0.8)));
        const glowColor = mul(vec3(particleColor), densityBoost, pulse);

        // Opacity based on density and pulsing
        const baseOpacity = mul(particleDensity, volumeDensity, float(0.4));
        const finalOpacity = clamp(mul(baseOpacity, pulse), float(0.1), float(0.8));

        material.colorNode = vec4(glowColor, finalOpacity);

        const nebula = new THREE.Points(geometry, material);
        scene.add(nebula);

        // Add stars in background
        const starCount = 1000;
        const starGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(starCount * 3);

        for (let i = 0; i < starCount; i++) {
            const radius = 40 + Math.random() * 20;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(Math.random() * 2 - 1);

            starPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
            starPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            starPositions[i * 3 + 2] = radius * Math.cos(phi);
        }

        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.1,
            transparent: true,
            opacity: 0.8
        });

        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Ambient light
        const ambientLight = new THREE.AmbientLight(0x202040, 0.3);
        scene.add(ambientLight);

        function animate() {
            requestAnimationFrame(animate);

            // Slow rotation
            nebula.rotation.y += 0.0003;
            nebula.rotation.x = Math.sin(Date.now() * 0.0001) * 0.15;

            stars.rotation.y += 0.0001;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
