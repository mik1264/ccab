<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Displacement Shader - TSL Enhanced</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(76, 201, 240, 0.8);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-family: Arial;
            z-index: 10;
        }
        .tech-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }
        .info {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: Arial;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">← Back</a>
    <div class="tech-badge">TSL Displacement • Procedural Noise • Real-time</div>
    <div class="info">
        <div><strong>TSL Vertex Displacement</strong></div>
        <div>Procedural noise-based deformation</div>
        <div>Mouse: Rotate • Scroll: Zoom</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
            "three/nodes": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import {
            color,
            positionLocal,
            normalLocal,
            timerLocal,
            mul,
            add,
            sin,
            cos,
            mix,
            vec3,
            vec4,
            float,
            normalize
        } from 'three/nodes';
        import { mx_noise_float } from 'three/nodes';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 6;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Create high-resolution sphere geometry
        const geometry = new THREE.SphereGeometry(2, 256, 256);

        // TSL-based displacement material
        const material = new THREE.MeshStandardNodeMaterial({
            roughness: 0.3,
            metalness: 0.7
        });

        // Time-varying displacement
        const time = timerLocal();
        const pos = positionLocal;
        const norm = normalLocal;

        // Multi-octave displacement using trigonometric functions
        const freq1 = float(2.0);
        const freq2 = float(4.0);
        const freq3 = float(8.0);

        const wave1 = mul(
            sin(add(mul(pos.x, freq1), time)),
            cos(add(mul(pos.y, freq1), time)),
            sin(add(mul(pos.z, freq1), time))
        );
        const wave2 = mul(
            sin(add(mul(pos.x, freq2), mul(time, 0.7))),
            cos(add(mul(pos.y, freq2), mul(time, 0.7))),
            mul(float(0.5))
        );
        const wave3 = mul(
            sin(add(mul(pos.x, freq3), mul(time, 0.5))),
            cos(add(mul(pos.z, freq3), mul(time, 0.5))),
            mul(float(0.25))
        );

        // Combine waves
        const displacement = add(wave1, wave2, wave3);

        // Apply displacement along normals
        const displacementAmount = mul(displacement, float(0.5));
        const displacedPosition = add(pos, mul(norm, displacementAmount));

        material.positionNode = displacedPosition;

        // Dynamic color based on displacement
        const color1 = vec3(float(0.3), float(0.8), float(1.0)); // Cyan
        const color2 = vec3(float(1.0), float(0.3), float(0.5)); // Magenta
        const colorMix = add(mul(displacement, float(0.5)), float(0.5));
        const dynamicColor = mix(color1, color2, colorMix);

        material.colorNode = vec3(dynamicColor);

        // Add emissive glow
        const emissiveStrength = mul(sin(mul(time, float(2))), float(0.3), add(float(1), float(0.3)));
        material.emissiveNode = mul(dynamicColor, emissiveStrength);

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // Add wireframe overlay with TSL
        const wireframeGeometry = new THREE.SphereGeometry(2, 256, 256);
        const wireframeMaterial = new THREE.MeshBasicNodeMaterial({
            wireframe: true,
            transparent: true,
            opacity: 0.1
        });
        wireframeMaterial.positionNode = displacedPosition;
        wireframeMaterial.colorNode = vec3(float(0.5), float(0.5), float(1.0));

        const wireframeMesh = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
        scene.add(wireframeMesh);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 2, 100);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        const pointLight2 = new THREE.PointLight(0x4080ff, 1, 100);
        pointLight2.position.set(-5, -5, 5);
        scene.add(pointLight2);

        function animate() {
            requestAnimationFrame(animate);

            mesh.rotation.y += 0.003;
            wireframeMesh.rotation.y += 0.003;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
