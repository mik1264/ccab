<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Morphing Geometry</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(76, 201, 240, 0.8);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-family: Arial;
            z-index: 10;
        }
        .info {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: Arial;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10;
        }
        .info div { margin: 5px 0; }
        #shapeName {
            font-size: 18px;
            font-weight: bold;
            color: #4cc9f0;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">‚Üê Back</a>
    <div class="info">
        <div><strong>Morphing Geometry</strong></div>
        <div id="shapeName">Sphere</div>
        <div>Smooth transitions between shapes</div>
        <div>Mouse: Rotate view</div>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.149.0/build/three.module.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.149.0/examples/jsm/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a15);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Create geometries to morph between
        const geometries = [
            { geo: new THREE.SphereGeometry(2, 64, 64), name: 'Sphere' },
            { geo: new THREE.TorusGeometry(2, 0.8, 64, 64), name: 'Torus' },
            { geo: new THREE.BoxGeometry(3, 3, 3, 32, 32, 32), name: 'Box' },
            { geo: new THREE.DodecahedronGeometry(2.5, 2), name: 'Dodecahedron' },
            { geo: new THREE.TorusKnotGeometry(1.5, 0.5, 128, 32), name: 'Torus Knot' },
            { geo: new THREE.IcosahedronGeometry(2.5, 2), name: 'Icosahedron' }
        ];

        // Normalize all geometries to have the same vertex count
        const maxVertices = Math.max(...geometries.map(g => g.geo.attributes.position.count));

        // Create morph target geometry
        const baseGeometry = geometries[0].geo.clone();

        // Add morph targets
        for (let i = 1; i < geometries.length; i++) {
            const targetGeo = geometries[i].geo;
            const positions = targetGeo.attributes.position.array;
            baseGeometry.morphAttributes.position = baseGeometry.morphAttributes.position || [];
            baseGeometry.morphAttributes.position.push(
                new THREE.Float32BufferAttribute(positions, 3)
            );
        }

        // Create material with gradient colors
        const material = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            shininess: 100,
            specular: 0x444444,
            morphTargets: true,
            flatShading: false,
            vertexColors: false
        });

        const mesh = new THREE.Mesh(baseGeometry, material);
        scene.add(mesh);

        // Add wireframe
        const wireframeMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            wireframe: true,
            transparent: true,
            opacity: 0.2,
            morphTargets: true
        });
        const wireframeMesh = new THREE.Mesh(baseGeometry.clone(), wireframeMaterial);
        scene.add(wireframeMesh);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0xff0080, 1, 100);
        pointLight1.position.set(5, 5, 5);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0x0080ff, 1, 100);
        pointLight2.position.set(-5, -5, 5);
        scene.add(pointLight2);

        const pointLight3 = new THREE.PointLight(0x80ff00, 1, 100);
        pointLight3.position.set(0, 5, -5);
        scene.add(pointLight3);

        // Morphing animation state
        let currentShape = 0;
        let nextShape = 1;
        let morphProgress = 0;
        const morphSpeed = 0.3;
        const holdTime = 1.5;
        let holdCounter = 0;

        const shapeNameEl = document.getElementById('shapeName');

        function updateMorphTargets() {
            // Reset all morph influences
            for (let i = 0; i < geometries.length - 1; i++) {
                mesh.morphTargetInfluences[i] = 0;
                wireframeMesh.morphTargetInfluences[i] = 0;
            }

            // Set current morph influence
            if (nextShape > 0) {
                const influence = morphProgress;
                mesh.morphTargetInfluences[nextShape - 1] = influence;
                wireframeMesh.morphTargetInfluences[nextShape - 1] = influence;
            }
        }

        // Animation
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;
            const deltaTime = 0.016; // Approximate 60fps

            // Update morphing
            if (holdCounter <= 0) {
                morphProgress += deltaTime * morphSpeed;

                if (morphProgress >= 1) {
                    morphProgress = 0;
                    currentShape = nextShape;
                    nextShape = (nextShape + 1) % geometries.length;
                    holdCounter = holdTime;

                    // Update shape name
                    shapeNameEl.textContent = geometries[currentShape].name;

                    // Update material color
                    const hue = (currentShape / geometries.length);
                    material.color.setHSL(hue, 0.7, 0.6);
                }
            } else {
                holdCounter -= deltaTime;
            }

            updateMorphTargets();

            // Rotate mesh
            mesh.rotation.x = time * 0.2;
            mesh.rotation.y = time * 0.3;
            wireframeMesh.rotation.x = time * 0.2;
            wireframeMesh.rotation.y = time * 0.3;

            // Animate lights
            pointLight1.position.x = Math.cos(time * 0.5) * 5;
            pointLight1.position.z = Math.sin(time * 0.5) * 5;

            pointLight2.position.x = Math.cos(time * 0.7 + Math.PI) * 5;
            pointLight2.position.y = Math.sin(time * 0.7 + Math.PI) * 5;

            pointLight3.position.y = Math.cos(time * 0.6) * 5;
            pointLight3.position.z = Math.sin(time * 0.6) * 5;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
