<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hopf Fibration Explorer - CCAB</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: Arial, sans-serif; }
        canvas { display: block; }
        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(76, 201, 240, 0.8);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            z-index: 100;
        }
        .back-btn:hover { background: rgba(76, 201, 240, 1); }

        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            max-width: 280px;
            font-size: 13px;
            z-index: 100;
        }
        .info-panel h3 { color: #4cc9f0; margin: 0 0 10px 0; }
        .info-panel p { margin: 8px 0; line-height: 1.5; color: #aaa; }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 10px;
            display: flex;
            gap: 20px;
            align-items: center;
            z-index: 100;
        }
        .control-group { display: flex; align-items: center; gap: 8px; }
        label { color: #888; font-size: 13px; }
        input[type="range"] { width: 100px; accent-color: #4cc9f0; }
        select {
            padding: 5px 10px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            color: white;
        }
        button {
            padding: 8px 16px;
            background: #4cc9f0;
            border: none;
            border-radius: 5px;
            color: black;
            font-weight: bold;
            cursor: pointer;
        }
        button:hover { background: #7dd8f5; }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">← Back</a>

    <div class="info-panel">
        <h3>Hopf Fibration</h3>
        <p>The Hopf fibration maps the 3-sphere (S³) to the 2-sphere (S²), where each point on S² corresponds to a circle (fiber) in S³.</p>
        <p>This visualization uses stereographic projection to show the fibers in 3D space. Click on the base sphere to highlight specific fibers.</p>
        <p>Adjacent fibers are linked - a fundamental topological property.</p>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Fibers:</label>
            <input type="range" id="fiberCount" min="12" max="100" value="36">
            <span id="fiberValue">36</span>
        </div>
        <div class="control-group">
            <label>Mode:</label>
            <select id="colorMode">
                <option value="latitude">By Latitude</option>
                <option value="longitude">By Longitude</option>
                <option value="rainbow">Rainbow</option>
                <option value="linked">Show Linking</option>
            </select>
        </div>
        <div class="control-group">
            <label>Speed:</label>
            <input type="range" id="speed" min="0" max="100" value="30">
        </div>
        <button id="toggleBase">Toggle Base Sphere</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Parameters
        let fiberCount = 36;
        let colorMode = 'latitude';
        let animationSpeed = 0.3;
        let showBaseSphere = true;
        let time = 0;

        // Fiber group
        const fiberGroup = new THREE.Group();
        scene.add(fiberGroup);

        // Base sphere (S²)
        const baseSphereGeom = new THREE.SphereGeometry(0.8, 32, 32);
        const baseSphereMat = new THREE.MeshBasicMaterial({
            color: 0x4cc9f0,
            wireframe: true,
            transparent: true,
            opacity: 0.3
        });
        const baseSphere = new THREE.Mesh(baseSphereGeom, baseSphereMat);
        baseSphere.position.set(5, 0, 0);
        scene.add(baseSphere);

        // Points on base sphere
        const basePointsGroup = new THREE.Group();
        baseSphere.add(basePointsGroup);

        // Stereographic projection from S³ to R³
        function stereographicProject(x, y, z, w) {
            const denom = 1 - w + 0.001;
            return new THREE.Vector3(
                x / denom,
                y / denom,
                z / denom
            );
        }

        // Generate a point on S³ from Hopf coordinates
        function hopfPoint(theta, phi, psi) {
            // theta, phi: coordinates on S²
            // psi: parameter along the fiber [0, 2π]
            const cosTheta2 = Math.cos(theta / 2);
            const sinTheta2 = Math.sin(theta / 2);

            return {
                x: cosTheta2 * Math.cos((phi + psi) / 2),
                y: cosTheta2 * Math.sin((phi + psi) / 2),
                z: sinTheta2 * Math.cos((phi - psi) / 2),
                w: sinTheta2 * Math.sin((phi - psi) / 2)
            };
        }

        // Generate fiber (circle in S³) for a point on S²
        function generateFiber(theta, phi, numPoints = 64) {
            const points = [];
            for (let i = 0; i <= numPoints; i++) {
                const psi = (i / numPoints) * Math.PI * 2;
                const p = hopfPoint(theta, phi, psi);
                const projected = stereographicProject(p.x, p.y, p.z, p.w);

                // Scale down for better visualization
                projected.multiplyScalar(0.8);
                points.push(projected);
            }
            return points;
        }

        // Color based on position on S²
        function getFiberColor(theta, phi, mode) {
            if (mode === 'latitude') {
                const hue = (theta / Math.PI) * 0.7; // 0 to 0.7 (red to blue range)
                return new THREE.Color().setHSL(hue, 0.9, 0.6);
            } else if (mode === 'longitude') {
                const hue = (phi / (Math.PI * 2)) % 1;
                return new THREE.Color().setHSL(hue, 0.9, 0.6);
            } else if (mode === 'rainbow') {
                const hue = ((theta / Math.PI) + (phi / (Math.PI * 2))) % 1;
                return new THREE.Color().setHSL(hue, 0.85, 0.55);
            } else if (mode === 'linked') {
                // Highlight pairs of linked fibers
                const idx = Math.floor((phi / (Math.PI * 2)) * 6) % 2;
                return idx === 0 ? new THREE.Color(0xff4444) : new THREE.Color(0x44ff44);
            }
            return new THREE.Color(0xffffff);
        }

        // Create all fibers
        function createFibers() {
            // Clear existing fibers
            while (fiberGroup.children.length > 0) {
                const child = fiberGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                fiberGroup.remove(child);
            }

            // Clear base points
            while (basePointsGroup.children.length > 0) {
                const child = basePointsGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                basePointsGroup.remove(child);
            }

            // Generate fibers on a grid of points on S²
            const latSteps = Math.ceil(Math.sqrt(fiberCount));
            const lonSteps = Math.ceil(fiberCount / latSteps);

            for (let i = 0; i < latSteps; i++) {
                const theta = ((i + 0.5) / latSteps) * Math.PI; // Latitude: 0 to π

                for (let j = 0; j < lonSteps; j++) {
                    const phi = (j / lonSteps) * Math.PI * 2; // Longitude: 0 to 2π

                    // Generate fiber
                    const fiberPoints = generateFiber(theta, phi);
                    const geometry = new THREE.BufferGeometry().setFromPoints(fiberPoints);

                    const color = getFiberColor(theta, phi, colorMode);
                    const material = new THREE.LineBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.8,
                        linewidth: 2
                    });

                    const fiber = new THREE.Line(geometry, material);
                    fiber.userData = { theta, phi };
                    fiberGroup.add(fiber);

                    // Add point on base sphere
                    const pointGeom = new THREE.SphereGeometry(0.03, 8, 8);
                    const pointMat = new THREE.MeshBasicMaterial({ color: color });
                    const point = new THREE.Mesh(pointGeom, pointMat);

                    // Convert spherical to cartesian for base sphere
                    point.position.set(
                        0.8 * Math.sin(theta) * Math.cos(phi),
                        0.8 * Math.cos(theta),
                        0.8 * Math.sin(theta) * Math.sin(phi)
                    );
                    basePointsGroup.add(point);
                }
            }
        }

        // Animation
        function animate() {
            requestAnimationFrame(animate);

            time += animationSpeed * 0.01;

            // Rotate fiber group
            fiberGroup.rotation.y = time * 0.3;
            fiberGroup.rotation.x = Math.sin(time * 0.2) * 0.1;

            // Rotate base sphere sync
            baseSphere.rotation.y = time * 0.3;

            controls.update();
            renderer.render(scene, camera);
        }

        // Event listeners
        document.getElementById('fiberCount').addEventListener('input', (e) => {
            fiberCount = parseInt(e.target.value);
            document.getElementById('fiberValue').textContent = fiberCount;
            createFibers();
        });

        document.getElementById('colorMode').addEventListener('change', (e) => {
            colorMode = e.target.value;
            createFibers();
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            animationSpeed = parseInt(e.target.value) / 100;
        });

        document.getElementById('toggleBase').addEventListener('click', () => {
            showBaseSphere = !showBaseSphere;
            baseSphere.visible = showBaseSphere;
        });

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        createFibers();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
