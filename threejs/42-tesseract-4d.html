<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4D Tesseract (Hypercube) - CCAB</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: Arial, sans-serif; }
        canvas { display: block; }
        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(147, 51, 234, 0.8);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            z-index: 100;
        }
        .back-btn:hover { background: rgba(147, 51, 234, 1); }

        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px;
            border-radius: 10px;
            max-width: 280px;
            font-size: 13px;
            z-index: 100;
        }
        .info-panel h3 { color: #a855f7; margin: 0 0 10px 0; }
        .info-panel p { margin: 8px 0; line-height: 1.5; color: #aaa; }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 25px;
            border-radius: 10px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            z-index: 100;
        }
        .control-group { display: flex; align-items: center; gap: 8px; }
        label { color: #888; font-size: 13px; }
        input[type="range"] { width: 80px; accent-color: #a855f7; }
        select, button {
            padding: 6px 12px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            color: white;
            cursor: pointer;
        }
        button { background: #a855f7; border: none; font-weight: bold; }
        button:hover { background: #c084fc; }

        .rotation-indicator {
            position: absolute;
            bottom: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            color: #888;
        }
        .rotation-indicator span { color: #a855f7; }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">← Back</a>

    <div class="info-panel">
        <h3>4D Tesseract</h3>
        <p>A tesseract (hypercube) is a 4-dimensional analog of a cube. It has 16 vertices, 32 edges, 24 square faces, and 8 cubic cells.</p>
        <p>This visualization projects 4D coordinates into 3D using perspective projection, then renders in your browser.</p>
        <p>Drag to rotate in 3D. Use sliders to rotate in 4D (XW, YW, ZW planes).</p>
    </div>

    <div class="rotation-indicator">
        4D Rotation: <span id="rotInfo">XW: 0° YW: 0° ZW: 0°</span>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>XW:</label>
            <input type="range" id="rotXW" min="0" max="360" value="0">
        </div>
        <div class="control-group">
            <label>YW:</label>
            <input type="range" id="rotYW" min="0" max="360" value="0">
        </div>
        <div class="control-group">
            <label>ZW:</label>
            <input type="range" id="rotZW" min="0" max="360" value="0">
        </div>
        <div class="control-group">
            <label>Auto:</label>
            <select id="autoRotate">
                <option value="none">None</option>
                <option value="xw" selected>XW</option>
                <option value="yw">YW</option>
                <option value="zw">ZW</option>
                <option value="all">All</option>
            </select>
        </div>
        <div class="control-group">
            <label>View:</label>
            <select id="viewMode">
                <option value="perspective">Perspective</option>
                <option value="orthographic">Orthographic</option>
            </select>
        </div>
        <button id="resetBtn">Reset</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(4, 3, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Tesseract vertices in 4D (16 vertices)
        const vertices4D = [];
        for (let i = 0; i < 16; i++) {
            vertices4D.push([
                (i & 1) ? 1 : -1,
                (i & 2) ? 1 : -1,
                (i & 4) ? 1 : -1,
                (i & 8) ? 1 : -1
            ]);
        }

        // Edges: connect vertices that differ in exactly one coordinate
        const edges = [];
        for (let i = 0; i < 16; i++) {
            for (let j = i + 1; j < 16; j++) {
                let diff = 0;
                for (let k = 0; k < 4; k++) {
                    if (vertices4D[i][k] !== vertices4D[j][k]) diff++;
                }
                if (diff === 1) {
                    edges.push([i, j]);
                }
            }
        }

        // 4D rotation parameters
        let rotXW = 0, rotYW = 0, rotZW = 0;
        let viewMode = 'perspective';
        let autoRotateMode = 'xw';

        // 4D rotation matrices
        function rotateXW(v, angle) {
            const c = Math.cos(angle), s = Math.sin(angle);
            return [
                v[0] * c - v[3] * s,
                v[1],
                v[2],
                v[0] * s + v[3] * c
            ];
        }

        function rotateYW(v, angle) {
            const c = Math.cos(angle), s = Math.sin(angle);
            return [
                v[0],
                v[1] * c - v[3] * s,
                v[2],
                v[1] * s + v[3] * c
            ];
        }

        function rotateZW(v, angle) {
            const c = Math.cos(angle), s = Math.sin(angle);
            return [
                v[0],
                v[1],
                v[2] * c - v[3] * s,
                v[2] * s + v[3] * c
            ];
        }

        // Project 4D to 3D
        function project4Dto3D(v, mode) {
            if (mode === 'perspective') {
                const w = 2; // Distance from viewpoint in 4D
                const scale = 1 / (w - v[3]);
                return new THREE.Vector3(v[0] * scale, v[1] * scale, v[2] * scale);
            } else {
                // Orthographic: just drop the w coordinate
                return new THREE.Vector3(v[0], v[1], v[2]);
            }
        }

        // Create Three.js objects
        const tesseractGroup = new THREE.Group();
        scene.add(tesseractGroup);

        // Vertex spheres
        const vertexGeom = new THREE.SphereGeometry(0.08, 16, 16);
        const vertexMaterial = new THREE.MeshBasicMaterial({ color: 0xa855f7 });
        const vertexMeshes = [];

        for (let i = 0; i < 16; i++) {
            const mesh = new THREE.Mesh(vertexGeom, vertexMaterial.clone());
            tesseractGroup.add(mesh);
            vertexMeshes.push(mesh);
        }

        // Edge lines
        const edgeLines = [];
        const lineMaterial = new THREE.LineBasicMaterial({
            color: 0x8b5cf6,
            transparent: true,
            opacity: 0.8
        });

        for (const edge of edges) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(6);
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const line = new THREE.Line(geometry, lineMaterial.clone());
            tesseractGroup.add(line);
            edgeLines.push({ line, edge });
        }

        // Update tesseract positions
        function updateTesseract() {
            const projected = [];

            for (let i = 0; i < 16; i++) {
                let v = [...vertices4D[i]];

                // Apply 4D rotations
                v = rotateXW(v, rotXW);
                v = rotateYW(v, rotYW);
                v = rotateZW(v, rotZW);

                // Project to 3D
                const p3d = project4Dto3D(v, viewMode);
                projected.push(p3d);

                // Update vertex sphere
                vertexMeshes[i].position.copy(p3d);

                // Color based on W coordinate (depth in 4D)
                const wNorm = (v[3] + 1.5) / 3; // Normalize to 0-1
                const hue = 0.75 - wNorm * 0.3; // Purple to blue range
                vertexMeshes[i].material.color.setHSL(hue, 0.8, 0.6);
            }

            // Update edges
            for (let i = 0; i < edgeLines.length; i++) {
                const { line, edge } = edgeLines[i];
                const p1 = projected[edge[0]];
                const p2 = projected[edge[1]];

                const positions = line.geometry.attributes.position.array;
                positions[0] = p1.x; positions[1] = p1.y; positions[2] = p1.z;
                positions[3] = p2.x; positions[4] = p2.y; positions[5] = p2.z;
                line.geometry.attributes.position.needsUpdate = true;

                // Color edge based on average W depth
                const v1 = rotateZW(rotateYW(rotateXW([...vertices4D[edge[0]]], rotXW), rotYW), rotZW);
                const v2 = rotateZW(rotateYW(rotateXW([...vertices4D[edge[1]]], rotXW), rotYW), rotZW);
                const avgW = (v1[3] + v2[3]) / 2;
                const wNorm = (avgW + 1.5) / 3;
                const hue = 0.75 - wNorm * 0.3;
                line.material.color.setHSL(hue, 0.7, 0.5);
                line.material.opacity = 0.5 + wNorm * 0.5;
            }
        }

        // Update rotation info display
        function updateRotInfo() {
            const xwDeg = Math.round(rotXW * 180 / Math.PI) % 360;
            const ywDeg = Math.round(rotYW * 180 / Math.PI) % 360;
            const zwDeg = Math.round(rotZW * 180 / Math.PI) % 360;
            document.getElementById('rotInfo').textContent =
                `XW: ${xwDeg}° YW: ${ywDeg}° ZW: ${zwDeg}°`;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Auto-rotation
            const speed = 0.005;
            if (autoRotateMode === 'xw' || autoRotateMode === 'all') {
                rotXW += speed;
                document.getElementById('rotXW').value = (rotXW * 180 / Math.PI) % 360;
            }
            if (autoRotateMode === 'yw' || autoRotateMode === 'all') {
                rotYW += speed * 0.7;
                document.getElementById('rotYW').value = (rotYW * 180 / Math.PI) % 360;
            }
            if (autoRotateMode === 'zw' || autoRotateMode === 'all') {
                rotZW += speed * 0.5;
                document.getElementById('rotZW').value = (rotZW * 180 / Math.PI) % 360;
            }

            updateTesseract();
            updateRotInfo();
            controls.update();
            renderer.render(scene, camera);
        }

        // Event listeners
        document.getElementById('rotXW').addEventListener('input', (e) => {
            rotXW = e.target.value * Math.PI / 180;
            autoRotateMode = 'none';
            document.getElementById('autoRotate').value = 'none';
        });

        document.getElementById('rotYW').addEventListener('input', (e) => {
            rotYW = e.target.value * Math.PI / 180;
            autoRotateMode = 'none';
            document.getElementById('autoRotate').value = 'none';
        });

        document.getElementById('rotZW').addEventListener('input', (e) => {
            rotZW = e.target.value * Math.PI / 180;
            autoRotateMode = 'none';
            document.getElementById('autoRotate').value = 'none';
        });

        document.getElementById('autoRotate').addEventListener('change', (e) => {
            autoRotateMode = e.target.value;
        });

        document.getElementById('viewMode').addEventListener('change', (e) => {
            viewMode = e.target.value;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            rotXW = rotYW = rotZW = 0;
            document.getElementById('rotXW').value = 0;
            document.getElementById('rotYW').value = 0;
            document.getElementById('rotZW').value = 0;
            autoRotateMode = 'xw';
            document.getElementById('autoRotate').value = 'xw';
            camera.position.set(4, 3, 5);
            controls.reset();
        });

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Grid helper
        const gridHelper = new THREE.GridHelper(6, 12, 0x333366, 0x222244);
        gridHelper.position.y = -2;
        scene.add(gridHelper);

        // Initialize
        updateTesseract();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
