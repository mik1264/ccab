<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNA Helix - TSL Enhanced</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(76, 201, 240, 0.8);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-family: Arial;
            z-index: 10;
        }
        .tech-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">← Back</a>
    <div class="tech-badge">TSL DNA • Glowing Helices • Dynamic Tubes</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
            "three/nodes": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import {
            color,
            attribute,
            positionLocal,
            normalLocal,
            timerLocal,
            cameraPosition,
            mul,
            add,
            sin,
            cos,
            mix,
            smoothstep,
            pow,
            abs,
            dot,
            normalize,
            sub,
            vec3,
            vec4,
            float,
            length
        } from 'three/nodes';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000510);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(10, 5, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 2.0;

        const group = new THREE.Group();

        // DNA parameters
        const steps = 200;
        const radius = 2.5;
        const height = 25;
        const turns = 4;

        // Create helix tubes with TSL materials
        const curve1 = new THREE.CatmullRomCurve3(
            Array.from({ length: steps }, (_, i) => {
                const t = i / (steps - 1);
                const angle = t * Math.PI * 2 * turns;
                return new THREE.Vector3(
                    Math.cos(angle) * radius,
                    t * height - height / 2,
                    Math.sin(angle) * radius
                );
            })
        );

        const curve2 = new THREE.CatmullRomCurve3(
            Array.from({ length: steps }, (_, i) => {
                const t = i / (steps - 1);
                const angle = t * Math.PI * 2 * turns + Math.PI;
                return new THREE.Vector3(
                    Math.cos(angle) * radius,
                    t * height - height / 2,
                    Math.sin(angle) * radius
                );
            })
        );

        // Create tube geometries
        const tubeGeometry1 = new THREE.TubeGeometry(curve1, steps * 2, 0.15, 8, false);
        const tubeGeometry2 = new THREE.TubeGeometry(curve2, steps * 2, 0.15, 8, false);

        // TSL material for glowing tubes
        const time = timerLocal();
        const pos = positionLocal;
        const norm = normalLocal;

        // Strand 1 - Cyan glow
        const tubeMaterial1 = new THREE.MeshStandardNodeMaterial({
            roughness: 0.2,
            metalness: 0.8
        });

        const baseColor1 = vec3(float(0.3), float(0.8), float(1.0));
        const viewDir = normalize(sub(cameraPosition, pos));
        const fresnel = pow(sub(float(1.0), abs(dot(viewDir, norm))), float(3.0));
        const glowColor1 = add(baseColor1, mul(vec3(float(0.5), float(1.0), float(1.0)), fresnel));

        tubeMaterial1.colorNode = glowColor1;
        tubeMaterial1.emissiveNode = mul(baseColor1, add(float(0.5), mul(fresnel, float(0.5))));

        // Strand 2 - Magenta glow
        const tubeMaterial2 = new THREE.MeshStandardNodeMaterial({
            roughness: 0.2,
            metalness: 0.8
        });

        const baseColor2 = vec3(float(0.97), float(0.15), float(0.52));
        const glowColor2 = add(baseColor2, mul(vec3(float(1.0), float(0.5), float(0.8)), fresnel));

        tubeMaterial2.colorNode = glowColor2;
        tubeMaterial2.emissiveNode = mul(baseColor2, add(float(0.5), mul(fresnel, float(0.5))));

        const strand1 = new THREE.Mesh(tubeGeometry1, tubeMaterial1);
        const strand2 = new THREE.Mesh(tubeGeometry2, tubeMaterial2);

        group.add(strand1);
        group.add(strand2);

        // Create connecting base pairs with TSL particles
        const basePairCount = 40;
        const bpGeometry = new THREE.BufferGeometry();
        const bpPositions = new Float32Array(basePairCount * 2 * 3);
        const bpColors = new Float32Array(basePairCount * 2 * 3);
        const bpSizes = new Float32Array(basePairCount * 2);

        let idx = 0;
        for (let i = 0; i < basePairCount; i++) {
            const t = i / (basePairCount - 1);
            const angle = t * Math.PI * 2 * turns;
            const y = t * height - height / 2;

            // Point 1
            bpPositions[idx * 3] = Math.cos(angle) * radius;
            bpPositions[idx * 3 + 1] = y;
            bpPositions[idx * 3 + 2] = Math.sin(angle) * radius;
            bpColors[idx * 3] = 1.0;
            bpColors[idx * 3 + 1] = 1.0;
            bpColors[idx * 3 + 2] = 1.0;
            bpSizes[idx] = 0.3;
            idx++;

            // Point 2
            bpPositions[idx * 3] = Math.cos(angle + Math.PI) * radius;
            bpPositions[idx * 3 + 1] = y;
            bpPositions[idx * 3 + 2] = Math.sin(angle + Math.PI) * radius;
            bpColors[idx * 3] = 1.0;
            bpColors[idx * 3 + 1] = 1.0;
            bpColors[idx * 3 + 2] = 1.0;
            bpSizes[idx] = 0.3;
            idx++;
        }

        bpGeometry.setAttribute('position', new THREE.BufferAttribute(bpPositions, 3));
        bpGeometry.setAttribute('color', new THREE.BufferAttribute(bpColors, 3));
        bpGeometry.setAttribute('aSize', new THREE.BufferAttribute(bpSizes, 1));

        // TSL material for base pair spheres
        const bpColor = attribute('color', 'vec3');
        const bpSize = attribute('aSize', 'float');

        const bpMaterial = new THREE.PointsNodeMaterial({
            transparent: true,
            blending: THREE.AdditiveBlending
        });

        const pulse = add(sin(mul(time, float(2))), float(1));
        bpMaterial.sizeNode = mul(bpSize, pulse, float(window.innerHeight * 0.01));
        bpMaterial.colorNode = vec4(vec3(bpColor), float(0.9));

        const basePairs = new THREE.Points(bpGeometry, bpMaterial);
        group.add(basePairs);

        // Add connecting lines
        for (let i = 0; i < basePairCount; i++) {
            const lineGeometry = new THREE.BufferGeometry();
            const linePositions = new Float32Array(6);

            linePositions[0] = bpPositions[i * 6];
            linePositions[1] = bpPositions[i * 6 + 1];
            linePositions[2] = bpPositions[i * 6 + 2];
            linePositions[3] = bpPositions[i * 6 + 3];
            linePositions[4] = bpPositions[i * 6 + 4];
            linePositions[5] = bpPositions[i * 6 + 5];

            lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.4
            });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            group.add(line);
        }

        scene.add(group);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x202040, 0.5);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0x4cc9f0, 2, 50);
        pointLight1.position.set(5, 0, 5);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xf72585, 2, 50);
        pointLight2.position.set(-5, 0, -5);
        scene.add(pointLight2);

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
