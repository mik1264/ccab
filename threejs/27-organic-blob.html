<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organic Blob - TSL Enhanced</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(76, 201, 240, 0.8);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-family: Arial;
            z-index: 10;
        }
        .tech-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">← Back</a>
    <div class="tech-badge">TSL Blob • Multi-Noise Displacement • Iridescent</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
            "three/nodes": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import {
            positionLocal,
            normalLocal,
            normalView,
            timerLocal,
            cameraPosition,
            mul,
            add,
            sin,
            cos,
            mix,
            smoothstep,
            pow,
            abs,
            dot,
            normalize,
            sub,
            vec3,
            vec4,
            float,
            length
        } from 'three/nodes';
        import { mx_fractal_noise_vec3, mx_worley_noise_float } from 'three/nodes';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000510);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.5;

        // High-resolution sphere for smooth organic deformation
        const geometry = new THREE.SphereGeometry(2.5, 256, 256);

        // TSL material with advanced displacement
        const material = new THREE.MeshStandardNodeMaterial({
            roughness: 0.2,
            metalness: 0.9
        });

        const time = timerLocal();
        const pos = positionLocal;
        const norm = normalLocal;
        const viewNorm = normalView;

        // Multi-layered noise displacement
        const timeScale = mul(time, float(0.3));

        // Layer 1: Fractal noise for large bulges
        const noise1Pos = add(mul(pos, float(1.5)), vec3(timeScale, mul(timeScale, 0.7), mul(timeScale, 0.5)));
        const noise1 = mx_fractal_noise_vec3(noise1Pos, float(4), float(2.0), float(0.5));

        // Layer 2: Worley noise for cellular/organic structure
        const noise2Pos = add(mul(pos, float(3.0)), vec3(mul(timeScale, 0.5), timeScale, mul(timeScale, 0.8)));
        const noise2 = mx_worley_noise_float(noise2Pos, float(1.0));

        // Layer 3: Fine detail fractal noise
        const noise3Pos = add(mul(pos, float(5.0)), vec3(mul(timeScale, 0.3), mul(timeScale, 0.6), timeScale));
        const noise3 = mx_fractal_noise_vec3(noise3Pos, float(2), float(2.0), float(0.5));

        // Combine noises with different weights
        const combinedNoise = add(
            mul(noise1.x, float(0.5)),
            mul(noise2, float(0.3)),
            mul(noise3.x, float(0.2))
        );

        // Apply displacement along normals
        const displacement = mul(combinedNoise, float(0.8));
        const displacedPos = add(pos, mul(norm, displacement));

        material.positionNode = displacedPos;

        // Iridescent coloring based on view angle and noise
        const viewDir = normalize(sub(cameraPosition, pos));
        const fresnel = pow(sub(float(1.0), abs(dot(viewDir, norm))), float(2.5));

        // Multi-color iridescence
        const color1 = vec3(float(1.0), float(0.0), float(0.43)); // Magenta
        const color2 = vec3(float(0.3), float(0.8), float(1.0));  // Cyan
        const color3 = vec3(float(1.0), float(0.6), float(0.0));  // Orange

        // Cycle through colors based on noise and time
        const colorCycle = add(mul(combinedNoise, float(0.5)), mul(sin(mul(time, float(0.5))), float(0.5)));
        let blobColor = mix(color1, color2, smoothstep(float(0), float(0.5), colorCycle));
        blobColor = mix(blobColor, color3, smoothstep(float(0.5), float(1.0), colorCycle));

        // Add fresnel rim
        const rimColor = vec3(float(1.0), float(1.0), float(1.0));
        blobColor = add(blobColor, mul(rimColor, fresnel, float(0.4)));

        material.colorNode = blobColor;

        // Emissive glow
        material.emissiveNode = mul(blobColor, add(float(0.3), mul(fresnel, float(0.5))));

        const blob = new THREE.Mesh(geometry, material);
        scene.add(blob);

        // Add environment lights
        const ambientLight = new THREE.AmbientLight(0x202040, 0.3);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0x4cc9f0, 2, 50);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xf72585, 2, 50);
        scene.add(pointLight2);

        const pointLight3 = new THREE.PointLight(0xffa500, 1.5, 50);
        scene.add(pointLight3);

        function animate() {
            requestAnimationFrame(animate);

            const t = Date.now() * 0.001;

            // Orbit lights around blob
            pointLight1.position.set(
                Math.cos(t) * 7,
                Math.sin(t * 0.7) * 7,
                Math.sin(t) * 7
            );

            pointLight2.position.set(
                Math.cos(t + Math.PI) * 7,
                Math.sin(t * 0.7 + Math.PI) * 7,
                Math.sin(t + Math.PI) * 7
            );

            pointLight3.position.set(
                Math.sin(t * 0.5) * 6,
                Math.cos(t * 0.5) * 6,
                Math.cos(t * 0.8) * 6
            );

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
