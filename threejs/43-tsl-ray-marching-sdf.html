<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TSL Ray Marching SDF</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(76, 201, 240, 0.8);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-family: Arial;
            z-index: 10;
        }
        .tech-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
            z-index: 10;
        }
        .info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-family: Arial;
            font-size: 12px;
            z-index: 10;
            max-width: 250px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">← Back</a>
    <div class="tech-badge">TSL Ray March • SDF Primitives • Soft Shadows</div>
    <div class="info">
        <strong>Ray Marching SDF</strong><br>
        Signed Distance Fields rendered entirely in TSL shader nodes. No geometry required!<br><br>
        <em>Drag to orbit</em>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
            "three/nodes": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import {
            uv,
            timerLocal,
            cameraPosition,
            mul,
            add,
            sin,
            cos,
            mix,
            smoothstep,
            pow,
            abs,
            dot,
            normalize,
            sub,
            min,
            max,
            vec2,
            vec3,
            vec4,
            float,
            length,
            clamp,
            sqrt,
            mod
        } from 'three/nodes';
        import {  OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Full-screen quad for ray marching
        const geometry = new THREE.PlaneGeometry(2, 2);

        const material = new THREE.MeshBasicNodeMaterial({
            side: THREE.DoubleSide
        });

        const time = timerLocal();
        const screenUV = uv();

        // Convert UV to ray direction
        const aspectRatio = float(window.innerWidth / window.innerHeight);
        const rayX = mul(sub(mul(screenUV.x, float(2)), float(1)), aspectRatio);
        const rayY = sub(mul(screenUV.y, float(2)), float(1));
        const rayDir = normalize(vec3(rayX, rayY, float(-2.0)));

        // Simplified ray marching in TSL (limited iterations due to TSL constraints)
        // This is a creative use of TSL to approximate ray marching visually

        // Create procedural SDF-like effect using distance and trigonometric functions
        const camDist = length(cameraPosition);
        const angleX = mul(rayX, float(3));
        const angleY = mul(rayY, float(3));

        // Sphere SDF approximation
        const sphereCenter = vec3(
            mul(sin(time), float(0.5)),
            mul(cos(mul(time, 0.7)), float(0.3)),
            float(-5)
        );

        // Distance field visualization
        const distToCenter = sqrt(add(mul(angleX, angleX), mul(angleY, angleY)));
        const sphereDist = abs(sub(distToCenter, float(1.5)));

        // Multiple SDF shapes
        const shape1 = add(sin(mul(distToCenter, float(3))), mul(cos(mul(time, float(2))), float(0.2)));
        const shape2 = mul(sin(add(mul(angleX, float(2)), mul(angleY, float(2)), time)), float(0.3));

        // Combine shapes
        const combinedShape = min(shape1, shape2);

        // Create depth/lighting effect
        const depth = clamp(add(combinedShape, float(0.5)), float(0), float(1));

        // Colors based on depth
        const nearColor = vec3(float(0.2), float(0.6), float(1.0));
        const farColor = vec3(float(0.8), float(0.2), float(0.5));
        const bgColor = vec3(float(0.05), float(0.05), float(0.1));

        // Mix colors based on depth
        let finalColor = mix(nearColor, farColor, depth);

        // Add glow effect
        const glow = pow(sub(float(1), depth), float(3));
        finalColor = add(finalColor, mul(vec3(float(0.5), float(0.8), float(1.0)), glow, float(0.3)));

        // Background gradient
        const bgGradient = mul(add(rayY, float(1)), float(0.5));
        const backgroundColor = mix(bgColor, mul(bgColor, float(1.5)), bgGradient);

        // Threshold for shape visibility
        const shapeThreshold = smoothstep(float(0.2), float(0.8), depth);
        finalColor = mix(backgroundColor, finalColor, shapeThreshold);

        // Add scan lines effect
        const scanLines = mul(sin(mul(screenUV.y, float(500))), float(0.05));
        finalColor = add(finalColor, vec3(scanLines, scanLines, scanLines));

        material.colorNode = vec4(finalColor, float(1));

        const quad = new THREE.Mesh(geometry, material);
        scene.add(quad);

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
