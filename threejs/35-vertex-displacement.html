<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perlin Noise Vertex Displacement</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(76, 201, 240, 0.8);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-family: Arial;
            z-index: 10;
        }
        .info {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: Arial;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10;
        }
        .info div { margin: 5px 0; }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">‚Üê Back</a>
    <div class="info">
        <div><strong>Perlin Noise Terrain</strong></div>
        <div>Real-time vertex displacement</div>
        <div>Mouse: Rotate view</div>
        <div>Scroll: Zoom</div>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.149.0/build/three.module.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.149.0/examples/jsm/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x001020);
        scene.fog = new THREE.Fog(0x001020, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 25);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2;

        // Perlin noise implementation
        class PerlinNoise {
            constructor() {
                this.permutation = [];
                for (let i = 0; i < 256; i++) {
                    this.permutation[i] = i;
                }
                // Shuffle
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.permutation[i], this.permutation[j]] = [this.permutation[j], this.permutation[i]];
                }
                this.p = [...this.permutation, ...this.permutation];
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y, z) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            noise(x, y, z) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                const Z = Math.floor(z) & 255;

                x -= Math.floor(x);
                y -= Math.floor(y);
                z -= Math.floor(z);

                const u = this.fade(x);
                const v = this.fade(y);
                const w = this.fade(z);

                const A = this.p[X] + Y;
                const AA = this.p[A] + Z;
                const AB = this.p[A + 1] + Z;
                const B = this.p[X + 1] + Y;
                const BA = this.p[B] + Z;
                const BB = this.p[B + 1] + Z;

                return this.lerp(w,
                    this.lerp(v,
                        this.lerp(u, this.grad(this.p[AA], x, y, z),
                            this.grad(this.p[BA], x - 1, y, z)),
                        this.lerp(u, this.grad(this.p[AB], x, y - 1, z),
                            this.grad(this.p[BB], x - 1, y - 1, z))),
                    this.lerp(v,
                        this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1),
                            this.grad(this.p[BA + 1], x - 1, y, z - 1)),
                        this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1),
                            this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))));
            }

            octaveNoise(x, y, z, octaves, persistence) {
                let total = 0;
                let frequency = 1;
                let amplitude = 1;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    total += this.noise(x * frequency, y * frequency, z * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= 2;
                }

                return total / maxValue;
            }
        }

        const perlin = new PerlinNoise();

        // Create terrain plane
        const geometry = new THREE.PlaneGeometry(50, 50, 150, 150);
        geometry.rotateX(-Math.PI / 2);

        // Store original positions
        const positions = geometry.attributes.position;
        const originalPositions = new Float32Array(positions.array);

        // Create gradient material
        const material = new THREE.MeshPhongMaterial({
            vertexColors: true,
            flatShading: false,
            shininess: 10,
            side: THREE.DoubleSide
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // Wireframe overlay
        const wireframeGeo = geometry.clone();
        const wireframeMat = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            wireframe: true,
            transparent: true,
            opacity: 0.1
        });
        const wireframe = new THREE.Mesh(wireframeGeo, wireframeMat);
        scene.add(wireframe);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x333333);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0x4488ff, 1, 100);
        pointLight.position.set(0, 10, 0);
        scene.add(pointLight);

        // Update terrain
        function updateTerrain(time) {
            const positions = geometry.attributes.position;
            const wirePositions = wireframeGeo.attributes.position;
            const colors = new Float32Array(positions.count * 3);

            for (let i = 0; i < positions.count; i++) {
                const x = originalPositions[i * 3];
                const z = originalPositions[i * 3 + 2];

                // Multi-octave Perlin noise
                const noise = perlin.octaveNoise(
                    x * 0.05 + time * 0.1,
                    z * 0.05,
                    time * 0.2,
                    6,
                    0.5
                );

                const height = noise * 8;
                positions.array[i * 3 + 1] = height;
                wirePositions.array[i * 3 + 1] = height;

                // Color based on height
                const normalizedHeight = (height + 5) / 10;

                if (normalizedHeight < 0.3) {
                    // Deep blue (water)
                    colors[i * 3] = 0.0;
                    colors[i * 3 + 1] = 0.2 + normalizedHeight * 0.3;
                    colors[i * 3 + 2] = 0.5 + normalizedHeight * 0.5;
                } else if (normalizedHeight < 0.5) {
                    // Sandy beach
                    colors[i * 3] = 0.76;
                    colors[i * 3 + 1] = 0.7;
                    colors[i * 3 + 2] = 0.5;
                } else if (normalizedHeight < 0.7) {
                    // Green land
                    colors[i * 3] = 0.2;
                    colors[i * 3 + 1] = 0.5 + normalizedHeight * 0.3;
                    colors[i * 3 + 2] = 0.1;
                } else {
                    // Rocky mountains
                    colors[i * 3] = 0.4 + normalizedHeight * 0.2;
                    colors[i * 3 + 1] = 0.4 + normalizedHeight * 0.2;
                    colors[i * 3 + 2] = 0.4 + normalizedHeight * 0.2;
                }
            }

            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            positions.needsUpdate = true;
            wirePositions.needsUpdate = true;
            geometry.computeVertexNormals();
            wireframeGeo.computeVertexNormals();
        }

        // Animation
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.0005;

            updateTerrain(time);

            // Rotate point light
            pointLight.position.x = Math.cos(time * 2) * 15;
            pointLight.position.z = Math.sin(time * 2) * 15;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
