<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dandelin Spheres - Conic Sections - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a15;
            color: #e8e6e1;
            overflow: hidden;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            color: #fbbf24;
            text-decoration: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 500;
            z-index: 1000;
            transition: all 0.3s ease;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .back-link:hover {
            background: rgba(251, 191, 36, 0.2);
            transform: translateX(-5px);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        .controls {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            z-index: 1000;
            max-width: 280px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls h2 {
            font-size: 16px;
            color: #fbbf24;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #fbbf24;
            border-radius: 50%;
            cursor: pointer;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 12px;
            color: #ccc;
            margin-bottom: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #fbbf24;
        }

        button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            border: none;
            border-radius: 8px;
            color: #1a1a2e;
            font-weight: 600;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s ease;
            margin-top: 8px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(251, 191, 36, 0.4);
        }

        .conic-type {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        .conic-btn {
            flex: 1;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #ccc;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
        }

        .conic-btn.active {
            background: rgba(251, 191, 36, 0.3);
            border-color: #fbbf24;
            color: #fbbf24;
        }

        .info-panel {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px 20px;
            z-index: 1000;
            max-width: 400px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-panel h3 {
            color: #fbbf24;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .info-panel p {
            font-size: 11px;
            color: #aaa;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: #aaa;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 50%;
        }

        .conic-label {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 80px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.03);
            pointer-events: none;
            z-index: 1;
        }

        @media (max-width: 768px) {
            .controls {
                max-width: 240px;
                padding: 15px;
            }

            .info-panel {
                max-width: calc(100% - 30px);
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <div id="canvas-container"></div>

    <div class="conic-label" id="conicLabel">ELLIPSE</div>

    <div class="controls">
        <h2>Dandelin Spheres</h2>

        <div class="conic-type">
            <button class="conic-btn active" data-type="ellipse">Ellipse</button>
            <button class="conic-btn" data-type="parabola">Parabola</button>
            <button class="conic-btn" data-type="hyperbola">Hyperbola</button>
        </div>

        <div class="control-group">
            <label>Plane Tilt: <span id="tiltVal">30</span>°</label>
            <input type="range" id="tilt" min="5" max="85" value="30">
        </div>

        <div class="control-group">
            <label>Cone Angle: <span id="coneVal">30</span>°</label>
            <input type="range" id="coneAngle" min="15" max="60" value="30">
        </div>

        <div class="control-group checkbox-group">
            <label>
                <input type="checkbox" id="showCone" checked>
                Show Cone
            </label>
            <label>
                <input type="checkbox" id="showSpheres" checked>
                Show Dandelin Spheres
            </label>
            <label>
                <input type="checkbox" id="showPlane" checked>
                Show Cutting Plane
            </label>
            <label>
                <input type="checkbox" id="showConic" checked>
                Show Conic Section
            </label>
            <label>
                <input type="checkbox" id="showFoci" checked>
                Show Foci
            </label>
            <label>
                <input type="checkbox" id="autoRotate">
                Auto Rotate
            </label>
        </div>

        <button id="reset">Reset View</button>
    </div>

    <div class="info-panel">
        <h3>About Dandelin Spheres</h3>
        <p>
            Discovered by Germinal Dandelin (1822), these spheres elegantly prove that conic sections
            have foci. Spheres inscribed in the cone, tangent to both cone and cutting plane,
            touch the plane exactly at the <strong>foci</strong> of the conic.
        </p>
        <p id="conicDescription">
            <strong>Ellipse:</strong> Two spheres (one above, one below) — each tangent point is a focus.
        </p>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(78, 205, 196, 0.8);"></div>
                Dandelin Spheres
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #fbbf24;"></div>
                Foci
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 107, 107, 0.8);"></div>
                Conic Section
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let cone, plane, spheres = [], foci = [], conicCurve;
        let conicType = 'ellipse';
        let planeTilt = 30;
        let coneHalfAngle = 30;
        let autoRotate = false;

        // Settings
        const settings = {
            showCone: true,
            showSpheres: true,
            showPlane: true,
            showConic: true,
            showFoci: true
        };

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a15);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 6, 8);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0xfbbf24, 0.5);
            pointLight.position.set(-5, 5, 5);
            scene.add(pointLight);

            // Grid helper
            const gridHelper = new THREE.GridHelper(20, 20, 0x333333, 0x222222);
            gridHelper.position.y = -5;
            scene.add(gridHelper);

            // Create geometry
            createScene();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            setupControls();

            animate();
        }

        function createScene() {
            // Clear existing objects
            if (cone) scene.remove(cone);
            if (plane) scene.remove(plane);
            spheres.forEach(s => scene.remove(s));
            foci.forEach(f => scene.remove(f));
            if (conicCurve) scene.remove(conicCurve);
            spheres = [];
            foci = [];

            const coneAngleRad = coneHalfAngle * Math.PI / 180;
            const planeTiltRad = planeTilt * Math.PI / 180;

            // Create double cone (two nappes)
            const coneHeight = 8;
            const coneRadius = coneHeight * Math.tan(coneAngleRad);

            const coneGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 64, 1, true);
            const coneMaterial = new THREE.MeshPhongMaterial({
                color: 0x4a4a6a,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                wireframe: false
            });

            // Upper cone
            cone = new THREE.Group();
            const upperCone = new THREE.Mesh(coneGeometry, coneMaterial);
            upperCone.position.y = coneHeight / 2;
            cone.add(upperCone);

            // Lower cone (inverted)
            const lowerCone = new THREE.Mesh(coneGeometry, coneMaterial);
            lowerCone.rotation.x = Math.PI;
            lowerCone.position.y = -coneHeight / 2;
            cone.add(lowerCone);

            // Cone wireframe
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0x6a6a8a,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            const upperWire = new THREE.Mesh(coneGeometry, wireframeMaterial);
            upperWire.position.y = coneHeight / 2;
            cone.add(upperWire);

            const lowerWire = new THREE.Mesh(coneGeometry, wireframeMaterial);
            lowerWire.rotation.x = Math.PI;
            lowerWire.position.y = -coneHeight / 2;
            cone.add(lowerWire);

            scene.add(cone);

            // Create cutting plane
            const planeSize = 12;
            const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize);
            const planeMaterial = new THREE.MeshPhongMaterial({
                color: 0x3388ff,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            plane = new THREE.Mesh(planeGeometry, planeMaterial);

            // Position plane based on conic type
            let planeY = 0;
            let effectiveTilt = planeTiltRad;

            if (conicType === 'ellipse') {
                effectiveTilt = Math.min(planeTiltRad, coneAngleRad - 0.05);
                planeY = 2;
            } else if (conicType === 'parabola') {
                effectiveTilt = coneAngleRad;
                planeY = 2;
            } else { // hyperbola
                effectiveTilt = Math.max(planeTiltRad, coneAngleRad + 0.05);
                planeY = 0;
            }

            plane.rotation.x = -Math.PI / 2 + effectiveTilt;
            plane.position.y = planeY;
            scene.add(plane);

            // Create Dandelin spheres
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: 0x4ecdc4,
                transparent: true,
                opacity: 0.6
            });

            // Calculate sphere positions and radii
            if (conicType === 'ellipse') {
                // Two spheres for ellipse
                const sphereData = calculateEllipseSpheres(coneAngleRad, effectiveTilt, planeY);
                sphereData.forEach(data => {
                    const sphereGeom = new THREE.SphereGeometry(data.radius, 32, 32);
                    const sphere = new THREE.Mesh(sphereGeom, sphereMaterial);
                    sphere.position.set(0, data.y, 0);
                    scene.add(sphere);
                    spheres.push(sphere);

                    // Focus point
                    const focusGeom = new THREE.SphereGeometry(0.15, 16, 16);
                    const focusMat = new THREE.MeshPhongMaterial({ color: 0xfbbf24, emissive: 0xfbbf24, emissiveIntensity: 0.5 });
                    const focus = new THREE.Mesh(focusGeom, focusMat);
                    focus.position.copy(data.focusPos);
                    scene.add(focus);
                    foci.push(focus);
                });
            } else if (conicType === 'parabola') {
                // One sphere for parabola
                const data = calculateParabolaSphere(coneAngleRad, effectiveTilt, planeY);
                const sphereGeom = new THREE.SphereGeometry(data.radius, 32, 32);
                const sphere = new THREE.Mesh(sphereGeom, sphereMaterial);
                sphere.position.set(0, data.y, 0);
                scene.add(sphere);
                spheres.push(sphere);

                const focusGeom = new THREE.SphereGeometry(0.15, 16, 16);
                const focusMat = new THREE.MeshPhongMaterial({ color: 0xfbbf24, emissive: 0xfbbf24, emissiveIntensity: 0.5 });
                const focus = new THREE.Mesh(focusGeom, focusMat);
                focus.position.copy(data.focusPos);
                scene.add(focus);
                foci.push(focus);
            } else {
                // Two spheres for hyperbola (on opposite nappes)
                const sphereData = calculateHyperbolaSpheres(coneAngleRad, effectiveTilt, planeY);
                sphereData.forEach(data => {
                    const sphereGeom = new THREE.SphereGeometry(data.radius, 32, 32);
                    const sphere = new THREE.Mesh(sphereGeom, sphereMaterial);
                    sphere.position.set(0, data.y, 0);
                    scene.add(sphere);
                    spheres.push(sphere);

                    const focusGeom = new THREE.SphereGeometry(0.15, 16, 16);
                    const focusMat = new THREE.MeshPhongMaterial({ color: 0xfbbf24, emissive: 0xfbbf24, emissiveIntensity: 0.5 });
                    const focus = new THREE.Mesh(focusGeom, focusMat);
                    focus.position.copy(data.focusPos);
                    scene.add(focus);
                    foci.push(focus);
                });
            }

            // Draw conic section curve
            drawConicSection(coneAngleRad, effectiveTilt, planeY);

            updateVisibility();
        }

        function calculateEllipseSpheres(coneAngle, planeAngle, planeY) {
            const results = [];

            // Simplified calculation for visualization
            const tanCone = Math.tan(coneAngle);

            // Upper sphere
            const r1 = 0.8;
            const y1 = planeY + r1 / Math.sin(coneAngle) + 0.5;
            const focusZ1 = (y1 - planeY) * Math.tan(planeAngle);
            results.push({
                radius: r1,
                y: y1,
                focusPos: new THREE.Vector3(0, planeY + 0.01, focusZ1)
            });

            // Lower sphere
            const r2 = 0.6;
            const y2 = planeY - r2 / Math.sin(coneAngle) - 0.3;
            const focusZ2 = (y2 - planeY) * Math.tan(planeAngle);
            results.push({
                radius: r2,
                y: y2,
                focusPos: new THREE.Vector3(0, planeY + 0.01, focusZ2)
            });

            return results;
        }

        function calculateParabolaSphere(coneAngle, planeAngle, planeY) {
            const r = 0.7;
            const y = planeY + r / Math.sin(coneAngle) + 0.3;
            const focusZ = (y - planeY) * Math.tan(planeAngle);

            return {
                radius: r,
                y: y,
                focusPos: new THREE.Vector3(0, planeY + 0.01, focusZ)
            };
        }

        function calculateHyperbolaSpheres(coneAngle, planeAngle, planeY) {
            const results = [];

            // Upper sphere (upper nappe)
            const r1 = 0.7;
            const y1 = 3;
            results.push({
                radius: r1,
                y: y1,
                focusPos: new THREE.Vector3(0, planeY + 0.01, 1.5)
            });

            // Lower sphere (lower nappe)
            const r2 = 0.7;
            const y2 = -3;
            results.push({
                radius: r2,
                y: y2,
                focusPos: new THREE.Vector3(0, planeY + 0.01, -1.5)
            });

            return results;
        }

        function drawConicSection(coneAngle, planeAngle, planeY) {
            const points = [];
            const segments = 100;

            const conicMaterial = new THREE.LineBasicMaterial({
                color: 0xff6b6b,
                linewidth: 3
            });

            if (conicType === 'ellipse') {
                // Parametric ellipse on tilted plane
                const a = 2.5; // semi-major
                const b = 1.5; // semi-minor

                for (let i = 0; i <= segments; i++) {
                    const t = (i / segments) * Math.PI * 2;
                    const x = a * Math.cos(t);
                    const z = b * Math.sin(t);
                    const y = planeY + z * Math.tan(planeAngle);
                    points.push(new THREE.Vector3(x, y, z));
                }
            } else if (conicType === 'parabola') {
                // Parametric parabola
                for (let i = 0; i <= segments; i++) {
                    const t = (i / segments) * 6 - 3;
                    const x = t;
                    const z = 0.3 * t * t;
                    const y = planeY + z * Math.tan(planeAngle);
                    points.push(new THREE.Vector3(x, y, z));
                }
            } else {
                // Hyperbola (two branches)
                // Right branch
                for (let i = 0; i <= segments / 2; i++) {
                    const t = (i / (segments / 2)) * 3;
                    const x = Math.cosh(t);
                    const z = Math.sinh(t);
                    const y = planeY + z * Math.tan(planeAngle) * 0.3;
                    points.push(new THREE.Vector3(x, y, z));
                }
                // Left branch
                for (let i = 0; i <= segments / 2; i++) {
                    const t = (i / (segments / 2)) * 3;
                    const x = -Math.cosh(t);
                    const z = -Math.sinh(t);
                    const y = planeY + z * Math.tan(planeAngle) * 0.3;
                    points.push(new THREE.Vector3(x, y, z));
                }
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            conicCurve = new THREE.Line(geometry, conicMaterial);
            scene.add(conicCurve);
        }

        function updateVisibility() {
            if (cone) cone.visible = settings.showCone;
            if (plane) plane.visible = settings.showPlane;
            spheres.forEach(s => s.visible = settings.showSpheres);
            foci.forEach(f => f.visible = settings.showFoci);
            if (conicCurve) conicCurve.visible = settings.showConic;
        }

        function setupControls() {
            // Conic type buttons
            document.querySelectorAll('.conic-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.conic-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    conicType = btn.dataset.type;
                    document.getElementById('conicLabel').textContent = conicType.toUpperCase();
                    updateDescription();
                    createScene();
                });
            });

            // Sliders
            document.getElementById('tilt').addEventListener('input', (e) => {
                planeTilt = parseInt(e.target.value);
                document.getElementById('tiltVal').textContent = planeTilt;
                createScene();
            });

            document.getElementById('coneAngle').addEventListener('input', (e) => {
                coneHalfAngle = parseInt(e.target.value);
                document.getElementById('coneVal').textContent = coneHalfAngle;
                createScene();
            });

            // Checkboxes
            ['showCone', 'showSpheres', 'showPlane', 'showConic', 'showFoci'].forEach(id => {
                document.getElementById(id).addEventListener('change', (e) => {
                    settings[id] = e.target.checked;
                    updateVisibility();
                });
            });

            document.getElementById('autoRotate').addEventListener('change', (e) => {
                autoRotate = e.target.checked;
            });

            document.getElementById('reset').addEventListener('click', () => {
                camera.position.set(8, 6, 8);
                controls.target.set(0, 0, 0);
                controls.update();
            });
        }

        function updateDescription() {
            const desc = document.getElementById('conicDescription');
            if (conicType === 'ellipse') {
                desc.innerHTML = '<strong>Ellipse:</strong> Two spheres (one above, one below) — each tangent point is a focus.';
            } else if (conicType === 'parabola') {
                desc.innerHTML = '<strong>Parabola:</strong> One sphere — the single tangent point is the focus.';
            } else {
                desc.innerHTML = '<strong>Hyperbola:</strong> Two spheres on opposite nappes — each tangent point is a focus.';
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (autoRotate) {
                cone.rotation.y += 0.005;
                plane.rotation.y += 0.005;
                spheres.forEach(s => s.rotation.y += 0.005);
                if (conicCurve) conicCurve.rotation.y += 0.005;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
