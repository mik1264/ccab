<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perlin Noise Landscape - TSL Enhanced</title>
    <style>
        body { margin: 0; overflow: hidden; background: linear-gradient(#87CEEB, #2F4F4F); }
        canvas { display: block; }
        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(76, 201, 240, 0.8);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-family: Arial;
            z-index: 10;
        }
        .tech-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">← Back</a>
    <div class="tech-badge">TSL Terrain • MaterialX Noise • Dynamic LOD</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
            "three/nodes": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import {
            positionLocal,
            normalLocal,
            timerLocal,
            mul,
            add,
            sin,
            cos,
            mix,
            smoothstep,
            vec3,
            vec4,
            float,
            normalize,
            clamp
        } from 'three/nodes';
        import { mx_fractal_noise_float } from 'three/nodes';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 30, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 25, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.minDistance = 10;
        controls.maxDistance = 80;

        // Create high-resolution terrain
        const terrainSize = 100;
        const resolution = 200;
        const geometry = new THREE.PlaneGeometry(terrainSize, terrainSize, resolution - 1, resolution - 1);
        geometry.rotateX(-Math.PI / 2);

        // TSL material with MaterialX multi-octave noise
        const material = new THREE.MeshStandardNodeMaterial({
            roughness: 0.8,
            metalness: 0.1,
            wireframe: false
        });

        const time = timerLocal();
        const pos = positionLocal;
        const norm = normalLocal;

        // Multi-octave fractal noise for terrain height
        const noiseScale = float(0.03);
        const timeScale = mul(time, float(0.1));

        // First octave - large features
        const noisePos1 = mul(vec3(pos.x, pos.z, timeScale), noiseScale);
        const noise1 = mx_fractal_noise_float(noisePos1, float(4), float(2.0), float(0.5));

        // Second octave - medium details
        const noisePos2 = mul(vec3(pos.x, pos.z, timeScale), mul(noiseScale, float(2)));
        const noise2 = mx_fractal_noise_float(noisePos2, float(3), float(2.0), float(0.5));

        // Third octave - fine details
        const noisePos3 = mul(vec3(pos.x, pos.z, timeScale), mul(noiseScale, float(4)));
        const noise3 = mx_fractal_noise_float(noisePos3, float(2), float(2.0), float(0.5));

        // Combine octaves
        const combinedNoise = add(
            mul(noise1, float(10)),
            mul(noise2, float(3)),
            mul(noise3, float(1))
        );

        // Apply height displacement
        const height = mul(combinedNoise, float(1.0));
        const displacedY = add(pos.y, height);
        const displacedPos = vec3(pos.x, displacedY, pos.z);

        material.positionNode = displacedPos;

        // Height-based coloring
        const snowLevel = float(8);
        const rockLevel = float(5);
        const grassLevel = float(2);

        const snowColor = vec3(float(0.95), float(0.95), float(1.0));
        const rockColor = vec3(float(0.5), float(0.5), float(0.5));
        const grassColor = vec3(float(0.2), float(0.6), float(0.2));
        const sandColor = vec3(float(0.8), float(0.7), float(0.5));

        // Smooth color transitions based on height
        let terrainColor = mix(sandColor, grassColor, smoothstep(float(0), grassLevel, height));
        terrainColor = mix(terrainColor, rockColor, smoothstep(grassLevel, rockLevel, height));
        terrainColor = mix(terrainColor, snowColor, smoothstep(rockLevel, snowLevel, height));

        // Add slope-based variation (steeper = more rock)
        const slopeInfluence = clamp(mul(normalize(norm).y, float(-1)), float(0), float(1));
        terrainColor = mix(terrainColor, rockColor, mul(slopeInfluence, float(0.3)));

        material.colorNode = terrainColor;

        const terrain = new THREE.Mesh(geometry, material);
        terrain.receiveShadow = true;
        terrain.castShadow = true;
        scene.add(terrain);

        // Add water plane
        const waterGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize);
        waterGeometry.rotateX(-Math.PI / 2);

        const waterMaterial = new THREE.MeshStandardMaterial({
            color: 0x1E90FF,
            transparent: true,
            opacity: 0.6,
            roughness: 0.1,
            metalness: 0.8
        });

        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.position.y = 1;
        scene.add(water);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(50, 50, 30);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Add clouds as particle system
        const cloudCount = 500;
        const cloudGeometry = new THREE.BufferGeometry();
        const cloudPositions = new Float32Array(cloudCount * 3);
        const cloudSizes = new Float32Array(cloudCount);

        for (let i = 0; i < cloudCount; i++) {
            cloudPositions[i * 3] = (Math.random() - 0.5) * 120;
            cloudPositions[i * 3 + 1] = 15 + Math.random() * 10;
            cloudPositions[i * 3 + 2] = (Math.random() - 0.5) * 120;
            cloudSizes[i] = 2 + Math.random() * 3;
        }

        cloudGeometry.setAttribute('position', new THREE.BufferAttribute(cloudPositions, 3));
        cloudGeometry.setAttribute('size', new THREE.BufferAttribute(cloudSizes, 1));

        const cloudMaterial = new THREE.PointsMaterial({
            size: 5,
            color: 0xffffff,
            transparent: true,
            opacity: 0.6,
            sizeAttenuation: true
        });

        const clouds = new THREE.Points(cloudGeometry, cloudMaterial);
        scene.add(clouds);

        camera.lookAt(0, 0, 0);

        function animate() {
            requestAnimationFrame(animate);

            // Slowly move clouds
            clouds.position.x += 0.01;
            if (clouds.position.x > 60) clouds.position.x = -60;

            // Animate water
            water.position.y = 1 + Math.sin(Date.now() * 0.0005) * 0.2;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
