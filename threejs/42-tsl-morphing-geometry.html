<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TSL Morphing Geometry</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(76, 201, 240, 0.8);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-family: Arial;
            z-index: 10;
        }
        .tech-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }
        .info {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: Arial;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">← Back</a>
    <div class="tech-badge">TSL Morphing • Shape Interpolation • Procedural Animation</div>
    <div class="info">
        <div><strong>Morphing Geometry</strong></div>
        <div>Sphere ↔ Cube ↔ Torus transitions</div>
        <div>Mouse: Rotate • Scroll: Zoom</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
            "three/nodes": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import {
            color,
            positionLocal,
            normalLocal,
            timerLocal,
            cameraPosition,
            mul,
            add,
            sin,
            cos,
            mix,
            smoothstep,
            pow,
            abs,
            dot,
            normalize,
            sub,
            vec3,
            vec4,
            float,
            length,
            clamp,
            fract,
            step
        } from 'three/nodes';
        import { mx_fractal_noise_vec3, mx_worley_noise_float } from 'three/nodes';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Create base geometry (sphere with high resolution)
        const geometry = new THREE.SphereGeometry(2, 256, 256);

        // TSL-based morphing material
        const material = new THREE.MeshStandardNodeMaterial({
            roughness: 0.3,
            metalness: 0.7,
            wireframe: false
        });

        const time = timerLocal();
        const pos = positionLocal;
        const norm = normalLocal;

        // Morph cycle: 0-1 = sphere to cube, 1-2 = cube to torus, 2-3 = torus to sphere
        const cycleTime = mul(time, float(0.2));
        const morphPhase = fract(cycleTime);

        // Distance from center
        const dist = length(pos);

        // Sphere shape (original)
        const spherePos = mul(normalize(pos), float(2));

        // Cube shape
        const absPos = vec3(abs(pos.x), abs(pos.y), abs(pos.z));
        const maxComp = clamp(
            add(
                mul(step(absPos.y, absPos.x), step(absPos.z, absPos.x)),
                mul(step(absPos.x, absPos.y), step(absPos.z, absPos.y), float(2)),
                mul(step(absPos.x, absPos.z), step(absPos.y, absPos.z), float(4))
            ),
            float(0),
            float(4)
        );

        const cubeScale = float(2.3);
        const cubeX = mul(normalize(pos).x, cubeScale);
        const cubeY = mul(normalize(pos).y, cubeScale);
        const cubeZ = mul(normalize(pos).z, cubeScale);
        const cubePos = vec3(cubeX, cubeY, cubeZ);

        // Torus shape approximation using cylindrical distortion
        const theta = mul(time, float(0.5));
        const torusR = float(1.5); // Major radius
        const torusr = float(0.7); // Minor radius

        const angle = Math.atan2(1, 1); // This will be computed per-vertex in reality
        // Simplified torus: distort sphere into torus-like shape
        const torusDistort = mul(
            sin(add(mul(pos.x, float(2)), mul(pos.z, float(2)))),
            float(0.8)
        );
        const torusPos = add(pos, mul(norm, torusDistort));

        // Morph between shapes based on cycle
        const cycle = fract(mul(time, float(0.15)));
        const phase1 = smoothstep(float(0), float(0.33), cycle);
        const phase2 = smoothstep(float(0.33), float(0.66), cycle);
        const phase3 = smoothstep(float(0.66), float(1.0), cycle);

        // First morph: sphere to cube
        let morphedPos = mix(spherePos, cubePos, phase1);

        // Second morph: to torus
        morphedPos = mix(morphedPos, torusPos, sub(phase2, phase1));

        // Third morph: back to sphere
        morphedPos = mix(morphedPos, spherePos, sub(phase3, phase2));

        // Add noise displacement for organic feel
        const noisePos = mul(add(pos, vec3(time, time, time)), float(0.5));
        const noise = mx_fractal_noise_vec3(noisePos, float(2), float(2.0), float(0.5));
        const noiseDisplacement = mul(noise, float(0.15));
        morphedPos = add(morphedPos, noiseDisplacement);

        material.positionNode = morphedPos;

        // Dynamic color based on morph phase
        const color1 = vec3(float(0.2), float(0.6), float(1.0)); // Blue (sphere)
        const color2 = vec3(float(1.0), float(0.4), float(0.2)); // Orange (cube)
        const color3 = vec3(float(0.4), float(1.0), float(0.5)); // Green (torus)

        let baseColor = mix(color1, color2, phase1);
        baseColor = mix(baseColor, color3, sub(phase2, phase1));
        baseColor = mix(baseColor, color1, sub(phase3, phase2));

        // Fresnel effect
        const viewDir = normalize(sub(cameraPosition, pos));
        const fresnel = pow(sub(float(1.0), abs(dot(viewDir, norm))), float(2.0));
        const fresnelGlow = mul(baseColor, fresnel, float(0.5));

        const finalColor = add(baseColor, fresnelGlow);
        material.colorNode = finalColor;

        // Emissive
        material.emissiveNode = mul(finalColor, fresnel, float(0.3));

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // Add wireframe overlay
        const wireframeGeometry = new THREE.SphereGeometry(2, 256, 256);
        const wireframeMaterial = new THREE.MeshBasicNodeMaterial({
            wireframe: true,
            transparent: true,
            opacity: 0.15
        });
        wireframeMaterial.positionNode = morphedPos;
        wireframeMaterial.colorNode = vec3(float(1.0), float(1.0), float(1.0));

        const wireframeMesh = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
        scene.add(wireframeMesh);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0x4080ff, 2, 50);
        pointLight1.position.set(10, 10, 10);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff8040, 1.5, 50);
        pointLight2.position.set(-10, -10, 10);
        scene.add(pointLight2);

        function animate() {
            requestAnimationFrame(animate);

            // Slow rotation
            mesh.rotation.y += 0.003;
            mesh.rotation.x += 0.001;
            wireframeMesh.rotation.y += 0.003;
            wireframeMesh.rotation.x += 0.001;

            // Animate lights
            const t = Date.now() * 0.0003;
            pointLight1.position.x = Math.cos(t) * 12;
            pointLight1.position.z = Math.sin(t) * 12;
            pointLight2.position.x = Math.cos(t + Math.PI) * 12;
            pointLight2.position.z = Math.sin(t + Math.PI) * 12;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
