<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TSL Particle Flow Field</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(76, 201, 240, 0.8);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-family: Arial;
            z-index: 10;
        }
        .tech-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }
        .info {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: Arial;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">← Back</a>
    <div class="tech-badge">TSL Flow Field • GPU Particles • Curl Noise</div>
    <div class="info">
        <div><strong>Particle Flow Field</strong></div>
        <div>50K particles • Curl noise • TSL compute</div>
        <div>Mouse: Rotate • Scroll: Zoom</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
            "three/nodes": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import {
            color,
            attribute,
            positionLocal,
            timerLocal,
            mul,
            add,
            sin,
            cos,
            mix,
            vec3,
            vec4,
            float,
            length,
            normalize,
            mod
        } from 'three/nodes';
        import { mx_curl_noise } from 'three/nodes';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000510);
        scene.fog = new THREE.FogExp2(0x000510, 0.015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 150;

        // Create particle system with flow field
        const particleCount = 50000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        const lifetimes = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
            // Initialize positions in a volume
            positions[i * 3] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 100;

            // Random velocities
            velocities[i * 3] = (Math.random() - 0.5) * 0.2;
            velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.2;
            velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.2;

            // Color based on initial position
            const hue = (i / particleCount) * 360;
            const c = new THREE.Color(`hsl(${hue}, 80%, 60%)`);
            colors[i * 3] = c.r;
            colors[i * 3 + 1] = c.g;
            colors[i * 3 + 2] = c.b;

            sizes[i] = Math.random() * 2 + 0.5;
            lifetimes[i] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('aLifetime', new THREE.BufferAttribute(lifetimes, 1));

        // TSL material for particles with flow field influence
        const particleColor = attribute('color', 'vec3');
        const particleSize = attribute('aSize', 'float');
        const particleLifetime = attribute('aLifetime', 'float');

        const time = timerLocal();
        const pos = positionLocal;

        // Curl noise for flow field
        const flowScale = float(0.05);
        const flowTime = mul(time, float(0.2));
        const flowPos = mul(pos, flowScale);
        const curlNoise = mx_curl_noise(add(flowPos, vec3(flowTime, flowTime, flowTime)));

        // Distance-based effects
        const distanceFromCenter = length(pos);
        const distanceFactor = mul(distanceFromCenter, float(0.01));

        // Pulsing based on lifetime
        const pulse = add(sin(add(mul(time, float(3)), mul(particleLifetime, float(6.28)))), float(1));
        const dynamicSize = mul(particleSize, add(float(0.8), mul(pulse, float(0.4))));

        // Color modulation
        const colorShift = add(mul(sin(mul(time, float(0.5))), float(0.3)), float(1));
        const finalColor = mul(vec3(particleColor), colorShift);

        // Add glow based on curl noise strength
        const curlStrength = length(curlNoise);
        const glow = mul(curlStrength, float(0.5));
        const glowColor = add(finalColor, vec3(glow, glow, mul(glow, float(1.5))));

        const material = new THREE.PointsNodeMaterial({
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        material.sizeNode = mul(dynamicSize, float(window.innerHeight * 0.02));
        material.colorNode = vec4(glowColor, float(0.6));

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // Update particle positions in animation loop
        function updateParticles() {
            const positions = geometry.attributes.position.array;
            const velocities = geometry.attributes.velocity.array;
            const t = Date.now() * 0.0001;

            for (let i = 0; i < particleCount; i++) {
                const idx = i * 3;

                // Get position
                let x = positions[idx];
                let y = positions[idx + 1];
                let z = positions[idx + 2];

                // Apply curl noise flow field
                const scale = 0.05;
                const flowX = x * scale + t;
                const flowY = y * scale + t;
                const flowZ = z * scale + t;

                // Simplified curl noise approximation
                const curlX = Math.sin(flowY) * Math.cos(flowZ) * 0.1;
                const curlY = Math.sin(flowZ) * Math.cos(flowX) * 0.1;
                const curlZ = Math.sin(flowX) * Math.cos(flowY) * 0.1;

                velocities[idx] += curlX * 0.05;
                velocities[idx + 1] += curlY * 0.05;
                velocities[idx + 2] += curlZ * 0.05;

                // Apply velocity damping
                velocities[idx] *= 0.98;
                velocities[idx + 1] *= 0.98;
                velocities[idx + 2] *= 0.98;

                // Update positions
                positions[idx] += velocities[idx];
                positions[idx + 1] += velocities[idx + 1];
                positions[idx + 2] += velocities[idx + 2];

                // Boundary wrapping
                const boundary = 50;
                if (Math.abs(positions[idx]) > boundary) positions[idx] = -positions[idx];
                if (Math.abs(positions[idx + 1]) > boundary) positions[idx + 1] = -positions[idx + 1];
                if (Math.abs(positions[idx + 2]) > boundary) positions[idx + 2] = -positions[idx + 2];
            }

            geometry.attributes.position.needsUpdate = true;
        }

        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        function animate() {
            requestAnimationFrame(animate);

            updateParticles();

            // Rotate entire particle system slowly
            particles.rotation.y += 0.0005;
            particles.rotation.x += 0.0002;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
