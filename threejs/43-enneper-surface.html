<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enneper Surface Curvature Explorer - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0e1a;
            color: #e8e6e1;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            color: #fbbf24;
            text-decoration: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 500;
            z-index: 1000;
            transition: all 0.3s ease;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .back-link:hover {
            background: rgba(251, 191, 36, 0.2);
            transform: translateX(-5px);
        }

        .controls {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            z-index: 1000;
            max-width: 320px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls h2 {
            font-size: 16px;
            color: #fbbf24;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 5px;
        }

        .control-group select,
        .control-group input[type="range"] {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-size: 13px;
        }

        .control-group select option {
            background: #1a1a2e;
        }

        .control-group input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            padding: 0;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #fbbf24;
            border-radius: 50%;
            cursor: pointer;
        }

        .checkbox-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 12px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #fbbf24;
        }

        .info-panel {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px 20px;
            z-index: 1000;
            max-width: 400px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-panel h3 {
            color: #fbbf24;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .info-panel p {
            font-size: 11px;
            color: #aaa;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .formula {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            margin-top: 10px;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            border-radius: 6px;
        }

        .stat-item .label {
            font-size: 10px;
            color: #888;
        }

        .stat-item .value {
            font-size: 13px;
            color: #fbbf24;
            font-family: 'Courier New', monospace;
        }

        .legend {
            display: flex;
            gap: 15px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: #aaa;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        @media (max-width: 768px) {
            .controls {
                max-width: 280px;
                padding: 15px;
            }

            .info-panel {
                max-width: calc(100% - 30px);
                bottom: 10px;
                left: 10px;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <div id="container"></div>

    <div class="controls">
        <h2>Enneper Surface Explorer</h2>

        <div class="control-group">
            <label>Color Mode</label>
            <select id="colorMode">
                <option value="curvature">Gaussian Curvature</option>
                <option value="mean">Mean Curvature (Zero)</option>
                <option value="normal">Surface Normal</option>
                <option value="gradient">Height Gradient</option>
                <option value="wireframe">Wireframe</option>
            </select>
        </div>

        <div class="control-group">
            <label>Surface Range: <span id="rangeVal">1.5</span></label>
            <input type="range" id="range" min="0.5" max="3" step="0.1" value="1.5">
        </div>

        <div class="control-group">
            <label>Resolution: <span id="resVal">80</span></label>
            <input type="range" id="resolution" min="20" max="150" step="10" value="80">
        </div>

        <div class="control-group">
            <label>Rotation Speed: <span id="speedVal">0.5</span></label>
            <input type="range" id="speed" min="0" max="20" value="5">
        </div>

        <div class="control-group checkbox-group">
            <label>
                <input type="checkbox" id="showGeodesics">
                Show Geodesics
            </label>
            <label>
                <input type="checkbox" id="showNormals">
                Show Normals
            </label>
        </div>
    </div>

    <div class="info-panel">
        <h3>Enneper's Minimal Surface</h3>
        <p>
            Discovered by Alfred Enneper in 1864, this self-intersecting minimal surface
            has zero mean curvature everywhere (locally minimizes area).
        </p>
        <div class="formula">
            x = u - u³/3 + uv² &nbsp;&nbsp; y = -v - u²v + v³/3 &nbsp;&nbsp; z = u² - v²
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="label">Gaussian Curvature K</div>
                <div class="value" id="gaussK">-4/(1+u²+v²)⁴</div>
            </div>
            <div class="stat-item">
                <div class="label">Mean Curvature H</div>
                <div class="value" id="meanH">0 (minimal)</div>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);"></div>
                K: Negative → Zero
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #10b981;"></div>
                Geodesic curves
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let enneperMesh, geodesicLines, normalHelpers;
        let surfaceRange = 1.5;
        let resolution = 80;
        let rotationSpeed = 0.005;
        let colorMode = 'curvature';
        let showGeodesics = false;
        let showNormals = false;

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0e1a);

            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(5, 4, 5);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1;

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0x8888ff, 0.5);
            directionalLight2.position.set(-5, -5, -5);
            scene.add(directionalLight2);

            // Create surface
            createEnneperSurface();

            // Handle resize
            window.addEventListener('resize', onWindowResize);

            // Setup controls
            setupControls();

            // Start animation
            animate();
        }

        // Enneper parametric equations
        function enneperX(u, v) {
            return u - (u * u * u) / 3 + u * v * v;
        }

        function enneperY(u, v) {
            return -v - u * u * v + (v * v * v) / 3;
        }

        function enneperZ(u, v) {
            return u * u - v * v;
        }

        // Gaussian curvature at point (u, v)
        function gaussianCurvature(u, v) {
            const denom = 1 + u * u + v * v;
            return -4 / Math.pow(denom, 4);
        }

        // Create Enneper surface mesh
        function createEnneperSurface() {
            if (enneperMesh) {
                scene.remove(enneperMesh);
                enneperMesh.geometry.dispose();
                enneperMesh.material.dispose();
            }

            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            const indices = [];
            const normals = [];

            const segments = resolution;
            const range = surfaceRange;

            // Generate vertices
            for (let i = 0; i <= segments; i++) {
                for (let j = 0; j <= segments; j++) {
                    const u = (i / segments - 0.5) * 2 * range;
                    const v = (j / segments - 0.5) * 2 * range;

                    const x = enneperX(u, v);
                    const y = enneperY(u, v);
                    const z = enneperZ(u, v);

                    vertices.push(x, y, z);

                    // Calculate color based on mode
                    const color = getVertexColor(u, v, x, y, z);
                    colors.push(color.r, color.g, color.b);

                    // Calculate normals (approximate)
                    const eps = 0.01;
                    const dx_du = (enneperX(u + eps, v) - enneperX(u - eps, v)) / (2 * eps);
                    const dy_du = (enneperY(u + eps, v) - enneperY(u - eps, v)) / (2 * eps);
                    const dz_du = (enneperZ(u + eps, v) - enneperZ(u - eps, v)) / (2 * eps);

                    const dx_dv = (enneperX(u, v + eps) - enneperX(u, v - eps)) / (2 * eps);
                    const dy_dv = (enneperY(u, v + eps) - enneperY(u, v - eps)) / (2 * eps);
                    const dz_dv = (enneperZ(u, v + eps) - enneperZ(u, v - eps)) / (2 * eps);

                    // Cross product for normal
                    const nx = dy_du * dz_dv - dz_du * dy_dv;
                    const ny = dz_du * dx_dv - dx_du * dz_dv;
                    const nz = dx_du * dy_dv - dy_du * dx_dv;
                    const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;

                    normals.push(nx / len, ny / len, nz / len);
                }
            }

            // Generate indices
            for (let i = 0; i < segments; i++) {
                for (let j = 0; j < segments; j++) {
                    const a = i * (segments + 1) + j;
                    const b = a + segments + 1;
                    const c = a + 1;
                    const d = b + 1;

                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setIndex(indices);

            let material;
            if (colorMode === 'wireframe') {
                material = new THREE.MeshBasicMaterial({
                    color: 0xfbbf24,
                    wireframe: true
                });
            } else {
                material = new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    side: THREE.DoubleSide,
                    shininess: 50,
                    flatShading: false
                });
            }

            enneperMesh = new THREE.Mesh(geometry, material);
            scene.add(enneperMesh);

            // Update geodesics and normals
            if (showGeodesics) createGeodesics();
            if (showNormals) createNormalHelpers();
        }

        function getVertexColor(u, v, x, y, z) {
            const color = new THREE.Color();

            switch (colorMode) {
                case 'curvature': {
                    const K = gaussianCurvature(u, v);
                    // K is always negative for Enneper surface
                    // Map from most negative (red) to zero (green)
                    const t = Math.min(1, Math.max(0, 1 + K * 10));
                    color.setHSL(t * 0.33, 0.9, 0.5);
                    break;
                }

                case 'mean': {
                    // Mean curvature is always 0 for minimal surfaces
                    color.setHSL(0.5, 0.9, 0.5); // Cyan to show H=0
                    break;
                }

                case 'normal': {
                    // Color based on normal direction
                    const eps = 0.01;
                    const dx_du = (enneperX(u + eps, v) - enneperX(u - eps, v)) / (2 * eps);
                    const dy_du = (enneperY(u + eps, v) - enneperY(u - eps, v)) / (2 * eps);
                    const dz_du = (enneperZ(u + eps, v) - enneperZ(u - eps, v)) / (2 * eps);
                    const dx_dv = (enneperX(u, v + eps) - enneperX(u, v - eps)) / (2 * eps);
                    const dy_dv = (enneperY(u, v + eps) - enneperY(u, v - eps)) / (2 * eps);
                    const dz_dv = (enneperZ(u, v + eps) - enneperZ(u, v - eps)) / (2 * eps);

                    const nx = dy_du * dz_dv - dz_du * dy_dv;
                    const ny = dz_du * dx_dv - dx_du * dz_dv;
                    const nz = dx_du * dy_dv - dy_du * dx_dv;
                    const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;

                    color.setRGB(
                        (nx / len + 1) / 2,
                        (ny / len + 1) / 2,
                        (nz / len + 1) / 2
                    );
                    break;
                }

                case 'gradient': {
                    // Height-based gradient
                    const height = z;
                    const range = surfaceRange * surfaceRange * 2;
                    const t = (height + range) / (2 * range);
                    color.setHSL(0.7 - t * 0.5, 0.8, 0.5);
                    break;
                }

                default:
                    color.setHex(0xfbbf24);
            }

            return color;
        }

        // Create geodesic curves on the surface
        function createGeodesics() {
            if (geodesicLines) {
                geodesicLines.forEach(line => {
                    scene.remove(line);
                    line.geometry.dispose();
                    line.material.dispose();
                });
            }
            geodesicLines = [];

            const numGeodesics = 8;
            const range = surfaceRange;

            // Geodesics along u and v parameter lines
            for (let i = 0; i < numGeodesics; i++) {
                const points = [];
                const t = (i / (numGeodesics - 1) - 0.5) * 2 * range * 0.8;

                // u-geodesic (v = const)
                for (let j = 0; j <= 50; j++) {
                    const u = (j / 50 - 0.5) * 2 * range * 0.9;
                    points.push(new THREE.Vector3(
                        enneperX(u, t),
                        enneperY(u, t),
                        enneperZ(u, t)
                    ));
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x10b981, linewidth: 2 });
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                geodesicLines.push(line);
            }

            // v-geodesics (u = const)
            for (let i = 0; i < numGeodesics; i++) {
                const points = [];
                const t = (i / (numGeodesics - 1) - 0.5) * 2 * range * 0.8;

                for (let j = 0; j <= 50; j++) {
                    const v = (j / 50 - 0.5) * 2 * range * 0.9;
                    points.push(new THREE.Vector3(
                        enneperX(t, v),
                        enneperY(t, v),
                        enneperZ(t, v)
                    ));
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0xf472b6, linewidth: 2 });
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                geodesicLines.push(line);
            }
        }

        // Create normal vector helpers
        function createNormalHelpers() {
            if (normalHelpers) {
                normalHelpers.forEach(helper => {
                    scene.remove(helper);
                    helper.geometry.dispose();
                    helper.material.dispose();
                });
            }
            normalHelpers = [];

            const numNormals = 10;
            const range = surfaceRange * 0.7;

            for (let i = 0; i < numNormals; i++) {
                for (let j = 0; j < numNormals; j++) {
                    const u = (i / (numNormals - 1) - 0.5) * 2 * range;
                    const v = (j / (numNormals - 1) - 0.5) * 2 * range;

                    const x = enneperX(u, v);
                    const y = enneperY(u, v);
                    const z = enneperZ(u, v);

                    // Calculate normal
                    const eps = 0.01;
                    const dx_du = (enneperX(u + eps, v) - enneperX(u - eps, v)) / (2 * eps);
                    const dy_du = (enneperY(u + eps, v) - enneperY(u - eps, v)) / (2 * eps);
                    const dz_du = (enneperZ(u + eps, v) - enneperZ(u - eps, v)) / (2 * eps);
                    const dx_dv = (enneperX(u, v + eps) - enneperX(u, v - eps)) / (2 * eps);
                    const dy_dv = (enneperY(u, v + eps) - enneperY(u, v - eps)) / (2 * eps);
                    const dz_dv = (enneperZ(u, v + eps) - enneperZ(u, v - eps)) / (2 * eps);

                    const nx = dy_du * dz_dv - dz_du * dy_dv;
                    const ny = dz_du * dx_dv - dx_du * dz_dv;
                    const nz = dx_du * dy_dv - dy_du * dx_dv;
                    const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;

                    const normalLen = 0.3;
                    const points = [
                        new THREE.Vector3(x, y, z),
                        new THREE.Vector3(
                            x + (nx / len) * normalLen,
                            y + (ny / len) * normalLen,
                            z + (nz / len) * normalLen
                        )
                    ];

                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({ color: 0xfbbf24 });
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                    normalHelpers.push(line);
                }
            }
        }

        function removeGeodesics() {
            if (geodesicLines) {
                geodesicLines.forEach(line => {
                    scene.remove(line);
                    line.geometry.dispose();
                    line.material.dispose();
                });
                geodesicLines = [];
            }
        }

        function removeNormalHelpers() {
            if (normalHelpers) {
                normalHelpers.forEach(helper => {
                    scene.remove(helper);
                    helper.geometry.dispose();
                    helper.material.dispose();
                });
                normalHelpers = [];
            }
        }

        function setupControls() {
            document.getElementById('colorMode').addEventListener('change', (e) => {
                colorMode = e.target.value;
                createEnneperSurface();
            });

            document.getElementById('range').addEventListener('input', (e) => {
                surfaceRange = parseFloat(e.target.value);
                document.getElementById('rangeVal').textContent = surfaceRange.toFixed(1);
                createEnneperSurface();
            });

            document.getElementById('resolution').addEventListener('input', (e) => {
                resolution = parseInt(e.target.value);
                document.getElementById('resVal').textContent = resolution;
                createEnneperSurface();
            });

            document.getElementById('speed').addEventListener('input', (e) => {
                rotationSpeed = e.target.value / 1000;
                controls.autoRotateSpeed = e.target.value / 5;
                document.getElementById('speedVal').textContent = (e.target.value / 10).toFixed(1);
            });

            document.getElementById('showGeodesics').addEventListener('change', (e) => {
                showGeodesics = e.target.checked;
                if (showGeodesics) {
                    createGeodesics();
                } else {
                    removeGeodesics();
                }
            });

            document.getElementById('showNormals').addEventListener('change', (e) => {
                showNormals = e.target.checked;
                if (showNormals) {
                    createNormalHelpers();
                } else {
                    removeNormalHelpers();
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Initialize
        init();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
