<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Observer Theory Playground - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
            --bg: #0a0e14;
            --panel-bg: rgba(18, 24, 32, 0.92);
            --border: rgba(138, 154, 91, 0.25);
            --glow-sage: rgba(138, 154, 91, 0.4);
            --glow-earth: rgba(221, 161, 94, 0.4);
            --text: #e0ddd4;
            --text-dim: #8a8778;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: 'Nunito', sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* Back link */
        .organic-back-link {
            position: fixed;
            top: 12px;
            left: 12px;
            z-index: 10000;
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            color: var(--terracotta);
            text-decoration: none;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            font-size: 0.85rem;
            padding: 0.35rem 0.75rem;
            background: rgba(254, 250, 224, 0.08);
            border-radius: 16px;
            border: 1px solid rgba(138, 154, 91, 0.3);
            transition: all 0.3s ease;
            backdrop-filter: blur(8px);
        }
        .organic-back-link:hover {
            background: rgba(254, 250, 224, 0.15);
            transform: translateX(-3px);
            border-color: var(--earth);
        }

        /* Main layout */
        .app {
            display: grid;
            grid-template-rows: auto 1fr;
            height: 100vh;
            gap: 0;
        }

        /* Header */
        .header {
            padding: 10px 20px 8px;
            text-align: center;
            background: linear-gradient(180deg, rgba(18,24,32,0.95) 0%, transparent 100%);
            position: relative;
            z-index: 100;
        }
        .header h1 {
            font-family: 'Lora', serif;
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--cream);
            letter-spacing: 0.03em;
        }
        .header h1 span { color: var(--earth); }
        .header .subtitle {
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-top: 2px;
        }

        /* Main content area */
        .main-content {
            display: grid;
            grid-template-columns: 260px 1fr 1fr 280px;
            gap: 8px;
            padding: 0 8px 8px;
            min-height: 0;
        }

        /* Panels */
        .panel {
            background: var(--panel-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }
        .panel-header {
            padding: 10px 14px 8px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }
        .panel-header h2 {
            font-family: 'Lora', serif;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--earth);
        }
        .panel-header p {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-top: 2px;
        }
        .panel-body {
            flex: 1;
            overflow-y: auto;
            min-height: 0;
            position: relative;
        }

        /* Controls panel */
        .controls-section {
            padding: 10px 14px;
            border-bottom: 1px solid rgba(138,154,91,0.12);
        }
        .controls-section h3 {
            font-family: 'Lora', serif;
            font-size: 0.78rem;
            color: var(--sage);
            margin-bottom: 6px;
            font-weight: 600;
        }
        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        .control-row label {
            font-size: 0.72rem;
            color: var(--text-dim);
        }
        .control-row select,
        .control-row input[type="range"] {
            background: rgba(255,255,255,0.06);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.72rem;
            padding: 3px 6px;
            font-family: 'Nunito', sans-serif;
        }
        .control-row select {
            width: 130px;
            cursor: pointer;
        }
        .control-row select option {
            background: #1a2030;
        }
        .control-row input[type="range"] {
            width: 100px;
            accent-color: var(--sage);
        }
        .control-row .value-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.68rem;
            color: var(--earth);
            min-width: 28px;
            text-align: right;
        }

        /* Buttons */
        .btn-row {
            display: flex;
            gap: 6px;
            padding: 10px 14px;
        }
        .btn {
            flex: 1;
            padding: 6px 10px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: rgba(138,154,91,0.1);
            color: var(--sage);
            font-family: 'Nunito', sans-serif;
            font-size: 0.72rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn:hover {
            background: rgba(138,154,91,0.25);
            border-color: var(--sage);
        }
        .btn.active {
            background: rgba(138,154,91,0.3);
            border-color: var(--sage);
            box-shadow: 0 0 10px var(--glow-sage);
        }
        .btn-earth {
            background: rgba(221,161,94,0.1);
            color: var(--earth);
            border-color: rgba(221,161,94,0.25);
        }
        .btn-earth:hover {
            background: rgba(221,161,94,0.25);
            border-color: var(--earth);
        }

        /* Canvas containers */
        .canvas-wrap {
            width: 100%;
            height: 100%;
            position: relative;
        }
        .canvas-wrap canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Observer lens badges */
        .lens-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.68rem;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
        }
        .lens-badge.lens-a {
            background: rgba(100, 180, 255, 0.15);
            color: #64b4ff;
            border: 1px solid rgba(100, 180, 255, 0.3);
        }
        .lens-badge.lens-b {
            background: rgba(255, 140, 90, 0.15);
            color: #ff8c5a;
            border: 1px solid rgba(255, 140, 90, 0.3);
        }

        /* Observer labels on canvases */
        .observer-label {
            position: absolute;
            top: 8px;
            left: 10px;
            z-index: 10;
        }

        /* Git graph panel */
        .git-panel {
            grid-column: span 2;
        }
        .git-canvas-wrap {
            display: flex;
            gap: 0;
            height: 100%;
        }
        .git-canvas-wrap canvas {
            flex: 1;
            height: 100%;
            display: block;
        }
        .git-divider {
            width: 1px;
            background: var(--border);
            flex-shrink: 0;
        }

        /* Info panel */
        .info-section {
            padding: 10px 14px;
            border-bottom: 1px solid rgba(138,154,91,0.12);
        }
        .info-section h3 {
            font-family: 'Lora', serif;
            font-size: 0.78rem;
            color: var(--sage);
            margin-bottom: 4px;
            font-weight: 600;
        }
        .info-section p {
            font-size: 0.7rem;
            line-height: 1.5;
            color: var(--text-dim);
        }
        .info-section code {
            font-family: 'JetBrains Mono', monospace;
            background: rgba(138,154,91,0.12);
            padding: 1px 5px;
            border-radius: 4px;
            font-size: 0.65rem;
            color: var(--sage);
        }

        /* Stats row */
        .stats-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            padding: 8px 14px;
        }
        .stat-box {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(138,154,91,0.1);
            border-radius: 8px;
            padding: 6px 8px;
            text-align: center;
        }
        .stat-box .stat-val {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--earth);
        }
        .stat-box .stat-label {
            font-size: 0.6rem;
            color: var(--text-dim);
            margin-top: 1px;
        }

        /* Equivalence indicator */
        .equiv-indicator {
            margin: 8px 14px;
            padding: 8px 10px;
            border-radius: 8px;
            font-size: 0.7rem;
            text-align: center;
            font-weight: 600;
            transition: all 0.3s;
        }
        .equiv-indicator.same {
            background: rgba(138,154,91,0.15);
            border: 1px solid rgba(138,154,91,0.3);
            color: var(--sage);
        }
        .equiv-indicator.different {
            background: rgba(221,161,94,0.15);
            border: 1px solid rgba(221,161,94,0.3);
            color: var(--earth);
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(138,154,91,0.3); border-radius: 4px; }

        /* Speed indicator */
        .speed-indicator {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-dim);
            padding: 4px 14px;
        }

        /* Responsive fallback */
        @media (max-width: 1100px) {
            .main-content {
                grid-template-columns: 220px 1fr 1fr 240px;
            }
        }
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto 1fr 1fr;
            }
            .panel:first-child {
                grid-column: span 2;
            }
            .panel:last-child {
                grid-column: span 2;
            }
        }

        /* Legend items */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 6px 14px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.65rem;
            color: var(--text-dim);
        }
        .legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        /* Tooltip */
        .tooltip {
            position: fixed;
            background: rgba(18,24,32,0.95);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 0.7rem;
            color: var(--text);
            pointer-events: none;
            z-index: 99999;
            max-width: 260px;
            backdrop-filter: blur(8px);
            display: none;
        }

        /* Tab bar */
        .tab-bar {
            display: flex;
            gap: 2px;
            padding: 6px 10px 0;
        }
        .tab {
            padding: 5px 12px;
            border-radius: 8px 8px 0 0;
            font-size: 0.7rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
            border-bottom: none;
            color: var(--text-dim);
            background: transparent;
        }
        .tab.active {
            background: var(--panel-bg);
            color: var(--earth);
            border-color: var(--border);
        }
        .tab:hover:not(.active) {
            color: var(--text);
            background: rgba(255,255,255,0.03);
        }

        .tab-content { display: none; }
        .tab-content.active { display: block; }
    </style>
</head>
<body>
    <a href="../index.html" class="organic-back-link">
        <span class="back-arrow">&#8592;</span>
        <span class="back-text">Gallery</span>
    </a>

    <div class="tooltip" id="tooltip"></div>

    <div class="app">
        <header class="header">
            <h1>Observer Theory <span>Playground</span></h1>
            <p class="subtitle">Navigate the Ruliad, choose observation lenses, and watch different observers construct different realities</p>
        </header>

        <div class="main-content">
            <!-- Left: Controls Panel -->
            <div class="panel">
                <div class="panel-header">
                    <h2>Configuration</h2>
                    <p>Tune the Ruliad and observers</p>
                </div>
                <div class="panel-body">
                    <div class="controls-section">
                        <h3>Ruliad Engine</h3>
                        <div class="control-row">
                            <label>CA Rule</label>
                            <select id="caRule">
                                <option value="30">Rule 30 (Chaotic)</option>
                                <option value="90">Rule 90 (Fractal)</option>
                                <option value="110" selected>Rule 110 (Complex)</option>
                                <option value="184">Rule 184 (Traffic)</option>
                                <option value="73">Rule 73 (Balanced)</option>
                                <option value="54">Rule 54 (Structured)</option>
                                <option value="150">Rule 150 (Additive)</option>
                                <option value="105">Rule 105 (Chaotic-II)</option>
                            </select>
                        </div>
                        <div class="control-row">
                            <label>Grid Width</label>
                            <input type="range" id="gridWidth" min="64" max="400" value="200" step="8">
                            <span class="value-display" id="gridWidthVal">200</span>
                        </div>
                        <div class="control-row">
                            <label>Init Mode</label>
                            <select id="initMode">
                                <option value="single">Single Seed</option>
                                <option value="random">Random 50%</option>
                                <option value="random25">Random 25%</option>
                                <option value="blocks">Block Pattern</option>
                                <option value="gradient">Gradient</option>
                            </select>
                        </div>
                    </div>

                    <div class="controls-section">
                        <h3>Observer A <span class="lens-badge lens-a">Blue</span></h3>
                        <div class="control-row">
                            <label>Lens Type</label>
                            <select id="lensA">
                                <option value="raw">Raw (1:1)</option>
                                <option value="block2" selected>Block 2x2</option>
                                <option value="block3">Block 3x3</option>
                                <option value="block4">Block 4x4</option>
                                <option value="density">Density Field</option>
                                <option value="entropy">Local Entropy</option>
                                <option value="edges">Edge Detection</option>
                                <option value="temporal">Temporal Avg</option>
                            </select>
                        </div>
                        <div class="control-row">
                            <label>Threshold</label>
                            <input type="range" id="threshA" min="0" max="100" value="50">
                            <span class="value-display" id="threshAVal">50%</span>
                        </div>
                    </div>

                    <div class="controls-section">
                        <h3>Observer B <span class="lens-badge lens-b">Amber</span></h3>
                        <div class="control-row">
                            <label>Lens Type</label>
                            <select id="lensB">
                                <option value="raw">Raw (1:1)</option>
                                <option value="block2">Block 2x2</option>
                                <option value="block3">Block 3x3</option>
                                <option value="block4">Block 4x4</option>
                                <option value="density">Density Field</option>
                                <option value="entropy" selected>Local Entropy</option>
                                <option value="edges">Edge Detection</option>
                                <option value="temporal">Temporal Avg</option>
                            </select>
                        </div>
                        <div class="control-row">
                            <label>Threshold</label>
                            <input type="range" id="threshB" min="0" max="100" value="50">
                            <span class="value-display" id="threshBVal">50%</span>
                        </div>
                    </div>

                    <div class="controls-section">
                        <h3>Simulation</h3>
                        <div class="control-row">
                            <label>Speed</label>
                            <input type="range" id="speed" min="1" max="30" value="10">
                            <span class="value-display" id="speedVal">10</span>
                        </div>
                    </div>

                    <div class="btn-row">
                        <button class="btn active" id="btnPlay">Play</button>
                        <button class="btn" id="btnStep">Step</button>
                        <button class="btn btn-earth" id="btnReset">Reset</button>
                    </div>

                    <div class="speed-indicator" id="stepCounter">Step: 0</div>
                </div>
            </div>

            <!-- Center Left: Observer A View -->
            <div class="panel">
                <div class="panel-header" style="display:flex; justify-content:space-between; align-items:center;">
                    <div>
                        <h2>Observer A's Reality</h2>
                        <p>Coarse-grained through blue lens</p>
                    </div>
                    <span class="lens-badge lens-a" id="lensABadge">Block 2x2</span>
                </div>
                <div class="panel-body">
                    <div class="canvas-wrap">
                        <canvas id="canvasA"></canvas>
                    </div>
                </div>
            </div>

            <!-- Center Right: Observer B View -->
            <div class="panel">
                <div class="panel-header" style="display:flex; justify-content:space-between; align-items:center;">
                    <div>
                        <h2>Observer B's Reality</h2>
                        <p>Coarse-grained through amber lens</p>
                    </div>
                    <span class="lens-badge lens-b" id="lensBBadge">Local Entropy</span>
                </div>
                <div class="panel-body">
                    <div class="canvas-wrap">
                        <canvas id="canvasB"></canvas>
                    </div>
                </div>
            </div>

            <!-- Right: Info / Git Panel -->
            <div class="panel">
                <div class="tab-bar">
                    <div class="tab active" data-tab="info">Theory</div>
                    <div class="tab" data-tab="git">Git-Ruliad</div>
                    <div class="tab" data-tab="stats">Stats</div>
                </div>
                <div class="panel-body">
                    <!-- Theory Tab -->
                    <div class="tab-content active" id="tab-info">
                        <div class="info-section">
                            <h3>What is the Ruliad?</h3>
                            <p>The <strong>Ruliad</strong> is Wolfram's concept of the entangled limit of all possible computations. It's the ultimate structure underlying all of reality - every possible rule applied to every possible initial condition, all woven together.</p>
                        </div>
                        <div class="info-section">
                            <h3>Observer Theory</h3>
                            <p>Different observers, embedded in the Ruliad, construct <em>different realities</em> by sampling and coarse-graining the same underlying computation. What you "see" depends on your observational lens.</p>
                        </div>
                        <div class="info-section">
                            <h3>Coarse-Graining</h3>
                            <p>Each lens applies a different reduction:</p>
                            <p><code>Block NxN</code> averages spatial neighborhoods - like blurring reality to see large-scale structure.</p>
                            <p><code>Density</code> computes local population density - seeing flow rather than individuals.</p>
                            <p><code>Entropy</code> measures local disorder - revealing where complexity lives.</p>
                            <p><code>Edge</code> detects boundaries - seeing only where change happens.</p>
                            <p><code>Temporal</code> averages across time - filtering out transient noise.</p>
                        </div>
                        <div class="info-section">
                            <h3>Try This</h3>
                            <p>Set Observer A to <code>Block 2x2</code> and Observer B to <code>Entropy</code>. Notice how they construct completely different narratives from the same Rule 110 Ruliad. One sees smooth structure; the other sees where information is being processed.</p>
                        </div>
                        <div class="equiv-indicator different" id="equivIndicator">
                            Observers see different realities
                        </div>
                    </div>

                    <!-- Git-Ruliad Tab -->
                    <div class="tab-content" id="tab-git">
                        <div class="info-section">
                            <h3>Git as Ruliad</h3>
                            <p>A Git repository is a miniature Ruliad: every commit is a computation state, branches are alternative rule paths, and merges show where separate observers' realities reconnect.</p>
                        </div>
                        <div class="info-section">
                            <h3>The Analogy</h3>
                            <p><code>commit</code> = one step of cellular automaton evolution</p>
                            <p><code>branch</code> = an observer choosing a different coarse-graining rule</p>
                            <p><code>merge</code> = observers discovering their realities are equivalent at a higher level</p>
                            <p><code>diff</code> = the observational gap between two lenses</p>
                        </div>
                        <div style="padding: 10px 14px;">
                            <canvas id="canvasGit" width="248" height="340"></canvas>
                        </div>
                        <div class="info-section">
                            <p>The graph above shows Observer A (blue) and Observer B (amber) branching from a shared Ruliad state, evolving through their own lens, and potentially merging when their coarse-grained views converge.</p>
                        </div>
                    </div>

                    <!-- Stats Tab -->
                    <div class="tab-content" id="tab-stats">
                        <div class="stats-row">
                            <div class="stat-box">
                                <div class="stat-val" id="statSteps">0</div>
                                <div class="stat-label">Steps</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-val" id="statDensity">0%</div>
                                <div class="stat-label">Density</div>
                            </div>
                        </div>
                        <div class="stats-row">
                            <div class="stat-box">
                                <div class="stat-val" id="statEntropyA">0</div>
                                <div class="stat-label">Entropy A</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-val" id="statEntropyB">0</div>
                                <div class="stat-label">Entropy B</div>
                            </div>
                        </div>
                        <div class="stats-row">
                            <div class="stat-box">
                                <div class="stat-val" id="statDivergence">0</div>
                                <div class="stat-label">Divergence</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-val" id="statComplexity">0</div>
                                <div class="stat-label">Complexity</div>
                            </div>
                        </div>
                        <div class="info-section">
                            <h3>Divergence</h3>
                            <p>Measures how differently the two observers perceive reality. High divergence means the lenses construct radically different narratives from the same underlying computation.</p>
                        </div>
                        <div class="info-section">
                            <h3>Complexity</h3>
                            <p>Approximate Kolmogorov complexity of the raw Ruliad, estimated via compression ratio. Higher values indicate the CA is producing genuinely complex, non-trivial structure.</p>
                        </div>
                        <div class="legend">
                            <div class="legend-item"><div class="legend-dot" style="background:#64b4ff"></div> Observer A</div>
                            <div class="legend-item"><div class="legend-dot" style="background:#ff8c5a"></div> Observer B</div>
                            <div class="legend-item"><div class="legend-dot" style="background:var(--sage)"></div> Raw Ruliad</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    (function() {
        'use strict';

        // ================================================================
        // CELLULAR AUTOMATON ENGINE (THE RULIAD)
        // ================================================================
        class Ruliad {
            constructor(rule, width) {
                this.rule = rule;
                this.width = width;
                this.ruleset = this.buildRuleset(rule);
                this.grid = [];
                this.step = 0;
            }

            buildRuleset(ruleNum) {
                const bits = ruleNum.toString(2).padStart(8, '0');
                const patterns = ['111','110','101','100','011','010','001','000'];
                const rs = {};
                patterns.forEach((p, i) => rs[p] = parseInt(bits[i]));
                return rs;
            }

            init(mode) {
                this.grid = [];
                this.step = 0;
                const row = new Uint8Array(this.width);
                switch (mode) {
                    case 'single':
                        row[Math.floor(this.width / 2)] = 1;
                        break;
                    case 'random':
                        for (let i = 0; i < this.width; i++) row[i] = Math.random() < 0.5 ? 1 : 0;
                        break;
                    case 'random25':
                        for (let i = 0; i < this.width; i++) row[i] = Math.random() < 0.25 ? 1 : 0;
                        break;
                    case 'blocks':
                        for (let i = 0; i < this.width; i++) row[i] = (Math.floor(i / 8) % 2 === 0) ? 1 : 0;
                        break;
                    case 'gradient':
                        for (let i = 0; i < this.width; i++) row[i] = Math.random() < (i / this.width) ? 1 : 0;
                        break;
                }
                this.grid.push(row);
            }

            evolve() {
                const prev = this.grid[this.grid.length - 1];
                const next = new Uint8Array(this.width);
                for (let i = 0; i < this.width; i++) {
                    const l = prev[(i - 1 + this.width) % this.width];
                    const c = prev[i];
                    const r = prev[(i + 1) % this.width];
                    next[i] = this.ruleset[`${l}${c}${r}`];
                }
                this.grid.push(next);
                this.step++;
                // Keep limited history for memory
                const maxHistory = 600;
                if (this.grid.length > maxHistory) {
                    this.grid = this.grid.slice(this.grid.length - maxHistory);
                }
                return next;
            }

            getDensity() {
                if (this.grid.length === 0) return 0;
                const row = this.grid[this.grid.length - 1];
                let count = 0;
                for (let i = 0; i < row.length; i++) count += row[i];
                return count / row.length;
            }
        }

        // ================================================================
        // OBSERVATION LENSES (COARSE-GRAINING)
        // ================================================================
        const Lenses = {
            // Raw 1:1 view
            raw(grid, _threshold) {
                return grid.map(row => {
                    const out = new Float32Array(row.length);
                    for (let i = 0; i < row.length; i++) out[i] = row[i];
                    return out;
                });
            },

            // Block NxN averaging
            blockN(grid, n, threshold) {
                const th = threshold / 100;
                const rows = grid.length;
                if (rows === 0) return [];
                const cols = grid[0].length;
                const outRows = Math.floor(rows / n);
                const outCols = Math.floor(cols / n);
                const result = [];
                for (let r = 0; r < outRows; r++) {
                    const outRow = new Float32Array(outCols);
                    for (let c = 0; c < outCols; c++) {
                        let sum = 0;
                        for (let dr = 0; dr < n; dr++) {
                            for (let dc = 0; dc < n; dc++) {
                                const gr = r * n + dr;
                                const gc = c * n + dc;
                                if (gr < rows && gc < cols) sum += grid[gr][gc];
                            }
                        }
                        const avg = sum / (n * n);
                        outRow[c] = avg >= th ? avg : 0;
                    }
                    result.push(outRow);
                }
                return result;
            },

            block2(grid, threshold) { return Lenses.blockN(grid, 2, threshold); },
            block3(grid, threshold) { return Lenses.blockN(grid, 3, threshold); },
            block4(grid, threshold) { return Lenses.blockN(grid, 4, threshold); },

            // Density field - Gaussian-like local density
            density(grid, threshold) {
                const radius = 4;
                const th = threshold / 100 * 0.5;
                return grid.map(row => {
                    const cols = row.length;
                    const out = new Float32Array(cols);
                    for (let i = 0; i < cols; i++) {
                        let sum = 0, weight = 0;
                        for (let d = -radius; d <= radius; d++) {
                            const j = (i + d + cols) % cols;
                            const w = Math.exp(-d * d / (2 * radius));
                            sum += row[j] * w;
                            weight += w;
                        }
                        const val = sum / weight;
                        out[i] = val >= th ? val : 0;
                    }
                    return out;
                });
            },

            // Local entropy - Shannon entropy in neighborhood
            entropy(grid, threshold) {
                const radius = 5;
                const th = threshold / 100;
                return grid.map(row => {
                    const cols = row.length;
                    const out = new Float32Array(cols);
                    for (let i = 0; i < cols; i++) {
                        let ones = 0;
                        const n = 2 * radius + 1;
                        for (let d = -radius; d <= radius; d++) {
                            ones += row[(i + d + cols) % cols];
                        }
                        const p1 = ones / n;
                        const p0 = 1 - p1;
                        let H = 0;
                        if (p1 > 0 && p1 < 1) {
                            H = -(p1 * Math.log2(p1) + p0 * Math.log2(p0));
                        }
                        out[i] = H >= th ? H : 0;
                    }
                    return out;
                });
            },

            // Edge detection - XOR-like boundary detection
            edges(grid, threshold) {
                const th = threshold / 100;
                return grid.map(row => {
                    const cols = row.length;
                    const out = new Float32Array(cols);
                    for (let i = 0; i < cols; i++) {
                        const l = row[(i - 1 + cols) % cols];
                        const r = row[(i + 1) % cols];
                        const val = Math.abs(row[i] - l) + Math.abs(row[i] - r);
                        out[i] = val / 2 >= th ? val / 2 : 0;
                    }
                    return out;
                });
            },

            // Temporal averaging over last N rows
            temporal(grid, threshold) {
                const window = 6;
                const th = threshold / 100 * 0.5;
                const rows = grid.length;
                if (rows === 0) return [];
                const cols = grid[0].length;
                const result = [];
                for (let r = 0; r < rows; r++) {
                    const out = new Float32Array(cols);
                    const start = Math.max(0, r - window + 1);
                    const count = r - start + 1;
                    for (let c = 0; c < cols; c++) {
                        let sum = 0;
                        for (let t = start; t <= r; t++) {
                            sum += grid[t][c];
                        }
                        const val = sum / count;
                        out[c] = val >= th ? val : 0;
                    }
                    result.push(out);
                }
                return result;
            }
        };

        // ================================================================
        // RENDERING
        // ================================================================
        class Renderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.resize();
            }

            resize() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.w = rect.width;
                this.h = rect.height;
            }

            drawGrid(data, colorFn, scrollOffset) {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.w, this.h);

                if (!data || data.length === 0) return;

                const rows = data.length;
                const cols = data[0].length;
                const cellW = this.w / cols;
                const cellH = Math.max(1, Math.min(cellW, this.h / Math.min(rows, 200)));
                const visibleRows = Math.ceil(this.h / cellH);

                // Draw from bottom up (newest at bottom)
                const startRow = Math.max(0, rows - visibleRows - scrollOffset);
                const endRow = Math.min(rows, startRow + visibleRows + 1);

                for (let r = startRow; r < endRow; r++) {
                    const y = (r - startRow) * cellH;
                    if (y > this.h) break;
                    const row = data[r];
                    if (!row) continue;
                    for (let c = 0; c < cols; c++) {
                        const val = row[c];
                        if (val > 0.001) {
                            ctx.fillStyle = colorFn(val);
                            ctx.fillRect(c * cellW, y, Math.ceil(cellW), Math.ceil(cellH));
                        }
                    }
                }
            }
        }

        // Color functions for observers
        function colorA(val) {
            const v = Math.min(1, val);
            const r = Math.floor(30 + 70 * (1 - v));
            const g = Math.floor(100 + 80 * v);
            const b = Math.floor(180 + 75 * v);
            return `rgb(${r},${g},${b})`;
        }

        function colorB(val) {
            const v = Math.min(1, val);
            const r = Math.floor(180 + 75 * v);
            const g = Math.floor(80 + 60 * v);
            const b = Math.floor(40 + 50 * (1 - v));
            return `rgb(${r},${g},${b})`;
        }

        // ================================================================
        // GIT-RULIAD GRAPH RENDERER
        // ================================================================
        class GitGraph {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.commits = [];
                this.maxCommits = 30;
            }

            resize() {
                const rect = this.canvas.parentElement
                    ? { width: this.canvas.parentElement.clientWidth - 28, height: 340 }
                    : { width: 248, height: 340 };
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.w = rect.width;
                this.h = rect.height;
            }

            addCommit(step, densityA, densityB, divergence) {
                this.commits.push({ step, densityA, densityB, divergence });
                if (this.commits.length > this.maxCommits) {
                    this.commits.shift();
                }
            }

            draw() {
                const ctx = this.ctx;
                const w = this.w;
                const h = this.h;
                ctx.clearRect(0, 0, w, h);

                if (this.commits.length < 2) return;

                const n = this.commits.length;
                const marginTop = 20;
                const marginBottom = 20;
                const rowH = (h - marginTop - marginBottom) / (n - 1);

                const centerX = w / 2;
                const branchSpread = w * 0.25;

                // Draw merge lines from root
                ctx.save();

                // Background trunk line
                ctx.strokeStyle = 'rgba(138,154,91,0.15)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(centerX, marginTop);
                ctx.lineTo(centerX, h - marginBottom);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw branch lines
                const pointsA = [];
                const pointsB = [];

                for (let i = 0; i < n; i++) {
                    const c = this.commits[i];
                    const y = marginTop + i * rowH;
                    const spread = c.divergence * branchSpread;
                    const xA = centerX - spread;
                    const xB = centerX + spread;
                    pointsA.push({ x: xA, y });
                    pointsB.push({ x: xB, y });
                }

                // Draw Observer A branch
                ctx.strokeStyle = 'rgba(100, 180, 255, 0.6)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(pointsA[0].x, pointsA[0].y);
                for (let i = 1; i < pointsA.length; i++) {
                    const prev = pointsA[i - 1];
                    const curr = pointsA[i];
                    const cpY = (prev.y + curr.y) / 2;
                    ctx.bezierCurveTo(prev.x, cpY, curr.x, cpY, curr.x, curr.y);
                }
                ctx.stroke();

                // Draw Observer B branch
                ctx.strokeStyle = 'rgba(255, 140, 90, 0.6)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(pointsB[0].x, pointsB[0].y);
                for (let i = 1; i < pointsB.length; i++) {
                    const prev = pointsB[i - 1];
                    const curr = pointsB[i];
                    const cpY = (prev.y + curr.y) / 2;
                    ctx.bezierCurveTo(prev.x, cpY, curr.x, cpY, curr.x, curr.y);
                }
                ctx.stroke();

                // Draw merge connections where divergence is low
                ctx.strokeStyle = 'rgba(138,154,91,0.2)';
                ctx.lineWidth = 1;
                for (let i = 0; i < n; i++) {
                    if (this.commits[i].divergence < 0.15) {
                        ctx.beginPath();
                        ctx.moveTo(pointsA[i].x, pointsA[i].y);
                        ctx.lineTo(pointsB[i].x, pointsB[i].y);
                        ctx.stroke();
                    }
                }

                // Draw commit nodes
                for (let i = 0; i < n; i++) {
                    const c = this.commits[i];
                    const isLast = i === n - 1;
                    const nodeR = isLast ? 5 : 3;

                    // Observer A node
                    ctx.beginPath();
                    ctx.arc(pointsA[i].x, pointsA[i].y, nodeR, 0, Math.PI * 2);
                    ctx.fillStyle = isLast ? '#64b4ff' : 'rgba(100,180,255,0.5)';
                    ctx.fill();
                    if (isLast) {
                        ctx.strokeStyle = 'rgba(100,180,255,0.3)';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }

                    // Observer B node
                    ctx.beginPath();
                    ctx.arc(pointsB[i].x, pointsB[i].y, nodeR, 0, Math.PI * 2);
                    ctx.fillStyle = isLast ? '#ff8c5a' : 'rgba(255,140,90,0.5)';
                    ctx.fill();
                    if (isLast) {
                        ctx.strokeStyle = 'rgba(255,140,90,0.3)';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }

                    // Root node on center line
                    if (i === 0) {
                        ctx.beginPath();
                        ctx.arc(centerX, pointsA[i].y, 4, 0, Math.PI * 2);
                        ctx.fillStyle = 'var(--sage)';
                        ctx.fill();
                    }
                }

                // Labels
                ctx.font = '10px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(100,180,255,0.7)';
                ctx.textAlign = 'right';
                ctx.fillText('Observer A', pointsA[n - 1].x - 8, pointsA[n - 1].y + 3);

                ctx.fillStyle = 'rgba(255,140,90,0.7)';
                ctx.textAlign = 'left';
                ctx.fillText('Observer B', pointsB[n - 1].x + 8, pointsB[n - 1].y + 3);

                // Step labels
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                ctx.textAlign = 'center';
                ctx.font = '9px "JetBrains Mono", monospace';
                const first = this.commits[0];
                const last = this.commits[n - 1];
                ctx.fillText('t=' + first.step, centerX, marginTop - 6);
                ctx.fillText('t=' + last.step, centerX, h - marginBottom + 14);

                ctx.restore();
            }
        }

        // ================================================================
        // STATS & ANALYSIS
        // ================================================================
        function computeGridEntropy(data) {
            if (!data || data.length === 0) return 0;
            let totalH = 0, count = 0;
            for (const row of data) {
                for (let i = 0; i < row.length; i++) {
                    const v = Math.min(1, Math.max(0, row[i]));
                    if (v > 0 && v < 1) {
                        totalH += -(v * Math.log2(v) + (1 - v) * Math.log2(1 - v));
                    }
                    count++;
                }
            }
            return count > 0 ? totalH / count : 0;
        }

        function computeDivergence(dataA, dataB) {
            if (!dataA || !dataB || dataA.length === 0 || dataB.length === 0) return 0;
            // Normalize to same resolution for comparison
            const rowsA = dataA.length, rowsB = dataB.length;
            const colsA = dataA[0].length, colsB = dataB[0].length;
            const rows = Math.min(rowsA, rowsB);
            const cols = Math.min(colsA, colsB);

            let diff = 0, count = 0;
            for (let r = 0; r < Math.min(rows, 20); r++) {
                const rA = rowsA - rows + r;
                const rB = rowsB - rows + r;
                for (let c = 0; c < cols; c++) {
                    const cA = Math.floor(c * colsA / cols);
                    const cB = Math.floor(c * colsB / cols);
                    const vA = dataA[rA] ? (dataA[rA][cA] || 0) : 0;
                    const vB = dataB[rB] ? (dataB[rB][cB] || 0) : 0;
                    diff += Math.abs(vA - vB);
                    count++;
                }
            }
            return count > 0 ? diff / count : 0;
        }

        function estimateComplexity(grid) {
            if (!grid || grid.length === 0) return 0;
            // Run-length encoding approximation of Kolmogorov complexity
            const lastRows = grid.slice(-10);
            let runs = 0, total = 0;
            for (const row of lastRows) {
                let prev = -1;
                for (let i = 0; i < row.length; i++) {
                    if (row[i] !== prev) {
                        runs++;
                        prev = row[i];
                    }
                    total++;
                }
            }
            return total > 0 ? (runs / total).toFixed(3) : 0;
        }

        // ================================================================
        // MAIN APPLICATION
        // ================================================================
        const caRuleEl = document.getElementById('caRule');
        const gridWidthEl = document.getElementById('gridWidth');
        const gridWidthValEl = document.getElementById('gridWidthVal');
        const initModeEl = document.getElementById('initMode');
        const lensAEl = document.getElementById('lensA');
        const lensBEl = document.getElementById('lensB');
        const threshAEl = document.getElementById('threshA');
        const threshBEl = document.getElementById('threshB');
        const threshAValEl = document.getElementById('threshAVal');
        const threshBValEl = document.getElementById('threshBVal');
        const speedEl = document.getElementById('speed');
        const speedValEl = document.getElementById('speedVal');
        const btnPlay = document.getElementById('btnPlay');
        const btnStep = document.getElementById('btnStep');
        const btnReset = document.getElementById('btnReset');
        const stepCounterEl = document.getElementById('stepCounter');
        const lensABadge = document.getElementById('lensABadge');
        const lensBBadge = document.getElementById('lensBBadge');
        const equivIndicator = document.getElementById('equivIndicator');

        const rendererA = new Renderer(document.getElementById('canvasA'));
        const rendererB = new Renderer(document.getElementById('canvasB'));
        const gitGraph = new GitGraph(document.getElementById('canvasGit'));

        let ruliad = null;
        let playing = true;
        let frameCount = 0;
        let animId = null;

        const lensNames = {
            raw: 'Raw (1:1)',
            block2: 'Block 2x2',
            block3: 'Block 3x3',
            block4: 'Block 4x4',
            density: 'Density Field',
            entropy: 'Local Entropy',
            edges: 'Edge Detection',
            temporal: 'Temporal Avg'
        };

        function initSimulation() {
            const rule = parseInt(caRuleEl.value);
            const width = parseInt(gridWidthEl.value);
            const mode = initModeEl.value;

            ruliad = new Ruliad(rule, width);
            ruliad.init(mode);

            // Pre-evolve a few rows so there's something to see
            for (let i = 0; i < 20; i++) ruliad.evolve();

            gitGraph.commits = [];
            frameCount = 0;
            updateDisplay();
        }

        function stepSimulation() {
            if (!ruliad) return;
            ruliad.evolve();
            updateDisplay();
        }

        function updateDisplay() {
            if (!ruliad) return;

            const lensTypeA = lensAEl.value;
            const lensTypeB = lensBEl.value;
            const threshA = parseInt(threshAEl.value);
            const threshB = parseInt(threshBEl.value);

            // Apply lenses
            const dataA = Lenses[lensTypeA](ruliad.grid, threshA);
            const dataB = Lenses[lensTypeB](ruliad.grid, threshB);

            // Render
            rendererA.drawGrid(dataA, colorA, 0);
            rendererB.drawGrid(dataB, colorB, 0);

            // Update badges
            lensABadge.textContent = lensNames[lensTypeA] || lensTypeA;
            lensBBadge.textContent = lensNames[lensTypeB] || lensTypeB;

            // Compute stats
            const entropyA = computeGridEntropy(dataA);
            const entropyB = computeGridEntropy(dataB);
            const divergence = computeDivergence(dataA, dataB);
            const complexity = estimateComplexity(ruliad.grid);
            const density = ruliad.getDensity();

            document.getElementById('statSteps').textContent = ruliad.step;
            document.getElementById('statDensity').textContent = (density * 100).toFixed(1) + '%';
            document.getElementById('statEntropyA').textContent = entropyA.toFixed(3);
            document.getElementById('statEntropyB').textContent = entropyB.toFixed(3);
            document.getElementById('statDivergence').textContent = divergence.toFixed(3);
            document.getElementById('statComplexity').textContent = complexity;

            stepCounterEl.textContent = 'Step: ' + ruliad.step;

            // Update equivalence indicator
            if (divergence < 0.08) {
                equivIndicator.className = 'equiv-indicator same';
                equivIndicator.textContent = 'Observers see similar realities (low divergence)';
            } else if (divergence < 0.25) {
                equivIndicator.className = 'equiv-indicator different';
                equivIndicator.textContent = 'Observers see moderately different realities';
            } else {
                equivIndicator.className = 'equiv-indicator different';
                equivIndicator.textContent = 'Observers see radically different realities!';
            }

            // Update git graph
            if (ruliad.step % 3 === 0) {
                const avgA = dataA.length > 0 ? dataA[dataA.length - 1].reduce((s, v) => s + v, 0) / dataA[dataA.length - 1].length : 0;
                const avgB = dataB.length > 0 ? dataB[dataB.length - 1].reduce((s, v) => s + v, 0) / dataB[dataB.length - 1].length : 0;
                gitGraph.addCommit(ruliad.step, avgA, avgB, Math.min(1, divergence * 3));
                gitGraph.draw();
            }
        }

        function animate() {
            frameCount++;
            const spd = parseInt(speedEl.value);

            if (playing && frameCount % Math.max(1, 31 - spd) === 0) {
                stepSimulation();
            }

            animId = requestAnimationFrame(animate);
        }

        // ================================================================
        // EVENT HANDLERS
        // ================================================================
        btnPlay.addEventListener('click', () => {
            playing = !playing;
            btnPlay.textContent = playing ? 'Pause' : 'Play';
            btnPlay.classList.toggle('active', playing);
        });

        btnStep.addEventListener('click', () => {
            playing = false;
            btnPlay.textContent = 'Play';
            btnPlay.classList.remove('active');
            stepSimulation();
        });

        btnReset.addEventListener('click', () => {
            initSimulation();
        });

        caRuleEl.addEventListener('change', initSimulation);
        initModeEl.addEventListener('change', initSimulation);

        gridWidthEl.addEventListener('input', () => {
            gridWidthValEl.textContent = gridWidthEl.value;
        });
        gridWidthEl.addEventListener('change', initSimulation);

        threshAEl.addEventListener('input', () => {
            threshAValEl.textContent = threshAEl.value + '%';
            updateDisplay();
        });
        threshBEl.addEventListener('input', () => {
            threshBValEl.textContent = threshBEl.value + '%';
            updateDisplay();
        });

        speedEl.addEventListener('input', () => {
            speedValEl.textContent = speedEl.value;
        });

        lensAEl.addEventListener('change', updateDisplay);
        lensBEl.addEventListener('change', updateDisplay);

        // Tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
                if (tab.dataset.tab === 'git') {
                    setTimeout(() => {
                        gitGraph.resize();
                        gitGraph.draw();
                    }, 50);
                }
            });
        });

        // Resize handling
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                rendererA.resize();
                rendererB.resize();
                gitGraph.resize();
                updateDisplay();
            }, 150);
        });

        // ================================================================
        // INIT
        // ================================================================
        initSimulation();
        gitGraph.resize();
        animate();

    })();
    </script>
</body>
</html>
