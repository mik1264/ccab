<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Enzyme Kinetics (Michaelis-Menten)</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; }
.title-overlay {
    position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
    color: #fbbf24; font-size: 20px; font-weight: 600; z-index: 998;
    text-shadow: 0 0 10px rgba(251,191,36,0.5); pointer-events: none;
}
.controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 16px; align-items: center; z-index: 999;
    background: rgba(0,0,0,0.7); padding: 12px 24px; border-radius: 12px;
    border: 1px solid rgba(251,191,36,0.3); flex-wrap: wrap; justify-content: center;
}
.controls label { color: #ccc; font-size: 13px; white-space: nowrap; }
.controls input[type=range] { width: 120px; accent-color: #fbbf24; }
.controls span { color: #fbbf24; font-size: 13px; }
.controls button {
    background: rgba(251,191,36,0.2); color: #fbbf24; border: 1px solid rgba(251,191,36,0.5);
    padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 13px;
}
.controls button:hover { background: rgba(251,191,36,0.4); }
.legend {
    position: fixed; top: 80px; right: 20px; z-index: 998;
    background: rgba(0,0,0,0.6); padding: 12px 16px; border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.1); font-size: 13px; color: #ccc; line-height: 2;
}
.legend .dot { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 6px; }
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">← Back to Gallery</a>
<div class="title-overlay">Enzyme Kinetics: Michaelis-Menten Model</div>
<div class="legend">
    <div><span class="dot" style="background:#4a9eff;"></span>Substrate (S)</div>
    <div><span class="dot" style="background:#22c55e;"></span>Enzyme (E)</div>
    <div><span class="dot" style="background:#fbbf24;"></span>ES Complex</div>
    <div><span class="dot" style="background:#a855f7;"></span>Product (P)</div>
    <div style="margin-top:8px;font-size:11px;color:#888;">E + S ⇌ ES → E + P</div>
</div>
<div class="controls">
    <label>Enzyme Conc: <input type="range" id="enzymeSlider" min="2" max="15" value="5"> <span id="enzymeVal">5</span></label>
    <label>Substrate: <input type="range" id="subSlider" min="10" max="100" value="40"> <span id="subVal">40</span></label>
    <label>Km: <input type="range" id="kmSlider" min="5" max="50" value="20"> <span id="kmVal">20</span></label>
    <button id="resetBtn">Reset</button>
    <button id="addSub">+10 Substrate</button>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

let enzymeCount = 5;
let substrateCount = 40;
let km = 20;
let entities = [];
let rateHistory = [];
let subHistory = [];
let time = 0;
let productsFormed = 0;
let rateWindow = [];

const STATES = { FREE_ENZYME: 0, SUBSTRATE: 1, ES_COMPLEX: 2, PRODUCT: 3 };

class Entity {
    constructor(type, x, y) {
        this.type = type;
        this.x = x || Math.random() * (W - 40) + 20;
        this.y = y || Math.random() * (H - 160) + 80;
        const angle = Math.random() * Math.PI * 2;
        const speed = type === STATES.PRODUCT ? 1.5 : (type === STATES.SUBSTRATE ? 2 : 0.8);
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.r = type === STATES.FREE_ENZYME ? 14 : (type === STATES.ES_COMPLEX ? 16 : 6);
        this.partner = null;
        this.complexTimer = 0;
        this.flash = 0;
        this.wobble = Math.random() * Math.PI * 2;
    }
}

function init() {
    entities = [];
    productsFormed = 0;
    rateHistory = [];
    subHistory = [];
    rateWindow = [];
    time = 0;
    for (let i = 0; i < enzymeCount; i++) {
        entities.push(new Entity(STATES.FREE_ENZYME));
    }
    for (let i = 0; i < substrateCount; i++) {
        entities.push(new Entity(STATES.SUBSTRATE));
    }
}
init();

document.getElementById('enzymeSlider').addEventListener('input', function() {
    enzymeCount = +this.value;
    document.getElementById('enzymeVal').textContent = this.value;
    init();
});
document.getElementById('subSlider').addEventListener('input', function() {
    substrateCount = +this.value;
    document.getElementById('subVal').textContent = this.value;
    init();
});
document.getElementById('kmSlider').addEventListener('input', function() {
    km = +this.value;
    document.getElementById('kmVal').textContent = this.value;
});
document.getElementById('resetBtn').addEventListener('click', init);
document.getElementById('addSub').addEventListener('click', () => {
    for (let i = 0; i < 10; i++) entities.push(new Entity(STATES.SUBSTRATE));
});

function update() {
    time++;
    const enzymes = entities.filter(e => e.type === STATES.FREE_ENZYME);
    const substrates = entities.filter(e => e.type === STATES.SUBSTRATE);
    const complexes = entities.filter(e => e.type === STATES.ES_COMPLEX);

    // Move all
    for (let e of entities) {
        e.wobble += 0.05;
        if (e.type !== STATES.ES_COMPLEX) {
            e.x += e.vx + Math.sin(e.wobble) * 0.2;
            e.y += e.vy + Math.cos(e.wobble * 1.3) * 0.2;
        } else {
            e.x += e.vx * 0.3;
            e.y += e.vy * 0.3;
            e.complexTimer++;
        }
        if (e.flash > 0) e.flash *= 0.93;

        // Bounds
        if (e.x < e.r + 10) { e.x = e.r + 10; e.vx *= -1; }
        if (e.x > W - e.r - 10) { e.x = W - e.r - 10; e.vx *= -1; }
        if (e.y < e.r + 70) { e.y = e.r + 70; e.vy *= -1; }
        if (e.y > H - e.r - 80) { e.y = H - e.r - 80; e.vy *= -1; }
    }

    // Enzyme + Substrate binding
    for (let enz of enzymes) {
        for (let sub of substrates) {
            const dx = enz.x - sub.x;
            const dy = enz.y - sub.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            if (d < enz.r + sub.r + 5) {
                // Binding probability related to affinity (inverse of Km)
                const bindProb = 0.05 * (50 / km);
                if (Math.random() < bindProb) {
                    // Form complex
                    enz.type = STATES.ES_COMPLEX;
                    enz.r = 16;
                    enz.complexTimer = 0;
                    enz.flash = 1;
                    enz.partner = sub;
                    const idx = entities.indexOf(sub);
                    if (idx > -1) entities.splice(idx, 1);
                    break;
                }
            }
        }
    }

    // ES Complex → E + P
    for (let c of complexes) {
        const catalysisTime = 40 + km * 2;
        if (c.complexTimer > catalysisTime) {
            c.type = STATES.FREE_ENZYME;
            c.r = 14;
            c.flash = 1;
            const p = new Entity(STATES.PRODUCT, c.x + 20, c.y);
            p.flash = 1;
            entities.push(p);
            productsFormed++;
            rateWindow.push(time);
        }
    }

    // Clean old rate window
    rateWindow = rateWindow.filter(t => time - t < 120);

    // Record history
    if (time % 5 === 0) {
        const currentRate = rateWindow.length;
        const currentSub = entities.filter(e => e.type === STATES.SUBSTRATE).length;
        rateHistory.push(currentRate);
        subHistory.push(currentSub);
        if (rateHistory.length > 150) { rateHistory.shift(); subHistory.shift(); }
    }
}

function drawEntity(e) {
    ctx.save();
    if (e.type === STATES.FREE_ENZYME) {
        // Enzyme: green pac-man-like shape
        ctx.beginPath();
        const mouthAngle = 0.3 + Math.sin(e.wobble * 2) * 0.15;
        ctx.arc(e.x, e.y, e.r, mouthAngle, Math.PI * 2 - mouthAngle);
        ctx.lineTo(e.x, e.y);
        ctx.closePath();
        ctx.fillStyle = '#22c55e';
        ctx.fill();
        ctx.strokeStyle = '#16a34a';
        ctx.lineWidth = 2;
        ctx.stroke();
        // Active site highlight
        ctx.beginPath();
        ctx.arc(e.x + e.r * 0.5, e.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = '#fbbf24';
        ctx.fill();
    } else if (e.type === STATES.SUBSTRATE) {
        // Substrate: blue triangle/wedge
        ctx.beginPath();
        ctx.moveTo(e.x + e.r, e.y);
        ctx.lineTo(e.x - e.r * 0.7, e.y - e.r * 0.8);
        ctx.lineTo(e.x - e.r * 0.7, e.y + e.r * 0.8);
        ctx.closePath();
        ctx.fillStyle = '#4a9eff';
        ctx.fill();
    } else if (e.type === STATES.ES_COMPLEX) {
        // Complex: enzyme with substrate inside
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(251, 191, 36, 0.3)';
        ctx.fill();
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Enzyme part
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r - 2, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(34, 197, 94, 0.6)';
        ctx.fill();

        // Substrate inside
        ctx.beginPath();
        const sx = e.x + 2;
        ctx.moveTo(sx + 5, e.y);
        ctx.lineTo(sx - 3, e.y - 4);
        ctx.lineTo(sx - 3, e.y + 4);
        ctx.closePath();
        ctx.fillStyle = '#4a9eff';
        ctx.fill();

        // Progress bar
        const catalysisTime = 40 + km * 2;
        const progress = Math.min(e.complexTimer / catalysisTime, 1);
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.fillRect(e.x - 12, e.y - e.r - 8, 24, 4);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(e.x - 12, e.y - e.r - 8, 24 * progress, 4);
    } else if (e.type === STATES.PRODUCT) {
        // Product: purple diamond
        ctx.beginPath();
        ctx.moveTo(e.x, e.y - e.r);
        ctx.lineTo(e.x + e.r, e.y);
        ctx.lineTo(e.x, e.y + e.r);
        ctx.lineTo(e.x - e.r, e.y);
        ctx.closePath();
        ctx.fillStyle = '#a855f7';
        ctx.fill();
    }

    // Flash effect
    if (e.flash > 0.1) {
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r + 10 * e.flash, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(251, 191, 36, ${e.flash * 0.5})`;
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    ctx.restore();
}

function drawMMGraph() {
    const gx = 20, gy = 80, gw = 260, gh = 150;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(gx, gy, gw, gh + 35, 10);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = '#aaa';
    ctx.font = '11px sans-serif';
    ctx.fillText('Michaelis-Menten Curve', gx + 60, gy + 15);

    // Draw theoretical MM curve
    const Vmax = enzymeCount * 0.8;
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(251,191,36,0.3)';
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 3]);
    for (let s = 0; s <= 100; s++) {
        const v = (Vmax * s) / (km + s);
        const x = gx + 10 + (s / 100) * (gw - 20);
        const y = gy + gh + 5 - (v / Vmax) * (gh - 20);
        if (s === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // Vmax line
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.setLineDash([2, 4]);
    const vmaxY = gy + gh + 5 - (gh - 20);
    ctx.beginPath();
    ctx.moveTo(gx + 10, vmaxY);
    ctx.lineTo(gx + gw - 10, vmaxY);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#888';
    ctx.font = '9px sans-serif';
    ctx.fillText('Vmax', gx + gw - 35, vmaxY - 3);

    // Plot rate vs substrate data points
    if (rateHistory.length > 1) {
        ctx.beginPath();
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 2;
        for (let i = 0; i < rateHistory.length; i++) {
            const sub = subHistory[i];
            const rate = rateHistory[i];
            const x = gx + 10 + (sub / 100) * (gw - 20);
            const y = gy + gh + 5 - (rate / (Vmax * 120)) * (gh - 20);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    }

    // Axes labels
    ctx.fillStyle = '#888';
    ctx.font = '10px sans-serif';
    ctx.fillText('[S]', gx + gw / 2, gy + gh + 30);
    ctx.save();
    ctx.translate(gx + 8, gy + gh / 2 + 10);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Rate (v)', 0, 0);
    ctx.restore();
}

function draw() {
    ctx.fillStyle = 'rgba(10, 14, 26, 0.25)';
    ctx.fillRect(0, 0, W, H);

    for (let e of entities) drawEntity(e);

    drawMMGraph();

    // Stats
    const sCount = entities.filter(e => e.type === STATES.SUBSTRATE).length;
    const eCount = entities.filter(e => e.type === STATES.FREE_ENZYME).length;
    const esCount = entities.filter(e => e.type === STATES.ES_COMPLEX).length;
    const pCount = entities.filter(e => e.type === STATES.PRODUCT).length;

    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(20, H - 105, 220, 35);
    ctx.font = '11px sans-serif';
    ctx.fillStyle = '#22c55e'; ctx.fillText(`E: ${eCount}`, 30, H - 86);
    ctx.fillStyle = '#4a9eff'; ctx.fillText(`S: ${sCount}`, 75, H - 86);
    ctx.fillStyle = '#fbbf24'; ctx.fillText(`ES: ${esCount}`, 115, H - 86);
    ctx.fillStyle = '#a855f7'; ctx.fillText(`P: ${pCount}`, 170, H - 86);
}

function animate() {
    update();
    draw();
    requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
