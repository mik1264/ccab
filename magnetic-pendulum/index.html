<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magnetic Pendulum - Chaos Fractal - CCAB</title>
    <meta name="description" content="Interactive magnetic pendulum chaos simulation. Watch the pendulum swing between magnets and generate beautiful fractal basin of attraction patterns.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a1a;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            display: flex;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.6);
            color: #e91e63;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(233, 30, 99, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(233, 30, 99, 0.2);
            transform: translateX(-4px);
        }

        #main-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .canvas-wrapper {
            position: relative;
        }

        canvas {
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(233, 30, 99, 0.3);
        }

        #pendulum-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        #sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid rgba(233, 30, 99, 0.2);
        }

        #sidebar h2 {
            color: #e91e63;
            font-size: 1.3em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(233, 30, 99, 0.3);
        }

        #sidebar h3 {
            color: #f48fb1;
            font-size: 0.9em;
            margin: 15px 0 10px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #e91e63;
            font-weight: bold;
        }

        .control-group {
            margin: 10px 0;
        }

        .control-group label {
            display: block;
            color: #f48fb1;
            font-size: 11px;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: #e91e63;
        }

        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: rgba(233, 30, 99, 0.2);
            border: 1px solid rgba(233, 30, 99, 0.4);
            color: #e91e63;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(233, 30, 99, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .mode-toggle {
            display: flex;
            gap: 5px;
            margin: 10px 0;
        }

        .mode-toggle button {
            flex: 1;
        }

        .mode-toggle button.active {
            background: rgba(233, 30, 99, 0.5);
            border-color: #e91e63;
        }

        .info-text {
            font-size: 11px;
            color: #888;
            line-height: 1.5;
            margin-top: 15px;
        }

        .magnet-colors {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .magnet-color {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            color: #aaa;
        }

        .magnet-color .swatch {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        #fps-display {
            position: fixed;
            bottom: 15px;
            right: 320px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 6px;
            color: #e91e63;
            font-size: 12px;
            z-index: 1000;
        }

        .progress-bar {
            height: 4px;
            background: rgba(233, 30, 99, 0.2);
            border-radius: 2px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-bar .fill {
            height: 100%;
            background: #e91e63;
            transition: width 0.1s;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>

    <div id="main-container">
        <div class="canvas-wrapper">
            <canvas id="fractal-canvas"></canvas>
            <canvas id="pendulum-canvas"></canvas>
        </div>
    </div>

    <div id="sidebar">
        <h2>Magnetic Pendulum</h2>

        <div class="stat-row">
            <span class="stat-label">Mode</span>
            <span class="stat-value" id="mode">Interactive</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Pixels Rendered</span>
            <span class="stat-value" id="pixels">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Progress</span>
            <span class="stat-value" id="progress">0%</span>
        </div>
        <div class="progress-bar">
            <div class="fill" id="progress-fill" style="width: 0%"></div>
        </div>

        <h3>Mode</h3>
        <div class="mode-toggle">
            <button id="interactive-mode" class="active">Interactive</button>
            <button id="fractal-mode">Fractal</button>
        </div>

        <h3>Physics Parameters</h3>
        <div class="control-group">
            <label>Gravity Strength: <span id="gravity-val">0.5</span></label>
            <input type="range" id="gravity" min="0.1" max="2" step="0.1" value="0.5">
        </div>
        <div class="control-group">
            <label>Magnetic Strength: <span id="magnetic-val">1.0</span></label>
            <input type="range" id="magnetic" min="0.1" max="3" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label>Friction: <span id="friction-val">0.1</span></label>
            <input type="range" id="friction" min="0.01" max="0.5" step="0.01" value="0.1">
        </div>
        <div class="control-group">
            <label>Magnet Height: <span id="height-val">0.3</span></label>
            <input type="range" id="height" min="0.1" max="1" step="0.05" value="0.3">
        </div>

        <h3>Fractal Settings</h3>
        <div class="control-group">
            <label>Resolution: <span id="resolution-val">400</span></label>
            <input type="range" id="resolution" min="100" max="800" step="50" value="400">
        </div>

        <button id="generate-fractal">Generate Fractal</button>
        <button id="stop-fractal" disabled>Stop</button>
        <button id="reset">Reset</button>

        <h3>Magnet Colors</h3>
        <div class="magnet-colors">
            <div class="magnet-color">
                <div class="swatch" style="background: #e91e63;"></div>
                <span>Magnet 1</span>
            </div>
            <div class="magnet-color">
                <div class="swatch" style="background: #00bcd4;"></div>
                <span>Magnet 2</span>
            </div>
            <div class="magnet-color">
                <div class="swatch" style="background: #4caf50;"></div>
                <span>Magnet 3</span>
            </div>
        </div>

        <p class="info-text">
            <strong>Interactive Mode:</strong> Click to release the pendulum from any position. Watch it chaotically swing between magnets before settling.<br><br>
            <strong>Fractal Mode:</strong> Generate a basin of attraction fractal where each pixel's color shows which magnet captures the pendulum released from that position.
        </p>
    </div>

    <div id="fps-display">FPS: <span id="fps">0</span></div>

    <script>
        // Canvas setup
        const fractalCanvas = document.getElementById('fractal-canvas');
        const pendulumCanvas = document.getElementById('pendulum-canvas');
        const fractalCtx = fractalCanvas.getContext('2d');
        const pendulumCtx = pendulumCanvas.getContext('2d');

        // Size
        const size = Math.min(window.innerWidth - 340, window.innerHeight - 40);
        fractalCanvas.width = fractalCanvas.height = size;
        pendulumCanvas.width = pendulumCanvas.height = size;

        // UI Elements
        const modeDisplay = document.getElementById('mode');
        const pixelsDisplay = document.getElementById('pixels');
        const progressDisplay = document.getElementById('progress');
        const progressFill = document.getElementById('progress-fill');
        const fpsDisplay = document.getElementById('fps');

        // Configuration
        let config = {
            gravity: 0.5,      // k_g - restoring force
            magnetic: 1.0,     // k_m - magnetic attraction
            friction: 0.1,     // k_f - damping
            magnetHeight: 0.3, // z-height of magnets above plane
            resolution: 400,
            mode: 'interactive'
        };

        // Magnet positions (equilateral triangle)
        const magnetRadius = 0.35;
        const magnets = [
            { x: 0, y: -magnetRadius, color: '#e91e63' },
            { x: magnetRadius * Math.cos(Math.PI / 6), y: magnetRadius * Math.sin(Math.PI / 6), color: '#00bcd4' },
            { x: -magnetRadius * Math.cos(Math.PI / 6), y: magnetRadius * Math.sin(Math.PI / 6), color: '#4caf50' }
        ];

        // Pendulum state
        let pendulum = {
            x: 0.3,
            y: 0.2,
            vx: 0,
            vy: 0,
            trail: [],
            active: false,
            settled: false,
            settledMagnet: -1
        };

        // Fractal generation state
        let fractalData = null;
        let generating = false;
        let currentPixel = 0;
        let totalPixels = 0;

        // Convert world coords to canvas coords
        function worldToCanvas(x, y) {
            const scale = size / 2;
            return {
                x: size / 2 + x * scale,
                y: size / 2 - y * scale
            };
        }

        // Convert canvas coords to world coords
        function canvasToWorld(cx, cy) {
            const scale = size / 2;
            return {
                x: (cx - size / 2) / scale,
                y: (size / 2 - cy) / scale
            };
        }

        // Calculate acceleration on pendulum
        function getAcceleration(x, y, vx, vy) {
            let ax = 0;
            let ay = 0;

            // Restoring force (gravity pulling back to center)
            const r = Math.sqrt(x * x + y * y);
            ax -= config.gravity * x;
            ay -= config.gravity * y;

            // Magnetic forces from each magnet
            for (const magnet of magnets) {
                const dx = magnet.x - x;
                const dy = magnet.y - y;
                const dz = config.magnetHeight;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                const dist3 = dist * dist * dist;

                // Inverse square law (simplified)
                const force = config.magnetic / dist3;
                ax += force * dx;
                ay += force * dy;
            }

            // Friction (velocity-dependent damping)
            ax -= config.friction * vx;
            ay -= config.friction * vy;

            return { ax, ay };
        }

        // Simulate pendulum until it settles
        function simulatePendulum(startX, startY, maxSteps = 5000) {
            let x = startX, y = startY;
            let vx = 0, vy = 0;
            const dt = 0.01;
            let steps = 0;

            const trail = [{ x, y }];

            while (steps < maxSteps) {
                const { ax, ay } = getAcceleration(x, y, vx, vy);

                // Velocity Verlet integration
                vx += ax * dt;
                vy += ay * dt;
                x += vx * dt;
                y += vy * dt;

                steps++;

                // Record trail (every 5 steps for performance)
                if (steps % 5 === 0) {
                    trail.push({ x, y });
                }

                // Check if settled on a magnet
                const speed = Math.sqrt(vx * vx + vy * vy);
                if (speed < 0.001) {
                    // Find which magnet we're closest to
                    let minDist = Infinity;
                    let settledMagnet = -1;

                    for (let i = 0; i < magnets.length; i++) {
                        const dx = x - magnets[i].x;
                        const dy = y - magnets[i].y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < minDist) {
                            minDist = dist;
                            settledMagnet = i;
                        }
                    }

                    return { settledMagnet, steps, trail };
                }
            }

            // Didn't settle, find closest magnet
            let minDist = Infinity;
            let settledMagnet = 0;
            for (let i = 0; i < magnets.length; i++) {
                const dx = x - magnets[i].x;
                const dy = y - magnets[i].y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < minDist) {
                    minDist = dist;
                    settledMagnet = i;
                }
            }

            return { settledMagnet, steps, trail };
        }

        // Draw the base scene
        function drawBase() {
            fractalCtx.fillStyle = '#0a0a1a';
            fractalCtx.fillRect(0, 0, size, size);

            // Draw magnets
            for (let i = 0; i < magnets.length; i++) {
                const pos = worldToCanvas(magnets[i].x, magnets[i].y);

                // Glow
                const gradient = fractalCtx.createRadialGradient(
                    pos.x, pos.y, 0,
                    pos.x, pos.y, 30
                );
                gradient.addColorStop(0, magnets[i].color);
                gradient.addColorStop(1, 'transparent');
                fractalCtx.fillStyle = gradient;
                fractalCtx.beginPath();
                fractalCtx.arc(pos.x, pos.y, 30, 0, Math.PI * 2);
                fractalCtx.fill();

                // Core
                fractalCtx.fillStyle = magnets[i].color;
                fractalCtx.beginPath();
                fractalCtx.arc(pos.x, pos.y, 12, 0, Math.PI * 2);
                fractalCtx.fill();

                // Label
                fractalCtx.fillStyle = '#fff';
                fractalCtx.font = 'bold 14px sans-serif';
                fractalCtx.textAlign = 'center';
                fractalCtx.textBaseline = 'middle';
                fractalCtx.fillText((i + 1).toString(), pos.x, pos.y);
            }

            // Draw center pivot
            const center = worldToCanvas(0, 0);
            fractalCtx.fillStyle = '#666';
            fractalCtx.beginPath();
            fractalCtx.arc(center.x, center.y, 5, 0, Math.PI * 2);
            fractalCtx.fill();
        }

        // Draw pendulum
        function drawPendulum() {
            pendulumCtx.clearRect(0, 0, size, size);

            if (!pendulum.active && pendulum.trail.length === 0) return;

            // Draw trail
            if (pendulum.trail.length > 1) {
                pendulumCtx.beginPath();
                const start = worldToCanvas(pendulum.trail[0].x, pendulum.trail[0].y);
                pendulumCtx.moveTo(start.x, start.y);

                for (let i = 1; i < pendulum.trail.length; i++) {
                    const pos = worldToCanvas(pendulum.trail[i].x, pendulum.trail[i].y);
                    pendulumCtx.lineTo(pos.x, pos.y);
                }

                const alpha = pendulum.settled ? 0.3 : 0.6;
                pendulumCtx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                pendulumCtx.lineWidth = 1.5;
                pendulumCtx.stroke();
            }

            // Draw string
            const center = worldToCanvas(0, 0);
            const pos = worldToCanvas(pendulum.x, pendulum.y);

            pendulumCtx.beginPath();
            pendulumCtx.moveTo(center.x, center.y);
            pendulumCtx.lineTo(pos.x, pos.y);
            pendulumCtx.strokeStyle = '#888';
            pendulumCtx.lineWidth = 2;
            pendulumCtx.stroke();

            // Draw bob
            const bobColor = pendulum.settledMagnet >= 0 ? magnets[pendulum.settledMagnet].color : '#e91e63';

            // Glow
            const gradient = pendulumCtx.createRadialGradient(
                pos.x, pos.y, 0,
                pos.x, pos.y, 25
            );
            gradient.addColorStop(0, bobColor);
            gradient.addColorStop(1, 'transparent');
            pendulumCtx.fillStyle = gradient;
            pendulumCtx.beginPath();
            pendulumCtx.arc(pos.x, pos.y, 25, 0, Math.PI * 2);
            pendulumCtx.fill();

            // Core
            pendulumCtx.fillStyle = bobColor;
            pendulumCtx.beginPath();
            pendulumCtx.arc(pos.x, pos.y, 10, 0, Math.PI * 2);
            pendulumCtx.fill();
        }

        // Update pendulum physics
        function updatePendulum() {
            if (!pendulum.active) return;

            const dt = 0.016; // ~60fps timestep
            const substeps = 5;

            for (let i = 0; i < substeps; i++) {
                const { ax, ay } = getAcceleration(pendulum.x, pendulum.y, pendulum.vx, pendulum.vy);

                pendulum.vx += ax * dt / substeps;
                pendulum.vy += ay * dt / substeps;
                pendulum.x += pendulum.vx * dt / substeps;
                pendulum.y += pendulum.vy * dt / substeps;
            }

            // Record trail
            pendulum.trail.push({ x: pendulum.x, y: pendulum.y });
            if (pendulum.trail.length > 500) {
                pendulum.trail.shift();
            }

            // Check if settled
            const speed = Math.sqrt(pendulum.vx * pendulum.vx + pendulum.vy * pendulum.vy);
            if (speed < 0.005) {
                pendulum.active = false;
                pendulum.settled = true;

                // Find which magnet
                let minDist = Infinity;
                for (let i = 0; i < magnets.length; i++) {
                    const dx = pendulum.x - magnets[i].x;
                    const dy = pendulum.y - magnets[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        minDist = dist;
                        pendulum.settledMagnet = i;
                    }
                }
            }
        }

        // Generate fractal image
        async function generateFractal() {
            generating = true;
            document.getElementById('generate-fractal').disabled = true;
            document.getElementById('stop-fractal').disabled = false;

            const res = config.resolution;
            fractalData = fractalCtx.createImageData(size, size);
            currentPixel = 0;
            totalPixels = res * res;

            const scale = 1.0 / (res / 2);

            for (let py = 0; py < res && generating; py++) {
                for (let px = 0; px < res && generating; px++) {
                    const worldX = (px - res / 2) * scale;
                    const worldY = (res / 2 - py) * scale;

                    const result = simulatePendulum(worldX, worldY, 3000);

                    // Get color based on which magnet it settled on
                    const color = magnets[result.settledMagnet].color;

                    // Parse color and add brightness based on steps
                    const brightness = Math.max(0.3, 1 - result.steps / 3000);

                    // Convert hex to RGB
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);

                    // Map to canvas pixel (scale up if resolution < canvas size)
                    const pixelScale = size / res;
                    for (let dy = 0; dy < pixelScale; dy++) {
                        for (let dx = 0; dx < pixelScale; dx++) {
                            const canvasX = Math.floor(px * pixelScale + dx);
                            const canvasY = Math.floor(py * pixelScale + dy);
                            const idx = (canvasY * size + canvasX) * 4;

                            fractalData.data[idx] = r * brightness;
                            fractalData.data[idx + 1] = g * brightness;
                            fractalData.data[idx + 2] = b * brightness;
                            fractalData.data[idx + 3] = 255;
                        }
                    }

                    currentPixel++;
                }

                // Update display every row
                fractalCtx.putImageData(fractalData, 0, 0);

                // Draw magnets on top
                for (let i = 0; i < magnets.length; i++) {
                    const pos = worldToCanvas(magnets[i].x, magnets[i].y);
                    fractalCtx.fillStyle = '#fff';
                    fractalCtx.beginPath();
                    fractalCtx.arc(pos.x, pos.y, 8, 0, Math.PI * 2);
                    fractalCtx.fill();
                    fractalCtx.fillStyle = magnets[i].color;
                    fractalCtx.beginPath();
                    fractalCtx.arc(pos.x, pos.y, 6, 0, Math.PI * 2);
                    fractalCtx.fill();
                }

                const progress = Math.round((py / res) * 100);
                progressDisplay.textContent = progress + '%';
                progressFill.style.width = progress + '%';
                pixelsDisplay.textContent = currentPixel;

                // Yield to allow UI updates
                await new Promise(resolve => setTimeout(resolve, 0));
            }

            generating = false;
            document.getElementById('generate-fractal').disabled = false;
            document.getElementById('stop-fractal').disabled = true;
            progressDisplay.textContent = '100%';
            progressFill.style.width = '100%';
        }

        // Animation loop
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;

        function animate(currentTime) {
            requestAnimationFrame(animate);

            // FPS calculation
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                fpsDisplay.textContent = fps;
            }

            if (config.mode === 'interactive') {
                updatePendulum();
                drawPendulum();
            }
        }

        // Event listeners
        pendulumCanvas.addEventListener('click', (e) => {
            if (config.mode !== 'interactive') return;

            const rect = pendulumCanvas.getBoundingClientRect();
            const cx = e.clientX - rect.left;
            const cy = e.clientY - rect.top;
            const world = canvasToWorld(cx, cy);

            // Reset and start pendulum
            pendulum.x = world.x;
            pendulum.y = world.y;
            pendulum.vx = 0;
            pendulum.vy = 0;
            pendulum.trail = [{ x: world.x, y: world.y }];
            pendulum.active = true;
            pendulum.settled = false;
            pendulum.settledMagnet = -1;
        });

        // Mode toggle
        document.getElementById('interactive-mode').addEventListener('click', () => {
            config.mode = 'interactive';
            modeDisplay.textContent = 'Interactive';
            document.getElementById('interactive-mode').classList.add('active');
            document.getElementById('fractal-mode').classList.remove('active');
            drawBase();
            pendulumCtx.clearRect(0, 0, size, size);
        });

        document.getElementById('fractal-mode').addEventListener('click', () => {
            config.mode = 'fractal';
            modeDisplay.textContent = 'Fractal';
            document.getElementById('fractal-mode').classList.add('active');
            document.getElementById('interactive-mode').classList.remove('active');
            pendulumCtx.clearRect(0, 0, size, size);
        });

        // Control sliders
        document.getElementById('gravity').addEventListener('input', (e) => {
            config.gravity = parseFloat(e.target.value);
            document.getElementById('gravity-val').textContent = config.gravity.toFixed(1);
        });

        document.getElementById('magnetic').addEventListener('input', (e) => {
            config.magnetic = parseFloat(e.target.value);
            document.getElementById('magnetic-val').textContent = config.magnetic.toFixed(1);
        });

        document.getElementById('friction').addEventListener('input', (e) => {
            config.friction = parseFloat(e.target.value);
            document.getElementById('friction-val').textContent = config.friction.toFixed(2);
        });

        document.getElementById('height').addEventListener('input', (e) => {
            config.magnetHeight = parseFloat(e.target.value);
            document.getElementById('height-val').textContent = config.magnetHeight.toFixed(2);
        });

        document.getElementById('resolution').addEventListener('input', (e) => {
            config.resolution = parseInt(e.target.value);
            document.getElementById('resolution-val').textContent = config.resolution;
        });

        document.getElementById('generate-fractal').addEventListener('click', () => {
            if (config.mode === 'interactive') {
                document.getElementById('fractal-mode').click();
            }
            generateFractal();
        });

        document.getElementById('stop-fractal').addEventListener('click', () => {
            generating = false;
        });

        document.getElementById('reset').addEventListener('click', () => {
            generating = false;
            pendulum.active = false;
            pendulum.trail = [];
            pendulum.settled = false;
            pendulum.settledMagnet = -1;
            drawBase();
            pendulumCtx.clearRect(0, 0, size, size);
            progressDisplay.textContent = '0%';
            progressFill.style.width = '0%';
            pixelsDisplay.textContent = '0';
        });

        // Initialize
        drawBase();
        requestAnimationFrame(animate);
    </script>
</body>
</html>
