<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Migration Patterns</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #333;
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
        }
        h1 { color: #667eea; margin-bottom: 10px; font-size: 28px; }
        .description { color: #666; margin-bottom: 20px; line-height: 1.6; }
        canvas { border: 2px solid #667eea; border-radius: 8px; background: #000; display: block; margin: 0 auto 20px; }
        .controls { display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px; align-items: center; justify-content: center; }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s;
        }
        button:hover { background: #5568d3; }
        .slider-group { display: flex; flex-direction: column; gap: 5px; }
        .slider-group label { font-size: 12px; color: #666; font-weight: 600; }
        input[type="range"] { width: 200px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Agent Migration Patterns</h1>
        <p class="description">
            Agents can move toward areas with higher cooperation benefits. Agents with low fitness (being exploited) attempt
            to migrate to adjacent empty spaces or swap with neighbors. This creates dynamic boundaries as agents flee hostile
            territories. Migration allows altruists to escape exploitation temporarily but also enables ethnocentric clusters
            to expand more aggressively.
        </p>

        <canvas id="canvas" width="700" height="700"></canvas>

        <div class="controls">
            <button id="startBtn">Start</button>
            <button id="pauseBtn">Pause</button>
            <button id="resetBtn">Reset</button>

            <div class="slider-group">
                <label>Migration Probability: <span id="migrationValue">10%</span></label>
                <input type="range" id="migrationSlider" min="0" max="100" value="10" step="5">
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const GRID_SIZE = 70;
        const CELL_SIZE = canvas.width / GRID_SIZE;
        const COLORS = ['#4444ff', '#ff4444', '#44ff44', '#ffff44'];

        let grid = [];
        let running = false;
        let migrationProb = 0.1;

        class Agent {
            constructor(color, cooperateSame, cooperateDiff) {
                this.color = color;
                this.cooperateSame = cooperateSame;
                this.cooperateDiff = cooperateDiff;
                this.ptr = 0;
            }

            shouldCooperate(otherColor) {
                return (this.color === otherColor) ? this.cooperateSame : this.cooperateDiff;
            }

            clone() {
                let cs = this.cooperateSame;
                let cd = this.cooperateDiff;
                let c = this.color;

                if (Math.random() < 0.005) cs = !cs;
                if (Math.random() < 0.005) cd = !cd;
                if (Math.random() < 0.005) c = Math.floor(Math.random() * 4);

                return new Agent(c, cs, cd);
            }
        }

        function initialize() {
            grid = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                grid[i] = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (Math.random() < 0.5) {
                        grid[i][j] = new Agent(
                            Math.floor(Math.random() * 4),
                            Math.random() < 0.5,
                            Math.random() < 0.5
                        );
                    } else {
                        grid[i][j] = null;
                    }
                }
            }
            draw();
        }

        function getNeighbors(x, y) {
            const neighbors = [];
            const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    neighbors.push({x: nx, y: ny, agent: grid[nx][ny]});
                }
            }
            return neighbors;
        }

        function step() {
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j]) grid[i][j].ptr = 0;
                }
            }

            // Interactions
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (!agent) continue;

                    const neighbors = getNeighbors(i, j);
                    for (const {agent: neighbor} of neighbors) {
                        if (!neighbor) continue;
                        if (agent.shouldCooperate(neighbor.color)) {
                            agent.ptr -= 0.1;
                            neighbor.ptr += 0.5;
                        }
                    }
                }
            }

            // Migration phase - agents with negative ptr try to move
            const migrations = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (!agent || agent.ptr >= 0) continue;

                    // Try to migrate if fitness is negative
                    if (Math.random() < migrationProb) {
                        const neighbors = getNeighbors(i, j);
                        const emptyNeighbors = neighbors.filter(n => !n.agent);

                        if (emptyNeighbors.length > 0) {
                            const target = emptyNeighbors[Math.floor(Math.random() * emptyNeighbors.length)];
                            migrations.push({
                                from: {x: i, y: j},
                                to: {x: target.x, y: target.y},
                                agent: agent
                            });
                        }
                    }
                }
            }

            // Execute migrations
            for (const {from, to, agent} of migrations) {
                grid[from.x][from.y] = null;
                grid[to.x][to.y] = agent;
            }

            // Reproduction
            const newborns = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (!agent || agent.ptr < 1.0) continue;

                    const neighbors = getNeighbors(i, j);
                    const emptyNeighbors = neighbors.filter(n => !n.agent);

                    if (emptyNeighbors.length > 0) {
                        const target = emptyNeighbors[Math.floor(Math.random() * emptyNeighbors.length)];
                        newborns.push({x: target.x, y: target.y, agent: agent.clone()});
                        agent.ptr -= 1.0;
                    }
                }
            }

            for (const {x, y, agent} of newborns) {
                grid[x][y] = agent;
            }

            // Death
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j] && Math.random() < 0.01) {
                        grid[i][j] = null;
                    }
                }
            }

            draw();
        }

        function draw() {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (agent) {
                        ctx.fillStyle = COLORS[agent.color];
                        ctx.fillRect(i * CELL_SIZE, j * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
        }

        function animate() {
            if (running) {
                step();
                setTimeout(() => requestAnimationFrame(animate), 50);
            }
        }

        document.getElementById('migrationSlider').addEventListener('input', (e) => {
            migrationProb = e.target.value / 100;
            document.getElementById('migrationValue').textContent = (migrationProb * 100).toFixed(0) + '%';
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            running = true;
            animate();
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            running = false;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            initialize();
        });

        // Expose for enhance.js
        window.reset = function() { running = false; initialize(); };

        initialize();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
