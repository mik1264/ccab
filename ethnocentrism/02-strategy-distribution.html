<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategy Distribution Over Time</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #333;
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
        }
        h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 28px;
        }
        .description {
            color: #666;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        .canvas-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        canvas {
            border: 2px solid #667eea;
            border-radius: 8px;
        }
        #chartCanvas {
            background: #f8f9fa;
        }
        #gridCanvas {
            background: #000;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            backdrop-filter: blur(10px);
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s;
        }
        button:hover {
            background: #5568d3;
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        .legend-label {
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Strategy Distribution Over Time</h1>
        <p class="description">
            Tracks population of each strategy type over generations. Watch how ethnocentrics (cooperate with same color only)
            typically dominate, while altruists help everyone briefly before being exploited, and egoists fail to form
            cooperative clusters. The chart shows the classic pattern where ethnocentrism emerges as the stable strategy.
        </p>

        <div class="canvas-container">
            <canvas id="gridCanvas" width="400" height="400"></canvas>
            <canvas id="chartCanvas" width="700" height="400"></canvas>
        </div>

        <div class="controls">
            <button id="startBtn">Start</button>
            <button id="pauseBtn">Pause</button>
            <button id="resetBtn">Reset</button>
            <button id="clearChartBtn">Clear Chart</button>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #00ff00;"></div>
                <span class="legend-label">Altruists (++): Cooperate with everyone</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff0000;"></div>
                <span class="legend-label">Ethnocentrics (+-): Cooperate with same color only</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffaa00;"></div>
                <span class="legend-label">Cosmopolitans (-+): Cooperate with different colors only</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #0088ff;"></div>
                <span class="legend-label">Egoists (--): Never cooperate</span>
            </div>
        </div>
    </div>

    <script>
        const gridCanvas = document.getElementById('gridCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const chartCanvas = document.getElementById('chartCanvas');
        const chartCtx = chartCanvas.getContext('2d');

        const GRID_SIZE = 40;
        const CELL_SIZE = gridCanvas.width / GRID_SIZE;

        const ALTRUIST = 0;
        const ETHNOCENTRIC = 1;
        const COSMOPOLITAN = 2;
        const EGOIST = 3;

        const STRATEGY_COLORS = ['#00ff00', '#ff0000', '#ffaa00', '#0088ff'];
        const AGENT_COLORS = ['#4444ff', '#ff4444', '#44ff44', '#ffff44'];

        let grid = [];
        let generation = 0;
        let running = false;
        let history = [[], [], [], []]; // History for each strategy
        const MAX_HISTORY = 500;

        class Agent {
            constructor(color, cooperateSame, cooperateDiff) {
                this.color = color;
                this.cooperateSame = cooperateSame;
                this.cooperateDiff = cooperateDiff;
                this.ptr = 0;
            }

            get strategy() {
                if (this.cooperateSame && this.cooperateDiff) return ALTRUIST;
                if (this.cooperateSame && !this.cooperateDiff) return ETHNOCENTRIC;
                if (!this.cooperateSame && this.cooperateDiff) return COSMOPOLITAN;
                return EGOIST;
            }

            shouldCooperate(otherColor) {
                const sameColor = this.color === otherColor;
                return sameColor ? this.cooperateSame : this.cooperateDiff;
            }

            clone() {
                let cooperateSame = this.cooperateSame;
                let cooperateDiff = this.cooperateDiff;
                let color = this.color;

                if (Math.random() < 0.005) cooperateSame = !cooperateSame;
                if (Math.random() < 0.005) cooperateDiff = !cooperateDiff;
                if (Math.random() < 0.005) color = Math.floor(Math.random() * 4);

                return new Agent(color, cooperateSame, cooperateDiff);
            }
        }

        function initialize() {
            grid = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                grid[i] = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (Math.random() < 0.5) {
                        const color = Math.floor(Math.random() * 4);
                        const cooperateSame = Math.random() < 0.5;
                        const cooperateDiff = Math.random() < 0.5;
                        grid[i][j] = new Agent(color, cooperateSame, cooperateDiff);
                    } else {
                        grid[i][j] = null;
                    }
                }
            }
            generation = 0;
            history = [[], [], [], []];
            draw();
        }

        function getNeighbors(x, y) {
            const neighbors = [];
            const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    neighbors.push({x: nx, y: ny, agent: grid[nx][ny]});
                }
            }
            return neighbors;
        }

        function step() {
            // Interactions
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (!agent) continue;

                    const neighbors = getNeighbors(i, j);
                    for (const {agent: neighbor} of neighbors) {
                        if (!neighbor) continue;
                        if (agent.shouldCooperate(neighbor.color)) {
                            agent.ptr -= 0.1;
                            neighbor.ptr += 0.5;
                        }
                    }
                }
            }

            // Reproduction
            const newborns = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (!agent || agent.ptr < 1.0) continue;

                    const neighbors = getNeighbors(i, j);
                    const emptyNeighbors = neighbors.filter(n => !n.agent);

                    if (emptyNeighbors.length > 0) {
                        const target = emptyNeighbors[Math.floor(Math.random() * emptyNeighbors.length)];
                        newborns.push({x: target.x, y: target.y, agent: agent.clone()});
                        agent.ptr -= 1.0;
                    }
                }
            }

            for (const {x, y, agent} of newborns) {
                grid[x][y] = agent;
            }

            // Death
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j] && Math.random() < 0.01) {
                        grid[i][j] = null;
                    }
                }
            }

            generation++;
            updateHistory();
            draw();
        }

        function updateHistory() {
            let counts = [0, 0, 0, 0];
            let total = 0;

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (agent) {
                        counts[agent.strategy]++;
                        total++;
                    }
                }
            }

            // Store percentages
            for (let s = 0; s < 4; s++) {
                history[s].push(total > 0 ? (counts[s] / total) * 100 : 0);
                if (history[s].length > MAX_HISTORY) {
                    history[s].shift();
                }
            }
        }

        function draw() {
            // Draw grid
            gridCtx.fillStyle = '#000000';
            gridCtx.fillRect(0, 0, gridCanvas.width, gridCanvas.height);

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (agent) {
                        gridCtx.fillStyle = AGENT_COLORS[agent.color];
                        gridCtx.fillRect(i * CELL_SIZE, j * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }

            // Draw chart
            chartCtx.fillStyle = '#f8f9fa';
            chartCtx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);

            // Draw axes
            chartCtx.strokeStyle = '#333';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();
            chartCtx.moveTo(50, 10);
            chartCtx.lineTo(50, 360);
            chartCtx.lineTo(690, 360);
            chartCtx.stroke();

            // Labels
            chartCtx.fillStyle = '#333';
            chartCtx.font = '12px sans-serif';
            chartCtx.fillText('100%', 10, 15);
            chartCtx.fillText('50%', 15, 185);
            chartCtx.fillText('0%', 20, 365);
            chartCtx.fillText('Generation', 320, 390);

            // Draw lines
            if (history[0].length > 1) {
                const xScale = 640 / MAX_HISTORY;
                const yScale = 350 / 100;

                for (let s = 0; s < 4; s++) {
                    chartCtx.strokeStyle = STRATEGY_COLORS[s];
                    chartCtx.lineWidth = 2;
                    chartCtx.beginPath();

                    for (let i = 0; i < history[s].length; i++) {
                        const x = 50 + i * xScale;
                        const y = 360 - history[s][i] * yScale;

                        if (i === 0) {
                            chartCtx.moveTo(x, y);
                        } else {
                            chartCtx.lineTo(x, y);
                        }
                    }
                    chartCtx.stroke();
                }
            }
        }

        function animate() {
            if (running) {
                step();
                setTimeout(() => requestAnimationFrame(animate), 50);
            }
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            running = true;
            animate();
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            running = false;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            initialize();
        });

        document.getElementById('clearChartBtn').addEventListener('click', () => {
            history = [[], [], [], []];
            draw();
        });

        // Expose functions for enhance.js keyboard shortcuts
        window.reset = initialize;

        initialize();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
