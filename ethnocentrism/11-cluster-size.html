<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cluster Size Evolution</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #333;
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
        }
        h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 28px;
        }
        .description {
            color: #666;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        .canvas-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        canvas {
            border: 2px solid #667eea;
            border-radius: 8px;
        }
        #gridCanvas { background: #000; }
        #chartCanvas { background: #f8f9fa; }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s;
        }
        button:hover {
            background: #5568d3;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Cluster Size Evolution</h1>
        <p class="description">
            Tracks the size of same-color clusters over time. Small clusters grow through internal cooperation, merge when
            they meet, and compete at boundaries. Chart shows average cluster size for each color. Larger clusters have
            more internal cooperation and better survival, demonstrating how ethnocentrism creates selective advantage for
            larger same-color territories.
        </p>

        <div class="canvas-container">
            <canvas id="gridCanvas" width="500" height="500"></canvas>
            <canvas id="chartCanvas" width="600" height="500"></canvas>
        </div>

        <div class="controls">
            <button id="startBtn">Start</button>
            <button id="pauseBtn">Pause</button>
            <button id="resetBtn">Reset</button>
        </div>
    </div>

    <script>
        const gridCanvas = document.getElementById('gridCanvas');
        const chartCanvas = document.getElementById('chartCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const chartCtx = chartCanvas.getContext('2d');

        const GRID_SIZE = 50;
        const CELL_SIZE = gridCanvas.width / GRID_SIZE;
        const COLORS = ['#4444ff', '#ff4444', '#44ff44', '#ffff44'];

        let grid = [];
        let running = false;
        let generation = 0;
        let clusterHistory = [[], [], [], []]; // History for each color
        const MAX_HISTORY = 300;

        class Agent {
            constructor(color) {
                this.color = color;
                this.cooperateSame = true;
                this.cooperateDiff = false;
                this.ptr = 0;
            }

            shouldCooperate(otherColor) {
                return this.color === otherColor;
            }

            clone() {
                const agent = new Agent(this.color);
                if (Math.random() < 0.002) agent.color = Math.floor(Math.random() * 4);
                return agent;
            }
        }

        function initialize() {
            grid = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                grid[i] = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    grid[i][j] = Math.random() < 0.4 ? new Agent(Math.floor(Math.random() * 4)) : null;
                }
            }
            generation = 0;
            clusterHistory = [[], [], [], []];
            draw();
        }

        function getNeighbors(x, y) {
            const neighbors = [];
            const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    neighbors.push({x: nx, y: ny, agent: grid[nx][ny]});
                }
            }
            return neighbors;
        }

        function findClusters() {
            const visited = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(false));
            const clusters = [[], [], [], []];

            function floodFill(x, y, color) {
                if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return 0;
                if (visited[x][y] || !grid[x][y] || grid[x][y].color !== color) return 0;

                visited[x][y] = true;
                let size = 1;

                size += floodFill(x - 1, y, color);
                size += floodFill(x + 1, y, color);
                size += floodFill(x, y - 1, color);
                size += floodFill(x, y + 1, color);

                return size;
            }

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (!visited[i][j] && grid[i][j]) {
                        const size = floodFill(i, j, grid[i][j].color);
                        if (size > 0) {
                            clusters[grid[i][j].color].push(size);
                        }
                    }
                }
            }

            return clusters;
        }

        function step() {
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j]) grid[i][j].ptr = 0;
                }
            }

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (!agent) continue;

                    const neighbors = getNeighbors(i, j);
                    for (const {agent: neighbor} of neighbors) {
                        if (!neighbor) continue;
                        if (agent.shouldCooperate(neighbor.color)) {
                            agent.ptr -= 0.1;
                            neighbor.ptr += 0.5;
                        }
                    }
                }
            }

            const newborns = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (!agent || agent.ptr < 1.0) continue;

                    const neighbors = getNeighbors(i, j);
                    const emptyNeighbors = neighbors.filter(n => !n.agent);

                    if (emptyNeighbors.length > 0) {
                        const target = emptyNeighbors[Math.floor(Math.random() * emptyNeighbors.length)];
                        newborns.push({x: target.x, y: target.y, agent: agent.clone()});
                        agent.ptr -= 1.0;
                    }
                }
            }

            for (const {x, y, agent} of newborns) {
                grid[x][y] = agent;
            }

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j] && Math.random() < 0.01) {
                        grid[i][j] = null;
                    }
                }
            }

            generation++;

            // Calculate average cluster sizes
            const clusters = findClusters();
            for (let c = 0; c < 4; c++) {
                const avg = clusters[c].length > 0
                    ? clusters[c].reduce((a, b) => a + b, 0) / clusters[c].length
                    : 0;
                clusterHistory[c].push(avg);
                if (clusterHistory[c].length > MAX_HISTORY) {
                    clusterHistory[c].shift();
                }
            }

            draw();
        }

        function draw() {
            // Draw grid
            gridCtx.fillStyle = '#000000';
            gridCtx.fillRect(0, 0, gridCanvas.width, gridCanvas.height);

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (agent) {
                        gridCtx.fillStyle = COLORS[agent.color];
                        gridCtx.fillRect(i * CELL_SIZE, j * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }

            // Draw chart
            chartCtx.fillStyle = '#f8f9fa';
            chartCtx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);

            // Axes
            chartCtx.strokeStyle = '#333';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();
            chartCtx.moveTo(50, 10);
            chartCtx.lineTo(50, 460);
            chartCtx.lineTo(590, 460);
            chartCtx.stroke();

            // Labels
            chartCtx.fillStyle = '#333';
            chartCtx.font = '12px sans-serif';
            chartCtx.fillText('Avg Cluster Size', 10, 30);
            chartCtx.fillText('100', 15, 60);
            chartCtx.fillText('50', 20, 235);
            chartCtx.fillText('0', 25, 465);

            if (clusterHistory[0].length > 1) {
                const xScale = 540 / MAX_HISTORY;
                const yScale = 450 / 100;

                for (let c = 0; c < 4; c++) {
                    chartCtx.strokeStyle = COLORS[c];
                    chartCtx.lineWidth = 2;
                    chartCtx.beginPath();

                    for (let i = 0; i < clusterHistory[c].length; i++) {
                        const x = 50 + i * xScale;
                        const y = 460 - Math.min(clusterHistory[c][i], 100) * yScale;

                        if (i === 0) chartCtx.moveTo(x, y);
                        else chartCtx.lineTo(x, y);
                    }
                    chartCtx.stroke();
                }
            }
        }

        function animate() {
            if (running) {
                step();
                setTimeout(() => requestAnimationFrame(animate), 100);
            }
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            running = true;
            animate();
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            running = false;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            initialize();
        });

        // Expose for enhance.js
        window.reset = function() { running = false; initialize(); };

        initialize();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
