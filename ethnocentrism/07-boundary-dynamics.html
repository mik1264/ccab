<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boundary Dynamics Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #333;
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 1400px;
            width: 100%;
        }
        h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 28px;
        }
        .description {
            color: #666;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        .canvas-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            justify-content: center;
        }
        .canvas-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .canvas-wrapper h3 {
            margin-bottom: 10px;
            color: #667eea;
        }
        canvas {
            border: 2px solid #667eea;
            border-radius: 8px;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s;
        }
        button:hover {
            background: #5568d3;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Boundary Dynamics Visualizer</h1>
        <p class="description">
            Highlights interaction dynamics at color boundaries. Left shows agent colors, right shows boundary zones in red
            (areas where different colors meet). Ethnocentric territories have sharp, hostile boundaries with high defection
            rates. Watch how boundaries shift as territories compete and expand through differential reproduction.
        </p>

        <div class="canvas-container">
            <div class="canvas-wrapper">
                <h3>Agent Grid</h3>
                <canvas id="gridCanvas" width="500" height="500"></canvas>
            </div>
            <div class="canvas-wrapper">
                <h3>Boundary Zones (Red = Conflict)</h3>
                <canvas id="boundaryCanvas" width="500" height="500"></canvas>
            </div>
        </div>

        <div class="controls">
            <button id="startBtn">Start</button>
            <button id="pauseBtn">Pause</button>
            <button id="resetBtn">Reset</button>
        </div>
    </div>

    <script>
        const gridCanvas = document.getElementById('gridCanvas');
        const boundaryCanvas = document.getElementById('boundaryCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const boundaryCtx = boundaryCanvas.getContext('2d');

        const GRID_SIZE = 60;
        const CELL_SIZE = gridCanvas.width / GRID_SIZE;

        const COLORS = ['#4444ff', '#ff4444', '#44ff44', '#ffff44'];

        let grid = [];
        let running = false;

        class Agent {
            constructor(color) {
                this.color = color;
                this.cooperateSame = true;
                this.cooperateDiff = false;
                this.ptr = 0;
            }

            shouldCooperate(otherColor) {
                return this.color === otherColor ? this.cooperateSame : this.cooperateDiff;
            }

            clone() {
                const newAgent = new Agent(this.color);
                newAgent.cooperateSame = this.cooperateSame;
                newAgent.cooperateDiff = this.cooperateDiff;
                if (Math.random() < 0.002) newAgent.color = Math.floor(Math.random() * 4);
                return newAgent;
            }
        }

        function initialize() {
            grid = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                grid[i] = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (Math.random() < 0.5) {
                        const color = Math.floor(Math.random() * 4);
                        grid[i][j] = new Agent(color);
                    } else {
                        grid[i][j] = null;
                    }
                }
            }
            draw();
        }

        function getNeighbors(x, y) {
            const neighbors = [];
            const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    neighbors.push({x: nx, y: ny, agent: grid[nx][ny]});
                }
            }
            return neighbors;
        }

        function isBoundary(x, y) {
            const agent = grid[x][y];
            if (!agent) return false;

            const neighbors = getNeighbors(x, y);
            for (const {agent: neighbor} of neighbors) {
                if (neighbor && neighbor.color !== agent.color) {
                    return true;
                }
            }
            return false;
        }

        function step() {
            // Reset PTR
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j]) grid[i][j].ptr = 0;
                }
            }

            // Interactions
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (!agent) continue;

                    const neighbors = getNeighbors(i, j);
                    for (const {agent: neighbor} of neighbors) {
                        if (!neighbor) continue;
                        if (agent.shouldCooperate(neighbor.color)) {
                            agent.ptr -= 0.1;
                            neighbor.ptr += 0.5;
                        }
                    }
                }
            }

            // Reproduction
            const newborns = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (!agent || agent.ptr < 1.0) continue;

                    const neighbors = getNeighbors(i, j);
                    const emptyNeighbors = neighbors.filter(n => !n.agent);

                    if (emptyNeighbors.length > 0) {
                        const target = emptyNeighbors[Math.floor(Math.random() * emptyNeighbors.length)];
                        newborns.push({x: target.x, y: target.y, agent: agent.clone()});
                        agent.ptr -= 1.0;
                    }
                }
            }

            for (const {x, y, agent} of newborns) {
                grid[x][y] = agent;
            }

            // Death
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j] && Math.random() < 0.01) {
                        grid[i][j] = null;
                    }
                }
            }

            draw();
        }

        function draw() {
            // Draw agent grid
            gridCtx.fillStyle = '#000000';
            gridCtx.fillRect(0, 0, gridCanvas.width, gridCanvas.height);

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (agent) {
                        gridCtx.fillStyle = COLORS[agent.color];
                        gridCtx.fillRect(i * CELL_SIZE, j * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }

            // Draw boundary map
            boundaryCtx.fillStyle = '#000000';
            boundaryCtx.fillRect(0, 0, boundaryCanvas.width, boundaryCanvas.height);

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j]) {
                        if (isBoundary(i, j)) {
                            // Red for boundary
                            boundaryCtx.fillStyle = '#ff0000';
                        } else {
                            // Green for interior
                            boundaryCtx.fillStyle = '#00ff00';
                        }
                        boundaryCtx.fillRect(i * CELL_SIZE, j * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
        }

        function animate() {
            if (running) {
                step();
                setTimeout(() => requestAnimationFrame(animate), 100);
            }
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            running = true;
            animate();
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            running = false;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            initialize();
        });

        // Expose for enhance.js
        window.reset = function() { running = false; initialize(); };

        initialize();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
