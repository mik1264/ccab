<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carrying Capacity Effects</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #333;
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
        }
        h1 { color: #667eea; margin-bottom: 10px; font-size: 28px; }
        .description { color: #666; margin-bottom: 20px; line-height: 1.6; }
        canvas { border: 2px solid #667eea; border-radius: 8px; background: #000; display: block; margin: 0 auto 20px; }
        .controls { display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px; align-items: center; justify-content: center; }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s;
        }
        button:hover { background: #5568d3; }
        .slider-group { display: flex; flex-direction: column; gap: 5px; }
        .slider-group label { font-size: 12px; color: #666; font-weight: 600; }
        input[type="range"] { width: 200px; }
        .stats { text-align: center; font-size: 14px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Carrying Capacity Effects</h1>
        <p class="description">
            Limits population density by preventing reproduction when local density exceeds threshold. High carrying capacity
            allows dense packing and stronger ethnocentric clusters. Low capacity forces competition for space, making
            cooperation benefits more critical. Adjust the slider to see how population limits affect strategy evolution
            and territorial dynamics.
        </p>

        <canvas id="canvas" width="700" height="700"></canvas>

        <div class="controls">
            <button id="startBtn">Start</button>
            <button id="pauseBtn">Pause</button>
            <button id="resetBtn">Reset</button>

            <div class="slider-group">
                <label>Carrying Capacity: <span id="capacityValue">80%</span></label>
                <input type="range" id="capacitySlider" min="20" max="100" value="80" step="5">
            </div>
        </div>

        <div class="stats" id="stats">
            Generation: 0 | Population: 0 / Max: 0
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const GRID_SIZE = 70;
        const CELL_SIZE = canvas.width / GRID_SIZE;
        const COLORS = ['#4444ff', '#ff4444', '#44ff44', '#ffff44'];

        let grid = [];
        let running = false;
        let generation = 0;
        let carryingCapacity = 0.8;

        class Agent {
            constructor(color, cooperateSame, cooperateDiff) {
                this.color = color;
                this.cooperateSame = cooperateSame;
                this.cooperateDiff = cooperateDiff;
                this.ptr = 0;
            }

            shouldCooperate(otherColor) {
                return (this.color === otherColor) ? this.cooperateSame : this.cooperateDiff;
            }

            clone() {
                let cs = this.cooperateSame;
                let cd = this.cooperateDiff;
                let c = this.color;

                if (Math.random() < 0.005) cs = !cs;
                if (Math.random() < 0.005) cd = !cd;
                if (Math.random() < 0.005) c = Math.floor(Math.random() * 4);

                return new Agent(c, cs, cd);
            }
        }

        function initialize() {
            grid = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                grid[i] = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (Math.random() < 0.4) {
                        grid[i][j] = new Agent(
                            Math.floor(Math.random() * 4),
                            Math.random() < 0.5,
                            Math.random() < 0.5
                        );
                    } else {
                        grid[i][j] = null;
                    }
                }
            }
            generation = 0;
            draw();
        }

        function getNeighbors(x, y) {
            const neighbors = [];
            const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    neighbors.push({x: nx, y: ny, agent: grid[nx][ny]});
                }
            }
            return neighbors;
        }

        function getLocalDensity(x, y, radius = 2) {
            let count = 0;
            let total = 0;

            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                        total++;
                        if (grid[nx][ny]) count++;
                    }
                }
            }

            return total > 0 ? count / total : 0;
        }

        function step() {
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j]) grid[i][j].ptr = 0;
                }
            }

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (!agent) continue;

                    const neighbors = getNeighbors(i, j);
                    for (const {agent: neighbor} of neighbors) {
                        if (!neighbor) continue;
                        if (agent.shouldCooperate(neighbor.color)) {
                            agent.ptr -= 0.1;
                            neighbor.ptr += 0.5;
                        }
                    }
                }
            }

            const newborns = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (!agent || agent.ptr < 1.0) continue;

                    // Check carrying capacity before reproducing
                    const localDensity = getLocalDensity(i, j);
                    if (localDensity >= carryingCapacity) continue;

                    const neighbors = getNeighbors(i, j);
                    const emptyNeighbors = neighbors.filter(n => !n.agent);

                    if (emptyNeighbors.length > 0) {
                        const target = emptyNeighbors[Math.floor(Math.random() * emptyNeighbors.length)];
                        newborns.push({x: target.x, y: target.y, agent: agent.clone()});
                        agent.ptr -= 1.0;
                    }
                }
            }

            for (const {x, y, agent} of newborns) {
                grid[x][y] = agent;
            }

            // Increased death rate when near capacity
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j]) {
                        const localDensity = getLocalDensity(i, j);
                        const deathProb = 0.01 + (localDensity > carryingCapacity ? 0.05 : 0);
                        if (Math.random() < deathProb) {
                            grid[i][j] = null;
                        }
                    }
                }
            }

            generation++;
            draw();
        }

        function draw() {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let population = 0;

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (agent) {
                        ctx.fillStyle = COLORS[agent.color];
                        ctx.fillRect(i * CELL_SIZE, j * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        population++;
                    }
                }
            }

            const maxPop = Math.floor(GRID_SIZE * GRID_SIZE * carryingCapacity);
            document.getElementById('stats').textContent = `Generation: ${generation} | Population: ${population} / Max: ${maxPop}`;
        }

        function animate() {
            if (running) {
                step();
                setTimeout(() => requestAnimationFrame(animate), 50);
            }
        }

        document.getElementById('capacitySlider').addEventListener('input', (e) => {
            carryingCapacity = e.target.value / 100;
            document.getElementById('capacityValue').textContent = (carryingCapacity * 100).toFixed(0) + '%';
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            running = true;
            animate();
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            running = false;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            initialize();
        });

        // Expose for enhance.js
        window.reset = function() { running = false; initialize(); };

        initialize();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
