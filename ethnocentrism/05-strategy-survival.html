<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategy Survival Comparison</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #333;
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 1400px;
            width: 100%;
        }
        h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 28px;
        }
        .description {
            color: #666;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        .canvas-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }
        .canvas-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .canvas-wrapper h3 {
            margin-bottom: 10px;
            color: #667eea;
        }
        canvas {
            border: 2px solid #667eea;
            border-radius: 8px;
            background: #000;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s;
        }
        button:hover {
            background: #5568d3;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Strategy Survival Comparison</h1>
        <p class="description">
            Four simultaneous simulations, each starting with 100% of one strategy type. Watch how each pure population
            evolves when mutations introduce other strategies. Ethnocentrics maintain dominance even when mutations occur,
            while altruists get exploited, cosmopolitans fail to cluster, and egoists starve from lack of cooperation.
        </p>

        <div class="canvas-grid">
            <div class="canvas-wrapper">
                <h3>100% Altruists Start</h3>
                <canvas id="canvas0" width="350" height="350"></canvas>
                <p id="stats0" style="margin-top: 10px;"></p>
            </div>
            <div class="canvas-wrapper">
                <h3>100% Ethnocentrics Start</h3>
                <canvas id="canvas1" width="350" height="350"></canvas>
                <p id="stats1" style="margin-top: 10px;"></p>
            </div>
            <div class="canvas-wrapper">
                <h3>100% Cosmopolitans Start</h3>
                <canvas id="canvas2" width="350" height="350"></canvas>
                <p id="stats2" style="margin-top: 10px;"></p>
            </div>
            <div class="canvas-wrapper">
                <h3>100% Egoists Start</h3>
                <canvas id="canvas3" width="350" height="350"></canvas>
                <p id="stats3" style="margin-top: 10px;"></p>
            </div>
        </div>

        <div class="controls">
            <button id="startBtn">Start All</button>
            <button id="pauseBtn">Pause All</button>
            <button id="resetBtn">Reset All</button>
        </div>
    </div>

    <script>
        const GRID_SIZE = 35;
        const COLORS = ['#4444ff', '#ff4444', '#44ff44', '#ffff44'];

        let running = false;
        let grids = [[], [], [], []];
        let generations = [0, 0, 0, 0];

        class Agent {
            constructor(color, cooperateSame, cooperateDiff) {
                this.color = color;
                this.cooperateSame = cooperateSame;
                this.cooperateDiff = cooperateDiff;
                this.ptr = 0;
            }

            get strategy() {
                if (this.cooperateSame && this.cooperateDiff) return 0; // Altruist
                if (this.cooperateSame && !this.cooperateDiff) return 1; // Ethnocentric
                if (!this.cooperateSame && this.cooperateDiff) return 2; // Cosmopolitan
                return 3; // Egoist
            }

            shouldCooperate(otherColor) {
                const sameColor = this.color === otherColor;
                return sameColor ? this.cooperateSame : this.cooperateDiff;
            }

            clone() {
                let cooperateSame = this.cooperateSame;
                let cooperateDiff = this.cooperateDiff;
                let color = this.color;

                if (Math.random() < 0.01) cooperateSame = !cooperateSame;
                if (Math.random() < 0.01) cooperateDiff = !cooperateDiff;
                if (Math.random() < 0.01) color = Math.floor(Math.random() * 4);

                return new Agent(color, cooperateSame, cooperateDiff);
            }
        }

        function initializeGrid(gridIndex, strategy) {
            const grid = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                grid[i] = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (Math.random() < 0.5) {
                        const color = Math.floor(Math.random() * 4);
                        const cooperateSame = (strategy === 0 || strategy === 1);
                        const cooperateDiff = (strategy === 0 || strategy === 2);
                        grid[i][j] = new Agent(color, cooperateSame, cooperateDiff);
                    } else {
                        grid[i][j] = null;
                    }
                }
            }
            grids[gridIndex] = grid;
            generations[gridIndex] = 0;
        }

        function initialize() {
            initializeGrid(0, 0); // All altruists
            initializeGrid(1, 1); // All ethnocentrics
            initializeGrid(2, 2); // All cosmopolitans
            initializeGrid(3, 3); // All egoists
            drawAll();
        }

        function getNeighbors(grid, x, y) {
            const neighbors = [];
            const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    neighbors.push({x: nx, y: ny, agent: grid[nx][ny]});
                }
            }
            return neighbors;
        }

        function stepGrid(gridIndex) {
            const grid = grids[gridIndex];

            // Reset PTR
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j]) grid[i][j].ptr = 0;
                }
            }

            // Interactions
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (!agent) continue;

                    const neighbors = getNeighbors(grid, i, j);
                    for (const {agent: neighbor} of neighbors) {
                        if (!neighbor) continue;
                        if (agent.shouldCooperate(neighbor.color)) {
                            agent.ptr -= 0.1;
                            neighbor.ptr += 0.5;
                        }
                    }
                }
            }

            // Reproduction
            const newborns = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (!agent || agent.ptr < 1.0) continue;

                    const neighbors = getNeighbors(grid, i, j);
                    const emptyNeighbors = neighbors.filter(n => !n.agent);

                    if (emptyNeighbors.length > 0) {
                        const target = emptyNeighbors[Math.floor(Math.random() * emptyNeighbors.length)];
                        newborns.push({x: target.x, y: target.y, agent: agent.clone()});
                        agent.ptr -= 1.0;
                    }
                }
            }

            for (const {x, y, agent} of newborns) {
                grid[x][y] = agent;
            }

            // Death
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j] && Math.random() < 0.01) {
                        grid[i][j] = null;
                    }
                }
            }

            generations[gridIndex]++;
        }

        function drawGrid(gridIndex) {
            const canvas = document.getElementById(`canvas${gridIndex}`);
            const ctx = canvas.getContext('2d');
            const cellSize = canvas.width / GRID_SIZE;
            const grid = grids[gridIndex];

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (agent) {
                        ctx.fillStyle = COLORS[agent.color];
                        ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                    }
                }
            }

            // Update stats
            const counts = [0, 0, 0, 0];
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (agent) counts[agent.strategy]++;
                }
            }

            const statsEl = document.getElementById(`stats${gridIndex}`);
            statsEl.innerHTML = `Gen ${generations[gridIndex]} | A:${counts[0]} E:${counts[1]} C:${counts[2]} Eg:${counts[3]}`;
        }

        function drawAll() {
            for (let i = 0; i < 4; i++) {
                drawGrid(i);
            }
        }

        function step() {
            for (let i = 0; i < 4; i++) {
                stepGrid(i);
            }
            drawAll();
        }

        function animate() {
            if (running) {
                step();
                setTimeout(() => requestAnimationFrame(animate), 100);
            }
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            running = true;
            animate();
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            running = false;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            initialize();
        });

        // Expose for enhance.js
        window.reset = function() { running = false; initialize(); };

        initialize();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
