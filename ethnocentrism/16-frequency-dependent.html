<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frequency-Dependent Selection</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #333;
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
        }
        h1 { color: #667eea; margin-bottom: 10px; font-size: 28px; }
        .description { color: #666; margin-bottom: 20px; line-height: 1.6; }
        .canvas-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        canvas { border: 2px solid #667eea; border-radius: 8px; }
        #gridCanvas { background: #000; }
        #chartCanvas { background: #f8f9fa; }
        .controls { display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px; align-items: center; justify-content: center; }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s;
        }
        button:hover { background: #5568d3; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Frequency-Dependent Selection</h1>
        <p class="description">
            Shows how strategy success depends on population frequencies. Minority strategies initially have advantage:
            altruists succeed when rare (find each other in sea of egoists), ethnocentrics succeed when rare (exploit
            altruists while cooperating with themselves). Once common, ethnocentrics maintain dominance through spatial
            clustering. Chart shows fitness (reproduction rate) for each strategy over time.
        </p>

        <div class="canvas-container">
            <canvas id="gridCanvas" width="500" height="500"></canvas>
            <canvas id="chartCanvas" width="600" height="500"></canvas>
        </div>

        <div class="controls">
            <button id="startBtn">Start</button>
            <button id="pauseBtn">Pause</button>
            <button id="resetBtn">Reset</button>
        </div>
    </div>

    <script>
        const gridCanvas = document.getElementById('gridCanvas');
        const chartCanvas = document.getElementById('chartCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const chartCtx = chartCanvas.getContext('2d');

        const GRID_SIZE = 50;
        const CELL_SIZE = gridCanvas.width / GRID_SIZE;
        const STRATEGY_COLORS = ['#00ff00', '#ff0000', '#ffaa00', '#0088ff'];
        const AGENT_COLORS = ['#4444ff', '#ff4444', '#44ff44', '#ffff44'];

        let grid = [];
        let running = false;
        let fitnessHistory = [[], [], [], []];
        const MAX_HISTORY = 300;

        class Agent {
            constructor(color, cooperateSame, cooperateDiff) {
                this.color = color;
                this.cooperateSame = cooperateSame;
                this.cooperateDiff = cooperateDiff;
                this.ptr = 0;
            }

            get strategy() {
                if (this.cooperateSame && this.cooperateDiff) return 0;
                if (this.cooperateSame && !this.cooperateDiff) return 1;
                if (!this.cooperateSame && this.cooperateDiff) return 2;
                return 3;
            }

            shouldCooperate(otherColor) {
                return (this.color === otherColor) ? this.cooperateSame : this.cooperateDiff;
            }

            clone() {
                let cs = this.cooperateSame;
                let cd = this.cooperateDiff;
                let c = this.color;

                if (Math.random() < 0.005) cs = !cs;
                if (Math.random() < 0.005) cd = !cd;
                if (Math.random() < 0.005) c = Math.floor(Math.random() * 4);

                return new Agent(c, cs, cd);
            }
        }

        function initialize() {
            grid = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                grid[i] = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (Math.random() < 0.5) {
                        grid[i][j] = new Agent(
                            Math.floor(Math.random() * 4),
                            Math.random() < 0.5,
                            Math.random() < 0.5
                        );
                    } else {
                        grid[i][j] = null;
                    }
                }
            }
            fitnessHistory = [[], [], [], []];
            draw();
        }

        function getNeighbors(x, y) {
            const neighbors = [];
            const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    neighbors.push({x: nx, y: ny, agent: grid[nx][ny]});
                }
            }
            return neighbors;
        }

        function step() {
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j]) grid[i][j].ptr = 0;
                }
            }

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (!agent) continue;

                    const neighbors = getNeighbors(i, j);
                    for (const {agent: neighbor} of neighbors) {
                        if (!neighbor) continue;
                        if (agent.shouldCooperate(neighbor.color)) {
                            agent.ptr -= 0.1;
                            neighbor.ptr += 0.5;
                        }
                    }
                }
            }

            // Calculate average fitness per strategy
            const fitness = [0, 0, 0, 0];
            const counts = [0, 0, 0, 0];

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (agent) {
                        fitness[agent.strategy] += agent.ptr;
                        counts[agent.strategy]++;
                    }
                }
            }

            for (let s = 0; s < 4; s++) {
                const avgFitness = counts[s] > 0 ? fitness[s] / counts[s] : 0;
                fitnessHistory[s].push(avgFitness * 10); // Scale for visibility
                if (fitnessHistory[s].length > MAX_HISTORY) {
                    fitnessHistory[s].shift();
                }
            }

            const newborns = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (!agent || agent.ptr < 1.0) continue;

                    const neighbors = getNeighbors(i, j);
                    const emptyNeighbors = neighbors.filter(n => !n.agent);

                    if (emptyNeighbors.length > 0) {
                        const target = emptyNeighbors[Math.floor(Math.random() * emptyNeighbors.length)];
                        newborns.push({x: target.x, y: target.y, agent: agent.clone()});
                        agent.ptr -= 1.0;
                    }
                }
            }

            for (const {x, y, agent} of newborns) {
                grid[x][y] = agent;
            }

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j] && Math.random() < 0.01) {
                        grid[i][j] = null;
                    }
                }
            }

            draw();
        }

        function draw() {
            // Draw grid
            gridCtx.fillStyle = '#000000';
            gridCtx.fillRect(0, 0, gridCanvas.width, gridCanvas.height);

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const agent = grid[i][j];
                    if (agent) {
                        gridCtx.fillStyle = AGENT_COLORS[agent.color];
                        gridCtx.fillRect(i * CELL_SIZE, j * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }

            // Draw chart
            chartCtx.fillStyle = '#f8f9fa';
            chartCtx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);

            // Axes
            chartCtx.strokeStyle = '#333';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();
            chartCtx.moveTo(50, 10);
            chartCtx.lineTo(50, 460);
            chartCtx.lineTo(590, 460);
            chartCtx.stroke();

            // Labels
            chartCtx.fillStyle = '#333';
            chartCtx.font = '12px sans-serif';
            chartCtx.fillText('Fitness', 10, 30);
            chartCtx.fillText('10', 20, 60);
            chartCtx.fillText('5', 25, 235);
            chartCtx.fillText('0', 25, 465);

            if (fitnessHistory[0].length > 1) {
                const xScale = 540 / MAX_HISTORY;
                const yScale = 450 / 10;

                for (let s = 0; s < 4; s++) {
                    chartCtx.strokeStyle = STRATEGY_COLORS[s];
                    chartCtx.lineWidth = 2;
                    chartCtx.beginPath();

                    for (let i = 0; i < fitnessHistory[s].length; i++) {
                        const x = 50 + i * xScale;
                        const y = 460 - Math.min(fitnessHistory[s][i], 10) * yScale;

                        if (i === 0) chartCtx.moveTo(x, y);
                        else chartCtx.lineTo(x, y);
                    }
                    chartCtx.stroke();
                }
            }
        }

        function animate() {
            if (running) {
                step();
                setTimeout(() => requestAnimationFrame(animate), 100);
            }
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            running = true;
            animate();
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            running = false;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            initialize();
        });

        initialize();
    </script>
</body>
</html>
