<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gabriel's Horn - Infinite Surface, Finite Volume</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e8e8e8;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 25px;
        }

        h1 {
            font-size: 2.2rem;
            background: linear-gradient(135deg, #ffd700, #ff8c00, #ff6347);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #aaa;
            font-size: 1.1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 330px;
            gap: 25px;
        }

        @media (max-width: 1100px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .viz-section {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 20px;
        }

        .canvas-container {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
        }

        canvas {
            border-radius: 8px;
            background: #0a0a0a;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #ffd700, #ff8c00);
            color: #000;
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .btn.active {
            background: linear-gradient(135deg, #ff6347, #dc143c);
            color: #fff;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }

        .control-group label {
            font-size: 0.85rem;
            color: #aaa;
        }

        input[type="range"] {
            width: 100px;
        }

        .stats-display {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .stat-box {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-box.volume {
            border: 2px solid #2ecc71;
        }

        .stat-box.surface {
            border: 2px solid #e74c3c;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .stat-value.finite {
            color: #2ecc71;
        }

        .stat-value.infinite {
            color: #e74c3c;
        }

        .stat-formula {
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: #aaa;
            margin-top: 5px;
        }

        .paradox-box {
            margin-top: 15px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,99,71,0.1));
            border-radius: 10px;
            border: 1px solid rgba(255,215,0,0.3);
            text-align: center;
        }

        .paradox-box h4 {
            color: #ffd700;
            margin-bottom: 10px;
        }

        .paradox-box p {
            color: #ccc;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .exp-card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 18px;
            border-left: 4px solid #ffd700;
        }

        .exp-card h3 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .exp-card p {
            color: #ccc;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .formula {
            background: rgba(0,0,0,0.4);
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            color: #ffd700;
            text-align: center;
            font-size: 0.85rem;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #ffd700;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            opacity: 0.8;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .back-link:hover {
            opacity: 1;
        }

        .highlight {
            color: #ff8c00;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>Gabriel's Horn</h1>
            <p class="subtitle">Evangelista Torricelli (1641) - The Painter's Paradox</p>
        </header>

        <div class="main-content">
            <div class="viz-section">
                <div class="canvas-container">
                    <canvas id="hornCanvas" width="700" height="450"></canvas>
                </div>

                <div class="controls">
                    <button class="btn btn-primary" id="rotateBtn">Rotate</button>
                    <button class="btn btn-secondary" id="fillBtn">Fill with Paint</button>
                    <button class="btn btn-secondary" id="resetBtn">Reset</button>

                    <div class="control-group">
                        <label>Length (x):</label>
                        <input type="range" id="lengthSlider" min="2" max="50" value="10">
                        <span id="lengthValue">10</span>
                    </div>
                </div>

                <div class="stats-display">
                    <div class="stat-box volume">
                        <div class="stat-label">Volume</div>
                        <div class="stat-value finite" id="volumeValue">œÄ</div>
                        <div class="stat-formula">‚à´‚ÇÅ^‚àû œÄ/x¬≤ dx = œÄ</div>
                    </div>
                    <div class="stat-box surface">
                        <div class="stat-label">Surface Area</div>
                        <div class="stat-value infinite" id="surfaceValue">‚àû</div>
                        <div class="stat-formula">‚à´‚ÇÅ^‚àû 2œÄ/x ‚àö(1+1/x‚Å¥) dx ‚Üí ‚àû</div>
                    </div>
                </div>

                <div class="paradox-box">
                    <h4>üé® The Painter's Paradox</h4>
                    <p id="paradoxText">You can FILL the horn with a finite amount of paint (œÄ cubic units). But to PAINT the outside surface, you'd need INFINITE paint! Yet... when it's full, the paint touches the entire inner surface. How can finite paint cover infinite area?</p>
                </div>
            </div>

            <div class="sidebar">
                <div class="exp-card">
                    <h3>üìØ The Shape</h3>
                    <p>Gabriel's Horn is formed by rotating the curve <span class="highlight">y = 1/x</span> around the x-axis, from x = 1 to infinity. The horn extends forever, getting narrower and narrower but never closing.</p>
                </div>

                <div class="exp-card">
                    <h3">üìä The Math</h3>
                    <p>Volume (disk method):</p>
                    <div class="formula">
                        V = œÄ‚à´‚ÇÅ^‚àû (1/x)¬≤ dx = œÄ
                    </div>
                    <p>Surface area diverges because 1/x decreases too slowly!</p>
                </div>

                <div class="exp-card">
                    <h3">üß† Resolution</h3>
                    <p>Mathematical "paint" has <span class="highlight">zero thickness</span>, so ‚àû √ó 0 is indeterminate. Physical paint has atomic thickness‚Äîeventually the horn gets too narrow for paint molecules, so only finite area is actually paintable!</p>
                </div>

                <div class="exp-card">
                    <h3">üìú History</h3>
                    <p>Torricelli discovered this in <span class="highlight">1641</span>, shocking mathematicians. Hobbes, Wallis, and Galileo debated its implications for infinity. It challenged 17th-century understanding of the infinite.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('hornCanvas');
        const ctx = canvas.getContext('2d');

        let rotation = 0;
        let animating = false;
        let animationId = null;
        let fillLevel = 0;
        let filling = false;

        function drawHorn() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const maxX = parseInt(document.getElementById('lengthSlider').value);
            const startX = 80;
            const endX = canvas.width - 40;
            const centerY = canvas.height / 2;
            const scale = (endX - startX) / maxX;

            // Draw axis
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(startX, centerY);
            ctx.lineTo(endX + 20, centerY);
            ctx.stroke();

            // Draw x-axis labels
            ctx.fillStyle = '#666';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            for (let x = 1; x <= maxX; x += Math.max(1, Math.floor(maxX / 10))) {
                const px = startX + (x - 1) * scale;
                ctx.fillText(x.toString(), px, centerY + 20);
            }

            // Generate horn profile points
            const points = [];
            for (let x = 1; x <= maxX; x += 0.1) {
                const y = 1 / x;
                const px = startX + (x - 1) * scale;
                const py = y * 150; // Scale for visibility
                points.push({ x: px, y: py, originalX: x });
            }

            // Draw filled portion if filling
            if (fillLevel > 0) {
                const fillX = 1 + (maxX - 1) * fillLevel;
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.beginPath();
                ctx.moveTo(startX, centerY);

                for (const p of points) {
                    if (p.originalX <= fillX) {
                        ctx.lineTo(p.x, centerY - p.y);
                    }
                }

                const lastFillPoint = points.find(p => p.originalX >= fillX) || points[points.length - 1];
                ctx.lineTo(lastFillPoint.x, centerY);

                for (let i = points.length - 1; i >= 0; i--) {
                    if (points[i].originalX <= fillX) {
                        ctx.lineTo(points[i].x, centerY + points[i].y);
                    }
                }

                ctx.closePath();
                ctx.fill();
            }

            // Draw 3D-ish horn with rotation effect
            const numRings = 30;
            const ringSpacing = Math.floor(points.length / numRings);

            for (let i = 0; i < numRings; i++) {
                const idx = Math.min(i * ringSpacing, points.length - 1);
                const p = points[idx];
                const radius = p.y;

                // Draw ellipse (ring) with rotation effect
                const perspective = 0.3 + 0.7 * (1 - idx / points.length);
                const yScale = Math.abs(Math.sin(rotation + i * 0.1)) * 0.8 + 0.2;

                ctx.strokeStyle = `hsla(${40 + i * 2}, 80%, ${50 + i}%, ${0.5 + perspective * 0.5})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(p.x, centerY, radius * yScale, radius, 0, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw horn outline (top and bottom curves)
            const gradient = ctx.createLinearGradient(startX, 0, endX, 0);
            gradient.addColorStop(0, '#ffd700');
            gradient.addColorStop(0.5, '#ff8c00');
            gradient.addColorStop(1, '#ff6347');

            ctx.strokeStyle = gradient;
            ctx.lineWidth = 3;

            // Top curve
            ctx.beginPath();
            ctx.moveTo(points[0].x, centerY - points[0].y);
            for (const p of points) {
                ctx.lineTo(p.x, centerY - p.y);
            }
            ctx.stroke();

            // Bottom curve
            ctx.beginPath();
            ctx.moveTo(points[0].x, centerY + points[0].y);
            for (const p of points) {
                ctx.lineTo(p.x, centerY + p.y);
            }
            ctx.stroke();

            // Draw opening circle at x=1
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(startX, centerY, points[0].y * 0.3, points[0].y, 0, 0, Math.PI * 2);
            ctx.stroke();

            // Label
            ctx.fillStyle = '#ffd700';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('y = 1/x', startX + 10, centerY - points[0].y - 10);

            // Arrow indicating infinite extension
            ctx.fillStyle = '#666';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('‚Üí ‚àû', endX + 10, centerY - 5);

            updateStats();
        }

        function updateStats() {
            const maxX = parseInt(document.getElementById('lengthSlider').value);

            // Volume at x approaches œÄ as x ‚Üí ‚àû
            const volume = Math.PI * (1 - 1 / maxX);
            document.getElementById('volumeValue').textContent = `‚âà ${volume.toFixed(4)} ‚Üí œÄ`;

            // Surface area grows without bound
            // Approximate: 2œÄ * ln(x) for large x
            const surface = 2 * Math.PI * Math.log(maxX);
            document.getElementById('surfaceValue').textContent = `‚âà ${surface.toFixed(1)} ‚Üí ‚àû`;

            document.getElementById('lengthValue').textContent = maxX;
        }

        function animateRotation() {
            if (!animating) return;

            rotation += 0.03;
            drawHorn();
            animationId = requestAnimationFrame(animateRotation);
        }

        function toggleRotation() {
            if (animating) {
                animating = false;
                document.getElementById('rotateBtn').textContent = 'Rotate';
                if (animationId) cancelAnimationFrame(animationId);
            } else {
                animating = true;
                document.getElementById('rotateBtn').textContent = 'Stop';
                animateRotation();
            }
        }

        function fillWithPaint() {
            if (filling) return;

            filling = true;
            fillLevel = 0;

            function animateFill() {
                fillLevel += 0.02;
                drawHorn();

                if (fillLevel < 1) {
                    requestAnimationFrame(animateFill);
                } else {
                    fillLevel = 1;
                    filling = false;
                    document.getElementById('paradoxText').textContent =
                        "The horn is now FULL! œÄ cubic units of paint fill the entire infinite length. The paint touches every point of the inner surface... yet that surface has INFINITE area. Paradox!";
                }
            }

            animateFill();
        }

        function reset() {
            animating = false;
            filling = false;
            fillLevel = 0;
            rotation = 0;
            document.getElementById('rotateBtn').textContent = 'Rotate';
            if (animationId) cancelAnimationFrame(animationId);
            document.getElementById('paradoxText').textContent =
                "You can FILL the horn with a finite amount of paint (œÄ cubic units). But to PAINT the outside surface, you'd need INFINITE paint! Yet... when it's full, the paint touches the entire inner surface. How can finite paint cover infinite area?";
            drawHorn();
        }

        // Event listeners
        document.getElementById('rotateBtn').addEventListener('click', toggleRotation);
        document.getElementById('fillBtn').addEventListener('click', fillWithPaint);
        document.getElementById('resetBtn').addEventListener('click', reset);
        document.getElementById('lengthSlider').addEventListener('input', () => {
            if (!animating) drawHorn();
        });

        // Initialize
        drawHorn();
    </script>
</body>
</html>
