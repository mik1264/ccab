<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Hairy Ball Theorem - You Can't Comb It Flat</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a2a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #ff6b9d;
            text-decoration: none;
            font-size: 0.9rem;
            z-index: 100;
            padding: 8px 16px;
            background: rgba(255,107,157,0.1);
            border-radius: 20px;
            border: 1px solid rgba(255,107,157,0.3);
            transition: all 0.3s;
        }
        .back-link:hover {
            background: rgba(255,107,157,0.2);
            transform: translateX(-3px);
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 80px 20px 40px;
        }
        h1 {
            text-align: center;
            font-size: 2.8rem;
            background: linear-gradient(135deg, #ff6b9d, #c44569, #ff9a56);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }
        .subtitle {
            text-align: center;
            font-size: 1.3rem;
            color: #9090b0;
            margin-bottom: 40px;
            font-style: italic;
        }
        .intro-box {
            background: rgba(255,107,157,0.1);
            border-left: 4px solid #ff6b9d;
            padding: 25px;
            border-radius: 0 15px 15px 0;
            margin-bottom: 40px;
            line-height: 1.8;
        }
        .intro-box strong {
            color: #ff9a56;
        }
        .sphere-section {
            background: rgba(255,255,255,0.03);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 40px;
            border: 1px solid rgba(255,107,157,0.2);
        }
        .sphere-title {
            text-align: center;
            font-size: 1.5rem;
            color: #ff6b9d;
            margin-bottom: 20px;
        }
        .canvas-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        canvas {
            border-radius: 10px;
            background: #0d0d20;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        button {
            padding: 12px 25px;
            font-size: 1rem;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        .btn-primary {
            background: linear-gradient(135deg, #ff6b9d, #c44569);
            color: white;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255,107,157,0.4);
        }
        .btn-secondary {
            background: rgba(78,205,196,0.2);
            color: #4ecdc4;
            border: 2px solid #4ecdc4;
        }
        .btn-secondary.active {
            background: rgba(78,205,196,0.4);
        }
        .slider-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-group label {
            font-size: 0.9rem;
            color: #9090b0;
        }
        input[type="range"] {
            width: 120px;
            accent-color: #ff6b9d;
        }
        .cowlick-indicator {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, rgba(231,76,60,0.2), rgba(192,57,43,0.2));
            border-radius: 15px;
            margin: 20px 0;
            border: 2px solid #e74c3c;
        }
        .cowlick-indicator h4 {
            color: #e74c3c;
            margin-bottom: 10px;
            font-size: 1.3rem;
        }
        .cowlick-indicator p {
            color: #c0c0d0;
        }
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 30px 0;
        }
        @media (max-width: 800px) {
            .comparison-grid { grid-template-columns: 1fr; }
        }
        .comparison-box {
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }
        .comparison-box h4 {
            margin-bottom: 15px;
        }
        .comparison-box.sphere h4 { color: #e74c3c; }
        .comparison-box.torus h4 { color: #2ecc71; }
        .comparison-box canvas {
            max-width: 100%;
        }
        .explanation-section {
            background: rgba(255,255,255,0.03);
            border-radius: 20px;
            padding: 35px;
            margin-bottom: 40px;
            border: 1px solid rgba(255,107,157,0.2);
        }
        .explanation-section h2 {
            color: #ff6b9d;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }
        .explanation-section h3 {
            color: #ff9a56;
            margin: 25px 0 15px;
            font-size: 1.3rem;
        }
        .explanation-section p {
            line-height: 1.8;
            margin-bottom: 15px;
            color: #c0c0d0;
        }
        .key-insight {
            background: linear-gradient(135deg, rgba(255,107,157,0.15), rgba(196,69,105,0.15));
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            border-left: 4px solid #ff6b9d;
        }
        .key-insight h4 {
            color: #ff6b9d;
            margin-bottom: 10px;
        }
        .math-box {
            background: rgba(0,0,0,0.4);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-family: 'Times New Roman', serif;
            font-size: 1.2rem;
            margin: 20px 0;
            color: #4ecdc4;
        }
        .application-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        .app-card {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 15px;
            border-left: 4px solid #4ecdc4;
        }
        .app-card h4 {
            color: #4ecdc4;
            margin-bottom: 10px;
        }
        .app-card p {
            font-size: 0.95rem;
            line-height: 1.6;
        }
        .wind-box {
            background: linear-gradient(135deg, rgba(52,152,219,0.2), rgba(46,204,113,0.2));
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            border: 1px solid rgba(52,152,219,0.4);
        }
        .wind-box h4 {
            color: #3498db;
            margin-bottom: 15px;
        }
        .euler-box {
            background: rgba(155,89,182,0.15);
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            text-align: center;
        }
        .euler-box h4 {
            color: #9b59b6;
            margin-bottom: 15px;
        }
        .euler-table {
            margin: 15px auto;
            border-collapse: collapse;
        }
        .euler-table th, .euler-table td {
            padding: 10px 20px;
            border: 1px solid rgba(155,89,182,0.3);
        }
        .euler-table th {
            background: rgba(155,89,182,0.2);
            color: #9b59b6;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <div class="container">
        <h1>The Hairy Ball Theorem</h1>
        <p class="subtitle">You can't comb a hairy sphere flat without creating a cowlick</p>

        <div class="intro-box">
            <p>Imagine a perfectly hairy sphere ‚Äî like a fuzzy tennis ball with infinitely fine hair covering every point. Now try to comb all the hair to lie flat against the surface, with no hair sticking up.</p>
            <p><strong>It's impossible.</strong> No matter how carefully you comb, there will always be at least one point where the hair either sticks straight up or vanishes entirely ‚Äî a <strong>cowlick</strong>.</p>
            <p>This isn't just a quirky math fact. It means <strong>there's always at least one point on Earth where the wind isn't blowing</strong>!</p>
        </div>

        <div class="sphere-section">
            <h3 class="sphere-title">Interactive Hairy Sphere</h3>
            <p style="text-align: center; color: #9090b0; margin-bottom: 15px;">Drag to rotate ‚Ä¢ Watch the cowlicks form</p>

            <div class="canvas-container">
                <canvas id="sphereCanvas" width="500" height="500"></canvas>
            </div>

            <div class="controls">
                <button class="btn-primary" id="combBtn">Try to Comb Flat</button>
                <button class="btn-secondary" id="rotateBtn">Auto Rotate</button>
                <button class="btn-secondary" id="resetBtn">Reset</button>
            </div>

            <div class="slider-container">
                <div class="slider-group">
                    <label>Hair Density:</label>
                    <input type="range" id="densitySlider" min="50" max="300" value="150">
                </div>
                <div class="slider-group">
                    <label>Hair Length:</label>
                    <input type="range" id="lengthSlider" min="10" max="40" value="25">
                </div>
            </div>

            <div class="cowlick-indicator" id="cowlickIndicator">
                <h4>‚ö†Ô∏è Cowlicks Detected: <span id="cowlickCount">2</span></h4>
                <p>No matter how you comb, you cannot eliminate all cowlicks on a sphere!</p>
            </div>
        </div>

        <div class="comparison-grid">
            <div class="comparison-box sphere">
                <h4>‚ùå Sphere (Euler œá = 2)</h4>
                <canvas id="miniSphere" width="200" height="200"></canvas>
                <p style="margin-top: 10px; color: #e74c3c;">Cannot comb flat ‚Äî must have cowlicks</p>
            </div>
            <div class="comparison-box torus">
                <h4>‚úì Torus (Euler œá = 0)</h4>
                <canvas id="miniTorus" width="200" height="200"></canvas>
                <p style="margin-top: 10px; color: #2ecc71;">CAN be combed perfectly flat!</p>
            </div>
        </div>

        <div class="explanation-section">
            <h2>Why Can't You Comb a Sphere?</h2>

            <div class="key-insight">
                <h4>The Theorem (Poincar√©-Brouwer, 1912)</h4>
                <p>There is no continuous, non-vanishing tangent vector field on any even-dimensional sphere. In simple terms: <strong>every hairy sphere has at least one bald spot or cowlick</strong>.</p>
            </div>

            <h3>The Euler Characteristic Connection</h3>
            <p>The secret lies in a number called the <strong>Euler characteristic (œá)</strong>. For any surface:</p>

            <div class="math-box">
                Sum of indices at all zeros = œá (Euler characteristic)
            </div>

            <div class="euler-box">
                <h4>Euler Characteristics of Surfaces</h4>
                <table class="euler-table">
                    <tr>
                        <th>Surface</th>
                        <th>œá</th>
                        <th>Can Comb Flat?</th>
                    </tr>
                    <tr>
                        <td>Sphere</td>
                        <td>2</td>
                        <td style="color: #e74c3c;">No ‚ùå</td>
                    </tr>
                    <tr>
                        <td>Torus (donut)</td>
                        <td>0</td>
                        <td style="color: #2ecc71;">Yes ‚úì</td>
                    </tr>
                    <tr>
                        <td>Double torus</td>
                        <td>-2</td>
                        <td style="color: #e74c3c;">No ‚ùå</td>
                    </tr>
                </table>
            </div>

            <p>Since a sphere has œá = 2, the indices at any zeros must sum to 2. This means there must be at least one zero (cowlick). In fact, the most "efficient" combing creates exactly <strong>two cowlicks</strong> ‚Äî one at each pole!</p>

            <h3>Types of Cowlicks (Singularities)</h3>
            <div class="application-grid">
                <div class="app-card">
                    <h4>Source (Index +1)</h4>
                    <p>Hair radiates outward from a point, like a crown of the head. All vectors point away.</p>
                </div>
                <div class="app-card">
                    <h4>Sink (Index +1)</h4>
                    <p>Hair converges inward to a point, like water going down a drain. All vectors point in.</p>
                </div>
                <div class="app-card">
                    <h4>Saddle (Index -1)</h4>
                    <p>Hair comes in from two directions and exits in two others. Creates a hyperbolic pattern.</p>
                </div>
            </div>

            <p>On a sphere with œá = 2, you could have:</p>
            <ul style="margin-left: 30px; line-height: 2;">
                <li>Two sources (1 + 1 = 2)</li>
                <li>Two sinks (1 + 1 = 2)</li>
                <li>One source + one sink (1 + 1 = 2)</li>
                <li>Four sources + two saddles (4 - 2 = 2)</li>
            </ul>
        </div>

        <div class="explanation-section">
            <h2>Real-World Applications</h2>

            <div class="wind-box">
                <h4>üåÄ There's ALWAYS a Cyclone on Earth</h4>
                <p>Model wind as a vector field tangent to Earth's surface. The Hairy Ball Theorem guarantees at least one point where wind velocity is zero ‚Äî the <strong>eye of a cyclone</strong>!</p>
                <p style="margin-top: 10px;">This doesn't mean a destructive hurricane ‚Äî it could be a gentle low-pressure system. But mathematically, there must always be <strong>at least two</strong> such calm spots at any moment.</p>
            </div>

            <div class="application-grid">
                <div class="app-card">
                    <h4>üñ•Ô∏è Computer Graphics</h4>
                    <p>No single continuous function can generate a perpendicular vector for every input in 3D. Graphics engines must handle edge cases!</p>
                </div>
                <div class="app-card">
                    <h4>üì° Antenna Design</h4>
                    <p>A perfectly omnidirectional antenna is impossible. The signal must have a null point somewhere ‚Äî you can't broadcast equally in all directions.</p>
                </div>
                <div class="app-card">
                    <h4>üî¨ Nanotechnology</h4>
                    <p>Molecules on spherical nanoparticles must "stick up" at poles, creating reactive hotspots useful for chemical bonding.</p>
                </div>
                <div class="app-card">
                    <h4>üèÄ Spinning Objects</h4>
                    <p>Spin a basketball ‚Äî there's always at least one point on its surface with zero velocity (the poles of rotation).</p>
                </div>
            </div>

            <div class="key-insight">
                <h4>The Deep Truth</h4>
                <p>The Hairy Ball Theorem reveals that <strong>topology constrains physics</strong>. The shape of a surface ‚Äî not its size or material ‚Äî determines what's possible. A sphere's "two-ness" (œá = 2) forces cowlicks into existence. The universe's rules emerge from pure geometry.</p>
            </div>

            <h3>Historical Note</h3>
            <p>The theorem was first proven by <strong>Henri Poincar√©</strong> in 1885 for the 2-sphere, and generalized by <strong>L.E.J. Brouwer</strong> in 1912 to all even-dimensional spheres. It's also called the "hedgehog theorem" in some European countries.</p>
        </div>
    </div>

    <script>
        // Main sphere canvas
        const canvas = document.getElementById('sphereCanvas');
        const ctx = canvas.getContext('2d');

        // State
        let rotationX = 0.3;
        let rotationY = 0;
        let autoRotate = false;
        let isDragging = false;
        let lastMouseX, lastMouseY;
        let hairDensity = 150;
        let hairLength = 25;
        let combingPhase = 0;
        let isCombing = false;

        // Generate points on sphere using fibonacci lattice
        function fibonacciSphere(n) {
            const points = [];
            const phi = Math.PI * (3 - Math.sqrt(5)); // golden angle

            for (let i = 0; i < n; i++) {
                const y = 1 - (i / (n - 1)) * 2;
                const radius = Math.sqrt(1 - y * y);
                const theta = phi * i;

                points.push({
                    x: Math.cos(theta) * radius,
                    y: y,
                    z: Math.sin(theta) * radius
                });
            }
            return points;
        }

        // Rotate point
        function rotatePoint(p, rx, ry) {
            // Rotate around Y axis
            let x = p.x * Math.cos(ry) - p.z * Math.sin(ry);
            let z = p.x * Math.sin(ry) + p.z * Math.cos(ry);

            // Rotate around X axis
            let y = p.y * Math.cos(rx) - z * Math.sin(rx);
            z = p.y * Math.sin(rx) + z * Math.cos(rx);

            return { x, y, z };
        }

        // Get hair direction based on combing pattern
        function getHairDirection(point, phase) {
            // Try to comb toward equator (creates two polar cowlicks)
            const lat = Math.asin(point.y);
            const lon = Math.atan2(point.z, point.x);

            // Interpolate between random and "combed" state
            const t = Math.min(phase, 1);

            // Target: flow around the equator
            const targetX = -Math.sin(lon) * (1 - Math.abs(point.y) * 0.9);
            const targetY = -point.y * 0.1; // slight pull toward equator
            const targetZ = Math.cos(lon) * (1 - Math.abs(point.y) * 0.9);

            // Random initial direction (tangent to sphere)
            const randAngle = point.x * 3 + point.y * 5 + point.z * 7;
            const randX = Math.cos(randAngle) * (1 - point.y * point.y);
            const randY = 0;
            const randZ = Math.sin(randAngle) * (1 - point.y * point.y);

            return {
                x: randX * (1 - t) + targetX * t,
                y: randY * (1 - t) + targetY * t,
                z: randZ * (1 - t) + targetZ * t
            };
        }

        // Project 3D to 2D
        function project(p, scale = 180) {
            const perspective = 4;
            const factor = perspective / (perspective + p.z);
            return {
                x: canvas.width / 2 + p.x * scale * factor,
                y: canvas.height / 2 - p.y * scale * factor,
                z: p.z,
                scale: factor
            };
        }

        // Draw sphere with hair
        function drawSphere() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw sphere surface (gradient)
            const gradient = ctx.createRadialGradient(
                canvas.width/2 - 50, canvas.height/2 - 50, 10,
                canvas.width/2, canvas.height/2, 200
            );
            gradient.addColorStop(0, 'rgba(100,100,150,0.3)');
            gradient.addColorStop(1, 'rgba(30,30,60,0.1)');

            ctx.beginPath();
            ctx.arc(canvas.width/2, canvas.height/2, 180, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,107,157,0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Generate and draw hair
            const points = fibonacciSphere(hairDensity);
            const hairs = [];

            points.forEach(p => {
                const rotated = rotatePoint(p, rotationX, rotationY);
                const projected = project(rotated);

                // Only draw front-facing hair
                if (rotated.z > -0.3) {
                    const dir = getHairDirection(p, combingPhase);
                    const rotatedDir = rotatePoint(dir, rotationX, rotationY);

                    // Normalize and scale direction
                    const len = Math.sqrt(rotatedDir.x**2 + rotatedDir.y**2 + rotatedDir.z**2) || 1;
                    const normalizedDir = {
                        x: rotatedDir.x / len,
                        y: rotatedDir.y / len,
                        z: rotatedDir.z / len
                    };

                    hairs.push({
                        x: projected.x,
                        y: projected.y,
                        z: rotated.z,
                        dx: normalizedDir.x * hairLength * projected.scale,
                        dy: -normalizedDir.y * hairLength * projected.scale,
                        scale: projected.scale,
                        isCowlick: Math.abs(p.y) > 0.95 && combingPhase > 0.5
                    });
                }
            });

            // Sort by z for proper layering
            hairs.sort((a, b) => a.z - b.z);

            // Draw hairs
            hairs.forEach(hair => {
                const alpha = 0.3 + hair.z * 0.4;

                ctx.beginPath();
                ctx.moveTo(hair.x, hair.y);
                ctx.lineTo(hair.x + hair.dx, hair.y + hair.dy);

                if (hair.isCowlick) {
                    ctx.strokeStyle = `rgba(231,76,60,${alpha + 0.3})`;
                    ctx.lineWidth = 3;
                } else {
                    ctx.strokeStyle = `rgba(255,200,100,${alpha})`;
                    ctx.lineWidth = 1.5 * hair.scale;
                }
                ctx.stroke();

                // Hair tip
                ctx.beginPath();
                ctx.arc(hair.x + hair.dx, hair.y + hair.dy, hair.isCowlick ? 3 : 1.5, 0, Math.PI * 2);
                ctx.fillStyle = hair.isCowlick ? '#e74c3c' : `rgba(255,150,50,${alpha})`;
                ctx.fill();
            });

            // Draw cowlick markers at poles when combed
            if (combingPhase > 0.5) {
                // North pole
                const northPole = rotatePoint({x: 0, y: 1, z: 0}, rotationX, rotationY);
                if (northPole.z > -0.5) {
                    const np = project(northPole);
                    ctx.beginPath();
                    ctx.arc(np.x, np.y, 15, 0, Math.PI * 2);
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(231,76,60,0.3)';
                    ctx.fill();
                }

                // South pole
                const southPole = rotatePoint({x: 0, y: -1, z: 0}, rotationX, rotationY);
                if (southPole.z > -0.5) {
                    const sp = project(southPole);
                    ctx.beginPath();
                    ctx.arc(sp.x, sp.y, 15, 0, Math.PI * 2);
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(231,76,60,0.3)';
                    ctx.fill();
                }
            }

            // Label
            ctx.fillStyle = '#ff6b9d';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(combingPhase > 0.5 ? 'Combed (but cowlicks remain!)' : 'Uncombed', canvas.width/2, 30);
        }

        // Animation loop
        function animate() {
            if (autoRotate) {
                rotationY += 0.01;
            }

            if (isCombing && combingPhase < 1) {
                combingPhase += 0.02;
                if (combingPhase >= 1) {
                    combingPhase = 1;
                    isCombing = false;
                }
            }

            drawSphere();
            requestAnimationFrame(animate);
        }

        // Mini sphere
        function drawMiniSphere() {
            const miniCanvas = document.getElementById('miniSphere');
            const miniCtx = miniCanvas.getContext('2d');
            miniCtx.clearRect(0, 0, 200, 200);

            // Sphere
            const gradient = miniCtx.createRadialGradient(80, 80, 10, 100, 100, 80);
            gradient.addColorStop(0, 'rgba(150,100,100,0.5)');
            gradient.addColorStop(1, 'rgba(60,30,30,0.3)');

            miniCtx.beginPath();
            miniCtx.arc(100, 100, 70, 0, Math.PI * 2);
            miniCtx.fillStyle = gradient;
            miniCtx.fill();
            miniCtx.strokeStyle = '#e74c3c';
            miniCtx.lineWidth = 2;
            miniCtx.stroke();

            // Draw some hair with cowlicks
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                const r = 65;
                const x = 100 + Math.cos(angle) * r * 0.9;
                const y = 100 + Math.sin(angle) * r * 0.9;

                // Hair direction (circular flow)
                const dx = -Math.sin(angle) * 15;
                const dy = Math.cos(angle) * 15;

                miniCtx.beginPath();
                miniCtx.moveTo(x, y);
                miniCtx.lineTo(x + dx, y + dy);
                miniCtx.strokeStyle = 'rgba(255,150,100,0.7)';
                miniCtx.lineWidth = 2;
                miniCtx.stroke();
            }

            // Cowlicks at poles
            miniCtx.fillStyle = '#e74c3c';
            miniCtx.beginPath();
            miniCtx.arc(100, 35, 8, 0, Math.PI * 2);
            miniCtx.fill();
            miniCtx.beginPath();
            miniCtx.arc(100, 165, 8, 0, Math.PI * 2);
            miniCtx.fill();
        }

        // Mini torus
        function drawMiniTorus() {
            const torusCanvas = document.getElementById('miniTorus');
            const torusCtx = torusCanvas.getContext('2d');
            torusCtx.clearRect(0, 0, 200, 200);

            // Simple torus representation
            const cx = 100, cy = 100;
            const R = 50, r = 20;

            // Outer ellipse
            torusCtx.beginPath();
            torusCtx.ellipse(cx, cy, R + r, (R + r) * 0.5, 0, 0, Math.PI * 2);
            torusCtx.strokeStyle = '#2ecc71';
            torusCtx.lineWidth = 2;
            torusCtx.stroke();

            // Inner ellipse (hole)
            torusCtx.beginPath();
            torusCtx.ellipse(cx, cy, R - r, (R - r) * 0.5, 0, 0, Math.PI * 2);
            torusCtx.stroke();

            // Fill donut shape
            torusCtx.fillStyle = 'rgba(46,204,113,0.2)';
            torusCtx.beginPath();
            torusCtx.ellipse(cx, cy, R + r, (R + r) * 0.5, 0, 0, Math.PI * 2);
            torusCtx.fill();

            // Draw hair flowing around (no cowlicks!)
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const x = cx + Math.cos(angle) * R;
                const y = cy + Math.sin(angle) * R * 0.5;

                const dx = Math.cos(angle + Math.PI/2) * 12;
                const dy = Math.sin(angle + Math.PI/2) * 6;

                torusCtx.beginPath();
                torusCtx.moveTo(x, y);
                torusCtx.lineTo(x + dx, y + dy);
                torusCtx.strokeStyle = 'rgba(100,255,150,0.7)';
                torusCtx.lineWidth = 2;
                torusCtx.stroke();
            }

            torusCtx.fillStyle = '#2ecc71';
            torusCtx.font = '12px sans-serif';
            torusCtx.textAlign = 'center';
            torusCtx.fillText('No cowlicks needed!', cx, 190);
        }

        // Event listeners
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                rotationY += dx * 0.01;
                rotationX += dy * 0.01;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => isDragging = false);

        document.getElementById('combBtn').addEventListener('click', () => {
            isCombing = true;
        });

        document.getElementById('rotateBtn').addEventListener('click', (e) => {
            autoRotate = !autoRotate;
            e.target.classList.toggle('active', autoRotate);
            e.target.textContent = autoRotate ? 'Stop Rotation' : 'Auto Rotate';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            combingPhase = 0;
            rotationX = 0.3;
            rotationY = 0;
            autoRotate = false;
            document.getElementById('rotateBtn').classList.remove('active');
            document.getElementById('rotateBtn').textContent = 'Auto Rotate';
        });

        document.getElementById('densitySlider').addEventListener('input', (e) => {
            hairDensity = parseInt(e.target.value);
        });

        document.getElementById('lengthSlider').addEventListener('input', (e) => {
            hairLength = parseInt(e.target.value);
        });

        // Initialize
        drawMiniSphere();
        drawMiniTorus();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
