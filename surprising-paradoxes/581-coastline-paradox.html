<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Coastline Paradox - Why Coastlines Have Infinite Length</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a1628 0%, #1a3a5c 50%, #0d2840 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 0;
        }

        h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, #4ecdc4, #44a08d, #093028);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #7fb3d5;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            margin-top: 20px;
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(78, 205, 196, 0.2);
        }

        canvas {
            display: block;
            width: 100%;
            background: linear-gradient(180deg, #1a3a5c 0%, #0d2840 100%);
            border-radius: 10px;
        }

        .controls {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(78, 205, 196, 0.2);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: #4ecdc4;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #4ecdc4;
            border-radius: 50%;
            cursor: pointer;
        }

        .value-display {
            min-width: 60px;
            text-align: right;
            color: #4ecdc4;
            font-family: monospace;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        button {
            padding: 12px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .preset-btn {
            background: linear-gradient(135deg, #1a3a5c, #2a4a6c);
            color: #e0e0e0;
            border: 1px solid rgba(78, 205, 196, 0.3);
        }

        .preset-btn:hover {
            background: linear-gradient(135deg, #2a4a6c, #3a5a7c);
            border-color: #4ecdc4;
        }

        .preset-btn.active {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: #000;
        }

        .stats {
            background: rgba(78, 205, 196, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(78, 205, 196, 0.1);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #7fb3d5;
        }

        .stat-value {
            color: #4ecdc4;
            font-family: monospace;
        }

        .length-display {
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.2), rgba(68, 160, 141, 0.2));
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            text-align: center;
        }

        .length-title {
            color: #7fb3d5;
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .length-value {
            font-size: 2rem;
            font-weight: 700;
            color: #4ecdc4;
            font-family: monospace;
        }

        .length-unit {
            font-size: 1rem;
            color: #7fb3d5;
        }

        .formula-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            border-left: 3px solid #44a08d;
        }

        .formula-title {
            color: #44a08d;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .formula {
            font-family: 'Times New Roman', serif;
            font-size: 1.1rem;
            color: #fff;
            text-align: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }

        .explanation {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .exp-card {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(78, 205, 196, 0.2);
        }

        .exp-card h3 {
            color: #4ecdc4;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .exp-card p {
            line-height: 1.7;
            color: #aaccdd;
        }

        .highlight {
            color: #4ecdc4;
            font-weight: 500;
        }

        .back-link {
            display: inline-block;
            color: #4ecdc4;
            text-decoration: none;
            margin-bottom: 20px;
            transition: transform 0.3s;
        }

        .back-link:hover {
            transform: translateX(-5px);
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

        <header>
            <h1>The Coastline Paradox</h1>
            <p class="subtitle">The shorter your ruler, the longer the coast‚Äîto infinity!</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="coastCanvas" width="800" height="600"></canvas>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Ruler Length: <span id="rulerDisplay">50</span> km</label>
                    <div class="slider-container">
                        <input type="range" id="rulerSlider" min="5" max="200" value="50">
                    </div>
                </div>

                <div class="control-group">
                    <label>Coastline Roughness (Fractal Dimension)</label>
                    <div class="slider-container">
                        <input type="range" id="roughnessSlider" min="100" max="150" value="125">
                        <span class="value-display" id="roughnessValue">D=1.25</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Coastline Type</label>
                    <div class="preset-buttons">
                        <button class="preset-btn active" data-coast="britain">Britain (D‚âà1.25)</button>
                        <button class="preset-btn" data-coast="norway">Norway (D‚âà1.52)</button>
                        <button class="preset-btn" data-coast="africa">S. Africa (D‚âà1.02)</button>
                        <button class="preset-btn" data-coast="australia">Australia (D‚âà1.13)</button>
                    </div>
                </div>

                <div class="length-display">
                    <div class="length-title">Measured Coastline Length</div>
                    <div class="length-value" id="coastLength">0</div>
                    <div class="length-unit">km</div>
                </div>

                <div class="stats">
                    <div class="stat-row">
                        <span class="stat-label">Ruler Segments Used</span>
                        <span class="stat-value" id="segmentCount">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Fractal Dimension D</span>
                        <span class="stat-value" id="fractalDim">1.25</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">% Increase from 200km ruler</span>
                        <span class="stat-value" id="percentIncrease">0%</span>
                    </div>
                </div>

                <div class="formula-box">
                    <div class="formula-title">Richardson's Formula (1961)</div>
                    <div class="formula">L(Œµ) = F √ó Œµ<sup>(1-D)</sup></div>
                    <p style="font-size: 0.85rem; color: #7fb3d5; margin-top: 10px; text-align: center;">
                        L = length, Œµ = ruler size, D = fractal dimension
                    </p>
                </div>
            </div>
        </div>

        <div class="explanation">
            <div class="exp-card">
                <h3>üèùÔ∏è The Paradox</h3>
                <p>
                    How long is Britain's coast? It depends on your <span class="highlight">ruler</span>!
                    Use 200km segments: ~2,400km. Use 50km: ~3,400km. Use 1km: ~8,000km+.
                    As ruler ‚Üí 0, length ‚Üí <span class="highlight">infinity</span>! Every bay contains
                    smaller bays, every rock smaller pebbles‚Äîdetail at every scale.
                </p>
            </div>

            <div class="exp-card">
                <h3>üìè Richardson's Discovery</h3>
                <p>
                    Lewis Richardson (1950s) found this while studying <span class="highlight">border
                    lengths</span> and war probability. Different maps gave wildly different answers!
                    He discovered measured length follows a power law: L ‚àù Œµ^(1-D). The exponent D
                    became the "fractal dimension"‚Äîa measure of coastline wiggliness.
                </p>
            </div>

            <div class="exp-card">
                <h3>üåÄ Mandelbrot's Fractals</h3>
                <p>
                    In 1967, Benoit Mandelbrot asked <span class="highlight">"How Long Is the Coast
                    of Britain?"</span>‚Äîand invented fractal geometry to answer it. Coastlines have
                    dimension between 1 (line) and 2 (surface). Norway's fjords (D‚âà1.52) are "more
                    fractal" than South Africa's smooth coast (D‚âà1.02).
                </p>
            </div>

            <div class="exp-card">
                <h3>üó∫Ô∏è Real-World Implications</h3>
                <p>
                    This isn't just theory! <span class="highlight">Official coastline lengths vary
                    wildly</span> between sources. The CIA Factbook says Norway's coast is 25,148km;
                    Norway's own statistics say 100,915km! Neither is "wrong"‚Äîthey just used different
                    measurement scales. The concept underlies all of fractal science.
                </p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('coastCanvas');
        const ctx = canvas.getContext('2d');

        // High DPI support
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        const W = rect.width;
        const H = rect.height;

        let fractalDimension = 1.25;
        let rulerLength = 50;
        let coastlinePoints = [];
        let baseLength = 800; // Reference length

        // Generate fractal coastline using midpoint displacement
        function generateCoastline(roughness, iterations = 10) {
            const points = [];
            const startX = 50;
            const endX = W - 50;
            const baseY = H * 0.6;

            // Start with simple line
            points.push({ x: startX, y: baseY });
            points.push({ x: endX, y: baseY });

            // Midpoint displacement
            for (let iter = 0; iter < iterations; iter++) {
                const newPoints = [points[0]];
                const displacement = (roughness - 1) * 80 / Math.pow(2, iter * 0.5);

                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];

                    // Midpoint with random displacement
                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2 + (Math.random() - 0.5) * displacement;

                    newPoints.push({ x: midX, y: Math.max(H * 0.2, Math.min(H * 0.85, midY)) });
                    newPoints.push(p2);
                }
                points.length = 0;
                points.push(...newPoints);
            }

            return points;
        }

        // Measure coastline with given ruler length
        function measureCoastline(points, rulerPx) {
            if (points.length < 2) return { length: 0, segments: 0 };

            let totalLength = 0;
            let segments = 0;
            let currentIdx = 0;
            const measurementPoints = [points[0]];

            while (currentIdx < points.length - 1) {
                // Find the farthest point within ruler distance
                let bestIdx = currentIdx + 1;
                let bestDist = 0;

                for (let i = currentIdx + 1; i < points.length; i++) {
                    const dx = points[i].x - points[currentIdx].x;
                    const dy = points[i].y - points[currentIdx].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist <= rulerPx && dist > bestDist) {
                        bestIdx = i;
                        bestDist = dist;
                    } else if (dist > rulerPx) {
                        break;
                    }
                }

                if (bestDist > 0) {
                    totalLength += bestDist;
                    segments++;
                    measurementPoints.push(points[bestIdx]);
                    currentIdx = bestIdx;
                } else {
                    // Step forward if no point found
                    currentIdx++;
                }
            }

            return { length: totalLength, segments, measurementPoints };
        }

        // Calculate baseline length at max ruler
        function getBaselineLength() {
            const maxRuler = 200 * (W - 100) / 800; // Scale to canvas
            const result = measureCoastline(coastlinePoints, maxRuler);
            return result.length;
        }

        // Draw everything
        function draw() {
            // Background gradient (ocean and land)
            const gradient = ctx.createLinearGradient(0, 0, 0, H);
            gradient.addColorStop(0, '#1a3a5c');
            gradient.addColorStop(0.5, '#0d2840');
            gradient.addColorStop(1, '#093028');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, W, H);

            // Draw land (below coastline)
            ctx.fillStyle = '#2d5a27';
            ctx.beginPath();
            ctx.moveTo(0, H);
            ctx.lineTo(coastlinePoints[0].x, coastlinePoints[0].y);
            for (const p of coastlinePoints) {
                ctx.lineTo(p.x, p.y);
            }
            ctx.lineTo(W, H);
            ctx.closePath();
            ctx.fill();

            // Draw coastline
            ctx.strokeStyle = '#f4d03f';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(coastlinePoints[0].x, coastlinePoints[0].y);
            for (let i = 1; i < coastlinePoints.length; i++) {
                ctx.lineTo(coastlinePoints[i].x, coastlinePoints[i].y);
            }
            ctx.stroke();

            // Measure with current ruler
            const rulerPx = rulerLength * (W - 100) / 800;
            const result = measureCoastline(coastlinePoints, rulerPx);

            // Draw measurement line
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            if (result.measurementPoints.length > 0) {
                ctx.moveTo(result.measurementPoints[0].x, result.measurementPoints[0].y);
                for (let i = 1; i < result.measurementPoints.length; i++) {
                    ctx.lineTo(result.measurementPoints[i].x, result.measurementPoints[i].y);
                }
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw measurement points
            ctx.fillStyle = '#ff6b6b';
            for (const p of result.measurementPoints) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw ruler reference
            ctx.fillStyle = '#fff';
            ctx.font = '14px sans-serif';
            ctx.fillText(`Ruler: ${rulerLength} km`, 60, 30);

            // Draw ruler scale
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(60, 45);
            ctx.lineTo(60 + rulerPx, 45);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#7fb3d5';
            ctx.font = '12px sans-serif';
            ctx.fillText('OCEAN', W / 2 - 25, 80);
            ctx.fillStyle = '#8fbc8f';
            ctx.fillText('LAND', W / 2 - 20, H - 30);

            // Update stats
            const scaledLength = result.length * 800 / (W - 100); // Scale to km
            document.getElementById('coastLength').textContent = Math.round(scaledLength).toLocaleString();
            document.getElementById('segmentCount').textContent = result.segments.toLocaleString();
            document.getElementById('fractalDim').textContent = fractalDimension.toFixed(2);

            // Calculate % increase from baseline
            const baseline = getBaselineLength() * 800 / (W - 100);
            const increase = ((scaledLength - baseline) / baseline * 100);
            document.getElementById('percentIncrease').textContent =
                (increase > 0 ? '+' : '') + increase.toFixed(1) + '%';
        }

        // Regenerate coastline
        function regenerate() {
            coastlinePoints = generateCoastline(fractalDimension);
            draw();
        }

        // Event listeners
        document.getElementById('rulerSlider').addEventListener('input', (e) => {
            rulerLength = parseInt(e.target.value);
            document.getElementById('rulerDisplay').textContent = rulerLength;
            draw();
        });

        document.getElementById('roughnessSlider').addEventListener('input', (e) => {
            fractalDimension = parseInt(e.target.value) / 100;
            document.getElementById('roughnessValue').textContent = 'D=' + fractalDimension.toFixed(2);
            regenerate();
        });

        document.querySelectorAll('.preset-btn[data-coast]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.preset-btn[data-coast]').forEach(b =>
                    b.classList.remove('active'));
                btn.classList.add('active');

                const dims = {
                    britain: 1.25,
                    norway: 1.52,
                    africa: 1.02,
                    australia: 1.13
                };
                fractalDimension = dims[btn.dataset.coast];
                document.getElementById('roughnessSlider').value = fractalDimension * 100;
                document.getElementById('roughnessValue').textContent = 'D=' + fractalDimension.toFixed(2);
                regenerate();
            });
        });

        // Initial render
        regenerate();
    </script>
</body>
</html>
