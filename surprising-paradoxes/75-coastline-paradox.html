<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Coastline Paradox - Infinite Length</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --ocean-deep: #1a3a52;
            --ocean-light: #3498db;
            --sand: #f4d03f;
            --land-green: #27ae60;
            --land-dark: #1e8449;
            --cream: #FEFAE0;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, var(--ocean-deep) 0%, #0a1628 50%, #0d2137 100%);
            min-height: 100vh;
            color: #ecf0f1;
            overflow-x: hidden;
        }

        /* Ocean waves background */
        .ocean-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                repeating-linear-gradient(
                    0deg,
                    transparent 0px,
                    transparent 40px,
                    rgba(52, 152, 219, 0.05) 40px,
                    rgba(52, 152, 219, 0.05) 41px
                );
            z-index: 0;
        }

        .wave {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 200%;
            height: 100px;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1440 320'%3E%3Cpath fill='%231a3a52' fill-opacity='0.3' d='M0,160L48,170.7C96,181,192,203,288,186.7C384,171,480,117,576,117.3C672,117,768,171,864,181.3C960,192,1056,160,1152,144C1248,128,1344,128,1392,128L1440,128L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z'%3E%3C/path%3E%3C/svg%3E") repeat-x;
            animation: wave 15s linear infinite;
            z-index: 1;
        }

        @keyframes wave {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 18px;
            background: rgba(52, 152, 219, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 30px;
            color: var(--ocean-light);
            text-decoration: none;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .organic-back-link:hover {
            background: rgba(52, 152, 219, 0.4);
            transform: translateX(-3px);
        }

        .container {
            position: relative;
            z-index: 10;
            max-width: 1100px;
            margin: 0 auto;
            padding: 80px 20px 40px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-family: 'Lora', serif;
            font-size: 2.8rem;
            background: linear-gradient(135deg, var(--ocean-light), var(--sand));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .header .subtitle {
            font-size: 1.2rem;
            color: #bdc3c7;
        }

        .question-box {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.2), rgba(39, 174, 96, 0.2));
            border: 2px solid var(--ocean-light);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 30px;
            text-align: center;
        }

        .question-box h2 {
            font-family: 'Lora', serif;
            color: var(--ocean-light);
            margin-bottom: 15px;
        }

        .question-box p {
            font-size: 1.2rem;
            color: #ecf0f1;
            line-height: 1.6;
        }

        .main-panel {
            background: rgba(26, 58, 82, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .main-panel h2 {
            font-family: 'Lora', serif;
            color: var(--ocean-light);
            margin-bottom: 20px;
            text-align: center;
        }

        .visualization-area {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }

        @media (max-width: 800px) {
            .visualization-area {
                grid-template-columns: 1fr;
            }
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 10px;
            position: relative;
        }

        canvas {
            width: 100%;
            height: 400px;
            border-radius: 10px;
        }

        .ruler-indicator {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ruler-bar {
            height: 4px;
            background: var(--sand);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .stats-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--sand);
        }

        .stat-label {
            font-size: 0.85rem;
            color: #bdc3c7;
            margin-top: 5px;
        }

        .controls {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .slider-container {
            margin-bottom: 15px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            color: #bdc3c7;
        }

        .slider-value {
            color: var(--sand);
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--ocean-light);
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .btn-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            flex: 1;
            min-width: 120px;
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--ocean-light), #2980b9);
            color: white;
        }

        .btn-primary:hover {
            transform: scale(1.02);
            box-shadow: 0 5px 20px rgba(52, 152, 219, 0.4);
        }

        .btn-secondary {
            background: rgba(52, 152, 219, 0.2);
            color: var(--ocean-light);
            border: 1px solid var(--ocean-light);
        }

        .graph-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .graph-container h3 {
            color: var(--ocean-light);
            margin-bottom: 15px;
            text-align: center;
        }

        .graph-canvas {
            width: 100%;
            height: 200px;
        }

        .explanation {
            background: rgba(26, 58, 82, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 20px;
            padding: 30px;
            margin-top: 30px;
        }

        .explanation h2 {
            font-family: 'Lora', serif;
            color: var(--ocean-light);
            margin-bottom: 20px;
        }

        .explanation p {
            line-height: 1.8;
            margin-bottom: 15px;
            color: #bdc3c7;
        }

        .highlight {
            color: var(--sand);
            font-weight: 600;
        }

        .paradox-box {
            background: linear-gradient(135deg, rgba(244, 208, 63, 0.2), rgba(52, 152, 219, 0.2));
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            border-left: 4px solid var(--sand);
        }

        .paradox-box h3 {
            color: var(--sand);
            margin-bottom: 10px;
        }

        .country-examples {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .country-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }

        .country-flag {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .country-name {
            color: var(--ocean-light);
            font-weight: 600;
        }

        .country-dim {
            color: var(--sand);
            font-size: 1.2rem;
            font-weight: bold;
        }

        .country-desc {
            font-size: 0.8rem;
            color: #bdc3c7;
            margin-top: 5px;
        }

        .timeline {
            position: relative;
            padding-left: 30px;
            margin: 30px 0;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--ocean-light);
        }

        .timeline-item {
            position: relative;
            margin-bottom: 20px;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -26px;
            top: 5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--ocean-light);
        }

        .timeline-year {
            color: var(--sand);
            font-weight: bold;
        }

        .insight-box {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.2), rgba(52, 152, 219, 0.2));
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            border-left: 4px solid var(--land-green);
        }

        .insight-box h3 {
            color: var(--land-green);
            margin-bottom: 10px;
        }

        .formula-box {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
        }

        .formula {
            font-size: 1.3rem;
            color: var(--sand);
        }
    </style>
</head>
<body>
    <div class="ocean-bg"></div>
    <div class="wave"></div>

    <a href="index.html" class="organic-back-link">
        <span class="back-arrow">‚Üê</span>
        <span class="back-text">Gallery</span>
    </a>

    <div class="container">
        <header class="header">
            <h1>The Coastline Paradox</h1>
            <p class="subtitle">Why coastlines have no definite length</p>
        </header>

        <div class="question-box">
            <h2>üó∫Ô∏è How Long Is Britain's Coastline?</h2>
            <p>
                According to the CIA World Factbook: <strong>12,429 km</strong><br>
                According to the Ordnance Survey: <strong>17,820 km</strong><br>
                The difference? <strong>The ruler they used!</strong>
            </p>
        </div>

        <div class="main-panel">
            <h2>Interactive Coastline Measurement</h2>

            <div class="visualization-area">
                <div class="canvas-container">
                    <canvas id="coastlineCanvas"></canvas>
                    <div class="ruler-indicator">
                        <span>Ruler:</span>
                        <div class="ruler-bar" id="rulerBar" style="width: 50px;"></div>
                        <span id="rulerLength">50 units</span>
                    </div>
                </div>

                <div class="stats-panel">
                    <div class="stat-box">
                        <div class="stat-value" id="measuredLength">0</div>
                        <div class="stat-label">Measured Length</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="rulerCount">0</div>
                        <div class="stat-label">Rulers Used</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="detailLevel">Low</div>
                        <div class="stat-label">Detail Captured</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="fractalDim">~1.25</div>
                        <div class="stat-label">Fractal Dimension</div>
                    </div>
                </div>
            </div>

            <div class="controls">
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Ruler Length (measurement scale)</span>
                        <span class="slider-value" id="sliderValue">50 units</span>
                    </div>
                    <input type="range" id="rulerSlider" min="5" max="100" step="1" value="50">
                </div>

                <div class="slider-container">
                    <div class="slider-label">
                        <span>Coastline Complexity (fractal iterations)</span>
                        <span class="slider-value" id="complexityValue">4</span>
                    </div>
                    <input type="range" id="complexitySlider" min="1" max="7" step="1" value="4">
                </div>

                <div class="btn-row">
                    <button class="btn btn-primary" onclick="animateMeasurement()">Animate Measurement</button>
                    <button class="btn btn-secondary" onclick="compareScales()">Compare All Scales</button>
                </div>
            </div>

            <div class="graph-container">
                <h3>Length vs. Ruler Size (Log-Log Plot)</h3>
                <canvas id="graphCanvas" class="graph-canvas"></canvas>
                <p style="text-align: center; color: #bdc3c7; font-size: 0.9rem; margin-top: 10px;">
                    A straight line on log-log plot indicates fractal behavior. Slope = 1 - D (fractal dimension).
                </p>
            </div>
        </div>

        <div class="explanation">
            <h2>The Paradox of Infinite Coastlines</h2>

            <div class="paradox-box">
                <h3>The Discovery</h3>
                <p>
                    In the 1950s, mathematician <span class="highlight">Lewis Fry Richardson</span> was studying
                    whether countries with longer shared borders were more likely to go to war. He noticed something
                    strange: different sources gave wildly different lengths for the same borders!
                    <br><br>
                    The answer: <strong>it depends on how closely you measure.</strong>
                </p>
            </div>

            <p>
                When you measure a coastline with a long ruler, you skip over small bays and inlets.
                Use a shorter ruler, and you capture more detail‚Äîbut the total length <em>increases</em>.
                Use an even shorter ruler to measure around individual rocks, and it increases again!
            </p>

            <div class="formula-box">
                <div class="formula">L(Œµ) = F ¬∑ Œµ^(1-D)</div>
                <p style="color: #bdc3c7; margin-top: 10px;">
                    L = measured length, Œµ = ruler size, D = fractal dimension, F = constant
                </p>
            </div>

            <p>
                For a truly fractal coastline, as your ruler length approaches zero,
                the measured length approaches <span class="highlight">infinity</span>!
            </p>

            <h3 style="color: var(--ocean-light); margin: 30px 0 20px;">Fractal Dimensions of Real Coastlines</h3>

            <div class="country-examples">
                <div class="country-card">
                    <div class="country-flag">üáøüá¶</div>
                    <div class="country-name">South Africa</div>
                    <div class="country-dim">D ‚âà 1.02</div>
                    <div class="country-desc">Very smooth coast</div>
                </div>
                <div class="country-card">
                    <div class="country-flag">üá¨üáß</div>
                    <div class="country-name">Britain</div>
                    <div class="country-dim">D ‚âà 1.25</div>
                    <div class="country-desc">Moderately complex</div>
                </div>
                <div class="country-card">
                    <div class="country-flag">üá≥üá¥</div>
                    <div class="country-name">Norway</div>
                    <div class="country-dim">D ‚âà 1.52</div>
                    <div class="country-desc">Highly fractured fjords</div>
                </div>
                <div class="country-card">
                    <div class="country-flag">üèùÔ∏è</div>
                    <div class="country-name">Koch Snowflake</div>
                    <div class="country-dim">D = 1.26</div>
                    <div class="country-desc">Theoretical fractal</div>
                </div>
            </div>

            <h3 style="color: var(--ocean-light); margin: 30px 0 20px;">Historical Timeline</h3>

            <div class="timeline">
                <div class="timeline-item">
                    <span class="timeline-year">1951</span> - Richardson discovers the coastline measurement problem while studying causes of war
                </div>
                <div class="timeline-item">
                    <span class="timeline-year">1961</span> - Richardson's posthumous paper "The Problem of Contiguity" published
                </div>
                <div class="timeline-item">
                    <span class="timeline-year">1967</span> - Mandelbrot publishes "How Long Is the Coast of Britain?" formalizing fractal dimension
                </div>
                <div class="timeline-item">
                    <span class="timeline-year">1975</span> - Mandelbrot coins the term "fractal" and establishes fractal geometry
                </div>
            </div>

            <div class="insight-box">
                <h3>Why This Matters</h3>
                <p>
                    The coastline paradox reveals that <span class="highlight">measurement isn't always straightforward</span>.
                    Many natural phenomena‚Äîclouds, mountains, blood vessels, trees‚Äîexhibit fractal properties.
                    Their "size" depends on the scale at which you observe them.
                    <br><br>
                    This insight revolutionized mathematics, physics, and computer graphics. Fractal algorithms
                    now generate realistic terrain in video games and movies!
                </p>
            </div>

            <div class="paradox-box" style="border-left-color: var(--ocean-light);">
                <h3 style="color: var(--ocean-light);">The Philosophical Question</h3>
                <p>
                    Does Britain's coastline have a "true" length? In a sense, no‚Äîlength is not an intrinsic
                    property of fractal curves. The question "how long?" is incomplete without specifying
                    "measured with what ruler?" This challenges our intuitive notion that physical properties
                    should be well-defined.
                </p>
            </div>
        </div>
    </div>

    <script>
        const coastlineCanvas = document.getElementById('coastlineCanvas');
        const coastlineCtx = coastlineCanvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');

        let rulerLength = 50;
        let complexity = 4;
        let coastlinePoints = [];
        let measurements = [];

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;

            let rect = coastlineCanvas.parentElement.getBoundingClientRect();
            coastlineCanvas.width = rect.width * dpr;
            coastlineCanvas.height = 400 * dpr;
            coastlineCtx.scale(dpr, dpr);

            rect = graphCanvas.parentElement.getBoundingClientRect();
            graphCanvas.width = (rect.width - 40) * dpr;
            graphCanvas.height = 200 * dpr;
            graphCtx.scale(dpr, dpr);
        }

        // Generate Koch-like fractal coastline
        function generateCoastline(iterations) {
            const width = coastlineCanvas.width / (window.devicePixelRatio || 1);
            const height = 400;
            const margin = 50;

            // Start with a simple line
            let points = [
                { x: margin, y: height / 2 },
                { x: width - margin, y: height / 2 }
            ];

            for (let i = 0; i < iterations; i++) {
                const newPoints = [];
                for (let j = 0; j < points.length - 1; j++) {
                    const p1 = points[j];
                    const p2 = points[j + 1];

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const len = Math.sqrt(dx * dx + dy * dy);

                    // Add randomized Koch-like displacement
                    const third1 = { x: p1.x + dx / 3, y: p1.y + dy / 3 };
                    const third2 = { x: p1.x + 2 * dx / 3, y: p1.y + 2 * dy / 3 };

                    // Random perpendicular displacement
                    const perpX = -dy / len;
                    const perpY = dx / len;
                    const displacement = (Math.random() - 0.3) * len * 0.4;

                    const peak = {
                        x: (p1.x + p2.x) / 2 + perpX * displacement,
                        y: (p1.y + p2.y) / 2 + perpY * displacement
                    };

                    newPoints.push(p1, third1, peak, third2);
                }
                newPoints.push(points[points.length - 1]);
                points = newPoints;
            }

            return points;
        }

        // Measure coastline with given ruler length
        function measureCoastline(points, rulerLen) {
            let totalLength = 0;
            let rulerCount = 0;
            const measurementPoints = [points[0]];

            let currentPoint = points[0];
            let pointIndex = 1;

            while (pointIndex < points.length) {
                // Find next point that's at least rulerLen away
                let accumulated = 0;
                let lastPoint = currentPoint;

                while (pointIndex < points.length) {
                    const dx = points[pointIndex].x - lastPoint.x;
                    const dy = points[pointIndex].y - lastPoint.y;
                    const segLen = Math.sqrt(dx * dx + dy * dy);

                    if (accumulated + segLen >= rulerLen) {
                        // Interpolate to exact ruler length
                        const needed = rulerLen - accumulated;
                        const ratio = needed / segLen;
                        currentPoint = {
                            x: lastPoint.x + dx * ratio,
                            y: lastPoint.y + dy * ratio
                        };
                        measurementPoints.push(currentPoint);
                        totalLength += rulerLen;
                        rulerCount++;
                        break;
                    }

                    accumulated += segLen;
                    lastPoint = points[pointIndex];
                    pointIndex++;
                }

                if (pointIndex >= points.length) {
                    // Add remaining distance
                    const dx = points[points.length - 1].x - currentPoint.x;
                    const dy = points[points.length - 1].y - currentPoint.y;
                    totalLength += Math.sqrt(dx * dx + dy * dy);
                    measurementPoints.push(points[points.length - 1]);
                    break;
                }
            }

            return { length: totalLength, count: rulerCount, points: measurementPoints };
        }

        function drawCoastline() {
            const width = coastlineCanvas.width / (window.devicePixelRatio || 1);
            const height = 400;

            coastlineCtx.clearRect(0, 0, width, height);

            // Draw ocean
            coastlineCtx.fillStyle = 'rgba(52, 152, 219, 0.3)';
            coastlineCtx.fillRect(0, 0, width, height);

            // Draw land (above coastline)
            coastlineCtx.beginPath();
            coastlineCtx.moveTo(0, 0);
            coastlineCtx.lineTo(coastlinePoints[0].x, coastlinePoints[0].y);
            for (const point of coastlinePoints) {
                coastlineCtx.lineTo(point.x, point.y);
            }
            coastlineCtx.lineTo(width, coastlinePoints[coastlinePoints.length - 1].y);
            coastlineCtx.lineTo(width, 0);
            coastlineCtx.closePath();
            coastlineCtx.fillStyle = 'rgba(39, 174, 96, 0.6)';
            coastlineCtx.fill();

            // Draw coastline
            coastlineCtx.beginPath();
            coastlineCtx.moveTo(coastlinePoints[0].x, coastlinePoints[0].y);
            for (const point of coastlinePoints) {
                coastlineCtx.lineTo(point.x, point.y);
            }
            coastlineCtx.strokeStyle = '#f4d03f';
            coastlineCtx.lineWidth = 2;
            coastlineCtx.stroke();

            // Measure and draw ruler segments
            const measurement = measureCoastline(coastlinePoints, rulerLength);

            coastlineCtx.beginPath();
            coastlineCtx.moveTo(measurement.points[0].x, measurement.points[0].y);
            for (let i = 1; i < measurement.points.length; i++) {
                coastlineCtx.lineTo(measurement.points[i].x, measurement.points[i].y);
            }
            coastlineCtx.strokeStyle = '#e74c3c';
            coastlineCtx.lineWidth = 3;
            coastlineCtx.stroke();

            // Draw measurement points
            for (const point of measurement.points) {
                coastlineCtx.beginPath();
                coastlineCtx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                coastlineCtx.fillStyle = '#e74c3c';
                coastlineCtx.fill();
            }

            // Update stats
            document.getElementById('measuredLength').textContent = Math.round(measurement.length);
            document.getElementById('rulerCount').textContent = measurement.count;

            const detail = rulerLength > 50 ? 'Low' : rulerLength > 20 ? 'Medium' : rulerLength > 10 ? 'High' : 'Very High';
            document.getElementById('detailLevel').textContent = detail;

            return measurement;
        }

        function drawGraph() {
            const width = graphCanvas.width / (window.devicePixelRatio || 1);
            const height = 200;
            const padding = 40;

            graphCtx.clearRect(0, 0, width, height);

            // Axes
            graphCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            graphCtx.lineWidth = 1;
            graphCtx.beginPath();
            graphCtx.moveTo(padding, padding);
            graphCtx.lineTo(padding, height - padding);
            graphCtx.lineTo(width - padding, height - padding);
            graphCtx.stroke();

            // Labels
            graphCtx.fillStyle = '#bdc3c7';
            graphCtx.font = '12px Nunito';
            graphCtx.textAlign = 'center';
            graphCtx.fillText('log(Ruler Length)', width / 2, height - 10);
            graphCtx.save();
            graphCtx.translate(15, height / 2);
            graphCtx.rotate(-Math.PI / 2);
            graphCtx.fillText('log(Measured Length)', 0, 0);
            graphCtx.restore();

            if (measurements.length < 2) return;

            // Plot points
            const logRulers = measurements.map(m => Math.log(m.ruler));
            const logLengths = measurements.map(m => Math.log(m.length));

            const minLogR = Math.min(...logRulers);
            const maxLogR = Math.max(...logRulers);
            const minLogL = Math.min(...logLengths);
            const maxLogL = Math.max(...logLengths);

            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;

            coastlineCtx.beginPath();
            measurements.forEach((m, i) => {
                const x = padding + ((logRulers[i] - minLogR) / (maxLogR - minLogR || 1)) * chartWidth;
                const y = height - padding - ((logLengths[i] - minLogL) / (maxLogL - minLogL || 1)) * chartHeight;

                graphCtx.beginPath();
                graphCtx.arc(x, y, 5, 0, Math.PI * 2);
                graphCtx.fillStyle = '#f4d03f';
                graphCtx.fill();
            });

            // Draw trend line
            if (measurements.length >= 2) {
                const x1 = padding;
                const x2 = width - padding;
                const y1 = height - padding - chartHeight;
                const y2 = height - padding;

                graphCtx.beginPath();
                graphCtx.moveTo(x1, y1);
                graphCtx.lineTo(x2, y2);
                graphCtx.strokeStyle = 'rgba(231, 76, 60, 0.5)';
                graphCtx.lineWidth = 2;
                graphCtx.setLineDash([5, 5]);
                graphCtx.stroke();
                graphCtx.setLineDash([]);
            }
        }

        function updateVisualization() {
            coastlinePoints = generateCoastline(complexity);
            const measurement = drawCoastline();

            // Record measurement
            const existing = measurements.find(m => m.ruler === rulerLength);
            if (!existing) {
                measurements.push({ ruler: rulerLength, length: measurement.length });
                measurements.sort((a, b) => b.ruler - a.ruler);
            }

            drawGraph();

            // Update ruler indicator
            document.getElementById('rulerBar').style.width = rulerLength + 'px';
            document.getElementById('rulerLength').textContent = rulerLength + ' units';
        }

        function animateMeasurement() {
            measurements = [];
            let currentRuler = 100;

            const interval = setInterval(() => {
                rulerLength = currentRuler;
                document.getElementById('rulerSlider').value = currentRuler;
                document.getElementById('sliderValue').textContent = currentRuler + ' units';
                updateVisualization();

                currentRuler -= 5;
                if (currentRuler < 5) {
                    clearInterval(interval);
                }
            }, 200);
        }

        function compareScales() {
            measurements = [];
            for (let r = 100; r >= 5; r -= 5) {
                const m = measureCoastline(coastlinePoints, r);
                measurements.push({ ruler: r, length: m.length });
            }
            drawGraph();
        }

        // Event listeners
        document.getElementById('rulerSlider').addEventListener('input', (e) => {
            rulerLength = parseInt(e.target.value);
            document.getElementById('sliderValue').textContent = rulerLength + ' units';
            drawCoastline();
        });

        document.getElementById('complexitySlider').addEventListener('input', (e) => {
            complexity = parseInt(e.target.value);
            document.getElementById('complexityValue').textContent = complexity;
            measurements = [];
            updateVisualization();
        });

        window.addEventListener('resize', () => {
            resizeCanvas();
            updateVisualization();
        });

        // Initialize
        resizeCanvas();
        updateVisualization();
    </script>
</body>
</html>
