<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Zeigarnik Effect - Surprising Paradoxes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e0e0e0;
            line-height: 1.8;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        header {
            text-align: center;
            margin-bottom: 50px;
        }

        h1 {
            font-size: 2.8em;
            color: #e94560;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(233, 69, 96, 0.3);
        }

        .subtitle {
            font-size: 1.3em;
            color: #0f9b8e;
            font-style: italic;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 30px;
            color: #0f9b8e;
            text-decoration: none;
            font-size: 1.1em;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: #e94560;
        }

        .intro-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 40px;
            border-left: 4px solid #e94560;
        }

        .intro-section p {
            font-size: 1.15em;
            margin-bottom: 15px;
        }

        .waiter-story {
            background: linear-gradient(135deg, rgba(15, 155, 142, 0.15), rgba(233, 69, 96, 0.1));
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            border: 1px solid rgba(15, 155, 142, 0.3);
        }

        .waiter-story h3 {
            color: #0f9b8e;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .experiment-section {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 35px;
            margin-bottom: 40px;
        }

        .experiment-section h2 {
            color: #e94560;
            margin-bottom: 25px;
            font-size: 1.8em;
            text-align: center;
        }

        .task-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin: 25px 0;
        }

        .task-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
            position: relative;
            overflow: hidden;
        }

        .task-card:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-3px);
        }

        .task-card.completed {
            border-color: #4ade80;
            background: rgba(74, 222, 128, 0.15);
        }

        .task-card.interrupted {
            border-color: #f59e0b;
            background: rgba(245, 158, 11, 0.15);
        }

        .task-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .task-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .task-name {
            color: #fff;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .task-status {
            font-size: 0.85em;
            color: #888;
        }

        .progress-bar-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            height: 10px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #0f9b8e, #4ade80);
            border-radius: 10px;
            transition: width 0.3s;
        }

        .progress-bar.interrupted {
            background: linear-gradient(90deg, #f59e0b, #fbbf24);
        }

        .phase-indicator {
            text-align: center;
            padding: 20px;
            background: rgba(233, 69, 96, 0.1);
            border-radius: 10px;
            margin-bottom: 25px;
        }

        .phase-indicator h3 {
            color: #e94560;
            margin-bottom: 10px;
        }

        .phase-indicator p {
            font-size: 1.1em;
        }

        .btn {
            background: linear-gradient(135deg, #e94560, #d63353);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.1em;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-block;
            margin: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(233, 69, 96, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #0f9b8e, #0d8a7d);
        }

        .btn-secondary:hover {
            box-shadow: 0 10px 30px rgba(15, 155, 142, 0.4);
        }

        .recall-section {
            display: none;
        }

        .recall-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 25px 0;
        }

        .recall-input {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            color: white;
            font-size: 1em;
            width: 100%;
            transition: border-color 0.3s;
        }

        .recall-input:focus {
            outline: none;
            border-color: #0f9b8e;
        }

        .recall-input::placeholder {
            color: #888;
        }

        .results-section {
            display: none;
            text-align: center;
        }

        .results-chart {
            display: flex;
            justify-content: center;
            gap: 60px;
            margin: 40px 0;
        }

        .result-bar {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .bar-container {
            width: 80px;
            height: 200px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            display: flex;
            align-items: flex-end;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .bar-fill {
            width: 100%;
            transition: height 1s ease-out;
            border-radius: 10px;
        }

        .bar-fill.completed-bar {
            background: linear-gradient(to top, #4ade80, #22c55e);
        }

        .bar-fill.interrupted-bar {
            background: linear-gradient(to top, #f59e0b, #fbbf24);
        }

        .bar-label {
            font-size: 1.1em;
            font-weight: bold;
        }

        .bar-value {
            font-size: 2em;
            color: #e94560;
            margin-top: 10px;
        }

        .insight-box {
            background: linear-gradient(135deg, rgba(233, 69, 96, 0.2), rgba(15, 155, 142, 0.1));
            border-radius: 12px;
            padding: 25px;
            margin: 30px 0;
            border: 1px solid rgba(233, 69, 96, 0.3);
        }

        .insight-box h3 {
            color: #e94560;
            margin-bottom: 15px;
        }

        .stats-highlight {
            color: #fbbf24;
            font-weight: bold;
            font-size: 1.15em;
        }

        /* Progress Bar Demo */
        .progress-demo {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 35px;
            margin-bottom: 40px;
        }

        .progress-demo h2 {
            color: #e94560;
            margin-bottom: 25px;
            text-align: center;
        }

        .progress-examples {
            display: grid;
            gap: 25px;
        }

        .progress-example {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 20px;
        }

        .progress-example h4 {
            color: #0f9b8e;
            margin-bottom: 15px;
        }

        .large-progress {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            height: 30px;
            overflow: hidden;
            position: relative;
        }

        .large-progress-fill {
            height: 100%;
            border-radius: 15px;
            transition: width 0.5s;
            position: relative;
        }

        .large-progress-fill::after {
            content: attr(data-value);
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: white;
            font-weight: bold;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }

        .progress-1 {
            background: linear-gradient(90deg, #4ade80, #22c55e);
            width: 100%;
        }

        .progress-2 {
            background: linear-gradient(90deg, #e94560, #f87171);
            width: 73%;
        }

        .progress-3 {
            background: linear-gradient(90deg, #f59e0b, #fbbf24);
            width: 91%;
        }

        .urge-indicator {
            text-align: center;
            margin-top: 15px;
            font-size: 1.1em;
        }

        .urge-low { color: #4ade80; }
        .urge-medium { color: #fbbf24; }
        .urge-high { color: #e94560; }

        .applications-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 35px;
            margin-bottom: 40px;
        }

        .applications-section h2 {
            color: #e94560;
            margin-bottom: 25px;
            text-align: center;
        }

        .application-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .application-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 25px;
            border-left: 4px solid #0f9b8e;
        }

        .application-card h3 {
            color: #0f9b8e;
            margin-bottom: 12px;
            font-size: 1.2em;
        }

        .application-card p {
            color: #bbb;
            font-size: 0.95em;
        }

        .stat-callout {
            background: rgba(233, 69, 96, 0.2);
            padding: 8px 15px;
            border-radius: 8px;
            margin-top: 12px;
            font-size: 0.9em;
            color: #e94560;
        }

        .research-section {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            padding: 35px;
            margin-bottom: 40px;
        }

        .research-section h2 {
            color: #e94560;
            margin-bottom: 25px;
        }

        .research-section h3 {
            color: #0f9b8e;
            margin: 25px 0 15px;
        }

        .citation {
            font-style: italic;
            color: #888;
            font-size: 0.9em;
            border-left: 3px solid #0f9b8e;
            padding-left: 15px;
            margin: 15px 0;
        }

        .controversy-box {
            background: rgba(245, 158, 11, 0.15);
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }

        .controversy-box h4 {
            color: #f59e0b;
            margin-bottom: 10px;
        }

        .text-center {
            text-align: center;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @media (max-width: 768px) {
            h1 { font-size: 2em; }
            .container { padding: 20px 15px; }
            .results-chart { flex-direction: column; align-items: center; gap: 30px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Surprising Paradoxes</a>

        <header>
            <h1>üß© The Zeigarnik Effect</h1>
            <p class="subtitle">Why incomplete tasks haunt your memory</p>
        </header>

        <section class="intro-section">
            <p>
                <strong>Why can't you stop thinking about that unfinished project?</strong> Why do TV cliffhangers
                drive you crazy? Why does a half-complete progress bar feel like an itch you can't scratch?
            </p>
            <p>
                In 1927, Lithuanian-Soviet psychologist <strong>Bluma Zeigarnik</strong> discovered that we remember
                <span class="stats-highlight">incomplete tasks up to 90% better</span> than completed ones. Your brain
                treats unfinished business like an open tab‚Äîconsuming mental resources until it's closed.
            </p>

            <div class="waiter-story">
                <h3>üçΩÔ∏è The Waiter's Memory</h3>
                <p>
                    The discovery began in a Berlin restaurant. Gestalt psychologist <strong>Kurt Lewin</strong> noticed
                    something peculiar: their waiter could perfectly recall every detail of unpaid orders‚Äîbut the moment
                    a bill was settled, that information vanished from his mind. The transaction created closure,
                    releasing the mental tension that kept the memory alive.
                </p>
            </div>
        </section>

        <section class="experiment-section" id="taskPhase">
            <h2>üß™ Experience It Yourself: The Task Recall Experiment</h2>

            <div class="phase-indicator">
                <h3>Phase 1: Complete the Tasks</h3>
                <p>Click on each task to work on it. Some will complete fully‚Äîothers will be <strong>interrupted midway</strong>.</p>
            </div>

            <div class="task-grid" id="taskGrid">
                <!-- Tasks populated by JS -->
            </div>

            <div class="text-center">
                <p id="taskProgress" style="margin-bottom: 15px; color: #888;">Tasks processed: 0 / 8</p>
                <button class="btn" id="startRecallBtn" disabled>Begin Memory Test ‚Üí</button>
            </div>
        </section>

        <section class="experiment-section recall-section" id="recallPhase">
            <h2>üß† Phase 2: What Do You Remember?</h2>

            <div class="phase-indicator">
                <h3>Try to recall ALL the tasks you just worked on</h3>
                <p>Type as many task names as you can remember below. Don't worry about exact wording.</p>
            </div>

            <div class="recall-grid" id="recallGrid">
                <!-- Inputs populated by JS -->
            </div>

            <div class="text-center">
                <button class="btn" id="checkResultsBtn">Check My Memory ‚Üí</button>
            </div>
        </section>

        <section class="experiment-section results-section" id="resultsPhase">
            <h2>üìä Your Results</h2>

            <div class="results-chart">
                <div class="result-bar">
                    <div class="bar-container">
                        <div class="bar-fill completed-bar" id="completedBar"></div>
                    </div>
                    <div class="bar-label" style="color: #4ade80;">Completed Tasks</div>
                    <div class="bar-value" id="completedValue">0%</div>
                </div>
                <div class="result-bar">
                    <div class="bar-container">
                        <div class="bar-fill interrupted-bar" id="interruptedBar"></div>
                    </div>
                    <div class="bar-label" style="color: #f59e0b;">Interrupted Tasks</div>
                    <div class="bar-value" id="interruptedValue">0%</div>
                </div>
            </div>

            <div class="insight-box" id="insightBox">
                <!-- Dynamic insight -->
            </div>

            <div class="text-center">
                <button class="btn-secondary btn" onclick="resetExperiment()">Try Again</button>
            </div>
        </section>

        <section class="experiment-section" id="taskTrackingSection">
            <h2>Task Tracking: The Open Loop Simulator</h2>

            <div class="phase-indicator">
                <h3>Add tasks and watch your mental load grow</h3>
                <p>This interactive demo shows how incomplete tasks accumulate cognitive burden.</p>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin: 25px 0;">
                <div>
                    <h4 style="color: #0f9b8e; margin-bottom: 15px;">Add New Tasks</h4>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <input type="text" id="newTaskInput" class="recall-input" placeholder="Enter a task..." style="flex: 1;">
                        <button class="btn-secondary btn" style="padding: 10px 20px; margin: 0;" onclick="addTrackedTask()">Add</button>
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn" style="padding: 8px 15px; margin: 0; font-size: 0.85em; background: rgba(233, 69, 96, 0.3);" onclick="addQuickTask('Reply to email')">+ Email</button>
                        <button class="btn" style="padding: 8px 15px; margin: 0; font-size: 0.85em; background: rgba(233, 69, 96, 0.3);" onclick="addQuickTask('Finish report')">+ Report</button>
                        <button class="btn" style="padding: 8px 15px; margin: 0; font-size: 0.85em; background: rgba(233, 69, 96, 0.3);" onclick="addQuickTask('Call dentist')">+ Call</button>
                        <button class="btn" style="padding: 8px 15px; margin: 0; font-size: 0.85em; background: rgba(233, 69, 96, 0.3);" onclick="addQuickTask('Buy groceries')">+ Groceries</button>
                    </div>
                </div>

                <div>
                    <h4 style="color: #e94560; margin-bottom: 15px;">Mental Load Monitor</h4>
                    <div id="trackerMentalLoad" style="background: rgba(0,0,0,0.2); border-radius: 10px; padding: 20px; text-align: center;">
                        <div style="font-size: 3em; color: #4ade80; font-weight: bold;" id="trackerLoadValue">0%</div>
                        <div style="color: #888; margin-top: 5px;">Cognitive Load</div>
                        <div style="background: rgba(0,0,0,0.3); border-radius: 5px; height: 10px; margin-top: 15px; overflow: hidden;">
                            <div id="trackerLoadBar" style="background: linear-gradient(90deg, #4ade80, #22c55e); height: 100%; width: 0%; transition: all 0.5s;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="trackedTasksList" style="margin-top: 20px;">
                <h4 style="color: #888; margin-bottom: 15px;">Your Open Tasks (<span id="openTaskCount">0</span>)</h4>
                <div id="taskListContainer" style="display: grid; gap: 10px; max-height: 300px; overflow-y: auto;"></div>
            </div>

            <div style="text-align: center; margin-top: 25px;">
                <button class="btn-secondary btn" onclick="clearAllTrackedTasks()">Clear All (Experience Relief)</button>
            </div>
        </section>

        <section class="progress-demo">
            <h2>The Psychology of Progress Bars</h2>
            <p style="text-align: center; margin-bottom: 30px; color: #bbb;">
                Progress bars exploit the Zeigarnik Effect. Incomplete bars create mental tension‚Äî<br>
                an "open loop" your brain desperately wants to close.
            </p>

            <div class="progress-examples">
                <div class="progress-example">
                    <h4>‚úÖ Profile Complete</h4>
                    <div class="large-progress">
                        <div class="large-progress-fill progress-1" data-value="100%"></div>
                    </div>
                    <p class="urge-indicator urge-low">Mental tension: <strong>LOW</strong> ‚Äî Loop closed, forgotten</p>
                </div>

                <div class="progress-example">
                    <h4>‚ö†Ô∏è Profile 73% Complete</h4>
                    <div class="large-progress">
                        <div class="large-progress-fill progress-2" data-value="73%"></div>
                    </div>
                    <p class="urge-indicator urge-medium">Mental tension: <strong>MEDIUM</strong> ‚Äî Nagging awareness</p>
                </div>

                <div class="progress-example">
                    <h4>üî• Profile 91% Complete ‚Äî Just 2 Steps Left!</h4>
                    <div class="large-progress">
                        <div class="large-progress-fill progress-3" data-value="91%"></div>
                    </div>
                    <p class="urge-indicator urge-high">Mental tension: <strong>HIGH</strong> ‚Äî Almost there! Must complete!</p>
                </div>
            </div>

            <p style="text-align: center; margin-top: 25px; font-style: italic; color: #888;">
                LinkedIn uses this exact technique‚Äîtheir 91% profile completeness prompt exploits your need for closure.
            </p>
        </section>

        <section class="applications-section">
            <h2>üåç The Zeigarnik Effect in Daily Life</h2>

            <div class="application-grid">
                <div class="application-card">
                    <h3>üì∫ TV Cliffhangers</h3>
                    <p>Writers leave storylines unresolved to create "open loops" that keep viewers thinking about the show between episodes.</p>
                    <div class="stat-callout">61% of viewers binge-watch because they can't stop thinking about what happens next</div>
                </div>

                <div class="application-card">
                    <h3>üõí Abandoned Cart Emails</h3>
                    <p>When you leave items in your shopping cart, the unfinished transaction creates mental tension that reminder emails exploit.</p>
                    <div class="stat-callout">Cart abandonment emails have 45% higher open rates than typical marketing</div>
                </div>

                <div class="application-card">
                    <h3>‚úÖ Getting Things Done (GTD)</h3>
                    <p>Writing down tasks "closes the loop" temporarily, reducing anxiety without requiring immediate completion.</p>
                    <div class="stat-callout">Brain dumps before bed improve sleep by releasing incomplete tasks from working memory</div>
                </div>

                <div class="application-card">
                    <h3>üéÆ Quest Logs & Achievements</h3>
                    <p>Games show incomplete quests and missing achievements to keep players engaged through unfinished business.</p>
                    <div class="stat-callout">Completion mechanics drive 35% more gameplay time</div>
                </div>

                <div class="application-card">
                    <h3>üöÄ Beat Procrastination</h3>
                    <p>Just START a task‚Äîeven for 2 minutes. Once begun, your brain registers it as "open" and nudges you to return.</p>
                    <div class="stat-callout">Starting is 80% of the battle‚Äîthe Zeigarnik Effect handles the rest</div>
                </div>

                <div class="application-card">
                    <h3>üò∞ Rumination & Anxiety</h3>
                    <p>Too many "open loops" can cause intrusive thoughts and stress. Perfectionists are especially vulnerable.</p>
                    <div class="stat-callout">Unfinished tasks can disrupt sleep and cause cognitive overload</div>
                </div>
            </div>
        </section>

        <section class="research-section">
            <h2>üìö The Science Behind the Effect</h2>

            <h3>Zeigarnik's Original Experiment (1927)</h3>
            <p>
                Zeigarnik gave 32 adults a series of 18-22 tasks: stringing beads, solving puzzles, folding paper,
                counting backwards, drawing figures. Half of the tasks were interrupted "when the participant was
                most engrossed." After an hour's delay, she asked participants to recall which tasks they had worked on.
            </p>
            <p class="citation">
                "Participants were approximately <strong>twice as likely to remember incomplete tasks</strong> than
                completed ones." ‚Äî Zeigarnik, B. (1927). Das Behalten erledigter und unerledigter Handlungen.
                Psychologische Forschung, 9, 1-85.
            </p>

            <h3>Lewin's Field Theory Explanation</h3>
            <p>
                Kurt Lewin explained the phenomenon through his field theory: starting a task creates a
                <strong>"task-specific tension"</strong> that keeps relevant information cognitively accessible.
                Completing the task releases this tension‚Äîbut interruption keeps it active, like a browser tab
                consuming memory in the background.
            </p>

            <h3>The Ovsiankina Effect</h3>
            <p>
                Maria Ovsiankina, Zeigarnik's colleague, discovered a related phenomenon: people have a strong
                tendency to <strong>resume interrupted tasks</strong>, even without rewards or incentives.
                The "quasi-need" created by incompletion drives behavior toward resolution.
            </p>

            <div class="controversy-box">
                <h4>‚ö†Ô∏è Scientific Controversy</h4>
                <p>
                    The Zeigarnik Effect's reliability has been debated. A 2020 meta-analysis by Seifert & Patalano
                    found <strong>weak evidence for the memory advantage</strong> but confirmed the
                    <strong>Ovsiankina effect</strong>‚Äîpeople consistently want to resume incomplete tasks,
                    even if they don't necessarily remember them better.
                </p>
                <p style="margin-top: 10px;">
                    The psychological tension is real‚Äîeven if memory enhancement is context-dependent.
                </p>
            </div>

            <h3>Why It Works (When It Works)</h3>
            <p>
                Modern cognitive psychology suggests the effect depends on several factors:
            </p>
            <ul style="margin: 15px 0 15px 30px; color: #bbb;">
                <li><strong>Ego involvement:</strong> Tasks that matter to your identity show stronger effects</li>
                <li><strong>Interruption timing:</strong> Stopping at peak engagement is crucial</li>
                <li><strong>Achievement motivation:</strong> High-achievers show the effect more consistently</li>
                <li><strong>Stress levels:</strong> The effect reverses under high stress (completed tasks are remembered better)</li>
            </ul>
        </section>
    </div>

    <script>
        // Enhanced task set with more variety and actual mini-challenges
        const tasks = [
            { name: 'Count Backwards', icon: 'üî¢', willComplete: true, challenge: 'count', difficulty: 'easy' },
            { name: 'Word Puzzle', icon: 'üìù', willComplete: false, challenge: 'anagram', difficulty: 'medium' },
            { name: 'Pattern Match', icon: 'üéØ', willComplete: true, challenge: 'pattern', difficulty: 'easy' },
            { name: 'Memory Game', icon: 'üß†', willComplete: false, challenge: 'sequence', difficulty: 'hard' },
            { name: 'Shape Drawing', icon: '‚úèÔ∏è', willComplete: true, challenge: 'shape', difficulty: 'easy' },
            { name: 'Number Sequence', icon: '‚ûó', willComplete: false, challenge: 'math', difficulty: 'medium' },
            { name: 'Color Sorting', icon: 'üé®', willComplete: true, challenge: 'colors', difficulty: 'easy' },
            { name: 'Logic Riddle', icon: 'ü§î', willComplete: false, challenge: 'logic', difficulty: 'hard' }
        ];

        // Task Tracking System - Simulates mental load
        const taskTracker = {
            openTasks: [],
            closedTasks: [],
            mentalLoadHistory: [],

            addTask(task, status) {
                const entry = { ...task, timestamp: Date.now(), status };
                if (status === 'interrupted') {
                    this.openTasks.push(entry);
                } else {
                    this.closedTasks.push(entry);
                }
                this.updateMentalLoad();
            },

            updateMentalLoad() {
                const baseLoad = 20;
                const openTaskLoad = this.openTasks.length * 15;
                const recencyBonus = this.openTasks.reduce((acc, task) => {
                    const age = (Date.now() - task.timestamp) / 1000;
                    return acc + Math.max(0, 10 - age);
                }, 0);
                const totalLoad = Math.min(100, baseLoad + openTaskLoad + recencyBonus);
                this.mentalLoadHistory.push({ time: Date.now(), load: totalLoad });
                return totalLoad;
            },

            getMentalLoad() {
                if (this.mentalLoadHistory.length === 0) return 20;
                return this.mentalLoadHistory[this.mentalLoadHistory.length - 1].load;
            },

            reset() {
                this.openTasks = [];
                this.closedTasks = [];
                this.mentalLoadHistory = [];
            }
        };

        let taskStates = [];
        let processedCount = 0;
        let currentTaskIndex = -1;
        let experimentStartTime = 0;
        let taskInteractionTimes = [];

        function initExperiment() {
            const grid = document.getElementById('taskGrid');
            grid.innerHTML = '';
            taskTracker.reset();
            taskInteractionTimes = [];
            experimentStartTime = Date.now();

            taskStates = tasks.map((task, i) => ({
                ...task,
                index: i,
                processed: false,
                status: 'pending',
                progress: 0,
                interactionTime: 0
            }));

            taskStates.forEach((task, i) => {
                const card = document.createElement('div');
                card.className = 'task-card';
                card.id = `task-${i}`;
                card.innerHTML = `
                    <div class="task-icon">${task.icon}</div>
                    <div class="task-name">${task.name}</div>
                    <div class="task-difficulty" style="font-size: 0.75em; color: ${getDifficultyColor(task.difficulty)}">${task.difficulty.toUpperCase()}</div>
                    <div class="task-status">Click to start</div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="progress-${i}" style="width: 0%"></div>
                    </div>
                `;
                card.onclick = () => startTask(i);
                grid.appendChild(card);
            });

            processedCount = 0;
            updateProgress();
            updateMentalLoadDisplay();
        }

        function getDifficultyColor(difficulty) {
            switch(difficulty) {
                case 'easy': return '#4ade80';
                case 'medium': return '#fbbf24';
                case 'hard': return '#e94560';
                default: return '#888';
            }
        }

        function startTask(index) {
            if (taskStates[index].processed || currentTaskIndex !== -1) return;

            currentTaskIndex = index;
            const startTime = Date.now();
            const card = document.getElementById(`task-${index}`);
            const progressBar = document.getElementById(`progress-${index}`);
            const statusEl = card.querySelector('.task-status');

            // Show mini-challenge based on task type
            showMiniChallenge(taskStates[index], card);
            statusEl.textContent = 'Working...';
            card.style.pointerEvents = 'none';

            const willComplete = taskStates[index].willComplete;
            const targetProgress = willComplete ? 100 : Math.floor(Math.random() * 30) + 40;
            let progress = 0;

            const interval = setInterval(() => {
                progress += Math.random() * 8 + 2;
                if (progress >= targetProgress) {
                    progress = targetProgress;
                    clearInterval(interval);

                    const interactionTime = Date.now() - startTime;
                    taskStates[index].processed = true;
                    taskStates[index].progress = progress;
                    taskStates[index].interactionTime = interactionTime;
                    taskInteractionTimes.push({ index, time: interactionTime, completed: willComplete });

                    if (willComplete) {
                        taskStates[index].status = 'completed';
                        card.className = 'task-card completed';
                        statusEl.textContent = '‚úì Completed';
                        progressBar.style.width = '100%';
                        taskTracker.addTask(taskStates[index], 'completed');
                        hideMiniChallenge(card, true);
                    } else {
                        taskStates[index].status = 'interrupted';
                        card.className = 'task-card interrupted';
                        statusEl.textContent = '‚ö† INTERRUPTED!';
                        progressBar.style.width = progress + '%';
                        progressBar.classList.add('interrupted');
                        taskTracker.addTask(taskStates[index], 'interrupted');
                        hideMiniChallenge(card, false);
                    }

                    processedCount++;
                    updateProgress();
                    updateMentalLoadDisplay();
                    currentTaskIndex = -1;
                } else {
                    progressBar.style.width = progress + '%';
                }
            }, 100);
        }

        function showMiniChallenge(task, card) {
            const challengeDiv = document.createElement('div');
            challengeDiv.className = 'mini-challenge';
            challengeDiv.style.cssText = 'position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; border-radius: 10px; padding: 10px;';

            let content = '';
            switch(task.challenge) {
                case 'count':
                    content = '<div style="text-align: center; color: #4ade80;"><div style="font-size: 2em;">10, 9, 8...</div><div style="font-size: 0.9em; margin-top: 5px;">Counting down...</div></div>';
                    break;
                case 'anagram':
                    content = '<div style="text-align: center; color: #fbbf24;"><div style="font-size: 1.5em;">LPZUEZ</div><div style="font-size: 0.9em; margin-top: 5px;">Unscramble: P_ZZL_</div></div>';
                    break;
                case 'pattern':
                    content = '<div style="text-align: center; color: #0f9b8e;"><div style="font-size: 1.5em;">‚óè ‚óã ‚óè ‚óã ?</div><div style="font-size: 0.9em; margin-top: 5px;">Finding pattern...</div></div>';
                    break;
                case 'sequence':
                    content = '<div style="text-align: center; color: #e94560;"><div style="font-size: 1.5em;">3 ‚Üí 7 ‚Üí 2 ‚Üí ?</div><div style="font-size: 0.9em; margin-top: 5px;">Memorizing...</div></div>';
                    break;
                case 'shape':
                    content = '<div style="text-align: center; color: #4ade80;"><div style="font-size: 2em;">‚ñ≥</div><div style="font-size: 0.9em; margin-top: 5px;">Drawing triangle...</div></div>';
                    break;
                case 'math':
                    content = '<div style="text-align: center; color: #fbbf24;"><div style="font-size: 1.5em;">2, 4, 8, 16, ?</div><div style="font-size: 0.9em; margin-top: 5px;">Calculating...</div></div>';
                    break;
                case 'colors':
                    content = '<div style="text-align: center;"><div style="font-size: 1.5em;">üî¥ üîµ üü¢ üü°</div><div style="font-size: 0.9em; margin-top: 5px; color: #4ade80;">Sorting colors...</div></div>';
                    break;
                case 'logic':
                    content = '<div style="text-align: center; color: #e94560;"><div style="font-size: 1.2em;">If A ‚Üí B, B ‚Üí C</div><div style="font-size: 0.9em; margin-top: 5px;">Then A ‚Üí ?</div></div>';
                    break;
            }

            challengeDiv.innerHTML = content;
            card.style.position = 'relative';
            card.appendChild(challengeDiv);
        }

        function hideMiniChallenge(card, completed) {
            const challenge = card.querySelector('.mini-challenge');
            if (challenge) {
                if (!completed) {
                    challenge.innerHTML = '<div style="text-align: center; color: #f59e0b; font-size: 1.2em;">‚ö†Ô∏è INTERRUPTED!</div>';
                    setTimeout(() => challenge.remove(), 500);
                } else {
                    challenge.innerHTML = '<div style="text-align: center; color: #4ade80; font-size: 1.5em;">‚úì</div>';
                    setTimeout(() => challenge.remove(), 300);
                }
            }
        }

        function updateMentalLoadDisplay() {
            const mentalLoad = taskTracker.getMentalLoad();
            const openCount = taskTracker.openTasks.length;

            let loadEl = document.getElementById('mentalLoadDisplay');
            if (!loadEl) {
                loadEl = document.createElement('div');
                loadEl.id = 'mentalLoadDisplay';
                loadEl.style.cssText = 'background: rgba(233, 69, 96, 0.1); border: 1px solid rgba(233, 69, 96, 0.3); border-radius: 10px; padding: 15px; margin-top: 20px; text-align: center;';
                document.querySelector('.phase-indicator').after(loadEl);
            }

            const loadColor = mentalLoad < 40 ? '#4ade80' : mentalLoad < 70 ? '#fbbf24' : '#e94560';
            loadEl.innerHTML = `
                <div style="font-size: 0.9em; color: #888; margin-bottom: 8px;">Cognitive Load Tracker</div>
                <div style="display: flex; justify-content: center; align-items: center; gap: 20px;">
                    <div>
                        <div style="font-size: 1.8em; color: ${loadColor}; font-weight: bold;">${Math.round(mentalLoad)}%</div>
                        <div style="font-size: 0.8em; color: #888;">Mental Load</div>
                    </div>
                    <div>
                        <div style="font-size: 1.8em; color: #f59e0b; font-weight: bold;">${openCount}</div>
                        <div style="font-size: 0.8em; color: #888;">Open Loops</div>
                    </div>
                </div>
                <div style="background: rgba(0,0,0,0.2); border-radius: 5px; height: 8px; margin-top: 10px; overflow: hidden;">
                    <div style="background: ${loadColor}; height: 100%; width: ${mentalLoad}%; transition: all 0.3s;"></div>
                </div>
            `;
        }

        function updateProgress() {
            document.getElementById('taskProgress').textContent =
                `Tasks processed: ${processedCount} / ${tasks.length}`;

            if (processedCount === tasks.length) {
                document.getElementById('startRecallBtn').disabled = false;
            }
        }

        document.getElementById('startRecallBtn').onclick = function() {
            // Add distraction phase
            document.getElementById('taskPhase').style.display = 'none';

            const distractionPhase = document.createElement('section');
            distractionPhase.className = 'experiment-section';
            distractionPhase.id = 'distractionPhase';
            distractionPhase.innerHTML = `
                <h2>üßò Brief Distraction</h2>
                <div class="phase-indicator">
                    <h3>Clear your mind for 10 seconds</h3>
                    <p>This simulates the delay in Zeigarnik's original experiment.</p>
                </div>
                <div style="text-align: center; margin: 30px 0;">
                    <div id="countdownTimer" style="font-size: 4em; color: #e94560; font-weight: bold;">10</div>
                    <p style="color: #888; margin-top: 15px;">Think about what you had for breakfast...</p>
                </div>
            `;

            document.getElementById('taskPhase').after(distractionPhase);

            let countdown = 10;
            const timer = setInterval(() => {
                countdown--;
                document.getElementById('countdownTimer').textContent = countdown;
                if (countdown <= 0) {
                    clearInterval(timer);
                    distractionPhase.remove();
                    showRecallPhase();
                }
            }, 1000);
        };

        function showRecallPhase() {
            document.getElementById('recallPhase').style.display = 'block';

            const recallGrid = document.getElementById('recallGrid');
            recallGrid.innerHTML = '';
            for (let i = 0; i < 8; i++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'recall-input';
                input.placeholder = `Task ${i + 1}...`;
                input.id = `recall-${i}`;
                recallGrid.appendChild(input);
            }

            // Add timer for recall phase
            const recallStart = Date.now();
            const timerDiv = document.createElement('div');
            timerDiv.id = 'recallTimer';
            timerDiv.style.cssText = 'text-align: center; color: #888; font-size: 0.9em; margin-top: 15px;';
            recallGrid.after(timerDiv);

            const timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - recallStart) / 1000);
                timerDiv.textContent = `Time: ${elapsed}s`;
            }, 1000);

            document.getElementById('checkResultsBtn').onclick = function() {
                clearInterval(timerInterval);
                const recallTime = Date.now() - recallStart;
                checkResults(recallTime);
            };
        }

        function checkResults(recallTime) {
            const recalled = [];
            const recallOrder = [];
            for (let i = 0; i < 8; i++) {
                const val = document.getElementById(`recall-${i}`).value.trim().toLowerCase();
                if (val) {
                    recalled.push(val);
                    recallOrder.push({ position: i, value: val });
                }
            }

            let completedRecalled = 0;
            let interruptedRecalled = 0;
            let completedTotal = 0;
            let interruptedTotal = 0;
            const matchedTasks = [];

            taskStates.forEach(task => {
                if (task.status === 'completed') completedTotal++;
                else if (task.status === 'interrupted') interruptedTotal++;

                const taskWords = task.name.toLowerCase().split(' ');
                const wasRecalled = recalled.some(r =>
                    taskWords.some(word => r.includes(word) || word.includes(r))
                );

                if (wasRecalled) {
                    matchedTasks.push(task);
                    if (task.status === 'completed') completedRecalled++;
                    else if (task.status === 'interrupted') interruptedRecalled++;
                }
            });

            const completedPct = completedTotal > 0 ? Math.round((completedRecalled / completedTotal) * 100) : 0;
            const interruptedPct = interruptedTotal > 0 ? Math.round((interruptedRecalled / interruptedTotal) * 100) : 0;

            document.getElementById('recallPhase').style.display = 'none';
            document.getElementById('resultsPhase').style.display = 'block';

            setTimeout(() => {
                document.getElementById('completedBar').style.height = completedPct + '%';
                document.getElementById('interruptedBar').style.height = interruptedPct + '%';
                document.getElementById('completedValue').textContent = completedPct + '%';
                document.getElementById('interruptedValue').textContent = interruptedPct + '%';
            }, 100);

            // Enhanced insight with statistics
            const insightBox = document.getElementById('insightBox');
            let insight = '';

            const avgRecallTime = (recallTime / 1000).toFixed(1);
            const openLoops = taskTracker.openTasks.length;
            const peakLoad = Math.max(...taskTracker.mentalLoadHistory.map(h => h.load));

            if (interruptedPct > completedPct) {
                const diff = interruptedPct - completedPct;
                insight = `
                    <h3>The Zeigarnik Effect in Action!</h3>
                    <p>You remembered <strong>${diff}% more interrupted tasks</strong> than completed ones!
                    Just like Zeigarnik's original participants, those unfinished tasks created mental tension
                    that kept them accessible in your memory.</p>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-top: 20px; text-align: center;">
                        <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                            <div style="font-size: 1.5em; color: #f59e0b;">${openLoops}</div>
                            <div style="font-size: 0.8em; color: #888;">Open Loops</div>
                        </div>
                        <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                            <div style="font-size: 1.5em; color: #e94560;">${peakLoad}%</div>
                            <div style="font-size: 0.8em; color: #888;">Peak Load</div>
                        </div>
                        <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                            <div style="font-size: 1.5em; color: #0f9b8e;">${avgRecallTime}s</div>
                            <div style="font-size: 0.8em; color: #888;">Recall Time</div>
                        </div>
                    </div>
                    <p style="margin-top: 15px; color: #888;">The "open loops" of interrupted tasks consumed
                    cognitive resources‚Äîthat nagging feeling has evolutionary roots in keeping unresolved
                    threats top of mind.</p>
                `;
            } else if (completedPct > interruptedPct) {
                insight = `
                    <h3>Interesting‚ÄîYou Bucked the Trend!</h3>
                    <p>You actually remembered <strong>more completed tasks</strong>. This happens!
                    Research shows the effect varies based on stress levels, achievement motivation,
                    and how "ego-involved" you felt in each task.</p>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-top: 20px; text-align: center;">
                        <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                            <div style="font-size: 1.5em; color: #4ade80;">${completedTotal}</div>
                            <div style="font-size: 0.8em; color: #888;">Completed</div>
                        </div>
                        <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                            <div style="font-size: 1.5em; color: #f59e0b;">${interruptedTotal}</div>
                            <div style="font-size: 0.8em; color: #888;">Interrupted</div>
                        </div>
                        <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                            <div style="font-size: 1.5em; color: #0f9b8e;">${avgRecallTime}s</div>
                            <div style="font-size: 0.8em; color: #888;">Recall Time</div>
                        </div>
                    </div>
                    <p style="margin-top: 15px; color: #888;">Under high cognitive load or stress,
                    the effect can reverse‚Äîcompleted tasks provide satisfying closure that makes them memorable.</p>
                `;
            } else {
                insight = `
                    <h3>Evenly Matched!</h3>
                    <p>You remembered completed and interrupted tasks equally well. The Zeigarnik Effect
                    isn't universal‚Äîit depends on task engagement, personal motivation, and context.</p>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-top: 20px; text-align: center;">
                        <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                            <div style="font-size: 1.5em; color: #0f9b8e;">${recalled.length}</div>
                            <div style="font-size: 0.8em; color: #888;">Tasks Recalled</div>
                        </div>
                        <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                            <div style="font-size: 1.5em; color: #e94560;">${peakLoad}%</div>
                            <div style="font-size: 0.8em; color: #888;">Peak Load</div>
                        </div>
                        <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
                            <div style="font-size: 1.5em; color: #fbbf24;">${avgRecallTime}s</div>
                            <div style="font-size: 0.8em; color: #888;">Recall Time</div>
                        </div>
                    </div>
                    <p style="margin-top: 15px; color: #888;">Modern research suggests the effect is
                    strongest when tasks feel personally important and interruption occurs at peak engagement.</p>
                `;
            }

            insightBox.innerHTML = insight;
        }

        function resetExperiment() {
            document.getElementById('resultsPhase').style.display = 'none';
            document.getElementById('taskPhase').style.display = 'block';
            document.getElementById('startRecallBtn').disabled = true;

            // Remove mental load display if exists
            const loadDisplay = document.getElementById('mentalLoadDisplay');
            if (loadDisplay) loadDisplay.remove();

            initExperiment();
        }

        // Initialize
        initExperiment();

        // Task Tracking Interactive Demo
        const trackedTasks = [];
        let trackerTaskId = 0;

        function addTrackedTask() {
            const input = document.getElementById('newTaskInput');
            const taskName = input.value.trim();
            if (taskName) {
                addQuickTask(taskName);
                input.value = '';
            }
        }

        function addQuickTask(taskName) {
            trackerTaskId++;
            const task = {
                id: trackerTaskId,
                name: taskName,
                addedAt: Date.now(),
                urgency: Math.random() > 0.5 ? 'high' : 'normal'
            };
            trackedTasks.push(task);
            renderTrackedTasks();
            updateTrackerMentalLoad();
        }

        function completeTrackedTask(id) {
            const index = trackedTasks.findIndex(t => t.id === id);
            if (index !== -1) {
                const taskEl = document.getElementById(`tracked-task-${id}`);
                if (taskEl) {
                    taskEl.style.background = 'rgba(74, 222, 128, 0.2)';
                    taskEl.style.borderColor = '#4ade80';
                    setTimeout(() => {
                        trackedTasks.splice(index, 1);
                        renderTrackedTasks();
                        updateTrackerMentalLoad();
                    }, 300);
                }
            }
        }

        function renderTrackedTasks() {
            const container = document.getElementById('taskListContainer');
            const countEl = document.getElementById('openTaskCount');
            countEl.textContent = trackedTasks.length;

            if (trackedTasks.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #4ade80; padding: 30px;">All loops closed. Mental clarity achieved.</div>';
                return;
            }

            container.innerHTML = trackedTasks.map(task => {
                const age = Math.floor((Date.now() - task.addedAt) / 1000);
                const urgencyColor = task.urgency === 'high' ? '#e94560' : '#f59e0b';
                return `
                    <div id="tracked-task-${task.id}" style="background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 8px; padding: 15px; display: flex; align-items: center; justify-content: space-between; transition: all 0.3s;">
                        <div>
                            <div style="font-weight: bold; color: #fff;">${task.name}</div>
                            <div style="font-size: 0.8em; color: #888;">Open for ${age}s ‚Ä¢ <span style="color: ${urgencyColor};">${task.urgency.toUpperCase()}</span></div>
                        </div>
                        <button onclick="completeTrackedTask(${task.id})" style="background: #4ade80; border: none; color: #000; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">Complete</button>
                    </div>
                `;
            }).join('');
        }

        function updateTrackerMentalLoad() {
            const baseLoad = 10;
            const taskLoad = trackedTasks.length * 12;
            const urgencyBonus = trackedTasks.filter(t => t.urgency === 'high').length * 8;
            const totalLoad = Math.min(100, baseLoad + taskLoad + urgencyBonus);

            const loadValue = document.getElementById('trackerLoadValue');
            const loadBar = document.getElementById('trackerLoadBar');

            loadValue.textContent = totalLoad + '%';
            loadBar.style.width = totalLoad + '%';

            if (totalLoad < 30) {
                loadValue.style.color = '#4ade80';
                loadBar.style.background = 'linear-gradient(90deg, #4ade80, #22c55e)';
            } else if (totalLoad < 60) {
                loadValue.style.color = '#fbbf24';
                loadBar.style.background = 'linear-gradient(90deg, #f59e0b, #fbbf24)';
            } else {
                loadValue.style.color = '#e94560';
                loadBar.style.background = 'linear-gradient(90deg, #e94560, #f87171)';
            }

            // Pulse effect when high
            if (totalLoad >= 70) {
                loadValue.style.animation = 'pulse 1s infinite';
            } else {
                loadValue.style.animation = 'none';
            }
        }

        function clearAllTrackedTasks() {
            const container = document.getElementById('taskListContainer');
            container.innerHTML = '<div style="text-align: center; padding: 30px;"><div style="font-size: 2em; color: #4ade80; margin-bottom: 10px;">Relief!</div><div style="color: #888;">All tasks completed. Notice how much lighter you feel?</div></div>';
            trackedTasks.length = 0;
            updateTrackerMentalLoad();

            setTimeout(() => {
                renderTrackedTasks();
            }, 2000);
        }

        // Update task ages every second
        setInterval(() => {
            if (trackedTasks.length > 0) {
                renderTrackedTasks();
            }
        }, 1000);

        // Handle enter key for task input
        document.getElementById('newTaskInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addTrackedTask();
            }
        });

        // Initialize tracker
        renderTrackedTasks();
        updateTrackerMentalLoad();
    </script>
</body>
</html>
