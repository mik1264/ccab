<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wada Basins - Three Regions, One Boundary - Surprising Paradoxes</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
            --root1: #ef4444;
            --root2: #22c55e;
            --root3: #3b82f6;
            --julia: #1a1a2e;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%);
            min-height: 100vh;
            color: var(--dark-moss);
            line-height: 1.8;
        }
        .organic-shape {
            position: fixed;
            border-radius: 60% 40% 50% 50% / 50% 60% 40% 50%;
            opacity: 0.12;
            z-index: 0;
            animation: morph 30s ease-in-out infinite;
        }
        .shape-1 { width: 600px; height: 600px; background: var(--root1); top: -200px; right: -150px; }
        .shape-2 { width: 500px; height: 500px; background: var(--root3); bottom: -150px; left: -150px; animation-delay: -15s; }
        @keyframes morph {
            0%, 100% { border-radius: 60% 40% 50% 50% / 50% 60% 40% 50%; }
            25% { border-radius: 50% 60% 40% 50% / 40% 50% 60% 50%; }
            50% { border-radius: 40% 50% 60% 50% / 50% 40% 50% 60%; }
            75% { border-radius: 50% 40% 50% 60% / 60% 50% 40% 50%; }
        }
        .container {
            max-width: 950px;
            margin: 0 auto;
            padding: 40px 20px 80px;
            position: relative;
            z-index: 1;
        }
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
            margin-bottom: 30px;
            padding: 10px 20px;
            background: rgba(255,255,255,0.6);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            transition: all 0.3s ease;
        }
        .back-link:hover { background: rgba(255,255,255,0.9); transform: translateX(-5px); }
        h1 { font-family: 'Lora', serif; font-size: 2.6rem; color: var(--moss); margin-bottom: 20px; }
        .subtitle { font-size: 1.3rem; color: var(--terracotta); margin-bottom: 40px; font-weight: 500; }
        .section {
            background: rgba(255,255,255,0.6);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(138,154,91,0.2);
        }
        h2 { font-family: 'Lora', serif; font-size: 1.6rem; color: var(--moss); margin-bottom: 20px; }
        h3 { font-family: 'Lora', serif; font-size: 1.3rem; color: var(--terracotta); margin: 25px 0 15px; }
        p { margin-bottom: 15px; color: #555; }
        .highlight {
            background: linear-gradient(135deg, rgba(239,68,68,0.1), rgba(59,130,246,0.1));
            border-left: 4px solid var(--root2);
            padding: 20px 25px;
            border-radius: 0 15px 15px 0;
            margin: 25px 0;
        }
        .highlight p { margin-bottom: 0; font-weight: 500; color: var(--dark-moss); }

        /* Simulation Container */
        .sim-container {
            background: linear-gradient(180deg, #0f172a 0%, #1e1b4b 100%);
            border-radius: 20px;
            padding: 30px;
            margin: 25px 0;
            position: relative;
            overflow: hidden;
        }
        .sim-title {
            font-family: 'Lora', serif;
            font-size: 1.5rem;
            color: #f8fafc;
            margin-bottom: 8px;
            text-align: center;
        }
        .sim-subtitle {
            color: #94a3b8;
            text-align: center;
            margin-bottom: 20px;
            font-size: 0.95rem;
        }

        /* Controls */
        .controls-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .sim-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .sim-btn.primary {
            background: linear-gradient(135deg, var(--root2), #166534);
            color: white;
        }
        .sim-btn.primary:hover { transform: scale(1.05); box-shadow: 0 5px 20px rgba(34,197,94,0.4); }
        .sim-btn.secondary {
            background: rgba(255,255,255,0.1);
            color: #e2e8f0;
            border: 2px solid rgba(255,255,255,0.2);
        }
        .sim-btn.secondary:hover { background: rgba(255,255,255,0.2); }

        /* Canvas */
        .canvas-container {
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 10px;
            margin-bottom: 20px;
            position: relative;
        }
        #fractalCanvas {
            width: 100%;
            height: 500px;
            display: block;
            border-radius: 10px;
            cursor: crosshair;
        }
        .zoom-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: #f8fafc;
            padding: 8px 15px;
            border-radius: 10px;
            font-size: 0.85rem;
        }
        .coords-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: #f8fafc;
            padding: 8px 15px;
            border-radius: 10px;
            font-size: 0.85rem;
            font-family: 'Courier New', monospace;
        }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 23, 42, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 15px;
            z-index: 10;
        }
        .loading-text {
            color: #f8fafc;
            font-size: 1.2rem;
        }
        .hidden { display: none !important; }

        /* Legend */
        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #e2e8f0;
            font-size: 0.9rem;
        }
        .legend-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        /* Root visualization */
        .roots-display {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .root-item {
            text-align: center;
            padding: 15px 25px;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
        }
        .root-name {
            font-weight: 700;
            font-size: 1.1rem;
            margin-bottom: 5px;
        }
        .root-value {
            font-family: 'Courier New', monospace;
            color: #94a3b8;
            font-size: 0.9rem;
        }

        /* Explanation boxes */
        .paradox-box {
            background: linear-gradient(135deg, rgba(239,68,68,0.1), rgba(34,197,94,0.1), rgba(59,130,246,0.1));
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            border: 2px solid rgba(255,255,255,0.2);
        }
        .paradox-box h3 {
            color: #f8fafc;
            margin-top: 0;
        }
        .paradox-box p {
            color: #e2e8f0;
            margin-bottom: 0;
        }

        /* Math formulas */
        .formula {
            font-family: 'Courier New', monospace;
            background: rgba(0,0,0,0.05);
            padding: 15px 20px;
            border-radius: 10px;
            margin: 15px 0;
            overflow-x: auto;
            text-align: center;
            font-size: 1.1rem;
        }

        /* Quote */
        .quote {
            background: linear-gradient(135deg, rgba(239,68,68,0.1), rgba(59,130,246,0.1));
            border-left: 4px solid var(--root1);
            padding: 20px 25px;
            margin: 25px 0;
            font-style: italic;
            border-radius: 0 15px 15px 0;
        }
        .quote-attribution {
            margin-top: 15px;
            font-style: normal;
            font-weight: 600;
            color: var(--root3);
        }

        /* Sources */
        .sources {
            background: rgba(255,255,255,0.4);
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
        }
        .sources h3 { font-family: 'Lora', serif; color: var(--moss); margin-bottom: 10px; }
        .sources ul { list-style: none; }
        .sources li { margin-bottom: 8px; }
        .sources a { color: var(--terracotta); text-decoration: none; }
        .sources a:hover { text-decoration: underline; }

        @media (max-width: 768px) {
            h1 { font-size: 2rem; }
            #fractalCanvas { height: 350px; }
            .roots-display { gap: 20px; }
        }
    </style>
</head>
<body>
    <div class="organic-shape shape-1"></div>
    <div class="organic-shape shape-2"></div>

    <main class="container">
        <a href="index.html" class="back-link">← Back to Paradoxes</a>

        <h1>Wada Basins</h1>
        <p class="subtitle">Three regions sharing the exact same boundary</p>

        <div class="section">
            <h2>The Paradox</h2>
            <p>Imagine three lakes. In ordinary geometry, if Lake A borders Lake B along some shoreline, then Lake C must be somewhere else—it can't also share that same stretch of shore.</p>

            <div class="highlight">
                <p>But in 1917, mathematician Takeo Wada discovered something impossible: you can construct three disjoint regions where <strong>every single boundary point touches all three regions</strong>. The three lakes share the <em>exact same</em> boundary!</p>
            </div>

            <p>This isn't just a mathematical curiosity—it appears naturally in chaos theory. The Newton fractal for z³ - 1 demonstrates this beautifully: three basins of attraction with a shared fractal boundary.</p>
        </div>

        <!-- Interactive Simulation -->
        <div class="sim-container">
            <h3 class="sim-title">Newton Fractal: z³ - 1</h3>
            <p class="sim-subtitle">Each color shows which of three roots that starting point converges to. Click to zoom in!</p>

            <div class="roots-display">
                <div class="root-item">
                    <div class="root-name" style="color: var(--root1);">Root 1</div>
                    <div class="root-value">z = 1</div>
                </div>
                <div class="root-item">
                    <div class="root-name" style="color: var(--root2);">Root 2</div>
                    <div class="root-value">z = -0.5 + 0.866i</div>
                </div>
                <div class="root-item">
                    <div class="root-name" style="color: var(--root3);">Root 3</div>
                    <div class="root-value">z = -0.5 - 0.866i</div>
                </div>
            </div>

            <div class="controls-row">
                <button class="sim-btn primary" onclick="resetView()">↺ Reset View</button>
                <button class="sim-btn secondary" onclick="zoomIn()">+ Zoom In</button>
                <button class="sim-btn secondary" onclick="zoomOut()">- Zoom Out</button>
                <button class="sim-btn secondary" onclick="increaseDetail()">More Detail</button>
            </div>

            <div class="canvas-container">
                <canvas id="fractalCanvas"></canvas>
                <div class="zoom-info" id="zoomInfo">Zoom: 1x</div>
                <div class="coords-info" id="coordsInfo">z = 0 + 0i</div>
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="loading-text">Rendering fractal...</div>
                </div>
            </div>

            <div class="paradox-box">
                <h3>The Wada Property in Action</h3>
                <p>Zoom into any boundary region. No matter how close you look, you'll find ALL THREE colors interleaved. There is no boundary between just two colors—the third always squeezes in between. This is the essence of the Wada property: three regions, one shared fractal boundary.</p>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-dot" style="background: var(--root1);"></div>
                    <span>Converges to z = 1</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: var(--root2);"></div>
                    <span>Converges to e^(2πi/3)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: var(--root3);"></div>
                    <span>Converges to e^(4πi/3)</span>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>How It Works</h2>

            <p>The Newton-Raphson method finds roots of equations by iteration:</p>

            <div class="formula">
                z<sub>n+1</sub> = z<sub>n</sub> - f(z<sub>n</sub>) / f'(z<sub>n</sub>)
            </div>

            <p>For f(z) = z³ - 1, this becomes:</p>

            <div class="formula">
                z<sub>n+1</sub> = z<sub>n</sub> - (z<sub>n</sub>³ - 1) / (3z<sub>n</sub>²) = (2z<sub>n</sub>³ + 1) / (3z<sub>n</sub>²)
            </div>

            <p>The polynomial z³ - 1 has three roots equally spaced around the unit circle:</p>
            <ul style="margin-left: 25px; margin-bottom: 20px;">
                <li><strong>z₁ = 1</strong> (red)</li>
                <li><strong>z₂ = e^(2πi/3) ≈ -0.5 + 0.866i</strong> (green)</li>
                <li><strong>z₃ = e^(4πi/3) ≈ -0.5 - 0.866i</strong> (blue)</li>
            </ul>

            <h3>The Surprising Result</h3>
            <p>Arthur Cayley posed this problem in 1879: which starting points converge to which root? He expected simple 120° "pie slices" around each root. The actual answer—revealed by computers a century later—is infinitely complex.</p>

            <p>The <strong>Julia set</strong> forms the boundary between all three basins. On this boundary, arbitrarily small perturbations can send you to any of the three roots. That's why the boundary is shared by all three regions!</p>
        </div>

        <div class="section">
            <h2>Why the Third Color Always Intrudes</h2>

            <div class="quote">
                "No two colours can ever form a solid interface because the third always manages to squeeze in between. That is the essence of the Wada property."
                <div class="quote-attribution">— Chalkdust Magazine</div>
            </div>

            <p>Think about it geometrically:</p>
            <ul style="margin-left: 25px; margin-bottom: 20px;">
                <li>If red and green regions meet along a border...</li>
                <li>Then somewhere nearby, there must be a point that goes to blue</li>
                <li>But blue must also border red and green!</li>
                <li>So blue must squeeze in between red and green</li>
                <li>This creates new red-blue and green-blue borders...</li>
                <li>Which themselves need the third color between them...</li>
                <li><strong>This continues infinitely!</strong></li>
            </ul>

            <p>The result is a fractal boundary of infinite complexity. The boundary has <strong>zero area</strong> (it's a 1-dimensional curve in a sense) but <strong>infinite length</strong>—just like the coastline paradox!</p>
        </div>

        <div class="section">
            <h2>The Original Lakes of Wada</h2>

            <p>Takeo Wada's 1917 construction was different but achieved the same property:</p>

            <ol style="margin-left: 25px; margin-bottom: 20px;">
                <li><strong>Day 1:</strong> Dig Lake 1, extending tendrils within distance a₁ of all land</li>
                <li><strong>Day 2:</strong> Dig Lake 2, extending within distance a₂ of all remaining land</li>
                <li><strong>Day 3:</strong> Dig Lake 3, extending within distance a₃ of all remaining land</li>
                <li><strong>Day 4:</strong> Extend Lake 1 within distance a₄...</li>
                <li>Continue cycling through lakes, with distances a₁, a₂, a₃, ... → 0</li>
            </ol>

            <p>After infinitely many days, the remaining "dry land" is the common boundary of all three lakes! This boundary is an <strong>indecomposable continuum</strong>—a bizarre topological object that cannot be split into two proper subcontinua.</p>
        </div>

        <div class="section">
            <h2>Wada Basins in Nature</h2>

            <p>The Wada property isn't just a mathematical curiosity—it appears in real physical systems:</p>

            <ul style="margin-left: 25px; margin-bottom: 20px;">
                <li><strong>Forced pendulums:</strong> The basins of attraction for different periodic states can have Wada boundaries</li>
                <li><strong>Light reflection:</strong> Four reflective spheres create Wada-like patterns</li>
                <li><strong>Magnetic pendulums:</strong> Multiple magnets create chaotic Wada basins</li>
                <li><strong>Chaotic scattering:</strong> Particle trajectories in certain potentials</li>
            </ul>

            <p>Anywhere you have three or more attractors in a chaotic system, Wada basins can emerge!</p>
        </div>

        <div class="sources">
            <h3>Sources & Further Reading</h3>
            <ul>
                <li><a href="https://en.wikipedia.org/wiki/Lakes_of_Wada" target="_blank">Wikipedia: Lakes of Wada</a></li>
                <li><a href="https://en.wikipedia.org/wiki/Newton_fractal" target="_blank">Wikipedia: Newton Fractal</a></li>
                <li><a href="https://chalkdustmagazine.com/features/the-newton-raphson-fractal/" target="_blank">Chalkdust: The Newton-Raphson Fractal</a></li>
                <li><a href="https://www.nature.com/articles/srep16579" target="_blank">Nature: Testing for Basins of Wada</a></li>
                <li><a href="https://users.math.yale.edu/public_html/People/frame/Fractals/MandelSet/ComplexNewton/NewtonBasins/Basins3.html" target="_blank">Yale: Newton Fractal Basins</a></li>
            </ul>
        </div>
    </main>

    <script>
        const canvas = document.getElementById('fractalCanvas');
        const ctx = canvas.getContext('2d');

        // View parameters
        let centerX = 0;
        let centerY = 0;
        let zoom = 1;
        let maxIterations = 50;

        // Colors for the three roots
        const colors = [
            [239, 68, 68],    // Root 1: red
            [34, 197, 94],    // Root 2: green
            [59, 130, 246]    // Root 3: blue
        ];

        // The three cube roots of unity
        const roots = [
            { re: 1, im: 0 },
            { re: -0.5, im: Math.sqrt(3)/2 },
            { re: -0.5, im: -Math.sqrt(3)/2 }
        ];

        function resizeCanvas() {
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const size = Math.min(rect.width - 20, 500);
            const dpr = window.devicePixelRatio || 1;
            canvas.width = (rect.width - 20) * dpr;
            canvas.height = 500 * dpr;
            canvas.style.width = (rect.width - 20) + 'px';
            canvas.style.height = '500px';
            render();
        }

        // Newton iteration for z^3 - 1
        // z_new = (2*z^3 + 1) / (3*z^2)
        function newtonIterate(zRe, zIm) {
            // z^2
            const z2Re = zRe * zRe - zIm * zIm;
            const z2Im = 2 * zRe * zIm;

            // z^3
            const z3Re = z2Re * zRe - z2Im * zIm;
            const z3Im = z2Re * zIm + z2Im * zRe;

            // 2*z^3 + 1
            const numRe = 2 * z3Re + 1;
            const numIm = 2 * z3Im;

            // 3*z^2
            const denRe = 3 * z2Re;
            const denIm = 3 * z2Im;

            // Division: num / den
            const denMag2 = denRe * denRe + denIm * denIm;
            if (denMag2 < 1e-20) return { re: zRe, im: zIm, diverged: true };

            return {
                re: (numRe * denRe + numIm * denIm) / denMag2,
                im: (numIm * denRe - numRe * denIm) / denMag2,
                diverged: false
            };
        }

        function distanceSquared(z, root) {
            const dx = z.re - root.re;
            const dy = z.im - root.im;
            return dx * dx + dy * dy;
        }

        function findRoot(startRe, startIm) {
            let zRe = startRe;
            let zIm = startIm;
            const tolerance = 1e-6;

            for (let i = 0; i < maxIterations; i++) {
                // Check if close to a root
                for (let r = 0; r < 3; r++) {
                    const d2 = distanceSquared({ re: zRe, im: zIm }, roots[r]);
                    if (d2 < tolerance) {
                        return { root: r, iterations: i };
                    }
                }

                // Iterate
                const next = newtonIterate(zRe, zIm);
                if (next.diverged) {
                    return { root: -1, iterations: i };
                }
                zRe = next.re;
                zIm = next.im;

                // Check for divergence
                if (zRe * zRe + zIm * zIm > 1e10) {
                    return { root: -1, iterations: i };
                }
            }

            // Didn't converge - find closest root
            let minDist = Infinity;
            let closestRoot = 0;
            for (let r = 0; r < 3; r++) {
                const d2 = distanceSquared({ re: zRe, im: zIm }, roots[r]);
                if (d2 < minDist) {
                    minDist = d2;
                    closestRoot = r;
                }
            }
            return { root: closestRoot, iterations: maxIterations };
        }

        function render() {
            const width = canvas.width;
            const height = canvas.height;
            const dpr = window.devicePixelRatio || 1;

            document.getElementById('loadingOverlay').classList.remove('hidden');

            // Use setTimeout to allow UI to update
            setTimeout(() => {
                const imageData = ctx.createImageData(width, height);
                const data = imageData.data;

                const scale = 3 / (zoom * Math.min(width, height));
                const aspectRatio = width / height;

                for (let py = 0; py < height; py++) {
                    for (let px = 0; px < width; px++) {
                        // Map pixel to complex plane
                        const x = (px - width / 2) * scale * aspectRatio + centerX;
                        const y = (height / 2 - py) * scale + centerY;

                        const result = findRoot(x, y);
                        const idx = (py * width + px) * 4;

                        if (result.root >= 0) {
                            const color = colors[result.root];
                            // Darken based on iteration count for nice shading
                            const brightness = Math.max(0.3, 1 - result.iterations / maxIterations * 0.7);
                            data[idx] = Math.floor(color[0] * brightness);
                            data[idx + 1] = Math.floor(color[1] * brightness);
                            data[idx + 2] = Math.floor(color[2] * brightness);
                            data[idx + 3] = 255;
                        } else {
                            // Didn't converge - show as dark
                            data[idx] = 20;
                            data[idx + 1] = 20;
                            data[idx + 2] = 40;
                            data[idx + 3] = 255;
                        }
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                document.getElementById('loadingOverlay').classList.add('hidden');
                document.getElementById('zoomInfo').textContent = `Zoom: ${zoom.toFixed(1)}x`;
            }, 10);
        }

        function resetView() {
            centerX = 0;
            centerY = 0;
            zoom = 1;
            maxIterations = 50;
            render();
        }

        function zoomIn() {
            zoom *= 2;
            render();
        }

        function zoomOut() {
            zoom = Math.max(0.5, zoom / 2);
            render();
        }

        function increaseDetail() {
            maxIterations = Math.min(200, maxIterations + 25);
            render();
        }

        // Click to zoom
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const px = (e.clientX - rect.left) * dpr;
            const py = (e.clientY - rect.top) * dpr;

            const width = canvas.width;
            const height = canvas.height;
            const scale = 3 / (zoom * Math.min(width, height));
            const aspectRatio = width / height;

            // Convert click position to complex coordinates
            centerX = (px - width / 2) * scale * aspectRatio + centerX;
            centerY = (height / 2 - py) * scale + centerY;
            zoom *= 2;

            render();
        });

        // Show coordinates on hover
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const px = (e.clientX - rect.left) * dpr;
            const py = (e.clientY - rect.top) * dpr;

            const width = canvas.width;
            const height = canvas.height;
            const scale = 3 / (zoom * Math.min(width, height));
            const aspectRatio = width / height;

            const x = (px - width / 2) * scale * aspectRatio + centerX;
            const y = (height / 2 - py) * scale + centerY;

            const sign = y >= 0 ? '+' : '-';
            document.getElementById('coordsInfo').textContent =
                `z = ${x.toFixed(4)} ${sign} ${Math.abs(y).toFixed(4)}i`;
        });

        // Initialize
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    </script>
</body>
</html>
