<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intransitive Dice - The Rock-Paper-Scissors of Probability</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            color: #e94560;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.2em;
            color: #a0a0a0;
            font-style: italic;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #e94560;
            text-decoration: none;
            font-size: 1.1em;
            z-index: 1000;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .panel {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .panel h2 {
            color: #e94560;
            margin-bottom: 20px;
            font-size: 1.4em;
        }

        /* Dice Display */
        .dice-showcase {
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }

        .dice-container {
            text-align: center;
        }

        .dice-label {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .dice {
            width: 120px;
            height: 120px;
            border-radius: 15px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
        }

        .dice:hover {
            transform: scale(1.05);
        }

        .dice.selected {
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
            transform: scale(1.1);
        }

        .dice-red { background: linear-gradient(145deg, #e74c3c, #c0392b); }
        .dice-blue { background: linear-gradient(145deg, #3498db, #2980b9); }
        .dice-green { background: linear-gradient(145deg, #2ecc71, #27ae60); }
        .dice-yellow { background: linear-gradient(145deg, #f1c40f, #f39c12); }

        .dice-faces {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 3px;
            padding: 8px;
            font-size: 0.9em;
            font-weight: bold;
        }

        .dice-face {
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Dominance Circle */
        .dominance-container {
            display: flex;
            justify-content: center;
            margin: 30px 0;
        }

        #dominanceCanvas {
            background: rgba(0,0,0,0.2);
            border-radius: 15px;
        }

        /* Battle Arena */
        .battle-arena {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 30px 0;
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-radius: 15px;
        }

        .battle-dice {
            text-align: center;
        }

        .battle-result {
            width: 80px;
            height: 80px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            font-weight: bold;
            transition: all 0.3s;
        }

        .vs-text {
            font-size: 2em;
            color: #e94560;
            font-weight: bold;
        }

        .winner {
            box-shadow: 0 0 20px #2ecc71;
            animation: pulse 0.5s;
        }

        .loser {
            opacity: 0.5;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        button {
            background: linear-gradient(145deg, #e94560, #c73550);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 1em;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: inherit;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(233,69,96,0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        button.secondary {
            background: linear-gradient(145deg, #3498db, #2980b9);
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .stat-matchup {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .stat-bar {
            height: 25px;
            background: #333;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            margin: 10px 0;
        }

        .stat-fill {
            height: 100%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9em;
            font-weight: bold;
        }

        .stat-count {
            color: #a0a0a0;
            font-size: 0.9em;
        }

        /* Monte Carlo */
        .monte-carlo {
            margin-top: 20px;
        }

        .monte-input {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin: 15px 0;
        }

        input[type="number"] {
            width: 120px;
            padding: 10px;
            border-radius: 8px;
            border: none;
            font-size: 1em;
            text-align: center;
        }

        /* Explanation */
        .explanation {
            margin-top: 30px;
            line-height: 1.8;
        }

        .explanation h3 {
            color: #e94560;
            margin: 20px 0 10px 0;
        }

        .math-box {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
        }

        .highlight {
            color: #f1c40f;
            font-weight: bold;
        }

        .quote {
            border-left: 4px solid #e94560;
            padding-left: 20px;
            margin: 20px 0;
            font-style: italic;
            color: #b0b0b0;
        }

        /* Responsive */
        @media (max-width: 900px) {
            .main-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }
        }

        .dice-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }

        .selector-label {
            text-align: center;
            font-size: 0.9em;
            color: #a0a0a0;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>Intransitive Dice</h1>
            <p class="subtitle">When A beats B, and B beats C, but C beats A!</p>
        </header>

        <div class="main-grid">
            <div class="panel">
                <h2>The Efron Dice</h2>
                <p>These four dice have a remarkable property: there is NO "best" die! Each die beats another more than 50% of the time, creating a cycle like rock-paper-scissors.</p>

                <div class="dice-showcase">
                    <div class="dice-container">
                        <div class="dice-label" style="color: #e74c3c;">Die A</div>
                        <div class="dice dice-red" data-die="A">
                            <div class="dice-faces">
                                <div class="dice-face">4</div>
                                <div class="dice-face">4</div>
                                <div class="dice-face">4</div>
                                <div class="dice-face">4</div>
                                <div class="dice-face">0</div>
                                <div class="dice-face">0</div>
                            </div>
                        </div>
                    </div>

                    <div class="dice-container">
                        <div class="dice-label" style="color: #3498db;">Die B</div>
                        <div class="dice dice-blue" data-die="B">
                            <div class="dice-faces">
                                <div class="dice-face">3</div>
                                <div class="dice-face">3</div>
                                <div class="dice-face">3</div>
                                <div class="dice-face">3</div>
                                <div class="dice-face">3</div>
                                <div class="dice-face">3</div>
                            </div>
                        </div>
                    </div>

                    <div class="dice-container">
                        <div class="dice-label" style="color: #2ecc71;">Die C</div>
                        <div class="dice dice-green" data-die="C">
                            <div class="dice-faces">
                                <div class="dice-face">6</div>
                                <div class="dice-face">6</div>
                                <div class="dice-face">2</div>
                                <div class="dice-face">2</div>
                                <div class="dice-face">2</div>
                                <div class="dice-face">2</div>
                            </div>
                        </div>
                    </div>

                    <div class="dice-container">
                        <div class="dice-label" style="color: #f1c40f;">Die D</div>
                        <div class="dice dice-yellow" data-die="D">
                            <div class="dice-faces">
                                <div class="dice-face">5</div>
                                <div class="dice-face">5</div>
                                <div class="dice-face">5</div>
                                <div class="dice-face">1</div>
                                <div class="dice-face">1</div>
                                <div class="dice-face">1</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="selector-label">Click two dice to battle them!</div>

                <div class="battle-arena" id="battleArena">
                    <div class="battle-dice" id="leftBattle">
                        <div class="dice-label" id="leftLabel">?</div>
                        <div class="battle-result" id="leftResult" style="background: #444;">-</div>
                    </div>
                    <div class="vs-text">VS</div>
                    <div class="battle-dice" id="rightBattle">
                        <div class="dice-label" id="rightLabel">?</div>
                        <div class="battle-result" id="rightResult" style="background: #444;">-</div>
                    </div>
                </div>

                <div class="controls">
                    <button id="rollBtn" disabled>Roll Dice</button>
                    <button id="roll100Btn" class="secondary" disabled>Roll 100×</button>
                    <button id="resetBtn" class="secondary">Reset</button>
                </div>
            </div>

            <div class="panel">
                <h2>Dominance Cycle</h2>
                <div class="dominance-container">
                    <canvas id="dominanceCanvas" width="350" height="350"></canvas>
                </div>
                <p style="text-align: center; color: #a0a0a0;">Each arrow shows which die wins more often. Notice the CYCLE!</p>
            </div>
        </div>

        <div class="panel">
            <h2>Battle Statistics</h2>
            <div class="stats-grid" id="statsGrid">
                <!-- Stats will be populated by JS -->
            </div>

            <div class="monte-carlo">
                <h3 style="text-align: center; color: #e94560; margin-bottom: 15px;">Monte Carlo Simulation</h3>
                <div class="monte-input">
                    <span>Run</span>
                    <input type="number" id="monteCount" value="10000" min="100" max="100000">
                    <span>simulations for all matchups</span>
                    <button id="monteBtn" class="secondary">Run</button>
                </div>
            </div>
        </div>

        <div class="panel explanation">
            <h2>The Paradox Explained</h2>

            <p>In normal comparisons, if A > B and B > C, then A > C. This is called <span class="highlight">transitivity</span>. But probability doesn't have to be transitive!</p>

            <h3>The Math Behind the Magic</h3>
            <p>Let's analyze Die A (faces: 4,4,4,4,0,0) vs Die B (faces: 3,3,3,3,3,3):</p>

            <div class="math-box">
                • When A rolls 4 (probability 4/6 = 2/3): A wins<br>
                • When A rolls 0 (probability 2/6 = 1/3): B wins<br>
                <br>
                P(A beats B) = <span class="highlight">2/3 ≈ 66.7%</span>
            </div>

            <p>Now Die B vs Die C (faces: 6,6,2,2,2,2):</p>

            <div class="math-box">
                • C rolls 6 (prob 2/6): C wins<br>
                • C rolls 2 (prob 4/6): B wins (3 > 2)<br>
                <br>
                P(B beats C) = <span class="highlight">4/6 ≈ 66.7%</span>
            </div>

            <p>But Die C vs Die A:</p>

            <div class="math-box">
                • C rolls 6 (prob 2/6): C always wins<br>
                • C rolls 2 (prob 4/6): C wins when A rolls 0 (prob 2/6)<br>
                <br>
                P(C beats A) = 2/6 + (4/6 × 2/6) = 2/6 + 4/18 = 10/18 = <span class="highlight">5/9 ≈ 55.6%</span>
            </div>

            <p>The cycle completes! A→B→C→A, each winning about 2/3 of the time.</p>

            <h3>The Buffett Hustle</h3>
            <div class="quote">
                "Warren Buffett once tried to trick Bill Gates with intransitive dice. He offered Gates first pick of any die, then he would pick second. Gates, being Gates, asked to see the dice first... and immediately realized the trap. No matter which die Gates picked, Buffett could choose one that beat it!"
            </div>

            <h3>Why It Matters</h3>
            <p>Intransitive dice reveal that:</p>
            <ul style="margin-left: 30px; line-height: 2;">
                <li><strong>Comparisons aren't always transitive</strong> — A being better than B, and B being better than C, doesn't mean A is better than C.</li>
                <li><strong>Voting paradoxes</strong> — The Condorcet paradox works similarly: voters might prefer A to B, B to C, but C to A!</li>
                <li><strong>Game theory implications</strong> — In competitions, "letting the opponent choose first" might be an advantage.</li>
                <li><strong>Evolution</strong> — Species A might outcompete B, B outcompete C, but C outcompete A (rock-paper-scissors in nature).</li>
            </ul>

            <h3>Create Your Own!</h3>
            <p>The simplest intransitive set uses just 3 dice:</p>
            <div class="math-box">
                Die A: 2, 2, 4, 4, 9, 9<br>
                Die B: 1, 1, 6, 6, 8, 8<br>
                Die C: 3, 3, 5, 5, 7, 7<br>
                <br>
                A beats B (5/9), B beats C (5/9), C beats A (5/9)
            </div>
        </div>
    </div>

    <script>
        // Efron Dice configuration
        const DICE = {
            A: { faces: [4, 4, 4, 4, 0, 0], color: '#e74c3c', name: 'A' },
            B: { faces: [3, 3, 3, 3, 3, 3], color: '#3498db', name: 'B' },
            C: { faces: [6, 6, 2, 2, 2, 2], color: '#2ecc71', name: 'C' },
            D: { faces: [5, 5, 5, 1, 1, 1], color: '#f1c40f', name: 'D' }
        };

        // Theoretical probabilities (for reference)
        const PROBABILITIES = {
            'A-B': 2/3,      // A beats B
            'B-C': 2/3,      // B beats C
            'C-D': 2/3,      // C beats D
            'D-A': 2/3,      // D beats A
            'A-C': 5/9,      // A beats C (it's close!)
            'B-D': 5/9       // B beats D
        };

        // State
        let selectedDice = [];
        let stats = {};
        const matchups = ['A-B', 'B-C', 'C-D', 'D-A', 'A-C', 'B-D'];

        matchups.forEach(m => {
            stats[m] = { wins1: 0, wins2: 0, total: 0 };
        });

        // DOM elements
        const rollBtn = document.getElementById('rollBtn');
        const roll100Btn = document.getElementById('roll100Btn');
        const resetBtn = document.getElementById('resetBtn');
        const monteBtn = document.getElementById('monteBtn');
        const statsGrid = document.getElementById('statsGrid');
        const dominanceCanvas = document.getElementById('dominanceCanvas');
        const ctx = dominanceCanvas.getContext('2d');

        // Initialize
        setupDiceClicks();
        renderStats();
        drawDominanceCircle();

        function setupDiceClicks() {
            document.querySelectorAll('.dice').forEach(die => {
                die.addEventListener('click', () => {
                    const dieName = die.dataset.die;

                    if (selectedDice.includes(dieName)) {
                        // Deselect
                        selectedDice = selectedDice.filter(d => d !== dieName);
                        die.classList.remove('selected');
                    } else if (selectedDice.length < 2) {
                        // Select
                        selectedDice.push(dieName);
                        die.classList.add('selected');
                    }

                    updateBattleArena();
                    updateButtons();
                });
            });
        }

        function updateBattleArena() {
            const leftLabel = document.getElementById('leftLabel');
            const rightLabel = document.getElementById('rightLabel');
            const leftResult = document.getElementById('leftResult');
            const rightResult = document.getElementById('rightResult');

            if (selectedDice.length >= 1) {
                leftLabel.textContent = `Die ${selectedDice[0]}`;
                leftLabel.style.color = DICE[selectedDice[0]].color;
                leftResult.style.background = DICE[selectedDice[0]].color;
                leftResult.textContent = '-';
            } else {
                leftLabel.textContent = '?';
                leftLabel.style.color = '#a0a0a0';
                leftResult.style.background = '#444';
                leftResult.textContent = '-';
            }

            if (selectedDice.length >= 2) {
                rightLabel.textContent = `Die ${selectedDice[1]}`;
                rightLabel.style.color = DICE[selectedDice[1]].color;
                rightResult.style.background = DICE[selectedDice[1]].color;
                rightResult.textContent = '-';
            } else {
                rightLabel.textContent = '?';
                rightLabel.style.color = '#a0a0a0';
                rightResult.style.background = '#444';
                rightResult.textContent = '-';
            }

            // Clear winner/loser classes
            leftResult.classList.remove('winner', 'loser');
            rightResult.classList.remove('winner', 'loser');
        }

        function updateButtons() {
            const enabled = selectedDice.length === 2;
            rollBtn.disabled = !enabled;
            roll100Btn.disabled = !enabled;
        }

        function rollDie(die) {
            const faces = DICE[die].faces;
            return faces[Math.floor(Math.random() * faces.length)];
        }

        function battle(die1, die2) {
            const roll1 = rollDie(die1);
            const roll2 = rollDie(die2);
            return { roll1, roll2, winner: roll1 > roll2 ? 1 : (roll2 > roll1 ? 2 : 0) };
        }

        function getMatchupKey(d1, d2) {
            // Normalize to consistent order
            const sorted = [d1, d2].sort();
            return `${sorted[0]}-${sorted[1]}`;
        }

        function recordBattle(die1, die2, winner) {
            const key = getMatchupKey(die1, die2);
            const first = [die1, die2].sort()[0];

            stats[key].total++;
            if (winner === 1) {
                if (die1 === first) stats[key].wins1++;
                else stats[key].wins2++;
            } else if (winner === 2) {
                if (die2 === first) stats[key].wins1++;
                else stats[key].wins2++;
            }
            // Ties don't count
        }

        function rollOnce() {
            if (selectedDice.length !== 2) return;

            const [d1, d2] = selectedDice;
            const result = battle(d1, d2);

            const leftResult = document.getElementById('leftResult');
            const rightResult = document.getElementById('rightResult');

            leftResult.textContent = result.roll1;
            rightResult.textContent = result.roll2;

            leftResult.classList.remove('winner', 'loser');
            rightResult.classList.remove('winner', 'loser');

            if (result.winner === 1) {
                leftResult.classList.add('winner');
                rightResult.classList.add('loser');
            } else if (result.winner === 2) {
                rightResult.classList.add('winner');
                leftResult.classList.add('loser');
            }

            if (result.winner !== 0) {
                recordBattle(d1, d2, result.winner);
                renderStats();
            }
        }

        function roll100() {
            if (selectedDice.length !== 2) return;

            const [d1, d2] = selectedDice;
            let wins1 = 0, wins2 = 0;

            for (let i = 0; i < 100; i++) {
                const result = battle(d1, d2);
                if (result.winner !== 0) {
                    recordBattle(d1, d2, result.winner);
                    if (result.winner === 1) wins1++;
                    else wins2++;
                }
            }

            // Show last result in display
            const lastResult = battle(d1, d2);
            document.getElementById('leftResult').textContent = lastResult.roll1;
            document.getElementById('rightResult').textContent = lastResult.roll2;

            renderStats();
        }

        function runMonteCarlo() {
            const count = parseInt(document.getElementById('monteCount').value) || 10000;

            // Reset stats
            matchups.forEach(m => {
                stats[m] = { wins1: 0, wins2: 0, total: 0 };
            });

            // Run all matchups
            matchups.forEach(m => {
                const [d1, d2] = m.split('-');
                for (let i = 0; i < count; i++) {
                    const result = battle(d1, d2);
                    stats[m].total++;
                    if (result.winner === 1) stats[m].wins1++;
                    else if (result.winner === 2) stats[m].wins2++;
                }
            });

            renderStats();
        }

        function resetStats() {
            matchups.forEach(m => {
                stats[m] = { wins1: 0, wins2: 0, total: 0 };
            });

            // Clear selection
            selectedDice = [];
            document.querySelectorAll('.dice').forEach(d => d.classList.remove('selected'));
            updateBattleArena();
            updateButtons();
            renderStats();
        }

        function renderStats() {
            statsGrid.innerHTML = '';

            matchups.forEach(m => {
                const [d1, d2] = m.split('-');
                const s = stats[m];
                const total = s.total || 1;
                const pct1 = (s.wins1 / total * 100).toFixed(1);
                const pct2 = (s.wins2 / total * 100).toFixed(1);

                const card = document.createElement('div');
                card.className = 'stat-card';

                const theoretical = PROBABILITIES[m];
                const theoPct1 = (theoretical * 100).toFixed(1);
                const theoPct2 = ((1 - theoretical) * 100).toFixed(1);

                card.innerHTML = `
                    <div class="stat-matchup">
                        <span style="color: ${DICE[d1].color}">${d1}</span> vs
                        <span style="color: ${DICE[d2].color}">${d2}</span>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-fill" style="width: ${s.total > 0 ? pct1 : 50}%; background: ${DICE[d1].color};">
                            ${s.total > 0 ? pct1 + '%' : '?'}
                        </div>
                    </div>
                    <div class="stat-count">
                        ${s.wins1} - ${s.wins2} (${s.total} rolls)
                    </div>
                    <div style="color: #888; font-size: 0.8em; margin-top: 5px;">
                        Theory: ${theoPct1}% - ${theoPct2}%
                    </div>
                `;

                statsGrid.appendChild(card);
            });
        }

        function drawDominanceCircle() {
            ctx.clearRect(0, 0, 350, 350);

            const centerX = 175;
            const centerY = 175;
            const radius = 120;

            // Position dice in a square (not circle) for cleaner arrows
            const positions = {
                A: { x: centerX - 80, y: centerY - 80 },
                B: { x: centerX + 80, y: centerY - 80 },
                C: { x: centerX + 80, y: centerY + 80 },
                D: { x: centerX - 80, y: centerY + 80 }
            };

            // Draw main cycle arrows (A→B→C→D→A)
            const mainCycle = [['A', 'B'], ['B', 'C'], ['C', 'D'], ['D', 'A']];

            mainCycle.forEach(([from, to]) => {
                drawArrow(
                    positions[from].x, positions[from].y,
                    positions[to].x, positions[to].y,
                    DICE[from].color, 3
                );
            });

            // Draw diagonal arrows (A→C, B→D) with dashed line
            ctx.setLineDash([5, 5]);
            drawArrow(positions.A.x, positions.A.y, positions.C.x, positions.C.y, '#888', 2);
            drawArrow(positions.B.x, positions.B.y, positions.D.x, positions.D.y, '#888', 2);
            ctx.setLineDash([]);

            // Draw dice circles
            Object.entries(DICE).forEach(([name, die]) => {
                const pos = positions[name];

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 35, 0, Math.PI * 2);
                ctx.fillStyle = die.color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Georgia';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(name, pos.x, pos.y);
            });

            // Add probability labels
            ctx.font = '12px Georgia';
            ctx.fillStyle = '#aaa';

            // Main cycle labels
            ctx.fillText('67%', centerX, centerY - 100);
            ctx.fillText('67%', centerX + 100, centerY);
            ctx.fillText('67%', centerX, centerY + 100);
            ctx.fillText('67%', centerX - 100, centerY);

            // Diagonal labels
            ctx.fillText('56%', centerX + 40, centerY - 20);
            ctx.fillText('56%', centerX - 40, centerY + 20);
        }

        function drawArrow(fromX, fromY, toX, toY, color, width) {
            const headLen = 15;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);
            const length = Math.sqrt(dx * dx + dy * dy);

            // Shorten to not overlap circles
            const shortenBy = 40;
            const startX = fromX + Math.cos(angle) * shortenBy;
            const startY = fromY + Math.sin(angle) * shortenBy;
            const endX = toX - Math.cos(angle) * shortenBy;
            const endY = toY - Math.sin(angle) * shortenBy;

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.stroke();

            // Arrowhead
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI/6), endY - headLen * Math.sin(angle - Math.PI/6));
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI/6), endY - headLen * Math.sin(angle + Math.PI/6));
            ctx.stroke();
        }

        // Event listeners
        rollBtn.addEventListener('click', rollOnce);
        roll100Btn.addEventListener('click', roll100);
        resetBtn.addEventListener('click', resetStats);
        monteBtn.addEventListener('click', runMonteCarlo);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && selectedDice.length === 2) {
                e.preventDefault();
                rollOnce();
            }
        });
    </script>
</body>
</html>
