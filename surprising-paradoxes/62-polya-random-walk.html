<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pólya's Random Walk Theorem - The Dimension of Getting Lost</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 50%, #0a1a2a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #8a6fdf;
            text-decoration: none;
            padding: 12px 24px;
            background: rgba(138, 111, 223, 0.1);
            border: 1px solid rgba(138, 111, 223, 0.3);
            border-radius: 30px;
            z-index: 100;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        .back-link:hover {
            background: rgba(138, 111, 223, 0.2);
            transform: translateX(-5px);
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 80px 20px 40px;
        }
        header {
            text-align: center;
            margin-bottom: 40px;
        }
        h1 {
            font-size: 2.8rem;
            font-weight: 400;
            color: #8a6fdf;
            margin-bottom: 15px;
            text-shadow: 0 0 40px rgba(138, 111, 223, 0.4);
        }
        .subtitle {
            font-size: 1.3rem;
            color: #a0a0c0;
            font-style: italic;
            max-width: 800px;
            margin: 0 auto 30px;
            line-height: 1.6;
        }
        .paradox-statement {
            background: linear-gradient(135deg, rgba(138, 111, 223, 0.15), rgba(100, 80, 180, 0.1));
            border: 1px solid rgba(138, 111, 223, 0.3);
            border-radius: 20px;
            padding: 30px;
            margin: 30px auto;
            max-width: 900px;
            text-align: center;
        }
        .paradox-statement h2 {
            color: #ff6b9d;
            font-size: 1.4rem;
            margin-bottom: 15px;
            font-weight: 500;
        }
        .paradox-statement p {
            font-size: 1.15rem;
            line-height: 1.8;
            color: #d0d0e0;
        }
        .highlight {
            color: #8a6fdf;
            font-weight: 600;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        button {
            padding: 14px 35px;
            font-size: 1rem;
            font-family: inherit;
            background: linear-gradient(135deg, #8a6fdf, #6a4fcf);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(138, 111, 223, 0.3);
        }
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(138, 111, 223, 0.5);
        }
        button.active {
            background: linear-gradient(135deg, #ff6b9d, #ff4f8b);
        }
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #a0a0c0;
        }
        .speed-control input {
            width: 120px;
        }
        .walks-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 25px;
            margin: 40px 0;
        }
        .walk-panel {
            background: rgba(20, 15, 40, 0.8);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(138, 111, 223, 0.2);
            position: relative;
            overflow: hidden;
        }
        .walk-panel h3 {
            text-align: center;
            color: #8a6fdf;
            font-size: 1.3rem;
            margin-bottom: 10px;
            font-weight: 500;
        }
        .dimension-tag {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: 600;
        }
        .recurrent {
            background: rgba(0, 255, 150, 0.2);
            color: #00ff96;
            border: 1px solid rgba(0, 255, 150, 0.4);
        }
        .transient {
            background: rgba(255, 107, 157, 0.2);
            color: #ff6b9d;
            border: 1px solid rgba(255, 107, 157, 0.4);
        }
        canvas {
            width: 100%;
            height: 350px;
            border-radius: 15px;
            background: rgba(0, 0, 20, 0.5);
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
            font-size: 0.9rem;
        }
        .stat-item {
            padding: 10px;
            background: rgba(138, 111, 223, 0.1);
            border-radius: 10px;
            text-align: center;
        }
        .stat-label {
            color: #808090;
            font-size: 0.8rem;
            margin-bottom: 3px;
        }
        .stat-value {
            color: #8a6fdf;
            font-size: 1.1rem;
            font-weight: 600;
        }
        .stat-value.green { color: #00ff96; }
        .stat-value.red { color: #ff6b9d; }
        .probability-bar {
            margin-top: 15px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        .probability-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .explanation {
            background: rgba(20, 15, 40, 0.6);
            border-radius: 20px;
            padding: 40px;
            margin-top: 40px;
            border: 1px solid rgba(138, 111, 223, 0.2);
        }
        .explanation h2 {
            color: #8a6fdf;
            font-size: 1.6rem;
            margin-bottom: 25px;
            font-weight: 500;
        }
        .explanation-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
        }
        .explanation-section h3 {
            color: #ff6b9d;
            font-size: 1.2rem;
            margin-bottom: 12px;
            font-weight: 500;
        }
        .explanation-section p {
            color: #b0b0c0;
            line-height: 1.8;
            margin-bottom: 12px;
        }
        .math-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 12px;
            font-family: 'Courier New', monospace;
            color: #00ff96;
            margin: 15px 0;
            text-align: center;
            font-size: 1.1rem;
        }
        .quote {
            font-style: italic;
            color: #a0a0c0;
            border-left: 3px solid #8a6fdf;
            padding-left: 20px;
            margin: 20px 0;
        }
        @media (max-width: 900px) {
            .walks-container { grid-template-columns: 1fr; }
            .explanation-grid { grid-template-columns: 1fr; }
            h1 { font-size: 2rem; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>Pólya's Random Walk Theorem</h1>
            <p class="subtitle">A drunk person wandering a city grid will always find their way home.<br>
            But in our 3D universe? They're lost forever.</p>
        </header>

        <div class="paradox-statement">
            <h2>The Profound Paradox</h2>
            <p>
                In <span class="highlight">one or two dimensions</span>, a random walker returns to the origin
                with <span class="highlight">probability 1</span> — certainty. They will <em>always</em> come back.
                <br><br>
                In <span class="highlight">three dimensions</span>, the probability drops to just
                <span class="highlight">≈ 34%</span>. Add more dimensions, and they're almost certainly
                <em>lost forever</em>.
            </p>
        </div>

        <div class="controls">
            <button id="startBtn" class="active">Start Walking</button>
            <button id="resetBtn">Reset All</button>
            <div class="speed-control">
                <label>Speed:</label>
                <input type="range" id="speedSlider" min="1" max="50" value="20">
                <span id="speedVal">20</span>
            </div>
        </div>

        <div class="walks-container">
            <!-- 1D Walk -->
            <div class="walk-panel">
                <span class="dimension-tag recurrent">RECURRENT</span>
                <h3>1D: The Number Line</h3>
                <canvas id="canvas1D"></canvas>
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-label">Steps</div>
                        <div class="stat-value" id="steps1D">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Returns to Origin</div>
                        <div class="stat-value green" id="returns1D">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Current Position</div>
                        <div class="stat-value" id="pos1D">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Theory: P(return)</div>
                        <div class="stat-value green">100%</div>
                    </div>
                </div>
                <div class="probability-bar">
                    <div class="probability-fill" style="width: 100%; background: #00ff96;"></div>
                </div>
            </div>

            <!-- 2D Walk -->
            <div class="walk-panel">
                <span class="dimension-tag recurrent">RECURRENT</span>
                <h3>2D: The City Grid</h3>
                <canvas id="canvas2D"></canvas>
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-label">Steps</div>
                        <div class="stat-value" id="steps2D">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Returns to Origin</div>
                        <div class="stat-value green" id="returns2D">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Position</div>
                        <div class="stat-value" id="pos2D">(0, 0)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Theory: P(return)</div>
                        <div class="stat-value green">100%</div>
                    </div>
                </div>
                <div class="probability-bar">
                    <div class="probability-fill" style="width: 100%; background: #00ff96;"></div>
                </div>
            </div>

            <!-- 3D Walk -->
            <div class="walk-panel">
                <span class="dimension-tag transient">TRANSIENT</span>
                <h3>3D: Our Universe</h3>
                <canvas id="canvas3D"></canvas>
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-label">Steps</div>
                        <div class="stat-value" id="steps3D">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Returns to Origin</div>
                        <div class="stat-value red" id="returns3D">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Distance from Origin</div>
                        <div class="stat-value" id="pos3D">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Theory: P(return)</div>
                        <div class="stat-value red">≈34%</div>
                    </div>
                </div>
                <div class="probability-bar">
                    <div class="probability-fill" style="width: 34%; background: #ff6b9d;"></div>
                </div>
            </div>
        </div>

        <div class="explanation">
            <h2>Why Does Dimension Matter?</h2>
            <div class="explanation-grid">
                <div class="explanation-section">
                    <h3>The Intuition</h3>
                    <p>
                        In lower dimensions, there's simply <em>less space to get lost in</em>.
                        A drunk on a 1D line can only go left or right — eventually, they'll stumble
                        back to the starting point.
                    </p>
                    <p>
                        In 2D, despite having more freedom, the walker's path is still "squeezed"
                        enough that return is inevitable. They might wander far, but the probability
                        of returning remains 1.
                    </p>
                    <p>
                        In 3D, the vast emptiness of space opens up. The walker has so many
                        directions to choose from that they can drift away infinitely without
                        ever finding their way back.
                    </p>

                    <div class="quote">
                        "A drunk man will find his way home, but a drunk bird may get lost forever."
                        <br>— Shizuo Kakutani
                    </div>
                </div>

                <div class="explanation-section">
                    <h3>The Mathematics</h3>
                    <p>
                        Pólya proved in 1921 that recurrence depends on whether a certain infinite
                        series converges or diverges.
                    </p>

                    <div class="math-box">
                        P(return) = 1  if  Σ 1/n^(d/2) diverges<br>
                        P(return) < 1  if  Σ 1/n^(d/2) converges
                    </div>

                    <p>
                        For d=1,2: the series diverges → guaranteed return<br>
                        For d≥3: the series converges → finite probability of never returning
                    </p>

                    <div class="math-box">
                        P₃ = 1 - 1/u₃ ≈ 0.3405373296...<br>
                        (about 34% chance of return in 3D)
                    </div>

                    <p>
                        The value u₃ is related to Watson's triple integral, a famous result
                        in mathematical physics connected to random walks on lattices.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas1D = document.getElementById('canvas1D');
        const canvas2D = document.getElementById('canvas2D');
        const canvas3D = document.getElementById('canvas3D');
        const ctx1D = canvas1D.getContext('2d');
        const ctx2D = canvas2D.getContext('2d');
        const ctx3D = canvas3D.getContext('2d');

        function resizeCanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.getContext('2d').scale(dpr, dpr);
        }

        [canvas1D, canvas2D, canvas3D].forEach(resizeCanvas);
        window.addEventListener('resize', () => {
            [canvas1D, canvas2D, canvas3D].forEach(resizeCanvas);
        });

        // State
        let running = false;
        let speed = 20;

        // 1D Walker
        const walk1D = {
            pos: 0,
            steps: 0,
            returns: 0,
            history: [0],
            maxHistory: 500
        };

        // 2D Walker
        const walk2D = {
            x: 0,
            y: 0,
            steps: 0,
            returns: 0,
            history: [{x: 0, y: 0}],
            maxHistory: 2000
        };

        // 3D Walker
        const walk3D = {
            x: 0,
            y: 0,
            z: 0,
            steps: 0,
            returns: 0,
            history: [{x: 0, y: 0, z: 0}],
            maxHistory: 2000,
            angle: 0
        };

        function step1D() {
            const dir = Math.random() < 0.5 ? -1 : 1;
            walk1D.pos += dir;
            walk1D.steps++;
            walk1D.history.push(walk1D.pos);
            if (walk1D.history.length > walk1D.maxHistory) {
                walk1D.history.shift();
            }
            if (walk1D.pos === 0) walk1D.returns++;
        }

        function step2D() {
            const dir = Math.floor(Math.random() * 4);
            switch(dir) {
                case 0: walk2D.x++; break;
                case 1: walk2D.x--; break;
                case 2: walk2D.y++; break;
                case 3: walk2D.y--; break;
            }
            walk2D.steps++;
            walk2D.history.push({x: walk2D.x, y: walk2D.y});
            if (walk2D.history.length > walk2D.maxHistory) {
                walk2D.history.shift();
            }
            if (walk2D.x === 0 && walk2D.y === 0) walk2D.returns++;
        }

        function step3D() {
            const dir = Math.floor(Math.random() * 6);
            switch(dir) {
                case 0: walk3D.x++; break;
                case 1: walk3D.x--; break;
                case 2: walk3D.y++; break;
                case 3: walk3D.y--; break;
                case 4: walk3D.z++; break;
                case 5: walk3D.z--; break;
            }
            walk3D.steps++;
            walk3D.history.push({x: walk3D.x, y: walk3D.y, z: walk3D.z});
            if (walk3D.history.length > walk3D.maxHistory) {
                walk3D.history.shift();
            }
            if (walk3D.x === 0 && walk3D.y === 0 && walk3D.z === 0) walk3D.returns++;
        }

        function draw1D() {
            const w = canvas1D.width / (window.devicePixelRatio || 1);
            const h = canvas1D.height / (window.devicePixelRatio || 1);

            ctx1D.fillStyle = 'rgba(0, 0, 20, 0.3)';
            ctx1D.fillRect(0, 0, w, h);

            const centerY = h / 2;
            const maxVal = Math.max(Math.abs(Math.min(...walk1D.history)), Math.abs(Math.max(...walk1D.history)), 20);
            const scale = (h * 0.4) / maxVal;

            // Draw zero line
            ctx1D.strokeStyle = 'rgba(138, 111, 223, 0.3)';
            ctx1D.lineWidth = 1;
            ctx1D.beginPath();
            ctx1D.moveTo(0, centerY);
            ctx1D.lineTo(w, centerY);
            ctx1D.stroke();

            // Draw path
            const gradient = ctx1D.createLinearGradient(0, 0, w, 0);
            gradient.addColorStop(0, 'rgba(0, 255, 150, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 255, 150, 1)');

            ctx1D.strokeStyle = gradient;
            ctx1D.lineWidth = 2;
            ctx1D.beginPath();
            for (let i = 0; i < walk1D.history.length; i++) {
                const x = (i / walk1D.history.length) * w;
                const y = centerY - walk1D.history[i] * scale;
                if (i === 0) ctx1D.moveTo(x, y);
                else ctx1D.lineTo(x, y);
            }
            ctx1D.stroke();

            // Current position dot
            ctx1D.fillStyle = '#00ff96';
            ctx1D.beginPath();
            ctx1D.arc(w - 10, centerY - walk1D.pos * scale, 6, 0, Math.PI * 2);
            ctx1D.fill();

            // Origin marker
            ctx1D.fillStyle = '#8a6fdf';
            ctx1D.beginPath();
            ctx1D.arc(w - 10, centerY, 4, 0, Math.PI * 2);
            ctx1D.fill();
        }

        function draw2D() {
            const w = canvas2D.width / (window.devicePixelRatio || 1);
            const h = canvas2D.height / (window.devicePixelRatio || 1);

            ctx2D.fillStyle = 'rgba(0, 0, 20, 0.1)';
            ctx2D.fillRect(0, 0, w, h);

            const centerX = w / 2;
            const centerY = h / 2;

            // Calculate scale
            let maxDist = 20;
            walk2D.history.forEach(p => {
                maxDist = Math.max(maxDist, Math.abs(p.x), Math.abs(p.y));
            });
            const scale = Math.min(w, h) * 0.4 / maxDist;

            // Draw axes
            ctx2D.strokeStyle = 'rgba(138, 111, 223, 0.2)';
            ctx2D.lineWidth = 1;
            ctx2D.beginPath();
            ctx2D.moveTo(0, centerY);
            ctx2D.lineTo(w, centerY);
            ctx2D.moveTo(centerX, 0);
            ctx2D.lineTo(centerX, h);
            ctx2D.stroke();

            // Draw path with gradient
            if (walk2D.history.length > 1) {
                for (let i = 1; i < walk2D.history.length; i++) {
                    const alpha = i / walk2D.history.length;
                    ctx2D.strokeStyle = `rgba(0, 255, 150, ${alpha * 0.8})`;
                    ctx2D.lineWidth = 1 + alpha;
                    ctx2D.beginPath();
                    ctx2D.moveTo(
                        centerX + walk2D.history[i-1].x * scale,
                        centerY - walk2D.history[i-1].y * scale
                    );
                    ctx2D.lineTo(
                        centerX + walk2D.history[i].x * scale,
                        centerY - walk2D.history[i].y * scale
                    );
                    ctx2D.stroke();
                }
            }

            // Origin
            ctx2D.fillStyle = '#8a6fdf';
            ctx2D.beginPath();
            ctx2D.arc(centerX, centerY, 5, 0, Math.PI * 2);
            ctx2D.fill();

            // Current position
            ctx2D.fillStyle = '#00ff96';
            ctx2D.shadowColor = '#00ff96';
            ctx2D.shadowBlur = 10;
            ctx2D.beginPath();
            ctx2D.arc(centerX + walk2D.x * scale, centerY - walk2D.y * scale, 6, 0, Math.PI * 2);
            ctx2D.fill();
            ctx2D.shadowBlur = 0;
        }

        function draw3D() {
            const w = canvas3D.width / (window.devicePixelRatio || 1);
            const h = canvas3D.height / (window.devicePixelRatio || 1);

            ctx3D.fillStyle = 'rgba(0, 0, 20, 0.1)';
            ctx3D.fillRect(0, 0, w, h);

            const centerX = w / 2;
            const centerY = h / 2;

            // Isometric projection with rotation
            walk3D.angle += 0.005;
            const cosA = Math.cos(walk3D.angle);
            const sinA = Math.sin(walk3D.angle);

            function project(x, y, z) {
                // Rotate around Y axis
                const rx = x * cosA - z * sinA;
                const rz = x * sinA + z * cosA;
                // Isometric projection
                const px = rx * 0.8 - y * 0.4;
                const py = -rz * 0.5 - y * 0.4;
                return { x: px, y: py };
            }

            // Calculate scale
            let maxDist = 20;
            walk3D.history.forEach(p => {
                maxDist = Math.max(maxDist, Math.abs(p.x), Math.abs(p.y), Math.abs(p.z));
            });
            const scale = Math.min(w, h) * 0.3 / maxDist;

            // Draw axes
            ctx3D.strokeStyle = 'rgba(138, 111, 223, 0.3)';
            ctx3D.lineWidth = 1;
            const axisLen = 30;
            [
                {x: axisLen, y: 0, z: 0},
                {x: 0, y: axisLen, z: 0},
                {x: 0, y: 0, z: axisLen}
            ].forEach(axis => {
                const p = project(axis.x, axis.y, axis.z);
                ctx3D.beginPath();
                ctx3D.moveTo(centerX, centerY);
                ctx3D.lineTo(centerX + p.x * 3, centerY + p.y * 3);
                ctx3D.stroke();
            });

            // Draw path
            if (walk3D.history.length > 1) {
                for (let i = 1; i < walk3D.history.length; i++) {
                    const alpha = i / walk3D.history.length;
                    ctx3D.strokeStyle = `rgba(255, 107, 157, ${alpha * 0.8})`;
                    ctx3D.lineWidth = 1 + alpha;

                    const p1 = project(
                        walk3D.history[i-1].x * scale,
                        walk3D.history[i-1].y * scale,
                        walk3D.history[i-1].z * scale
                    );
                    const p2 = project(
                        walk3D.history[i].x * scale,
                        walk3D.history[i].y * scale,
                        walk3D.history[i].z * scale
                    );

                    ctx3D.beginPath();
                    ctx3D.moveTo(centerX + p1.x, centerY + p1.y);
                    ctx3D.lineTo(centerX + p2.x, centerY + p2.y);
                    ctx3D.stroke();
                }
            }

            // Origin
            ctx3D.fillStyle = '#8a6fdf';
            ctx3D.beginPath();
            ctx3D.arc(centerX, centerY, 5, 0, Math.PI * 2);
            ctx3D.fill();

            // Current position
            const currP = project(walk3D.x * scale, walk3D.y * scale, walk3D.z * scale);
            ctx3D.fillStyle = '#ff6b9d';
            ctx3D.shadowColor = '#ff6b9d';
            ctx3D.shadowBlur = 10;
            ctx3D.beginPath();
            ctx3D.arc(centerX + currP.x, centerY + currP.y, 6, 0, Math.PI * 2);
            ctx3D.fill();
            ctx3D.shadowBlur = 0;
        }

        function updateStats() {
            document.getElementById('steps1D').textContent = walk1D.steps.toLocaleString();
            document.getElementById('returns1D').textContent = walk1D.returns.toLocaleString();
            document.getElementById('pos1D').textContent = walk1D.pos;

            document.getElementById('steps2D').textContent = walk2D.steps.toLocaleString();
            document.getElementById('returns2D').textContent = walk2D.returns.toLocaleString();
            document.getElementById('pos2D').textContent = `(${walk2D.x}, ${walk2D.y})`;

            document.getElementById('steps3D').textContent = walk3D.steps.toLocaleString();
            document.getElementById('returns3D').textContent = walk3D.returns.toLocaleString();
            const dist3D = Math.sqrt(walk3D.x**2 + walk3D.y**2 + walk3D.z**2).toFixed(1);
            document.getElementById('pos3D').textContent = dist3D;
        }

        function reset() {
            walk1D.pos = 0;
            walk1D.steps = 0;
            walk1D.returns = 0;
            walk1D.history = [0];

            walk2D.x = 0;
            walk2D.y = 0;
            walk2D.steps = 0;
            walk2D.returns = 0;
            walk2D.history = [{x: 0, y: 0}];

            walk3D.x = 0;
            walk3D.y = 0;
            walk3D.z = 0;
            walk3D.steps = 0;
            walk3D.returns = 0;
            walk3D.history = [{x: 0, y: 0, z: 0}];

            ctx1D.clearRect(0, 0, canvas1D.width, canvas1D.height);
            ctx2D.clearRect(0, 0, canvas2D.width, canvas2D.height);
            ctx3D.clearRect(0, 0, canvas3D.width, canvas3D.height);
            updateStats();
        }

        function animate() {
            if (running) {
                for (let i = 0; i < speed; i++) {
                    step1D();
                    step2D();
                    step3D();
                }
            }

            draw1D();
            draw2D();
            draw3D();
            updateStats();

            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', function() {
            running = !running;
            this.textContent = running ? 'Pause' : 'Start Walking';
            this.classList.toggle('active', running);
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        document.getElementById('speedSlider').addEventListener('input', function() {
            speed = parseInt(this.value);
            document.getElementById('speedVal').textContent = speed;
        });

        // Start
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
