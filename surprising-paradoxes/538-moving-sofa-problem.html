<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Moving Sofa Problem - A 58-Year Mathematical Quest</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a0a1a 0%, #2a1a2a 50%, #1a1a2a 100%);
            min-height: 100vh;
            color: #f0e8f0;
            line-height: 1.9;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 12px 24px;
            background: rgba(200,100,255,0.15);
            backdrop-filter: blur(10px);
            color: #d4a0ff;
            text-decoration: none;
            border-radius: 30px;
            font-size: 14px;
            z-index: 1000;
            transition: all 0.3s;
            border: 1px solid rgba(200,100,255,0.3);
        }

        .back-link:hover {
            background: rgba(200,100,255,0.3);
            transform: translateX(-5px);
        }

        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 80px 30px 60px;
        }

        header {
            text-align: center;
            margin-bottom: 60px;
        }

        h1 {
            font-size: 3.2rem;
            font-weight: 400;
            background: linear-gradient(135deg, #d4a0ff, #ffa0d4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
            letter-spacing: 1px;
        }

        .subtitle {
            font-size: 1.5rem;
            color: #b088c8;
            font-style: italic;
        }

        .solved-badge {
            display: inline-block;
            background: linear-gradient(135deg, #4CAF50, #8BC34A);
            color: white;
            padding: 8px 20px;
            border-radius: 30px;
            font-size: 0.9rem;
            font-weight: 600;
            margin-top: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .paradox-statement {
            background: linear-gradient(135deg, rgba(212,160,255,0.15) 0%, rgba(255,160,212,0.1) 100%);
            border-left: 4px solid #d4a0ff;
            padding: 35px 45px;
            margin: 50px 0;
            border-radius: 0 20px 20px 0;
            font-size: 1.35rem;
            text-align: center;
            color: #d0b8e0;
        }

        .paradox-statement strong {
            color: #ffa0d4;
        }

        h2 {
            font-size: 1.9rem;
            color: #d4a0ff;
            margin: 60px 0 30px;
            font-weight: 400;
            border-bottom: 1px solid rgba(212,160,255,0.2);
            padding-bottom: 15px;
        }

        h3 {
            font-size: 1.4rem;
            color: #ffa0d4;
            margin: 40px 0 20px;
            font-weight: 400;
        }

        p {
            margin-bottom: 22px;
            color: #c0a8d0;
            font-size: 1.1rem;
        }

        .highlight {
            color: #ffa0d4;
            font-weight: 500;
        }

        .simulation-container {
            background: rgba(40,20,40,0.6);
            border-radius: 20px;
            padding: 35px;
            margin: 50px 0;
            border: 1px solid rgba(212,160,255,0.2);
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
        }

        .sim-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .sim-title {
            font-size: 1.3rem;
            color: #d4a0ff;
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            background: rgba(212,160,255,0.2);
            border: 1px solid rgba(212,160,255,0.5);
            color: #d4a0ff;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            font-family: inherit;
        }

        button:hover {
            background: rgba(212,160,255,0.4);
            transform: translateY(-2px);
        }

        button.active {
            background: linear-gradient(135deg, #d4a0ff, #ffa0d4);
            color: #1a0a1a;
            font-weight: 600;
        }

        select {
            background: rgba(212,160,255,0.2);
            border: 1px solid rgba(212,160,255,0.5);
            color: #d4a0ff;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 14px;
            cursor: pointer;
            font-family: inherit;
        }

        select option {
            background: #2a1a2a;
            color: #d4a0ff;
        }

        canvas {
            width: 100%;
            border-radius: 12px;
            background: rgba(10,5,15,0.8);
        }

        .stats-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 20px;
            margin-top: 30px;
            padding-top: 25px;
            border-top: 1px solid rgba(212,160,255,0.2);
        }

        .stat {
            text-align: center;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 300;
            color: #ffa0d4;
            font-family: 'Courier New', monospace;
        }

        .stat-label {
            font-size: 11px;
            color: #b088c8;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 5px;
        }

        .timeline {
            position: relative;
            padding-left: 30px;
            margin: 40px 0;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: linear-gradient(to bottom, #d4a0ff, #ffa0d4);
            border-radius: 2px;
        }

        .timeline-item {
            position: relative;
            margin-bottom: 30px;
            padding-left: 25px;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -34px;
            top: 8px;
            width: 12px;
            height: 12px;
            background: #d4a0ff;
            border-radius: 50%;
            border: 3px solid #1a0a1a;
        }

        .timeline-year {
            color: #ffa0d4;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .timeline-text {
            color: #c0a8d0;
            margin-top: 5px;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }

        .comparison-card {
            background: rgba(0,0,0,0.3);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(212,160,255,0.15);
            text-align: center;
            transition: all 0.3s;
        }

        .comparison-card:hover {
            transform: translateY(-5px);
            border-color: rgba(255,160,212,0.4);
        }

        .comparison-card h4 {
            color: #d4a0ff;
            margin-bottom: 10px;
            font-weight: 400;
        }

        .comparison-card .area {
            font-size: 2rem;
            color: #ffa0d4;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
        }

        .comparison-card p {
            font-size: 0.9rem;
            color: #a088b8;
            margin: 0;
        }

        .insight-box {
            background: linear-gradient(135deg, rgba(255,200,100,0.1) 0%, rgba(255,150,100,0.1) 100%);
            border-left: 4px solid #ffcc66;
            padding: 25px 30px;
            margin: 40px 0;
            border-radius: 0 15px 15px 0;
        }

        .insight-box strong {
            color: #ffcc66;
        }

        .math-box {
            background: rgba(100,50,150,0.2);
            padding: 25px 35px;
            border-radius: 15px;
            font-family: 'Courier New', monospace;
            text-align: center;
            margin: 30px 0;
            font-size: 1.2rem;
            color: #d4a0ff;
            border: 1px solid rgba(212,160,255,0.2);
        }

        footer {
            text-align: center;
            margin-top: 80px;
            padding: 40px 0;
            border-top: 1px solid rgba(212,160,255,0.2);
            color: #7a6888;
            font-size: 0.9rem;
        }

        footer a {
            color: #d4a0ff;
            text-decoration: none;
        }

        @media (max-width: 768px) {
            h1 { font-size: 2.2rem; }
            .container { padding: 60px 20px 40px; }
            .simulation-container { padding: 20px; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>The Moving Sofa Problem</h1>
            <p class="subtitle">What's the largest shape that can navigate an L-shaped corner?</p>
            <div class="solved-badge">Solved November 2024</div>
        </header>

        <div class="paradox-statement">
            <strong>The Problem:</strong> You're moving a sofa through an L-shaped hallway.
            What's the <strong>largest possible sofa</strong> that can make it around the corner?
            After 58 years, mathematicians finally have the answer: <strong>2.2195...</strong>
        </div>

        <h2>A Deceptively Simple Question</h2>

        <p>
            Everyone who has ever moved furniture knows the frustration: that perfect couch that
            just won't fit around the corner. In 1966, mathematician Leo Moser transformed this
            everyday annoyance into one of geometry's most stubborn problems.
        </p>

        <p>
            The rules are simple: an L-shaped corridor with unit width (1 meter). A rigid 2D shape
            must slide through, rotating as needed, without overlapping the walls.
            <span class="highlight">What's the maximum area this shape can have?</span>
        </p>

        <p>
            Surely, with modern mathematics and computers, this should be trivial? Yet for nearly
            six decades, the best minds in geometry could only narrow down the answer to a range.
            Until November 2024.
        </p>

        <h2>Watch It Move</h2>

        <div class="simulation-container">
            <div class="sim-header">
                <div class="sim-title">Interactive Sofa Navigator</div>
                <div class="controls">
                    <select id="sofaType">
                        <option value="gerver">Gerver's Sofa (Optimal)</option>
                        <option value="hammersley">Hammersley's Sofa</option>
                        <option value="semicircle">Semicircle</option>
                        <option value="rectangle">Rectangle</option>
                    </select>
                    <button id="playBtn">Play</button>
                    <button id="resetBtn">Reset</button>
                </div>
            </div>

            <canvas id="mainCanvas" height="500"></canvas>

            <div class="stats-panel">
                <div class="stat">
                    <div class="stat-value" id="areaValue">2.2195</div>
                    <div class="stat-label">Area</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="progressValue">0%</div>
                    <div class="stat-label">Progress</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="rotationValue">0°</div>
                    <div class="stat-label">Rotation</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="statusValue">Ready</div>
                    <div class="stat-label">Status</div>
                </div>
            </div>
        </div>

        <h2>A Brief History of Sofa Optimization</h2>

        <div class="timeline">
            <div class="timeline-item">
                <div class="timeline-year">1966</div>
                <div class="timeline-text">Leo Moser poses the problem. Initial bound: a semicircle has area π/2 ≈ 1.57</div>
            </div>
            <div class="timeline-item">
                <div class="timeline-year">1968</div>
                <div class="timeline-text">John Hammersley designs a "telephone" shape with a semicircular bite, achieving area π/2 + 2/π ≈ 2.2074</div>
            </div>
            <div class="timeline-item">
                <div class="timeline-year">1992</div>
                <div class="timeline-text">Joseph Gerver constructs a sofa from 18 analytic curves, area ≈ 2.2195. Conjectures it's optimal.</div>
            </div>
            <div class="timeline-item">
                <div class="timeline-year">2018</div>
                <div class="timeline-text">Kallus and Romik prove upper bound of 2.37—no sofa can be larger than this.</div>
            </div>
            <div class="timeline-item">
                <div class="timeline-year">November 2024</div>
                <div class="timeline-text"><strong>Jineon Baek proves Gerver's sofa is optimal!</strong> The 58-year quest is complete.</div>
            </div>
        </div>

        <h2>Compare the Shapes</h2>

        <div class="comparison-grid">
            <div class="comparison-card">
                <h4>Rectangle</h4>
                <div class="area">1.00</div>
                <p>The naive solution. A 1×1 square just barely fits.</p>
            </div>
            <div class="comparison-card">
                <h4>Semicircle</h4>
                <div class="area">1.57</div>
                <p>π/2—a natural first improvement using circular motion.</p>
            </div>
            <div class="comparison-card">
                <h4>Hammersley</h4>
                <div class="area">2.21</div>
                <p>A semicircle with a bite taken out. Major breakthrough.</p>
            </div>
            <div class="comparison-card">
                <h4>Gerver (Optimal)</h4>
                <div class="area">2.2195</div>
                <p>18 precise curves. Proven optimal in 2024.</p>
            </div>
        </div>

        <h2>Why Was This So Hard?</h2>

        <p>
            The difficulty lies in the continuous nature of the problem. Unlike discrete puzzles
            with finite possibilities, the sofa can be <em>any</em> shape. Every curve, every
            indentation, every bulge must be considered.
        </p>

        <div class="insight-box">
            <p><strong>The Core Insight:</strong> The sofa must rotate as it navigates the corner.
            This means different parts of the sofa sweep different paths. The optimal shape
            balances two competing goals: maximize area while ensuring every point can complete
            its required trajectory.</p>
        </div>

        <p>
            Gerver's breakthrough was recognizing that the optimal sofa's boundary consists of
            18 distinct curves, each satisfying specific differential equations. The shape has:
        </p>

        <ul style="color: #c0a8d0; margin: 20px 0 30px 40px; line-height: 2;">
            <li>A rounded outer edge that hugs the outer wall</li>
            <li>A precise inner cutout that clears the corner</li>
            <li>Beveled transitions between segments</li>
            <li>3 straight line segments and 15 curved pieces</li>
        </ul>

        <div class="math-box">
            Area = 2.2195316688...
            <br>
            <span style="font-size: 0.9rem; color: #a088b8;">
                (approximately π/2 + 2/π + tiny optimizations)
            </span>
        </div>

        <h2>The Ambidextrous Variant</h2>

        <p>
            John Conway posed a variant: what if the sofa must navigate both left AND right turns?
            This "ambidextrous sofa" problem has a different optimal shape—symmetric and smaller.
        </p>

        <p>
            Dan Romik found such a sofa with area ≈ 1.64495. The constraint of bilateral
            navigation significantly reduces the maximum achievable area.
        </p>

        <h2>Real-World Implications</h2>

        <p>
            While purely mathematical, the moving sofa problem connects to practical concerns in:
        </p>

        <div class="comparison-grid" style="grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));">
            <div class="comparison-card">
                <h4>Robotics</h4>
                <p>Path planning for autonomous vehicles and warehouse robots navigating tight spaces.</p>
            </div>
            <div class="comparison-card">
                <h4>Manufacturing</h4>
                <p>Designing machinery that must be transported through factory corridors.</p>
            </div>
            <div class="comparison-card">
                <h4>Architecture</h4>
                <p>Understanding furniture accessibility when designing building layouts.</p>
            </div>
        </div>

        <h2>The Deeper Lesson</h2>

        <p>
            The moving sofa problem reminds us that <span class="highlight">simple questions can
            hide profound complexity</span>. A child can understand the problem in seconds.
            Proving the answer took humanity 58 years.
        </p>

        <div class="paradox-statement">
            "The simplest-sounding problems are often the hardest to solve—because simplicity
            in statement doesn't imply simplicity in structure."
        </div>

        <footer>
            <p>Part of the <a href="../index.html">CCAB</a> Surprising Paradoxes collection</p>
            <p>Sources: <a href="https://en.wikipedia.org/wiki/Moving_sofa_problem">Wikipedia</a> ·
            <a href="https://www.scientificamerican.com/article/mathematicians-solve-infamous-moving-sofa-problem/">Scientific American</a> ·
            <a href="https://www.math.ucdavis.edu/~romik/movingsofa">Dan Romik</a> ·
            <a href="https://mathworld.wolfram.com/GerverSofa.html">Wolfram MathWorld</a></p>
        </footer>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        // High DPI support
        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
        }

        // Sofa definitions
        const sofas = {
            gerver: {
                name: "Gerver's Sofa",
                area: 2.2195,
                color: '#d4a0ff',
                // Approximation of Gerver's shape
                getPath: function(scale) {
                    const path = [];
                    const w = 2.0 * scale;  // width
                    const h = 1.0 * scale;  // height
                    const r = 0.6 * scale;  // main radius
                    const cr = 0.35 * scale; // cutout radius

                    // Right semicircle
                    for (let a = -Math.PI/2; a <= Math.PI/2; a += 0.05) {
                        path.push({
                            x: w/2 - r + Math.cos(a) * r,
                            y: Math.sin(a) * r
                        });
                    }

                    // Top edge with slight curve (beveled)
                    const topY = r * 0.92;
                    path.push({ x: -w/2 + r * 0.7, y: topY });

                    // Left rounded corner
                    for (let a = Math.PI/2; a <= Math.PI; a += 0.05) {
                        path.push({
                            x: -w/2 + r * 0.7 + Math.cos(a) * r * 0.3,
                            y: topY - r * 0.3 + Math.sin(a) * r * 0.3
                        });
                    }

                    // Left edge
                    path.push({ x: -w/2 + r * 0.4, y: -topY + r * 0.3 });

                    // Left bottom rounded corner
                    for (let a = Math.PI; a <= 3*Math.PI/2; a += 0.05) {
                        path.push({
                            x: -w/2 + r * 0.7 + Math.cos(a) * r * 0.3,
                            y: -topY + r * 0.3 + Math.sin(a) * r * 0.3
                        });
                    }

                    // Bottom left
                    path.push({ x: -cr * 1.2, y: -topY });

                    // Inner cutout (Gerver has beveled edges here)
                    const bevel = 0.08 * scale;
                    path.push({ x: -cr * 1.1, y: -topY + bevel });

                    // Inner semicircular cutout
                    for (let a = -Math.PI/2; a >= -3*Math.PI/2; a -= 0.05) {
                        const cutR = cr * 0.85;
                        path.push({
                            x: Math.cos(a) * cutR,
                            y: -topY + cr + Math.sin(a) * cutR + cr * 0.15
                        });
                    }

                    path.push({ x: cr * 1.1, y: -topY + bevel });
                    path.push({ x: cr * 1.2, y: -topY });

                    // Bottom right edge back to start
                    path.push({ x: w/2 - r, y: -r });

                    return path;
                }
            },
            hammersley: {
                name: "Hammersley's Sofa",
                area: 2.2074,
                color: '#a0d4ff',
                getPath: function(scale) {
                    const path = [];
                    const w = 2.0 * scale;
                    const r = 0.5 * scale;
                    const cr = 0.318 * scale; // 2/π cutout radius

                    // Outer semicircle
                    for (let a = -Math.PI/2; a <= Math.PI/2; a += 0.05) {
                        path.push({
                            x: w/2 - r + Math.cos(a) * r,
                            y: Math.sin(a) * r
                        });
                    }

                    // Top edge
                    path.push({ x: -w/2 + r, y: r });

                    // Left semicircle
                    for (let a = Math.PI/2; a <= 3*Math.PI/2; a += 0.05) {
                        path.push({
                            x: -w/2 + r + Math.cos(a) * r,
                            y: Math.sin(a) * r
                        });
                    }

                    // Bottom left
                    path.push({ x: -cr, y: -r });

                    // Inner semicircular cutout
                    for (let a = -Math.PI/2; a >= -3*Math.PI/2; a -= 0.05) {
                        path.push({
                            x: Math.cos(a) * cr,
                            y: -r + cr + Math.sin(a) * cr
                        });
                    }

                    // Bottom right
                    path.push({ x: w/2 - r, y: -r });

                    return path;
                }
            },
            semicircle: {
                name: "Semicircle",
                area: 1.5708,
                color: '#a0ffd4',
                getPath: function(scale) {
                    const path = [];
                    const r = 0.5 * scale;

                    for (let a = 0; a <= Math.PI; a += 0.05) {
                        path.push({
                            x: Math.cos(a) * r * 2,
                            y: Math.sin(a) * r
                        });
                    }

                    path.push({ x: -r * 2, y: 0 });

                    return path;
                }
            },
            rectangle: {
                name: "Rectangle",
                area: 1.0000,
                color: '#ffd4a0',
                getPath: function(scale) {
                    const s = 0.5 * scale;
                    return [
                        { x: -s, y: -s },
                        { x: s, y: -s },
                        { x: s, y: s },
                        { x: -s, y: s }
                    ];
                }
            }
        };

        // Animation state
        let currentSofa = 'gerver';
        let animationProgress = 0;
        let isPlaying = false;
        let animationId = null;

        // Corridor dimensions
        const corridorWidth = 80;

        function getCorridorPath(w, h) {
            const cw = corridorWidth;
            const cx = w * 0.5;
            const cy = h * 0.5;

            return {
                // Outer walls
                outer: [
                    { x: cx - cw * 2.5, y: cy - cw },  // Top left of horizontal
                    { x: cx, y: cy - cw },              // Corner outer top
                    { x: cx, y: cy - cw * 2.5 },        // Top of vertical
                    { x: cx + cw, y: cy - cw * 2.5 },   // Top right of vertical
                    { x: cx + cw, y: cy },              // Corner outer right
                    { x: cx + cw * 2.5, y: cy },        // Right end of horizontal
                    { x: cx + cw * 2.5, y: cy + cw },   // Bottom right
                    { x: cx - cw * 2.5, y: cy + cw },   // Bottom left
                ],
                // Inner corner
                inner: { x: cx, y: cy },
                center: { x: cx, y: cy },
                width: cw
            };
        }

        function getSofaTransform(progress, corridor) {
            const cw = corridor.width;
            const cx = corridor.center.x;
            const cy = corridor.center.y;

            // Path: enter from left, rotate around corner, exit upward
            let x, y, rotation;

            if (progress < 0.33) {
                // Phase 1: Moving right in horizontal corridor
                const p = progress / 0.33;
                x = cx - cw * 2 + p * cw * 1.5;
                y = cy;
                rotation = 0;
            } else if (progress < 0.67) {
                // Phase 2: Rotating around corner
                const p = (progress - 0.33) / 0.34;
                const angle = p * Math.PI / 2;

                // Pivot point near inner corner
                const pivotX = cx + cw * 0.3;
                const pivotY = cy - cw * 0.3;
                const radius = cw * 0.8;

                x = pivotX - Math.cos(angle) * radius * 0.5 + Math.sin(angle) * radius * 0.3;
                y = pivotY + Math.sin(angle) * radius * 0.5 + Math.cos(angle) * radius * 0.3;
                rotation = angle;
            } else {
                // Phase 3: Moving up in vertical corridor
                const p = (progress - 0.67) / 0.33;
                x = cx + cw * 0.5;
                y = cy - cw * 0.5 - p * cw * 1.5;
                rotation = Math.PI / 2;
            }

            return { x, y, rotation };
        }

        function drawCorridor(w, h) {
            const corridor = getCorridorPath(w, h);
            const cw = corridor.width;

            // Background gradient
            const gradient = ctx.createLinearGradient(0, 0, w, h);
            gradient.addColorStop(0, '#1a0a1a');
            gradient.addColorStop(1, '#2a1a2a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, w, h);

            // Draw corridor (white space)
            ctx.fillStyle = 'rgba(60, 40, 60, 0.8)';

            // Horizontal part
            ctx.fillRect(
                corridor.center.x - cw * 2.5,
                corridor.center.y - cw,
                cw * 3.5,
                cw * 2
            );

            // Vertical part
            ctx.fillRect(
                corridor.center.x,
                corridor.center.y - cw * 2.5,
                cw,
                cw * 2.5
            );

            // Walls with glow
            ctx.strokeStyle = '#d4a0ff';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#d4a0ff';
            ctx.shadowBlur = 10;

            // Outer walls
            ctx.beginPath();
            const outer = corridor.outer;
            ctx.moveTo(outer[0].x, outer[0].y);
            for (let i = 1; i < outer.length; i++) {
                ctx.lineTo(outer[i].x, outer[i].y);
            }
            ctx.closePath();
            ctx.stroke();

            // Inner corner
            ctx.beginPath();
            ctx.moveTo(corridor.inner.x, corridor.inner.y - cw);
            ctx.lineTo(corridor.inner.x, corridor.inner.y);
            ctx.lineTo(corridor.inner.x + cw, corridor.inner.y);
            ctx.stroke();

            ctx.shadowBlur = 0;

            // Corner highlight
            ctx.fillStyle = '#ffa0d4';
            ctx.beginPath();
            ctx.arc(corridor.inner.x, corridor.inner.y, 5, 0, Math.PI * 2);
            ctx.fill();

            return corridor;
        }

        function drawSofa(sofa, transform, scale) {
            const path = sofa.getPath(scale);

            ctx.save();
            ctx.translate(transform.x, transform.y);
            ctx.rotate(transform.rotation);

            // Shadow
            ctx.shadowColor = sofa.color;
            ctx.shadowBlur = 20;

            // Fill
            ctx.fillStyle = sofa.color + '40';
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.closePath();
            ctx.fill();

            // Stroke
            ctx.strokeStyle = sofa.color;
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function draw() {
            const w = canvas.getBoundingClientRect().width;
            const h = canvas.getBoundingClientRect().height;

            const corridor = drawCorridor(w, h);

            const sofa = sofas[currentSofa];
            const transform = getSofaTransform(animationProgress, corridor);
            const scale = corridorWidth * 0.9;

            drawSofa(sofa, transform, scale);

            // Update stats
            document.getElementById('areaValue').textContent = sofa.area.toFixed(4);
            document.getElementById('progressValue').textContent = Math.round(animationProgress * 100) + '%';
            document.getElementById('rotationValue').textContent = Math.round(transform.rotation * 180 / Math.PI) + '°';
            document.getElementById('statusValue').textContent = isPlaying ? 'Moving' : 'Paused';
        }

        function animate() {
            if (isPlaying) {
                animationProgress += 0.003;
                if (animationProgress >= 1) {
                    animationProgress = 0;
                }
            }
            draw();
            animationId = requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('playBtn').addEventListener('click', () => {
            isPlaying = !isPlaying;
            document.getElementById('playBtn').textContent = isPlaying ? 'Pause' : 'Play';
            document.getElementById('playBtn').classList.toggle('active', isPlaying);
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            animationProgress = 0;
            isPlaying = false;
            document.getElementById('playBtn').textContent = 'Play';
            document.getElementById('playBtn').classList.remove('active');
        });

        document.getElementById('sofaType').addEventListener('change', (e) => {
            currentSofa = e.target.value;
            animationProgress = 0;
        });

        window.addEventListener('resize', () => {
            setupCanvas();
        });

        // Initialize
        setupCanvas();
        animate();
    </script>
</body>
</html>
