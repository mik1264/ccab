<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galloping Bubbles - Defying Physics | Surprising Paradoxes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #0a1929 0%, #1a4971 50%, #0d2847 100%);
            color: #e0f4ff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #64b5f6;
            text-decoration: none;
            font-size: 14px;
            z-index: 1000;
            padding: 8px 16px;
            background: rgba(10, 25, 41, 0.9);
            border-radius: 20px;
            border: 1px solid rgba(100, 181, 246, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(100, 181, 246, 0.2);
            border-color: #64b5f6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 80px 20px 40px;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(135deg, #64b5f6, #81d4fa, #4fc3f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #81d4fa;
            font-size: 1.2em;
            font-style: italic;
        }

        .paradox-box {
            background: linear-gradient(135deg, rgba(100, 181, 246, 0.15), rgba(129, 212, 250, 0.1));
            border: 2px solid rgba(100, 181, 246, 0.4);
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
            text-align: center;
        }

        .paradox-box h3 {
            color: #4fc3f7;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .paradox-box p {
            font-size: 1.15em;
            line-height: 1.7;
            color: #e3f2fd;
        }

        .discovery-badge {
            display: inline-block;
            background: linear-gradient(135deg, #00bcd4, #00acc1);
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 0.85em;
            margin-top: 15px;
            font-weight: 500;
        }

        .simulation-area {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 30px;
            margin: 40px 0;
        }

        @media (max-width: 1000px) {
            .simulation-area {
                grid-template-columns: 1fr;
            }
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(100, 181, 246, 0.2);
        }

        canvas {
            display: block;
            width: 100%;
            border-radius: 10px;
            background: linear-gradient(180deg, #0a1a2e 0%, #1a3a5c 100%);
        }

        .controls {
            background: rgba(10, 25, 41, 0.8);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(100, 181, 246, 0.2);
        }

        .controls h3 {
            color: #64b5f6;
            margin-bottom: 20px;
            font-size: 1.2em;
            border-bottom: 1px solid rgba(100, 181, 246, 0.3);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: #81d4fa;
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #0277bd, #0288d1, #039be5);
            border-radius: 4px;
            outline: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #4fc3f7;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
        }

        .threshold-indicator {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .threshold-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .threshold-dot.below {
            background: #78909c;
            box-shadow: none;
        }

        .threshold-dot.above {
            background: #4fc3f7;
            box-shadow: 0 0 10px #4fc3f7;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .threshold-text {
            color: #b0bec5;
            font-size: 0.85em;
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .mode-btn {
            padding: 12px 8px;
            font-size: 0.85em;
            border: 1px solid rgba(100, 181, 246, 0.5);
            background: rgba(10, 25, 41, 0.8);
            color: #e0f4ff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, rgba(100, 181, 246, 0.3), rgba(79, 195, 247, 0.2));
            border-color: #4fc3f7;
        }

        .mode-btn:hover {
            background: rgba(100, 181, 246, 0.2);
        }

        .stats-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(100, 181, 246, 0.1);
            font-size: 0.9em;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #4dd0e1;
        }

        .stat-value {
            color: #81d4fa;
            font-weight: bold;
        }

        .essay {
            background: rgba(10, 25, 41, 0.6);
            border-radius: 15px;
            padding: 40px;
            margin-top: 40px;
            line-height: 1.9;
        }

        .essay h2 {
            color: #64b5f6;
            margin: 30px 0 20px;
            font-size: 1.5em;
        }

        .essay h2:first-child {
            margin-top: 0;
        }

        .essay p {
            margin-bottom: 20px;
            color: #b3e5fc;
            text-align: justify;
        }

        .essay strong {
            color: #4fc3f7;
        }

        .essay em {
            color: #80deea;
            font-style: italic;
        }

        .highlight-stat {
            display: inline-block;
            background: linear-gradient(135deg, rgba(79, 195, 247, 0.2), rgba(100, 181, 246, 0.2));
            padding: 2px 10px;
            border-radius: 4px;
            color: #80deea;
            font-weight: bold;
        }

        .application-cards {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 30px 0;
        }

        @media (max-width: 768px) {
            .application-cards {
                grid-template-columns: 1fr;
            }
        }

        .app-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(100, 181, 246, 0.2);
        }

        .app-card h4 {
            color: #64b5f6;
            margin-bottom: 10px;
        }

        .app-card p {
            font-size: 0.9em;
            color: #78909c;
            margin: 0;
        }

        .app-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        footer {
            text-align: center;
            padding: 40px 20px;
            color: #546e7a;
            font-size: 0.9em;
        }

        footer a {
            color: #64b5f6;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>ü´ß Galloping Bubbles</h1>
            <p class="subtitle">Shake Up-Down, Watch Them Run Sideways</p>
        </header>

        <div class="paradox-box">
            <h3>üé† The Perpendicular Paradox</h3>
            <p>
                Shake a container of liquid <strong>up and down</strong>. Where do you expect bubbles to go?
                Up and down, obviously. But above a certain threshold, bubbles spontaneously break symmetry
                and start moving <strong>horizontally</strong>‚Äîperpendicular to the shaking! They "gallop"
                across surfaces like tiny horses, bouncing and zigzagging. This impossible-seeming motion
                was just discovered in <strong>February 2025</strong>.
            </p>
            <span class="discovery-badge">üî¨ Published Feb 2025 in Nature Communications</span>
        </div>

        <div class="simulation-area">
            <div class="canvas-container">
                <canvas id="bubbleCanvas"></canvas>
            </div>

            <div class="controls">
                <h3>‚öóÔ∏è Vibration Chamber</h3>

                <div class="control-group">
                    <label>Shaking Amplitude: <span id="ampValue">1.5</span></label>
                    <input type="range" id="ampSlider" min="0.5" max="3.0" step="0.1" value="1.5">
                    <div class="threshold-indicator">
                        <div class="threshold-dot below" id="thresholdDot"></div>
                        <span class="threshold-text" id="thresholdText">Below galloping threshold</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Shaking Frequency: <span id="freqValue">40</span> Hz</label>
                    <input type="range" id="freqSlider" min="20" max="80" value="40">
                </div>

                <div class="control-group">
                    <label>Bubble Size: <span id="sizeValue">25</span> mm¬≥</label>
                    <input type="range" id="sizeSlider" min="10" max="50" value="25">
                </div>

                <div class="control-group">
                    <label>Motion Regime</label>
                    <div class="mode-buttons">
                        <button class="mode-btn active" data-mode="rectilinear">üìè Rectilinear</button>
                        <button class="mode-btn" data-mode="orbital">üîÑ Orbital</button>
                        <button class="mode-btn" data-mode="tumble">üé≤ Run-Tumble</button>
                        <button class="mode-btn" data-mode="cleaning">üßπ Cleaning</button>
                    </div>
                </div>

                <div class="stats-panel">
                    <div class="stat-row">
                        <span class="stat-label">Bubble State</span>
                        <span class="stat-value" id="bubbleState">Stationary</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Horizontal Velocity</span>
                        <span class="stat-value" id="hVelocity">0 mm/s</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Shape Mode</span>
                        <span class="stat-value" id="shapeMode">Axisymmetric</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Symmetry</span>
                        <span class="stat-value" id="symmetry">Preserved</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="essay">
            <h2>A Simple Question, Impossible Answer</h2>
            <p>
                In early 2025, researchers at the University of North Carolina and Princeton University
                asked what seemed like a simple question: <em>Could shaking bubbles up and down make
                them move continuously in one direction?</em> Classical intuition says no‚Äîvertical
                oscillation should produce vertical motion. But when they ran the experiment, something
                extraordinary happened. Above a critical amplitude, the bubbles didn't just wobble‚Äîthey
                started <strong>galloping horizontally</strong>, perpendicular to the driving force,
                like tiny horses racing across the liquid surface.
            </p>

            <h2>The Symmetry-Breaking Moment</h2>
            <p>
                At low shaking amplitudes, a <span class="highlight-stat">25 mm¬≥</span> bubble vibrated
                at <span class="highlight-stat">40 Hz</span> oscillates perfectly symmetrically‚Äîsquishing
                and stretching along the vertical axis like a tiny accordion. Its shape remains
                <em>axisymmetric</em>, and it stays in place. But increase the amplitude past a
                <strong>galloping threshold</strong>, and the symmetry spontaneously breaks. The bubble's
                oscillation mode shifts, creating asymmetric deformations that generate net propulsion.
                Without any horizontal force applied, the bubble starts moving sideways.
            </p>

            <h2>How Bubbles Swim Without Vortices</h2>
            <p>
                Most swimming organisms and propulsion systems rely on <strong>vortex shedding</strong>‚Äî
                pushing fluid backwards to move forwards. Galloping bubbles do something different. They
                leverage <em>inertial forces</em> through periodic body deformations. As the bubble
                shape oscillates asymmetrically, it essentially "ratchets" through the fluid, converting
                the external vertical vibration into horizontal translation. This mechanism works even
                when viscous traction (the usual way microorganisms swim) isn't viable‚Äîopening new
                possibilities for propulsion in low-friction environments.
            </p>

            <div class="application-cards">
                <div class="app-card">
                    <div class="app-icon">üßπ</div>
                    <h4>Surface Cleaning</h4>
                    <p>Galloping bubbles can clean dusty surfaces by bouncing and zigzagging across them‚Äîlike a tiny Roomba.</p>
                </div>
                <div class="app-card">
                    <div class="app-icon">üõ∞Ô∏è</div>
                    <h4>Space Applications</h4>
                    <p>In microgravity, where buoyancy doesn't work, shaking can move bubbles off critical equipment.</p>
                </div>
                <div class="app-card">
                    <div class="app-icon">üíä</div>
                    <h4>Drug Delivery</h4>
                    <p>Controllable bubble motion could enable targeted delivery of medications in biomedical applications.</p>
                </div>
            </div>

            <h2>Three Regimes of Motion</h2>
            <p>
                Depending on the driving parameters, galloping bubbles exhibit distinct trajectory regimes
                that can be <strong>dynamically tuned</strong>. In <em>rectilinear mode</em>, the bubble
                moves in a straight line across the surface. In <em>orbital mode</em>, it traces circular
                or elliptical paths. Most intriguingly, in <em>run-and-tumble mode</em>, the bubble
                alternates between straight runs and random direction changes‚Äîmimicking the behavior of
                bacteria searching for food. This tunability means researchers can control bubble
                trajectories simply by adjusting the vibration amplitude and frequency.
            </p>

            <h2>Award-Winning Visualization</h2>
            <p>
                The discovery was so visually striking that the research team's video entry won an award
                at the <strong>Gallery of Fluid Motion</strong>, organized by the American Physical
                Society. The footage shows bubbles transitioning from calm oscillation to energetic
                galloping as the amplitude crosses the threshold‚Äîa dramatic visualization of symmetry
                breaking in action. Published in <em>Nature Communications</em> in February 2025, this
                work adds a new chapter to our understanding of bubble dynamics and opens pathways for
                applications from industrial cleaning to space exploration.
            </p>

            <p>
                As lead author Jian Guan noted, the discovery shows that <em>"shaking up and down can
                make things move sideways"</em>‚Äîa sentence that would have seemed like nonsense until
                this research proved it true. Physics, once again, reminds us that intuition is often
                wrong, and the universe is stranger than we imagine.
            </p>
        </div>

        <footer>
            <p>
                Sources:
                <a href="https://www.nature.com/articles/s41467-025-56611-5">Nature Communications</a> |
                <a href="https://phys.org/news/2025-02-fluid-discovery-defies-logic.html">Phys.org</a> |
                <a href="https://scitechdaily.com/bubbles-that-defy-physics-scientists-uncover-a-mind-blowing-new-phenomenon/">SciTechDaily</a>
            </p>
        </footer>
    </div>

    <script>
        const canvas = document.getElementById('bubbleCanvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        // Parameters
        let amplitude = 1.5;
        let frequency = 40;
        let bubbleSize = 25;
        let motionMode = 'rectilinear';
        let time = 0;

        // Bubble state
        let bubbles = [];
        const GALLOP_THRESHOLD = 1.8;

        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const size = rect.width - 40;
            canvas.width = size * dpr;
            canvas.height = size * 0.75 * dpr;
            canvas.style.width = size + 'px';
            canvas.style.height = size * 0.75 + 'px';
            ctx.scale(dpr, dpr);
        }

        resizeCanvas();
        window.addEventListener('resize', () => {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            resizeCanvas();
            initBubbles();
        });

        class Bubble {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.baseSize = size;
                this.vx = 0;
                this.vy = 0;
                this.phase = Math.random() * Math.PI * 2;
                this.shapePhase = Math.random() * Math.PI * 2;
                this.tumbleTimer = 0;
                this.tumbleDir = Math.random() * Math.PI * 2;
                this.trail = [];
            }

            update(dt, containerOffset, w, h) {
                const isGalloping = amplitude >= GALLOP_THRESHOLD;
                const wallY = 40; // Top wall position

                // Store trail
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 100) this.trail.shift();

                // Vertical oscillation from container
                this.phase += dt * frequency * 0.1;
                this.shapePhase += dt * frequency * 0.15;

                if (isGalloping) {
                    // Galloping motion - perpendicular to shaking
                    const gallopStrength = (amplitude - GALLOP_THRESHOLD) * 0.5;

                    switch (motionMode) {
                        case 'rectilinear':
                            this.vx += gallopStrength * 0.3;
                            break;

                        case 'orbital':
                            const orbitalPhase = time * 0.02;
                            this.vx = Math.cos(orbitalPhase) * gallopStrength * 2;
                            this.vy = Math.sin(orbitalPhase) * gallopStrength * 0.5;
                            break;

                        case 'tumble':
                            this.tumbleTimer -= dt;
                            if (this.tumbleTimer <= 0) {
                                this.tumbleDir = Math.random() * Math.PI * 2;
                                this.tumbleTimer = 30 + Math.random() * 50;
                            }
                            this.vx += Math.cos(this.tumbleDir) * gallopStrength * 0.2;
                            this.vy += Math.sin(this.tumbleDir) * gallopStrength * 0.1;
                            break;

                        case 'cleaning':
                            // Zigzag cleaning pattern
                            const zigzag = Math.sin(time * 0.05) * gallopStrength;
                            this.vx += gallopStrength * 0.2;
                            this.vy += zigzag * 0.1;
                            break;
                    }

                    // Damping
                    this.vx *= 0.98;
                    this.vy *= 0.98;

                    // Move
                    this.x += this.vx;
                    this.y += this.vy;

                    // Bounce off walls
                    const margin = this.baseSize + 20;
                    if (this.x < margin) { this.x = margin; this.vx *= -0.8; }
                    if (this.x > w - margin) { this.x = margin; this.vx *= -0.8; }
                    if (this.y < wallY + this.baseSize) { this.y = wallY + this.baseSize; this.vy *= -0.5; }
                    if (this.y > h - margin) { this.y = h - margin; this.vy *= -0.5; }
                }

                // Keep bubble near top wall when galloping
                if (isGalloping) {
                    this.y = wallY + this.baseSize + Math.sin(this.phase) * 5;
                }
            }

            draw(ctx, containerOffset, isGalloping) {
                const oscillation = Math.sin(this.phase) * amplitude * 3;
                const drawY = this.y + containerOffset + oscillation;

                // Draw trail
                if (this.trail.length > 1 && isGalloping) {
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(100, 181, 246, 0.2)';
                    ctx.lineWidth = 2;
                    this.trail.forEach((pt, i) => {
                        const ty = pt.y + containerOffset + Math.sin(this.phase - i * 0.1) * amplitude * 3;
                        if (i === 0) ctx.moveTo(pt.x, ty);
                        else ctx.lineTo(pt.x, ty);
                    });
                    ctx.stroke();
                }

                // Calculate shape deformation
                let stretchX = 1;
                let stretchY = 1;

                if (isGalloping) {
                    // Asymmetric shape oscillation (broken symmetry)
                    stretchX = 1 + Math.sin(this.shapePhase) * 0.2 + Math.cos(this.shapePhase * 2) * 0.1;
                    stretchY = 1 - Math.sin(this.shapePhase) * 0.15;
                } else {
                    // Symmetric axial oscillation
                    stretchY = 1 + Math.sin(this.shapePhase * 2) * 0.15;
                    stretchX = 1 - Math.sin(this.shapePhase * 2) * 0.1;
                }

                // Draw bubble
                ctx.save();
                ctx.translate(this.x, drawY);

                // Bubble body
                const gradient = ctx.createRadialGradient(
                    -this.baseSize * 0.3, -this.baseSize * 0.3, 0,
                    0, 0, this.baseSize * stretchX
                );
                gradient.addColorStop(0, 'rgba(200, 230, 255, 0.9)');
                gradient.addColorStop(0.5, 'rgba(100, 181, 246, 0.6)');
                gradient.addColorStop(1, 'rgba(30, 136, 229, 0.3)');

                ctx.beginPath();
                ctx.scale(stretchX, stretchY);
                ctx.arc(0, 0, this.baseSize, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Highlight
                ctx.beginPath();
                ctx.arc(-this.baseSize * 0.3, -this.baseSize * 0.3, this.baseSize * 0.25, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fill();

                ctx.restore();
            }
        }

        function initBubbles() {
            const w = canvas.width / dpr;
            const h = canvas.height / dpr;
            bubbles = [];

            // Create bubbles
            const count = motionMode === 'cleaning' ? 5 : 3;
            for (let i = 0; i < count; i++) {
                const x = w * 0.2 + (i / count) * w * 0.6;
                const y = 80 + Math.random() * 20;
                bubbles.push(new Bubble(x, y, bubbleSize));
            }
        }

        function drawContainer(w, h, offset) {
            // Container walls
            ctx.strokeStyle = 'rgba(100, 181, 246, 0.6)';
            ctx.lineWidth = 3;

            const margin = 15;
            const containerTop = 30 + offset;
            const containerBottom = h - 30 + offset;

            // Left wall
            ctx.beginPath();
            ctx.moveTo(margin, containerTop);
            ctx.lineTo(margin, containerBottom);
            ctx.stroke();

            // Right wall
            ctx.beginPath();
            ctx.moveTo(w - margin, containerTop);
            ctx.lineTo(w - margin, containerBottom);
            ctx.stroke();

            // Bottom
            ctx.beginPath();
            ctx.moveTo(margin, containerBottom);
            ctx.lineTo(w - margin, containerBottom);
            ctx.stroke();

            // Top surface (where bubbles gallop)
            ctx.strokeStyle = 'rgba(129, 212, 250, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin, 40 + offset);
            ctx.lineTo(w - margin, 40 + offset);
            ctx.stroke();

            // Liquid fill
            const liquidGradient = ctx.createLinearGradient(0, containerTop, 0, containerBottom);
            liquidGradient.addColorStop(0, 'rgba(30, 136, 229, 0.1)');
            liquidGradient.addColorStop(1, 'rgba(21, 101, 192, 0.3)');

            ctx.fillStyle = liquidGradient;
            ctx.fillRect(margin + 3, 43 + offset, w - 2 * margin - 6, containerBottom - 43 - offset);

            // Vibration arrows
            const arrowSize = 20 + amplitude * 5;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';

            // Up arrow
            ctx.fillText('‚Üë', w - 40, h / 2 - arrowSize);
            // Down arrow
            ctx.fillText('‚Üì', w - 40, h / 2 + arrowSize);

            ctx.font = '12px Georgia';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.fillText('Vibration', w - 40, h / 2 + arrowSize + 20);
        }

        function drawDustParticles(w, h, offset) {
            if (motionMode !== 'cleaning') return;

            ctx.fillStyle = 'rgba(139, 119, 101, 0.6)';
            for (let i = 0; i < 30; i++) {
                const x = 30 + (i % 10) * ((w - 60) / 10);
                const y = 35 + Math.floor(i / 10) * 3 + offset;

                // Check if any bubble is near (cleaned)
                let cleaned = false;
                for (const b of bubbles) {
                    const dist = Math.sqrt((x - b.x) ** 2 + (y - 40 - offset) ** 2);
                    if (dist < bubbleSize * 2) {
                        cleaned = true;
                        break;
                    }
                }

                if (!cleaned) {
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function updateStats() {
            const isGalloping = amplitude >= GALLOP_THRESHOLD;

            document.getElementById('bubbleState').textContent =
                isGalloping ? 'Galloping' : 'Oscillating';

            const avgVx = bubbles.reduce((s, b) => s + Math.abs(b.vx), 0) / bubbles.length;
            document.getElementById('hVelocity').textContent =
                isGalloping ? (avgVx * 10).toFixed(1) + ' mm/s' : '0 mm/s';

            document.getElementById('shapeMode').textContent =
                isGalloping ? 'Asymmetric' : 'Axisymmetric';

            document.getElementById('symmetry').textContent =
                isGalloping ? 'Broken!' : 'Preserved';

            // Update threshold indicator
            const dot = document.getElementById('thresholdDot');
            const text = document.getElementById('thresholdText');
            if (isGalloping) {
                dot.className = 'threshold-dot above';
                text.textContent = 'Above threshold - GALLOPING!';
            } else {
                dot.className = 'threshold-dot below';
                text.textContent = 'Below galloping threshold';
            }
        }

        function draw() {
            const w = canvas.width / dpr;
            const h = canvas.height / dpr;

            // Clear
            ctx.fillStyle = '#0a1929';
            ctx.fillRect(0, 0, w, h);

            // Container oscillation
            const containerOffset = Math.sin(time * frequency * 0.1) * amplitude * 3;

            const isGalloping = amplitude >= GALLOP_THRESHOLD;

            drawContainer(w, h, containerOffset);
            drawDustParticles(w, h, containerOffset);

            // Update and draw bubbles
            bubbles.forEach(b => {
                b.update(1, containerOffset, w, h);
                b.draw(ctx, containerOffset, isGalloping);
            });

            // Direction indicator when galloping
            if (isGalloping) {
                ctx.fillStyle = 'rgba(79, 195, 247, 0.8)';
                ctx.font = 'bold 14px Georgia';
                ctx.textAlign = 'center';
                ctx.fillText('‚Üí Horizontal motion ‚Üê', w / 2, h - 50);
            }

            updateStats();
            time++;
            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('ampSlider').addEventListener('input', (e) => {
            amplitude = parseFloat(e.target.value);
            document.getElementById('ampValue').textContent = amplitude.toFixed(1);
        });

        document.getElementById('freqSlider').addEventListener('input', (e) => {
            frequency = parseInt(e.target.value);
            document.getElementById('freqValue').textContent = frequency;
        });

        document.getElementById('sizeSlider').addEventListener('input', (e) => {
            bubbleSize = parseInt(e.target.value);
            document.getElementById('sizeValue').textContent = bubbleSize;
            initBubbles();
        });

        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                motionMode = btn.dataset.mode;
                initBubbles();
            });
        });

        // Initialize
        initBubbles();
        draw();
    </script>
</body>
</html>
