<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaos Game - Surprising Paradoxes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0f1520 0%, #1a2535 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(135deg, #e74c3c 0%, #f39c12 50%, #2ecc71 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2em;
            color: #888;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
        }

        @media (max-width: 1000px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .canvas-container {
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        #chaosCanvas {
            display: block;
            width: 100%;
        }

        .info-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.85em;
            font-family: monospace;
        }

        .info-overlay span {
            color: #2ecc71;
        }

        .controls {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
        }

        .control-section {
            margin-bottom: 25px;
        }

        .control-section h3 {
            color: #2ecc71;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 1px solid rgba(46,204,113,0.3);
            padding-bottom: 8px;
        }

        .control-row {
            margin-bottom: 15px;
        }

        .control-row label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 0.9em;
        }

        .control-row input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-row .value {
            text-align: right;
            font-family: monospace;
            color: #2ecc71;
            font-size: 0.9em;
        }

        select {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
            color: #e0e0e0;
            font-size: 0.95em;
        }

        .btn-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(46,204,113,0.4);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #e0e0e0;
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
        }

        .preset-btn {
            flex: 1;
            min-width: 70px;
            font-size: 0.8em;
            padding: 8px 10px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-box {
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.2em;
            color: #2ecc71;
            font-family: monospace;
        }

        .stat-label {
            font-size: 0.75em;
            color: #888;
            margin-top: 4px;
        }

        .explanation {
            margin-top: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .exp-card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            border-left: 4px solid #2ecc71;
        }

        .exp-card h3 {
            color: #2ecc71;
            margin-bottom: 10px;
        }

        .exp-card p {
            color: #bbb;
            line-height: 1.6;
        }

        .algorithm {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.9em;
            margin: 10px 0;
            color: #f39c12;
        }

        .back-link {
            display: inline-block;
            color: #2ecc71;
            text-decoration: none;
            margin-bottom: 20px;
            transition: transform 0.2s;
        }

        .back-link:hover {
            transform: translateX(-5px);
        }

        .speed-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .speed-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #2ecc71;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        .speed-text {
            font-size: 0.85em;
            color: #888;
        }

        .rule-display {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.85em;
            color: #f39c12;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Paradoxes</a>

        <header>
            <h1>The Chaos Game</h1>
            <p class="subtitle">When random choices create perfect order</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="chaosCanvas" width="900" height="700"></canvas>
                <div class="info-overlay">
                    <div>Points: <span id="pointCount">0</span></div>
                    <div>Pattern: <span id="patternName">Sierpinski</span></div>
                </div>
            </div>

            <div class="controls">
                <div class="control-section">
                    <h3>Fractal Pattern</h3>
                    <select id="patternSelect">
                        <option value="sierpinski">Sierpinski Triangle (3 vertices)</option>
                        <option value="square">Square (4 vertices, restricted)</option>
                        <option value="pentagon">Pentagon (5 vertices)</option>
                        <option value="hexagon">Hexagon (6 vertices)</option>
                        <option value="fern">Barnsley Fern</option>
                        <option value="tree">Fractal Tree</option>
                    </select>
                </div>

                <div class="control-section">
                    <h3>Animation</h3>
                    <div class="btn-group">
                        <button class="btn-primary" id="playBtn">▶ Play</button>
                        <button class="btn-secondary" id="pauseBtn">⏸ Pause</button>
                        <button class="btn-secondary" id="resetBtn">Reset</button>
                    </div>
                    <div class="speed-indicator">
                        <div class="speed-dot" id="speedDot"></div>
                        <span class="speed-text" id="speedText">Running...</span>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Speed</h3>
                    <div class="control-row">
                        <label>Points per frame</label>
                        <input type="range" id="speedSlider" min="1" max="1000" value="100">
                        <div class="value"><span id="speedValue">100</span> pts/frame</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Jump Ratio</h3>
                    <div class="control-row">
                        <label>Distance to vertex</label>
                        <input type="range" id="ratioSlider" min="0.1" max="0.9" step="0.05" value="0.5">
                        <div class="value"><span id="ratioValue">0.5</span> (halfway)</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="stat-value" id="statPoints">0</div>
                            <div class="stat-label">Total Points</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="statVertices">3</div>
                            <div class="stat-label">Vertices</div>
                        </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Current Rule</h3>
                    <div class="rule-display" id="ruleDisplay">
                        Jump 1/2 toward random vertex
                    </div>
                </div>
            </div>
        </div>

        <div class="explanation">
            <div class="exp-card">
                <h3>The Algorithm</h3>
                <div class="algorithm">
                    1. Pick random start point<br>
                    2. Randomly choose a vertex<br>
                    3. Jump halfway toward it<br>
                    4. Plot the new point<br>
                    5. Repeat from step 2
                </div>
                <p>This absurdly simple algorithm, with completely random choices at every step, creates perfect geometric fractals. How can randomness produce such precise structure?</p>
            </div>

            <div class="exp-card">
                <h3>The Paradox of Order from Chaos</h3>
                <p>Every single point placement is random—yet the result is perfectly deterministic! The Sierpinski triangle emerges from pure chaos because the jumping rules implicitly encode the fractal's structure. The random choices average out, but the geometry is preserved.</p>
            </div>

            <div class="exp-card">
                <h3>Iterated Function Systems</h3>
                <p>Michael Barnsley (1988) formalized this as IFS: the fractal is the unique "attractor" of the random iteration. No matter where you start, the process converges to the same shape. The chaos game is really an efficient way to sample points from this attractor.</p>
            </div>

            <div class="exp-card">
                <h3>Why Different Shapes?</h3>
                <p>For 4+ vertices with ratio 1/2, extra rules are needed (like "can't pick the same vertex twice"). Different ratios create different fractals—ratio 1/3 with a square makes a filled square! The mathematics of when order emerges from which rules is surprisingly deep.</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('chaosCanvas');
        const ctx = canvas.getContext('2d');

        let isPlaying = false;
        let animationFrame = null;
        let points = [];
        let currentPoint = null;
        let vertices = [];
        let pattern = 'sierpinski';
        let speed = 100;
        let ratio = 0.5;
        let totalPoints = 0;
        let lastVertex = -1;

        // Pattern definitions
        const patterns = {
            sierpinski: {
                vertices: 3,
                rule: 'none',
                ratio: 0.5,
                getVertices: () => {
                    const cx = canvas.width / 2;
                    const cy = canvas.height / 2;
                    const r = Math.min(canvas.width, canvas.height) * 0.45;
                    return [
                        { x: cx, y: cy - r },
                        { x: cx - r * Math.cos(Math.PI/6), y: cy + r * Math.sin(Math.PI/6) },
                        { x: cx + r * Math.cos(Math.PI/6), y: cy + r * Math.sin(Math.PI/6) }
                    ];
                },
                colors: ['#e74c3c', '#f39c12', '#2ecc71']
            },
            square: {
                vertices: 4,
                rule: 'no-same',
                ratio: 0.5,
                getVertices: () => {
                    const cx = canvas.width / 2;
                    const cy = canvas.height / 2;
                    const r = Math.min(canvas.width, canvas.height) * 0.4;
                    return [
                        { x: cx - r, y: cy - r },
                        { x: cx + r, y: cy - r },
                        { x: cx + r, y: cy + r },
                        { x: cx - r, y: cy + r }
                    ];
                },
                colors: ['#e74c3c', '#f39c12', '#2ecc71', '#3498db']
            },
            pentagon: {
                vertices: 5,
                rule: 'none',
                ratio: 0.618, // Golden ratio
                getVertices: () => {
                    const cx = canvas.width / 2;
                    const cy = canvas.height / 2;
                    const r = Math.min(canvas.width, canvas.height) * 0.4;
                    const verts = [];
                    for (let i = 0; i < 5; i++) {
                        const angle = -Math.PI/2 + (2 * Math.PI * i) / 5;
                        verts.push({
                            x: cx + r * Math.cos(angle),
                            y: cy + r * Math.sin(angle)
                        });
                    }
                    return verts;
                },
                colors: ['#e74c3c', '#f39c12', '#2ecc71', '#3498db', '#9b59b6']
            },
            hexagon: {
                vertices: 6,
                rule: 'none',
                ratio: 0.667,
                getVertices: () => {
                    const cx = canvas.width / 2;
                    const cy = canvas.height / 2;
                    const r = Math.min(canvas.width, canvas.height) * 0.4;
                    const verts = [];
                    for (let i = 0; i < 6; i++) {
                        const angle = (2 * Math.PI * i) / 6;
                        verts.push({
                            x: cx + r * Math.cos(angle),
                            y: cy + r * Math.sin(angle)
                        });
                    }
                    return verts;
                },
                colors: ['#e74c3c', '#f39c12', '#2ecc71', '#3498db', '#9b59b6', '#1abc9c']
            },
            fern: {
                vertices: 0,
                rule: 'fern',
                ratio: 1,
                getVertices: () => [],
                colors: ['#2ecc71']
            },
            tree: {
                vertices: 0,
                rule: 'tree',
                ratio: 1,
                getVertices: () => [],
                colors: ['#8B4513', '#2ecc71']
            }
        };

        function init() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const p = patterns[pattern];
            vertices = p.getVertices();
            ratio = p.ratio;
            document.getElementById('ratioSlider').value = ratio;
            document.getElementById('ratioValue').textContent = ratio.toFixed(2);

            // Draw vertices
            vertices.forEach((v, i) => {
                ctx.beginPath();
                ctx.arc(v.x, v.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = p.colors[i % p.colors.length];
                ctx.fill();
            });

            // Initialize starting point
            if (pattern === 'fern' || pattern === 'tree') {
                currentPoint = { x: 0, y: 0 };
            } else {
                currentPoint = {
                    x: canvas.width / 2 + (Math.random() - 0.5) * 100,
                    y: canvas.height / 2 + (Math.random() - 0.5) * 100
                };
            }

            totalPoints = 0;
            lastVertex = -1;
            updateStats();
        }

        function iterate() {
            const p = patterns[pattern];

            if (pattern === 'fern') {
                // Barnsley fern transformation
                const r = Math.random();
                let nx, ny;
                if (r < 0.01) {
                    nx = 0;
                    ny = 0.16 * currentPoint.y;
                } else if (r < 0.86) {
                    nx = 0.85 * currentPoint.x + 0.04 * currentPoint.y;
                    ny = -0.04 * currentPoint.x + 0.85 * currentPoint.y + 1.6;
                } else if (r < 0.93) {
                    nx = 0.2 * currentPoint.x - 0.26 * currentPoint.y;
                    ny = 0.23 * currentPoint.x + 0.22 * currentPoint.y + 1.6;
                } else {
                    nx = -0.15 * currentPoint.x + 0.28 * currentPoint.y;
                    ny = 0.26 * currentPoint.x + 0.24 * currentPoint.y + 0.44;
                }
                currentPoint = { x: nx, y: ny };

                // Map to canvas
                const px = canvas.width / 2 + currentPoint.x * 80;
                const py = canvas.height - currentPoint.y * 65 - 20;

                return { x: px, y: py, color: '#2ecc71' };
            }

            if (pattern === 'tree') {
                const r = Math.random();
                let nx, ny;
                if (r < 0.05) {
                    nx = 0;
                    ny = 0.5 * currentPoint.y;
                } else if (r < 0.45) {
                    nx = 0.42 * currentPoint.x - 0.42 * currentPoint.y;
                    ny = 0.42 * currentPoint.x + 0.42 * currentPoint.y + 0.5;
                } else if (r < 0.85) {
                    nx = 0.42 * currentPoint.x + 0.42 * currentPoint.y;
                    ny = -0.42 * currentPoint.x + 0.42 * currentPoint.y + 0.5;
                } else {
                    nx = 0.1 * currentPoint.x;
                    ny = 0.1 * currentPoint.y + 0.2;
                }
                currentPoint = { x: nx, y: ny };

                const px = canvas.width / 2 + currentPoint.x * 250;
                const py = canvas.height - currentPoint.y * 350 - 50;

                const color = currentPoint.y > 0.3 ? '#2ecc71' : '#8B4513';
                return { x: px, y: py, color };
            }

            // Regular polygon chaos game
            let vertexIndex;
            if (p.rule === 'no-same') {
                // Can't pick the same vertex twice in a row
                do {
                    vertexIndex = Math.floor(Math.random() * vertices.length);
                } while (vertexIndex === lastVertex && vertices.length > 1);
            } else {
                vertexIndex = Math.floor(Math.random() * vertices.length);
            }

            lastVertex = vertexIndex;
            const target = vertices[vertexIndex];

            currentPoint = {
                x: currentPoint.x + (target.x - currentPoint.x) * ratio,
                y: currentPoint.y + (target.y - currentPoint.y) * ratio
            };

            return {
                x: currentPoint.x,
                y: currentPoint.y,
                color: p.colors[vertexIndex % p.colors.length]
            };
        }

        function draw() {
            if (!isPlaying) return;

            for (let i = 0; i < speed; i++) {
                const point = iterate();
                if (point.x >= 0 && point.x < canvas.width &&
                    point.y >= 0 && point.y < canvas.height) {
                    ctx.fillStyle = point.color;
                    ctx.fillRect(point.x, point.y, 1, 1);
                }
                totalPoints++;
            }

            updateStats();
            animationFrame = requestAnimationFrame(draw);
        }

        function updateStats() {
            document.getElementById('pointCount').textContent = totalPoints.toLocaleString();
            document.getElementById('statPoints').textContent = totalPoints.toLocaleString();
            document.getElementById('patternName').textContent = pattern.charAt(0).toUpperCase() + pattern.slice(1);

            const p = patterns[pattern];
            document.getElementById('statVertices').textContent = p.vertices || 'IFS';

            // Update rule display
            let ruleText = '';
            if (pattern === 'sierpinski') {
                ruleText = 'Jump 1/2 toward random vertex';
            } else if (pattern === 'square') {
                ruleText = 'Jump 1/2, can\'t repeat same vertex';
            } else if (pattern === 'pentagon') {
                ruleText = 'Jump φ ≈ 0.618 (golden ratio) toward vertex';
            } else if (pattern === 'hexagon') {
                ruleText = 'Jump 2/3 toward random vertex';
            } else if (pattern === 'fern') {
                ruleText = 'Barnsley IFS with 4 affine transforms';
            } else if (pattern === 'tree') {
                ruleText = 'Fractal tree IFS transforms';
            }
            document.getElementById('ruleDisplay').textContent = ruleText;
        }

        function play() {
            isPlaying = true;
            document.getElementById('speedDot').style.background = '#2ecc71';
            document.getElementById('speedText').textContent = 'Running...';
            draw();
        }

        function pause() {
            isPlaying = false;
            document.getElementById('speedDot').style.background = '#e74c3c';
            document.getElementById('speedText').textContent = 'Paused';
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
        }

        function reset() {
            pause();
            init();
        }

        // Event listeners
        document.getElementById('playBtn').addEventListener('click', play);
        document.getElementById('pauseBtn').addEventListener('click', pause);
        document.getElementById('resetBtn').addEventListener('click', reset);

        document.getElementById('patternSelect').addEventListener('change', (e) => {
            pattern = e.target.value;
            reset();
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = speed;
        });

        document.getElementById('ratioSlider').addEventListener('input', (e) => {
            ratio = parseFloat(e.target.value);
            document.getElementById('ratioValue').textContent = ratio.toFixed(2);
        });

        // Initialize and start
        init();
        play();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
