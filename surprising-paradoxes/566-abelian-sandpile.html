<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Abelian Sandpile - Self-Organized Criticality</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #2c1810 0%, #3d2317 50%, #4a2c1a 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 0;
        }

        h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, #f4d03f, #e67e22, #c0392b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #a88;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
            margin-top: 20px;
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(244, 208, 63, 0.2);
        }

        canvas {
            display: block;
            width: 100%;
            background: #1a1a1a;
            border-radius: 10px;
        }

        .controls {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(244, 208, 63, 0.2);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: #f4d03f;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            background: linear-gradient(90deg, #f4d03f, #e67e22);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #f4d03f;
            border-radius: 50%;
            cursor: pointer;
        }

        .value-display {
            min-width: 60px;
            text-align: right;
            color: #f4d03f;
            font-family: monospace;
        }

        .button-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        button {
            padding: 12px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .control-btn {
            background: linear-gradient(135deg, #f4d03f, #e6c02f);
            color: #333;
            font-size: 1rem;
        }

        .control-btn:hover {
            background: linear-gradient(135deg, #e6c02f, #d6b01f);
            transform: scale(1.02);
        }

        .control-btn.running {
            background: linear-gradient(135deg, #e67e22, #d76e12);
        }

        .preset-btn {
            background: linear-gradient(135deg, #3a2a1a, #4a3a2a);
            color: #e0e0e0;
            border: 1px solid rgba(244, 208, 63, 0.3);
            padding: 10px;
        }

        .preset-btn:hover {
            background: linear-gradient(135deg, #4a3a2a, #5a4a3a);
            border-color: #f4d03f;
        }

        .preset-btn.active {
            background: linear-gradient(135deg, #f4d03f, #e67e22);
            color: #333;
        }

        .stats {
            background: rgba(244, 208, 63, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(244, 208, 63, 0.1);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #a88;
        }

        .stat-value {
            color: #f4d03f;
            font-family: monospace;
        }

        .rules-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            border-left: 3px solid #e67e22;
        }

        .rules-title {
            color: #e67e22;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .rule-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin: 8px 0;
            font-size: 0.9rem;
            color: #ccc;
        }

        .rule-icon {
            color: #f4d03f;
        }

        .color-legend {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            margin-top: 15px;
        }

        .legend-item {
            text-align: center;
            padding: 8px;
            border-radius: 5px;
            font-size: 0.8rem;
        }

        .explanation {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .exp-card {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(244, 208, 63, 0.2);
        }

        .exp-card h3 {
            color: #f4d03f;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .exp-card p {
            line-height: 1.7;
            color: #bbb;
        }

        .highlight {
            color: #f4d03f;
            font-weight: 500;
        }

        .back-link {
            display: inline-block;
            color: #f4d03f;
            text-decoration: none;
            margin-bottom: 20px;
            transition: transform 0.3s;
        }

        .back-link:hover {
            transform: translateX(-5px);
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

        <header>
            <h1>The Abelian Sandpile</h1>
            <p class="subtitle">Self-organized criticality: complexity from simplicity, fractals from falling sand</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="sandpileCanvas" width="600" height="600"></canvas>
            </div>

            <div class="controls">
                <div class="control-group">
                    <div class="button-row">
                        <button class="control-btn" id="playPauseBtn">‚ñ∂ Start</button>
                        <button class="control-btn" id="resetBtn">‚Ü∫ Reset</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Grains per Frame</label>
                    <div class="slider-container">
                        <input type="range" id="speedSlider" min="1" max="100" value="10">
                        <span class="value-display" id="speedValue">10</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Grid Size</label>
                    <div class="slider-container">
                        <input type="range" id="sizeSlider" min="50" max="300" value="150">
                        <span class="value-display" id="sizeValue">150</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Mode</label>
                    <div class="button-row">
                        <button class="preset-btn active" data-mode="center">Center Drop</button>
                        <button class="preset-btn" data-mode="fractal">Fractal (Pile)</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Quick Presets</label>
                    <div class="button-row">
                        <button class="preset-btn" data-grains="10000">10K Grains</button>
                        <button class="preset-btn" data-grains="50000">50K Grains</button>
                        <button class="preset-btn" data-grains="100000">100K Grains</button>
                        <button class="preset-btn" data-grains="500000">500K Grains</button>
                    </div>
                </div>

                <div class="stats">
                    <div class="stat-row">
                        <span class="stat-label">Total Grains Added</span>
                        <span class="stat-value" id="grainCount">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Total Topples</span>
                        <span class="stat-value" id="toppleCount">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Grains Lost (Edge)</span>
                        <span class="stat-value" id="lostCount">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Current Avalanche</span>
                        <span class="stat-value" id="avalancheSize">0</span>
                    </div>
                </div>

                <div class="rules-box">
                    <div class="rules-title">The Toppling Rule</div>
                    <div class="rule-item">
                        <span class="rule-icon">üì•</span>
                        <span>Add grain to center cell</span>
                    </div>
                    <div class="rule-item">
                        <span class="rule-icon">‚ö†Ô∏è</span>
                        <span>If cell has ‚â•4 grains: TOPPLE!</span>
                    </div>
                    <div class="rule-item">
                        <span class="rule-icon">‚ÜîÔ∏è</span>
                        <span>Give 1 grain to each of 4 neighbors</span>
                    </div>
                    <div class="rule-item">
                        <span class="rule-icon">üîÑ</span>
                        <span>Repeat until stable (no cell ‚â•4)</span>
                    </div>
                </div>

                <div class="color-legend">
                    <div class="legend-item" style="background: #1a1a1a; color: #666;">0</div>
                    <div class="legend-item" style="background: #1a4a1a; color: #fff;">1</div>
                    <div class="legend-item" style="background: #4a4a1a; color: #fff;">2</div>
                    <div class="legend-item" style="background: #8a4a1a; color: #fff;">3</div>
                </div>
            </div>
        </div>

        <div class="explanation">
            <div class="exp-card">
                <h3>‚õ∞Ô∏è The Surprise</h3>
                <p>
                    Add sand one grain at a time. Most additions do nothing. Some cause small
                    avalanches. Rarely, <span class="highlight">massive cascades</span> sweep across
                    the entire pile! The system naturally tunes itself to a "critical" state where
                    avalanches of <span class="highlight">all sizes</span> occur‚Äîa power law with no
                    characteristic scale. This is self-organized criticality (SOC).
                </p>
            </div>

            <div class="exp-card">
                <h3>üìä Power Laws Everywhere</h3>
                <p>
                    The distribution of avalanche sizes follows a <span class="highlight">power law</span>:
                    P(s) ~ s^(-œÑ). This pattern appears everywhere‚Äîearthquakes, forest fires, stock
                    market crashes, neural activity. Bak, Tang & Wiesenfeld (1987) proposed SOC as
                    the unifying explanation for why nature is full of scale-free phenomena.
                </p>
            </div>

            <div class="exp-card">
                <h3>üé® Fractal Identity</h3>
                <p>
                    Start with a massive pile at the center (try "Fractal" mode). After all topples
                    settle, a <span class="highlight">stunning fractal pattern</span> emerges! This
                    "identity configuration" has self-similar structure at all scales. The mathematics
                    involves abelian groups‚Äîhence "Abelian" sandpile. Order of operations doesn't matter!
                </p>
            </div>

            <div class="exp-card">
                <h3>‚àû Edge of Chaos</h3>
                <p>
                    The critical state sits at the <span class="highlight">edge of chaos</span>‚Äînot
                    too ordered, not too random. Information propagates maximally. Some theorize
                    the brain operates here, enabling both stability and rapid adaptation. The sandpile
                    shows how simple rules create this delicate balance spontaneously.
                </p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('sandpileCanvas');
        const ctx = canvas.getContext('2d');

        // High DPI support
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        const W = rect.width;
        const H = rect.height;

        // Colors for 0-3 grains
        const COLORS = [
            '#1a1a1a', // 0 - dark
            '#1a5a1a', // 1 - green
            '#6a6a1a', // 2 - yellow-green
            '#aa4a1a'  // 3 - orange
        ];

        // State
        let gridSize = 150;
        let grid = [];
        let running = false;
        let grainsPerFrame = 10;
        let mode = 'center';
        let animationId = null;

        // Stats
        let totalGrains = 0;
        let totalTopples = 0;
        let grainsLost = 0;
        let currentAvalanche = 0;

        // Initialize grid
        function initGrid() {
            grid = new Array(gridSize);
            for (let i = 0; i < gridSize; i++) {
                grid[i] = new Uint8Array(gridSize);
            }
        }

        // Add a grain at position
        function addGrain(x, y) {
            if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) {
                grainsLost++;
                return;
            }
            grid[x][y]++;
            totalGrains++;
        }

        // Topple all unstable cells (parallel update)
        function topple() {
            let toppled = false;
            currentAvalanche = 0;

            // Find all cells that need to topple
            const toTopple = [];
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    if (grid[x][y] >= 4) {
                        toTopple.push([x, y]);
                    }
                }
            }

            // Topple them all
            for (const [x, y] of toTopple) {
                grid[x][y] -= 4;
                totalTopples++;
                currentAvalanche++;
                toppled = true;

                // Give to neighbors
                if (x > 0) grid[x-1][y]++;
                else grainsLost++;

                if (x < gridSize-1) grid[x+1][y]++;
                else grainsLost++;

                if (y > 0) grid[x][y-1]++;
                else grainsLost++;

                if (y < gridSize-1) grid[x][y+1]++;
                else grainsLost++;
            }

            return toppled;
        }

        // Stabilize the pile (topple until stable)
        function stabilize() {
            while (topple()) {
                // Keep toppling until no more unstable cells
            }
        }

        // Add grains and stabilize
        function step() {
            const cx = Math.floor(gridSize / 2);
            const cy = Math.floor(gridSize / 2);

            for (let i = 0; i < grainsPerFrame; i++) {
                addGrain(cx, cy);
                stabilize();
            }
        }

        // Create fractal from large initial pile
        function createFractalPile(n) {
            const cx = Math.floor(gridSize / 2);
            const cy = Math.floor(gridSize / 2);
            grid[cx][cy] = n;
            totalGrains = n;

            // Stabilize
            let iterations = 0;
            const maxIterations = 10000000;
            while (topple() && iterations < maxIterations) {
                iterations++;
            }
        }

        // Render
        function render() {
            const cellSize = Math.min(W, H) / gridSize;

            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, W, H);

            // Offset to center the grid
            const offsetX = (W - gridSize * cellSize) / 2;
            const offsetY = (H - gridSize * cellSize) / 2;

            // Draw cells
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    const val = Math.min(grid[x][y], 3);
                    if (val > 0) {
                        ctx.fillStyle = COLORS[val];
                        ctx.fillRect(
                            offsetX + x * cellSize,
                            offsetY + y * cellSize,
                            cellSize,
                            cellSize
                        );
                    }
                }
            }

            updateStats();
        }

        // Update stats display
        function updateStats() {
            document.getElementById('grainCount').textContent = totalGrains.toLocaleString();
            document.getElementById('toppleCount').textContent = totalTopples.toLocaleString();
            document.getElementById('lostCount').textContent = grainsLost.toLocaleString();
            document.getElementById('avalancheSize').textContent = currentAvalanche.toLocaleString();
        }

        // Animation loop
        function animate() {
            if (running) {
                step();
                render();
                animationId = requestAnimationFrame(animate);
            }
        }

        // Reset
        function reset() {
            running = false;
            document.getElementById('playPauseBtn').textContent = '‚ñ∂ Start';
            document.getElementById('playPauseBtn').classList.remove('running');
            if (animationId) cancelAnimationFrame(animationId);

            gridSize = parseInt(document.getElementById('sizeSlider').value);
            initGrid();
            totalGrains = 0;
            totalTopples = 0;
            grainsLost = 0;
            currentAvalanche = 0;

            render();
        }

        // Toggle play/pause
        function togglePlay() {
            running = !running;
            const btn = document.getElementById('playPauseBtn');
            btn.textContent = running ? '‚è∏ Pause' : '‚ñ∂ Start';
            btn.classList.toggle('running', running);

            if (running) {
                animate();
            }
        }

        // Jump to specific grain count
        function jumpToGrains(targetGrains) {
            running = false;
            document.getElementById('playPauseBtn').textContent = '‚ñ∂ Start';
            document.getElementById('playPauseBtn').classList.remove('running');
            if (animationId) cancelAnimationFrame(animationId);

            reset();

            if (mode === 'fractal') {
                createFractalPile(targetGrains);
            } else {
                const cx = Math.floor(gridSize / 2);
                const cy = Math.floor(gridSize / 2);
                for (let i = 0; i < targetGrains; i++) {
                    addGrain(cx, cy);
                }
                stabilize();
            }

            render();
        }

        // Event listeners
        document.getElementById('playPauseBtn').addEventListener('click', togglePlay);
        document.getElementById('resetBtn').addEventListener('click', reset);

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            grainsPerFrame = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = grainsPerFrame;
        });

        document.getElementById('sizeSlider').addEventListener('input', (e) => {
            document.getElementById('sizeValue').textContent = e.target.value;
        });

        document.querySelectorAll('.preset-btn[data-mode]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.preset-btn[data-mode]').forEach(b =>
                    b.classList.remove('active'));
                btn.classList.add('active');
                mode = btn.dataset.mode;
                reset();
            });
        });

        document.querySelectorAll('.preset-btn[data-grains]').forEach(btn => {
            btn.addEventListener('click', () => {
                jumpToGrains(parseInt(btn.dataset.grains));
            });
        });

        // Initialize
        initGrid();
        render();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
