<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Coastline Paradox - How Long Is Britain? | Surprising Paradoxes #620</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a1628 0%, #1a365d 50%, #0d2137 100%);
            min-height: 100vh;
            color: #e2e8f0;
            overflow-x: hidden;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #60a5fa;
            text-decoration: none;
            font-size: 0.9rem;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 8px 16px;
            background: rgba(30, 58, 138, 0.5);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        .back-link:hover {
            background: rgba(59, 130, 246, 0.5);
            transform: translateX(-3px);
        }
        header {
            text-align: center;
            padding: 60px 20px 30px;
        }
        h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, #60a5fa, #34d399, #a78bfa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }
        .subtitle {
            color: #94a3b8;
            font-size: 1.1rem;
            max-width: 700px;
            margin: 0 auto;
        }
        .paradox-statement {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(249, 115, 22, 0.2));
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 15px;
            padding: 20px;
            max-width: 800px;
            margin: 20px auto;
            text-align: center;
        }
        .paradox-statement h2 {
            color: #f87171;
            font-size: 1.3rem;
            margin-bottom: 10px;
        }
        .main-container {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        @media (max-width: 1000px) {
            .main-container { grid-template-columns: 1fr; }
        }
        .canvas-container {
            background: rgba(15, 23, 42, 0.8);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(96, 165, 250, 0.2);
        }
        canvas {
            width: 100%;
            border-radius: 10px;
            background: #0f172a;
        }
        .controls {
            background: rgba(15, 23, 42, 0.8);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(96, 165, 250, 0.2);
        }
        .control-group {
            margin-bottom: 25px;
        }
        .control-group label {
            display: block;
            color: #60a5fa;
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #1e3a5f;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #60a5fa, #3b82f6);
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(59, 130, 246, 0.5);
        }
        .value-display {
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            color: #34d399;
            margin-top: 10px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }
        .stat-box {
            background: rgba(30, 58, 138, 0.3);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }
        .stat-box .label {
            font-size: 0.8rem;
            color: #94a3b8;
            margin-bottom: 5px;
        }
        .stat-box .value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #60a5fa;
        }
        .stat-box.highlight .value {
            color: #f59e0b;
        }
        .coastline-select {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .coastline-btn {
            padding: 8px 16px;
            border: 1px solid rgba(96, 165, 250, 0.3);
            background: rgba(30, 58, 138, 0.3);
            color: #94a3b8;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85rem;
        }
        .coastline-btn:hover {
            background: rgba(59, 130, 246, 0.3);
            color: #e2e8f0;
        }
        .coastline-btn.active {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
            border-color: #3b82f6;
        }
        .dimension-display {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(168, 85, 247, 0.2));
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            margin-top: 20px;
        }
        .dimension-display .label {
            font-size: 0.9rem;
            color: #a78bfa;
        }
        .dimension-display .value {
            font-size: 2rem;
            font-weight: bold;
            color: #c4b5fd;
        }
        .info-section {
            max-width: 1400px;
            margin: 40px auto;
            padding: 0 20px;
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
        }
        .info-card {
            background: rgba(15, 23, 42, 0.8);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(96, 165, 250, 0.2);
        }
        .info-card h3 {
            color: #60a5fa;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        .info-card p {
            color: #94a3b8;
            line-height: 1.7;
            font-size: 0.95rem;
        }
        .formula {
            background: rgba(30, 58, 138, 0.4);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            color: #34d399;
            text-align: center;
            font-size: 1.1rem;
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .comparison-table th, .comparison-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid rgba(96, 165, 250, 0.2);
        }
        .comparison-table th {
            color: #60a5fa;
            font-weight: 600;
        }
        .comparison-table td {
            color: #94a3b8;
        }
        .timeline {
            position: relative;
            padding-left: 30px;
        }
        .timeline::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(to bottom, #3b82f6, #8b5cf6);
        }
        .timeline-item {
            position: relative;
            margin-bottom: 20px;
        }
        .timeline-item::before {
            content: '';
            position: absolute;
            left: -34px;
            top: 5px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #60a5fa;
        }
        .timeline-year {
            color: #f59e0b;
            font-weight: bold;
        }
        .animate-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
        }
        .animate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(59, 130, 246, 0.4);
        }
        .log-plot {
            background: rgba(15, 23, 42, 0.9);
            border-radius: 10px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <header>
        <h1>The Coastline Paradox</h1>
        <p class="subtitle">Why nobody can agree on the length of Britain's coastline</p>

        <div class="paradox-statement">
            <h2>THE PARADOX</h2>
            <p>The measured length of a coastline depends on the length of your ruler. As your ruler gets smaller, the coastline gets <strong>INFINITELY LONGER</strong>. There is no "true" length!</p>
        </div>
    </header>

    <div class="main-container">
        <div class="canvas-container">
            <canvas id="coastCanvas" width="800" height="600"></canvas>
            <canvas id="logPlot" class="log-plot" width="800" height="200"></canvas>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>üîç Ruler Length (Measurement Scale)</label>
                <input type="range" id="rulerSize" min="5" max="100" value="50">
                <div class="value-display" id="rulerDisplay">50 km</div>
            </div>

            <div class="control-group">
                <label>üó∫Ô∏è Coastline Type</label>
                <div class="coastline-select">
                    <button class="coastline-btn active" data-type="britain" data-dim="1.25">Britain (D=1.25)</button>
                    <button class="coastline-btn" data-type="norway" data-dim="1.52">Norway (D=1.52)</button>
                    <button class="coastline-btn" data-type="australia" data-dim="1.13">Australia (D=1.13)</button>
                    <button class="coastline-btn" data-type="smooth" data-dim="1.02">Smooth (D=1.02)</button>
                </div>
            </div>

            <div class="dimension-display">
                <div class="label">Fractal Dimension</div>
                <div class="value" id="fractalDim">D = 1.25</div>
            </div>

            <div class="stats-grid">
                <div class="stat-box">
                    <div class="label">Ruler Count</div>
                    <div class="value" id="rulerCount">0</div>
                </div>
                <div class="stat-box highlight">
                    <div class="label">Measured Length</div>
                    <div class="value" id="measuredLength">0 km</div>
                </div>
                <div class="stat-box">
                    <div class="label">At 100km ruler</div>
                    <div class="value" id="length100">~2,800 km</div>
                </div>
                <div class="stat-box">
                    <div class="label">At 1km ruler</div>
                    <div class="value" id="length1">~17,820 km</div>
                </div>
            </div>

            <button class="animate-btn" id="animateBtn">‚ñ∂ Animate Measurement</button>
        </div>
    </div>

    <div class="info-section">
        <div class="info-grid">
            <div class="info-card">
                <h3>üìê Richardson's Discovery (1951)</h3>
                <p>Lewis Fry Richardson was studying whether border length affects the probability of war. He noticed Spain reported its border with Portugal as <strong>1,214 km</strong>, while Portugal reported it as <strong>987 km</strong>‚Äîa 23% difference!</p>
                <p style="margin-top: 10px;">This discrepancy led to his groundbreaking insight: measured length depends on measurement scale.</p>
            </div>

            <div class="info-card">
                <h3>üìè The Richardson Effect</h3>
                <p>Richardson found that coastline length L follows a power law:</p>
                <div class="formula">L(Œµ) = F ¬∑ Œµ^(1-D)</div>
                <p>Where Œµ is ruler length, F is a constant, and D is the <strong>fractal dimension</strong>. As Œµ ‚Üí 0, length ‚Üí ‚àû for any D > 1!</p>
            </div>

            <div class="info-card">
                <h3>üåä Why Does This Happen?</h3>
                <p>Coastlines are <strong>statistically self-similar</strong>‚Äîzoom in, and you see similar jaggedness at every scale:</p>
                <ul style="margin-top: 10px; padding-left: 20px; color: #94a3b8;">
                    <li>100km: Major bays and peninsulas</li>
                    <li>10km: Inlets and headlands</li>
                    <li>1km: Coves and promontories</li>
                    <li>1m: Rocks and tidal pools</li>
                    <li>1cm: Individual stones and pebbles</li>
                </ul>
            </div>

            <div class="info-card">
                <h3>üåç Real-World Fractal Dimensions</h3>
                <table class="comparison-table">
                    <tr><th>Coastline</th><th>D</th><th>Character</th></tr>
                    <tr><td>South Africa</td><td>1.02</td><td>Very smooth</td></tr>
                    <tr><td>Australia</td><td>1.13</td><td>Moderately smooth</td></tr>
                    <tr><td>Britain</td><td>1.25</td><td>Moderately jagged</td></tr>
                    <tr><td>Norway</td><td>1.52</td><td>Extremely fjorded</td></tr>
                </table>
            </div>

            <div class="info-card">
                <h3>üìö Historical Timeline</h3>
                <div class="timeline">
                    <div class="timeline-item">
                        <span class="timeline-year">1951</span> - Richardson notices border measurement discrepancies
                    </div>
                    <div class="timeline-item">
                        <span class="timeline-year">1961</span> - Richardson's paper published posthumously
                    </div>
                    <div class="timeline-item">
                        <span class="timeline-year">1967</span> - Mandelbrot publishes "How Long Is the Coast of Britain?"
                    </div>
                    <div class="timeline-item">
                        <span class="timeline-year">1975</span> - Mandelbrot coins the term "fractal"
                    </div>
                </div>
            </div>

            <div class="info-card">
                <h3>ü§Ø The Paradox Deepens</h3>
                <p>The CIA World Factbook and World Resources Institute disagree on Britain's coastline by <strong>4,500 miles</strong>!</p>
                <ul style="margin-top: 10px; padding-left: 20px; color: #94a3b8;">
                    <li>CIA: 7,723 miles (12,429 km)</li>
                    <li>WRI: 12,251 miles (19,717 km)</li>
                </ul>
                <p style="margin-top: 10px;">Neither is "wrong"‚Äîthey just used different measurement scales!</p>
            </div>
        </div>
    </div>

    <script>
        const coastCanvas = document.getElementById('coastCanvas');
        const ctx = coastCanvas.getContext('2d');
        const logCanvas = document.getElementById('logPlot');
        const logCtx = logCanvas.getContext('2d');

        let coastlinePoints = [];
        let currentType = 'britain';
        let currentDimension = 1.25;
        let animating = false;
        let measurements = [];

        // Generate fractal coastline using midpoint displacement
        function generateCoastline(dimension, numPoints = 512) {
            const roughness = Math.pow(2, dimension - 1) * 0.5;
            const points = [];

            // Start with basic shape
            const basePoints = [
                { x: 100, y: 100 },
                { x: 150, y: 150 },
                { x: 200, y: 120 },
                { x: 280, y: 180 },
                { x: 350, y: 150 },
                { x: 420, y: 200 },
                { x: 500, y: 170 },
                { x: 550, y: 220 },
                { x: 600, y: 180 },
                { x: 650, y: 250 },
                { x: 680, y: 320 },
                { x: 650, y: 400 },
                { x: 600, y: 450 },
                { x: 520, y: 480 },
                { x: 450, y: 500 },
                { x: 380, y: 480 },
                { x: 300, y: 450 },
                { x: 250, y: 400 },
                { x: 200, y: 350 },
                { x: 150, y: 280 },
                { x: 120, y: 200 },
                { x: 100, y: 100 }
            ];

            // Apply fractal subdivision
            let currentPoints = [...basePoints];
            const iterations = Math.floor(Math.log2(numPoints / basePoints.length)) + 1;

            for (let iter = 0; iter < iterations; iter++) {
                const newPoints = [];
                const scale = Math.pow(roughness, iter + 1) * 30;

                for (let i = 0; i < currentPoints.length - 1; i++) {
                    const p1 = currentPoints[i];
                    const p2 = currentPoints[i + 1];

                    newPoints.push(p1);

                    // Midpoint with displacement
                    const midX = (p1.x + p2.x) / 2 + (Math.random() - 0.5) * scale;
                    const midY = (p1.y + p2.y) / 2 + (Math.random() - 0.5) * scale;

                    newPoints.push({ x: midX, y: midY });
                }
                newPoints.push(currentPoints[currentPoints.length - 1]);
                currentPoints = newPoints;
            }

            return currentPoints;
        }

        // Measure coastline with given ruler size
        function measureCoastline(points, rulerSize) {
            let totalLength = 0;
            let rulerCount = 0;
            const rulerPositions = [];

            let currentIndex = 0;
            let currentPoint = points[0];
            rulerPositions.push({ ...currentPoint });

            while (currentIndex < points.length - 1) {
                // Find next point at approximately rulerSize distance
                let bestIndex = currentIndex + 1;
                let bestDist = Infinity;

                for (let i = currentIndex + 1; i < points.length; i++) {
                    const dx = points[i].x - currentPoint.x;
                    const dy = points[i].y - currentPoint.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (Math.abs(dist - rulerSize) < Math.abs(bestDist - rulerSize)) {
                        bestDist = dist;
                        bestIndex = i;
                    }

                    if (dist > rulerSize * 1.5) break;
                }

                if (bestIndex >= points.length - 1) {
                    // Last segment
                    const dx = points[points.length - 1].x - currentPoint.x;
                    const dy = points[points.length - 1].y - currentPoint.y;
                    totalLength += Math.sqrt(dx * dx + dy * dy);
                    rulerCount++;
                    rulerPositions.push({ ...points[points.length - 1] });
                    break;
                }

                totalLength += rulerSize;
                rulerCount++;
                currentPoint = points[bestIndex];
                currentIndex = bestIndex;
                rulerPositions.push({ ...currentPoint });
            }

            return { totalLength, rulerCount, rulerPositions };
        }

        // Draw coastline
        function drawCoastline() {
            ctx.clearRect(0, 0, coastCanvas.width, coastCanvas.height);

            // Background gradient (ocean)
            const gradient = ctx.createLinearGradient(0, 0, coastCanvas.width, coastCanvas.height);
            gradient.addColorStop(0, '#0c4a6e');
            gradient.addColorStop(1, '#164e63');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, coastCanvas.width, coastCanvas.height);

            // Draw land mass
            ctx.beginPath();
            ctx.moveTo(coastlinePoints[0].x, coastlinePoints[0].y);
            for (let i = 1; i < coastlinePoints.length; i++) {
                ctx.lineTo(coastlinePoints[i].x, coastlinePoints[i].y);
            }
            ctx.closePath();

            const landGradient = ctx.createLinearGradient(300, 100, 400, 500);
            landGradient.addColorStop(0, '#4ade80');
            landGradient.addColorStop(0.5, '#22c55e');
            landGradient.addColorStop(1, '#16a34a');
            ctx.fillStyle = landGradient;
            ctx.fill();

            // Draw coastline outline
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Draw measurement rulers
        function drawMeasurement(rulerPositions, rulerSize) {
            // Draw ruler segments
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 3;
            ctx.setLineDash([]);

            ctx.beginPath();
            for (let i = 0; i < rulerPositions.length - 1; i++) {
                ctx.moveTo(rulerPositions[i].x, rulerPositions[i].y);
                ctx.lineTo(rulerPositions[i + 1].x, rulerPositions[i + 1].y);
            }
            ctx.stroke();

            // Draw measurement points
            ctx.fillStyle = '#fbbf24';
            for (const pos of rulerPositions) {
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw ruler length indicator
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText(`Ruler: ${rulerSize.toFixed(0)} km`, 20, 30);
        }

        // Draw log-log plot
        function drawLogPlot() {
            logCtx.clearRect(0, 0, logCanvas.width, logCanvas.height);

            // Background
            logCtx.fillStyle = '#0f172a';
            logCtx.fillRect(0, 0, logCanvas.width, logCanvas.height);

            // Axes
            const margin = 60;
            const plotWidth = logCanvas.width - margin * 2;
            const plotHeight = logCanvas.height - margin - 30;

            logCtx.strokeStyle = '#475569';
            logCtx.lineWidth = 1;

            // Y axis
            logCtx.beginPath();
            logCtx.moveTo(margin, 20);
            logCtx.lineTo(margin, plotHeight + 20);
            logCtx.stroke();

            // X axis
            logCtx.beginPath();
            logCtx.moveTo(margin, plotHeight + 20);
            logCtx.lineTo(logCanvas.width - margin, plotHeight + 20);
            logCtx.stroke();

            // Labels
            logCtx.fillStyle = '#94a3b8';
            logCtx.font = '12px sans-serif';
            logCtx.fillText('log(ruler size) ‚Üí', logCanvas.width / 2, plotHeight + 50);

            logCtx.save();
            logCtx.translate(20, plotHeight / 2 + 20);
            logCtx.rotate(-Math.PI / 2);
            logCtx.fillText('log(length) ‚Üí', 0, 0);
            logCtx.restore();

            // Title
            logCtx.fillStyle = '#60a5fa';
            logCtx.font = 'bold 14px sans-serif';
            logCtx.fillText('Richardson Plot (Log-Log)', margin, 15);

            // Plot measurements
            if (measurements.length > 1) {
                const minLogR = Math.log10(5);
                const maxLogR = Math.log10(100);
                const minLogL = Math.min(...measurements.map(m => Math.log10(m.length)));
                const maxLogL = Math.max(...measurements.map(m => Math.log10(m.length)));

                const scaleX = plotWidth / (maxLogR - minLogR);
                const scaleY = plotHeight / (maxLogL - minLogL + 0.5);

                // Draw theoretical line
                logCtx.strokeStyle = 'rgba(139, 92, 246, 0.5)';
                logCtx.lineWidth = 2;
                logCtx.setLineDash([5, 5]);
                logCtx.beginPath();

                const theoreticalY1 = maxLogL + 0.2;
                const theoreticalY2 = theoreticalY1 - (1 - currentDimension) * (maxLogR - minLogR);

                const x1 = margin + (minLogR - minLogR) * scaleX;
                const y1 = 20 + plotHeight - (theoreticalY1 - minLogL) * scaleY;
                const x2 = margin + (maxLogR - minLogR) * scaleX;
                const y2 = 20 + plotHeight - (theoreticalY2 - minLogL) * scaleY;

                logCtx.moveTo(x1, y1);
                logCtx.lineTo(x2, y2);
                logCtx.stroke();
                logCtx.setLineDash([]);

                // Draw data points
                logCtx.fillStyle = '#34d399';
                for (const m of measurements) {
                    const logR = Math.log10(m.rulerSize);
                    const logL = Math.log10(m.length);

                    const x = margin + (logR - minLogR) * scaleX;
                    const y = 20 + plotHeight - (logL - minLogL) * scaleY;

                    logCtx.beginPath();
                    logCtx.arc(x, y, 5, 0, Math.PI * 2);
                    logCtx.fill();
                }

                // Slope annotation
                logCtx.fillStyle = '#a78bfa';
                logCtx.font = '11px sans-serif';
                logCtx.fillText(`Slope = 1 - D = ${(1 - currentDimension).toFixed(2)}`, logCanvas.width - margin - 120, 40);
            }
        }

        // Update display
        function update() {
            const rulerSize = parseInt(document.getElementById('rulerSize').value);
            document.getElementById('rulerDisplay').textContent = `${rulerSize} km`;

            const measurement = measureCoastline(coastlinePoints, rulerSize);

            // Scale to realistic values based on Britain
            const scaleFactor = 2800 / measureCoastline(coastlinePoints, 100).totalLength;
            const realLength = measurement.totalLength * scaleFactor;

            document.getElementById('rulerCount').textContent = measurement.rulerCount;
            document.getElementById('measuredLength').textContent = `${Math.round(realLength).toLocaleString()} km`;

            // Calculate expected lengths
            const length100 = 2800;
            const length1 = Math.round(length100 * Math.pow(100, currentDimension - 1));
            document.getElementById('length100').textContent = `~${length100.toLocaleString()} km`;
            document.getElementById('length1').textContent = `~${length1.toLocaleString()} km`;

            drawCoastline();
            drawMeasurement(measurement.rulerPositions, rulerSize);

            // Add to measurements for log plot
            const existing = measurements.find(m => m.rulerSize === rulerSize);
            if (!existing) {
                measurements.push({ rulerSize, length: realLength });
                measurements.sort((a, b) => b.rulerSize - a.rulerSize);
            }
            drawLogPlot();
        }

        // Animation
        async function animateMeasurement() {
            if (animating) return;
            animating = true;

            const btn = document.getElementById('animateBtn');
            btn.textContent = '‚è∏ Measuring...';

            measurements = [];

            for (let ruler = 100; ruler >= 5; ruler -= 5) {
                document.getElementById('rulerSize').value = ruler;
                update();
                await new Promise(resolve => setTimeout(resolve, 200));
            }

            btn.textContent = '‚ñ∂ Animate Measurement';
            animating = false;
        }

        // Event listeners
        document.getElementById('rulerSize').addEventListener('input', update);
        document.getElementById('animateBtn').addEventListener('click', animateMeasurement);

        document.querySelectorAll('.coastline-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.coastline-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                currentType = btn.dataset.type;
                currentDimension = parseFloat(btn.dataset.dim);
                document.getElementById('fractalDim').textContent = `D = ${currentDimension}`;

                coastlinePoints = generateCoastline(currentDimension);
                measurements = [];
                update();
            });
        });

        // Initialize
        coastlinePoints = generateCoastline(currentDimension);
        update();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
