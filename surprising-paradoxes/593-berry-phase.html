<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Berry Phase - Surprising Paradoxes</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #0a0a12 0%, #1a1a2e 50%, #0f0f1a 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        .back-link {
            display: inline-block;
            color: #f4a261;
            text-decoration: none;
            margin-bottom: 20px;
            font-size: 0.95rem;
            transition: color 0.3s;
        }

        .back-link:hover { color: #e9c46a; }

        h1 {
            font-size: 2.5rem;
            color: #e9c46a;
            margin-bottom: 15px;
            text-shadow: 0 0 40px rgba(233, 196, 106, 0.3);
        }

        .subtitle {
            font-size: 1.2rem;
            color: #8ecae6;
            font-style: italic;
        }

        .visualization-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 40px;
            border: 1px solid rgba(233, 196, 106, 0.2);
        }

        .dual-canvas {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-panel {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .canvas-panel h3 {
            color: #e9c46a;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        canvas {
            border-radius: 8px;
            background: #000;
        }

        .phase-display {
            text-align: center;
            margin: 15px 0;
            padding: 15px;
            background: rgba(142, 202, 230, 0.1);
            border-radius: 10px;
        }

        .phase-value {
            font-size: 2rem;
            color: #e9c46a;
            font-family: 'Courier New', monospace;
        }

        .phase-label {
            color: #8ecae6;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #e9c46a;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group .value {
            text-align: right;
            font-size: 0.8rem;
            color: #8ecae6;
        }

        .btn-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        .btn {
            padding: 10px 20px;
            border: 1px solid rgba(142, 202, 230, 0.5);
            background: rgba(142, 202, 230, 0.1);
            color: #8ecae6;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
        }

        .btn:hover {
            background: rgba(142, 202, 230, 0.25);
        }

        .btn.active {
            background: rgba(142, 202, 230, 0.3);
        }

        .essay {
            line-height: 1.9;
            font-size: 1.1rem;
        }

        .essay h2 {
            color: #e9c46a;
            margin: 40px 0 20px;
            font-size: 1.6rem;
            border-bottom: 1px solid rgba(233, 196, 106, 0.3);
            padding-bottom: 10px;
        }

        .essay h3 {
            color: #f4a261;
            margin: 30px 0 15px;
            font-size: 1.3rem;
        }

        .essay p {
            margin-bottom: 20px;
            text-align: justify;
        }

        .equation {
            background: rgba(142, 202, 230, 0.1);
            padding: 20px;
            margin: 25px 0;
            border-radius: 10px;
            text-align: center;
            font-family: 'Courier New', monospace;
            color: #8ecae6;
            font-size: 1.1rem;
            overflow-x: auto;
        }

        .highlight-box {
            background: linear-gradient(135deg, rgba(233, 196, 106, 0.1), rgba(244, 162, 97, 0.1));
            border-left: 4px solid #e9c46a;
            padding: 20px;
            margin: 25px 0;
            border-radius: 0 10px 10px 0;
        }

        .highlight-box strong {
            color: #e9c46a;
        }

        .sources {
            background: rgba(0, 0, 0, 0.3);
            padding: 25px;
            border-radius: 10px;
            margin-top: 40px;
        }

        .sources h3 {
            color: #e9c46a;
            margin-bottom: 15px;
        }

        .sources ul {
            list-style: none;
        }

        .sources li {
            margin-bottom: 10px;
        }

        .sources a {
            color: #8ecae6;
            text-decoration: none;
        }

        .sources a:hover {
            text-decoration: underline;
        }

        @media (max-width: 700px) {
            .dual-canvas {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">← Back to Surprising Paradoxes</a>
            <h1>The Berry Phase</h1>
            <p class="subtitle">Geometry leaves its fingerprint on quantum states</p>
        </header>

        <div class="visualization-container">
            <div class="dual-canvas">
                <div class="canvas-panel">
                    <h3>Classical Analog: Parallel Transport on Sphere</h3>
                    <canvas id="sphereCanvas" width="350" height="350"></canvas>
                </div>
                <div class="canvas-panel">
                    <h3>Quantum: State Evolution in Parameter Space</h3>
                    <canvas id="quantumCanvas" width="350" height="350"></canvas>
                </div>
            </div>

            <div class="phase-display">
                <div class="phase-value" id="phaseValue">γ = 0.00π</div>
                <div class="phase-label">Accumulated geometric phase (Berry phase)</div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Path Solid Angle (Ω)</label>
                    <input type="range" id="solidAngle" min="0.1" max="2" step="0.05" value="0.5">
                    <div class="value"><span id="angleValue">0.50</span>π sr</div>
                </div>

                <div class="control-group">
                    <label>Evolution Speed</label>
                    <input type="range" id="evolSpeed" min="0.2" max="2" step="0.1" value="0.8">
                    <div class="value"><span id="speedValue">0.8</span>x</div>
                </div>

                <div class="control-group">
                    <label>Path Shape</label>
                    <input type="range" id="pathShape" min="3" max="8" step="1" value="4">
                    <div class="value"><span id="shapeValue">4</span>-sided</div>
                </div>
            </div>

            <div class="btn-row">
                <button class="btn" onclick="resetPath()">Reset</button>
                <button class="btn" id="playBtn" onclick="togglePlay()">Pause</button>
                <button class="btn" onclick="completeCycle()">Complete Cycle</button>
            </div>
        </div>

        <article class="essay">
            <h2>The Phase That Geometry Creates</h2>

            <p>
                In quantum mechanics, we usually think of phase as something that accumulates with time—
                states evolve as e<sup>-iEt/ℏ</sup>, picking up phase proportional to energy and duration.
                But in 1984, Michael Berry discovered something profound: there's another source of phase,
                one that depends purely on <strong>geometry</strong>.
            </p>

            <p>
                When a quantum system is slowly guided around a closed loop in parameter space—returning
                exactly to where it started—it doesn't quite return to its original state. It picks up
                an extra phase factor that depends only on the <em>shape</em> of the path, not on how
                fast or slow you traverse it.
            </p>

            <div class="highlight-box">
                <strong>The Paradox:</strong> Return a quantum state to its starting point, and it's
                different! The wave function acquires a phase γ = -Ω/2, where Ω is the solid angle
                enclosed by the path. Two cycles give twice the phase. The path's geometry permanently
                marks the quantum state.
            </div>

            <h2>The Classical Analog: Parallel Transport</h2>

            <p>
                The Berry phase has a beautiful classical analog that makes the geometry intuitive.
                Imagine carrying an arrow around the Earth, always keeping it "parallel" to itself
                (never rotating it relative to the local surface). Start at the North Pole pointing
                toward London, walk to the equator, around a quarter of the globe, and back to the pole.
            </p>

            <p>
                The arrow has rotated! Even though you never explicitly turned it, the curvature of the
                sphere caused a net rotation. The angle of rotation equals the solid angle enclosed
                by your path. This is the essence of the Berry phase—geometry itself creates a rotation.
            </p>

            <div class="equation">
                Classical: Rotation angle = Solid angle enclosed (Ω)<br><br>
                Quantum: Berry phase γ = -Ω/2 (for spin-1/2)
            </div>

            <h3>The Foucault Pendulum</h3>

            <p>
                The Foucault pendulum demonstrates Berry phase in action. As Earth rotates, the pendulum's
                plane of oscillation appears to rotate—not because anything pushes it, but because parallel
                transport around the sphere (one day = one loop around the Earth's axis) accumulates
                geometric phase.
            </p>

            <p>
                At latitude λ, the daily rotation is 2π sin(λ), which equals the solid angle subtended
                by the pendulum's path as viewed from Earth's center. At the poles, it's 2π (full rotation
                per day). At the equator, it's zero.
            </p>

            <h2>Quantum Geometric Phase</h2>

            <p>
                In quantum mechanics, the parameter space is the space of Hamiltonian parameters. For a
                spin-1/2 particle in a magnetic field, the parameters are the field components
                (B<sub>x</sub>, B<sub>y</sub>, B<sub>z</sub>). As the field direction changes, the
                spin state adiabatically follows, staying in the instantaneous eigenstate.
            </p>

            <p>
                If the field direction traces a closed loop on the unit sphere, the spin state acquires
                Berry phase equal to <strong>minus half the solid angle</strong> enclosed:
            </p>

            <div class="equation">
                γ = -½ Ω = -½ ∫∫ sin(θ) dθ dφ
            </div>

            <p>
                The factor of 1/2 comes from spin-1/2. For spin-s particles, the phase is γ = -s·Ω.
            </p>

            <h2>Why It Matters</h2>

            <h3>Topological Phases of Matter</h3>

            <p>
                The Berry phase underlies the modern classification of topological materials. In
                topological insulators, electrons accumulating Berry phase as they move through the
                Brillouin zone are protected from backscattering. The quantum Hall effect, discovered
                in 1980, is fundamentally a Berry phase phenomenon—the quantized Hall conductance
                equals e²/h times a topological invariant (the Chern number) computed from Berry curvature.
            </p>

            <h3>Geometric Quantum Computation</h3>

            <p>
                Because Berry phase depends only on geometry, not on speed or timing, it's inherently
                robust against certain errors. Geometric quantum gates use Berry phases to manipulate
                qubits in ways that are less sensitive to noise than dynamical approaches.
            </p>

            <h3>Molecular Conical Intersections</h3>

            <p>
                In molecules, when two electronic energy surfaces touch at a point (a conical intersection),
                the electronic wave function acquires a Berry phase of π when carried around the intersection.
                This sign change has dramatic effects on molecular dynamics and photochemistry.
            </p>

            <h2>Berry Curvature and Connection</h2>

            <p>
                The mathematical structure of Berry phase is identical to gauge theory. The
                <strong>Berry connection</strong> A(R) plays the role of a vector potential:
            </p>

            <div class="equation">
                A<sub>n</sub>(R) = i⟨n(R)|∇<sub>R</sub>|n(R)⟩
            </div>

            <p>
                The <strong>Berry curvature</strong> is the "magnetic field" in parameter space:
            </p>

            <div class="equation">
                F = ∇ × A
            </div>

            <p>
                The Berry phase around any loop equals the flux of this curvature through the loop.
                For a sphere, the curvature is constant, giving phase proportional to enclosed area.
            </p>

            <h2>Pancharatnam's Optical Precursor</h2>

            <p>
                Remarkably, the geometric phase was discovered 30 years before Berry's paper—in optics!
                In 1956, S. Pancharatnam showed that light polarization states acquire geometric phases
                when cycled through polarization configurations. This "Pancharatnam phase" is the same
                phenomenon; Berry provided the general quantum framework.
            </p>

            <div class="highlight-box">
                <strong>The Deep Insight:</strong> Geometry is physical. The shape of a path through
                parameter space—not just its endpoints—affects quantum evolution. The universe keeps
                track of the "winding" of quantum states, and this topological memory manifests as
                observable phase. Geometry itself is a force in quantum mechanics.
            </div>

            <div class="sources">
                <h3>Sources & Further Reading</h3>
                <ul>
                    <li><a href="https://en.wikipedia.org/wiki/Geometric_phase">Geometric phase - Wikipedia</a></li>
                    <li><a href="https://en.wikipedia.org/wiki/Berry_connection_and_curvature">Berry connection and curvature - Wikipedia</a></li>
                    <li><a href="https://www.nature.com/articles/s42254-019-0071-1">Geometric phase from Aharonov–Bohm to Pancharatnam–Berry and beyond - Nature Reviews Physics</a></li>
                    <li><a href="https://pines.berkeley.edu/sites/default/files/publications/berrys_phase.pdf">Berry's Phase - Berkeley</a></li>
                    <li><a href="https://arxiv.org/pdf/1912.12596">Geometric phase from Aharonov-Bohm to Pancharatnam–Berry - arXiv</a></li>
                </ul>
            </div>
        </article>
    </div>

    <script>
        const sphereCanvas = document.getElementById('sphereCanvas');
        const quantumCanvas = document.getElementById('quantumCanvas');
        const sphereCtx = sphereCanvas.getContext('2d');
        const quantumCtx = quantumCanvas.getContext('2d');

        // High DPI
        function setupCanvas(canvas, ctx) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            return { width: rect.width, height: rect.height };
        }

        const sphereSize = setupCanvas(sphereCanvas, sphereCtx);
        const quantumSize = setupCanvas(quantumCanvas, quantumCtx);

        // Parameters
        let solidAngle = 0.5;
        let evolSpeed = 0.8;
        let pathSides = 4;
        let playing = true;
        let time = 0;
        let cycleProgress = 0;
        let accumulatedPhase = 0;

        // Controls
        document.getElementById('solidAngle').addEventListener('input', (e) => {
            solidAngle = parseFloat(e.target.value);
            document.getElementById('angleValue').textContent = solidAngle.toFixed(2);
            resetPath();
        });

        document.getElementById('evolSpeed').addEventListener('input', (e) => {
            evolSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = evolSpeed.toFixed(1);
        });

        document.getElementById('pathShape').addEventListener('input', (e) => {
            pathSides = parseInt(e.target.value);
            document.getElementById('shapeValue').textContent = pathSides;
            resetPath();
        });

        function resetPath() {
            cycleProgress = 0;
            accumulatedPhase = 0;
            updatePhaseDisplay();
        }

        function togglePlay() {
            playing = !playing;
            document.getElementById('playBtn').textContent = playing ? 'Pause' : 'Play';
        }

        function completeCycle() {
            cycleProgress = 1;
            accumulatedPhase = solidAngle / 2;
            updatePhaseDisplay();
        }

        function updatePhaseDisplay() {
            const phaseStr = (accumulatedPhase / Math.PI).toFixed(3);
            document.getElementById('phaseValue').textContent = `γ = ${phaseStr}π`;
        }

        function getPathPoint(t, radius) {
            // Create a path that encloses the desired solid angle
            const baseLatitude = Math.PI / 2 - Math.sqrt(solidAngle); // Approximate
            const nPoints = pathSides;
            const segmentFraction = t * nPoints;
            const segment = Math.floor(segmentFraction) % nPoints;
            const frac = segmentFraction - Math.floor(segmentFraction);

            const angle1 = (segment / nPoints) * Math.PI * 2;
            const angle2 = ((segment + 1) / nPoints) * Math.PI * 2;
            const phi = angle1 + (angle2 - angle1) * frac;

            // Latitude varies to create enclosed area
            const theta = baseLatitude;

            // Convert spherical to screen coordinates (orthographic projection)
            const x = radius * Math.sin(theta) * Math.cos(phi);
            const y = radius * Math.cos(theta);
            const z = radius * Math.sin(theta) * Math.sin(phi);

            return { x, y, z, phi, theta };
        }

        function drawSphere(ctx, size) {
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(0, 0, size.width, size.height);

            const centerX = size.width / 2;
            const centerY = size.height / 2;
            const radius = 130;

            // Draw sphere outline
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(142, 202, 230, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw latitude lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let lat = -60; lat <= 60; lat += 30) {
                const r = radius * Math.cos(lat * Math.PI / 180);
                const y = centerY - radius * Math.sin(lat * Math.PI / 180) * 0.5;
                ctx.beginPath();
                ctx.ellipse(centerX, y, r, r * 0.3, 0, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw longitude lines
            for (let lon = 0; lon < 180; lon += 30) {
                ctx.beginPath();
                for (let lat = -90; lat <= 90; lat += 5) {
                    const r = radius;
                    const x = centerX + r * Math.cos(lat * Math.PI / 180) * Math.sin(lon * Math.PI / 180);
                    const y = centerY - r * Math.sin(lat * Math.PI / 180) * 0.5;
                    if (lat === -90) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // Draw the path
            ctx.beginPath();
            ctx.strokeStyle = '#e9c46a';
            ctx.lineWidth = 3;

            for (let t = 0; t <= 1; t += 0.01) {
                const p = getPathPoint(t, radius);
                const screenX = centerX + p.x;
                const screenY = centerY - p.y * 0.5 - p.z * 0.3;
                if (t === 0) ctx.moveTo(screenX, screenY);
                else ctx.lineTo(screenX, screenY);
            }
            ctx.closePath();
            ctx.stroke();

            // Fill enclosed area
            ctx.fillStyle = 'rgba(233, 196, 106, 0.2)';
            ctx.fill();

            // Draw current position with vector
            const pos = getPathPoint(cycleProgress, radius);
            const posX = centerX + pos.x;
            const posY = centerY - pos.y * 0.5 - pos.z * 0.3;

            // Draw vector at current position
            const vectorAngle = -pos.phi + accumulatedPhase * 2;
            const vecLen = 25;

            ctx.beginPath();
            ctx.moveTo(posX, posY);
            ctx.lineTo(posX + Math.cos(vectorAngle) * vecLen, posY - Math.sin(vectorAngle) * vecLen * 0.5);
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Arrow head
            const tipX = posX + Math.cos(vectorAngle) * vecLen;
            const tipY = posY - Math.sin(vectorAngle) * vecLen * 0.5;
            ctx.beginPath();
            ctx.arc(tipX, tipY, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#4CAF50';
            ctx.fill();

            // Position marker
            ctx.beginPath();
            ctx.arc(posX, posY, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#ff6b6b';
            ctx.fill();

            // Labels
            ctx.font = '11px Georgia';
            ctx.fillStyle = '#888';
            ctx.textAlign = 'center';
            ctx.fillText('Parallel transport', centerX, size.height - 30);
            ctx.fillText('on curved surface', centerX, size.height - 15);

            ctx.fillStyle = '#e9c46a';
            ctx.fillText(`Ω = ${(solidAngle).toFixed(2)}π`, centerX, 25);
        }

        function drawQuantum(ctx, size) {
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(0, 0, size.width, size.height);

            const centerX = size.width / 2;
            const centerY = size.height / 2;
            const radius = 100;

            // Draw Bloch sphere wireframe
            ctx.strokeStyle = 'rgba(142, 202, 230, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();

            // Equator
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, radius, radius * 0.3, 0, 0, Math.PI * 2);
            ctx.stroke();

            // Meridian
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, radius * 0.3, radius, 0, 0, Math.PI * 2);
            ctx.stroke();

            // |0⟩ and |1⟩ labels
            ctx.font = '14px Georgia';
            ctx.fillStyle = '#8ecae6';
            ctx.textAlign = 'center';
            ctx.fillText('|↑⟩', centerX, centerY - radius - 15);
            ctx.fillText('|↓⟩', centerX, centerY + radius + 20);

            // Draw parameter path on equator
            ctx.beginPath();
            ctx.strokeStyle = '#e9c46a';
            ctx.lineWidth = 2;
            for (let t = 0; t <= cycleProgress; t += 0.02) {
                const angle = t * Math.PI * 2;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * 0.3 * Math.sin(angle);
                if (t === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Current position in parameter space
            const angle = cycleProgress * Math.PI * 2;
            const posX = centerX + radius * Math.cos(angle);
            const posY = centerY + radius * 0.3 * Math.sin(angle);

            ctx.beginPath();
            ctx.arc(posX, posY, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#ff6b6b';
            ctx.fill();

            // Draw state vector (from center of Bloch sphere)
            // State follows field but with Berry phase rotation
            const stateAngle = angle + Math.PI / 2;
            const stateX = centerX + 70 * Math.cos(stateAngle + accumulatedPhase * 2);
            const stateY = centerY + 70 * 0.3 * Math.sin(stateAngle + accumulatedPhase * 2);

            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(stateX, stateY);
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(stateX, stateY, 6, 0, Math.PI * 2);
            ctx.fillStyle = '#4CAF50';
            ctx.fill();

            // Phase indicator circle
            ctx.beginPath();
            ctx.arc(centerX, size.height - 50, 30, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(142, 202, 230, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Phase arrow
            ctx.beginPath();
            ctx.moveTo(centerX, size.height - 50);
            ctx.lineTo(
                centerX + 25 * Math.cos(-accumulatedPhase * 2),
                size.height - 50 + 25 * Math.sin(-accumulatedPhase * 2)
            );
            ctx.strokeStyle = '#e9c46a';
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.font = '10px Georgia';
            ctx.fillStyle = '#888';
            ctx.fillText('Phase', centerX, size.height - 15);

            // Labels
            ctx.font = '11px Georgia';
            ctx.fillStyle = '#ff6b6b';
            ctx.textAlign = 'left';
            ctx.fillText('Parameter', posX + 15, posY);

            ctx.fillStyle = '#4CAF50';
            ctx.fillText('State', stateX + 10, stateY);
        }

        function animate() {
            time += 0.016;

            if (playing && cycleProgress < 1) {
                cycleProgress += 0.002 * evolSpeed;
                if (cycleProgress > 1) cycleProgress = 1;

                // Accumulate Berry phase (proportional to enclosed solid angle)
                accumulatedPhase = cycleProgress * solidAngle / 2;
                updatePhaseDisplay();
            }

            drawSphere(sphereCtx, sphereSize);
            drawQuantum(quantumCtx, quantumSize);

            requestAnimationFrame(animate);
        }

        // Initialize
        updatePhaseDisplay();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
