<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Coastline Paradox - Surprising Paradoxes</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --ocean: #0077b6;
            --deep-ocean: #023e8a;
            --sand: #f4d35e;
            --coast: #0a9396;
            --land: #588157;
            --cream: #FEFAE0;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #0077b6 0%, #023e8a 50%, #001845 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }
        .wave-bg {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 200%;
            height: 200px;
            opacity: 0.1;
            z-index: 0;
        }
        .wave-bg path {
            fill: var(--sand);
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            position: relative;
            z-index: 1;
        }
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--sand);
            text-decoration: none;
            font-weight: 500;
            margin-bottom: 30px;
            padding: 10px 20px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            transition: all 0.3s ease;
        }
        .back-link:hover {
            background: rgba(255,255,255,0.2);
            transform: translateX(-5px);
        }
        h1 {
            font-family: 'Lora', serif;
            font-size: 2.8rem;
            font-weight: 600;
            margin-bottom: 15px;
            text-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .subtitle {
            font-size: 1.3rem;
            color: rgba(255,255,255,0.8);
            margin-bottom: 40px;
            max-width: 700px;
            line-height: 1.7;
        }
        .intro-box {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 40px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .intro-box p {
            line-height: 1.8;
            margin-bottom: 15px;
        }
        .intro-box p:last-child { margin-bottom: 0; }
        .highlight {
            color: var(--sand);
            font-weight: 600;
        }
        .simulation-area {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 30px;
            margin-bottom: 40px;
        }
        @media (max-width: 900px) {
            .simulation-area { grid-template-columns: 1fr; }
        }
        .canvas-container {
            background: rgba(0,0,0,0.3);
            border-radius: 20px;
            padding: 20px;
            position: relative;
        }
        #coastCanvas {
            width: 100%;
            height: 500px;
            border-radius: 12px;
            background: linear-gradient(180deg, #48cae4 0%, #0077b6 100%);
        }
        .controls {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .control-group {
            margin-bottom: 25px;
        }
        .control-label {
            display: block;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--sand);
        }
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.2);
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--sand);
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        .value-display {
            text-align: center;
            font-size: 1.3rem;
            font-weight: 700;
            color: #fff;
            margin-top: 10px;
        }
        .stats-grid {
            display: grid;
            gap: 15px;
            margin-top: 25px;
        }
        .stat-box {
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }
        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--sand);
        }
        .stat-label {
            font-size: 0.85rem;
            color: rgba(255,255,255,0.7);
            margin-top: 5px;
        }
        .coastline-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        .coast-btn {
            padding: 10px 18px;
            border: 2px solid rgba(255,255,255,0.3);
            background: transparent;
            color: #fff;
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Nunito', sans-serif;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        .coast-btn:hover {
            background: rgba(255,255,255,0.1);
        }
        .coast-btn.active {
            background: var(--sand);
            color: #023e8a;
            border-color: var(--sand);
        }
        .log-plot-section {
            margin-top: 40px;
        }
        .log-plot-section h2 {
            font-family: 'Lora', serif;
            font-size: 1.8rem;
            margin-bottom: 20px;
        }
        #logPlotCanvas {
            width: 100%;
            height: 350px;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
        }
        .formula-box {
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
            text-align: center;
            font-family: 'Georgia', serif;
        }
        .formula {
            font-size: 1.5rem;
            color: var(--sand);
            margin-bottom: 15px;
        }
        .formula-explanation {
            font-size: 0.95rem;
            color: rgba(255,255,255,0.7);
        }
        .examples-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 40px;
        }
        .example-card {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .example-card h4 {
            color: var(--sand);
            margin-bottom: 10px;
            font-family: 'Lora', serif;
        }
        .example-card p {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.8);
            line-height: 1.6;
        }
        .dimension-value {
            display: inline-block;
            background: rgba(244,211,94,0.2);
            color: var(--sand);
            padding: 4px 10px;
            border-radius: 8px;
            font-weight: 700;
            margin-top: 10px;
        }
        .history-section {
            margin-top: 50px;
            padding: 30px;
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
        }
        .history-section h3 {
            font-family: 'Lora', serif;
            color: var(--sand);
            margin-bottom: 20px;
        }
        .timeline {
            position: relative;
            padding-left: 30px;
            border-left: 3px solid rgba(255,255,255,0.2);
        }
        .timeline-item {
            margin-bottom: 25px;
            position: relative;
        }
        .timeline-item::before {
            content: '';
            position: absolute;
            left: -36px;
            top: 5px;
            width: 12px;
            height: 12px;
            background: var(--sand);
            border-radius: 50%;
        }
        .timeline-year {
            font-weight: 700;
            color: var(--sand);
        }
        .sources {
            margin-top: 50px;
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-radius: 15px;
            font-size: 0.85rem;
        }
        .sources h4 {
            color: var(--sand);
            margin-bottom: 10px;
        }
        .sources a {
            color: rgba(255,255,255,0.7);
            text-decoration: none;
        }
        .sources a:hover {
            color: var(--sand);
        }
    </style>
</head>
<body>
    <svg class="wave-bg" viewBox="0 0 1440 200" preserveAspectRatio="none">
        <path d="M0,100 C320,180 420,40 720,100 C1020,160 1120,60 1440,100 L1440,200 L0,200 Z"></path>
    </svg>
    
    <div class="container">
        <a href="index.html" class="back-link">← Back to Paradoxes</a>
        
        <h1>The Coastline Paradox</h1>
        <p class="subtitle">The length of a coastline depends on how you measure it—and can approach infinity</p>
        
        <div class="intro-box">
            <p>How long is the coast of Britain? It seems like a simple question with a definite answer. But in 1967, mathematician <span class="highlight">Benoit Mandelbrot</span> revealed a mind-bending truth: coastlines don't have well-defined lengths at all.</p>
            <p>The more precisely you measure, the longer the coastline becomes. Use a 100 km ruler and Britain's coast is about <span class="highlight">2,800 km</span>. Use a 1 km ruler and it jumps to over <span class="highlight">8,000 km</span>. As your ruler approaches zero, the length approaches infinity!</p>
        </div>
        
        <div class="simulation-area">
            <div class="canvas-container">
                <canvas id="coastCanvas"></canvas>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label class="control-label">Ruler Size (km)</label>
                    <input type="range" id="rulerSize" min="5" max="100" value="50">
                    <div class="value-display"><span id="rulerValue">50</span> km</div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Choose Coastline</label>
                    <div class="coastline-selector">
                        <button class="coast-btn active" data-coast="britain">Britain</button>
                        <button class="coast-btn" data-coast="norway">Norway</button>
                        <button class="coast-btn" data-coast="africa">South Africa</button>
                        <button class="coast-btn" data-coast="koch">Koch Curve</button>
                    </div>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-value" id="measuredLength">0</div>
                        <div class="stat-label">Measured Length (km)</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="segmentCount">0</div>
                        <div class="stat-label">Number of Segments</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="fractalDim">1.25</div>
                        <div class="stat-label">Fractal Dimension</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="formula-box">
            <div class="formula">L(ε) = Mε<sup>1-D</sup></div>
            <div class="formula-explanation">
                Where L is the measured length, ε is the ruler size, M is a constant, and D is the fractal dimension.<br>
                As ε → 0, the length L → ∞ for any D > 1.
            </div>
        </div>
        
        <div class="log-plot-section">
            <h2>The Richardson Effect</h2>
            <p style="margin-bottom: 20px; color: rgba(255,255,255,0.8);">Plot log(length) vs log(ruler size)—you get a straight line! The slope reveals the fractal dimension.</p>
            <canvas id="logPlotCanvas"></canvas>
        </div>
        
        <h2 style="font-family: 'Lora', serif; margin-top: 50px; margin-bottom: 20px;">Fractal Dimensions of Real Coastlines</h2>
        <div class="examples-grid">
            <div class="example-card">
                <h4>South Africa Coast</h4>
                <p>One of the smoothest coastlines in the world, with gentle curves and few inlets.</p>
                <div class="dimension-value">D ≈ 1.02</div>
            </div>
            <div class="example-card">
                <h4>Australia Coast</h4>
                <p>Moderately complex with some bays and peninsulas.</p>
                <div class="dimension-value">D ≈ 1.13</div>
            </div>
            <div class="example-card">
                <h4>Britain Coast</h4>
                <p>Highly irregular with countless inlets, bays, and peninsulas.</p>
                <div class="dimension-value">D ≈ 1.25</div>
            </div>
            <div class="example-card">
                <h4>Norway Coast</h4>
                <p>Extremely complex fjord coastline, one of the most irregular on Earth.</p>
                <div class="dimension-value">D ≈ 1.52</div>
            </div>
            <div class="example-card">
                <h4>Koch Snowflake</h4>
                <p>The theoretical fractal with exactly known dimension—infinitely long perimeter enclosing finite area.</p>
                <div class="dimension-value">D = log(4)/log(3) ≈ 1.26</div>
            </div>
            <div class="example-card">
                <h4>Lake Shorelines</h4>
                <p>Lakes typically have more complex boundaries than ocean coasts due to erosion patterns.</p>
                <div class="dimension-value">D ≈ 1.28 (typical)</div>
            </div>
        </div>
        
        <div class="history-section">
            <h3>A Brief History</h3>
            <div class="timeline">
                <div class="timeline-item">
                    <div class="timeline-year">1951</div>
                    <p>Lewis Fry Richardson, researching whether border lengths affect war probability, notices Spain and Portugal disagree on their shared border length by 227 km!</p>
                </div>
                <div class="timeline-item">
                    <div class="timeline-year">1961</div>
                    <p>Richardson publishes his findings posthumously. He discovers the "Richardson effect": measured length increases as ruler size decreases.</p>
                </div>
                <div class="timeline-item">
                    <div class="timeline-year">1967</div>
                    <p>Benoit Mandelbrot publishes "How Long Is the Coast of Britain?" in Science, connecting Richardson's observations to fractional dimensions.</p>
                </div>
                <div class="timeline-item">
                    <div class="timeline-year">1975</div>
                    <p>Mandelbrot coins the term "fractal" and publishes his seminal work, revolutionizing our understanding of natural geometry.</p>
                </div>
            </div>
        </div>
        
        <div class="sources">
            <h4>Sources</h4>
            <p>
                <a href="https://en.wikipedia.org/wiki/Coastline_paradox">Wikipedia: Coastline Paradox</a> • 
                <a href="https://www.britannica.com/science/coastline-paradox">Britannica: Coastline Paradox</a> • 
                <a href="https://mathworld.wolfram.com/CoastlineParadox.html">Wolfram MathWorld</a>
            </p>
        </div>
    </div>
    
    <script>
        // Coastline data with fractal dimensions
        const coastlines = {
            britain: {
                name: 'Britain',
                dimension: 1.25,
                baseLength: 2800,
                color: '#588157',
                points: generateFractalCoast(1.25, 200)
            },
            norway: {
                name: 'Norway',
                dimension: 1.52,
                baseLength: 25000,
                color: '#2d6a4f',
                points: generateFractalCoast(1.52, 200)
            },
            africa: {
                name: 'South Africa',
                dimension: 1.02,
                baseLength: 2800,
                color: '#bc6c25',
                points: generateFractalCoast(1.02, 200)
            },
            koch: {
                name: 'Koch Curve',
                dimension: Math.log(4) / Math.log(3),
                baseLength: 1000,
                color: '#9d4edd',
                points: generateKochCurve(4)
            }
        };
        
        let currentCoast = 'britain';
        let rulerSize = 50;
        let measurementPoints = [];
        let logPlotData = [];
        
        // Generate fractal-like coastline with given dimension
        function generateFractalCoast(dimension, numPoints) {
            const points = [];
            const roughness = (dimension - 1) * 2;
            
            // Midpoint displacement algorithm
            let segments = [{x: 0, y: 0.3}, {x: 1, y: 0.3}];
            
            for (let iter = 0; iter < 8; iter++) {
                const newSegments = [];
                for (let i = 0; i < segments.length - 1; i++) {
                    const p1 = segments[i];
                    const p2 = segments[i + 1];
                    const mid = {
                        x: (p1.x + p2.x) / 2,
                        y: (p1.y + p2.y) / 2 + (Math.random() - 0.5) * roughness * Math.pow(0.5, iter)
                    };
                    newSegments.push(p1);
                    newSegments.push(mid);
                }
                newSegments.push(segments[segments.length - 1]);
                segments = newSegments;
            }
            
            return segments;
        }
        
        // Generate Koch curve
        function generateKochCurve(iterations) {
            let points = [{x: 0, y: 0.5}, {x: 1, y: 0.5}];
            
            for (let i = 0; i < iterations; i++) {
                const newPoints = [];
                for (let j = 0; j < points.length - 1; j++) {
                    const p1 = points[j];
                    const p2 = points[j + 1];
                    
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    
                    const a = {x: p1.x + dx/3, y: p1.y + dy/3};
                    const c = {x: p1.x + 2*dx/3, y: p1.y + 2*dy/3};
                    
                    // Peak of the triangle
                    const angle = Math.PI / 3;
                    const b = {
                        x: a.x + (dx/3) * Math.cos(angle) - (dy/3) * Math.sin(angle),
                        y: a.y + (dx/3) * Math.sin(angle) + (dy/3) * Math.cos(angle)
                    };
                    
                    newPoints.push(p1, a, b, c);
                }
                newPoints.push(points[points.length - 1]);
                points = newPoints;
            }
            
            return points;
        }
        
        // Measure coastline with given ruler size
        function measureCoastline(points, rulerSize, canvasWidth) {
            const scaledRuler = rulerSize / 100; // Normalize
            const measured = [points[0]];
            let currentPoint = points[0];
            let totalLength = 0;
            
            while (true) {
                let bestPoint = null;
                let bestDist = Infinity;
                
                // Find the farthest point within ruler distance
                for (const point of points) {
                    const dist = Math.sqrt(
                        Math.pow(point.x - currentPoint.x, 2) + 
                        Math.pow(point.y - currentPoint.y, 2)
                    );
                    
                    if (dist <= scaledRuler && dist > 0.001) {
                        if (point.x > currentPoint.x || (point.x === currentPoint.x && point.y > currentPoint.y)) {
                            if (dist > bestDist * 0.8 || point.x > bestPoint?.x) {
                                bestPoint = point;
                                bestDist = dist;
                            }
                        }
                    }
                }
                
                if (!bestPoint) {
                    // Find closest point ahead that we haven't passed
                    for (const point of points) {
                        if (point.x > currentPoint.x) {
                            const dist = Math.sqrt(
                                Math.pow(point.x - currentPoint.x, 2) + 
                                Math.pow(point.y - currentPoint.y, 2)
                            );
                            if (!bestPoint || point.x < bestPoint.x) {
                                bestPoint = point;
                                bestDist = dist;
                            }
                        }
                    }
                }
                
                if (!bestPoint || bestPoint.x >= 0.99) {
                    measured.push(points[points.length - 1]);
                    totalLength += Math.sqrt(
                        Math.pow(points[points.length - 1].x - currentPoint.x, 2) + 
                        Math.pow(points[points.length - 1].y - currentPoint.y, 2)
                    );
                    break;
                }
                
                measured.push(bestPoint);
                totalLength += bestDist;
                currentPoint = bestPoint;
            }
            
            return { points: measured, length: totalLength };
        }
        
        // Main canvas rendering
        const canvas = document.getElementById('coastCanvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth - 40;
            canvas.height = 500;
            draw();
        }
        
        function draw() {
            const coast = coastlines[currentCoast];
            const points = coast.points;
            
            // Clear
            ctx.fillStyle = 'rgba(0, 119, 182, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw water pattern
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            for (let i = 0; i < 10; i++) {
                ctx.beginPath();
                ctx.moveTo(0, 50 + i * 50);
                for (let x = 0; x < canvas.width; x += 20) {
                    ctx.lineTo(x, 50 + i * 50 + Math.sin(x * 0.02 + Date.now() * 0.001 + i) * 5);
                }
                ctx.stroke();
            }
            
            // Draw land
            ctx.fillStyle = coast.color;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            for (const point of points) {
                ctx.lineTo(point.x * canvas.width, point.y * canvas.height);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();
            
            // Draw coastline
            ctx.strokeStyle = '#f4d35e';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                if (i === 0) {
                    ctx.moveTo(point.x * canvas.width, point.y * canvas.height);
                } else {
                    ctx.lineTo(point.x * canvas.width, point.y * canvas.height);
                }
            }
            ctx.stroke();
            
            // Measure with current ruler
            const measurement = measureCoastline(points, rulerSize, canvas.width);
            measurementPoints = measurement.points;
            
            // Draw ruler measurements
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            for (let i = 0; i < measurementPoints.length; i++) {
                const point = measurementPoints[i];
                if (i === 0) {
                    ctx.moveTo(point.x * canvas.width, point.y * canvas.height);
                } else {
                    ctx.lineTo(point.x * canvas.width, point.y * canvas.height);
                }
            }
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw measurement points
            ctx.fillStyle = '#ff6b6b';
            for (const point of measurementPoints) {
                ctx.beginPath();
                ctx.arc(point.x * canvas.width, point.y * canvas.height, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Calculate displayed length using Richardson's formula
            const baseLength = coast.baseLength;
            const D = coast.dimension;
            const measuredLength = Math.round(baseLength * Math.pow(rulerSize / 100, 1 - D));
            
            // Update stats
            document.getElementById('measuredLength').textContent = measuredLength.toLocaleString();
            document.getElementById('segmentCount').textContent = measurementPoints.length - 1;
            document.getElementById('fractalDim').textContent = D.toFixed(2);
            
            // Update log plot
            updateLogPlot();
        }
        
        // Log-log plot
        const logCanvas = document.getElementById('logPlotCanvas');
        const logCtx = logCanvas.getContext('2d');
        
        function resizeLogCanvas() {
            const container = logCanvas.parentElement;
            logCanvas.width = container.clientWidth;
            logCanvas.height = 350;
        }
        
        function updateLogPlot() {
            const coast = coastlines[currentCoast];
            const D = coast.dimension;
            const baseLength = coast.baseLength;
            
            // Generate data points for various ruler sizes
            const dataPoints = [];
            for (let r = 5; r <= 100; r += 5) {
                const length = baseLength * Math.pow(r / 100, 1 - D);
                dataPoints.push({
                    logRuler: Math.log10(r),
                    logLength: Math.log10(length),
                    ruler: r
                });
            }
            
            // Clear
            logCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            logCtx.fillRect(0, 0, logCanvas.width, logCanvas.height);
            
            // Margins
            const margin = { top: 40, right: 40, bottom: 60, left: 80 };
            const plotWidth = logCanvas.width - margin.left - margin.right;
            const plotHeight = logCanvas.height - margin.top - margin.bottom;
            
            // Scales
            const xMin = Math.log10(5);
            const xMax = Math.log10(100);
            const yMin = Math.min(...dataPoints.map(d => d.logLength)) - 0.1;
            const yMax = Math.max(...dataPoints.map(d => d.logLength)) + 0.1;
            
            const scaleX = (logX) => margin.left + (logX - xMin) / (xMax - xMin) * plotWidth;
            const scaleY = (logY) => margin.top + plotHeight - (logY - yMin) / (yMax - yMin) * plotHeight;
            
            // Grid
            logCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            logCtx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = margin.top + i * plotHeight / 5;
                logCtx.beginPath();
                logCtx.moveTo(margin.left, y);
                logCtx.lineTo(logCanvas.width - margin.right, y);
                logCtx.stroke();
            }
            
            // Axes
            logCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            logCtx.lineWidth = 2;
            logCtx.beginPath();
            logCtx.moveTo(margin.left, margin.top);
            logCtx.lineTo(margin.left, margin.top + plotHeight);
            logCtx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
            logCtx.stroke();
            
            // Draw best fit line
            logCtx.strokeStyle = 'rgba(244, 211, 94, 0.5)';
            logCtx.lineWidth = 3;
            logCtx.beginPath();
            logCtx.moveTo(scaleX(xMin), scaleY(dataPoints[0].logLength - (xMin - dataPoints[0].logRuler) * (1 - D)));
            logCtx.lineTo(scaleX(xMax), scaleY(dataPoints[dataPoints.length-1].logLength + (xMax - dataPoints[dataPoints.length-1].logRuler) * (1 - D)));
            logCtx.stroke();
            
            // Plot data points
            logCtx.fillStyle = '#f4d35e';
            for (const point of dataPoints) {
                logCtx.beginPath();
                logCtx.arc(scaleX(point.logRuler), scaleY(point.logLength), 5, 0, Math.PI * 2);
                logCtx.fill();
            }
            
            // Highlight current point
            const currentLogRuler = Math.log10(rulerSize);
            const currentLength = baseLength * Math.pow(rulerSize / 100, 1 - D);
            const currentLogLength = Math.log10(currentLength);
            
            logCtx.fillStyle = '#ff6b6b';
            logCtx.beginPath();
            logCtx.arc(scaleX(currentLogRuler), scaleY(currentLogLength), 8, 0, Math.PI * 2);
            logCtx.fill();
            
            // Labels
            logCtx.fillStyle = '#fff';
            logCtx.font = '14px Nunito';
            logCtx.textAlign = 'center';
            logCtx.fillText('log(Ruler Size)', logCanvas.width / 2, logCanvas.height - 15);
            
            logCtx.save();
            logCtx.translate(25, logCanvas.height / 2);
            logCtx.rotate(-Math.PI / 2);
            logCtx.fillText('log(Measured Length)', 0, 0);
            logCtx.restore();
            
            // Slope annotation
            logCtx.fillStyle = 'rgba(244, 211, 94, 0.9)';
            logCtx.font = '16px Nunito';
            logCtx.textAlign = 'left';
            logCtx.fillText(`Slope = 1 - D = ${(1 - D).toFixed(2)}`, margin.left + 20, margin.top + 30);
            logCtx.fillText(`D = ${D.toFixed(2)}`, margin.left + 20, margin.top + 55);
        }
        
        // Event listeners
        document.getElementById('rulerSize').addEventListener('input', (e) => {
            rulerSize = parseInt(e.target.value);
            document.getElementById('rulerValue').textContent = rulerSize;
            draw();
        });
        
        document.querySelectorAll('.coast-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.coast-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentCoast = btn.dataset.coast;
                draw();
            });
        });
        
        // Animation loop for waves
        function animate() {
            draw();
            requestAnimationFrame(animate);
        }
        
        // Initialize
        window.addEventListener('resize', () => {
            resizeCanvas();
            resizeLogCanvas();
        });
        
        resizeCanvas();
        resizeLogCanvas();
        animate();
    </script>
</body>
</html>
