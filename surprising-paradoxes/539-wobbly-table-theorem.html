<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Wobbly Table Theorem - Surprising Paradoxes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00d9ff;
            text-decoration: none;
            font-size: 14px;
            z-index: 100;
            padding: 8px 16px;
            background: rgba(0, 217, 255, 0.1);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }

        .back-link:hover {
            background: rgba(0, 217, 255, 0.2);
        }

        header {
            text-align: center;
            padding: 60px 20px 20px;
        }

        h1 {
            font-size: clamp(1.8rem, 5vw, 2.8rem);
            background: linear-gradient(135deg, #00d9ff, #00ff88, #ffcc00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
        }

        .subtitle {
            font-size: 1.1rem;
            color: #9e9e9e;
            max-width: 700px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .main-container {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            max-width: 1400px;
            margin: 20px auto;
            padding: 0 20px;
        }

        @media (max-width: 1000px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }

        .viz-panel {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
            min-height: 500px;
        }

        #scene-container {
            width: 100%;
            height: 450px;
            border-radius: 12px;
            overflow: hidden;
            background: #0a0a15;
        }

        .controls-panel {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 25px;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group h3 {
            color: #00d9ff;
            font-size: 1rem;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .angle-display {
            font-size: 3rem;
            font-weight: bold;
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
            margin: 10px 0;
        }

        .angle-label {
            text-align: center;
            color: #888;
            font-size: 0.9rem;
        }

        input[type="range"] {
            width: 100%;
            height: 10px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            border-radius: 5px;
            outline: none;
            margin: 10px 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 28px;
            height: 28px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.5);
            cursor: grab;
        }

        button {
            width: 100%;
            padding: 15px;
            font-size: 1rem;
            background: linear-gradient(135deg, #00d9ff, #00ff88);
            border: none;
            border-radius: 12px;
            color: #0a0a15;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 5px 0;
        }

        button:hover {
            transform: scale(1.02);
            box-shadow: 0 5px 25px rgba(0, 255, 136, 0.3);
        }

        .status-box {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 12px;
            margin: 15px 0;
        }

        .leg-status {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .leg {
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-size: 0.85rem;
            transition: background 0.3s;
        }

        .leg.touching {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
        }

        .leg.floating {
            background: rgba(255, 100, 100, 0.2);
            border: 1px solid #ff6464;
            color: #ff6464;
        }

        .wobble-indicator {
            text-align: center;
            padding: 15px;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: bold;
            margin: 15px 0;
        }

        .wobble-indicator.stable {
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
        }

        .wobble-indicator.unstable {
            background: rgba(255, 204, 0, 0.2);
            border: 2px solid #ffcc00;
            color: #ffcc00;
        }

        .graph-container {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
        }

        .graph-container h4 {
            color: #00d9ff;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        #wobbleGraph {
            width: 100%;
            height: 120px;
            background: #0a0a15;
            border-radius: 8px;
        }

        .explanation {
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.1), rgba(0, 255, 136, 0.1));
            border-radius: 20px;
            padding: 30px;
            margin: 30px auto;
            max-width: 1360px;
        }

        .explanation h2 {
            color: #00ff88;
            margin-bottom: 20px;
        }

        .explanation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .exp-card {
            background: rgba(0,0,0,0.2);
            padding: 20px;
            border-radius: 12px;
        }

        .exp-card h3 {
            color: #00d9ff;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .exp-card p {
            color: #bdbdbd;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .math-highlight {
            background: rgba(255, 204, 0, 0.1);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ffcc00;
            margin: 15px 0;
            font-family: 'Times New Roman', serif;
            font-size: 1.1rem;
            text-align: center;
        }

        footer {
            text-align: center;
            padding: 40px 20px;
            color: #616161;
            font-size: 0.85rem;
        }

        footer a {
            color: #00d9ff;
            text-decoration: none;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <header>
        <h1>The Wobbly Table Theorem</h1>
        <p class="subtitle">
            That annoying restaurant table that rocks back and forth?
            Mathematics <em>guarantees</em> you can fix it by just rotating it‚Äîno napkins needed!
            Rotate by at most 90¬∞ and the table will be stable.
        </p>
    </header>

    <div class="main-container">
        <div class="viz-panel">
            <div id="scene-container"></div>
        </div>

        <div class="controls-panel">
            <div class="control-group">
                <h3>Table Rotation</h3>
                <div class="angle-display" id="angleDisplay">0¬∞</div>
                <div class="angle-label">Rotation Angle</div>
                <input type="range" id="angleSlider" min="0" max="90" value="0" step="0.5">
            </div>

            <button onclick="autoStabilize()">‚ú® Auto-Stabilize!</button>
            <button onclick="randomizeFloor()" style="background: linear-gradient(135deg, #9b59b6, #e74c3c);">
                üé≤ New Random Floor
            </button>

            <div class="wobble-indicator" id="wobbleIndicator">
                Checking stability...
            </div>

            <div class="status-box">
                <h3 style="color: #00d9ff; font-size: 0.9rem; margin-bottom: 10px;">Leg Status</h3>
                <div class="leg-status">
                    <div class="leg" id="leg1">Leg 1: --</div>
                    <div class="leg" id="leg2">Leg 2: --</div>
                    <div class="leg" id="leg3">Leg 3: --</div>
                    <div class="leg" id="leg4">Leg 4: --</div>
                </div>
            </div>

            <div class="graph-container">
                <h4>Wobble Function w(Œ∏)</h4>
                <canvas id="wobbleGraph"></canvas>
                <p style="color: #888; font-size: 0.8rem; margin-top: 8px; text-align: center;">
                    When w(Œ∏) crosses zero, the table is stable!
                </p>
            </div>
        </div>
    </div>

    <div class="explanation">
        <h2>How Does This Work?</h2>
        <div class="explanation-grid">
            <div class="exp-card">
                <h3>The Setup</h3>
                <p>Imagine a square table with 4 equal-length legs on an uneven floor.
                   At any position, 3 legs touch the ground while 1 leg floats (or 2 diagonal legs
                   float while the other 2 touch).</p>
            </div>
            <div class="exp-card">
                <h3>The Key Insight</h3>
                <p>Define a "wobble function" w(Œ∏) = height of floating diagonal pair minus
                   height of touching diagonal pair. As you rotate, this function changes
                   <strong>continuously</strong>.</p>
            </div>
            <div class="exp-card">
                <h3>The Math Magic</h3>
                <p>At Œ∏=0¬∞, suppose w(0) > 0 (one diagonal floats). At Œ∏=90¬∞, the table is in
                   the same position but rotated, so w(90¬∞) = ‚àíw(0) < 0. By the <strong>Intermediate
                   Value Theorem</strong>, w(Œ∏) = 0 somewhere in between!</p>
            </div>
            <div class="exp-card">
                <h3>The Guarantee</h3>
                <p>Mathematics guarantees a stable position exists within 90¬∞ of rotation.
                   This was rigorously proved in 2005 by Baritompa, L√∂wen, Polster, and Ross,
                   though the idea dates to the 1960s.</p>
            </div>
        </div>

        <div class="math-highlight">
            w(0) > 0 and w(90¬∞) < 0 ‚üπ ‚àÉŒ∏* ‚àà (0¬∞, 90¬∞) such that w(Œ∏*) = 0
            <br><small style="color: #888;">The Intermediate Value Theorem at work!</small>
        </div>
    </div>

    <footer>
        <p>Part of <a href="index.html">Surprising Paradoxes</a> |
           Next time you're at a restaurant, try it!</p>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Three.js scene setup
        let scene, camera, renderer, table, floor;
        let floorHeightMap = [];
        const tableSize = 2;
        const legLength = 1.5;
        let currentAngle = 0;
        let stableAngle = null;

        function init() {
            const container = document.getElementById('scene-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a15);

            // Camera
            camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
            camera.position.set(5, 4, 5);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0x00d9ff, 0.5);
            pointLight.position.set(-3, 5, -3);
            scene.add(pointLight);

            // Create floor and table
            createFloor();
            createTable();

            // Initial update
            updateTable();
            animate();

            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }

        function createFloor() {
            // Generate random height map for uneven floor
            generateFloorHeightMap();

            const geometry = new THREE.PlaneGeometry(8, 8, 32, 32);
            const positions = geometry.attributes.position.array;

            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                positions[i + 2] = getFloorHeight(x, y);
            }

            geometry.computeVertexNormals();

            const material = new THREE.MeshStandardMaterial({
                color: 0x2a2a4a,
                roughness: 0.8,
                metalness: 0.2,
                side: THREE.DoubleSide
            });

            floor = new THREE.Mesh(geometry, material);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Add grid helper
            const gridHelper = new THREE.GridHelper(8, 16, 0x444466, 0x333355);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);
        }

        function generateFloorHeightMap() {
            // Create bumpy floor using multiple sine waves
            floorHeightMap = {
                frequencies: [
                    { fx: Math.random() * 0.5 + 0.3, fy: Math.random() * 0.5 + 0.3, amp: Math.random() * 0.15 + 0.05, phase: Math.random() * Math.PI * 2 },
                    { fx: Math.random() * 0.8 + 0.2, fy: Math.random() * 0.8 + 0.2, amp: Math.random() * 0.1 + 0.03, phase: Math.random() * Math.PI * 2 },
                    { fx: Math.random() * 1.2 + 0.5, fy: Math.random() * 1.2 + 0.5, amp: Math.random() * 0.05 + 0.02, phase: Math.random() * Math.PI * 2 }
                ]
            };
        }

        function getFloorHeight(x, y) {
            let h = 0;
            for (const wave of floorHeightMap.frequencies) {
                h += wave.amp * Math.sin(wave.fx * x + wave.phase) * Math.cos(wave.fy * y + wave.phase);
            }
            return h;
        }

        function createTable() {
            table = new THREE.Group();

            // Table top
            const topGeometry = new THREE.BoxGeometry(tableSize, 0.1, tableSize);
            const topMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b4513,
                roughness: 0.6,
                metalness: 0.1
            });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = legLength;
            top.castShadow = true;
            table.add(top);

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.05, 0.05, legLength, 8);
            const legMaterial = new THREE.MeshStandardMaterial({
                color: 0x654321,
                roughness: 0.7
            });

            const legPositions = [
                [-tableSize/2 + 0.1, 0, -tableSize/2 + 0.1],
                [tableSize/2 - 0.1, 0, -tableSize/2 + 0.1],
                [tableSize/2 - 0.1, 0, tableSize/2 - 0.1],
                [-tableSize/2 + 0.1, 0, tableSize/2 - 0.1]
            ];

            table.legs = [];
            table.legIndicators = [];

            legPositions.forEach((pos, i) => {
                const leg = new THREE.Mesh(legGeometry, legMaterial.clone());
                leg.position.set(pos[0], legLength / 2, pos[2]);
                leg.castShadow = true;
                table.add(leg);
                table.legs.push(leg);

                // Leg indicator (glowing sphere at bottom)
                const indicatorGeometry = new THREE.SphereGeometry(0.08, 16, 16);
                const indicatorMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
                const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
                indicator.position.set(pos[0], 0, pos[2]);
                table.add(indicator);
                table.legIndicators.push(indicator);
            });

            scene.add(table);
        }

        function updateTable() {
            const angle = currentAngle * Math.PI / 180;
            table.rotation.y = angle;

            // Calculate leg positions in world coordinates
            const legWorldPositions = [];
            const halfSize = tableSize / 2 - 0.1;
            const localPositions = [
                [-halfSize, -halfSize],
                [halfSize, -halfSize],
                [halfSize, halfSize],
                [-halfSize, halfSize]
            ];

            localPositions.forEach(([lx, lz]) => {
                const wx = lx * Math.cos(angle) - lz * Math.sin(angle);
                const wz = lx * Math.sin(angle) + lz * Math.cos(angle);
                legWorldPositions.push({ x: wx, z: wz, floorHeight: getFloorHeight(wx, wz) });
            });

            // Find the three highest floor heights (these legs will touch)
            const heights = legWorldPositions.map((p, i) => ({ index: i, height: p.floorHeight }));
            heights.sort((a, b) => b.height - a.height);

            // Calculate table height (supported by highest 3 legs, adjusted for diagonal support)
            const supportHeight = heights[0].height;
            table.position.y = supportHeight;

            // Update leg indicators
            const legStatus = [];
            legWorldPositions.forEach((pos, i) => {
                const legBottom = supportHeight;
                const floorAtLeg = pos.floorHeight;
                const gap = legBottom - floorAtLeg;

                const indicator = table.legIndicators[i];
                indicator.position.y = floorAtLeg + 0.08;

                if (gap < 0.02) {
                    indicator.material.color.setHex(0x00ff88);
                    legStatus.push({ touching: true, gap: 0 });
                } else {
                    indicator.material.color.setHex(0xff6464);
                    legStatus.push({ touching: false, gap: gap });
                }
            });

            updateUI(legStatus);
            updateWobbleGraph();
        }

        function calculateWobble(angleDeg) {
            const angle = angleDeg * Math.PI / 180;
            const halfSize = tableSize / 2 - 0.1;
            const localPositions = [
                [-halfSize, -halfSize],
                [halfSize, -halfSize],
                [halfSize, halfSize],
                [-halfSize, halfSize]
            ];

            const heights = localPositions.map(([lx, lz]) => {
                const wx = lx * Math.cos(angle) - lz * Math.sin(angle);
                const wz = lx * Math.sin(angle) + lz * Math.cos(angle);
                return getFloorHeight(wx, wz);
            });

            // Wobble = (diagonal 1 sum) - (diagonal 2 sum)
            const diag1 = heights[0] + heights[2];
            const diag2 = heights[1] + heights[3];
            return diag1 - diag2;
        }

        function findStableAngle() {
            // Binary search for where wobble crosses zero
            let low = 0, high = 90;
            const w0 = calculateWobble(0);
            const w90 = calculateWobble(90);

            if (Math.abs(w0) < 0.01) return 0;
            if (Math.abs(w90) < 0.01) return 90;

            // Check if they have opposite signs
            if (w0 * w90 > 0) {
                // Search for zero crossing more carefully
                for (let a = 0; a <= 90; a += 0.5) {
                    if (Math.abs(calculateWobble(a)) < 0.02) return a;
                }
                return 45; // fallback
            }

            for (let i = 0; i < 50; i++) {
                const mid = (low + high) / 2;
                const wMid = calculateWobble(mid);

                if (Math.abs(wMid) < 0.005) return mid;

                if (w0 * wMid < 0) {
                    high = mid;
                } else {
                    low = mid;
                }
            }

            return (low + high) / 2;
        }

        function updateUI(legStatus) {
            // Update leg status display
            legStatus.forEach((status, i) => {
                const el = document.getElementById(`leg${i + 1}`);
                if (status.touching) {
                    el.className = 'leg touching';
                    el.textContent = `Leg ${i + 1}: Touch`;
                } else {
                    el.className = 'leg floating';
                    el.textContent = `Leg ${i + 1}: +${status.gap.toFixed(2)}`;
                }
            });

            // Update wobble indicator
            const wobble = Math.abs(calculateWobble(currentAngle));
            const indicator = document.getElementById('wobbleIndicator');
            if (wobble < 0.02) {
                indicator.className = 'wobble-indicator stable';
                indicator.innerHTML = '‚úÖ TABLE IS STABLE!';
            } else {
                indicator.className = 'wobble-indicator unstable';
                indicator.innerHTML = `‚ö†Ô∏è Wobble: ${wobble.toFixed(3)}`;
            }
        }

        function updateWobbleGraph() {
            const canvas = document.getElementById('wobbleGraph');
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.clientWidth * 2;
            const height = canvas.height = canvas.clientHeight * 2;
            ctx.scale(2, 2);

            const w = canvas.clientWidth;
            const h = canvas.clientHeight;

            ctx.clearRect(0, 0, w, h);

            // Draw zero line
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, h / 2);
            ctx.lineTo(w, h / 2);
            ctx.stroke();

            // Find max wobble for scaling
            let maxWobble = 0;
            for (let a = 0; a <= 90; a += 1) {
                maxWobble = Math.max(maxWobble, Math.abs(calculateWobble(a)));
            }
            maxWobble = Math.max(maxWobble, 0.1);

            // Draw wobble function
            ctx.beginPath();
            ctx.strokeStyle = '#00d9ff';
            ctx.lineWidth = 2;

            for (let a = 0; a <= 90; a += 1) {
                const x = (a / 90) * w;
                const wobble = calculateWobble(a);
                const y = h / 2 - (wobble / maxWobble) * (h / 2 - 10);

                if (a === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            // Mark current position
            const currentX = (currentAngle / 90) * w;
            const currentWobble = calculateWobble(currentAngle);
            const currentY = h / 2 - (currentWobble / maxWobble) * (h / 2 - 10);

            ctx.beginPath();
            ctx.arc(currentX, currentY, 6, 0, Math.PI * 2);
            ctx.fillStyle = '#00ff88';
            ctx.fill();

            // Mark zero crossings
            ctx.fillStyle = '#ffcc00';
            for (let a = 0; a < 90; a += 0.5) {
                const w1 = calculateWobble(a);
                const w2 = calculateWobble(a + 0.5);
                if (w1 * w2 < 0 || Math.abs(w1) < 0.01) {
                    const zeroX = (a / 90) * w;
                    ctx.beginPath();
                    ctx.arc(zeroX, h / 2, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.fillText('0¬∞', 2, h - 5);
            ctx.fillText('90¬∞', w - 20, h - 5);
            ctx.fillText('w>0', 5, 15);
            ctx.fillText('w<0', 5, h - 15);
        }

        function autoStabilize() {
            stableAngle = findStableAngle();

            // Animate to stable angle
            const startAngle = currentAngle;
            const duration = 1500;
            const startTime = Date.now();

            function animateToStable() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);

                currentAngle = startAngle + (stableAngle - startAngle) * eased;
                document.getElementById('angleSlider').value = currentAngle;
                document.getElementById('angleDisplay').textContent = currentAngle.toFixed(1) + '¬∞';
                updateTable();

                if (progress < 1) {
                    requestAnimationFrame(animateToStable);
                }
            }

            animateToStable();
        }

        function randomizeFloor() {
            scene.remove(floor);
            generateFloorHeightMap();

            const geometry = new THREE.PlaneGeometry(8, 8, 32, 32);
            const positions = geometry.attributes.position.array;

            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                positions[i + 2] = getFloorHeight(x, y);
            }

            geometry.computeVertexNormals();

            const material = new THREE.MeshStandardMaterial({
                color: 0x2a2a4a,
                roughness: 0.8,
                metalness: 0.2,
                side: THREE.DoubleSide
            });

            floor = new THREE.Mesh(geometry, material);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            currentAngle = 0;
            document.getElementById('angleSlider').value = 0;
            document.getElementById('angleDisplay').textContent = '0¬∞';
            updateTable();
        }

        function onWindowResize() {
            const container = document.getElementById('scene-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Event listeners
        document.getElementById('angleSlider').addEventListener('input', function() {
            currentAngle = parseFloat(this.value);
            document.getElementById('angleDisplay').textContent = currentAngle.toFixed(1) + '¬∞';
            updateTable();
        });

        // Initialize
        init();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
