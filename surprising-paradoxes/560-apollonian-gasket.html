<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Apollonian Gasket - Infinite Circles from Descartes' Theorem</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 0;
        }

        h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, #ffd700, #ffaa00, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #888;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            margin-top: 20px;
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 215, 0, 0.2);
        }

        canvas {
            display: block;
            width: 100%;
            background: #050510;
            border-radius: 10px;
        }

        .controls {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 215, 0, 0.2);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: #ffd700;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            background: linear-gradient(90deg, #ffd700, #ff6b6b);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #ffd700;
            border-radius: 50%;
            cursor: pointer;
        }

        .value-display {
            min-width: 40px;
            text-align: right;
            color: #ffd700;
            font-family: monospace;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        button {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .preset-btn {
            background: linear-gradient(135deg, #2a2a4a, #3a3a5a);
            color: #e0e0e0;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .preset-btn:hover {
            background: linear-gradient(135deg, #3a3a5a, #4a4a6a);
            border-color: #ffd700;
        }

        .preset-btn.active {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
        }

        .color-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .color-btn {
            padding: 8px;
            font-size: 0.85rem;
        }

        .stats {
            background: rgba(255, 215, 0, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 215, 0, 0.1);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #ffd700;
            font-family: monospace;
        }

        .theorem-box {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 107, 107, 0.1));
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            border-left: 3px solid #ffd700;
        }

        .theorem-title {
            color: #ffd700;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .formula {
            font-family: 'Times New Roman', serif;
            font-size: 1.1rem;
            color: #fff;
            text-align: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            margin: 10px 0;
        }

        .explanation {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .exp-card {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 215, 0, 0.2);
        }

        .exp-card h3 {
            color: #ffd700;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .exp-card p {
            line-height: 1.7;
            color: #bbb;
        }

        .highlight {
            color: #ffd700;
            font-weight: 500;
        }

        .back-link {
            display: inline-block;
            color: #ffd700;
            text-decoration: none;
            margin-bottom: 20px;
            transition: transform 0.3s;
        }

        .back-link:hover {
            transform: translateX(-5px);
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

        <header>
            <h1>The Apollonian Gasket</h1>
            <p class="subtitle">Infinite circles emerge from Descartes' elegant theorem</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="gasketCanvas" width="800" height="800"></canvas>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Recursion Depth</label>
                    <div class="slider-container">
                        <input type="range" id="depthSlider" min="1" max="8" value="5">
                        <span class="value-display" id="depthValue">5</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Minimum Circle Size (px)</label>
                    <div class="slider-container">
                        <input type="range" id="minSizeSlider" min="1" max="10" value="2">
                        <span class="value-display" id="minSizeValue">2</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Starting Configuration</label>
                    <div class="preset-buttons">
                        <button class="preset-btn active" data-config="symmetric">Symmetric</button>
                        <button class="preset-btn" data-config="asymmetric">Asymmetric</button>
                        <button class="preset-btn" data-config="integral">Integral</button>
                        <button class="preset-btn" data-config="nested">Nested</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Color Scheme</label>
                    <div class="color-buttons">
                        <button class="preset-btn color-btn active" data-color="depth">Depth</button>
                        <button class="preset-btn color-btn" data-color="gold">Gold</button>
                        <button class="preset-btn color-btn" data-color="rainbow">Rainbow</button>
                        <button class="preset-btn color-btn" data-color="fire">Fire</button>
                        <button class="preset-btn color-btn" data-color="cool">Cool</button>
                        <button class="preset-btn color-btn" data-color="neon">Neon</button>
                    </div>
                </div>

                <div class="stats">
                    <div class="stat-row">
                        <span class="stat-label">Circles Drawn</span>
                        <span class="stat-value" id="circleCount">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Max Depth Reached</span>
                        <span class="stat-value" id="maxDepth">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Smallest Radius</span>
                        <span class="stat-value" id="smallestRadius">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Fractal Dimension</span>
                        <span class="stat-value">‚âà 1.3057</span>
                    </div>
                </div>

                <div class="theorem-box">
                    <div class="theorem-title">Descartes' Circle Theorem (1643)</div>
                    <div class="formula">(k‚ÇÅ + k‚ÇÇ + k‚ÇÉ + k‚ÇÑ)¬≤ = 2(k‚ÇÅ¬≤ + k‚ÇÇ¬≤ + k‚ÇÉ¬≤ + k‚ÇÑ¬≤)</div>
                    <p style="font-size: 0.9rem; color: #aaa; margin-top: 10px;">
                        Where k = 1/r is the curvature. The fourth circle's curvature:
                    </p>
                    <div class="formula">k‚ÇÑ = k‚ÇÅ + k‚ÇÇ + k‚ÇÉ ¬± 2‚àö(k‚ÇÅk‚ÇÇ + k‚ÇÅk‚ÇÉ + k‚ÇÇk‚ÇÉ)</div>
                </div>
            </div>
        </div>

        <div class="explanation">
            <div class="exp-card">
                <h3>üîÆ The Surprise</h3>
                <p>
                    Start with just <span class="highlight">three mutually tangent circles</span>.
                    Using only Descartes' quadratic formula from 1643, you can find a fourth circle
                    that kisses all three. Apply this recursively and <span class="highlight">infinite
                    circles</span> emerge, filling every gap with perfect tangencies. From finite
                    ingredients, an infinite fractal structure materializes‚Äîbounded in space yet
                    containing infinitely many circles.
                </p>
            </div>

            <div class="exp-card">
                <h3>üìê The Mathematics</h3>
                <p>
                    The key insight is <span class="highlight">curvature</span> (k = 1/radius).
                    Descartes discovered that for four mutually tangent circles, curvatures satisfy
                    an elegant quadratic relation. Even more remarkable: certain starting configurations
                    produce <span class="highlight">integral gaskets</span> where every single circle
                    (infinitely many!) has integer curvature. Try the "Integral" preset!
                </p>
            </div>

            <div class="exp-card">
                <h3>üåÄ Circle Centers</h3>
                <p>
                    Finding circle radii isn't enough‚Äîwe need positions too. The
                    <span class="highlight">Complex Descartes Theorem</span> extends the formula
                    to complex numbers representing centers: (k‚ÇÅz‚ÇÅ + k‚ÇÇz‚ÇÇ + k‚ÇÉz‚ÇÉ + k‚ÇÑz‚ÇÑ)¬≤ =
                    2(k‚ÇÅ¬≤z‚ÇÅ¬≤ + k‚ÇÇ¬≤z‚ÇÇ¬≤ + k‚ÇÉ¬≤z‚ÇÉ¬≤ + k‚ÇÑ¬≤z‚ÇÑ¬≤). This gives the exact position of each
                    new circle in the complex plane.
                </p>
            </div>

            <div class="exp-card">
                <h3>‚àû Fractal Properties</h3>
                <p>
                    The Apollonian Gasket has Hausdorff dimension <span class="highlight">‚âà 1.3057</span>‚Äî
                    more than a line but less than a plane. The gasket is <span class="highlight">not
                    strictly self-similar</span> (unlike the Sierpi≈Ñski triangle), yet it has
                    well-defined fractal dimension. Related to Kleinian groups, hyperbolic geometry,
                    and number theory‚Äîa crossroads of modern mathematics.
                </p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gasketCanvas');
        const ctx = canvas.getContext('2d');

        // High DPI support
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        const W = rect.width;
        const H = rect.height;

        let currentConfig = 'symmetric';
        let colorScheme = 'depth';
        let maxDepth = 5;
        let minRadius = 2;
        let circleCount = 0;
        let smallestRadius = Infinity;
        let maxDepthReached = 0;

        // Circle class with curvature and center
        class Circle {
            constructor(x, y, k) {
                this.x = x;
                this.y = y;
                this.k = k; // curvature = 1/radius
                this.r = Math.abs(1 / k);
            }
        }

        // Complex number operations
        function complexAdd(a, b) {
            return { re: a.re + b.re, im: a.im + b.im };
        }

        function complexSub(a, b) {
            return { re: a.re - b.re, im: a.im - b.im };
        }

        function complexMul(a, b) {
            return {
                re: a.re * b.re - a.im * b.im,
                im: a.re * b.im + a.im * b.re
            };
        }

        function complexScale(a, s) {
            return { re: a.re * s, im: a.im * s };
        }

        function complexSqrt(a) {
            const r = Math.sqrt(a.re * a.re + a.im * a.im);
            const theta = Math.atan2(a.im, a.re);
            const sqrtR = Math.sqrt(r);
            return {
                re: sqrtR * Math.cos(theta / 2),
                im: sqrtR * Math.sin(theta / 2)
            };
        }

        // Descartes' Circle Theorem: find fourth curvature
        function descartesCurvature(k1, k2, k3) {
            const sum = k1 + k2 + k3;
            const prod = Math.sqrt(k1 * k2 + k1 * k3 + k2 * k3);
            return [sum + 2 * prod, sum - 2 * prod];
        }

        // Complex Descartes' Theorem: find fourth center
        function descartesCenter(c1, c2, c3, k4) {
            const z1 = { re: c1.x, im: c1.y };
            const z2 = { re: c2.x, im: c2.y };
            const z3 = { re: c3.x, im: c3.y };

            // kz products
            const kz1 = complexScale(z1, c1.k);
            const kz2 = complexScale(z2, c2.k);
            const kz3 = complexScale(z3, c3.k);

            // Sum
            const sumKZ = complexAdd(complexAdd(kz1, kz2), kz3);

            // Product terms for sqrt
            const kz1_kz2 = complexMul(kz1, kz2);
            const kz1_kz3 = complexMul(kz1, kz3);
            const kz2_kz3 = complexMul(kz2, kz3);
            const sumProd = complexAdd(complexAdd(kz1_kz2, kz1_kz3), kz2_kz3);

            const sqrtTerm = complexSqrt(sumProd);

            // Two possible centers
            const center1 = complexScale(complexAdd(sumKZ, complexScale(sqrtTerm, 2)), 1 / k4);
            const center2 = complexScale(complexSub(sumKZ, complexScale(sqrtTerm, 2)), 1 / k4);

            return [center1, center2];
        }

        // Get starting circles based on configuration
        function getStartingCircles() {
            const cx = W / 2;
            const cy = H / 2;
            const R = Math.min(W, H) * 0.45;

            switch (currentConfig) {
                case 'symmetric': {
                    // Three equal circles inside an outer circle
                    const r = R / (1 + 2 / Math.sqrt(3));
                    const d = R - r;
                    const circles = [
                        new Circle(cx, cy, -1 / R) // Outer circle (negative curvature)
                    ];
                    for (let i = 0; i < 3; i++) {
                        const angle = (i * 2 * Math.PI / 3) - Math.PI / 2;
                        circles.push(new Circle(
                            cx + d * Math.cos(angle),
                            cy + d * Math.sin(angle),
                            1 / r
                        ));
                    }
                    return circles;
                }
                case 'asymmetric': {
                    // Different sized starting circles
                    const r1 = R * 0.5;
                    const r2 = R * 0.35;
                    const r3 = R * 0.25;

                    const c1 = new Circle(cx - R + r1, cy, 1 / r1);
                    const c2 = new Circle(cx - R + 2 * r1 + r2, cy, 1 / r2);

                    // Find position for c3 tangent to both
                    const d13 = r1 + r3;
                    const d23 = r2 + r3;
                    const d12 = r1 + r2;

                    // Use circle-circle intersection
                    const a = (d13 * d13 - d23 * d23 + d12 * d12) / (2 * d12);
                    const h = Math.sqrt(d13 * d13 - a * a);

                    const x3 = c1.x + a * (c2.x - c1.x) / d12 + h * (c2.y - c1.y) / d12;
                    const y3 = c1.y + a * (c2.y - c1.y) / d12 - h * (c2.x - c1.x) / d12;

                    const c3 = new Circle(x3, y3, 1 / r3);

                    // Outer circle containing all three
                    const [k4] = descartesCurvature(c1.k, c2.k, c3.k);
                    const r0 = Math.abs(1 / k4);
                    const c0 = new Circle(cx, cy, -1 / (R * 0.95));

                    return [c0, c1, c2, c3];
                }
                case 'integral': {
                    // Classic integral Apollonian gasket (-1, 2, 2, 3)
                    // Properly computed tangent positions
                    const scale = R;
                    // Outer circle: k=-1 (encompasses others)
                    const c0 = new Circle(cx, cy, -1 / scale);
                    // Two circles k=2, r=scale/2, tangent to each other and outer
                    const c1 = new Circle(cx, cy - scale / 2, 2 / scale);
                    const c2 = new Circle(cx, cy + scale / 2, 2 / scale);
                    // Third circle k=3, r=scale/3, tangent to both and outer
                    // At distance 2*scale/3 from center, touching both others
                    const c3 = new Circle(cx + scale * 2 / 3, cy, 3 / scale);
                    return [c0, c1, c2, c3];
                }
                case 'nested': {
                    // Deeply nested starting point
                    const r0 = R;
                    const r1 = R * 0.6;
                    const c0 = new Circle(cx, cy, -1 / r0);
                    const c1 = new Circle(cx, cy - (r0 - r1), 1 / r1);

                    // Two smaller circles tangent to both
                    const r2 = (r0 - r1) / 2;
                    const c2 = new Circle(cx - r2, cy + r2, 1 / r2);
                    const c3 = new Circle(cx + r2, cy + r2, 1 / r2);
                    return [c0, c1, c2, c3];
                }
            }
        }

        // Color functions
        function getColor(depth, maxD) {
            const t = depth / maxD;

            switch (colorScheme) {
                case 'depth':
                    const h = 45 + depth * 30;
                    const s = 80 - depth * 5;
                    const l = 60 - depth * 5;
                    return `hsl(${h}, ${s}%, ${l}%)`;
                case 'gold':
                    const brightness = 100 - depth * 10;
                    return `hsl(45, 90%, ${Math.max(30, brightness)}%)`;
                case 'rainbow':
                    return `hsl(${(depth * 47) % 360}, 70%, 55%)`;
                case 'fire':
                    const hFire = 60 - depth * 10;
                    return `hsl(${Math.max(0, hFire)}, 100%, ${60 - depth * 5}%)`;
                case 'cool':
                    return `hsl(${200 + depth * 20}, 70%, ${60 - depth * 3}%)`;
                case 'neon':
                    const colors = ['#ff00ff', '#00ffff', '#ff0066', '#66ff00', '#ffff00', '#ff6600'];
                    return colors[depth % colors.length];
            }
        }

        function drawCircle(circle, depth) {
            if (circle.r < minRadius) return;
            if (circle.k > 0) {
                circleCount++;
                smallestRadius = Math.min(smallestRadius, circle.r);
                maxDepthReached = Math.max(maxDepthReached, depth);
            }

            ctx.beginPath();
            ctx.arc(circle.x, circle.y, circle.r, 0, Math.PI * 2);
            ctx.strokeStyle = getColor(depth, maxDepth);
            ctx.lineWidth = Math.max(0.5, 2 - depth * 0.2);
            ctx.stroke();
        }

        // Check if circle is valid (not overlapping improperly)
        function isValidCircle(newCircle, c1, c2, c3) {
            if (!isFinite(newCircle.x) || !isFinite(newCircle.y) || !isFinite(newCircle.r)) {
                return false;
            }
            if (newCircle.r < 0.1 || newCircle.r > W) return false;

            // Check it's actually tangent
            const circles = [c1, c2, c3];
            for (const c of circles) {
                const dist = Math.sqrt((newCircle.x - c.x) ** 2 + (newCircle.y - c.y) ** 2);
                const expectedDist = (newCircle.k > 0 && c.k > 0) ?
                    newCircle.r + c.r : Math.abs(newCircle.r - c.r);
                const tolerance = Math.max(1, expectedDist * 0.1);
                if (Math.abs(dist - expectedDist) > tolerance) {
                    return false;
                }
            }
            return true;
        }

        // Recursive gasket generation
        function generateGasket(c1, c2, c3, c4, depth) {
            if (depth >= maxDepth) return;

            // For each triplet, find the fourth circle
            const triplets = [
                [c1, c2, c3, c4],
                [c1, c2, c4, c3],
                [c1, c3, c4, c2],
                [c2, c3, c4, c1]
            ];

            for (const [a, b, c, old] of triplets) {
                const [k4_plus, k4_minus] = descartesCurvature(a.k, b.k, c.k);

                // Use the curvature that's different from the old circle
                let k4 = Math.abs(k4_plus - old.k) > 0.001 ? k4_plus : k4_minus;

                if (Math.abs(1 / k4) < minRadius) continue;

                const centers = descartesCenter(a, b, c, k4);

                for (const center of centers) {
                    const newCircle = new Circle(center.re, center.im, k4);

                    // Check if this is actually a new valid circle
                    if (newCircle.r >= minRadius && isValidCircle(newCircle, a, b, c)) {
                        const distToOld = Math.sqrt((newCircle.x - old.x) ** 2 + (newCircle.y - old.y) ** 2);

                        // Make sure it's not the old circle
                        if (distToOld > 1) {
                            drawCircle(newCircle, depth + 1);
                            generateGasket(a, b, c, newCircle, depth + 1);
                        }
                    }
                }
            }
        }

        function render() {
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, W, H);

            circleCount = 0;
            smallestRadius = Infinity;
            maxDepthReached = 0;

            const startCircles = getStartingCircles();

            // Draw starting circles
            startCircles.forEach((c, i) => drawCircle(c, 0));

            // Generate gasket recursively
            if (startCircles.length === 4) {
                generateGasket(startCircles[0], startCircles[1], startCircles[2], startCircles[3], 0);
            }

            // Update stats
            document.getElementById('circleCount').textContent = circleCount.toLocaleString();
            document.getElementById('maxDepth').textContent = maxDepthReached;
            document.getElementById('smallestRadius').textContent =
                smallestRadius === Infinity ? '-' : smallestRadius.toFixed(2) + ' px';
        }

        // Event listeners
        document.getElementById('depthSlider').addEventListener('input', (e) => {
            maxDepth = parseInt(e.target.value);
            document.getElementById('depthValue').textContent = maxDepth;
            render();
        });

        document.getElementById('minSizeSlider').addEventListener('input', (e) => {
            minRadius = parseInt(e.target.value);
            document.getElementById('minSizeValue').textContent = minRadius;
            render();
        });

        document.querySelectorAll('.preset-btn:not(.color-btn)').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.preset-btn:not(.color-btn)').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentConfig = btn.dataset.config;
                render();
            });
        });

        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                colorScheme = btn.dataset.color;
                render();
            });
        });

        // Initial render
        render();
    </script>
</body>
</html>
