<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gabriel's Horn - Infinite Surface, Finite Volume</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --gold: #f1c40f;
            --brass: #d4a574;
            --heaven-blue: #3498db;
            --infinity-purple: #9b59b6;
            --cream: #FEFAE0;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 50%, #0f0f2d 100%);
            min-height: 100vh;
            color: #ecf0f1;
            overflow-x: hidden;
        }

        /* Celestial background */
        .celestial-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 20% 20%, rgba(241, 196, 15, 0.1) 0%, transparent 30%),
                radial-gradient(circle at 80% 80%, rgba(155, 89, 182, 0.1) 0%, transparent 30%);
            z-index: 0;
        }

        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
            animation: twinkle 2s ease-in-out infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 18px;
            background: rgba(241, 196, 15, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(241, 196, 15, 0.3);
            border-radius: 30px;
            color: var(--gold);
            text-decoration: none;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .organic-back-link:hover {
            background: rgba(241, 196, 15, 0.4);
            transform: translateX(-3px);
        }

        .container {
            position: relative;
            z-index: 10;
            max-width: 1100px;
            margin: 0 auto;
            padding: 80px 20px 40px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-family: 'Lora', serif;
            font-size: 2.8rem;
            background: linear-gradient(135deg, var(--gold), var(--brass));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .header .subtitle {
            font-size: 1.2rem;
            color: #bdc3c7;
        }

        .paradox-banner {
            background: linear-gradient(135deg, rgba(241, 196, 15, 0.2), rgba(155, 89, 182, 0.2));
            border: 2px solid var(--gold);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 30px;
            text-align: center;
        }

        .paradox-banner h2 {
            font-family: 'Lora', serif;
            color: var(--gold);
            font-size: 1.5rem;
            margin-bottom: 15px;
        }

        .paradox-stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            flex-wrap: wrap;
        }

        .paradox-stat {
            text-align: center;
        }

        .paradox-stat .value {
            font-size: 2.5rem;
            font-weight: bold;
        }

        .paradox-stat .value.finite { color: var(--heaven-blue); }
        .paradox-stat .value.infinite { color: var(--infinity-purple); }

        .paradox-stat .label {
            font-size: 0.9rem;
            color: #bdc3c7;
        }

        .vs {
            font-size: 1.5rem;
            color: var(--gold);
            display: flex;
            align-items: center;
        }

        .main-panel {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 25px;
            margin-bottom: 30px;
        }

        @media (max-width: 900px) {
            .main-panel {
                grid-template-columns: 1fr;
            }
        }

        .viz-panel {
            background: rgba(26, 26, 62, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(241, 196, 15, 0.3);
            border-radius: 20px;
            padding: 20px;
        }

        .viz-panel h2 {
            font-family: 'Lora', serif;
            color: var(--gold);
            margin-bottom: 15px;
            text-align: center;
        }

        .canvas-container {
            position: relative;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            overflow: hidden;
            height: 400px;
        }

        #hornCanvas {
            width: 100%;
            height: 100%;
        }

        .controls-panel {
            background: rgba(26, 26, 62, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(241, 196, 15, 0.3);
            border-radius: 20px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .controls-panel h2 {
            font-family: 'Lora', serif;
            color: var(--gold);
            text-align: center;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 15px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            color: #bdc3c7;
            font-size: 0.9rem;
        }

        .control-value {
            color: var(--gold);
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--gold);
            cursor: pointer;
        }

        .stat-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }

        .stat-display .big-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--gold);
        }

        .stat-display .stat-label {
            font-size: 0.8rem;
            color: #bdc3c7;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--gold), #d4a00d);
            color: #1a1a1a;
        }

        .btn-primary:hover {
            transform: scale(1.02);
            box-shadow: 0 5px 20px rgba(241, 196, 15, 0.4);
        }

        .btn-secondary {
            background: rgba(241, 196, 15, 0.2);
            color: var(--gold);
            border: 1px solid var(--gold);
        }

        .explanation {
            background: rgba(26, 26, 62, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(241, 196, 15, 0.3);
            border-radius: 20px;
            padding: 30px;
            margin-top: 30px;
        }

        .explanation h2 {
            font-family: 'Lora', serif;
            color: var(--gold);
            margin-bottom: 20px;
        }

        .explanation p {
            line-height: 1.8;
            margin-bottom: 15px;
            color: #bdc3c7;
        }

        .highlight {
            color: var(--gold);
            font-weight: 600;
        }

        .paradox-box {
            background: linear-gradient(135deg, rgba(155, 89, 182, 0.2), rgba(241, 196, 15, 0.2));
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            border-left: 4px solid var(--infinity-purple);
        }

        .paradox-box h3 {
            color: var(--infinity-purple);
            margin-bottom: 10px;
        }

        .math-box {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
        }

        .math-section {
            margin: 15px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .math-title {
            color: var(--gold);
            font-weight: bold;
            margin-bottom: 10px;
        }

        .math-formula {
            color: #ecf0f1;
            font-size: 1.1rem;
            text-align: center;
            margin: 10px 0;
        }

        .math-result {
            text-align: center;
            font-size: 1.3rem;
            font-weight: bold;
            margin-top: 10px;
        }

        .math-result.finite { color: var(--heaven-blue); }
        .math-result.infinite { color: var(--infinity-purple); }

        .painter-paradox {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.2), rgba(241, 196, 15, 0.2));
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            border-left: 4px solid var(--heaven-blue);
        }

        .painter-paradox h3 {
            color: var(--heaven-blue);
            margin-bottom: 10px;
        }

        .resolution-box {
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.2), rgba(241, 196, 15, 0.2));
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            border-left: 4px solid #2ecc71;
        }

        .resolution-box h3 {
            color: #2ecc71;
            margin-bottom: 10px;
        }

        .history-box {
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            margin: 20px 0;
        }

        .history-icon {
            font-size: 3rem;
        }

        .history-text h4 {
            color: var(--gold);
            margin-bottom: 5px;
        }

        .history-text p {
            font-size: 0.9rem;
            color: #bdc3c7;
        }

        .fill-animation {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to top, rgba(52, 152, 219, 0.6), transparent);
            transition: height 2s ease-out;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="celestial-bg"></div>
    <div class="stars" id="stars"></div>

    <a href="index.html" class="organic-back-link">
        <span class="back-arrow">‚Üê</span>
        <span class="back-text">Gallery</span>
    </a>

    <div class="container">
        <header class="header">
            <h1>Gabriel's Horn</h1>
            <p class="subtitle">Torricelli's Trumpet (1641)</p>
        </header>

        <div class="paradox-banner">
            <h2>üé∫ The Painter's Paradox</h2>
            <div class="paradox-stats">
                <div class="paradox-stat">
                    <div class="value finite">œÄ</div>
                    <div class="label">Volume (finite)</div>
                </div>
                <div class="vs">vs</div>
                <div class="paradox-stat">
                    <div class="value infinite">‚àû</div>
                    <div class="label">Surface Area (infinite)</div>
                </div>
            </div>
            <p style="margin-top: 15px; color: #bdc3c7;">
                You can FILL it with paint... but you can NEVER paint its surface!
            </p>
        </div>

        <div class="main-panel">
            <div class="viz-panel">
                <h2>3D Visualization</h2>
                <div class="canvas-container">
                    <canvas id="hornCanvas"></canvas>
                    <div class="fill-animation" id="fillAnimation" style="height: 0%;"></div>
                </div>
                <p style="text-align: center; color: #bdc3c7; margin-top: 10px; font-size: 0.9rem;">
                    Drag to rotate ‚Ä¢ Scroll to zoom
                </p>
            </div>

            <div class="controls-panel">
                <h2>Controls</h2>

                <div class="control-group">
                    <div class="control-label">
                        <span>Horn Length (x max)</span>
                        <span class="control-value" id="lengthValue">10</span>
                    </div>
                    <input type="range" id="lengthSlider" min="2" max="50" step="1" value="10">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Rotation Speed</span>
                        <span class="control-value" id="speedValue">1x</span>
                    </div>
                    <input type="range" id="speedSlider" min="0" max="3" step="0.5" value="1">
                </div>

                <div class="stat-display">
                    <div class="big-value" id="volumeDisplay">œÄ ‚âà 3.14</div>
                    <div class="stat-label">Volume (approaches œÄ)</div>
                </div>

                <div class="stat-display">
                    <div class="big-value" id="surfaceDisplay">‚àû</div>
                    <div class="stat-label">Surface Area (infinite)</div>
                </div>

                <button class="btn btn-primary" onclick="fillWithPaint()">Fill with Paint</button>
                <button class="btn btn-secondary" onclick="resetView()">Reset View</button>
            </div>
        </div>

        <div class="explanation">
            <h2>The Mathematics</h2>

            <p>
                Gabriel's Horn is created by rotating the curve <span class="highlight">y = 1/x</span>
                around the x-axis, for x ‚â• 1, extending infinitely to the right.
            </p>

            <div class="math-box">
                <div class="math-section">
                    <div class="math-title">Volume (Disk Method)</div>
                    <div class="math-formula">V = œÄ ‚à´‚ÇÅ^‚àû (1/x)¬≤ dx = œÄ ‚à´‚ÇÅ^‚àû x‚Åª¬≤ dx</div>
                    <div class="math-formula">= œÄ [-x‚Åª¬π]‚ÇÅ^‚àû = œÄ [0 - (-1)]</div>
                    <div class="math-result finite">V = œÄ ‚âà 3.14159...</div>
                </div>

                <div class="math-section">
                    <div class="math-title">Surface Area (Surface of Revolution)</div>
                    <div class="math-formula">S = 2œÄ ‚à´‚ÇÅ^‚àû (1/x)‚àö(1 + 1/x‚Å¥) dx</div>
                    <div class="math-formula">> 2œÄ ‚à´‚ÇÅ^‚àû (1/x) dx = 2œÄ [ln(x)]‚ÇÅ^‚àû</div>
                    <div class="math-result infinite">S = ‚àû (diverges!)</div>
                </div>
            </div>

            <div class="paradox-box">
                <h3>The Paradox</h3>
                <p>
                    How can a shape hold a finite amount of paint (exactly œÄ cubic units) yet have an
                    infinite surface that could never be fully painted? If you pour paint into the horn
                    until it's full, haven't you effectively "painted" the inside surface?
                </p>
            </div>

            <div class="painter-paradox">
                <h3>üé® The Painter's Version</h3>
                <p>
                    Imagine you're a painter. You buy œÄ cubic units of paint‚Äîenough to completely fill
                    Gabriel's Horn. You pour it in, and the horn is full. The inside surface is now covered!
                    <br><br>
                    But wait‚Äîif the inside surface is infinite, how did finite paint cover it?
                    And why can't you take that same paint and coat the <em>outside</em> of the horn?
                </p>
            </div>

            <div class="resolution-box">
                <h3>The Resolution</h3>
                <p>
                    The paradox dissolves when we consider <span class="highlight">thickness</span>:
                </p>
                <ul style="margin-left: 20px; color: #bdc3c7; line-height: 2;">
                    <li><strong>Mathematical paint</strong> has zero thickness‚Äîit's purely 2D.</li>
                    <li><strong>Real paint</strong> has thickness, fundamentally changing the problem.</li>
                    <li>As the horn narrows, it becomes <em>thinner than any paint layer could be</em>.</li>
                    <li>A finite volume of infinitely thin paint CAN cover infinite area!</li>
                </ul>
                <p style="margin-top: 15px;">
                    The "inside" IS coated‚Äîbut by paint that gets infinitely thin as it goes deeper.
                    This is mathematically valid but physically impossible.
                </p>
            </div>

            <div class="history-box">
                <div class="history-icon">üî≠</div>
                <div class="history-text">
                    <h4>Evangelista Torricelli (1641)</h4>
                    <p>
                        Italian physicist and mathematician Torricelli discovered this paradox before
                        calculus was formally developed! He called it an "acute hyperbolic solid" and
                        proved its finite volume using Cavalieri's principle. The name "Gabriel's Horn"
                        comes from the Archangel Gabriel, whose trumpet announces Judgment Day.
                    </p>
                </div>
            </div>

            <div class="paradox-box" style="border-left-color: var(--gold);">
                <h3 style="color: var(--gold);">Why It Matters</h3>
                <p>
                    Gabriel's Horn demonstrates that our geometric intuitions can fail spectacularly
                    with infinite objects. It challenged mathematicians to rigorously define concepts
                    like "area" and "volume" for infinite shapes, contributing to the development
                    of modern analysis and measure theory.
                </p>
            </div>
        </div>
    </div>

    <script>
        // Create stars
        const starsContainer = document.getElementById('stars');
        for (let i = 0; i < 100; i++) {
            const star = document.createElement('div');
            star.className = 'star';
            star.style.left = Math.random() * 100 + '%';
            star.style.top = Math.random() * 100 + '%';
            star.style.animationDelay = Math.random() * 2 + 's';
            starsContainer.appendChild(star);
        }

        // Canvas setup
        const canvas = document.getElementById('hornCanvas');
        const ctx = canvas.getContext('2d');

        let hornLength = 10;
        let rotationSpeed = 1;
        let rotation = 0;
        let isDragging = false;
        let lastX = 0;
        let manualRotation = 0;
        let zoom = 1;

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = 400 * dpr;
            ctx.scale(dpr, dpr);
        }

        function drawHorn() {
            const width = canvas.width / (window.devicePixelRatio || 1);
            const height = 400;

            ctx.clearRect(0, 0, width, height);

            const centerX = width * 0.3;
            const centerY = height / 2;
            const scale = 30 * zoom;

            // Draw 3D horn using lines
            const segments = 100;
            const rings = 20;

            // Calculate current rotation
            const angle = rotation + manualRotation;

            // Draw the horn surface
            for (let i = 0; i < segments; i++) {
                const x1 = 1 + (i / segments) * (hornLength - 1);
                const x2 = 1 + ((i + 1) / segments) * (hornLength - 1);
                const r1 = 1 / x1;
                const r2 = 1 / x2;

                // Draw rings at each x position
                for (let j = 0; j < rings; j++) {
                    const theta1 = (j / rings) * Math.PI * 2 + angle;
                    const theta2 = ((j + 1) / rings) * Math.PI * 2 + angle;

                    // 3D to 2D projection (simple perspective)
                    const perspective = 1 + x1 * 0.05;

                    const y1a = r1 * Math.cos(theta1) * scale / perspective;
                    const z1a = r1 * Math.sin(theta1);
                    const y1b = r1 * Math.cos(theta2) * scale / perspective;
                    const z1b = r1 * Math.sin(theta2);

                    const y2a = r2 * Math.cos(theta1) * scale / perspective;
                    const y2b = r2 * Math.cos(theta2) * scale / perspective;

                    // Only draw front-facing segments
                    if (z1a > -0.5 || z1b > -0.5) {
                        // Color based on depth
                        const brightness = 0.3 + 0.7 * ((z1a + 1) / 2);
                        const hue = 40 + x1 * 2; // Gold to orange gradient
                        ctx.strokeStyle = `hsla(${hue}, 80%, ${50 * brightness}%, 0.8)`;
                        ctx.lineWidth = 1;

                        // Draw ring segment
                        ctx.beginPath();
                        ctx.moveTo(centerX + x1 * scale, centerY + y1a);
                        ctx.lineTo(centerX + x1 * scale, centerY + y1b);
                        ctx.stroke();

                        // Draw along horn
                        if (i < segments - 1) {
                            ctx.beginPath();
                            ctx.moveTo(centerX + x1 * scale, centerY + y1a);
                            ctx.lineTo(centerX + x2 * scale, centerY + y2a);
                            ctx.stroke();
                        }
                    }
                }
            }

            // Draw the opening (x = 1)
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(241, 196, 15, 0.8)';
            ctx.lineWidth = 2;
            ctx.ellipse(centerX + scale, centerY, 5 * zoom, scale * zoom, 0, 0, Math.PI * 2);
            ctx.stroke();

            // Draw the curve y = 1/x (silhouette)
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(241, 196, 15, 0.5)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            for (let i = 0; i <= segments; i++) {
                const x = 1 + (i / segments) * (hornLength - 1);
                const y = 1 / x;
                const px = centerX + x * scale;
                const py = centerY - y * scale;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Draw bottom curve
            ctx.beginPath();
            for (let i = 0; i <= segments; i++) {
                const x = 1 + (i / segments) * (hornLength - 1);
                const y = 1 / x;
                const px = centerX + x * scale;
                const py = centerY + y * scale;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Labels
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '14px Nunito';
            ctx.textAlign = 'center';
            ctx.fillText('y = 1/x', centerX + scale * 2, centerY - scale - 10);
            ctx.fillText('x = 1', centerX + scale, height - 20);
            ctx.fillText('x ‚Üí ‚àû', width - 50, centerY);

            // Update stats
            updateStats();
        }

        function updateStats() {
            // Volume approaches œÄ as length ‚Üí ‚àû
            // V = œÄ(1 - 1/length)
            const volume = Math.PI * (1 - 1 / hornLength);
            document.getElementById('volumeDisplay').textContent =
                `œÄ √ó ${(1 - 1/hornLength).toFixed(3)} ‚âà ${volume.toFixed(4)}`;

            // Surface area (approximation showing growth)
            const surfaceApprox = 2 * Math.PI * Math.log(hornLength);
            document.getElementById('surfaceDisplay').textContent =
                `‚âà 2œÄ¬∑ln(${hornLength}) = ${surfaceApprox.toFixed(1)}...`;
        }

        function fillWithPaint() {
            const fill = document.getElementById('fillAnimation');
            fill.style.height = '80%';
            setTimeout(() => {
                fill.style.height = '0%';
            }, 3000);
        }

        function resetView() {
            manualRotation = 0;
            zoom = 1;
            hornLength = 10;
            document.getElementById('lengthSlider').value = 10;
            document.getElementById('lengthValue').textContent = 10;
            drawHorn();
        }

        // Event listeners
        document.getElementById('lengthSlider').addEventListener('input', (e) => {
            hornLength = parseInt(e.target.value);
            document.getElementById('lengthValue').textContent = hornLength;
            drawHorn();
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            rotationSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = rotationSpeed + 'x';
        });

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastX;
                manualRotation += dx * 0.01;
                lastX = e.clientX;
                drawHorn();
            }
        });

        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => isDragging = false);

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            zoom *= e.deltaY > 0 ? 0.95 : 1.05;
            zoom = Math.max(0.5, Math.min(2, zoom));
            drawHorn();
        });

        window.addEventListener('resize', () => {
            resizeCanvas();
            drawHorn();
        });

        // Animation loop
        function animate() {
            rotation += 0.01 * rotationSpeed;
            drawHorn();
            requestAnimationFrame(animate);
        }

        // Initialize
        resizeCanvas();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
