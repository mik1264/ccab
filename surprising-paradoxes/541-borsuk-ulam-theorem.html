<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Borsuk-Ulam Theorem - Surprising Paradoxes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a1628 0%, #1a2a4a 50%, #0d1f3c 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #4fc3f7;
            text-decoration: none;
            font-size: 14px;
            z-index: 100;
            padding: 8px 16px;
            background: rgba(79, 195, 247, 0.1);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }

        .back-link:hover {
            background: rgba(79, 195, 247, 0.2);
        }

        header {
            text-align: center;
            padding: 60px 20px 20px;
        }

        h1 {
            font-size: clamp(1.6rem, 4vw, 2.5rem);
            background: linear-gradient(135deg, #4fc3f7, #81c784, #fff176);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
        }

        .theorem-statement {
            font-size: 1.2rem;
            color: #fff176;
            max-width: 800px;
            margin: 0 auto 10px;
            font-style: italic;
        }

        .subtitle {
            font-size: 1rem;
            color: #9e9e9e;
            max-width: 700px;
            margin: 0 auto;
        }

        .main-container {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 20px;
            max-width: 1400px;
            margin: 20px auto;
            padding: 0 20px;
        }

        @media (max-width: 1000px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }

        .globe-panel {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
        }

        #globe-container {
            width: 100%;
            height: 500px;
            border-radius: 12px;
            overflow: hidden;
            background: radial-gradient(circle at center, #0a1628 0%, #000 100%);
            cursor: grab;
        }

        .controls-panel {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 25px;
        }

        .control-section {
            margin-bottom: 25px;
        }

        .control-section h3 {
            color: #4fc3f7;
            font-size: 0.95rem;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .point-display {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .point-display h4 {
            font-size: 0.85rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .point-marker {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }

        .point-a .point-marker { background: #ff7043; }
        .point-b .point-marker { background: #42a5f5; }

        .coords {
            font-family: monospace;
            font-size: 0.9rem;
            color: #bbb;
            margin-bottom: 8px;
        }

        .measurements {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .measurement {
            background: rgba(255,255,255,0.05);
            padding: 8px;
            border-radius: 8px;
            text-align: center;
        }

        .measurement-label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
        }

        .measurement-value {
            font-size: 1.1rem;
            font-weight: bold;
        }

        .temp-value { color: #ff7043; }
        .pressure-value { color: #42a5f5; }

        .difference-box {
            background: linear-gradient(135deg, rgba(255, 112, 67, 0.2), rgba(66, 165, 245, 0.2));
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            margin: 15px 0;
        }

        .difference-box h4 {
            color: #fff176;
            margin-bottom: 10px;
        }

        .diff-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .diff-item {
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .diff-label {
            font-size: 0.75rem;
            color: #888;
        }

        .diff-value {
            font-size: 1.3rem;
            font-weight: bold;
        }

        .match-indicator {
            padding: 12px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            margin: 10px 0;
        }

        .match-indicator.matching {
            background: rgba(129, 199, 132, 0.3);
            border: 2px solid #81c784;
            color: #81c784;
        }

        .match-indicator.not-matching {
            background: rgba(255, 183, 77, 0.2);
            border: 2px solid #ffb74d;
            color: #ffb74d;
        }

        button {
            width: 100%;
            padding: 14px;
            font-size: 1rem;
            background: linear-gradient(135deg, #4fc3f7, #81c784);
            border: none;
            border-radius: 12px;
            color: #0a1628;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 5px 0;
        }

        button:hover {
            transform: scale(1.02);
            box-shadow: 0 5px 25px rgba(79, 195, 247, 0.3);
        }

        button.secondary {
            background: linear-gradient(135deg, #7e57c2, #ec407a);
        }

        .legend {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8rem;
        }

        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 3px;
        }

        .explanation {
            background: linear-gradient(135deg, rgba(79, 195, 247, 0.1), rgba(129, 199, 132, 0.1));
            border-radius: 20px;
            padding: 30px;
            margin: 30px auto;
            max-width: 1360px;
        }

        .explanation h2 {
            color: #81c784;
            margin-bottom: 20px;
        }

        .proof-steps {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .proof-step {
            background: rgba(0,0,0,0.2);
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #4fc3f7;
        }

        .proof-step h3 {
            color: #4fc3f7;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .proof-step p {
            color: #bdbdbd;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .math-box {
            background: rgba(255, 241, 118, 0.1);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            margin: 20px 0;
            font-family: 'Times New Roman', serif;
            font-size: 1.2rem;
            border: 1px solid rgba(255, 241, 118, 0.3);
        }

        footer {
            text-align: center;
            padding: 40px 20px;
            color: #616161;
            font-size: 0.85rem;
        }

        footer a {
            color: #4fc3f7;
            text-decoration: none;
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <header>
        <h1>The Borsuk-Ulam Theorem</h1>
        <p class="theorem-statement">
            "At any moment, there exist two antipodal points on Earth with
            exactly the same temperature AND pressure."
        </p>
        <p class="subtitle">
            A stunning result from topology: no matter how weather varies across the globe,
            two opposite points are mathematically guaranteed to have identical conditions!
        </p>
    </header>

    <div class="main-container">
        <div class="globe-panel">
            <div id="globe-container"></div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(90deg, #1565c0, #4fc3f7, #81c784, #fff176, #ff7043);"></div>
                    <span>Temperature (Cold ‚Üí Hot)</span>
                </div>
            </div>
        </div>

        <div class="controls-panel">
            <div class="control-section">
                <h3>Selected Points</h3>

                <div class="point-display point-a">
                    <h4><span class="point-marker"></span> Point A</h4>
                    <div class="coords" id="coordsA">Click globe to select</div>
                    <div class="measurements">
                        <div class="measurement">
                            <div class="measurement-label">Temperature</div>
                            <div class="measurement-value temp-value" id="tempA">--</div>
                        </div>
                        <div class="measurement">
                            <div class="measurement-label">Pressure</div>
                            <div class="measurement-value pressure-value" id="pressureA">--</div>
                        </div>
                    </div>
                </div>

                <div class="point-display point-b">
                    <h4><span class="point-marker"></span> Point B (Antipodal)</h4>
                    <div class="coords" id="coordsB">Opposite side of Earth</div>
                    <div class="measurements">
                        <div class="measurement">
                            <div class="measurement-label">Temperature</div>
                            <div class="measurement-value temp-value" id="tempB">--</div>
                        </div>
                        <div class="measurement">
                            <div class="measurement-label">Pressure</div>
                            <div class="measurement-value pressure-value" id="pressureB">--</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="difference-box">
                <h4>Difference Between Points</h4>
                <div class="diff-grid">
                    <div class="diff-item">
                        <div class="diff-label">ŒîTemperature</div>
                        <div class="diff-value temp-value" id="diffTemp">--</div>
                    </div>
                    <div class="diff-item">
                        <div class="diff-label">ŒîPressure</div>
                        <div class="diff-value pressure-value" id="diffPressure">--</div>
                    </div>
                </div>
            </div>

            <div class="match-indicator not-matching" id="matchIndicator">
                Click globe or search for matching pair
            </div>

            <button onclick="findMatchingPair()" class="pulse">
                ‚ú® Find Matching Antipodal Pair!
            </button>
            <button onclick="randomizeWeather()" class="secondary">
                üåç New Weather Pattern
            </button>
        </div>
    </div>

    <div class="explanation">
        <h2>Why Must This Be True?</h2>
        <div class="proof-steps">
            <div class="proof-step">
                <h3>Step 1: The Setup</h3>
                <p>Consider temperature T(x) and pressure P(x) as continuous functions
                   on the sphere (Earth's surface). Define a new function:
                   <strong>f(x) = (T(x) - T(-x), P(x) - P(-x))</strong>
                   where -x is the antipodal point.</p>
            </div>
            <div class="proof-step">
                <h3>Step 2: The 1D Case</h3>
                <p>First consider just temperature along the equator. If point A is warmer
                   than antipodal B, then after rotating 180¬∞, A becomes cooler than B.
                   By the <strong>Intermediate Value Theorem</strong>, somewhere they're equal!</p>
            </div>
            <div class="proof-step">
                <h3>Step 3: The 2D Case</h3>
                <p>There's a whole curve of points with equal temperature to their antipodes.
                   Along this curve, apply the same argument to pressure. Somewhere on that
                   curve, pressure must also match!</p>
            </div>
            <div class="proof-step">
                <h3>Step 4: The Theorem</h3>
                <p>The Borsuk-Ulam theorem generalizes: any continuous map from S‚Åø to R‚Åø
                   must send some pair of antipodal points to the same value.
                   For Earth (S¬≤) with 2 measurements, matching points are guaranteed!</p>
            </div>
        </div>

        <div class="math-box">
            <strong>Borsuk-Ulam Theorem:</strong> For any continuous f: S‚Åø ‚Üí R‚Åø,
            ‚àÉx such that f(x) = f(‚àíx)
        </div>
    </div>

    <footer>
        <p>Part of <a href="index.html">Surprising Paradoxes</a> |
           Proved by Karol Borsuk in 1933, problem posed by Stanis≈Çaw Ulam</p>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, globe, markerA, markerB;
        let weatherData = { temp: [], pressure: [] };
        let selectedLat = null, selectedLon = null;
        let isSearching = false;

        function init() {
            const container = document.getElementById('globe-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.z = 3;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            // Ambient light
            const ambient = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambient);

            // Directional light (sun)
            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(5, 3, 5);
            scene.add(sun);

            // Generate weather and create globe
            generateWeatherData();
            createGlobe();
            createMarkers();

            // Mouse interaction
            container.addEventListener('click', onGlobeClick);
            container.addEventListener('mousedown', () => container.style.cursor = 'grabbing');
            container.addEventListener('mouseup', () => container.style.cursor = 'grab');

            // Auto-rotate
            let isDragging = false;
            let prevX = 0;

            container.addEventListener('mousedown', (e) => {
                isDragging = true;
                prevX = e.clientX;
            });

            container.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - prevX;
                    globe.rotation.y += deltaX * 0.005;
                    prevX = e.clientX;
                }
            });

            container.addEventListener('mouseup', () => isDragging = false);
            container.addEventListener('mouseleave', () => isDragging = false);

            animate();
            window.addEventListener('resize', onWindowResize);
        }

        function generateWeatherData() {
            // Generate smooth, continuous weather patterns using spherical harmonics
            const resolution = 64;
            weatherData.temp = [];
            weatherData.pressure = [];

            // Random coefficients for temperature
            const tempCoeffs = [];
            const pressureCoeffs = [];
            for (let l = 0; l < 5; l++) {
                for (let m = -l; m <= l; m++) {
                    tempCoeffs.push({
                        l, m,
                        a: (Math.random() - 0.5) * 2 / (l + 1),
                        b: (Math.random() - 0.5) * 2 / (l + 1)
                    });
                    pressureCoeffs.push({
                        l, m,
                        a: (Math.random() - 0.5) * 2 / (l + 1),
                        b: (Math.random() - 0.5) * 2 / (l + 1)
                    });
                }
            }

            for (let i = 0; i < resolution; i++) {
                weatherData.temp[i] = [];
                weatherData.pressure[i] = [];
                const lat = (i / resolution - 0.5) * Math.PI;

                for (let j = 0; j < resolution * 2; j++) {
                    const lon = (j / resolution - 1) * Math.PI;

                    // Simple noise-based temperature (warmer at equator)
                    let temp = 20 - Math.abs(lat) * 40 / (Math.PI / 2);
                    temp += noise(lat * 3, lon * 3) * 15;
                    temp += noise(lat * 7 + 100, lon * 7) * 8;

                    // Pressure with different pattern
                    let pressure = 1013 + noise(lat * 2 + 50, lon * 2 + 50) * 30;
                    pressure += noise(lat * 5 + 200, lon * 5 + 200) * 15;

                    weatherData.temp[i][j] = temp;
                    weatherData.pressure[i][j] = pressure;
                }
            }
        }

        function noise(x, y) {
            // Simple pseudo-random noise
            const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            return (n - Math.floor(n)) * 2 - 1;
        }

        function getWeatherAt(lat, lon) {
            const resolution = 64;
            const i = Math.floor(((lat / Math.PI) + 0.5) * resolution);
            const j = Math.floor(((lon / Math.PI) + 1) * resolution);

            const ii = Math.max(0, Math.min(resolution - 1, i));
            const jj = Math.max(0, Math.min(resolution * 2 - 1, j));

            return {
                temp: weatherData.temp[ii][jj],
                pressure: weatherData.pressure[ii][jj]
            };
        }

        function tempToColor(temp) {
            // Map temperature to color
            const t = (temp + 30) / 70; // Normalize -30 to 40
            const clamped = Math.max(0, Math.min(1, t));

            if (clamped < 0.25) {
                return new THREE.Color(0x1565c0).lerp(new THREE.Color(0x4fc3f7), clamped * 4);
            } else if (clamped < 0.5) {
                return new THREE.Color(0x4fc3f7).lerp(new THREE.Color(0x81c784), (clamped - 0.25) * 4);
            } else if (clamped < 0.75) {
                return new THREE.Color(0x81c784).lerp(new THREE.Color(0xfff176), (clamped - 0.5) * 4);
            } else {
                return new THREE.Color(0xfff176).lerp(new THREE.Color(0xff7043), (clamped - 0.75) * 4);
            }
        }

        function createGlobe() {
            const geometry = new THREE.SphereGeometry(1, 128, 64);
            const positions = geometry.attributes.position;
            const colors = new Float32Array(positions.count * 3);

            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);

                const lat = Math.asin(y);
                const lon = Math.atan2(z, x);

                const weather = getWeatherAt(lat, lon);
                const color = tempToColor(weather.temp);

                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.MeshStandardMaterial({
                vertexColors: true,
                roughness: 0.8,
                metalness: 0.1
            });

            globe = new THREE.Mesh(geometry, material);
            scene.add(globe);

            // Add wireframe for lat/lon lines
            const wireGeometry = new THREE.SphereGeometry(1.002, 24, 12);
            const wireMaterial = new THREE.MeshBasicMaterial({
                color: 0x444466,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            const wireframe = new THREE.Mesh(wireGeometry, wireMaterial);
            globe.add(wireframe);
        }

        function createMarkers() {
            // Marker A (orange)
            const markerGeomA = new THREE.SphereGeometry(0.05, 16, 16);
            const markerMatA = new THREE.MeshBasicMaterial({ color: 0xff7043 });
            markerA = new THREE.Mesh(markerGeomA, markerMatA);
            markerA.visible = false;
            scene.add(markerA);

            // Marker B (blue)
            const markerGeomB = new THREE.SphereGeometry(0.05, 16, 16);
            const markerMatB = new THREE.MeshBasicMaterial({ color: 0x42a5f5 });
            markerB = new THREE.Mesh(markerGeomB, markerMatB);
            markerB.visible = false;
            scene.add(markerB);
        }

        function latLonToPosition(lat, lon, radius = 1.05) {
            return new THREE.Vector3(
                radius * Math.cos(lat) * Math.cos(lon),
                radius * Math.sin(lat),
                radius * Math.cos(lat) * Math.sin(lon)
            );
        }

        function setSelectedPoint(lat, lon) {
            selectedLat = lat;
            selectedLon = lon;

            // Position markers
            const posA = latLonToPosition(lat, lon);
            markerA.position.copy(posA);
            markerA.visible = true;

            // Antipodal point
            const antiLat = -lat;
            const antiLon = lon > 0 ? lon - Math.PI : lon + Math.PI;
            const posB = latLonToPosition(antiLat, antiLon);
            markerB.position.copy(posB);
            markerB.visible = true;

            // Get weather data
            const weatherA = getWeatherAt(lat, lon);
            const weatherB = getWeatherAt(antiLat, antiLon);

            // Update UI
            document.getElementById('coordsA').textContent =
                `${(lat * 180 / Math.PI).toFixed(1)}¬∞${lat >= 0 ? 'N' : 'S'}, ${(lon * 180 / Math.PI).toFixed(1)}¬∞${lon >= 0 ? 'E' : 'W'}`;
            document.getElementById('coordsB').textContent =
                `${(-lat * 180 / Math.PI).toFixed(1)}¬∞${-lat >= 0 ? 'N' : 'S'}, ${((antiLon) * 180 / Math.PI).toFixed(1)}¬∞${antiLon >= 0 ? 'E' : 'W'}`;

            document.getElementById('tempA').textContent = weatherA.temp.toFixed(1) + '¬∞C';
            document.getElementById('tempB').textContent = weatherB.temp.toFixed(1) + '¬∞C';
            document.getElementById('pressureA').textContent = weatherA.pressure.toFixed(0) + ' hPa';
            document.getElementById('pressureB').textContent = weatherB.pressure.toFixed(0) + ' hPa';

            const diffTemp = Math.abs(weatherA.temp - weatherB.temp);
            const diffPressure = Math.abs(weatherA.pressure - weatherB.pressure);

            document.getElementById('diffTemp').textContent = diffTemp.toFixed(1) + '¬∞C';
            document.getElementById('diffPressure').textContent = diffPressure.toFixed(0) + ' hPa';

            const indicator = document.getElementById('matchIndicator');
            if (diffTemp < 0.5 && diffPressure < 2) {
                indicator.className = 'match-indicator matching';
                indicator.innerHTML = '‚úÖ MATCHING PAIR FOUND!<br>Same temperature AND pressure!';
            } else {
                indicator.className = 'match-indicator not-matching';
                indicator.innerHTML = `‚ö†Ô∏è Not matching yet<br>Keep searching or click "Find Matching Pair"`;
            }
        }

        function onGlobeClick(event) {
            const container = document.getElementById('globe-container');
            const rect = container.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObject(globe);
            if (intersects.length > 0) {
                const point = intersects[0].point;

                // Convert to lat/lon (accounting for globe rotation)
                const localPoint = globe.worldToLocal(point.clone());
                const lat = Math.asin(localPoint.y / localPoint.length());
                const lon = Math.atan2(localPoint.z, localPoint.x);

                setSelectedPoint(lat, lon);
            }
        }

        function findMatchingPair() {
            if (isSearching) return;
            isSearching = true;

            // Search for a matching pair using gradient descent on the difference
            let bestLat = 0, bestLon = 0;
            let bestScore = Infinity;

            // Grid search first
            for (let i = 0; i < 50; i++) {
                const lat = (Math.random() - 0.5) * Math.PI;
                const lon = (Math.random() - 0.5) * 2 * Math.PI;

                const antiLat = -lat;
                const antiLon = lon > 0 ? lon - Math.PI : lon + Math.PI;

                const weatherA = getWeatherAt(lat, lon);
                const weatherB = getWeatherAt(antiLat, antiLon);

                const score = Math.abs(weatherA.temp - weatherB.temp) +
                              Math.abs(weatherA.pressure - weatherB.pressure) / 10;

                if (score < bestScore) {
                    bestScore = score;
                    bestLat = lat;
                    bestLon = lon;
                }
            }

            // Animate the search
            let searchStep = 0;
            const searchInterval = setInterval(() => {
                // Random point near best
                const lat = bestLat + (Math.random() - 0.5) * 0.5;
                const lon = bestLon + (Math.random() - 0.5) * 0.5;

                setSelectedPoint(lat, lon);

                // Local optimization
                const antiLat = -lat;
                const antiLon = lon > 0 ? lon - Math.PI : lon + Math.PI;
                const weatherA = getWeatherAt(lat, lon);
                const weatherB = getWeatherAt(antiLat, antiLon);
                const score = Math.abs(weatherA.temp - weatherB.temp) +
                              Math.abs(weatherA.pressure - weatherB.pressure) / 10;

                if (score < bestScore) {
                    bestScore = score;
                    bestLat = lat;
                    bestLon = lon;
                }

                searchStep++;
                if (searchStep > 30 || bestScore < 0.5) {
                    clearInterval(searchInterval);
                    setSelectedPoint(bestLat, bestLon);
                    isSearching = false;
                }
            }, 100);
        }

        function randomizeWeather() {
            scene.remove(globe);
            generateWeatherData();
            createGlobe();

            markerA.visible = false;
            markerB.visible = false;

            document.getElementById('coordsA').textContent = 'Click globe to select';
            document.getElementById('coordsB').textContent = 'Opposite side of Earth';
            document.getElementById('tempA').textContent = '--';
            document.getElementById('tempB').textContent = '--';
            document.getElementById('pressureA').textContent = '--';
            document.getElementById('pressureB').textContent = '--';
            document.getElementById('diffTemp').textContent = '--';
            document.getElementById('diffPressure').textContent = '--';

            const indicator = document.getElementById('matchIndicator');
            indicator.className = 'match-indicator not-matching';
            indicator.innerHTML = 'Click globe or search for matching pair';
        }

        function onWindowResize() {
            const container = document.getElementById('globe-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Slow auto-rotation
            if (!isSearching) {
                globe.rotation.y += 0.001;
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
