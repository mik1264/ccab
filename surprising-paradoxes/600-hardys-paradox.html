<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hardy's Paradox - Particles That Should Annihilate But Don't</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 50%, #0a1a2e 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 0;
            border-bottom: 1px solid rgba(147, 112, 219, 0.3);
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(135deg, #9370db, #00bfff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2em;
            color: #888;
            font-style: italic;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        @media (max-width: 1000px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .visualization-section {
            background: rgba(20, 20, 40, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(147, 112, 219, 0.3);
        }

        canvas {
            width: 100%;
            border-radius: 10px;
            background: #050510;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        button {
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            border: none;
            border-radius: 25px;
            background: linear-gradient(135deg, #9370db, #6a5acd);
            color: white;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(147, 112, 219, 0.4);
        }

        button.active {
            background: linear-gradient(135deg, #00bfff, #0080ff);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-label {
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #9370db;
        }

        .paradox-indicator {
            background: linear-gradient(135deg, rgba(255, 100, 100, 0.2), rgba(255, 50, 50, 0.3));
            border: 1px solid rgba(255, 100, 100, 0.5);
        }

        .paradox-indicator .stat-value {
            color: #ff6666;
        }

        .essay-section {
            background: rgba(20, 20, 40, 0.6);
            border-radius: 15px;
            padding: 30px;
            border: 1px solid rgba(147, 112, 219, 0.2);
            max-height: 800px;
            overflow-y: auto;
        }

        .essay-section h2 {
            color: #9370db;
            margin: 25px 0 15px 0;
            font-size: 1.4em;
        }

        .essay-section h2:first-child {
            margin-top: 0;
        }

        .essay-section p {
            line-height: 1.8;
            margin-bottom: 15px;
            text-align: justify;
        }

        .equation {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
            font-size: 14px;
            overflow-x: auto;
        }

        .highlight {
            color: #00bfff;
            font-weight: bold;
        }

        .warning {
            color: #ff6666;
            font-weight: bold;
        }

        .diagram {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            white-space: pre;
            overflow-x: auto;
        }

        .sources {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(147, 112, 219, 0.3);
            font-size: 0.9em;
        }

        .sources h3 {
            color: #9370db;
            margin-bottom: 10px;
        }

        .sources ul {
            list-style: none;
            padding: 0;
        }

        .sources li {
            margin: 8px 0;
            padding-left: 15px;
            border-left: 2px solid #6a5acd;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #9370db;
            text-decoration: none;
            font-size: 14px;
        }

        .back-link:hover {
            color: #00bfff;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .setup-diagram {
            text-align: center;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Paradoxes</a>

        <header>
            <h1>Hardy's Paradox</h1>
            <p class="subtitle">Particles that should annihilate but don't - proving quantum nonlocality</p>
        </header>

        <div class="main-content">
            <div class="visualization-section">
                <canvas id="canvas" width="600" height="500"></canvas>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-dot" style="background: #ff6666;"></div>
                        <span>Electron (e⁻)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot" style="background: #66ff66;"></div>
                        <span>Positron (e⁺)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot" style="background: #ffff66;"></div>
                        <span>Overlap Region</span>
                    </div>
                </div>

                <div class="controls">
                    <button id="btnRun" class="active">Run Experiment</button>
                    <button id="btnStep">Single Shot</button>
                    <button id="btnReset">Reset Stats</button>
                    <button id="btnSpeed">Speed: Normal</button>
                </div>

                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">Total Experiments</div>
                        <div class="stat-value" id="totalExperiments">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Normal Results</div>
                        <div class="stat-value" id="normalResults">0</div>
                    </div>
                    <div class="stat-box paradox-indicator">
                        <div class="stat-label">Paradoxical Events</div>
                        <div class="stat-value" id="paradoxEvents">0</div>
                    </div>
                    <div class="stat-box paradox-indicator">
                        <div class="stat-label">Paradox Rate</div>
                        <div class="stat-value" id="paradoxRate">0.0%</div>
                    </div>
                </div>
            </div>

            <div class="essay-section">
                <h2>The Impossible Observation</h2>
                <p>
                    In 1992, physicist <span class="highlight">Lucien Hardy</span> devised what has been called
                    "the best version of Bell's theorem" - a thought experiment so profound that it proves
                    quantum mechanics cannot be both <span class="highlight">local</span> and <span class="highlight">realistic</span>
                    using just a single experimental outcome, not statistical correlations.
                </p>

                <p>
                    The setup involves an <span class="highlight">electron</span> and a <span class="highlight">positron</span>
                    (the electron's antiparticle) traveling through two overlapping Mach-Zehnder interferometers.
                    According to classical physics, when a particle meets its antiparticle, they must
                    <span class="warning">annihilate</span> - convert entirely into gamma rays.
                </p>

                <div class="diagram">        Electron                    Positron
            ┌──────┐                  ┌──────┐
      ──────│ BS1  │────────┐  ┌──────│ BS2  │──────
            └──────┘    ┌───┼──┼───┐  └──────┘
               │        │ Overlap │        │
               │        │  Zone   │        │
               │        └───┼──┼───┘        │
            ┌──────┐        │  │        ┌──────┐
      ──────│ BS3  │────────┘  └────────│ BS4  │──────
            └──────┘                    └──────┘
          D₁⁻   D₂⁻                    D₁⁺   D₂⁺
                </div>

                <h2>The Paradox</h2>
                <p>
                    Hardy showed that quantum mechanics predicts a probability of about <span class="highlight">9%</span>
                    for an outcome that seems logically impossible. Here's the paradox:
                </p>

                <p>
                    1. If we detect the electron at detector D₂⁻, we can infer it took the path through
                    the overlap region (because of interference at the beam splitters).<br><br>
                    2. Similarly, if we detect the positron at D₂⁺, it must have gone through the overlap region.<br><br>
                    3. But if both particles went through the overlap region, they <span class="warning">must have annihilated!</span><br><br>
                    4. Yet quantum mechanics predicts we sometimes detect both at D₂⁻ AND D₂⁺ simultaneously!
                </p>

                <div class="equation">
                    P(D₂⁻ AND D₂⁺) = (3 - 2√2)² / 16 ≈ 9.02%
                </div>

                <h2>What It Proves</h2>
                <p>
                    This "impossible" outcome proves that quantum mechanics is <span class="highlight">nonlocal</span>.
                    The particles seem to "know" about each other's measurements instantaneously, even though
                    they're spatially separated. The only way to explain the result classically would require
                    faster-than-light influence.
                </p>

                <p>
                    Unlike Bell's inequality, which requires statistical analysis of many measurements,
                    Hardy's paradox proves nonlocality with <span class="highlight">just one observation</span>.
                    A single D₂⁻/D₂⁺ coincidence is enough to rule out local hidden variables.
                </p>

                <h2>The Mathematics</h2>
                <p>The quantum state after the beam splitters is:</p>

                <div class="equation">
|ψ⟩ = ½[(|u⟩ₑ + |v⟩ₑ)(|u⟩ₚ + |v⟩ₚ)]

After accounting for annihilation:
|ψ'⟩ = ½[|u⟩ₑ|u⟩ₚ + |u⟩ₑ|v⟩ₚ + |v⟩ₑ|u⟩ₚ]
(The |v⟩ₑ|v⟩ₚ term is removed by annihilation)
                </div>

                <p>
                    The key insight is that the <span class="highlight">absence</span> of the |v⟩ₑ|v⟩ₚ term
                    (due to annihilation) creates quantum correlations that lead to the paradoxical outcome.
                </p>

                <h2>2024: Loophole-Free Confirmation</h2>
                <p>
                    In 2024, scientists in China achieved a <span class="highlight">loophole-free test</span>
                    of Hardy's paradox, published in Physical Review Letters. Using entangled photon pairs
                    with high-efficiency detectors and space-like separated measurements, they closed the
                    detection loophole and locality loophole simultaneously.
                </p>

                <p>
                    The "realigned Hardy's paradox" version developed in 2024 shows even stronger violations
                    of local realism and has applications in quantum cryptography and quantum computing.
                </p>

                <h2>Why It Matters</h2>
                <p>
                    Hardy's paradox is not just a curiosity - it has practical implications:
                </p>
                <p>
                    <span class="highlight">Device-Independent Quantum Cryptography:</span> The paradox can
                    certify the security of quantum key distribution without trusting the quantum devices.
                </p>
                <p>
                    <span class="highlight">Foundations of Reality:</span> It demonstrates that the universe
                    is fundamentally nonlocal - separated events can be correlated in ways impossible classically.
                </p>
                <p>
                    <span class="highlight">Quantum Information:</span> Understanding Hardy's paradox leads
                    to better protocols for quantum teleportation and entanglement distribution.
                </p>

                <div class="sources">
                    <h3>Sources</h3>
                    <ul>
                        <li>Hardy, L. (1993). "Nonlocality for two particles without inequalities" - Physical Review Letters</li>
                        <li>Lundeen, J.S. & Steinberg, A.M. (2009). "Experimental Joint Weak Measurement" - Physical Review Letters</li>
                        <li>Chen, J.L. et al. (2024). "Loophole-Free Test of Local Realism via Hardy's Violation" - Physical Review Letters 133, 060201</li>
                        <li>Wikipedia: Hardy's paradox</li>
                        <li>Perimeter Institute: Hardy's Paradox Confirmed Experimentally</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // High DPI support
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        const width = rect.width;
        const height = rect.height;

        // State
        let running = true;
        let speed = 1;
        let stats = { total: 0, normal: 0, paradox: 0 };

        // Experiment phases
        let phase = 'ready'; // ready, propagating, measuring, result
        let phaseTime = 0;
        let resultType = '';

        // Particle positions (as wave packets)
        let electronWave = null;
        let positronWave = null;

        // Geometry
        const centerX = width / 2;
        const centerY = height / 2;
        const scale = Math.min(width, height) / 500;

        // Beam splitter positions
        const bs1 = { x: centerX - 150 * scale, y: centerY - 80 * scale };
        const bs2 = { x: centerX + 150 * scale, y: centerY - 80 * scale };
        const bs3 = { x: centerX - 150 * scale, y: centerY + 80 * scale };
        const bs4 = { x: centerX + 150 * scale, y: centerY + 80 * scale };

        // Overlap region
        const overlapX = centerX;
        const overlapY = centerY;

        // Detectors
        const d1e = { x: bs3.x - 80 * scale, y: bs3.y + 60 * scale };
        const d2e = { x: bs3.x + 80 * scale, y: bs3.y + 60 * scale };
        const d1p = { x: bs4.x - 80 * scale, y: bs4.y + 60 * scale };
        const d2p = { x: bs4.x + 80 * scale, y: bs4.y + 60 * scale };

        // Initialize experiment
        function initExperiment() {
            phase = 'propagating';
            phaseTime = 0;

            // Create wave packets
            electronWave = {
                paths: [
                    { // Upper path (through overlap)
                        points: [
                            { x: bs1.x - 60 * scale, y: bs1.y },
                            { x: bs1.x, y: bs1.y },
                            { x: overlapX - 30 * scale, y: overlapY },
                            { x: bs3.x, y: bs3.y }
                        ],
                        amplitude: 0.5
                    },
                    { // Lower path (direct)
                        points: [
                            { x: bs1.x - 60 * scale, y: bs1.y },
                            { x: bs1.x, y: bs1.y },
                            { x: bs1.x, y: bs3.y },
                            { x: bs3.x, y: bs3.y }
                        ],
                        amplitude: 0.5
                    }
                ],
                progress: 0,
                color: '#ff6666'
            };

            positronWave = {
                paths: [
                    { // Upper path (through overlap)
                        points: [
                            { x: bs2.x + 60 * scale, y: bs2.y },
                            { x: bs2.x, y: bs2.y },
                            { x: overlapX + 30 * scale, y: overlapY },
                            { x: bs4.x, y: bs4.y }
                        ],
                        amplitude: 0.5
                    },
                    { // Lower path (direct)
                        points: [
                            { x: bs2.x + 60 * scale, y: bs2.y },
                            { x: bs2.x, y: bs2.y },
                            { x: bs2.x, y: bs4.y },
                            { x: bs4.x, y: bs4.y }
                        ],
                        amplitude: 0.5
                    }
                ],
                progress: 0,
                color: '#66ff66'
            };
        }

        // Draw beam splitter
        function drawBeamSplitter(x, y, label) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.PI / 4);
            ctx.fillStyle = 'rgba(100, 150, 255, 0.3)';
            ctx.fillRect(-15 * scale, -3 * scale, 30 * scale, 6 * scale);
            ctx.strokeStyle = '#6496ff';
            ctx.lineWidth = 2;
            ctx.strokeRect(-15 * scale, -3 * scale, 30 * scale, 6 * scale);
            ctx.restore();

            ctx.fillStyle = '#888';
            ctx.font = `${10 * scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(label, x, y - 20 * scale);
        }

        // Draw detector
        function drawDetector(x, y, label, detected) {
            ctx.fillStyle = detected ? (label.includes('2') ? '#ff6666' : '#66ff66') : 'rgba(100, 100, 100, 0.5)';
            ctx.beginPath();
            ctx.arc(x, y, 15 * scale, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = detected ? '#fff' : '#666';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = '#fff';
            ctx.font = `bold ${10 * scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(label, x, y + 4 * scale);
        }

        // Draw wave packet on path
        function drawWaveOnPath(path, progress, color, phaseOffset) {
            const points = path.points;
            const amplitude = path.amplitude;

            if (amplitude < 0.01) return;

            // Calculate total path length
            let totalLength = 0;
            for (let i = 0; i < points.length - 1; i++) {
                const dx = points[i + 1].x - points[i].x;
                const dy = points[i + 1].y - points[i].y;
                totalLength += Math.sqrt(dx * dx + dy * dy);
            }

            // Find position along path
            const targetDist = progress * totalLength;
            let currentDist = 0;
            let pos = points[0];
            let angle = 0;

            for (let i = 0; i < points.length - 1; i++) {
                const dx = points[i + 1].x - points[i].x;
                const dy = points[i + 1].y - points[i].y;
                const segLength = Math.sqrt(dx * dx + dy * dy);

                if (currentDist + segLength >= targetDist) {
                    const t = (targetDist - currentDist) / segLength;
                    pos = {
                        x: points[i].x + dx * t,
                        y: points[i].y + dy * t
                    };
                    angle = Math.atan2(dy, dx);
                    break;
                }
                currentDist += segLength;
            }

            // Draw wave packet
            const waveWidth = 30 * scale;
            const waveHeight = 10 * scale * amplitude;

            ctx.save();
            ctx.translate(pos.x, pos.y);
            ctx.rotate(angle);

            // Glow
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, waveWidth);
            gradient.addColorStop(0, color);
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.globalAlpha = 0.3 * amplitude;
            ctx.beginPath();
            ctx.arc(0, 0, waveWidth, 0, Math.PI * 2);
            ctx.fill();

            // Wave oscillation
            ctx.globalAlpha = amplitude;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = -waveWidth; x <= waveWidth; x += 2) {
                const envelope = Math.exp(-x * x / (waveWidth * waveWidth / 2));
                const y = Math.sin(x * 0.3 + phaseOffset) * waveHeight * envelope;
                if (x === -waveWidth) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            // Core particle
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(0, 0, 5 * scale * amplitude, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // Draw overlap region
        function drawOverlapRegion(active) {
            const gradient = ctx.createRadialGradient(
                overlapX, overlapY, 0,
                overlapX, overlapY, 50 * scale
            );

            if (active) {
                gradient.addColorStop(0, 'rgba(255, 255, 100, 0.4)');
                gradient.addColorStop(0.5, 'rgba(255, 200, 50, 0.2)');
                gradient.addColorStop(1, 'transparent');
            } else {
                gradient.addColorStop(0, 'rgba(100, 100, 150, 0.2)');
                gradient.addColorStop(1, 'transparent');
            }

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(overlapX, overlapY, 50 * scale, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = active ? 'rgba(255, 255, 100, 0.5)' : 'rgba(100, 100, 150, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#888';
            ctx.font = `${10 * scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('Overlap', overlapX, overlapY - 35 * scale);
            ctx.fillText('Zone', overlapX, overlapY - 25 * scale);
        }

        // Draw paths
        function drawPaths() {
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.3)';
            ctx.lineWidth = 1;

            // Electron paths
            ctx.beginPath();
            ctx.moveTo(bs1.x - 60 * scale, bs1.y);
            ctx.lineTo(bs1.x, bs1.y);
            ctx.lineTo(overlapX - 30 * scale, overlapY);
            ctx.lineTo(bs3.x, bs3.y);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(bs1.x, bs1.y);
            ctx.lineTo(bs1.x, bs3.y);
            ctx.lineTo(bs3.x, bs3.y);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(bs3.x, bs3.y);
            ctx.lineTo(d1e.x, d1e.y);
            ctx.moveTo(bs3.x, bs3.y);
            ctx.lineTo(d2e.x, d2e.y);
            ctx.stroke();

            // Positron paths
            ctx.beginPath();
            ctx.moveTo(bs2.x + 60 * scale, bs2.y);
            ctx.lineTo(bs2.x, bs2.y);
            ctx.lineTo(overlapX + 30 * scale, overlapY);
            ctx.lineTo(bs4.x, bs4.y);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(bs2.x, bs2.y);
            ctx.lineTo(bs2.x, bs4.y);
            ctx.lineTo(bs4.x, bs4.y);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(bs4.x, bs4.y);
            ctx.lineTo(d1p.x, d1p.y);
            ctx.moveTo(bs4.x, bs4.y);
            ctx.lineTo(d2p.x, d2p.y);
            ctx.stroke();
        }

        // Quantum measurement
        function measureResult() {
            // Hardy's paradox probabilities
            // P(D2e AND D2p) ≈ 9% - the paradoxical case
            // Simplified simulation of quantum outcomes

            const rand = Math.random();

            // Approximately 9% paradoxical outcomes
            if (rand < 0.0902) {
                return 'paradox'; // Both at D2
            } else if (rand < 0.4) {
                return 'd1e_d1p'; // Both at D1
            } else if (rand < 0.7) {
                return 'd1e_d2p'; // Electron D1, Positron D2
            } else {
                return 'd2e_d1p'; // Electron D2, Positron D1
            }
        }

        // Main draw function
        function draw(time) {
            // Clear
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, width, height);

            // Title
            ctx.fillStyle = '#9370db';
            ctx.font = `bold ${14 * scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('Hardy\'s Paradox: Mach-Zehnder Interferometers', centerX, 25 * scale);

            // Labels
            ctx.fillStyle = '#ff6666';
            ctx.font = `${12 * scale}px Arial`;
            ctx.textAlign = 'left';
            ctx.fillText('Electron (e⁻)', bs1.x - 100 * scale, bs1.y);

            ctx.fillStyle = '#66ff66';
            ctx.textAlign = 'right';
            ctx.fillText('Positron (e⁺)', bs2.x + 100 * scale, bs2.y);

            // Draw paths
            drawPaths();

            // Check if particles are in overlap region
            const overlapActive = phase === 'propagating' &&
                electronWave && positronWave &&
                electronWave.progress > 0.3 && electronWave.progress < 0.6;

            // Draw overlap region
            drawOverlapRegion(overlapActive);

            // Draw beam splitters
            drawBeamSplitter(bs1.x, bs1.y, 'BS₁');
            drawBeamSplitter(bs2.x, bs2.y, 'BS₂');
            drawBeamSplitter(bs3.x, bs3.y, 'BS₃');
            drawBeamSplitter(bs4.x, bs4.y, 'BS₄');

            // Determine detector states based on phase
            let d1eDetected = false, d2eDetected = false;
            let d1pDetected = false, d2pDetected = false;

            if (phase === 'result') {
                if (resultType === 'paradox') {
                    d2eDetected = true;
                    d2pDetected = true;
                } else if (resultType === 'd1e_d1p') {
                    d1eDetected = true;
                    d1pDetected = true;
                } else if (resultType === 'd1e_d2p') {
                    d1eDetected = true;
                    d2pDetected = true;
                } else if (resultType === 'd2e_d1p') {
                    d2eDetected = true;
                    d1pDetected = true;
                }
            }

            // Draw detectors
            drawDetector(d1e.x, d1e.y, 'D₁⁻', d1eDetected);
            drawDetector(d2e.x, d2e.y, 'D₂⁻', d2eDetected);
            drawDetector(d1p.x, d1p.y, 'D₁⁺', d1pDetected);
            drawDetector(d2p.x, d2p.y, 'D₂⁺', d2pDetected);

            // Draw wave packets
            if (phase === 'propagating' && electronWave && positronWave) {
                const phaseOffset = time * 0.01;

                electronWave.paths.forEach(path => {
                    drawWaveOnPath(path, electronWave.progress, electronWave.color, phaseOffset);
                });

                positronWave.paths.forEach(path => {
                    drawWaveOnPath(path, positronWave.progress, positronWave.color, phaseOffset + Math.PI);
                });
            }

            // Draw result text
            if (phase === 'result') {
                ctx.font = `bold ${16 * scale}px Arial`;
                ctx.textAlign = 'center';

                if (resultType === 'paradox') {
                    ctx.fillStyle = '#ff6666';
                    ctx.fillText('PARADOX! Both D₂⁻ AND D₂⁺ detected!', centerX, height - 30 * scale);
                    ctx.font = `${12 * scale}px Arial`;
                    ctx.fillText('Both particles took the overlap path... but didn\'t annihilate!', centerX, height - 12 * scale);
                } else {
                    ctx.fillStyle = '#66ff66';
                    ctx.fillText('Normal quantum outcome', centerX, height - 20 * scale);
                }
            }

            // Annihilation effect
            if (overlapActive && Math.random() < 0.1) {
                // Draw gamma rays occasionally (visual effect, not affecting outcome)
                const numRays = 8;
                ctx.strokeStyle = 'rgba(255, 255, 200, 0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i < numRays; i++) {
                    const angle = (i / numRays) * Math.PI * 2 + time * 0.005;
                    const length = 20 * scale * Math.random();
                    ctx.beginPath();
                    ctx.moveTo(overlapX, overlapY);
                    ctx.lineTo(
                        overlapX + Math.cos(angle) * length,
                        overlapY + Math.sin(angle) * length
                    );
                    ctx.stroke();
                }
            }
        }

        // Update simulation
        function update(deltaTime) {
            if (!running && phase === 'ready') return;

            phaseTime += deltaTime * speed;

            if (phase === 'propagating') {
                if (electronWave && positronWave) {
                    electronWave.progress = Math.min(1, phaseTime / 2000);
                    positronWave.progress = Math.min(1, phaseTime / 2000);

                    if (electronWave.progress >= 1) {
                        phase = 'measuring';
                        phaseTime = 0;
                        resultType = measureResult();
                    }
                }
            } else if (phase === 'measuring') {
                if (phaseTime > 200) {
                    phase = 'result';
                    phaseTime = 0;

                    // Update stats
                    stats.total++;
                    if (resultType === 'paradox') {
                        stats.paradox++;
                    } else {
                        stats.normal++;
                    }
                    updateStats();
                }
            } else if (phase === 'result') {
                if (phaseTime > (running ? 800 : 2000)) {
                    phase = 'ready';
                    phaseTime = 0;
                    if (running) {
                        initExperiment();
                    }
                }
            } else if (phase === 'ready' && running) {
                initExperiment();
            }
        }

        // Update statistics display
        function updateStats() {
            document.getElementById('totalExperiments').textContent = stats.total;
            document.getElementById('normalResults').textContent = stats.normal;
            document.getElementById('paradoxEvents').textContent = stats.paradox;
            const rate = stats.total > 0 ? (stats.paradox / stats.total * 100).toFixed(1) : '0.0';
            document.getElementById('paradoxRate').textContent = rate + '%';
        }

        // Animation loop
        let lastTime = 0;
        function animate(time) {
            const deltaTime = time - lastTime;
            lastTime = time;

            update(deltaTime);
            draw(time);

            requestAnimationFrame(animate);
        }

        // Button handlers
        document.getElementById('btnRun').addEventListener('click', function() {
            running = !running;
            this.textContent = running ? 'Pause' : 'Run Experiment';
            this.classList.toggle('active', running);
            if (running && phase === 'ready') {
                initExperiment();
            }
        });

        document.getElementById('btnStep').addEventListener('click', function() {
            running = false;
            document.getElementById('btnRun').textContent = 'Run Experiment';
            document.getElementById('btnRun').classList.remove('active');
            initExperiment();
        });

        document.getElementById('btnReset').addEventListener('click', function() {
            stats = { total: 0, normal: 0, paradox: 0 };
            updateStats();
        });

        document.getElementById('btnSpeed').addEventListener('click', function() {
            speed = speed === 1 ? 3 : (speed === 3 ? 0.5 : 1);
            const label = speed === 1 ? 'Normal' : (speed === 3 ? 'Fast' : 'Slow');
            this.textContent = 'Speed: ' + label;
        });

        // Start
        initExperiment();
        animate(0);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
