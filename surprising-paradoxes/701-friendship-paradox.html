<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>701 - Friendship Paradox | Surprising Paradoxes | CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
            padding: 20px;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #64b5f6;
            text-decoration: none;
            font-size: 14px;
            opacity: 0.8;
            z-index: 100;
        }
        .back-link:hover { opacity: 1; }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding-top: 40px;
        }
        h1 {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #9b59b6, #3498db);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle {
            text-align: center;
            color: #aaa;
            font-size: 1.1rem;
            margin-bottom: 30px;
        }
        .paradox-statement {
            background: rgba(155, 89, 182, 0.15);
            border: 1px solid rgba(155, 89, 182, 0.3);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 30px;
            text-align: center;
        }
        .paradox-statement h2 {
            color: #9b59b6;
            font-size: 1.5rem;
            margin-bottom: 15px;
        }
        .paradox-statement p {
            font-size: 1.2rem;
            line-height: 1.6;
        }
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
            margin-bottom: 30px;
        }
        @media (max-width: 900px) {
            .main-grid { grid-template-columns: 1fr; }
        }
        .network-panel {
            background: rgba(255,255,255,0.05);
            border-radius: 16px;
            padding: 20px;
        }
        .network-title {
            font-size: 1.2rem;
            color: #9b59b6;
            margin-bottom: 15px;
            text-align: center;
        }
        #network-canvas {
            width: 100%;
            height: 450px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            cursor: pointer;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .btn {
            padding: 10px 20px;
            font-size: 0.9rem;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .btn-primary {
            background: linear-gradient(135deg, #9b59b6, #3498db);
            color: white;
        }
        .btn-primary:hover { transform: scale(1.05); }
        .btn-secondary {
            background: rgba(100, 181, 246, 0.2);
            border: 2px solid #64b5f6;
            color: #64b5f6;
        }
        .btn-secondary:hover { background: rgba(100, 181, 246, 0.3); }
        .stats-panel {
            background: rgba(255,255,255,0.05);
            border-radius: 16px;
            padding: 20px;
        }
        .stat-section {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .stat-section h3 {
            color: #64b5f6;
            font-size: 1rem;
            margin-bottom: 10px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .stat-row:last-child { border-bottom: none; }
        .stat-value {
            font-weight: bold;
            color: #f1c40f;
        }
        .highlight-stat {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid rgba(231, 76, 60, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            text-align: center;
        }
        .highlight-stat .big-number {
            font-size: 2.5rem;
            font-weight: bold;
            color: #e74c3c;
        }
        .highlight-stat .label {
            color: #aaa;
            font-size: 0.9rem;
        }
        .selected-node {
            background: rgba(46, 204, 113, 0.2);
            border: 1px solid rgba(46, 204, 113, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        .selected-node h4 {
            color: #2ecc71;
            margin-bottom: 10px;
        }
        .explanation-section {
            background: rgba(255,255,255,0.05);
            border-radius: 16px;
            padding: 25px;
            margin-bottom: 30px;
        }
        .explanation-section h3 {
            color: #9b59b6;
            margin-bottom: 15px;
        }
        .explanation-section p {
            line-height: 1.7;
            margin-bottom: 12px;
        }
        .real-world {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .platform-card {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
        }
        .platform-card h4 {
            color: #3498db;
            margin-bottom: 10px;
        }
        .platform-stat {
            font-size: 2rem;
            font-weight: bold;
            color: #e74c3c;
        }
        .platform-desc {
            color: #aaa;
            font-size: 0.9rem;
            margin-top: 5px;
        }
        .application-box {
            background: rgba(46, 204, 113, 0.1);
            border: 1px solid rgba(46, 204, 113, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }
        .application-box h4 {
            color: #2ecc71;
            margin-bottom: 10px;
        }
        .math-box {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
            overflow-x: auto;
        }
        .history {
            background: rgba(155, 89, 182, 0.1);
            border-left: 4px solid #9b59b6;
            padding: 20px;
            margin-top: 30px;
            border-radius: 0 12px 12px 0;
        }
        .history h4 {
            color: #9b59b6;
            margin-bottom: 10px;
        }
        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            color: #aaa;
        }
        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Paradoxes</a>

    <div class="container">
        <h1>The Friendship Paradox</h1>
        <p class="subtitle">Scott L. Feld (1991) • American Journal of Sociology</p>

        <div class="paradox-statement">
            <h2>The Paradox</h2>
            <p>On average, <strong>your friends have more friends than you do</strong>.<br>
            This isn't about you personally — it's mathematically guaranteed for most people!</p>
        </div>

        <div class="main-grid">
            <div class="network-panel">
                <h3 class="network-title">Interactive Social Network</h3>
                <canvas id="network-canvas"></canvas>
                <div class="controls">
                    <button class="btn btn-primary" onclick="generateNetwork()">New Network</button>
                    <button class="btn btn-secondary" onclick="generateNetwork('hub')">Hub Network</button>
                    <button class="btn btn-secondary" onclick="generateNetwork('uniform')">Uniform Network</button>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-dot" style="background: #3498db;"></div>
                        <span>Normal node</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot" style="background: #2ecc71;"></div>
                        <span>Selected</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot" style="background: #e74c3c;"></div>
                        <span>Friends</span>
                    </div>
                </div>
            </div>

            <div class="stats-panel">
                <div class="stat-section">
                    <h3>Network Statistics</h3>
                    <div class="stat-row">
                        <span>Total People</span>
                        <span class="stat-value" id="total-nodes">0</span>
                    </div>
                    <div class="stat-row">
                        <span>Total Connections</span>
                        <span class="stat-value" id="total-edges">0</span>
                    </div>
                    <div class="stat-row">
                        <span>Avg Friends per Person</span>
                        <span class="stat-value" id="avg-degree">0</span>
                    </div>
                    <div class="stat-row">
                        <span>Avg Friends-of-Friends</span>
                        <span class="stat-value" id="avg-fof">0</span>
                    </div>
                </div>

                <div class="highlight-stat">
                    <div class="big-number" id="paradox-pct">0%</div>
                    <div class="label">of people have fewer friends<br>than their friends' average</div>
                </div>

                <div class="selected-node" id="selected-info" style="display: none;">
                    <h4>Selected: <span id="selected-name">Person</span></h4>
                    <div class="stat-row">
                        <span>Their friends</span>
                        <span class="stat-value" id="selected-friends">0</span>
                    </div>
                    <div class="stat-row">
                        <span>Friends' avg friends</span>
                        <span class="stat-value" id="selected-fof">0</span>
                    </div>
                    <div class="stat-row">
                        <span>Paradox applies?</span>
                        <span class="stat-value" id="selected-paradox">-</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="explanation-section">
            <h3>Why Does This Happen?</h3>
            <p>It's a <strong>sampling bias</strong>: popular people appear in more friend lists!</p>
            <p>Imagine Alice has 1 friend, but Bob has 100 friends. When we pick a random person and look at their friends, Bob is 100× more likely to appear than Alice. So when averaging "friends of friends," popular people are overrepresented.</p>

            <div class="math-box">
<strong>The Math:</strong><br><br>
Average degree of a random node: μ = Σd(i) / n<br><br>
Average degree of a random neighbor: μ' = Σd(i)² / Σd(i)<br><br>
By Cauchy-Schwarz inequality: μ' ≥ μ (always!)<br><br>
The gap increases with degree variance (inequality in popularity).
            </div>

            <div class="real-world">
                <div class="platform-card">
                    <h4>Facebook (2011)</h4>
                    <div class="platform-stat">92.7%</div>
                    <div class="platform-desc">of users have fewer friends than their friends' average</div>
                </div>
                <div class="platform-card">
                    <h4>Twitter (2013)</h4>
                    <div class="platform-stat">98%+</div>
                    <div class="platform-desc">of users have fewer followers than their followers' average</div>
                </div>
                <div class="platform-card">
                    <h4>Generalized</h4>
                    <div class="platform-stat">∞</div>
                    <div class="platform-desc">Extends to wealth, happiness, activity — your friends probably have more of everything!</div>
                </div>
            </div>

            <div class="application-box">
                <h4>Practical Application: Epidemic Detection</h4>
                <p>In 2010, Christakis & Fowler showed that monitoring <strong>friends of random people</strong> (not random people themselves) can detect flu outbreaks <strong>2 weeks earlier</strong> than traditional surveillance!</p>
                <p>Why? Friends-of-random-people are more central in the network, so diseases reach them sooner. This "friendship paradox sampling" is now used in public health.</p>
            </div>
        </div>

        <div class="history">
            <h4>Historical Note</h4>
            <p>Sociologist Scott L. Feld published "Why your friends have more friends than you do" in the American Journal of Sociology in 1991. He analyzed data from James S. Coleman's 1961 study of high school friendships. The paradox has since been confirmed on every major social network and extended to show that your friends are probably richer, happier, and more active than you — a "generalized friendship paradox" that may explain why social media makes people feel inadequate.</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('network-canvas');
        const ctx = canvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let selectedNode = null;
        let hoveredNode = null;

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }

        function generateNetwork(type = 'random') {
            resizeCanvas();
            const rect = canvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;

            const numNodes = 25 + Math.floor(Math.random() * 10);
            nodes = [];
            edges = [];

            // Create nodes in a circle with some randomness
            for (let i = 0; i < numNodes; i++) {
                const angle = (i / numNodes) * Math.PI * 2;
                const radius = Math.min(w, h) * 0.35;
                const jitter = Math.random() * 40 - 20;
                nodes.push({
                    id: i,
                    x: w/2 + Math.cos(angle) * (radius + jitter),
                    y: h/2 + Math.sin(angle) * (radius + jitter),
                    degree: 0,
                    name: `Person ${i + 1}`
                });
            }

            // Create edges based on network type
            if (type === 'hub') {
                // Create a few hubs with many connections
                const hubIndices = [0, Math.floor(numNodes/3), Math.floor(2*numNodes/3)];
                for (let i = 0; i < numNodes; i++) {
                    if (hubIndices.includes(i)) continue;
                    // Connect to random hub
                    const hub = hubIndices[Math.floor(Math.random() * hubIndices.length)];
                    if (i !== hub) {
                        edges.push([i, hub]);
                        nodes[i].degree++;
                        nodes[hub].degree++;
                    }
                    // Some random connections
                    if (Math.random() < 0.2) {
                        const other = Math.floor(Math.random() * numNodes);
                        if (other !== i && !edgeExists(i, other)) {
                            edges.push([i, other]);
                            nodes[i].degree++;
                            nodes[other].degree++;
                        }
                    }
                }
            } else if (type === 'uniform') {
                // Each node gets ~3 connections
                for (let i = 0; i < numNodes; i++) {
                    for (let j = 0; j < 2; j++) {
                        const other = (i + 1 + j) % numNodes;
                        if (!edgeExists(i, other)) {
                            edges.push([i, other]);
                            nodes[i].degree++;
                            nodes[other].degree++;
                        }
                    }
                }
            } else {
                // Random network with preferential attachment flavor
                for (let i = 1; i < numNodes; i++) {
                    // Connect to at least one existing node
                    const numConnections = 1 + Math.floor(Math.random() * 3);
                    for (let c = 0; c < numConnections; c++) {
                        // Prefer connecting to higher-degree nodes
                        let target;
                        if (Math.random() < 0.6 && edges.length > 0) {
                            // Pick weighted by degree
                            const totalDegree = nodes.slice(0, i).reduce((s, n) => s + n.degree + 1, 0);
                            let r = Math.random() * totalDegree;
                            target = 0;
                            for (let j = 0; j < i; j++) {
                                r -= nodes[j].degree + 1;
                                if (r <= 0) { target = j; break; }
                            }
                        } else {
                            target = Math.floor(Math.random() * i);
                        }
                        if (!edgeExists(i, target)) {
                            edges.push([i, target]);
                            nodes[i].degree++;
                            nodes[target].degree++;
                        }
                    }
                }
                // Add some extra random edges
                for (let i = 0; i < numNodes * 0.5; i++) {
                    const a = Math.floor(Math.random() * numNodes);
                    const b = Math.floor(Math.random() * numNodes);
                    if (a !== b && !edgeExists(a, b)) {
                        edges.push([a, b]);
                        nodes[a].degree++;
                        nodes[b].degree++;
                    }
                }
            }

            selectedNode = null;
            calculateStats();
            draw();
        }

        function edgeExists(a, b) {
            return edges.some(e => (e[0] === a && e[1] === b) || (e[0] === b && e[1] === a));
        }

        function getNeighbors(nodeId) {
            const neighbors = [];
            edges.forEach(e => {
                if (e[0] === nodeId) neighbors.push(e[1]);
                if (e[1] === nodeId) neighbors.push(e[0]);
            });
            return neighbors;
        }

        function calculateStats() {
            const n = nodes.length;
            const totalDegree = nodes.reduce((s, node) => s + node.degree, 0);
            const avgDegree = totalDegree / n;

            // Calculate average friends-of-friends for each node
            let paradoxCount = 0;
            let totalFoF = 0;

            nodes.forEach(node => {
                const neighbors = getNeighbors(node.id);
                if (neighbors.length > 0) {
                    const friendsDegreeSum = neighbors.reduce((s, nId) => s + nodes[nId].degree, 0);
                    node.avgFriendsDegree = friendsDegreeSum / neighbors.length;
                    totalFoF += node.avgFriendsDegree;
                    if (node.degree < node.avgFriendsDegree) {
                        paradoxCount++;
                    }
                } else {
                    node.avgFriendsDegree = 0;
                }
            });

            document.getElementById('total-nodes').textContent = n;
            document.getElementById('total-edges').textContent = edges.length;
            document.getElementById('avg-degree').textContent = avgDegree.toFixed(1);
            document.getElementById('avg-fof').textContent = (totalFoF / n).toFixed(1);
            document.getElementById('paradox-pct').textContent = ((paradoxCount / n) * 100).toFixed(0) + '%';
        }

        function draw() {
            const rect = canvas.getBoundingClientRect();
            ctx.clearRect(0, 0, rect.width, rect.height);

            const neighbors = selectedNode !== null ? getNeighbors(selectedNode) : [];

            // Draw edges
            edges.forEach(([a, b]) => {
                const nodeA = nodes[a];
                const nodeB = nodes[b];
                ctx.beginPath();
                ctx.moveTo(nodeA.x, nodeA.y);
                ctx.lineTo(nodeB.x, nodeB.y);

                if (selectedNode !== null && (a === selectedNode || b === selectedNode)) {
                    ctx.strokeStyle = 'rgba(231, 76, 60, 0.8)';
                    ctx.lineWidth = 2;
                } else {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                    ctx.lineWidth = 1;
                }
                ctx.stroke();
            });

            // Draw nodes
            nodes.forEach(node => {
                const radius = 8 + node.degree * 1.5;
                ctx.beginPath();
                ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);

                if (node.id === selectedNode) {
                    ctx.fillStyle = '#2ecc71';
                } else if (neighbors.includes(node.id)) {
                    ctx.fillStyle = '#e74c3c';
                } else if (node.id === hoveredNode) {
                    ctx.fillStyle = '#f1c40f';
                } else {
                    ctx.fillStyle = '#3498db';
                }
                ctx.fill();

                // Draw degree number
                ctx.fillStyle = 'white';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.degree, node.x, node.y);
            });
        }

        function getNodeAt(x, y) {
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                const radius = 8 + node.degree * 1.5;
                const dx = x - node.x;
                const dy = y - node.y;
                if (dx * dx + dy * dy <= radius * radius) {
                    return i;
                }
            }
            return null;
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const nodeId = getNodeAt(x, y);

            if (nodeId !== null) {
                selectedNode = nodeId;
                const node = nodes[nodeId];
                const neighbors = getNeighbors(nodeId);

                document.getElementById('selected-info').style.display = 'block';
                document.getElementById('selected-name').textContent = node.name;
                document.getElementById('selected-friends').textContent = node.degree;
                document.getElementById('selected-fof').textContent = node.avgFriendsDegree.toFixed(1);

                const hasParadox = node.degree < node.avgFriendsDegree;
                const paradoxEl = document.getElementById('selected-paradox');
                paradoxEl.textContent = hasParadox ? 'YES' : 'NO';
                paradoxEl.style.color = hasParadox ? '#e74c3c' : '#2ecc71';
            } else {
                selectedNode = null;
                document.getElementById('selected-info').style.display = 'none';
            }

            draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const nodeId = getNodeAt(x, y);

            if (nodeId !== hoveredNode) {
                hoveredNode = nodeId;
                canvas.style.cursor = nodeId !== null ? 'pointer' : 'default';
                draw();
            }
        });

        window.addEventListener('resize', () => {
            resizeCanvas();
            draw();
        });

        // Initialize
        generateNetwork();
    </script>
</body>
</html>
