<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Café Wall Illusion - Parallel Lines That Look Slanted</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            color: #e94560;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.2em;
            color: #a0a0a0;
            font-style: italic;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #e94560;
            text-decoration: none;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 100;
            background: rgba(26, 26, 46, 0.9);
            padding: 8px 15px;
            border-radius: 20px;
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(233, 69, 96, 0.2);
            transform: translateX(-3px);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel h2 {
            color: #e94560;
            margin-bottom: 20px;
            font-size: 1.4em;
        }

        .canvas-container {
            text-align: center;
            margin-bottom: 20px;
        }

        canvas {
            border-radius: 10px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            color: #a0a0a0;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #e94560;
            cursor: pointer;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .btn-primary {
            background: linear-gradient(135deg, #e94560, #0f3460);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(233, 69, 96, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .explanation {
            line-height: 1.8;
        }

        .explanation p {
            margin-bottom: 15px;
        }

        .highlight {
            color: #e94560;
            font-weight: bold;
        }

        .history-box {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 4px solid #e94560;
        }

        .history-box h3 {
            color: #e94560;
            margin-bottom: 10px;
        }

        .instruction-box {
            background: rgba(233, 69, 96, 0.15);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            border: 1px solid rgba(233, 69, 96, 0.3);
        }

        .variant-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 15px;
        }

        .theory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .theory-card {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 10px;
        }

        .theory-card h3 {
            color: #4ecdc4;
            margin-bottom: 10px;
        }

        .reveal-text {
            margin-top: 15px;
            padding: 15px;
            background: rgba(233, 69, 96, 0.2);
            border-radius: 10px;
            border: 1px solid #e94560;
            font-weight: bold;
            display: none;
        }

        .reveal-text.visible {
            display: block;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">
        <span>←</span> Back to Paradoxes
    </a>

    <div class="container">
        <header>
            <h1>The Café Wall Illusion</h1>
            <p class="subtitle">Perfectly parallel lines that appear to converge and diverge</p>
        </header>

        <div class="main-content">
            <!-- Classic Café Wall -->
            <div class="panel">
                <h2>The Original Café Wall</h2>
                <div class="instruction-box">
                    <strong>Look at the horizontal lines:</strong> They appear to SLOPE alternately
                    left and right—but they're perfectly PARALLEL! Use a straightedge to verify.
                </div>
                <div class="canvas-container">
                    <canvas id="classicCanvas" width="420" height="320"></canvas>
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn btn-primary" onclick="toggleGuides('classic')">Show Guide Lines</button>
                </div>
                <div id="classicReveal" class="reveal-text"></div>
            </div>

            <!-- Adjustable Version -->
            <div class="panel">
                <h2>Customize the Wall</h2>
                <div class="canvas-container">
                    <canvas id="customCanvas" width="420" height="320"></canvas>
                </div>
                <div class="controls">
                    <div class="control-group">
                        <label>Tile Offset: <span id="offsetValue">50%</span></label>
                        <input type="range" id="offsetSlider" min="0" max="100" value="50" oninput="updateCustom()">
                    </div>
                    <div class="control-group">
                        <label>Mortar (line) Width: <span id="mortarValue">3px</span></label>
                        <input type="range" id="mortarSlider" min="1" max="10" value="3" oninput="updateCustom()">
                    </div>
                    <div class="control-group">
                        <label>Tile Height: <span id="tileHeightValue">30px</span></label>
                        <input type="range" id="tileHeightSlider" min="15" max="50" value="30" oninput="updateCustom()">
                    </div>
                </div>
                <p style="margin-top: 15px; color: #a0a0a0; font-size: 0.9em;">
                    At 0% or 100% offset (tiles aligned), the illusion VANISHES! The mortar color is crucial too.
                </p>
            </div>

            <!-- Mortar Color -->
            <div class="panel">
                <h2>The Crucial Mortar Color</h2>
                <div class="canvas-container">
                    <canvas id="mortarCanvas" width="420" height="320"></canvas>
                </div>
                <div class="variant-buttons">
                    <button class="btn btn-secondary" onclick="setMortarColor('#808080')">Grey (Strong)</button>
                    <button class="btn btn-secondary" onclick="setMortarColor('#ffffff')">White (Weak)</button>
                    <button class="btn btn-secondary" onclick="setMortarColor('#000000')">Black (Weak)</button>
                    <button class="btn btn-secondary" onclick="setMortarColor('#c0c0c0')">Light Grey</button>
                </div>
                <p style="text-align: center; color: #a0a0a0; font-size: 0.9em;">
                    The illusion is STRONGEST when mortar is MID-GREY (between black and white tiles)!
                </p>
            </div>

            <!-- Breaking the Illusion -->
            <div class="panel">
                <h2>Breaking the Illusion</h2>
                <div class="canvas-container">
                    <canvas id="breakCanvas" width="420" height="320"></canvas>
                </div>
                <div class="variant-buttons">
                    <button class="btn btn-secondary" onclick="setBreakMode('normal')">Normal</button>
                    <button class="btn btn-secondary" onclick="setBreakMode('aligned')">Aligned (0% offset)</button>
                    <button class="btn btn-secondary" onclick="setBreakMode('thick')">Thick Mortar</button>
                    <button class="btn btn-secondary" onclick="setBreakMode('colored')">Colored Tiles</button>
                </div>
                <p style="text-align: center; color: #a0a0a0; font-size: 0.9em;">
                    Aligning tiles, widening mortar, or using non-B&W colors reduces/eliminates the effect.
                </p>
            </div>

            <!-- Animated Version -->
            <div class="panel">
                <h2>Animated Café Wall</h2>
                <div class="canvas-container">
                    <canvas id="animateCanvas" width="420" height="320"></canvas>
                </div>
                <div class="variant-buttons">
                    <button class="btn btn-primary" id="animateBtn" onclick="toggleAnimation()">Start Animation</button>
                    <button class="btn btn-secondary" onclick="resetAnimation()">Reset</button>
                </div>
                <p style="text-align: center; color: #a0a0a0; font-size: 0.9em;">
                    Watch the tiles shift—the apparent slope REVERSES as offset changes!
                </p>
            </div>

            <!-- Inverted Version -->
            <div class="panel">
                <h2>Inverted & Variations</h2>
                <div class="canvas-container">
                    <canvas id="variantCanvas" width="420" height="320"></canvas>
                </div>
                <div class="variant-buttons">
                    <button class="btn btn-secondary" onclick="setVariant('classic')">Classic</button>
                    <button class="btn btn-secondary" onclick="setVariant('inverted')">Inverted</button>
                    <button class="btn btn-secondary" onclick="setVariant('gradient')">Gradient</button>
                    <button class="btn btn-secondary" onclick="setVariant('triple')">Triple Row</button>
                </div>
            </div>

            <!-- Theory Section -->
            <div class="panel full-width">
                <h2>Why Does This Happen?</h2>
                <div class="theory-grid">
                    <div class="theory-card">
                        <h3>Border Contrast</h3>
                        <p>Where a dark tile meets the grey mortar, the mortar appears LIGHTER.
                        Where a white tile meets the mortar, it appears DARKER. This creates
                        apparent "wedge" shapes at tile borders.</p>
                    </div>
                    <div class="theory-card">
                        <h3>Irradiation</h3>
                        <p>Light areas appear to spread into adjacent dark areas (irradiation).
                        The white tiles "bleed" over the mortar line, while black tiles
                        appear to recede—shifting the apparent mortar position.</p>
                    </div>
                    <div class="theory-card">
                        <h3>Shifted Borders</h3>
                        <p>The mortar line between a black tile (above) and white tile (below)
                        appears to shift DOWN toward the white. The opposite occurs for
                        white-above-black. This creates alternating "tilts."</p>
                    </div>
                    <div class="theory-card">
                        <h3>Why Grey Mortar?</h3>
                        <p>Grey mortar maximizes the contrast difference with BOTH black and
                        white tiles. White or black mortar has high contrast with only ONE
                        tile color—reducing the differential shift effect.</p>
                    </div>
                </div>
            </div>

            <!-- Measurement Tool -->
            <div class="panel full-width">
                <h2>Prove It's Parallel</h2>
                <div style="display: flex; gap: 30px; flex-wrap: wrap; justify-content: center; align-items: start;">
                    <div class="canvas-container">
                        <canvas id="measureCanvas" width="500" height="350"></canvas>
                    </div>
                    <div style="max-width: 400px;">
                        <p style="margin-bottom: 15px;">
                            <strong>Click any two points</strong> on a horizontal mortar line to measure its angle.
                            Despite appearances, every line is at exactly <span class="highlight">0°</span>!
                        </p>
                        <div id="measureResult" style="margin-top: 15px; padding: 15px; background: rgba(78, 205, 196, 0.2); border-radius: 10px;">
                            <strong>Click two points to measure...</strong>
                        </div>
                        <button class="btn btn-secondary" style="margin-top: 15px;" onclick="resetMeasure()">Clear Measurements</button>
                    </div>
                </div>
            </div>

            <!-- Explanation -->
            <div class="panel full-width explanation">
                <h2>The Café Wall in Bristol</h2>
                <p>
                    The <span class="highlight">Café Wall Illusion</span> was first noticed on the
                    tiled wall of a café in St Michael's Hill, Bristol, UK in the 1970s. A member
                    of Richard Gregory's lab at the University of Bristol spotted it and brought
                    it to the attention of researchers.
                </p>
                <p>
                    The illusion was formally described by <span class="highlight">Richard Gregory
                    and Priscilla Heard in 1979</span>. It's a stunning example of how edge
                    detection and contrast processing in our visual system can create systematic
                    errors in geometric perception.
                </p>
                <p>
                    Unlike many illusions that rely on context or size comparisons, the Café Wall
                    is purely about <span class="highlight">local edge interactions</span>. The
                    mortar lines ARE parallel—there's no ambiguous depth information or comparison
                    trickery. Your early visual processing simply misinterprets where the edges are.
                </p>

                <div class="history-box">
                    <h3>Real-World Impact</h3>
                    <p>
                        Interior designers and architects must be aware of the Café Wall effect
                        when choosing tile patterns. Bathroom floors, kitchen backsplashes, and
                        building facades can unintentionally create disturbing "wavy" appearances
                        if the offset and mortar color aren't carefully chosen. Some designers
                        deliberately exploit the effect for artistic purposes!
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========== CLASSIC CAFÉ WALL ==========
        const classicCanvas = document.getElementById('classicCanvas');
        const classicCtx = classicCanvas.getContext('2d');
        let showClassicGuides = false;

        function drawCafeWall(ctx, width, height, offset = 0.5, mortarWidth = 3, tileHeight = 30, mortarColor = '#808080', showGuides = false) {
            const tileWidth = 50;
            const rows = Math.floor(height / (tileHeight + mortarWidth));

            // Background (mortar color)
            ctx.fillStyle = mortarColor;
            ctx.fillRect(0, 0, width, height);

            // Draw tiles
            for (let row = 0; row < rows; row++) {
                const y = row * (tileHeight + mortarWidth) + mortarWidth / 2;
                const rowOffset = (row % 2) * tileWidth * offset;

                for (let col = -1; col < Math.ceil(width / tileWidth) + 1; col++) {
                    const x = col * tileWidth + rowOffset;
                    ctx.fillStyle = (col % 2 === 0) ? '#000000' : '#ffffff';
                    ctx.fillRect(x, y, tileWidth, tileHeight);
                }
            }

            // Draw guide lines if enabled
            if (showGuides) {
                ctx.strokeStyle = '#e94560';
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 5]);

                for (let row = 0; row <= rows; row++) {
                    const y = row * (tileHeight + mortarWidth);
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }

                ctx.setLineDash([]);
            }
        }

        function toggleGuides(canvasType) {
            if (canvasType === 'classic') {
                showClassicGuides = !showClassicGuides;
                drawCafeWall(classicCtx, classicCanvas.width, classicCanvas.height, 0.5, 3, 30, '#808080', showClassicGuides);

                const reveal = document.getElementById('classicReveal');
                if (showClassicGuides) {
                    reveal.innerHTML = '<strong>RED LINES ARE PERFECTLY HORIZONTAL!</strong> The tiles create an illusion of slope, but every mortar line is straight and parallel.';
                    reveal.classList.add('visible');
                } else {
                    reveal.classList.remove('visible');
                }
            }
        }

        // ========== CUSTOM CAFÉ WALL ==========
        const customCanvas = document.getElementById('customCanvas');
        const customCtx = customCanvas.getContext('2d');

        function updateCustom() {
            const offset = parseInt(document.getElementById('offsetSlider').value) / 100;
            const mortarWidth = parseInt(document.getElementById('mortarSlider').value);
            const tileHeight = parseInt(document.getElementById('tileHeightSlider').value);

            document.getElementById('offsetValue').textContent = Math.round(offset * 100) + '%';
            document.getElementById('mortarValue').textContent = mortarWidth + 'px';
            document.getElementById('tileHeightValue').textContent = tileHeight + 'px';

            drawCafeWall(customCtx, customCanvas.width, customCanvas.height, offset, mortarWidth, tileHeight);
        }

        // ========== MORTAR COLOR ==========
        const mortarCanvas = document.getElementById('mortarCanvas');
        const mortarCtx = mortarCanvas.getContext('2d');
        let currentMortarColor = '#808080';

        function setMortarColor(color) {
            currentMortarColor = color;
            drawCafeWall(mortarCtx, mortarCanvas.width, mortarCanvas.height, 0.5, 3, 30, currentMortarColor);
        }

        // ========== BREAK MODE ==========
        const breakCanvas = document.getElementById('breakCanvas');
        const breakCtx = breakCanvas.getContext('2d');

        function setBreakMode(mode) {
            const width = breakCanvas.width;
            const height = breakCanvas.height;

            if (mode === 'normal') {
                drawCafeWall(breakCtx, width, height, 0.5, 3, 30);
            } else if (mode === 'aligned') {
                drawCafeWall(breakCtx, width, height, 0, 3, 30);
            } else if (mode === 'thick') {
                drawCafeWall(breakCtx, width, height, 0.5, 15, 30);
            } else if (mode === 'colored') {
                // Custom colored version
                const tileWidth = 50;
                const tileHeight = 30;
                const mortarWidth = 3;
                const rows = Math.floor(height / (tileHeight + mortarWidth));

                breakCtx.fillStyle = '#808080';
                breakCtx.fillRect(0, 0, width, height);

                for (let row = 0; row < rows; row++) {
                    const y = row * (tileHeight + mortarWidth) + mortarWidth / 2;
                    const rowOffset = (row % 2) * tileWidth * 0.5;

                    for (let col = -1; col < Math.ceil(width / tileWidth) + 1; col++) {
                        const x = col * tileWidth + rowOffset;
                        // Use colors instead of B&W
                        breakCtx.fillStyle = (col % 2 === 0) ? '#3498db' : '#e74c3c';
                        breakCtx.fillRect(x, y, tileWidth, tileHeight);
                    }
                }
            }
        }

        // ========== ANIMATION ==========
        const animateCanvas = document.getElementById('animateCanvas');
        const animateCtx = animateCanvas.getContext('2d');
        let isAnimating = false;
        let animFrame;
        let animOffset = 0;

        function animateCafeWall(time) {
            animOffset = (Math.sin(time * 0.002) + 1) / 2; // Oscillates 0 to 1
            drawCafeWall(animateCtx, animateCanvas.width, animateCanvas.height, animOffset, 3, 30);

            // Show current offset
            animateCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            animateCtx.fillRect(10, 10, 120, 30);
            animateCtx.fillStyle = '#4ecdc4';
            animateCtx.font = '14px Georgia';
            animateCtx.fillText(`Offset: ${Math.round(animOffset * 100)}%`, 20, 30);

            if (isAnimating) {
                animFrame = requestAnimationFrame(animateCafeWall);
            }
        }

        function toggleAnimation() {
            isAnimating = !isAnimating;
            document.getElementById('animateBtn').textContent = isAnimating ? 'Stop Animation' : 'Start Animation';

            if (isAnimating) {
                animFrame = requestAnimationFrame(animateCafeWall);
            } else {
                cancelAnimationFrame(animFrame);
            }
        }

        function resetAnimation() {
            isAnimating = false;
            cancelAnimationFrame(animFrame);
            document.getElementById('animateBtn').textContent = 'Start Animation';
            drawCafeWall(animateCtx, animateCanvas.width, animateCanvas.height, 0.5, 3, 30);
        }

        // ========== VARIANTS ==========
        const variantCanvas = document.getElementById('variantCanvas');
        const variantCtx = variantCanvas.getContext('2d');

        function setVariant(variant) {
            const width = variantCanvas.width;
            const height = variantCanvas.height;

            if (variant === 'classic') {
                drawCafeWall(variantCtx, width, height, 0.5, 3, 30);
            } else if (variant === 'inverted') {
                // Inverted colors
                const tileWidth = 50;
                const tileHeight = 30;
                const mortarWidth = 3;
                const rows = Math.floor(height / (tileHeight + mortarWidth));

                variantCtx.fillStyle = '#808080';
                variantCtx.fillRect(0, 0, width, height);

                for (let row = 0; row < rows; row++) {
                    const y = row * (tileHeight + mortarWidth) + mortarWidth / 2;
                    const rowOffset = (row % 2) * tileWidth * 0.5;

                    for (let col = -1; col < Math.ceil(width / tileWidth) + 1; col++) {
                        const x = col * tileWidth + rowOffset;
                        // Swap black and white
                        variantCtx.fillStyle = (col % 2 === 0) ? '#ffffff' : '#000000';
                        variantCtx.fillRect(x, y, tileWidth, tileHeight);
                    }
                }
            } else if (variant === 'gradient') {
                // Gradient tiles
                const tileWidth = 50;
                const tileHeight = 30;
                const mortarWidth = 3;
                const rows = Math.floor(height / (tileHeight + mortarWidth));

                variantCtx.fillStyle = '#808080';
                variantCtx.fillRect(0, 0, width, height);

                for (let row = 0; row < rows; row++) {
                    const y = row * (tileHeight + mortarWidth) + mortarWidth / 2;
                    const rowOffset = (row % 2) * tileWidth * 0.5;

                    for (let col = -1; col < Math.ceil(width / tileWidth) + 1; col++) {
                        const x = col * tileWidth + rowOffset;
                        const gradient = variantCtx.createLinearGradient(x, y, x + tileWidth, y);

                        if (col % 2 === 0) {
                            gradient.addColorStop(0, '#000000');
                            gradient.addColorStop(1, '#404040');
                        } else {
                            gradient.addColorStop(0, '#c0c0c0');
                            gradient.addColorStop(1, '#ffffff');
                        }

                        variantCtx.fillStyle = gradient;
                        variantCtx.fillRect(x, y, tileWidth, tileHeight);
                    }
                }
            } else if (variant === 'triple') {
                // Three rows offset pattern
                const tileWidth = 40;
                const tileHeight = 25;
                const mortarWidth = 3;
                const rows = Math.floor(height / (tileHeight + mortarWidth));

                variantCtx.fillStyle = '#808080';
                variantCtx.fillRect(0, 0, width, height);

                for (let row = 0; row < rows; row++) {
                    const y = row * (tileHeight + mortarWidth) + mortarWidth / 2;
                    const rowOffset = (row % 3) * tileWidth * 0.33;

                    for (let col = -1; col < Math.ceil(width / tileWidth) + 1; col++) {
                        const x = col * tileWidth + rowOffset;
                        variantCtx.fillStyle = (col % 2 === 0) ? '#000000' : '#ffffff';
                        variantCtx.fillRect(x, y, tileWidth, tileHeight);
                    }
                }
            }
        }

        // ========== MEASUREMENT TOOL ==========
        const measureCanvas = document.getElementById('measureCanvas');
        const measureCtx = measureCanvas.getContext('2d');
        let measurePoints = [];

        function drawMeasureCanvas() {
            drawCafeWall(measureCtx, measureCanvas.width, measureCanvas.height, 0.5, 3, 30);

            // Draw measurement points
            measureCtx.fillStyle = '#e94560';
            measurePoints.forEach(point => {
                measureCtx.beginPath();
                measureCtx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                measureCtx.fill();
            });

            // Draw line between points
            if (measurePoints.length === 2) {
                measureCtx.strokeStyle = '#e94560';
                measureCtx.lineWidth = 2;
                measureCtx.beginPath();
                measureCtx.moveTo(measurePoints[0].x, measurePoints[0].y);
                measureCtx.lineTo(measurePoints[1].x, measurePoints[1].y);
                measureCtx.stroke();

                // Calculate angle
                const dx = measurePoints[1].x - measurePoints[0].x;
                const dy = measurePoints[1].y - measurePoints[0].y;
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;

                document.getElementById('measureResult').innerHTML =
                    `<strong>Measured angle: ${angle.toFixed(2)}°</strong><br>` +
                    (Math.abs(angle) < 1 ?
                        '<span style="color: #4ecdc4;">The line IS horizontal! The tilt you see is an illusion.</span>' :
                        '<span style="color: #a0a0a0;">Tip: Click on the mortar lines for best results.</span>');
            }
        }

        measureCanvas.addEventListener('click', (e) => {
            const rect = measureCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (measurePoints.length >= 2) {
                measurePoints = [];
            }

            measurePoints.push({ x, y });
            drawMeasureCanvas();
        });

        function resetMeasure() {
            measurePoints = [];
            document.getElementById('measureResult').innerHTML = '<strong>Click two points to measure...</strong>';
            drawMeasureCanvas();
        }

        // Initialize all canvases
        drawCafeWall(classicCtx, classicCanvas.width, classicCanvas.height);
        updateCustom();
        drawCafeWall(mortarCtx, mortarCanvas.width, mortarCanvas.height);
        setBreakMode('normal');
        drawCafeWall(animateCtx, animateCanvas.width, animateCanvas.height);
        setVariant('classic');
        drawMeasureCanvas();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
