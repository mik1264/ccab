<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Coastline Paradox - Surprising Paradoxes #122</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Nunito:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --ocean: #1a5f7a;
            --sand: #deb887;
            --land: #228b22;
            --ruler: #ff6b35;
            --cream: #FEFAE0;
            --dark: #2c3e50;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(180deg, var(--ocean) 0%, #0d3d4d 100%);
            min-height: 100vh;
            color: var(--cream);
            overflow-x: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: var(--cream);
            text-decoration: none;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 100;
            background: rgba(0,0,0,0.3);
            padding: 8px 16px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(0,0,0,0.5);
            transform: translateX(-3px);
        }

        header {
            text-align: center;
            padding: 60px 20px 30px;
        }

        h1 {
            font-family: 'Lora', serif;
            font-size: clamp(2rem, 5vw, 3rem);
            margin-bottom: 10px;
            color: var(--sand);
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            max-width: 700px;
            margin: 0 auto;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .demo-area {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
            margin-bottom: 40px;
        }

        @media (max-width: 900px) {
            .demo-area {
                grid-template-columns: 1fr;
            }
        }

        .canvas-container {
            background: rgba(0,0,0,0.3);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        canvas {
            width: 100%;
            border-radius: 12px;
            background: linear-gradient(180deg, #87ceeb 0%, var(--ocean) 100%);
        }

        .controls-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .control-value {
            color: var(--sand);
            font-family: 'Courier New', monospace;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--ruler);
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .stat-box {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.85rem;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--sand);
            font-family: 'Courier New', monospace;
        }

        .trend-indicator {
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .trend-up { color: #4ade80; }
        .trend-same { color: #fbbf24; }

        .coastline-select {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .coast-btn {
            flex: 1;
            min-width: 100px;
            padding: 12px;
            border: 2px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.1);
            color: var(--cream);
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Nunito', sans-serif;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .coast-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .coast-btn.active {
            background: var(--ruler);
            border-color: var(--ruler);
        }

        .info-section {
            background: rgba(0,0,0,0.3);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            margin-bottom: 30px;
        }

        .info-section h2 {
            font-family: 'Lora', serif;
            color: var(--sand);
            margin-bottom: 15px;
        }

        .info-section p {
            line-height: 1.8;
            margin-bottom: 15px;
        }

        .quote-box {
            border-left: 4px solid var(--ruler);
            padding-left: 20px;
            margin: 20px 0;
            font-style: italic;
            opacity: 0.9;
        }

        .graph-container {
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }

        #lengthGraph {
            width: 100%;
            height: 200px;
        }

        .formula-box {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            margin: 20px 0;
        }

        .examples-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .example-card {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 12px;
        }

        .example-card h4 {
            color: var(--sand);
            margin-bottom: 10px;
        }

        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .legend-color {
            width: 20px;
            height: 4px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <header>
        <h1>The Coastline Paradox #122</h1>
        <p class="subtitle">The smaller your ruler, the longer the coastline becomes‚Äîapproaching INFINITY!</p>
    </header>

    <div class="container">
        <div class="demo-area">
            <div class="canvas-container">
                <canvas id="coastCanvas" width="800" height="600"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: var(--land);"></div>
                        <span>Land</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: var(--ruler); height: 6px;"></div>
                        <span>Measuring Segments</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: rgba(255,255,255,0.5);"></div>
                        <span>True Coastline</span>
                    </div>
                </div>
            </div>

            <div class="controls-panel">
                <h3 style="margin-bottom: 20px; color: var(--sand);">Measurement Controls</h3>

                <div class="coastline-select">
                    <button class="coast-btn active" data-coast="britain">Britain</button>
                    <button class="coast-btn" data-coast="norway">Norway</button>
                    <button class="coast-btn" data-coast="simple">Simple</button>
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Ruler Length</span>
                        <span class="control-value" id="rulerValue">50 km</span>
                    </div>
                    <input type="range" id="rulerSlider" min="5" max="100" value="50">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Fractal Detail</span>
                        <span class="control-value" id="detailValue">3</span>
                    </div>
                    <input type="range" id="detailSlider" min="1" max="6" value="3">
                </div>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-label">Ruler Length</div>
                        <div class="stat-value" id="currentRuler">50 km</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Segments Used</div>
                        <div class="stat-value" id="segmentCount">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Measured Length</div>
                        <div class="stat-value" id="measuredLength">0 km</div>
                        <div class="trend-indicator trend-up" id="trend">‚Üë Longer!</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Fractal Dimension</div>
                        <div class="stat-value" id="fractalDim">~1.25</div>
                    </div>
                </div>

                <div class="graph-container">
                    <canvas id="lengthGraph"></canvas>
                </div>
            </div>
        </div>

        <div class="info-section">
            <h2>Why Does This Happen?</h2>
            <p>In 1967, mathematician Benoit Mandelbrot asked: "How long is the coast of Britain?" The answer, paradoxically, is that <strong>it depends on how you measure it</strong>‚Äîand theoretically approaches infinity!</p>

            <div class="quote-box">
                "The length of a coastline is not a well-defined quantity. It depends on the scale of measurement... As the scale decreases, the total length increases without limit."
                <br>‚Äî Lewis Fry Richardson
            </div>

            <p>When you use a 100km ruler, you skip over bays and peninsulas. Use a 50km ruler, and you catch more detail. Use a 1km ruler, and every inlet adds to the length. Use a 1m ruler, and every rock counts. There's no "true" length!</p>

            <div class="formula-box">
                L(Œµ) = F ¬∑ Œµ<sup>(1-D)</sup>
                <br><small style="opacity: 0.7;">where D is the fractal dimension (between 1 and 2)</small>
            </div>
        </div>

        <div class="info-section">
            <h2>Real-World Examples</h2>
            <div class="examples-grid">
                <div class="example-card">
                    <h4>üá¨üáß Britain's Coast</h4>
                    <p>100km ruler: ~2,800 km<br>
                    50km ruler: ~3,500 km<br>
                    1km ruler: ~8,000+ km</p>
                    <p><strong>D ‚âà 1.25</strong></p>
                </div>
                <div class="example-card">
                    <h4>üá≥üá¥ Norway's Coast</h4>
                    <p>With its fjords, Norway has one of the most fractal coastlines on Earth!</p>
                    <p><strong>D ‚âà 1.52</strong></p>
                </div>
                <div class="example-card">
                    <h4>üáøüá¶ South Africa</h4>
                    <p>A relatively smooth coastline with fewer inlets.</p>
                    <p><strong>D ‚âà 1.02</strong></p>
                </div>
                <div class="example-card">
                    <h4>üó∫Ô∏è Spain-Portugal Border</h4>
                    <p>Portugal says: 987 km<br>
                    Spain says: 1,214 km<br>
                    Different rulers!</p>
                </div>
            </div>
        </div>

        <div class="info-section">
            <h2>Historical Context</h2>
            <p>Lewis Fry Richardson first noticed this paradox in the 1950s while studying whether border length affects war probability. He found that Spain and Portugal reported completely different lengths for their shared border!</p>
            <p>Mandelbrot later connected this to fractal geometry, showing that coastlines have a "fractional dimension" between 1 (a line) and 2 (a plane). The more jagged the coast, the higher the dimension.</p>
            <p>This has profound implications: <strong>many natural boundaries simply don't have a definite length</strong>. It's not measurement error‚Äîit's a fundamental property of fractals!</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('coastCanvas');
        const ctx = canvas.getContext('2d');
        const graphCanvas = document.getElementById('lengthGraph');
        const graphCtx = graphCanvas.getContext('2d');

        // High-DPI support
        function setupCanvas(c, w, h) {
            const dpr = window.devicePixelRatio || 1;
            c.width = w * dpr;
            c.height = h * dpr;
            c.style.width = w + 'px';
            c.style.height = h + 'px';
            c.getContext('2d').scale(dpr, dpr);
        }

        const coastlineTypes = {
            britain: { name: 'Britain', dimension: 1.25, complexity: 0.35 },
            norway: { name: 'Norway', dimension: 1.52, complexity: 0.5 },
            simple: { name: 'Simple', dimension: 1.05, complexity: 0.15 }
        };

        let currentCoast = 'britain';
        let rulerLength = 50;
        let detailLevel = 3;
        let coastlinePoints = [];
        let measurements = [];
        let previousLength = 0;

        // Generate fractal coastline using midpoint displacement
        function generateCoastline(complexity, iterations) {
            const width = 700;
            const height = 500;
            const margin = 80;

            // Start with basic peninsula shape
            let points = [
                { x: margin, y: height - margin },
                { x: width * 0.3, y: margin + 50 },
                { x: width * 0.5, y: margin },
                { x: width * 0.7, y: margin + 80 },
                { x: width - margin, y: height - margin }
            ];

            // Apply midpoint displacement
            for (let iter = 0; iter < iterations; iter++) {
                const newPoints = [points[0]];
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const mid = {
                        x: (p1.x + p2.x) / 2,
                        y: (p1.y + p2.y) / 2
                    };

                    // Displace perpendicular to segment
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const displacement = (Math.random() - 0.5) * len * complexity;

                    mid.x += (-dy / len) * displacement;
                    mid.y += (dx / len) * displacement;

                    // Keep within bounds
                    mid.x = Math.max(margin/2, Math.min(width - margin/2, mid.x));
                    mid.y = Math.max(margin/2, Math.min(height - margin/2, mid.y));

                    newPoints.push(mid);
                    newPoints.push(p2);
                }
                points = newPoints;
            }

            return points;
        }

        // Measure coastline with given ruler length
        function measureCoastline(points, rulerLen) {
            const segments = [];
            let totalLength = 0;
            let currentPoint = points[0];
            let i = 1;

            while (i < points.length) {
                // Find point approximately rulerLen away
                let accumulated = 0;
                let targetPoint = null;

                for (let j = i; j < points.length; j++) {
                    const dx = points[j].x - currentPoint.x;
                    const dy = points[j].y - currentPoint.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist >= rulerLen || j === points.length - 1) {
                        targetPoint = points[j];
                        i = j + 1;
                        break;
                    }
                }

                if (targetPoint) {
                    const dx = targetPoint.x - currentPoint.x;
                    const dy = targetPoint.y - currentPoint.y;
                    const segLen = Math.sqrt(dx * dx + dy * dy);

                    segments.push({
                        start: { ...currentPoint },
                        end: { ...targetPoint },
                        length: segLen
                    });

                    totalLength += segLen;
                    currentPoint = targetPoint;
                }
            }

            return { segments, totalLength };
        }

        // Calculate actual coastline length (sum of all tiny segments)
        function getActualLength(points) {
            let total = 0;
            for (let i = 1; i < points.length; i++) {
                const dx = points[i].x - points[i-1].x;
                const dy = points[i].y - points[i-1].y;
                total += Math.sqrt(dx * dx + dy * dy);
            }
            return total;
        }

        function draw() {
            const width = 800;
            const height = 600;
            ctx.clearRect(0, 0, width, height);

            // Draw ocean background
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#87ceeb');
            gradient.addColorStop(1, '#1a5f7a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Draw land mass
            ctx.beginPath();
            ctx.moveTo(0, height);
            ctx.lineTo(coastlinePoints[0].x, coastlinePoints[0].y);
            for (let i = 1; i < coastlinePoints.length; i++) {
                ctx.lineTo(coastlinePoints[i].x, coastlinePoints[i].y);
            }
            ctx.lineTo(width, height);
            ctx.closePath();

            const landGradient = ctx.createLinearGradient(0, 0, 0, height);
            landGradient.addColorStop(0, '#228b22');
            landGradient.addColorStop(0.5, '#2e7d32');
            landGradient.addColorStop(1, '#1b5e20');
            ctx.fillStyle = landGradient;
            ctx.fill();

            // Draw true coastline (thin white line)
            ctx.beginPath();
            ctx.moveTo(coastlinePoints[0].x, coastlinePoints[0].y);
            for (let i = 1; i < coastlinePoints.length; i++) {
                ctx.lineTo(coastlinePoints[i].x, coastlinePoints[i].y);
            }
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Measure with current ruler
            const measurement = measureCoastline(coastlinePoints, rulerLength * 2);

            // Draw measurement segments
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#ff6b35';
            ctx.lineCap = 'round';

            measurement.segments.forEach((seg, i) => {
                ctx.beginPath();
                ctx.moveTo(seg.start.x, seg.start.y);
                ctx.lineTo(seg.end.x, seg.end.y);
                ctx.stroke();

                // Draw ruler endpoint markers
                ctx.beginPath();
                ctx.arc(seg.start.x, seg.start.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#ff6b35';
                ctx.fill();
            });

            // Draw last point
            const lastSeg = measurement.segments[measurement.segments.length - 1];
            if (lastSeg) {
                ctx.beginPath();
                ctx.arc(lastSeg.end.x, lastSeg.end.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Update stats
            const scaleFactor = 10; // Pixels to km
            const measuredKm = Math.round(measurement.totalLength / scaleFactor);

            document.getElementById('currentRuler').textContent = rulerLength + ' km';
            document.getElementById('segmentCount').textContent = measurement.segments.length;
            document.getElementById('measuredLength').textContent = measuredKm.toLocaleString() + ' km';
            document.getElementById('fractalDim').textContent = '~' + coastlineTypes[currentCoast].dimension.toFixed(2);

            // Update trend
            const trend = document.getElementById('trend');
            if (measuredKm > previousLength && previousLength > 0) {
                trend.textContent = '‚Üë +' + (measuredKm - previousLength) + ' km!';
                trend.className = 'trend-indicator trend-up';
            } else if (measuredKm < previousLength) {
                trend.textContent = '‚Üì Shorter';
                trend.className = 'trend-indicator trend-same';
            } else {
                trend.textContent = '‚Äî';
                trend.className = 'trend-indicator trend-same';
            }
            previousLength = measuredKm;

            // Record measurement for graph
            recordMeasurement(rulerLength, measuredKm);
            drawGraph();
        }

        function recordMeasurement(ruler, length) {
            // Keep unique ruler values
            const existing = measurements.findIndex(m => m.ruler === ruler);
            if (existing >= 0) {
                measurements[existing].length = length;
            } else {
                measurements.push({ ruler, length });
                measurements.sort((a, b) => b.ruler - a.ruler);
            }

            // Keep last 10
            if (measurements.length > 15) {
                measurements = measurements.slice(0, 15);
            }
        }

        function drawGraph() {
            const width = graphCanvas.parentElement.clientWidth - 40;
            const height = 180;
            setupCanvas(graphCanvas, width, height);

            graphCtx.clearRect(0, 0, width, height);

            if (measurements.length < 2) {
                graphCtx.fillStyle = 'rgba(255,255,255,0.5)';
                graphCtx.font = '14px Nunito';
                graphCtx.textAlign = 'center';
                graphCtx.fillText('Move the ruler slider to see the length graph', width/2, height/2);
                return;
            }

            const margin = { top: 20, right: 20, bottom: 30, left: 50 };
            const graphWidth = width - margin.left - margin.right;
            const graphHeight = height - margin.top - margin.bottom;

            // Scales
            const minRuler = Math.min(...measurements.map(m => m.ruler));
            const maxRuler = Math.max(...measurements.map(m => m.ruler));
            const minLength = Math.min(...measurements.map(m => m.length));
            const maxLength = Math.max(...measurements.map(m => m.length));

            const xScale = (r) => margin.left + ((maxRuler - r) / (maxRuler - minRuler)) * graphWidth;
            const yScale = (l) => margin.top + graphHeight - ((l - minLength) / (maxLength - minLength + 1)) * graphHeight;

            // Draw axes
            graphCtx.strokeStyle = 'rgba(255,255,255,0.3)';
            graphCtx.lineWidth = 1;
            graphCtx.beginPath();
            graphCtx.moveTo(margin.left, margin.top);
            graphCtx.lineTo(margin.left, height - margin.bottom);
            graphCtx.lineTo(width - margin.right, height - margin.bottom);
            graphCtx.stroke();

            // Draw line
            graphCtx.beginPath();
            graphCtx.strokeStyle = '#ff6b35';
            graphCtx.lineWidth = 2;

            const sorted = [...measurements].sort((a, b) => b.ruler - a.ruler);
            sorted.forEach((m, i) => {
                const x = xScale(m.ruler);
                const y = yScale(m.length);
                if (i === 0) graphCtx.moveTo(x, y);
                else graphCtx.lineTo(x, y);
            });
            graphCtx.stroke();

            // Draw points
            sorted.forEach(m => {
                const x = xScale(m.ruler);
                const y = yScale(m.length);
                graphCtx.beginPath();
                graphCtx.arc(x, y, 4, 0, Math.PI * 2);
                graphCtx.fillStyle = '#ff6b35';
                graphCtx.fill();
            });

            // Labels
            graphCtx.fillStyle = 'rgba(255,255,255,0.7)';
            graphCtx.font = '11px Nunito';
            graphCtx.textAlign = 'center';
            graphCtx.fillText('‚Üê Smaller Ruler', width/2, height - 5);
            graphCtx.save();
            graphCtx.translate(12, height/2);
            graphCtx.rotate(-Math.PI/2);
            graphCtx.fillText('Length ‚Üí', 0, 0);
            graphCtx.restore();
        }

        function regenerateCoastline() {
            const config = coastlineTypes[currentCoast];
            coastlinePoints = generateCoastline(config.complexity, detailLevel);
            measurements = [];
            previousLength = 0;
            draw();
        }

        // Event listeners
        document.getElementById('rulerSlider').addEventListener('input', (e) => {
            rulerLength = parseInt(e.target.value);
            document.getElementById('rulerValue').textContent = rulerLength + ' km';
            draw();
        });

        document.getElementById('detailSlider').addEventListener('input', (e) => {
            detailLevel = parseInt(e.target.value);
            document.getElementById('detailValue').textContent = detailLevel;
            regenerateCoastline();
        });

        document.querySelectorAll('.coast-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.coast-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentCoast = btn.dataset.coast;
                regenerateCoastline();
            });
        });

        // Initialize
        setupCanvas(canvas, 800, 600);
        regenerateCoastline();

        // Handle resize
        window.addEventListener('resize', () => {
            drawGraph();
        });
    </script>
</body>
</html>
