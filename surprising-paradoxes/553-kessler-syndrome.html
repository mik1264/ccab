<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kessler Syndrome - The Space Debris Cascade | Surprising Paradoxes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: radial-gradient(ellipse at center, #0a0a20 0%, #000010 100%);
            color: #e0e8ff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #5c6bc0;
            text-decoration: none;
            font-size: 14px;
            z-index: 1000;
            padding: 8px 16px;
            background: rgba(10, 10, 32, 0.9);
            border-radius: 20px;
            border: 1px solid rgba(92, 107, 192, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(92, 107, 192, 0.2);
            border-color: #5c6bc0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 80px 20px 40px;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(135deg, #ff5252, #ff8a80, #ffab91);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #9fa8da;
            font-size: 1.2em;
            font-style: italic;
        }

        .paradox-box {
            background: linear-gradient(135deg, rgba(255, 82, 82, 0.1), rgba(92, 107, 192, 0.1));
            border: 2px solid rgba(255, 82, 82, 0.4);
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
            text-align: center;
        }

        .paradox-box h3 {
            color: #ff8a80;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .paradox-box p {
            font-size: 1.15em;
            line-height: 1.7;
            color: #c5cae9;
        }

        .simulation-area {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 30px;
            margin: 40px 0;
        }

        @media (max-width: 1000px) {
            .simulation-area {
                grid-template-columns: 1fr;
            }
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(92, 107, 192, 0.2);
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            border-radius: 10px;
        }

        .warning-overlay {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 82, 82, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            display: none;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .controls {
            background: rgba(10, 10, 32, 0.8);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(92, 107, 192, 0.2);
        }

        .controls h3 {
            color: #5c6bc0;
            margin-bottom: 20px;
            font-size: 1.2em;
            border-bottom: 1px solid rgba(92, 107, 192, 0.3);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: #9fa8da;
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #1a237e, #3949ab, #5c6bc0);
            border-radius: 4px;
            outline: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #ff5252;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 82, 82, 0.5);
        }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .action-btn {
            padding: 12px;
            font-size: 0.9em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .action-btn.collision {
            background: linear-gradient(135deg, #ff5252, #ff1744);
            color: white;
        }

        .action-btn.reset {
            background: linear-gradient(135deg, #3949ab, #5c6bc0);
            color: white;
        }

        .action-btn.launch {
            background: linear-gradient(135deg, #00c853, #69f0ae);
            color: #1b5e20;
        }

        .action-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .stats-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(92, 107, 192, 0.1);
            font-size: 0.9em;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #7986cb;
        }

        .stat-value {
            font-weight: bold;
        }

        .stat-value.safe {
            color: #69f0ae;
        }

        .stat-value.warning {
            color: #ffab40;
        }

        .stat-value.critical {
            color: #ff5252;
        }

        .debris-meter {
            margin-top: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
        }

        .meter-label {
            font-size: 0.85em;
            color: #9fa8da;
            margin-bottom: 8px;
        }

        .meter-bar {
            height: 12px;
            background: #1a237e;
            border-radius: 6px;
            overflow: hidden;
        }

        .meter-fill {
            height: 100%;
            transition: width 0.3s ease, background 0.3s ease;
            border-radius: 6px;
        }

        .essay {
            background: rgba(10, 10, 32, 0.6);
            border-radius: 15px;
            padding: 40px;
            margin-top: 40px;
            line-height: 1.9;
        }

        .essay h2 {
            color: #5c6bc0;
            margin: 30px 0 20px;
            font-size: 1.5em;
        }

        .essay h2:first-child {
            margin-top: 0;
        }

        .essay p {
            margin-bottom: 20px;
            color: #c5cae9;
            text-align: justify;
        }

        .essay strong {
            color: #ff8a80;
        }

        .essay em {
            color: #b39ddb;
            font-style: italic;
        }

        .highlight-stat {
            display: inline-block;
            background: linear-gradient(135deg, rgba(255, 82, 82, 0.2), rgba(92, 107, 192, 0.2));
            padding: 2px 10px;
            border-radius: 4px;
            color: #ffab91;
            font-weight: bold;
        }

        .timeline-cards {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin: 30px 0;
        }

        @media (max-width: 900px) {
            .timeline-cards {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .timeline-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            border-left: 3px solid #5c6bc0;
        }

        .timeline-card .year {
            color: #ff8a80;
            font-weight: bold;
            font-size: 1.1em;
        }

        .timeline-card .event {
            color: #9fa8da;
            font-size: 0.85em;
            margin-top: 5px;
        }

        footer {
            text-align: center;
            padding: 40px 20px;
            color: #3949ab;
            font-size: 0.9em;
        }

        footer a {
            color: #5c6bc0;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>üõ∞Ô∏è Kessler Syndrome</h1>
            <p class="subtitle">When One Collision Dooms an Entire Orbit</p>
        </header>

        <div class="paradox-box">
            <h3>üí• The Cascade Paradox</h3>
            <p>
                Space is vast and empty‚Äîyet it can become <strong>permanently unusable</strong>.
                A single collision between satellites creates thousands of fragments. Each fragment
                can cause another collision, creating more fragments, in an unstoppable chain reaction.
                At <span class="highlight-stat">7-15 km/s</span>, even a 1-gram piece of debris hits
                with the energy of a 2-ton rhino at full charge. We may be approaching a
                <strong>point of no return</strong>.
            </p>
        </div>

        <div class="simulation-area">
            <div class="canvas-container">
                <canvas id="orbitCanvas"></canvas>
                <div class="warning-overlay" id="warningOverlay">‚ö†Ô∏è CASCADE IN PROGRESS</div>
            </div>

            <div class="controls">
                <h3>üéÆ Orbital Control</h3>

                <div class="control-group">
                    <label>Simulation Speed: <span id="speedValue">1</span>x</label>
                    <input type="range" id="speedSlider" min="0.5" max="5" step="0.5" value="1">
                </div>

                <div class="control-group">
                    <label>Initial Satellites: <span id="satValue">50</span></label>
                    <input type="range" id="satSlider" min="20" max="200" value="50">
                </div>

                <div class="control-group">
                    <label>Actions</label>
                    <div class="action-buttons">
                        <button class="action-btn collision" id="collisionBtn">üí• Trigger Collision</button>
                        <button class="action-btn launch" id="launchBtn">üöÄ Launch Satellite</button>
                        <button class="action-btn reset" id="resetBtn">üîÑ Reset Simulation</button>
                    </div>
                </div>

                <div class="stats-panel">
                    <div class="stat-row">
                        <span class="stat-label">Active Satellites</span>
                        <span class="stat-value safe" id="satCount">50</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Debris Pieces</span>
                        <span class="stat-value safe" id="debrisCount">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Collisions</span>
                        <span class="stat-value safe" id="collisionCount">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Orbit Status</span>
                        <span class="stat-value safe" id="orbitStatus">Safe</span>
                    </div>
                </div>

                <div class="debris-meter">
                    <div class="meter-label">Debris Density (Kessler Threshold)</div>
                    <div class="meter-bar">
                        <div class="meter-fill" id="debrisMeter" style="width: 0%; background: #69f0ae;"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="essay">
            <h2>A Prison of Our Own Making</h2>
            <p>
                In 1978, NASA scientists Donald Kessler and Burton Cour-Palais published a paper
                that would haunt space exploration for decades. They described a nightmare scenario:
                as we launch more satellites, collisions become inevitable. Each collision creates
                <strong>thousands of fragments</strong>. Those fragments cause more collisions,
                which create more fragments, in a runaway cascade. Eventually, Earth's orbit becomes
                so crowded with hypersonic shrapnel that it's <em>permanently unusable</em>‚Äînot for
                years, not for decades, but potentially for <strong>centuries</strong>.
            </p>

            <h2>The Terrifying Math</h2>
            <p>
                Space debris travels at <span class="highlight-stat">7 to 15 km/s</span>‚Äîthat's up
                to 54,000 km/h. At these velocities, kinetic energy scales with the square of speed.
                A <strong>1-gram fleck of paint</strong> carries the same energy as a bowling ball
                dropped from several stories. A <strong>10-gram bolt</strong> hits like a hand
                grenade. The 2009 collision between the defunct Kosmos 2251 and active Iridium 33
                satellites‚Äîthe first accidental hypervelocity collision between two intact
                spacecraft‚Äîcreated over <span class="highlight-stat">2,000 trackable fragments</span>
                and countless smaller pieces.
            </p>

            <div class="timeline-cards">
                <div class="timeline-card">
                    <div class="year">1978</div>
                    <div class="event">Kessler & Cour-Palais publish theory</div>
                </div>
                <div class="timeline-card">
                    <div class="year">2007</div>
                    <div class="event">China ASAT test creates 3,500+ fragments</div>
                </div>
                <div class="timeline-card">
                    <div class="year">2009</div>
                    <div class="event">Iridium-Kosmos collision</div>
                </div>
                <div class="timeline-card">
                    <div class="year">2024</div>
                    <div class="event">Long March 6A breakup: 700+ fragments</div>
                </div>
            </div>

            <h2>The Numbers Today</h2>
            <p>
                As of 2025, there are over <span class="highlight-stat">11,800 satellites</span>
                in orbit, with SpaceX's Starlink constellation accounting for more than 7,000.
                Beyond satellites, tracking systems monitor approximately <span class="highlight-stat">
                23,000 pieces</span> of debris larger than 10 cm. But the truly terrifying number
                is the estimated <strong>600,000 fragments</strong> between 1-10 cm‚Äîtoo small to
                track reliably but large enough to destroy any spacecraft they hit. And there are
                millions more sub-centimeter particles.
            </p>

            <h2>The Point of No Return</h2>
            <p>
                The paradox lies in crossing an invisible threshold. Below a critical debris density,
                the environment is self-cleaning: atmospheric drag eventually pulls debris down,
                and collisions are rare enough that the situation stays manageable. But above that
                threshold, collisions generate debris faster than drag removes it. The cascade
                becomes <em>self-sustaining</em>. Some scientists warn we may have already passed
                this point in certain orbital bands. The debris already in orbit‚Äîeven if we never
                launched another satellite‚Äîcould continue colliding and fragmenting for generations.
            </p>

            <h2>Living with the Syndrome</h2>
            <p>
                The International Space Station regularly maneuvers to avoid debris‚Äîsometimes with
                less than a day's warning. In extreme cases, astronauts shelter in their return
                vehicles, prepared to evacuate. Every satellite launch now must include a
                <strong>deorbit plan</strong>. Companies and agencies are developing debris removal
                technologies: nets, harpoons, lasers, even "space tugs." But removing debris costs
                far more than creating it. The Kessler Syndrome is the ultimate tragedy of the
                commons‚Äîwe share the orbital environment, but no one owns responsibility for
                cleaning it.
            </p>

            <p>
                The final irony: we've become so dependent on satellites‚Äîfor GPS, weather,
                communications, internet‚Äîthat losing access to orbit would devastate modern
                civilization. The very tools that enabled globalization and the information age
                could trap us on Earth, surrounded by an impassable shell of our own garbage,
                moving at bullet speed.
            </p>
        </div>

        <footer>
            <p>
                Sources:
                <a href="https://en.wikipedia.org/wiki/Kessler_syndrome">Wikipedia</a> |
                <a href="https://www.space.com/kessler-syndrome-space-debris">Space.com</a> |
                <a href="https://www.esa.int/Enabling_Support/Space_Engineering_Technology/The_Kessler_Effect_and_how_to_stop_it">ESA</a>
            </p>
        </footer>
    </div>

    <script>
        const canvas = document.getElementById('orbitCanvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        let simSpeed = 1;
        let initialSats = 50;
        let time = 0;

        // Objects
        let satellites = [];
        let debris = [];
        let explosions = [];
        let collisionCount = 0;

        // Thresholds
        const KESSLER_THRESHOLD = 500; // Debris count for cascade
        let cascadeActive = false;

        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const size = Math.min(rect.width - 40, 600);
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            ctx.scale(dpr, dpr);
        }

        resizeCanvas();
        window.addEventListener('resize', () => {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            resizeCanvas();
        });

        class Satellite {
            constructor(altitude, angle) {
                this.altitude = altitude || 150 + Math.random() * 100;
                this.angle = angle || Math.random() * Math.PI * 2;
                this.speed = 0.002 + (250 - this.altitude) * 0.00001;
                this.size = 4;
                this.active = true;
            }

            update(dt) {
                this.angle += this.speed * dt * simSpeed;
            }

            getPosition(cx, cy) {
                return {
                    x: cx + Math.cos(this.angle) * this.altitude,
                    y: cy + Math.sin(this.angle) * this.altitude
                };
            }

            draw(ctx, cx, cy) {
                const pos = this.getPosition(cx, cy);

                // Solar panel glow
                ctx.fillStyle = 'rgba(100, 181, 246, 0.3)';
                ctx.fillRect(pos.x - 8, pos.y - 2, 16, 4);

                // Body
                ctx.fillStyle = '#90a4ae';
                ctx.fillRect(pos.x - 3, pos.y - 3, 6, 6);

                // Indicator light
                ctx.beginPath();
                ctx.arc(pos.x, pos.y - 4, 1.5, 0, Math.PI * 2);
                ctx.fillStyle = '#69f0ae';
                ctx.fill();
            }
        }

        class Debris {
            constructor(x, y, cx, cy) {
                const dx = x - cx;
                const dy = y - cy;
                this.altitude = Math.sqrt(dx * dx + dy * dy);
                this.angle = Math.atan2(dy, dx);
                this.speed = 0.002 + (250 - this.altitude) * 0.00001;
                // Add random velocity component from collision
                this.speed += (Math.random() - 0.5) * 0.003;
                this.angularDrift = (Math.random() - 0.5) * 0.001;
                this.size = 1 + Math.random() * 2;
                this.brightness = 0.3 + Math.random() * 0.7;
                this.life = 1000 + Math.random() * 2000; // Eventually deorbits
            }

            update(dt) {
                this.angle += (this.speed + this.angularDrift) * dt * simSpeed;
                this.altitude += (Math.random() - 0.5) * 0.1 * simSpeed;
                this.life -= dt * simSpeed * 0.1;

                // Gradual deorbit
                if (this.altitude < 250) {
                    this.altitude -= 0.01 * simSpeed;
                }
            }

            getPosition(cx, cy) {
                return {
                    x: cx + Math.cos(this.angle) * this.altitude,
                    y: cy + Math.sin(this.angle) * this.altitude
                };
            }

            draw(ctx, cx, cy) {
                const pos = this.getPosition(cx, cy);
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 138, 128, ${this.brightness})`;
                ctx.fill();
            }

            isDead() {
                return this.life <= 0 || this.altitude < 80;
            }
        }

        class Explosion {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 5;
                this.maxRadius = 30;
                this.life = 1;
            }

            update(dt) {
                this.radius += 2 * simSpeed;
                this.life -= 0.05 * simSpeed;
            }

            draw(ctx) {
                if (this.life <= 0) return;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 193, 7, ${this.life})`;
                ctx.lineWidth = 3;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 87, 34, ${this.life * 0.5})`;
                ctx.fill();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        function initSimulation() {
            satellites = [];
            debris = [];
            explosions = [];
            collisionCount = 0;
            cascadeActive = false;

            for (let i = 0; i < initialSats; i++) {
                satellites.push(new Satellite());
            }

            document.getElementById('warningOverlay').style.display = 'none';
        }

        function createCollision(sat1, sat2OrDebris, cx, cy) {
            const pos = sat1.getPosition(cx, cy);

            // Create explosion
            explosions.push(new Explosion(pos.x, pos.y));

            // Create debris (more from satellite-satellite collisions)
            const debrisCount = sat2OrDebris instanceof Satellite ?
                30 + Math.floor(Math.random() * 20) :
                5 + Math.floor(Math.random() * 10);

            for (let i = 0; i < debrisCount; i++) {
                const offsetX = (Math.random() - 0.5) * 30;
                const offsetY = (Math.random() - 0.5) * 30;
                debris.push(new Debris(pos.x + offsetX, pos.y + offsetY, cx, cy));
            }

            // Remove satellites involved
            sat1.active = false;
            if (sat2OrDebris instanceof Satellite) {
                sat2OrDebris.active = false;
            }

            collisionCount++;
        }

        function triggerRandomCollision(cx, cy) {
            if (satellites.length < 2) return;

            const idx1 = Math.floor(Math.random() * satellites.length);
            let idx2 = Math.floor(Math.random() * satellites.length);
            while (idx2 === idx1) idx2 = Math.floor(Math.random() * satellites.length);

            createCollision(satellites[idx1], satellites[idx2], cx, cy);
        }

        function checkCollisions(cx, cy) {
            const collisionDist = 15;

            // Satellite-Satellite collisions
            for (let i = 0; i < satellites.length; i++) {
                for (let j = i + 1; j < satellites.length; j++) {
                    if (!satellites[i].active || !satellites[j].active) continue;

                    const pos1 = satellites[i].getPosition(cx, cy);
                    const pos2 = satellites[j].getPosition(cx, cy);
                    const dist = Math.sqrt((pos1.x - pos2.x) ** 2 + (pos1.y - pos2.y) ** 2);

                    if (dist < collisionDist) {
                        createCollision(satellites[i], satellites[j], cx, cy);
                    }
                }
            }

            // Debris-Satellite collisions (cascade mechanism)
            for (const d of debris) {
                const debrisPos = d.getPosition(cx, cy);
                for (const sat of satellites) {
                    if (!sat.active) continue;
                    const satPos = sat.getPosition(cx, cy);
                    const dist = Math.sqrt((debrisPos.x - satPos.x) ** 2 + (debrisPos.y - satPos.y) ** 2);

                    if (dist < 10) {
                        createCollision(sat, d, cx, cy);
                        break;
                    }
                }
            }

            // Remove inactive satellites
            satellites = satellites.filter(s => s.active);
        }

        function updateStats() {
            const activeSats = satellites.length;
            const debrisNum = debris.length;

            document.getElementById('satCount').textContent = activeSats;
            document.getElementById('debrisCount').textContent = debrisNum;
            document.getElementById('collisionCount').textContent = collisionCount;

            // Color coding
            const satEl = document.getElementById('satCount');
            const debrisEl = document.getElementById('debrisCount');
            const statusEl = document.getElementById('orbitStatus');

            satEl.className = 'stat-value ' + (activeSats > 30 ? 'safe' : activeSats > 10 ? 'warning' : 'critical');

            if (debrisNum < 100) {
                debrisEl.className = 'stat-value safe';
                statusEl.className = 'stat-value safe';
                statusEl.textContent = 'Safe';
            } else if (debrisNum < KESSLER_THRESHOLD) {
                debrisEl.className = 'stat-value warning';
                statusEl.className = 'stat-value warning';
                statusEl.textContent = 'Elevated Risk';
            } else {
                debrisEl.className = 'stat-value critical';
                statusEl.className = 'stat-value critical';
                statusEl.textContent = 'CASCADE!';
                cascadeActive = true;
                document.getElementById('warningOverlay').style.display = 'block';
            }

            // Debris meter
            const meterFill = document.getElementById('debrisMeter');
            const fillPercent = Math.min(100, (debrisNum / KESSLER_THRESHOLD) * 100);
            meterFill.style.width = fillPercent + '%';

            if (fillPercent < 33) {
                meterFill.style.background = '#69f0ae';
            } else if (fillPercent < 66) {
                meterFill.style.background = '#ffab40';
            } else {
                meterFill.style.background = '#ff5252';
            }
        }

        function draw() {
            const w = canvas.width / dpr;
            const h = canvas.height / dpr;
            const cx = w / 2;
            const cy = h / 2;

            // Clear with space background
            ctx.fillStyle = '#000010';
            ctx.fillRect(0, 0, w, h);

            // Stars
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            for (let i = 0; i < 100; i++) {
                const x = (Math.sin(i * 100) * 0.5 + 0.5) * w;
                const y = (Math.cos(i * 50) * 0.5 + 0.5) * h;
                ctx.beginPath();
                ctx.arc(x, y, 0.5 + Math.random(), 0, Math.PI * 2);
                ctx.fill();
            }

            // Earth
            const earthRadius = 60;
            const earthGradient = ctx.createRadialGradient(cx - 15, cy - 15, 0, cx, cy, earthRadius);
            earthGradient.addColorStop(0, '#4fc3f7');
            earthGradient.addColorStop(0.5, '#29b6f6');
            earthGradient.addColorStop(1, '#0288d1');

            ctx.beginPath();
            ctx.arc(cx, cy, earthRadius, 0, Math.PI * 2);
            ctx.fillStyle = earthGradient;
            ctx.fill();

            // Atmosphere glow
            ctx.beginPath();
            ctx.arc(cx, cy, earthRadius + 5, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(100, 181, 246, 0.3)';
            ctx.lineWidth = 10;
            ctx.stroke();

            // Orbital bands (visual guides)
            ctx.strokeStyle = 'rgba(92, 107, 192, 0.1)';
            ctx.lineWidth = 1;
            for (let r = 100; r <= 250; r += 50) {
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Update and draw debris
            debris = debris.filter(d => !d.isDead());
            for (const d of debris) {
                d.update(1);
                d.draw(ctx, cx, cy);
            }

            // Update and draw satellites
            for (const sat of satellites) {
                sat.update(1);
                sat.draw(ctx, cx, cy);
            }

            // Update and draw explosions
            explosions = explosions.filter(e => !e.isDead());
            for (const exp of explosions) {
                exp.update(1);
                exp.draw(ctx);
            }

            // Check for collisions
            if (Math.random() < 0.01 * simSpeed * (cascadeActive ? 5 : 1)) {
                checkCollisions(cx, cy);
            }

            // Random debris-debris collisions in cascade mode
            if (cascadeActive && Math.random() < 0.005 * simSpeed) {
                // Debris fragmentation
                if (debris.length > 0) {
                    const idx = Math.floor(Math.random() * debris.length);
                    const d = debris[idx];
                    const pos = d.getPosition(cx, cy);
                    for (let i = 0; i < 3; i++) {
                        debris.push(new Debris(pos.x, pos.y, cx, cy));
                    }
                    explosions.push(new Explosion(pos.x, pos.y));
                }
            }

            updateStats();
            time++;
            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            simSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = simSpeed;
        });

        document.getElementById('satSlider').addEventListener('input', (e) => {
            initialSats = parseInt(e.target.value);
            document.getElementById('satValue').textContent = initialSats;
        });

        document.getElementById('collisionBtn').addEventListener('click', () => {
            const w = canvas.width / dpr;
            const h = canvas.height / dpr;
            triggerRandomCollision(w / 2, h / 2);
        });

        document.getElementById('launchBtn').addEventListener('click', () => {
            satellites.push(new Satellite());
        });

        document.getElementById('resetBtn').addEventListener('click', initSimulation);

        // Initialize
        initSimulation();
        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
