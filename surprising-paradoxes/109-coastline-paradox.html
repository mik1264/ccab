<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Coastline Paradox - How Long Is Britain's Coast?</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #0a1628 0%, #1a2a4a 50%, #0a2040 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(135deg, #00bfff, #00ff88, #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.3em;
            color: #aaa;
            font-style: italic;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00bfff;
            text-decoration: none;
            font-size: 1.1em;
            z-index: 100;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: #ffd700;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 1000px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(20, 40, 80, 0.8);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(0, 191, 255, 0.3);
        }

        .panel h2 {
            color: #00bfff;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        canvas {
            width: 100%;
            border-radius: 10px;
            background: #051020;
            cursor: crosshair;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .control-group label {
            min-width: 120px;
            color: #aaa;
        }

        input[type="range"] {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #00bfff, #00ff88);
            border-radius: 4px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 191, 255, 0.5);
        }

        .value-display {
            min-width: 80px;
            text-align: right;
            font-family: monospace;
            color: #00ff88;
            font-size: 1.1em;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.85em;
            color: #888;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.6em;
            font-family: monospace;
        }

        .stat-value.length {
            color: #00ff88;
        }

        .stat-value.dimension {
            color: #ffd700;
        }

        .stat-value.zoom {
            color: #00bfff;
        }

        .explanation {
            background: rgba(20, 40, 80, 0.8);
            border-radius: 15px;
            padding: 30px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            margin-bottom: 30px;
        }

        .explanation h2 {
            color: #ffd700;
            margin-bottom: 20px;
        }

        .explanation p {
            line-height: 1.8;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .highlight {
            color: #00bfff;
            font-weight: bold;
        }

        .paradox-box {
            background: linear-gradient(135deg, rgba(0, 100, 200, 0.2), rgba(0, 255, 136, 0.1));
            border: 2px solid #00bfff;
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
            text-align: center;
        }

        .paradox-box h3 {
            color: #00bfff;
            font-size: 1.5em;
            margin-bottom: 15px;
        }

        .paradox-box p {
            font-size: 1.2em;
            color: #fff;
        }

        .formula-box {
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            font-family: 'Times New Roman', serif;
        }

        .formula {
            font-size: 1.4em;
            margin: 15px 0;
            color: #00ff88;
        }

        .history-panel {
            background: rgba(100, 80, 50, 0.3);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
        }

        .history-panel h2 {
            color: #ffd700;
            margin-bottom: 15px;
        }

        .border-dispute {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: center;
            margin: 20px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .country {
            text-align: center;
        }

        .country-name {
            font-size: 1.2em;
            color: #ffd700;
            margin-bottom: 5px;
        }

        .country-length {
            font-size: 1.8em;
            font-family: monospace;
        }

        .vs {
            font-size: 1.5em;
            color: #ff6b6b;
        }

        .koch-comparison {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
        }

        .koch-comparison h3 {
            color: #00ff88;
            margin-bottom: 15px;
        }

        .dimension-scale {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .dimension-item {
            text-align: center;
        }

        .dimension-label {
            font-size: 0.9em;
            color: #888;
        }

        .dimension-value {
            font-size: 1.3em;
            color: #00ff88;
            font-family: monospace;
        }

        .measurement-table {
            width: 100%;
            margin-top: 20px;
            border-collapse: collapse;
        }

        .measurement-table th, .measurement-table td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .measurement-table th {
            color: #00bfff;
            font-weight: normal;
        }

        .measurement-table tr:hover {
            background: rgba(0, 191, 255, 0.1);
        }

        /* Coastline type selector */
        .coastline-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .coastline-btn {
            padding: 8px 16px;
            border: 2px solid #00bfff;
            background: rgba(0, 191, 255, 0.1);
            color: #00bfff;
            border-radius: 8px;
            cursor: pointer;
            font-family: Georgia, serif;
            font-size: 0.9em;
            transition: all 0.3s;
        }

        .coastline-btn:hover {
            background: rgba(0, 191, 255, 0.3);
        }

        .coastline-btn.active {
            background: #00bfff;
            color: #051020;
        }

        /* Zoom controls */
        .zoom-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            align-items: center;
        }

        .zoom-btn {
            width: 36px;
            height: 36px;
            border: 2px solid #00ff88;
            background: rgba(0, 255, 136, 0.1);
            color: #00ff88;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.4em;
            font-weight: bold;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background: rgba(0, 255, 136, 0.3);
        }

        .zoom-info {
            color: #888;
            font-size: 0.9em;
            margin-left: 10px;
        }

        /* Comparison panel */
        .comparison-panel {
            background: rgba(20, 40, 80, 0.8);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 100, 100, 0.3);
            margin-top: 30px;
        }

        .comparison-panel h2 {
            color: #ff6b6b;
            margin-bottom: 20px;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .comparison-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .comparison-item:hover {
            border-color: #00bfff;
        }

        .comparison-item.selected {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }

        .comparison-name {
            font-size: 1.1em;
            color: #fff;
            margin-bottom: 5px;
        }

        .comparison-dim {
            font-family: monospace;
            color: #00ff88;
            font-size: 1.3em;
        }

        .comparison-desc {
            font-size: 0.8em;
            color: #888;
            margin-top: 5px;
        }

        /* Fractal calculator panel */
        .calculator-panel {
            background: rgba(50, 30, 80, 0.8);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(180, 100, 255, 0.3);
            margin-top: 30px;
        }

        .calculator-panel h2 {
            color: #b480ff;
            margin-bottom: 20px;
        }

        .calc-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 800px) {
            .calc-grid {
                grid-template-columns: 1fr;
            }
        }

        .calc-result {
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .calc-label {
            color: #aaa;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .calc-value {
            font-size: 2.5em;
            font-family: monospace;
            color: #b480ff;
        }

        .calc-explanation {
            font-size: 0.85em;
            color: #888;
            margin-top: 10px;
            line-height: 1.5;
        }

        /* Self-similarity zoom view */
        .zoom-panel {
            position: relative;
        }

        .zoom-indicator {
            position: absolute;
            border: 2px dashed #ffd700;
            pointer-events: none;
            display: none;
        }

        .zoom-hint {
            color: #888;
            font-size: 0.85em;
            margin-top: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>The Coastline Paradox</h1>
            <p class="subtitle">How Long Is the Coast of Britain? It Depends Who's Measuring!</p>
        </header>

        <div class="main-grid">
            <div class="panel zoom-panel">
                <h2>Measure the Coastline</h2>
                <canvas id="coastCanvas" width="600" height="450"></canvas>
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoomIn">+</button>
                    <button class="zoom-btn" id="zoomOut">-</button>
                    <button class="zoom-btn" id="zoomReset" style="font-size: 0.9em;">R</button>
                    <span class="zoom-info">Click and drag to pan. Scroll to zoom. Notice self-similarity!</span>
                </div>
                <div class="controls">
                    <div class="control-group">
                        <label>Ruler Size:</label>
                        <input type="range" id="rulerSlider" min="1" max="100" value="50" step="1">
                        <span class="value-display" id="rulerValue">50 km</span>
                    </div>
                    <div class="control-group">
                        <label>Precision:</label>
                        <input type="range" id="precisionSlider" min="1" max="5" value="3" step="1">
                        <span class="value-display" id="precisionValue">Medium</span>
                    </div>
                </div>
                <p class="zoom-hint">Zoom in to see fractal detail at every scale - the pattern repeats infinitely!</p>
                <div class="coastline-selector">
                    <button class="coastline-btn active" data-type="britain">Britain</button>
                    <button class="coastline-btn" data-type="norway">Norway</button>
                    <button class="coastline-btn" data-type="australia">Australia</button>
                    <button class="coastline-btn" data-type="koch">Koch Curve</button>
                </div>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-label">Measured Length</div>
                        <div class="stat-value length" id="lengthDisplay">2,800</div>
                        <div style="font-size: 0.9em; color: #888;">km</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Fractal Dimension</div>
                        <div class="stat-value dimension" id="dimensionDisplay">1.25</div>
                        <div style="font-size: 0.9em; color: #888;">D</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Zoom Level</div>
                        <div class="stat-value zoom" id="zoomDisplay">1.0x</div>
                        <div style="font-size: 0.9em; color: #888;">magnification</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h2>Richardson's Law (Log-Log Plot)</h2>
                <canvas id="graphCanvas" width="600" height="450"></canvas>
                <p style="margin-top: 15px; color: #aaa; text-align: center; font-size: 0.95em;">
                    The slope of this line reveals the fractal dimension!<br>
                    A steeper slope = more complex coastline = longer at small scales
                </p>
            </div>
        </div>

        <!-- Fractal Dimension Calculator -->
        <div class="calculator-panel">
            <h2>Fractal Dimension Calculator</h2>
            <p style="color: #ccc; margin-bottom: 20px;">
                The fractal dimension D tells us how quickly the coastline length increases as measurement precision improves.
                For regular shapes D=1 (line) or D=2 (plane). Coastlines fall between 1 and 2!
            </p>
            <div class="calc-grid">
                <div class="calc-result">
                    <div class="calc-label">Calculated Dimension (Box-Counting)</div>
                    <div class="calc-value" id="calcDimension">1.25</div>
                    <div class="calc-explanation">
                        Using Richardson's formula: D = 1 - slope of log-log plot<br>
                        Measures how perimeter increases as box size decreases
                    </div>
                </div>
                <div class="calc-result">
                    <div class="calc-label">Length at Atomic Scale (1mm ruler)</div>
                    <div class="calc-value" id="atomicLength">∞</div>
                    <div class="calc-explanation">
                        Extrapolating Richardson's law to the smallest scales<br>
                        The length grows without bound as ruler shrinks!
                    </div>
                </div>
            </div>
        </div>

        <!-- Coastline Comparison -->
        <div class="comparison-panel">
            <h2>Compare Coastline Complexities</h2>
            <p style="color: #ccc; margin-bottom: 20px;">
                Different coastlines have different fractal dimensions based on their geological history and erosion patterns.
                Click to compare!
            </p>
            <div class="comparison-grid">
                <div class="comparison-item selected" data-coast="britain">
                    <div class="comparison-name">Britain</div>
                    <div class="comparison-dim">D = 1.25</div>
                    <div class="comparison-desc">Highly irregular, many inlets</div>
                </div>
                <div class="comparison-item" data-coast="norway">
                    <div class="comparison-name">Norway</div>
                    <div class="comparison-dim">D = 1.52</div>
                    <div class="comparison-desc">Extreme fjords, very complex</div>
                </div>
                <div class="comparison-item" data-coast="australia">
                    <div class="comparison-name">Australia</div>
                    <div class="comparison-dim">D = 1.13</div>
                    <div class="comparison-desc">Relatively smooth coastline</div>
                </div>
                <div class="comparison-item" data-coast="southafrica">
                    <div class="comparison-name">South Africa</div>
                    <div class="comparison-dim">D = 1.02</div>
                    <div class="comparison-desc">Nearly smooth, few indentations</div>
                </div>
                <div class="comparison-item" data-coast="koch">
                    <div class="comparison-name">Koch Curve</div>
                    <div class="comparison-dim">D = 1.26</div>
                    <div class="comparison-desc">Perfect mathematical fractal</div>
                </div>
                <div class="comparison-item" data-coast="hilbert">
                    <div class="comparison-name">Hilbert Curve</div>
                    <div class="comparison-dim">D = 2.00</div>
                    <div class="comparison-desc">Space-filling, approaches plane</div>
                </div>
            </div>
        </div>

        <div class="explanation">
            <h2>The Mind-Bending Paradox</h2>

            <p>
                In 1967, mathematician <span class="highlight">Benoit Mandelbrot</span> asked a deceptively simple question:
                <em>"How long is the coast of Britain?"</em> The answer shocked the mathematical world:
                <span class="highlight">it depends on your ruler!</span>
            </p>

            <div class="paradox-box">
                <h3>The Paradox</h3>
                <p>
                    Use a 100 km ruler → Britain's coast is ~2,800 km<br>
                    Use a 50 km ruler → It's ~3,500 km<br>
                    Use a 1 km ruler → It's ~8,000+ km<br>
                    <strong style="color: #ff6b6b;">As the ruler shrinks, the coastline approaches INFINITY!</strong>
                </p>
            </div>

            <p>
                This happens because coastlines are <span class="highlight">fractals</span>—they have detail at every scale.
                Zoom in on any bay, and you find smaller bays. Zoom into those, and there are even smaller ones.
                This self-similarity continues down to the level of individual grains of sand!
            </p>

            <div class="formula-box">
                <h4 style="color: #00ffff; margin-bottom: 15px;">Richardson's Empirical Law:</h4>
                <div class="formula">L(e) = C × e^(1-D)</div>
                <p style="color: #aaa; font-size: 0.95em;">
                    L = measured length, e = ruler size, D = fractal dimension, C = constant<br>
                    When D > 1, smaller rulers give exponentially longer measurements!
                </p>
            </div>
        </div>

        <div class="history-panel">
            <h2>The Spain-Portugal Border Dispute</h2>
            <p style="margin-bottom: 15px; color: #ccc;">
                Lewis Fry Richardson discovered the paradox while studying whether border length affects war probability.
                He found that Spain and Portugal reported wildly different lengths for their shared border!
            </p>
            <div class="border-dispute">
                <div class="country">
                    <div class="country-name">Portugal says:</div>
                    <div class="country-length" style="color: #00ff88;">987 km</div>
                </div>
                <div class="vs">!=</div>
                <div class="country">
                    <div class="country-name">Spain says:</div>
                    <div class="country-length" style="color: #ff6b6b;">1,214 km</div>
                </div>
            </div>
            <p style="color: #aaa; text-align: center;">
                A 23% difference! Neither was wrong—they just used different ruler sizes.
            </p>
        </div>

        <div class="koch-comparison">
            <h3>The Koch Snowflake: A Perfect Fractal</h3>
            <p style="margin-bottom: 15px; color: #ccc;">
                The Koch curve has dimension D = log(4)/log(3) = 1.26—similar to Britain's coast!
                Each iteration adds more detail, increasing the perimeter by 4/3 while area stays bounded.
            </p>
            <canvas id="kochCanvas" width="600" height="200"></canvas>
            <div class="dimension-scale">
                <div class="dimension-item">
                    <div class="dimension-label">Straight Line</div>
                    <div class="dimension-value">D = 1.00</div>
                </div>
                <div class="dimension-item">
                    <div class="dimension-label">South Africa</div>
                    <div class="dimension-value">D = 1.02</div>
                </div>
                <div class="dimension-item">
                    <div class="dimension-label">Britain</div>
                    <div class="dimension-value">D = 1.25</div>
                </div>
                <div class="dimension-item">
                    <div class="dimension-label">Koch Curve</div>
                    <div class="dimension-value">D = 1.26</div>
                </div>
                <div class="dimension-item">
                    <div class="dimension-label">Filled Plane</div>
                    <div class="dimension-value">D = 2.00</div>
                </div>
            </div>
        </div>

        <div class="panel" style="margin-top: 30px;">
            <h2>Britain's Coast at Different Scales</h2>
            <table class="measurement-table">
                <thead>
                    <tr>
                        <th>Ruler Size</th>
                        <th>Measured Length</th>
                        <th>Increase from 100km</th>
                    </tr>
                </thead>
                <tbody id="measurementTable">
                </tbody>
            </table>
        </div>
    </div>

    <script>
        const coastCanvas = document.getElementById('coastCanvas');
        const coastCtx = coastCanvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');
        const kochCanvas = document.getElementById('kochCanvas');
        const kochCtx = kochCanvas.getContext('2d');

        // Coastline types with their fractal dimensions and characteristics
        const coastlineTypes = {
            britain: {
                name: 'Britain',
                dimension: 1.25,
                baseLength: 2800,
                baseRuler: 100,
                complexity: [3, 7, 13, 23, 47, 89],
                amplitudes: [30, 20, 15, 10, 5, 2.5],
                color: '#88cc88'
            },
            norway: {
                name: 'Norway',
                dimension: 1.52,
                baseLength: 25000,
                baseRuler: 100,
                complexity: [2, 5, 11, 23, 47, 97, 193],
                amplitudes: [40, 30, 25, 20, 15, 10, 5],
                color: '#6699cc'
            },
            australia: {
                name: 'Australia',
                dimension: 1.13,
                baseLength: 34218,
                baseRuler: 100,
                complexity: [4, 9, 17],
                amplitudes: [25, 12, 5],
                color: '#cc9966'
            },
            koch: {
                name: 'Koch Curve',
                dimension: Math.log(4) / Math.log(3),
                baseLength: 1000,
                baseRuler: 100,
                isKoch: true,
                color: '#00bfff'
            }
        };

        // State
        let rulerSize = 50;
        let precision = 3;
        let currentCoastline = 'britain';
        let zoomLevel = 1;
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let coastlinePoints = [];

        // Generate a fractal-like coastline with configurable complexity
        function generateCoastline(type) {
            const config = coastlineTypes[type];

            if (config.isKoch) {
                return generateKochCoastline();
            }

            const points = [];
            const segments = 200 + (precision - 1) * 100;
            const baseRadius = 180;
            const centerX = 300;
            const centerY = 225;

            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                let radius = baseRadius;

                // Add multiple frequencies of noise for fractal-like appearance
                for (let j = 0; j < config.complexity.length && j < precision + 2; j++) {
                    radius += config.amplitudes[j] * Math.sin(angle * config.complexity[j] + j);
                }

                points.push({
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                });
            }
            return points;
        }

        function generateKochCoastline() {
            const points = [];
            const iterations = Math.min(precision + 2, 6);

            // Start with a circle approximated by koch-like segments
            const segments = 6;
            const baseRadius = 180;
            const centerX = 300;
            const centerY = 225;

            for (let i = 0; i < segments; i++) {
                const angle1 = (i / segments) * Math.PI * 2;
                const angle2 = ((i + 1) / segments) * Math.PI * 2;

                const x1 = centerX + baseRadius * Math.cos(angle1);
                const y1 = centerY + baseRadius * Math.sin(angle1);
                const x2 = centerX + baseRadius * Math.cos(angle2);
                const y2 = centerY + baseRadius * Math.sin(angle2);

                const kochPoints = generateKochPoints(x1, y1, x2, y2, iterations);
                points.push(...kochPoints);
            }

            return points;
        }

        function generateKochPoints(x1, y1, x2, y2, depth) {
            if (depth === 0) {
                return [{ x: x1, y: y1 }];
            }

            const dx = x2 - x1;
            const dy = y2 - y1;

            const x3 = x1 + dx / 3;
            const y3 = y1 + dy / 3;

            const x5 = x1 + 2 * dx / 3;
            const y5 = y1 + 2 * dy / 3;

            const x4 = (x3 + x5) / 2 - (y5 - y3) * Math.sqrt(3) / 2;
            const y4 = (y3 + y5) / 2 + (x5 - x3) * Math.sqrt(3) / 2;

            return [
                ...generateKochPoints(x1, y1, x3, y3, depth - 1),
                ...generateKochPoints(x3, y3, x4, y4, depth - 1),
                ...generateKochPoints(x4, y4, x5, y5, depth - 1),
                ...generateKochPoints(x5, y5, x2, y2, depth - 1)
            ];
        }

        // Update coastline
        function updateCoastline() {
            coastlinePoints = generateCoastline(currentCoastline);
        }

        // Slider handlers
        document.getElementById('rulerSlider').addEventListener('input', function() {
            rulerSize = parseFloat(this.value);
            document.getElementById('rulerValue').textContent = rulerSize + ' km';
            updateMeasurement();
            drawCoast();
            drawGraph();
        });

        document.getElementById('precisionSlider').addEventListener('input', function() {
            precision = parseInt(this.value);
            const labels = ['Very Low', 'Low', 'Medium', 'High', 'Very High'];
            document.getElementById('precisionValue').textContent = labels[precision - 1];
            updateCoastline();
            updateMeasurement();
            drawCoast();
            drawGraph();
            updateCalculator();
        });

        // Coastline type selector
        document.querySelectorAll('.coastline-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.coastline-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentCoastline = this.dataset.type;
                updateCoastline();
                updateMeasurement();
                drawCoast();
                drawGraph();
                updateCalculator();

                // Update dimension display
                document.getElementById('dimensionDisplay').textContent =
                    coastlineTypes[currentCoastline].dimension.toFixed(2);
            });
        });

        // Comparison selector
        document.querySelectorAll('.comparison-item').forEach(item => {
            item.addEventListener('click', function() {
                document.querySelectorAll('.comparison-item').forEach(i => i.classList.remove('selected'));
                this.classList.add('selected');

                const coast = this.dataset.coast;
                if (coastlineTypes[coast]) {
                    // Find and click the corresponding coastline button
                    const btn = document.querySelector(`.coastline-btn[data-type="${coast}"]`);
                    if (btn) {
                        btn.click();
                    }
                }
            });
        });

        // Zoom controls
        document.getElementById('zoomIn').addEventListener('click', () => {
            zoomLevel = Math.min(zoomLevel * 1.5, 10);
            updateZoomDisplay();
            drawCoast();
        });

        document.getElementById('zoomOut').addEventListener('click', () => {
            zoomLevel = Math.max(zoomLevel / 1.5, 0.5);
            updateZoomDisplay();
            drawCoast();
        });

        document.getElementById('zoomReset').addEventListener('click', () => {
            zoomLevel = 1;
            panX = 0;
            panY = 0;
            updateZoomDisplay();
            drawCoast();
        });

        function updateZoomDisplay() {
            document.getElementById('zoomDisplay').textContent = zoomLevel.toFixed(1) + 'x';
        }

        // Mouse controls for pan and zoom
        coastCanvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            coastCanvas.style.cursor = 'grabbing';
        });

        coastCanvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                panX += dx / zoomLevel;
                panY += dy / zoomLevel;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                drawCoast();
            }
        });

        coastCanvas.addEventListener('mouseup', () => {
            isDragging = false;
            coastCanvas.style.cursor = 'crosshair';
        });

        coastCanvas.addEventListener('mouseleave', () => {
            isDragging = false;
            coastCanvas.style.cursor = 'crosshair';
        });

        coastCanvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            zoomLevel = Math.max(0.5, Math.min(10, zoomLevel * delta));
            updateZoomDisplay();
            drawCoast();
        });

        function calculateLength(ruler, type = currentCoastline) {
            const config = coastlineTypes[type];
            // Richardson's law: L(e) = C × e^(1-D)
            const C = config.baseLength * Math.pow(config.baseRuler, config.dimension - 1);
            return C * Math.pow(ruler, 1 - config.dimension);
        }

        function updateMeasurement() {
            const length = calculateLength(rulerSize);
            document.getElementById('lengthDisplay').textContent = Math.round(length).toLocaleString();
        }

        function updateCalculator() {
            const config = coastlineTypes[currentCoastline];
            document.getElementById('calcDimension').textContent = config.dimension.toFixed(3);

            // Calculate length at 1mm ruler (0.001 km)
            const atomicLength = calculateLength(0.001);
            if (atomicLength > 1e9) {
                document.getElementById('atomicLength').textContent = (atomicLength / 1e9).toFixed(1) + 'B km';
            } else if (atomicLength > 1e6) {
                document.getElementById('atomicLength').textContent = (atomicLength / 1e6).toFixed(1) + 'M km';
            } else {
                document.getElementById('atomicLength').textContent = Math.round(atomicLength).toLocaleString() + ' km';
            }
        }

        function drawCoast() {
            const w = coastCanvas.width;
            const h = coastCanvas.height;
            const config = coastlineTypes[currentCoastline];

            coastCtx.clearRect(0, 0, w, h);

            // Background - ocean
            const oceanGrad = coastCtx.createRadialGradient(300, 225, 0, 300, 225, 300);
            oceanGrad.addColorStop(0, '#0a3060');
            oceanGrad.addColorStop(1, '#051020');
            coastCtx.fillStyle = oceanGrad;
            coastCtx.fillRect(0, 0, w, h);

            // Apply zoom and pan transformations
            coastCtx.save();
            coastCtx.translate(w / 2, h / 2);
            coastCtx.scale(zoomLevel, zoomLevel);
            coastCtx.translate(-w / 2 + panX, -h / 2 + panY);

            // Draw filled land mass
            coastCtx.beginPath();
            coastCtx.moveTo(coastlinePoints[0].x, coastlinePoints[0].y);
            for (let i = 1; i < coastlinePoints.length; i++) {
                coastCtx.lineTo(coastlinePoints[i].x, coastlinePoints[i].y);
            }
            coastCtx.closePath();
            coastCtx.fillStyle = currentCoastline === 'koch' ? '#1a3a4a' : '#2a5a30';
            coastCtx.fill();

            // Draw actual coastline
            coastCtx.beginPath();
            coastCtx.moveTo(coastlinePoints[0].x, coastlinePoints[0].y);
            for (let i = 1; i < coastlinePoints.length; i++) {
                coastCtx.lineTo(coastlinePoints[i].x, coastlinePoints[i].y);
            }
            coastCtx.closePath();
            coastCtx.strokeStyle = config.color;
            coastCtx.lineWidth = 1 / zoomLevel;
            coastCtx.stroke();

            // Calculate measurement with current ruler
            const rulerPixels = rulerSize * 2 / zoomLevel;
            const measurements = [];

            let currentPoint = coastlinePoints[0];
            measurements.push(currentPoint);

            for (let i = 1; i < coastlinePoints.length; i++) {
                const dist = Math.hypot(
                    coastlinePoints[i].x - currentPoint.x,
                    coastlinePoints[i].y - currentPoint.y
                );
                if (dist >= rulerPixels) {
                    const ratio = rulerPixels / dist;
                    const newPoint = {
                        x: currentPoint.x + (coastlinePoints[i].x - currentPoint.x) * ratio,
                        y: currentPoint.y + (coastlinePoints[i].y - currentPoint.y) * ratio
                    };
                    measurements.push(newPoint);
                    currentPoint = newPoint;
                    i--;
                }
            }

            // Draw measurement lines
            coastCtx.beginPath();
            coastCtx.moveTo(measurements[0].x, measurements[0].y);
            for (let i = 1; i < measurements.length; i++) {
                coastCtx.lineTo(measurements[i].x, measurements[i].y);
            }
            coastCtx.strokeStyle = '#ff6b6b';
            coastCtx.lineWidth = 3 / zoomLevel;
            coastCtx.stroke();

            // Draw measurement points
            for (const point of measurements) {
                coastCtx.beginPath();
                coastCtx.arc(point.x, point.y, 4 / zoomLevel, 0, Math.PI * 2);
                coastCtx.fillStyle = '#ffd700';
                coastCtx.fill();
            }

            coastCtx.restore();

            // Draw labels (not affected by zoom)
            coastCtx.fillStyle = '#fff';
            coastCtx.font = 'bold 16px Georgia';
            coastCtx.fillText(`${config.name} (D=${config.dimension.toFixed(2)})`, 20, 30);
            coastCtx.font = '14px Georgia';
            coastCtx.fillStyle = '#aaa';
            coastCtx.fillText(`Measuring with ${rulerSize}km ruler`, 20, 55);
            coastCtx.fillStyle = '#ff6b6b';
            coastCtx.fillText(`${measurements.length - 1} segments x ${rulerSize}km = ${((measurements.length - 1) * rulerSize).toLocaleString()}km`, 20, 80);
        }

        function drawGraph() {
            const w = graphCanvas.width;
            const h = graphCanvas.height;
            const config = coastlineTypes[currentCoastline];

            graphCtx.clearRect(0, 0, w, h);

            // Background
            graphCtx.fillStyle = '#051020';
            graphCtx.fillRect(0, 0, w, h);

            const padding = 60;
            const graphW = w - padding * 2;
            const graphH = h - padding * 2;

            // Title
            graphCtx.fillStyle = '#888';
            graphCtx.font = '14px Georgia';
            graphCtx.fillText('log(Length) vs log(Ruler Size)', padding, 25);

            // Axes
            graphCtx.strokeStyle = '#444';
            graphCtx.lineWidth = 1;
            graphCtx.beginPath();
            graphCtx.moveTo(padding, padding);
            graphCtx.lineTo(padding, h - padding);
            graphCtx.lineTo(w - padding, h - padding);
            graphCtx.stroke();

            // Axis labels
            graphCtx.fillStyle = '#888';
            graphCtx.font = '12px Georgia';
            graphCtx.textAlign = 'center';
            graphCtx.fillText('log(e) - Ruler Size', w / 2, h - 15);

            graphCtx.save();
            graphCtx.translate(15, h / 2);
            graphCtx.rotate(-Math.PI / 2);
            graphCtx.fillText('log(L) - Length', 0, 0);
            graphCtx.restore();

            // Log scale ranges
            const minLogRuler = Math.log10(1);
            const maxLogRuler = Math.log10(100);
            const minLogLength = Math.log10(calculateLength(100) * 0.5);
            const maxLogLength = Math.log10(calculateLength(1) * 1.2);

            // Draw grid
            graphCtx.strokeStyle = '#333';
            graphCtx.setLineDash([2, 4]);
            for (let r = 1; r <= 100; r *= 10) {
                const x = padding + ((Math.log10(r) - minLogRuler) / (maxLogRuler - minLogRuler)) * graphW;
                graphCtx.beginPath();
                graphCtx.moveTo(x, padding);
                graphCtx.lineTo(x, h - padding);
                graphCtx.stroke();
                graphCtx.fillStyle = '#888';
                graphCtx.textAlign = 'center';
                graphCtx.fillText(r + 'km', x, h - padding + 20);
            }
            graphCtx.setLineDash([]);

            // Draw comparison lines for all coastline types (faded)
            for (const [type, typeConfig] of Object.entries(coastlineTypes)) {
                if (type === currentCoastline) continue;

                graphCtx.beginPath();
                graphCtx.strokeStyle = typeConfig.color + '40';
                graphCtx.lineWidth = 1;

                for (let logR = minLogRuler; logR <= maxLogRuler; logR += 0.05) {
                    const ruler = Math.pow(10, logR);
                    const length = calculateLength(ruler, type);
                    const logL = Math.log10(length);

                    const x = padding + ((logR - minLogRuler) / (maxLogRuler - minLogRuler)) * graphW;
                    const y = h - padding - ((logL - minLogLength) / (maxLogLength - minLogLength)) * graphH;

                    if (logR === minLogRuler) graphCtx.moveTo(x, y);
                    else graphCtx.lineTo(x, y);
                }
                graphCtx.stroke();
            }

            // Draw Richardson's law line (current coastline)
            graphCtx.beginPath();
            graphCtx.strokeStyle = '#00ff88';
            graphCtx.lineWidth = 3;

            for (let logR = minLogRuler; logR <= maxLogRuler; logR += 0.05) {
                const ruler = Math.pow(10, logR);
                const length = calculateLength(ruler);
                const logL = Math.log10(length);

                const x = padding + ((logR - minLogRuler) / (maxLogRuler - minLogRuler)) * graphW;
                const y = h - padding - ((logL - minLogLength) / (maxLogLength - minLogLength)) * graphH;

                if (logR === minLogRuler) graphCtx.moveTo(x, y);
                else graphCtx.lineTo(x, y);
            }
            graphCtx.stroke();

            // Mark current position
            const currentLogR = Math.log10(rulerSize);
            const currentLength = calculateLength(rulerSize);
            const currentLogL = Math.log10(currentLength);

            const markerX = padding + ((currentLogR - minLogRuler) / (maxLogRuler - minLogRuler)) * graphW;
            const markerY = h - padding - ((currentLogL - minLogLength) / (maxLogLength - minLogLength)) * graphH;

            graphCtx.beginPath();
            graphCtx.arc(markerX, markerY, 10, 0, Math.PI * 2);
            graphCtx.fillStyle = '#ffd700';
            graphCtx.fill();
            graphCtx.strokeStyle = '#fff';
            graphCtx.lineWidth = 2;
            graphCtx.stroke();

            // Show slope (= 1 - D)
            graphCtx.fillStyle = '#00ff88';
            graphCtx.font = 'bold 14px Georgia';
            graphCtx.textAlign = 'left';
            graphCtx.fillText(`Slope = 1 - D = ${(1 - config.dimension).toFixed(2)}`, padding + 10, padding + 25);
            graphCtx.fillText(`D = ${config.dimension.toFixed(2)} (fractal dimension)`, padding + 10, padding + 45);

            // Current measurement annotation
            graphCtx.fillStyle = '#ffd700';
            graphCtx.font = '12px Georgia';
            const annotation = `${rulerSize}km -> ${Math.round(currentLength).toLocaleString()}km`;
            graphCtx.fillText(annotation, markerX + 15, markerY - 5);
        }

        function drawKoch() {
            const w = kochCanvas.width;
            const h = kochCanvas.height;
            kochCtx.clearRect(0, 0, w, h);

            kochCtx.fillStyle = '#051020';
            kochCtx.fillRect(0, 0, w, h);

            // Draw Koch curve iterations
            const iterations = [0, 1, 2, 3, 4];
            const sectionWidth = w / iterations.length;

            for (let iter = 0; iter < iterations.length; iter++) {
                const centerX = sectionWidth * iter + sectionWidth / 2;
                const startX = centerX - 50;
                const endX = centerX + 50;
                const y = h / 2;

                drawKochSegment(kochCtx, startX, y, endX, y, iterations[iter]);

                // Label
                kochCtx.fillStyle = '#888';
                kochCtx.font = '11px Georgia';
                kochCtx.textAlign = 'center';
                kochCtx.fillText(`n=${iter}`, centerX, h - 15);

                const length = Math.pow(4/3, iter);
                kochCtx.fillStyle = '#00ff88';
                kochCtx.fillText(`L=${length.toFixed(2)}`, centerX, h - 30);
            }

            kochCtx.fillStyle = '#fff';
            kochCtx.font = '12px Georgia';
            kochCtx.textAlign = 'left';
            kochCtx.fillText('Koch Curve: Each iteration multiplies length by 4/3', 10, 20);
        }

        function drawKochSegment(ctx, x1, y1, x2, y2, depth) {
            if (depth === 0) {
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = '#00bfff';
                ctx.lineWidth = 2;
                ctx.stroke();
                return;
            }

            const dx = x2 - x1;
            const dy = y2 - y1;

            const x3 = x1 + dx / 3;
            const y3 = y1 + dy / 3;

            const x5 = x1 + 2 * dx / 3;
            const y5 = y1 + 2 * dy / 3;

            const x4 = (x3 + x5) / 2 - (y5 - y3) * Math.sqrt(3) / 2;
            const y4 = (y3 + y5) / 2 + (x5 - x3) * Math.sqrt(3) / 2;

            drawKochSegment(ctx, x1, y1, x3, y3, depth - 1);
            drawKochSegment(ctx, x3, y3, x4, y4, depth - 1);
            drawKochSegment(ctx, x4, y4, x5, y5, depth - 1);
            drawKochSegment(ctx, x5, y5, x2, y2, depth - 1);
        }

        function populateTable() {
            const tbody = document.getElementById('measurementTable');
            const rulers = [100, 50, 25, 10, 5, 2, 1];
            const baseLength = calculateLength(100);

            let html = '';
            for (const r of rulers) {
                const length = calculateLength(r);
                const increase = ((length / baseLength - 1) * 100).toFixed(0);
                html += `
                    <tr>
                        <td>${r} km</td>
                        <td style="color: #00ff88;">${Math.round(length).toLocaleString()} km</td>
                        <td style="color: ${increase > 0 ? '#ffd700' : '#888'};">+${increase}%</td>
                    </tr>
                `;
            }
            tbody.innerHTML = html;
        }

        // Initialize
        updateCoastline();
        updateMeasurement();
        drawCoast();
        drawGraph();
        drawKoch();
        populateTable();
        updateCalculator();
    </script>
</body>
</html>
