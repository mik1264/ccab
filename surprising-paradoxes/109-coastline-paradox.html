<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Coastline Paradox - How Long Is Britain's Coast?</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #0a1628 0%, #1a2a4a 50%, #0a2040 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(135deg, #00bfff, #00ff88, #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.3em;
            color: #aaa;
            font-style: italic;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00bfff;
            text-decoration: none;
            font-size: 1.1em;
            z-index: 100;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: #ffd700;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 1000px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(20, 40, 80, 0.8);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(0, 191, 255, 0.3);
        }

        .panel h2 {
            color: #00bfff;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        canvas {
            width: 100%;
            border-radius: 10px;
            background: #051020;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .control-group label {
            min-width: 100px;
            color: #aaa;
        }

        input[type="range"] {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #00bfff, #00ff88);
            border-radius: 4px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 191, 255, 0.5);
        }

        .value-display {
            min-width: 80px;
            text-align: right;
            font-family: monospace;
            color: #00ff88;
            font-size: 1.1em;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.9em;
            color: #888;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 2em;
            font-family: monospace;
        }

        .stat-value.length {
            color: #00ff88;
        }

        .stat-value.dimension {
            color: #ffd700;
        }

        .explanation {
            background: rgba(20, 40, 80, 0.8);
            border-radius: 15px;
            padding: 30px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            margin-bottom: 30px;
        }

        .explanation h2 {
            color: #ffd700;
            margin-bottom: 20px;
        }

        .explanation p {
            line-height: 1.8;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .highlight {
            color: #00bfff;
            font-weight: bold;
        }

        .paradox-box {
            background: linear-gradient(135deg, rgba(0, 100, 200, 0.2), rgba(0, 255, 136, 0.1));
            border: 2px solid #00bfff;
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
            text-align: center;
        }

        .paradox-box h3 {
            color: #00bfff;
            font-size: 1.5em;
            margin-bottom: 15px;
        }

        .paradox-box p {
            font-size: 1.2em;
            color: #fff;
        }

        .formula-box {
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            font-family: 'Times New Roman', serif;
        }

        .formula {
            font-size: 1.4em;
            margin: 15px 0;
            color: #00ff88;
        }

        .history-panel {
            background: rgba(100, 80, 50, 0.3);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
        }

        .history-panel h2 {
            color: #ffd700;
            margin-bottom: 15px;
        }

        .border-dispute {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: center;
            margin: 20px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .country {
            text-align: center;
        }

        .country-name {
            font-size: 1.2em;
            color: #ffd700;
            margin-bottom: 5px;
        }

        .country-length {
            font-size: 1.8em;
            font-family: monospace;
        }

        .vs {
            font-size: 1.5em;
            color: #ff6b6b;
        }

        .koch-comparison {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
        }

        .koch-comparison h3 {
            color: #00ff88;
            margin-bottom: 15px;
        }

        .dimension-scale {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .dimension-item {
            text-align: center;
        }

        .dimension-label {
            font-size: 0.9em;
            color: #888;
        }

        .dimension-value {
            font-size: 1.3em;
            color: #00ff88;
            font-family: monospace;
        }

        .measurement-table {
            width: 100%;
            margin-top: 20px;
            border-collapse: collapse;
        }

        .measurement-table th, .measurement-table td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .measurement-table th {
            color: #00bfff;
            font-weight: normal;
        }

        .measurement-table tr:hover {
            background: rgba(0, 191, 255, 0.1);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>üèùÔ∏è The Coastline Paradox</h1>
            <p class="subtitle">How Long Is the Coast of Britain? It Depends Who's Measuring!</p>
        </header>

        <div class="main-grid">
            <div class="panel">
                <h2>üìè Measure the Coastline</h2>
                <canvas id="coastCanvas" width="600" height="450"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Ruler Size:</label>
                        <input type="range" id="rulerSlider" min="5" max="100" value="50">
                        <span class="value-display" id="rulerValue">50 km</span>
                    </div>
                </div>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-label">Measured Length</div>
                        <div class="stat-value length" id="lengthDisplay">2,800</div>
                        <div style="font-size: 0.9em; color: #888;">km</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Fractal Dimension</div>
                        <div class="stat-value dimension" id="dimensionDisplay">1.25</div>
                        <div style="font-size: 0.9em; color: #888;">D (Britain)</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h2>üìä Richardson's Law (Log-Log Plot)</h2>
                <canvas id="graphCanvas" width="600" height="450"></canvas>
                <p style="margin-top: 15px; color: #aaa; text-align: center; font-size: 0.95em;">
                    The slope of this line reveals the fractal dimension!<br>
                    A steeper slope = more complex coastline = longer at small scales
                </p>
            </div>
        </div>

        <div class="explanation">
            <h2>ü§Ø The Mind-Bending Paradox</h2>

            <p>
                In 1967, mathematician <span class="highlight">Benoit Mandelbrot</span> asked a deceptively simple question:
                <em>"How long is the coast of Britain?"</em> The answer shocked the mathematical world:
                <span class="highlight">it depends on your ruler!</span>
            </p>

            <div class="paradox-box">
                <h3>üìè The Paradox</h3>
                <p>
                    Use a 100 km ruler ‚Üí Britain's coast is ~2,800 km<br>
                    Use a 50 km ruler ‚Üí It's ~3,500 km<br>
                    Use a 1 km ruler ‚Üí It's ~8,000+ km<br>
                    <strong style="color: #ff6b6b;">As the ruler shrinks, the coastline approaches INFINITY!</strong>
                </p>
            </div>

            <p>
                This happens because coastlines are <span class="highlight">fractals</span>‚Äîthey have detail at every scale.
                Zoom in on any bay, and you find smaller bays. Zoom into those, and there are even smaller ones.
                This self-similarity continues down to the level of individual grains of sand!
            </p>

            <div class="formula-box">
                <h4 style="color: #00ffff; margin-bottom: 15px;">Richardson's Empirical Law:</h4>
                <div class="formula">L(Œµ) = C √ó Œµ<sup>(1-D)</sup></div>
                <p style="color: #aaa; font-size: 0.95em;">
                    L = measured length, Œµ = ruler size, D = fractal dimension, C = constant<br>
                    When D > 1, smaller rulers give exponentially longer measurements!
                </p>
            </div>
        </div>

        <div class="history-panel">
            <h2>üìú The Spain-Portugal Border Dispute</h2>
            <p style="margin-bottom: 15px; color: #ccc;">
                Lewis Fry Richardson discovered the paradox while studying whether border length affects war probability.
                He found that Spain and Portugal reported wildly different lengths for their shared border!
            </p>
            <div class="border-dispute">
                <div class="country">
                    <div class="country-name">üáµüáπ Portugal says:</div>
                    <div class="country-length" style="color: #00ff88;">987 km</div>
                </div>
                <div class="vs">‚â†</div>
                <div class="country">
                    <div class="country-name">üá™üá∏ Spain says:</div>
                    <div class="country-length" style="color: #ff6b6b;">1,214 km</div>
                </div>
            </div>
            <p style="color: #aaa; text-align: center;">
                A 23% difference! Neither was wrong‚Äîthey just used different ruler sizes.
            </p>
        </div>

        <div class="koch-comparison">
            <h3>üî∑ The Koch Snowflake: A Perfect Fractal</h3>
            <p style="margin-bottom: 15px; color: #ccc;">
                The Koch curve has dimension D = log(4)/log(3) ‚âà 1.26‚Äîsimilar to Britain's coast!
                Each iteration adds more detail, increasing the perimeter by 4/3 while area stays bounded.
            </p>
            <canvas id="kochCanvas" width="600" height="200"></canvas>
            <div class="dimension-scale">
                <div class="dimension-item">
                    <div class="dimension-label">Straight Line</div>
                    <div class="dimension-value">D = 1.00</div>
                </div>
                <div class="dimension-item">
                    <div class="dimension-label">South Africa</div>
                    <div class="dimension-value">D ‚âà 1.02</div>
                </div>
                <div class="dimension-item">
                    <div class="dimension-label">Britain</div>
                    <div class="dimension-value">D ‚âà 1.25</div>
                </div>
                <div class="dimension-item">
                    <div class="dimension-label">Koch Curve</div>
                    <div class="dimension-value">D ‚âà 1.26</div>
                </div>
                <div class="dimension-item">
                    <div class="dimension-label">Filled Plane</div>
                    <div class="dimension-value">D = 2.00</div>
                </div>
            </div>
        </div>

        <div class="panel" style="margin-top: 30px;">
            <h2>üåç Britain's Coast at Different Scales</h2>
            <table class="measurement-table">
                <thead>
                    <tr>
                        <th>Ruler Size</th>
                        <th>Measured Length</th>
                        <th>Increase from 100km</th>
                    </tr>
                </thead>
                <tbody id="measurementTable">
                </tbody>
            </table>
        </div>
    </div>

    <script>
        const coastCanvas = document.getElementById('coastCanvas');
        const coastCtx = coastCanvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');
        const kochCanvas = document.getElementById('kochCanvas');
        const kochCtx = kochCanvas.getContext('2d');

        // State
        let rulerSize = 50;
        const FRACTAL_DIMENSION = 1.25; // Britain's coast
        const BASE_LENGTH = 2800; // km at 100km ruler
        const BASE_RULER = 100;

        // Generate a fractal-like coastline
        function generateCoastline() {
            const points = [];
            const segments = 200;
            const baseRadius = 180;
            const centerX = 300;
            const centerY = 225;

            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                let radius = baseRadius;

                // Add multiple frequencies of noise for fractal-like appearance
                radius += 30 * Math.sin(angle * 3);
                radius += 20 * Math.sin(angle * 7 + 1);
                radius += 15 * Math.sin(angle * 13 + 2);
                radius += 10 * Math.sin(angle * 23 + 3);
                radius += 5 * Math.sin(angle * 47 + 4);

                points.push({
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                });
            }
            return points;
        }

        const coastline = generateCoastline();

        // Slider
        document.getElementById('rulerSlider').addEventListener('input', function() {
            rulerSize = parseFloat(this.value);
            document.getElementById('rulerValue').textContent = rulerSize + ' km';
            updateMeasurement();
            drawCoast();
            drawGraph();
        });

        function calculateLength(ruler) {
            // Richardson's law: L(Œµ) = C √ó Œµ^(1-D)
            // At 100km ruler, length is 2800km
            // C = 2800 / (100^(1-1.25)) = 2800 / (100^-0.25) = 2800 √ó 100^0.25
            const C = BASE_LENGTH * Math.pow(BASE_RULER, FRACTAL_DIMENSION - 1);
            return C * Math.pow(ruler, 1 - FRACTAL_DIMENSION);
        }

        function updateMeasurement() {
            const length = calculateLength(rulerSize);
            document.getElementById('lengthDisplay').textContent = Math.round(length).toLocaleString();
        }

        function drawCoast() {
            const w = coastCanvas.width;
            const h = coastCanvas.height;
            coastCtx.clearRect(0, 0, w, h);

            // Background - ocean
            const oceanGrad = coastCtx.createRadialGradient(300, 225, 0, 300, 225, 300);
            oceanGrad.addColorStop(0, '#0a3060');
            oceanGrad.addColorStop(1, '#051020');
            coastCtx.fillStyle = oceanGrad;
            coastCtx.fillRect(0, 0, w, h);

            // Draw filled land mass
            coastCtx.beginPath();
            coastCtx.moveTo(coastline[0].x, coastline[0].y);
            for (let i = 1; i < coastline.length; i++) {
                coastCtx.lineTo(coastline[i].x, coastline[i].y);
            }
            coastCtx.closePath();
            coastCtx.fillStyle = '#2a5a30';
            coastCtx.fill();

            // Draw actual coastline
            coastCtx.beginPath();
            coastCtx.moveTo(coastline[0].x, coastline[0].y);
            for (let i = 1; i < coastline.length; i++) {
                coastCtx.lineTo(coastline[i].x, coastline[i].y);
            }
            coastCtx.closePath();
            coastCtx.strokeStyle = '#88cc88';
            coastCtx.lineWidth = 1;
            coastCtx.stroke();

            // Calculate measurement with current ruler
            // Map ruler size to visual segments
            const rulerPixels = rulerSize * 2; // Scale: 1km = 2 pixels
            const measurements = [];

            let currentPoint = coastline[0];
            measurements.push(currentPoint);

            for (let i = 1; i < coastline.length; i++) {
                const dist = Math.hypot(
                    coastline[i].x - currentPoint.x,
                    coastline[i].y - currentPoint.y
                );
                if (dist >= rulerPixels) {
                    // Find point at exactly rulerPixels distance
                    const ratio = rulerPixels / dist;
                    const newPoint = {
                        x: currentPoint.x + (coastline[i].x - currentPoint.x) * ratio,
                        y: currentPoint.y + (coastline[i].y - currentPoint.y) * ratio
                    };
                    measurements.push(newPoint);
                    currentPoint = newPoint;
                    i--; // Recheck this point
                }
            }

            // Draw measurement lines
            coastCtx.beginPath();
            coastCtx.moveTo(measurements[0].x, measurements[0].y);
            for (let i = 1; i < measurements.length; i++) {
                coastCtx.lineTo(measurements[i].x, measurements[i].y);
            }
            coastCtx.strokeStyle = '#ff6b6b';
            coastCtx.lineWidth = 3;
            coastCtx.stroke();

            // Draw measurement points
            for (const point of measurements) {
                coastCtx.beginPath();
                coastCtx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                coastCtx.fillStyle = '#ffd700';
                coastCtx.fill();
            }

            // Label
            coastCtx.fillStyle = '#fff';
            coastCtx.font = 'bold 16px Georgia';
            coastCtx.fillText('üá¨üáß Britain (simplified)', 20, 30);
            coastCtx.font = '14px Georgia';
            coastCtx.fillStyle = '#aaa';
            coastCtx.fillText(`Measuring with ${rulerSize}km ruler`, 20, 55);
            coastCtx.fillStyle = '#ff6b6b';
            coastCtx.fillText(`${measurements.length - 1} segments √ó ${rulerSize}km = ${((measurements.length - 1) * rulerSize).toLocaleString()}km`, 20, 80);
        }

        function drawGraph() {
            const w = graphCanvas.width;
            const h = graphCanvas.height;
            graphCtx.clearRect(0, 0, w, h);

            // Background
            graphCtx.fillStyle = '#051020';
            graphCtx.fillRect(0, 0, w, h);

            const padding = 60;
            const graphW = w - padding * 2;
            const graphH = h - padding * 2;

            // Title
            graphCtx.fillStyle = '#888';
            graphCtx.font = '14px Georgia';
            graphCtx.fillText('log(Length) vs log(Ruler Size)', padding, 25);

            // Axes
            graphCtx.strokeStyle = '#444';
            graphCtx.lineWidth = 1;
            graphCtx.beginPath();
            graphCtx.moveTo(padding, padding);
            graphCtx.lineTo(padding, h - padding);
            graphCtx.lineTo(w - padding, h - padding);
            graphCtx.stroke();

            // Axis labels
            graphCtx.fillStyle = '#888';
            graphCtx.font = '12px Georgia';
            graphCtx.textAlign = 'center';
            graphCtx.fillText('log(Œµ) - Ruler Size', w / 2, h - 15);

            graphCtx.save();
            graphCtx.translate(15, h / 2);
            graphCtx.rotate(-Math.PI / 2);
            graphCtx.fillText('log(L) - Length', 0, 0);
            graphCtx.restore();

            // Log scale ranges
            const minLogRuler = Math.log10(1);   // 1 km
            const maxLogRuler = Math.log10(100); // 100 km
            const minLogLength = Math.log10(2000);
            const maxLogLength = Math.log10(15000);

            // Draw grid
            graphCtx.strokeStyle = '#333';
            graphCtx.setLineDash([2, 4]);
            for (let r = 1; r <= 100; r *= 10) {
                const x = padding + ((Math.log10(r) - minLogRuler) / (maxLogRuler - minLogRuler)) * graphW;
                graphCtx.beginPath();
                graphCtx.moveTo(x, padding);
                graphCtx.lineTo(x, h - padding);
                graphCtx.stroke();
                graphCtx.fillStyle = '#888';
                graphCtx.textAlign = 'center';
                graphCtx.fillText(r + 'km', x, h - padding + 20);
            }
            graphCtx.setLineDash([]);

            // Draw Richardson's law line (linear in log-log space)
            graphCtx.beginPath();
            graphCtx.strokeStyle = '#00ff88';
            graphCtx.lineWidth = 3;

            for (let logR = minLogRuler; logR <= maxLogRuler; logR += 0.05) {
                const ruler = Math.pow(10, logR);
                const length = calculateLength(ruler);
                const logL = Math.log10(length);

                const x = padding + ((logR - minLogRuler) / (maxLogRuler - minLogRuler)) * graphW;
                const y = h - padding - ((logL - minLogLength) / (maxLogLength - minLogLength)) * graphH;

                if (logR === minLogRuler) graphCtx.moveTo(x, y);
                else graphCtx.lineTo(x, y);
            }
            graphCtx.stroke();

            // Mark current position
            const currentLogR = Math.log10(rulerSize);
            const currentLength = calculateLength(rulerSize);
            const currentLogL = Math.log10(currentLength);

            const markerX = padding + ((currentLogR - minLogRuler) / (maxLogRuler - minLogRuler)) * graphW;
            const markerY = h - padding - ((currentLogL - minLogLength) / (maxLogLength - minLogLength)) * graphH;

            graphCtx.beginPath();
            graphCtx.arc(markerX, markerY, 10, 0, Math.PI * 2);
            graphCtx.fillStyle = '#ffd700';
            graphCtx.fill();
            graphCtx.strokeStyle = '#fff';
            graphCtx.lineWidth = 2;
            graphCtx.stroke();

            // Show slope (= 1 - D)
            graphCtx.fillStyle = '#00ff88';
            graphCtx.font = 'bold 14px Georgia';
            graphCtx.textAlign = 'left';
            graphCtx.fillText(`Slope = 1 - D = ${(1 - FRACTAL_DIMENSION).toFixed(2)}`, padding + 10, padding + 25);
            graphCtx.fillText(`D = ${FRACTAL_DIMENSION} (fractal dimension)`, padding + 10, padding + 45);

            // Current measurement annotation
            graphCtx.fillStyle = '#ffd700';
            graphCtx.font = '12px Georgia';
            const annotation = `${rulerSize}km ‚Üí ${Math.round(currentLength).toLocaleString()}km`;
            graphCtx.fillText(annotation, markerX + 15, markerY - 5);
        }

        function drawKoch() {
            const w = kochCanvas.width;
            const h = kochCanvas.height;
            kochCtx.clearRect(0, 0, w, h);

            kochCtx.fillStyle = '#051020';
            kochCtx.fillRect(0, 0, w, h);

            // Draw Koch curve iterations
            const iterations = [0, 1, 2, 3, 4];
            const sectionWidth = w / iterations.length;

            for (let iter = 0; iter < iterations.length; iter++) {
                const centerX = sectionWidth * iter + sectionWidth / 2;
                const startX = centerX - 50;
                const endX = centerX + 50;
                const y = h / 2;

                drawKochSegment(kochCtx, startX, y, endX, y, iterations[iter]);

                // Label
                kochCtx.fillStyle = '#888';
                kochCtx.font = '11px Georgia';
                kochCtx.textAlign = 'center';
                kochCtx.fillText(`n=${iter}`, centerX, h - 15);

                const length = Math.pow(4/3, iter);
                kochCtx.fillStyle = '#00ff88';
                kochCtx.fillText(`L=${length.toFixed(2)}`, centerX, h - 30);
            }

            kochCtx.fillStyle = '#fff';
            kochCtx.font = '12px Georgia';
            kochCtx.textAlign = 'left';
            kochCtx.fillText('Koch Curve: Each iteration multiplies length by 4/3', 10, 20);
        }

        function drawKochSegment(ctx, x1, y1, x2, y2, depth) {
            if (depth === 0) {
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = '#00bfff';
                ctx.lineWidth = 2;
                ctx.stroke();
                return;
            }

            const dx = x2 - x1;
            const dy = y2 - y1;

            const x3 = x1 + dx / 3;
            const y3 = y1 + dy / 3;

            const x5 = x1 + 2 * dx / 3;
            const y5 = y1 + 2 * dy / 3;

            const x4 = (x3 + x5) / 2 - (y5 - y3) * Math.sqrt(3) / 2;
            const y4 = (y3 + y5) / 2 + (x5 - x3) * Math.sqrt(3) / 2;

            drawKochSegment(ctx, x1, y1, x3, y3, depth - 1);
            drawKochSegment(ctx, x3, y3, x4, y4, depth - 1);
            drawKochSegment(ctx, x4, y4, x5, y5, depth - 1);
            drawKochSegment(ctx, x5, y5, x2, y2, depth - 1);
        }

        function populateTable() {
            const tbody = document.getElementById('measurementTable');
            const rulers = [100, 50, 25, 10, 5, 2, 1];
            const baseLength = calculateLength(100);

            let html = '';
            for (const r of rulers) {
                const length = calculateLength(r);
                const increase = ((length / baseLength - 1) * 100).toFixed(0);
                html += `
                    <tr>
                        <td>${r} km</td>
                        <td style="color: #00ff88;">${Math.round(length).toLocaleString()} km</td>
                        <td style="color: ${increase > 0 ? '#ffd700' : '#888'};">+${increase}%</td>
                    </tr>
                `;
            }
            tbody.innerHTML = html;
        }

        // Initialize
        updateMeasurement();
        drawCoast();
        drawGraph();
        drawKoch();
        populateTable();
    </script>
</body>
</html>
