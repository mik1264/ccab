<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dragon Curve - Surprising Paradoxes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a0a1e 0%, #0f1a2e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(135deg, #9b59b6 0%, #3498db 50%, #1abc9c 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2em;
            color: #888;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
        }

        @media (max-width: 1000px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .canvas-container {
            background: #0a0a0f;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        #dragonCanvas {
            display: block;
            width: 100%;
        }

        .info-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.85em;
            font-family: monospace;
        }

        .info-overlay span {
            color: #9b59b6;
        }

        .controls {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
        }

        .control-section {
            margin-bottom: 25px;
        }

        .control-section h3 {
            color: #9b59b6;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 1px solid rgba(155,89,182,0.3);
            padding-bottom: 8px;
        }

        .control-row {
            margin-bottom: 15px;
        }

        .control-row label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 0.9em;
        }

        .control-row input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-row .value {
            text-align: right;
            font-family: monospace;
            color: #9b59b6;
            font-size: 0.9em;
        }

        .btn-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #9b59b6, #3498db);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(155,89,182,0.4);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #e0e0e0;
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
        }

        .btn-secondary.active {
            background: rgba(155,89,182,0.3);
            border: 1px solid #9b59b6;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .stat-box {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.3em;
            color: #9b59b6;
            font-family: monospace;
        }

        .stat-label {
            font-size: 0.75em;
            color: #888;
            margin-top: 4px;
        }

        .paper-fold-demo {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .fold-sequence {
            font-family: monospace;
            font-size: 0.85em;
            color: #3498db;
            word-break: break-all;
            line-height: 1.4;
            max-height: 60px;
            overflow-y: auto;
        }

        .explanation {
            margin-top: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .exp-card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            border-left: 4px solid #9b59b6;
        }

        .exp-card h3 {
            color: #9b59b6;
            margin-bottom: 10px;
        }

        .exp-card p {
            color: #bbb;
            line-height: 1.6;
        }

        .lsystem {
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 1em;
            text-align: center;
            margin: 10px 0;
            color: #3498db;
        }

        .back-link {
            display: inline-block;
            color: #9b59b6;
            text-decoration: none;
            margin-bottom: 20px;
            transition: transform 0.2s;
        }

        .back-link:hover {
            transform: translateX(-5px);
        }

        .color-scheme-btns {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Paradoxes</a>

        <header>
            <h1>The Dragon Curve</h1>
            <p class="subtitle">Infinite complexity from folding paper</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="dragonCanvas" width="900" height="700"></canvas>
                <div class="info-overlay">
                    <div>Iteration: <span id="iterLabel">10</span></div>
                    <div>Segments: <span id="segmentCount">1024</span></div>
                    <div>Total Length: <span id="totalLength">—</span></div>
                </div>
            </div>

            <div class="controls">
                <div class="control-section">
                    <h3>Iterations</h3>
                    <div class="control-row">
                        <label>Folds (Iterations)</label>
                        <input type="range" id="iterSlider" min="1" max="18" value="10">
                        <div class="value">n = <span id="iterValue">10</span></div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Animation</h3>
                    <div class="btn-group">
                        <button class="btn-primary" id="animateBtn">▶ Animate Growth</button>
                        <button class="btn-secondary" id="resetBtn">Reset</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Variants</h3>
                    <div class="btn-group">
                        <button class="btn-secondary active" data-variant="heighway">Heighway</button>
                        <button class="btn-secondary" data-variant="twindragon">Twindragon</button>
                        <button class="btn-secondary" data-variant="terdragon">Terdragon</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Color Scheme</h3>
                    <div class="color-scheme-btns">
                        <button class="btn-secondary active" data-color="rainbow">Rainbow</button>
                        <button class="btn-secondary" data-color="fire">Fire</button>
                        <button class="btn-secondary" data-color="ice">Ice</button>
                        <button class="btn-secondary" data-color="mono">Mono</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="stat-value" id="statSegments">1024</div>
                            <div class="stat-label">Segments</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="statDimension">2</div>
                            <div class="stat-label">Fractal Dim</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="statTurns">—</div>
                            <div class="stat-label">Total Turns</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="statRatio">√2</div>
                            <div class="stat-label">Scale Ratio</div>
                        </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Paper Fold Sequence</h3>
                    <div class="paper-fold-demo">
                        <div class="fold-sequence" id="foldSequence">R R L R R L L...</div>
                    </div>
                    <p style="font-size: 0.75em; color: #666; margin-top: 8px;">R = Right turn, L = Left turn</p>
                </div>
            </div>
        </div>

        <div class="explanation">
            <div class="exp-card">
                <h3>Paper Folding Origin</h3>
                <p>The dragon curve was discovered in 1966 by NASA physicist John Heighway while folding paper strips. Fold a strip in half repeatedly (always in the same direction), then unfold with 90° turns at each crease. The resulting path is the dragon curve—infinite complexity from the simplest possible operation!</p>
            </div>

            <div class="exp-card">
                <h3>L-System Rules</h3>
                <div class="lsystem">
                    F → F + G<br>
                    G → F − G
                </div>
                <p>The curve can be generated using a Lindenmayer system (L-system). F and G both mean "draw forward", + means turn right 90°, − means turn left 90°. After n iterations, the string describes exactly how to draw the n-th order dragon curve.</p>
            </div>

            <div class="exp-card">
                <h3>The Space-Filling Paradox</h3>
                <p>Despite being a curve (1D), the dragon curve has fractal dimension exactly 2—it's a space-filling curve! As iterations increase, it fills a bounded region completely. Yet it never crosses itself, always maintaining a single connected path. How can a line fill an area?</p>
            </div>

            <div class="exp-card">
                <h3>Self-Similarity</h3>
                <p>The dragon curve contains two copies of itself at each scale: one rotated 45° clockwise and scaled by 1/√2, one rotated 135° counterclockwise. This √2 ratio appears everywhere—in the paper folding, the area calculations, and even the curve's bounding box proportions.</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('dragonCanvas');
        const ctx = canvas.getContext('2d');

        let iterations = 10;
        let colorScheme = 'rainbow';
        let variant = 'heighway';
        let isAnimating = false;
        let animationFrame = null;

        // Color palettes
        const colorPalettes = {
            rainbow: (t) => `hsl(${t * 360}, 80%, 55%)`,
            fire: (t) => `hsl(${t * 60}, 90%, ${30 + t * 40}%)`,
            ice: (t) => `hsl(${200 + t * 40}, 70%, ${40 + t * 30}%)`,
            mono: (t) => `rgb(${155 + t * 100}, ${89 + t * 100}, ${182 + t * 73})`
        };

        // Generate dragon curve turn sequence using the paper folding algorithm
        function generateFoldSequence(n) {
            if (n === 0) return [];

            let sequence = [1]; // 1 = R (right), -1 = L (left)

            for (let i = 1; i < n; i++) {
                const newSequence = [...sequence, 1];
                for (let j = sequence.length - 1; j >= 0; j--) {
                    newSequence.push(-sequence[j]);
                }
                sequence = newSequence;
            }

            return sequence;
        }

        // Generate terdragon sequence
        function generateTerdragonSequence(n) {
            // Terdragon: uses 120° turns
            if (n === 0) return [];
            let seq = [1];
            for (let i = 1; i < n; i++) {
                const newSeq = [];
                for (const turn of seq) {
                    newSeq.push(turn, 1, -turn);
                }
                seq = newSeq;
            }
            return seq;
        }

        // Draw dragon curve
        function drawDragon(maxSegments = -1) {
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let sequence;
            let angle;
            let turnAngle;

            if (variant === 'terdragon') {
                sequence = generateTerdragonSequence(iterations);
                angle = 0;
                turnAngle = Math.PI * 2 / 3; // 120°
            } else {
                sequence = generateFoldSequence(iterations);
                angle = 0;
                turnAngle = Math.PI / 2; // 90°
            }

            if (maxSegments > 0 && maxSegments < sequence.length + 1) {
                sequence = sequence.slice(0, maxSegments - 1);
            }

            // Calculate bounding box first
            let points = [{x: 0, y: 0}];
            let x = 0, y = 0;
            let tempAngle = angle;

            for (const turn of sequence) {
                x += Math.cos(tempAngle);
                y += Math.sin(tempAngle);
                points.push({x, y});
                tempAngle += turn * turnAngle;
            }

            // For twindragon, add mirrored copy
            if (variant === 'twindragon') {
                const mirrorPoints = [];
                x = 0; y = 0;
                tempAngle = Math.PI; // Start facing opposite direction
                mirrorPoints.push({x: 0, y: 0});

                for (const turn of sequence) {
                    x += Math.cos(tempAngle);
                    y += Math.sin(tempAngle);
                    mirrorPoints.push({x, y});
                    tempAngle += turn * turnAngle;
                }
                points = points.concat(mirrorPoints);
            }

            // Find bounds
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const p of points) {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            }

            // Calculate scale and offset
            const width = maxX - minX || 1;
            const height = maxY - minY || 1;
            const padding = 50;
            const scaleX = (canvas.width - 2 * padding) / width;
            const scaleY = (canvas.height - 2 * padding) / height;
            const scale = Math.min(scaleX, scaleY);
            const offsetX = padding + (canvas.width - 2 * padding - width * scale) / 2 - minX * scale;
            const offsetY = padding + (canvas.height - 2 * padding - height * scale) / 2 - minY * scale;

            // Draw the curve
            const getColor = colorPalettes[colorScheme];
            const totalSegments = sequence.length + 1;

            // Draw main dragon
            ctx.lineWidth = Math.max(1, 3 - iterations * 0.15);
            x = 0; y = 0;
            tempAngle = angle;

            for (let i = 0; i < sequence.length; i++) {
                const nx = x + Math.cos(tempAngle);
                const ny = y + Math.sin(tempAngle);

                ctx.beginPath();
                ctx.strokeStyle = getColor(i / totalSegments);
                ctx.moveTo(x * scale + offsetX, y * scale + offsetY);
                ctx.lineTo(nx * scale + offsetX, ny * scale + offsetY);
                ctx.stroke();

                x = nx; y = ny;
                tempAngle += sequence[i] * turnAngle;
            }

            // Draw final segment
            if (sequence.length > 0) {
                const nx = x + Math.cos(tempAngle);
                const ny = y + Math.sin(tempAngle);
                ctx.beginPath();
                ctx.strokeStyle = getColor(1);
                ctx.moveTo(x * scale + offsetX, y * scale + offsetY);
                ctx.lineTo(nx * scale + offsetX, ny * scale + offsetY);
                ctx.stroke();
            }

            // Draw twindragon mirror if needed
            if (variant === 'twindragon') {
                x = 0; y = 0;
                tempAngle = Math.PI;

                for (let i = 0; i < sequence.length; i++) {
                    const nx = x + Math.cos(tempAngle);
                    const ny = y + Math.sin(tempAngle);

                    ctx.beginPath();
                    ctx.strokeStyle = getColor(i / totalSegments);
                    ctx.moveTo(x * scale + offsetX, y * scale + offsetY);
                    ctx.lineTo(nx * scale + offsetX, ny * scale + offsetY);
                    ctx.stroke();

                    x = nx; y = ny;
                    tempAngle += sequence[i] * turnAngle;
                }

                const nx = x + Math.cos(tempAngle);
                const ny = y + Math.sin(tempAngle);
                ctx.beginPath();
                ctx.strokeStyle = getColor(1);
                ctx.moveTo(x * scale + offsetX, y * scale + offsetY);
                ctx.lineTo(nx * scale + offsetX, ny * scale + offsetY);
                ctx.stroke();
            }
        }

        function updateStats() {
            const numSegments = Math.pow(2, iterations);
            document.getElementById('iterLabel').textContent = iterations;
            document.getElementById('iterValue').textContent = iterations;
            document.getElementById('segmentCount').textContent = numSegments.toLocaleString();
            document.getElementById('statSegments').textContent = numSegments.toLocaleString();
            document.getElementById('statTurns').textContent = (numSegments - 1).toLocaleString();

            // Fractal dimension
            if (variant === 'terdragon') {
                document.getElementById('statDimension').textContent = 'log₃4 ≈ 1.26';
                document.getElementById('statRatio').textContent = '√3';
            } else {
                document.getElementById('statDimension').textContent = '2';
                document.getElementById('statRatio').textContent = '√2';
            }

            // Update fold sequence display
            const sequence = generateFoldSequence(Math.min(iterations, 8));
            const seqStr = sequence.map(t => t > 0 ? 'R' : 'L').join(' ');
            document.getElementById('foldSequence').textContent = seqStr + (iterations > 8 ? '...' : '');

            // Total length (relative to initial segment)
            document.getElementById('totalLength').textContent = numSegments.toLocaleString() + ' units';
        }

        function animate() {
            if (!isAnimating) return;

            let currentSegment = 1;
            const totalSegments = Math.pow(2, iterations);
            const animateBtn = document.getElementById('animateBtn');

            function step() {
                if (!isAnimating) {
                    animateBtn.textContent = '▶ Animate Growth';
                    return;
                }

                drawDragon(currentSegment);

                currentSegment += Math.max(1, Math.floor(totalSegments / 200));

                if (currentSegment <= totalSegments) {
                    animationFrame = requestAnimationFrame(step);
                } else {
                    isAnimating = false;
                    animateBtn.textContent = '▶ Animate Growth';
                    drawDragon();
                }
            }

            animateBtn.textContent = '⏸ Stop';
            step();
        }

        // Event listeners
        document.getElementById('iterSlider').addEventListener('input', (e) => {
            iterations = parseInt(e.target.value);
            updateStats();
            drawDragon();
        });

        document.getElementById('animateBtn').addEventListener('click', () => {
            if (isAnimating) {
                isAnimating = false;
                if (animationFrame) cancelAnimationFrame(animationFrame);
            } else {
                isAnimating = true;
                animate();
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            isAnimating = false;
            if (animationFrame) cancelAnimationFrame(animationFrame);
            iterations = 10;
            document.getElementById('iterSlider').value = 10;
            updateStats();
            drawDragon();
        });

        // Variant buttons
        document.querySelectorAll('[data-variant]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-variant]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                variant = btn.dataset.variant;
                updateStats();
                drawDragon();
            });
        });

        // Color scheme buttons
        document.querySelectorAll('[data-color]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-color]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                colorScheme = btn.dataset.color;
                drawDragon();
            });
        });

        // Initial render
        updateStats();
        drawDragon();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
