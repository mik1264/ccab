<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Coastline Paradox - Surprising Paradoxes - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%);
            min-height: 100vh;
            color: var(--dark-moss);
            line-height: 1.7;
        }
        .organic-shape {
            position: fixed;
            border-radius: 60% 40% 50% 50% / 50% 60% 40% 50%;
            opacity: 0.12;
            z-index: 0;
            animation: morph 30s ease-in-out infinite;
        }
        .shape-1 {
            width: 600px;
            height: 600px;
            background: linear-gradient(135deg, var(--sage), var(--moss));
            top: -200px;
            right: -150px;
        }
        .shape-2 {
            width: 500px;
            height: 500px;
            background: linear-gradient(135deg, var(--earth), var(--terracotta));
            bottom: -150px;
            left: -150px;
            animation-delay: -15s;
        }
        @keyframes morph {
            0%, 100% { border-radius: 60% 40% 50% 50% / 50% 60% 40% 50%; }
            25% { border-radius: 50% 60% 40% 50% / 40% 50% 60% 50%; }
            50% { border-radius: 40% 50% 60% 50% / 50% 40% 50% 60%; }
            75% { border-radius: 50% 40% 50% 60% / 60% 50% 40% 50%; }
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px 80px;
            position: relative;
            z-index: 1;
        }
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
            margin-bottom: 30px;
            padding: 10px 20px;
            background: rgba(255,255,255,0.6);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            transition: all 0.3s ease;
        }
        .back-link:hover {
            background: rgba(255,255,255,0.9);
            transform: translateX(-5px);
        }
        h1 {
            font-family: 'Lora', serif;
            font-size: 2.8rem;
            font-weight: 600;
            color: var(--moss);
            margin-bottom: 20px;
            line-height: 1.2;
        }
        .subtitle {
            font-size: 1.3rem;
            color: var(--terracotta);
            margin-bottom: 40px;
            font-weight: 500;
        }
        .badge {
            display: inline-block;
            background: linear-gradient(135deg, #ffd700, #ffb700);
            color: #1a1a2e;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 25px;
        }
        .card {
            background: rgba(255,255,255,0.7);
            backdrop-filter: blur(15px);
            border-radius: 24px;
            padding: 35px;
            margin-bottom: 35px;
            border: 1px solid rgba(138,154,91,0.2);
            box-shadow: 0 10px 40px rgba(0,0,0,0.08);
        }
        .card h2 {
            font-family: 'Lora', serif;
            font-size: 1.6rem;
            color: var(--moss);
            margin-bottom: 20px;
        }
        .card p {
            color: #555;
            margin-bottom: 18px;
        }
        .card p:last-child { margin-bottom: 0; }
        .highlight {
            background: linear-gradient(120deg, rgba(221,161,94,0.2) 0%, rgba(221,161,94,0.1) 100%);
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: 600;
            color: var(--terracotta);
        }

        /* Simulation */
        .simulation-container {
            background: linear-gradient(180deg, #1a3a5c 0%, #0d2840 100%);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 35px;
            box-shadow: 0 15px 50px rgba(0,0,0,0.2);
        }
        .simulation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .simulation-title {
            color: #fff;
            font-family: 'Lora', serif;
            font-size: 1.3rem;
        }
        #coastCanvas {
            display: block;
            width: 100%;
            border-radius: 12px;
            background: linear-gradient(180deg, #87CEEB 0%, #4a90c2 30%, #2d6a9f 100%);
        }
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 20px;
        }
        .slider-group {
            flex: 1;
            min-width: 200px;
        }
        .slider-label {
            color: rgba(255,255,255,0.8);
            font-size: 0.85rem;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }
        .slider-value {
            color: #4ecdc4;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.2);
            -webkit-appearance: none;
            cursor: pointer;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(78,205,196,0.4);
        }
        .btn {
            background: linear-gradient(135deg, var(--earth) 0%, var(--terracotta) 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-family: 'Nunito', sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(188,108,37,0.4);
        }
        .results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            margin-top: 25px;
        }
        .result-card {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 18px;
            text-align: center;
        }
        .result-label {
            color: rgba(255,255,255,0.7);
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }
        .result-value {
            font-size: 1.6rem;
            font-weight: 700;
            font-family: 'Courier New', monospace;
            color: #4ecdc4;
        }
        .result-unit {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.5);
        }

        /* Chart */
        .chart-container {
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            padding: 20px;
            margin-top: 25px;
        }
        .chart-title {
            color: #fff;
            font-size: 1rem;
            margin-bottom: 15px;
            text-align: center;
        }
        #lengthChart {
            width: 100%;
            height: 200px;
        }

        /* Quote */
        .quote {
            border-left: 4px solid var(--earth);
            padding-left: 25px;
            margin: 25px 0;
            font-style: italic;
            color: #666;
        }
        .quote-author {
            font-style: normal;
            font-weight: 600;
            color: var(--moss);
            margin-top: 10px;
        }

        /* Insight box */
        .insight-box {
            background: linear-gradient(135deg, rgba(138,154,91,0.15) 0%, rgba(96,108,56,0.1) 100%);
            border: 2px solid var(--sage);
            border-radius: 16px;
            padding: 25px;
            margin: 25px 0;
        }
        .insight-box h3 {
            color: var(--moss);
            font-family: 'Lora', serif;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Examples grid */
        .examples-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .example-card {
            background: rgba(255,255,255,0.5);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
        }
        .example-name {
            font-weight: 600;
            color: var(--moss);
            margin-bottom: 8px;
        }
        .example-short, .example-long {
            font-size: 0.85rem;
            color: #666;
        }
        .example-short span, .example-long span {
            font-weight: 700;
            color: var(--terracotta);
        }

        /* Formula */
        .formula {
            background: rgba(0,0,0,0.03);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            color: var(--dark-moss);
        }

        /* Fractal demo */
        .fractal-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 20px 0;
        }
        .fractal-step {
            background: #1a3a5c;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }
        .fractal-step canvas {
            width: 100%;
            height: 80px;
            display: block;
            border-radius: 4px;
            margin-bottom: 8px;
        }
        .fractal-step .label {
            font-size: 0.75rem;
            color: #888;
        }
        .fractal-step .length {
            font-size: 0.9rem;
            color: #4ecdc4;
            font-weight: 700;
        }

        .footer {
            text-align: center;
            padding-top: 30px;
            color: #888;
            font-size: 0.85rem;
        }
        .footer a { color: var(--moss); }

        @media (max-width: 600px) {
            h1 { font-size: 2rem; }
            .card { padding: 25px; }
            .simulation-container { padding: 20px; }
            .fractal-container { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>
    <div class="organic-shape shape-1"></div>
    <div class="organic-shape shape-2"></div>

    <main class="container">
        <a href="index.html" class="back-link">&#8592; Back to Paradoxes</a>

        <span class="badge">Fractal Geometry</span>
        <h1>The Coastline Paradox</h1>
        <p class="subtitle">How long is the coast of Britain? It depends on how you measure it&#8212;and the answer might be infinite.</p>

        <!-- Main Simulation -->
        <div class="simulation-container">
            <div class="simulation-header">
                <h2 class="simulation-title">Measure the Coastline</h2>
            </div>

            <canvas id="coastCanvas" width="800" height="400"></canvas>

            <div class="controls">
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Ruler Length</span>
                        <span class="slider-value" id="rulerValue">50 km</span>
                    </div>
                    <input type="range" id="rulerSlider" min="5" max="100" value="50">
                </div>
                <button class="btn" id="animateBtn">Animate Measurement</button>
            </div>

            <div class="results">
                <div class="result-card">
                    <div class="result-label">Ruler Length</div>
                    <div class="result-value" id="rulerResult">50</div>
                    <div class="result-unit">km</div>
                </div>
                <div class="result-card">
                    <div class="result-label">Segments Used</div>
                    <div class="result-value" id="segmentsResult">0</div>
                    <div class="result-unit">rulers</div>
                </div>
                <div class="result-card">
                    <div class="result-label">Total Length</div>
                    <div class="result-value" id="lengthResult">0</div>
                    <div class="result-unit">km</div>
                </div>
                <div class="result-card">
                    <div class="result-label">Increase</div>
                    <div class="result-value" id="increaseResult">&#8212;</div>
                    <div class="result-unit">%</div>
                </div>
            </div>

            <div class="chart-container">
                <div class="chart-title">Length vs. Ruler Size (Log-Log Plot)</div>
                <canvas id="lengthChart"></canvas>
            </div>
        </div>

        <!-- The Paradox -->
        <div class="card">
            <h2>The Measurement Paradox</h2>
            <p>In 1967, mathematician <strong>Benoit Mandelbrot</strong> asked a deceptively simple question: <span class="highlight">"How long is the coast of Britain?"</span></p>
            <p>The answer depends entirely on the length of ruler you use to measure it:</p>
            <ul style="margin-left: 25px; color: #555; margin-bottom: 18px;">
                <li>With a 100 km ruler: approximately 2,800 km</li>
                <li>With a 50 km ruler: approximately 3,400 km</li>
                <li>With a 1 km ruler: approximately 17,820 km</li>
                <li>With a 1 m ruler: much, much longer...</li>
            </ul>
            <p>As your ruler gets smaller, you capture more and more detail&#8212;every inlet, bay, rock, and pebble&#8212;and the measured length <span class="highlight">keeps increasing without bound</span>.</p>
        </div>

        <!-- Why It Happens -->
        <div class="card">
            <h2>Why Coastlines Are Infinite</h2>
            <p>Coastlines are <strong>fractal</strong> in nature. Unlike smooth geometric curves, they have detail at every scale of magnification:</p>

            <div class="insight-box">
                <h3>&#128270; The Fractal Property</h3>
                <p>Zoom into any section of coastline and you'll find the same rough, jagged complexity. Bays contain smaller bays, which contain inlets, which contain rocks, which contain crevices... the pattern repeats at ever-smaller scales.</p>
            </div>

            <p>A straight line has dimension 1. A filled square has dimension 2. But a coastline has a <strong>fractional dimension</strong> between 1 and 2:</p>

            <div class="formula">
                D = log(N) / log(1/s)
            </div>
            <p style="text-align: center; color: #888; font-size: 0.9rem;">Where D is fractal dimension, N is the number of segments, and s is the scale factor</p>

            <p>Britain's coastline has a fractal dimension of approximately <strong>1.25</strong>&#8212;more complex than a line but not quite filling a plane.</p>
        </div>

        <!-- Koch Snowflake Demo -->
        <div class="card">
            <h2>The Koch Curve: A Perfect Fractal Coastline</h2>
            <p>The Koch curve demonstrates the coastline paradox mathematically. Each iteration replaces straight segments with a zig-zag pattern, multiplying the length by 4/3:</p>

            <div class="fractal-container">
                <div class="fractal-step">
                    <canvas id="koch0"></canvas>
                    <div class="label">Iteration 0</div>
                    <div class="length">L = 1</div>
                </div>
                <div class="fractal-step">
                    <canvas id="koch1"></canvas>
                    <div class="label">Iteration 1</div>
                    <div class="length">L = 1.33</div>
                </div>
                <div class="fractal-step">
                    <canvas id="koch2"></canvas>
                    <div class="label">Iteration 2</div>
                    <div class="length">L = 1.78</div>
                </div>
                <div class="fractal-step">
                    <canvas id="koch3"></canvas>
                    <div class="label">Iteration 3</div>
                    <div class="length">L = 2.37</div>
                </div>
            </div>

            <p>After <em>n</em> iterations, the length is (4/3)<sup>n</sup>. As n approaches infinity, so does the length&#8212;yet the curve still fits in a finite area!</p>
        </div>

        <!-- Real Examples -->
        <div class="card">
            <h2>Real-World Measurements</h2>
            <p>Different countries have reported wildly different coastline lengths depending on their measurement methodology:</p>

            <div class="examples-grid">
                <div class="example-card">
                    <div class="example-name">Norway</div>
                    <div class="example-short">Straight: <span>2,650 km</span></div>
                    <div class="example-long">Detailed: <span>100,915 km</span></div>
                </div>
                <div class="example-card">
                    <div class="example-name">Britain</div>
                    <div class="example-short">Large ruler: <span>2,800 km</span></div>
                    <div class="example-long">Small ruler: <span>17,820 km</span></div>
                </div>
                <div class="example-card">
                    <div class="example-name">Australia</div>
                    <div class="example-short">Simple: <span>12,500 km</span></div>
                    <div class="example-long">Detailed: <span>66,530 km</span></div>
                </div>
                <div class="example-card">
                    <div class="example-name">Canada</div>
                    <div class="example-short">World Factbook: <span>202,080 km</span></div>
                    <div class="example-long">Longest in world!</div>
                </div>
            </div>

            <p style="margin-top: 20px;">Norway's fjord-carved coast is particularly fractal&#8212;its detailed measurement is <strong>38 times</strong> its straight-line approximation!</p>
        </div>

        <!-- Mandelbrot Quote -->
        <div class="card">
            <h2>Mandelbrot's Insight</h2>

            <div class="quote">
                "Clouds are not spheres, mountains are not cones, coastlines are not circles, and bark is not smooth, nor does lightning travel in a straight line."
                <div class="quote-author">&#8212; Benoit Mandelbrot, "The Fractal Geometry of Nature" (1982)</div>
            </div>

            <p>Mandelbrot's 1967 paper "How Long Is the Coast of Britain?" didn't just identify a measurement problem&#8212;it helped launch an entirely new field: <strong>fractal geometry</strong>.</p>
            <p>This work showed that classical geometry (smooth lines, circles, planes) fails to describe most natural phenomena. Nature is rough, jagged, and self-similar at multiple scales.</p>
        </div>

        <!-- Practical Implications -->
        <div class="card">
            <h2>Why This Matters</h2>

            <div class="insight-box">
                <h3>&#127758; Territorial Waters</h3>
                <p>International law grants countries exclusive economic zones extending from their coastlines. But if coastline length is undefined, how do you define maritime boundaries? In practice, a standard measurement resolution must be agreed upon.</p>
            </div>

            <p><strong>Other implications:</strong></p>
            <ul style="margin-left: 25px; color: #555;">
                <li><strong>Ecology:</strong> Species richness correlates with coastline complexity&#8212;more fractal = more habitats</li>
                <li><strong>Engineering:</strong> Erosion, flooding, and wave dynamics depend on fractal coastline geometry</li>
                <li><strong>Computer Graphics:</strong> Fractal algorithms generate realistic coastlines for maps and games</li>
                <li><strong>Lung Design:</strong> The human lung surface is fractal&#8212;packing enormous surface area into a small volume</li>
            </ul>
        </div>

        <!-- Resolution -->
        <div class="card">
            <h2>The Deeper Insight</h2>
            <p>The coastline paradox reveals something profound: <span class="highlight">measurement is not absolute</span>.</p>
            <p>For smooth objects like circles and lines, different measuring methods converge to the same answer. But for fractal objects&#8212;which include most of nature&#8212;the measured value depends fundamentally on the scale of measurement.</p>
            <p>This challenges our intuition that physical quantities have definite values waiting to be discovered. Instead, the coastline paradox suggests that "length" is not a property of the coastline alone, but a property of the interaction between the coastline and our method of measuring it.</p>
        </div>

        <div class="footer">
            <p>Sources: <a href="https://en.wikipedia.org/wiki/Coastline_paradox" target="_blank">Wikipedia</a>,
            <a href="https://mathworld.wolfram.com/CoastlineParadox.html" target="_blank">Wolfram MathWorld</a>,
            Mandelbrot, B. (1967). "How Long Is the Coast of Britain?"</p>
            <p style="margin-top: 10px;">Part of <a href="../index.html">CCAB</a> &#183; Surprising Paradoxes Collection</p>
        </div>
    </main>

    <script>
        // === COASTLINE SIMULATION ===
        const canvas = document.getElementById('coastCanvas');
        const ctx = canvas.getContext('2d');

        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';

        const W = rect.width;
        const H = rect.height;

        // Generate a fractal coastline using midpoint displacement
        function generateCoastline(iterations) {
            let points = [
                { x: 50, y: H * 0.5 },
                { x: W - 50, y: H * 0.5 }
            ];

            for (let i = 0; i < iterations; i++) {
                const newPoints = [];
                for (let j = 0; j < points.length - 1; j++) {
                    const p1 = points[j];
                    const p2 = points[j + 1];
                    const mid = {
                        x: (p1.x + p2.x) / 2,
                        y: (p1.y + p2.y) / 2
                    };
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const roughness = 0.5 * Math.pow(0.65, i);
                    mid.y += (Math.random() - 0.5) * len * roughness;
                    mid.y = Math.max(H * 0.2, Math.min(H * 0.8, mid.y));
                    newPoints.push(p1, mid);
                }
                newPoints.push(points[points.length - 1]);
                points = newPoints;
            }

            return points;
        }

        const coastline = generateCoastline(8);

        // Measure coastline with given ruler length (in pixels)
        function measureCoastline(rulerLength) {
            const segments = [];
            let currentPoint = { ...coastline[0] };
            let totalLength = 0;

            while (true) {
                // Find the farthest point on the coastline within ruler distance
                let bestPoint = null;
                let bestIndex = -1;

                for (let i = 0; i < coastline.length; i++) {
                    const p = coastline[i];
                    const dx = p.x - currentPoint.x;
                    const dy = p.y - currentPoint.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist <= rulerLength && dist > 1) {
                        if (p.x > currentPoint.x + 1) {
                            bestPoint = p;
                            bestIndex = i;
                        }
                    }
                }

                if (!bestPoint || bestPoint.x >= coastline[coastline.length - 1].x - 10) {
                    // Reach to end
                    segments.push({ from: currentPoint, to: coastline[coastline.length - 1] });
                    const dx = coastline[coastline.length - 1].x - currentPoint.x;
                    const dy = coastline[coastline.length - 1].y - currentPoint.y;
                    totalLength += Math.sqrt(dx * dx + dy * dy);
                    break;
                }

                segments.push({ from: { ...currentPoint }, to: { ...bestPoint } });
                const dx = bestPoint.x - currentPoint.x;
                const dy = bestPoint.y - currentPoint.y;
                totalLength += Math.sqrt(dx * dx + dy * dy);
                currentPoint = { ...bestPoint };
            }

            return { segments, totalLength };
        }

        let currentRulerLength = 50;
        let measurements = [];
        let baselineLength = null;
        let animating = false;
        let animStep = 0;

        function draw(highlightSegments = null, animProgress = 1) {
            ctx.clearRect(0, 0, W, H);

            // Sky gradient
            const sky = ctx.createLinearGradient(0, 0, 0, H);
            sky.addColorStop(0, '#87CEEB');
            sky.addColorStop(0.5, '#4a90c2');
            sky.addColorStop(1, '#2d6a9f');
            ctx.fillStyle = sky;
            ctx.fillRect(0, 0, W, H);

            // Water
            ctx.fillStyle = 'rgba(30, 80, 120, 0.5)';
            ctx.beginPath();
            ctx.moveTo(0, H);
            for (const p of coastline) {
                ctx.lineTo(p.x, p.y);
            }
            ctx.lineTo(W, H);
            ctx.closePath();
            ctx.fill();

            // Land
            ctx.fillStyle = '#5d7a3a';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, coastline[0].y);
            for (const p of coastline) {
                ctx.lineTo(p.x, p.y);
            }
            ctx.lineTo(W, coastline[coastline.length - 1].y);
            ctx.lineTo(W, 0);
            ctx.closePath();
            ctx.fill();

            // Coastline detail
            ctx.strokeStyle = '#3d5a2a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(coastline[0].x, coastline[0].y);
            for (const p of coastline) {
                ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();

            // Draw measurement segments
            if (highlightSegments) {
                const numToDraw = Math.floor(highlightSegments.length * animProgress);
                for (let i = 0; i < numToDraw; i++) {
                    const seg = highlightSegments[i];
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(seg.from.x, seg.from.y);
                    ctx.lineTo(seg.to.x, seg.to.y);
                    ctx.stroke();

                    // Endpoints
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(seg.from.x, seg.from.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                if (numToDraw > 0) {
                    const lastSeg = highlightSegments[numToDraw - 1];
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(lastSeg.to.x, lastSeg.to.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Labels
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Nunito';
            ctx.fillText('LAND', 60, 40);
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.fillText('SEA', 60, H - 30);
        }

        function updateMeasurement(animate = false) {
            const rulerPixels = currentRulerLength * 2; // Scale
            const { segments, totalLength } = measureCoastline(rulerPixels);

            // Convert to "km" (scaled)
            const lengthKm = Math.round(totalLength / 2);

            if (baselineLength === null) {
                baselineLength = lengthKm;
            }

            const increase = baselineLength > 0 ? ((lengthKm - baselineLength) / baselineLength * 100) : 0;

            document.getElementById('rulerResult').textContent = currentRulerLength;
            document.getElementById('segmentsResult').textContent = segments.length;
            document.getElementById('lengthResult').textContent = lengthKm.toLocaleString();
            document.getElementById('increaseResult').textContent = increase > 0 ? '+' + increase.toFixed(0) : '&#8212;';

            // Store measurement
            measurements.push({ ruler: currentRulerLength, length: lengthKm });

            if (animate) {
                animating = true;
                animStep = 0;
                const startTime = performance.now();
                function animFrame(time) {
                    const elapsed = time - startTime;
                    const progress = Math.min(1, elapsed / 2000);
                    draw(segments, progress);
                    if (progress < 1) {
                        requestAnimationFrame(animFrame);
                    } else {
                        animating = false;
                    }
                }
                requestAnimationFrame(animFrame);
            } else {
                draw(segments, 1);
            }

            drawChart();
        }

        // Chart
        function drawChart() {
            const chartCanvas = document.getElementById('lengthChart');
            const chartCtx = chartCanvas.getContext('2d');

            const cRect = chartCanvas.getBoundingClientRect();
            chartCanvas.width = cRect.width * dpr;
            chartCanvas.height = cRect.height * dpr;
            chartCtx.scale(dpr, dpr);

            const cW = cRect.width;
            const cH = cRect.height;
            const padding = 50;

            chartCtx.clearRect(0, 0, cW, cH);

            // Background
            chartCtx.fillStyle = 'rgba(0,0,0,0.3)';
            chartCtx.fillRect(0, 0, cW, cH);

            if (measurements.length < 2) return;

            // Axes
            chartCtx.strokeStyle = 'rgba(255,255,255,0.3)';
            chartCtx.lineWidth = 1;
            chartCtx.beginPath();
            chartCtx.moveTo(padding, padding);
            chartCtx.lineTo(padding, cH - padding);
            chartCtx.lineTo(cW - padding, cH - padding);
            chartCtx.stroke();

            // Labels
            chartCtx.fillStyle = 'rgba(255,255,255,0.7)';
            chartCtx.font = '11px Nunito';
            chartCtx.textAlign = 'center';
            chartCtx.fillText('Ruler Length (log)', cW / 2, cH - 10);
            chartCtx.save();
            chartCtx.translate(15, cH / 2);
            chartCtx.rotate(-Math.PI / 2);
            chartCtx.fillText('Coast Length (log)', 0, 0);
            chartCtx.restore();

            // Plot points (log-log)
            const minRuler = Math.min(...measurements.map(m => m.ruler));
            const maxRuler = Math.max(...measurements.map(m => m.ruler));
            const minLength = Math.min(...measurements.map(m => m.length));
            const maxLength = Math.max(...measurements.map(m => m.length));

            const logMinR = Math.log10(minRuler);
            const logMaxR = Math.log10(maxRuler);
            const logMinL = Math.log10(minLength);
            const logMaxL = Math.log10(maxLength);

            chartCtx.fillStyle = '#4ecdc4';
            for (const m of measurements) {
                const logR = Math.log10(m.ruler);
                const logL = Math.log10(m.length);
                const x = padding + ((logR - logMinR) / (logMaxR - logMinR || 1)) * (cW - 2 * padding);
                const y = cH - padding - ((logL - logMinL) / (logMaxL - logMinL || 1)) * (cH - 2 * padding);

                chartCtx.beginPath();
                chartCtx.arc(x, y, 5, 0, Math.PI * 2);
                chartCtx.fill();
            }

            // Trend line
            if (measurements.length >= 2) {
                chartCtx.strokeStyle = '#ff6b6b';
                chartCtx.lineWidth = 2;
                chartCtx.beginPath();
                for (let i = 0; i < measurements.length; i++) {
                    const m = measurements[i];
                    const logR = Math.log10(m.ruler);
                    const logL = Math.log10(m.length);
                    const x = padding + ((logR - logMinR) / (logMaxR - logMinR || 1)) * (cW - 2 * padding);
                    const y = cH - padding - ((logL - logMinL) / (logMaxL - logMinL || 1)) * (cH - 2 * padding);
                    if (i === 0) chartCtx.moveTo(x, y);
                    else chartCtx.lineTo(x, y);
                }
                chartCtx.stroke();
            }
        }

        // Event handlers
        document.getElementById('rulerSlider').addEventListener('input', function() {
            currentRulerLength = parseInt(this.value);
            document.getElementById('rulerValue').textContent = currentRulerLength + ' km';
            if (!animating) {
                updateMeasurement(false);
            }
        });

        document.getElementById('animateBtn').addEventListener('click', function() {
            if (!animating) {
                updateMeasurement(true);
            }
        });

        // === KOCH CURVE DEMOS ===
        function drawKoch(canvasId, iterations) {
            const kCanvas = document.getElementById(canvasId);
            const kCtx = kCanvas.getContext('2d');

            kCanvas.width = 200;
            kCanvas.height = 80;

            kCtx.fillStyle = '#0d2840';
            kCtx.fillRect(0, 0, 200, 80);

            function kochSegment(x1, y1, x2, y2, depth) {
                if (depth === 0) {
                    kCtx.beginPath();
                    kCtx.moveTo(x1, y1);
                    kCtx.lineTo(x2, y2);
                    kCtx.stroke();
                    return;
                }

                const dx = x2 - x1;
                const dy = y2 - y1;

                const ax = x1 + dx / 3;
                const ay = y1 + dy / 3;

                const bx = x1 + dx * 2 / 3;
                const by = y1 + dy * 2 / 3;

                const mx = (x1 + x2) / 2;
                const my = (y1 + y2) / 2;

                const h = Math.sqrt(3) / 6;
                const px = mx - dy * h;
                const py = my + dx * h;

                kochSegment(x1, y1, ax, ay, depth - 1);
                kochSegment(ax, ay, px, py, depth - 1);
                kochSegment(px, py, bx, by, depth - 1);
                kochSegment(bx, by, x2, y2, depth - 1);
            }

            kCtx.strokeStyle = '#4ecdc4';
            kCtx.lineWidth = 1.5;
            kochSegment(10, 50, 190, 50, iterations);
        }

        // Initialize
        draw();
        updateMeasurement(false);

        drawKoch('koch0', 0);
        drawKoch('koch1', 1);
        drawKoch('koch2', 2);
        drawKoch('koch3', 3);

        // Initial measurements at different ruler sizes
        const initialRulers = [100, 75, 50, 25, 10];
        measurements = [];
        baselineLength = null;

        for (const r of initialRulers) {
            const rulerPixels = r * 2;
            const { totalLength } = measureCoastline(rulerPixels);
            const lengthKm = Math.round(totalLength / 2);
            if (baselineLength === null) baselineLength = lengthKm;
            measurements.push({ ruler: r, length: lengthKm });
        }

        currentRulerLength = 50;
        updateMeasurement(false);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
