<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Zeigarnik Effect | Surprising Paradoxes</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, var(--cream) 0%, #F4F1DE 50%, #EDE8D5 100%);
            min-height: 100vh;
            color: var(--dark-moss);
            line-height: 1.7;
            padding: 2rem;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
            margin-bottom: 2rem;
            transition: color 0.3s ease;
        }

        .back-link:hover {
            color: var(--terracotta);
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-family: 'Lora', serif;
            font-size: 2.5rem;
            color: var(--moss);
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--terracotta);
            margin-bottom: 2rem;
        }

        .essay-section {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            padding: 2rem;
            border-radius: 20px;
            margin-bottom: 2rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        }

        h2 {
            font-family: 'Lora', serif;
            color: var(--moss);
            margin-bottom: 1rem;
            font-size: 1.5rem;
        }

        h3 {
            font-family: 'Lora', serif;
            color: var(--dark-moss);
            margin: 1.5rem 0 0.75rem;
            font-size: 1.2rem;
        }

        p {
            margin-bottom: 1rem;
        }

        .highlight {
            background: linear-gradient(120deg, rgba(221, 161, 94, 0.3) 0%, rgba(221, 161, 94, 0.1) 100%);
            padding: 0.2em 0.4em;
            border-radius: 4px;
        }

        .experiment-phase {
            display: none;
        }

        .experiment-phase.active {
            display: block;
        }

        .game-container {
            background: #1a1a2e;
            border-radius: 16px;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }

        .tasks-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .task-card {
            background: rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 1.25rem;
            position: relative;
            overflow: hidden;
        }

        .task-name {
            color: white;
            font-weight: 600;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .task-icon {
            font-size: 1.5rem;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 0.75rem;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--sage), var(--moss));
            transition: width 0.3s;
        }

        .task-status {
            font-size: 0.85rem;
            color: #aaa;
        }

        .task-status.completed {
            color: #4CAF50;
        }

        .task-status.interrupted {
            color: #ff6b6b;
        }

        .work-btn {
            margin-top: 0.5rem;
            padding: 0.5rem 1rem;
            background: linear-gradient(135deg, var(--sage), var(--moss));
            border: none;
            border-radius: 20px;
            color: white;
            font-family: 'Nunito', sans-serif;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .work-btn:hover {
            transform: scale(1.05);
        }

        .work-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .interrupt-notice {
            position: absolute;
            inset: 0;
            background: rgba(255, 100, 100, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            animation: interruptFlash 0.5s;
        }

        @keyframes interruptFlash {
            0%, 50% { opacity: 0; }
            100% { opacity: 1; }
        }

        .btn {
            background: linear-gradient(135deg, var(--sage), var(--moss));
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 30px;
            font-size: 1.1rem;
            cursor: pointer;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-block;
            margin: 0.5rem;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(138, 154, 91, 0.4);
        }

        .btn.secondary {
            background: rgba(255,255,255,0.2);
        }

        .controls {
            text-align: center;
            margin-top: 1rem;
        }

        .phase-message {
            text-align: center;
            color: #ccc;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .recall-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .recall-option {
            padding: 1rem;
            background: rgba(255,255,255,0.1);
            border: 2px solid transparent;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .recall-option:hover {
            background: rgba(255,255,255,0.2);
        }

        .recall-option.selected {
            border-color: var(--sage);
            background: rgba(138, 154, 91, 0.3);
        }

        .recall-option.correct {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.3);
        }

        .recall-option.incorrect {
            border-color: #ff6b6b;
            background: rgba(255, 100, 100, 0.3);
        }

        .recall-icon {
            font-size: 2rem;
            margin-bottom: 0.25rem;
        }

        .recall-name {
            color: white;
            font-size: 0.85rem;
        }

        .stats-display {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            margin: 1.5rem 0;
        }

        .stat-card {
            background: rgba(255,255,255,0.1);
            padding: 1.5rem;
            border-radius: 12px;
            text-align: center;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
        }

        .stat-value.interrupted {
            color: #ff6b6b;
        }

        .stat-value.completed {
            color: #4CAF50;
        }

        .stat-label {
            color: #aaa;
            font-size: 0.95rem;
            margin-top: 0.25rem;
        }

        .result-message {
            color: #ccc;
            text-align: center;
            padding: 1rem;
            font-size: 1rem;
        }

        .distractor-display {
            background: rgba(0,0,0,0.3);
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
        }

        .math-problem {
            font-size: 2rem;
            color: white;
            margin-bottom: 1rem;
        }

        .math-input {
            padding: 0.75rem 1rem;
            font-size: 1.5rem;
            width: 120px;
            text-align: center;
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.1);
            color: white;
            margin-right: 1rem;
        }

        .info-box {
            background: rgba(138, 154, 91, 0.15);
            border-left: 4px solid var(--sage);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 10px 10px 0;
        }

        .quote-box {
            font-family: 'Lora', serif;
            font-style: italic;
            font-size: 1.1rem;
            color: var(--moss);
            padding: 1.5rem;
            background: rgba(138, 154, 91, 0.1);
            border-radius: 10px;
            margin: 1.5rem 0;
            position: relative;
        }

        .quote-box::before {
            content: '"';
            font-size: 4rem;
            position: absolute;
            top: -10px;
            left: 10px;
            color: rgba(138, 154, 91, 0.3);
            font-family: Georgia, serif;
        }

        .quote-attribution {
            display: block;
            text-align: right;
            font-style: normal;
            font-size: 0.95rem;
            color: var(--terracotta);
            margin-top: 0.5rem;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .tasks-grid {
                grid-template-columns: 1fr;
            }

            .recall-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .stats-display {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Surprising Paradoxes</a>

        <h1>The Zeigarnik Effect</h1>
        <p class="subtitle">Why Unfinished Tasks Haunt Your Mind</p>

        <div class="essay-section">
            <h2>The Waiter Who Remembered Everything‚ÄîUntil He Didn't</h2>
            <p>
                In a Viennese caf√© in the 1920s, Gestalt psychologist <strong>Kurt Lewin</strong> noticed
                something peculiar about their waiter. The man could remember complex orders for multiple
                tables without writing anything down. But after the customers paid and left, he couldn't
                recall a single detail of what they had ordered.
            </p>
            <p>
                Lewin's student, <strong>Bluma Zeigarnik</strong>, investigated this phenomenon systematically.
                In <span class="highlight">1927</span>, she published her findings: people remember
                <strong>interrupted tasks</strong> significantly better than completed ones.
            </p>

            <div class="quote-box">
                A task that has already been started establishes a task-specific tension,
                which improves cognitive accessibility of the relevant contents. The tension
                is relieved upon completion of the task.
                <span class="quote-attribution">‚Äî Bluma Zeigarnik, 1927</span>
            </div>
        </div>

        <div class="essay-section">
            <h2>Experience It Yourself</h2>

            <div class="game-container">
                <!-- Phase 1: Instructions -->
                <div class="experiment-phase active" id="phase1">
                    <div class="phase-message">
                        <h3 style="color: var(--earth); margin-bottom: 0.5rem;">The Experiment</h3>
                        <p>You'll work on 6 simple tasks. Some you'll complete. Others will be
                        <strong style="color: #ff6b6b;">interrupted</strong> before you finish.</p>
                        <p>Then we'll test your memory for all the tasks.</p>
                    </div>
                    <div class="controls">
                        <button class="btn" onclick="startExperiment()">Begin Tasks</button>
                    </div>
                </div>

                <!-- Phase 2: Working on tasks -->
                <div class="experiment-phase" id="phase2">
                    <div class="phase-message">
                        Click "Work" to make progress. Some tasks will be interrupted randomly!
                    </div>
                    <div class="tasks-grid" id="tasksGrid"></div>
                    <div class="controls">
                        <button class="btn secondary" id="continueBtn" onclick="proceedToDistractor()" style="display: none;">
                            Continue to Memory Test
                        </button>
                    </div>
                </div>

                <!-- Phase 3: Distractor -->
                <div class="experiment-phase" id="phase3">
                    <div class="phase-message">
                        <h3 style="color: var(--earth);">Quick Math Break</h3>
                        <p>Solve these problems to clear your working memory...</p>
                    </div>
                    <div class="distractor-display">
                        <div class="math-problem" id="mathProblem">12 + 7 = ?</div>
                        <input type="number" class="math-input" id="mathInput">
                        <button class="btn" onclick="submitMath()">Submit</button>
                        <div style="color: #aaa; margin-top: 1rem;" id="mathProgress">Problem 1 of 5</div>
                    </div>
                </div>

                <!-- Phase 4: Recall -->
                <div class="experiment-phase" id="phase4">
                    <div class="phase-message">
                        <h3 style="color: var(--earth);">Memory Test</h3>
                        <p>Select ALL the tasks you remember working on:</p>
                    </div>
                    <div class="recall-grid" id="recallGrid"></div>
                    <div class="controls">
                        <button class="btn" onclick="submitRecall()">Submit Answers</button>
                    </div>
                </div>

                <!-- Phase 5: Results -->
                <div class="experiment-phase" id="phase5">
                    <div class="phase-message">
                        <h3 style="color: var(--earth);">Your Results</h3>
                    </div>

                    <div class="stats-display">
                        <div class="stat-card">
                            <div class="stat-value interrupted" id="interruptedRecall">0/0</div>
                            <div class="stat-label">Interrupted Tasks Recalled</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value completed" id="completedRecall">0/0</div>
                            <div class="stat-label">Completed Tasks Recalled</div>
                        </div>
                    </div>

                    <div class="result-message" id="resultMessage"></div>

                    <div class="controls">
                        <button class="btn secondary" onclick="resetExperiment()">Try Again</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="essay-section">
            <h2>The Psychological Mechanism</h2>

            <h3>Cognitive Tension</h3>
            <p>
                When you start a task, your brain opens a "mental file" for it. This creates
                <strong>psychological tension</strong>‚Äîa quasi-need that keeps the task accessible
                in memory. Completing the task closes the file and releases the tension. But interruption
                leaves the file open, and the tension persists.
            </p>

            <h3>The Ovsiankina Effect</h3>
            <p>
                Zeigarnik's colleague Maria Ovsiankina discovered a related phenomenon: we have a strong
                <strong>urge to resume</strong> interrupted tasks. This is why unfinished to-do items
                feel so nagging‚Äîyour brain is actively pushing you to complete them.
            </p>

            <div class="info-box">
                <strong>The escape:</strong> Research shows that simply making a <em>concrete plan</em>
                to complete an unfinished task releases the cognitive burden‚Äîeven without actually doing it.
                Writing "I'll finish X on Tuesday at 2pm" can quiet the nagging.
            </div>
        </div>

        <div class="essay-section">
            <h2>Modern Applications</h2>
            <ul style="margin: 1rem 0 1rem 2rem;">
                <li><strong>Cliffhangers:</strong> TV shows end episodes mid-scene to exploit Zeigarnik tension</li>
                <li><strong>GTD Method:</strong> "Capture everything" works by closing mental loops</li>
                <li><strong>Advertising:</strong> Incomplete slogans stick better ("Just Do _")</li>
                <li><strong>Procrastination:</strong> Starting is the hardest part‚Äîonce begun, tension builds</li>
                <li><strong>Learning:</strong> Spacing study sessions with breaks can enhance retention</li>
            </ul>
        </div>

        <div class="essay-section">
            <h2>Key Insights</h2>
            <ul style="margin: 1rem 0 1rem 2rem;">
                <li>Unfinished tasks create persistent cognitive "loops" that demand closure</li>
                <li>Completion releases the tension‚Äîand often the memory</li>
                <li>Planning alone can provide partial closure without doing the task</li>
                <li>The effect explains why cliffhangers, to-do list anxiety, and "just start" advice work</li>
                <li>2025 meta-analysis shows resumption urge is more reliable than memory advantage</li>
            </ul>
        </div>
    </div>

    <script>
        const allTasks = [
            { icon: 'üìù', name: 'Write email' },
            { icon: 'üìä', name: 'Analyze data' },
            { icon: 'üé®', name: 'Design logo' },
            { icon: 'üìû', name: 'Make call' },
            { icon: 'üì¶', name: 'Pack order' },
            { icon: 'üîß', name: 'Fix bug' },
            { icon: 'üìö', name: 'Read report' },
            { icon: 'üíª', name: 'Update code' }
        ];

        const distractorTasks = [
            { icon: 'üéµ', name: 'Play music' },
            { icon: 'üç≥', name: 'Cook dinner' },
            { icon: 'üöó', name: 'Drive car' },
            { icon: '‚úàÔ∏è', name: 'Book flight' }
        ];

        let tasks = [];
        let interruptedTasks = [];
        let completedTasks = [];
        let mathProblems = [];
        let currentMath = 0;
        let selectedRecall = new Set();

        function generateTasks() {
            // Pick 6 random tasks
            const shuffled = [...allTasks].sort(() => Math.random() - 0.5);
            tasks = shuffled.slice(0, 6).map((t, i) => ({
                ...t,
                id: i,
                progress: 0,
                maxProgress: 3 + Math.floor(Math.random() * 3), // 3-5 clicks
                status: 'pending',
                willInterrupt: i < 3 // First 3 will be interrupted
            }));

            // Shuffle so interrupts aren't predictable
            tasks.sort(() => Math.random() - 0.5);
        }

        function startExperiment() {
            generateTasks();
            interruptedTasks = [];
            completedTasks = [];
            showPhase(2);
            renderTasks();
        }

        function renderTasks() {
            const grid = document.getElementById('tasksGrid');
            grid.innerHTML = '';

            tasks.forEach((task, i) => {
                const card = document.createElement('div');
                card.className = 'task-card';
                card.id = 'task-' + task.id;

                const progressPercent = (task.progress / task.maxProgress) * 100;

                card.innerHTML = `
                    <div class="task-name">
                        <span class="task-icon">${task.icon}</span>
                        ${task.name}
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${progressPercent}%"></div>
                    </div>
                    <div class="task-status ${task.status}">${getStatusText(task)}</div>
                    ${task.status === 'pending' ? `<button class="work-btn" onclick="workOnTask(${task.id})">Work</button>` : ''}
                `;

                if (task.status === 'interrupted') {
                    card.innerHTML += `
                        <div class="interrupt-notice">
                            ‚ö†Ô∏è INTERRUPTED!
                        </div>
                    `;
                }

                grid.appendChild(card);
            });

            checkAllDone();
        }

        function getStatusText(task) {
            if (task.status === 'completed') return '‚úì Completed';
            if (task.status === 'interrupted') return '‚úó Interrupted';
            return `${task.progress}/${task.maxProgress} steps`;
        }

        function workOnTask(id) {
            const task = tasks.find(t => t.id === id);
            if (!task || task.status !== 'pending') return;

            task.progress++;

            // Check for interrupt
            if (task.willInterrupt && task.progress >= Math.ceil(task.maxProgress / 2)) {
                task.status = 'interrupted';
                interruptedTasks.push(task);
            } else if (task.progress >= task.maxProgress) {
                task.status = 'completed';
                completedTasks.push(task);
            }

            renderTasks();
        }

        function checkAllDone() {
            const pending = tasks.filter(t => t.status === 'pending').length;
            if (pending === 0) {
                document.getElementById('continueBtn').style.display = 'inline-block';
            }
        }

        function proceedToDistractor() {
            // Generate math problems
            mathProblems = [];
            for (let i = 0; i < 5; i++) {
                const a = 10 + Math.floor(Math.random() * 20);
                const b = 5 + Math.floor(Math.random() * 15);
                const op = Math.random() > 0.5 ? '+' : '-';
                const answer = op === '+' ? a + b : a - b;
                mathProblems.push({ problem: `${a} ${op} ${b} = ?`, answer });
            }
            currentMath = 0;

            showPhase(3);
            showMathProblem();
        }

        function showMathProblem() {
            document.getElementById('mathProblem').textContent = mathProblems[currentMath].problem;
            document.getElementById('mathInput').value = '';
            document.getElementById('mathProgress').textContent = `Problem ${currentMath + 1} of 5`;
        }

        function submitMath() {
            currentMath++;
            if (currentMath >= mathProblems.length) {
                showPhase(4);
                setupRecall();
            } else {
                showMathProblem();
            }
        }

        function setupRecall() {
            const grid = document.getElementById('recallGrid');
            grid.innerHTML = '';

            // Mix actual tasks with distractors
            const allOptions = [...tasks, ...distractorTasks].sort(() => Math.random() - 0.5);

            allOptions.forEach(option => {
                const div = document.createElement('div');
                div.className = 'recall-option';
                div.dataset.name = option.name;
                div.dataset.isReal = tasks.some(t => t.name === option.name) ? 'true' : 'false';

                div.innerHTML = `
                    <div class="recall-icon">${option.icon}</div>
                    <div class="recall-name">${option.name}</div>
                `;

                div.onclick = () => toggleRecall(div, option.name);
                grid.appendChild(div);
            });

            selectedRecall.clear();
        }

        function toggleRecall(element, name) {
            if (selectedRecall.has(name)) {
                selectedRecall.delete(name);
                element.classList.remove('selected');
            } else {
                selectedRecall.add(name);
                element.classList.add('selected');
            }
        }

        function submitRecall() {
            // Calculate results
            let interruptedRecalled = 0;
            let completedRecalled = 0;

            interruptedTasks.forEach(task => {
                if (selectedRecall.has(task.name)) interruptedRecalled++;
            });

            completedTasks.forEach(task => {
                if (selectedRecall.has(task.name)) completedRecalled++;
            });

            // Show feedback on grid
            document.querySelectorAll('.recall-option').forEach(el => {
                const name = el.dataset.name;
                const isReal = el.dataset.isReal === 'true';
                const wasSelected = selectedRecall.has(name);

                if (isReal && wasSelected) {
                    el.classList.add('correct');
                } else if (!isReal && wasSelected) {
                    el.classList.add('incorrect');
                }
            });

            // Update stats
            document.getElementById('interruptedRecall').textContent =
                `${interruptedRecalled}/${interruptedTasks.length}`;
            document.getElementById('completedRecall').textContent =
                `${completedRecalled}/${completedTasks.length}`;

            // Generate message
            const interruptRate = interruptedRecalled / interruptedTasks.length;
            const completeRate = completedRecalled / completedTasks.length;

            let message = '';
            if (interruptRate > completeRate) {
                message = `Classic Zeigarnik effect! You recalled ${Math.round(interruptRate * 100)}% of interrupted tasks vs ${Math.round(completeRate * 100)}% of completed ones. Unfinished business sticks in memory!`;
            } else if (interruptRate === completeRate) {
                message = `Equal recall for both types. The effect varies between individuals and situations‚Äîmodern replications show mixed results.`;
            } else {
                message = `Interesting‚Äîyou recalled completed tasks better! The Zeigarnik effect doesn't appear for everyone, and recent meta-analyses show it's harder to replicate than once thought.`;
            }

            document.getElementById('resultMessage').textContent = message;

            showPhase(5);
        }

        function resetExperiment() {
            showPhase(1);
        }

        function showPhase(num) {
            document.querySelectorAll('.experiment-phase').forEach(p => p.classList.remove('active'));
            document.getElementById('phase' + num).classList.add('active');
        }
    </script>
</body>
</html>
