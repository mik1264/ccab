<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Peripheral Drift Illusion - Static Images That Move</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 30px; }
        .back-link {
            color: #00d9ff;
            text-decoration: none;
            margin-bottom: 20px;
            display: inline-block;
        }
        h1 {
            font-size: 2.2rem;
            background: linear-gradient(135deg, #ff6b6b, #feca57, #48dbfb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }
        .subtitle {
            font-size: 1rem;
            color: #a0c4ff;
            max-width: 900px;
            margin: 0 auto;
            line-height: 1.6;
        }
        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 25px;
            margin-bottom: 30px;
        }
        @media (max-width: 1000px) {
            .main-content { grid-template-columns: 1fr; }
        }
        .canvas-panel {
            background: rgba(20, 30, 50, 0.8);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }
        .canvas-panel h2 {
            color: #feca57;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }
        #mainCanvas {
            border-radius: 10px;
            max-width: 100%;
            cursor: crosshair;
        }
        .instruction {
            color: #90e0ff;
            margin-top: 10px;
            font-size: 0.9rem;
            font-style: italic;
        }
        .controls-panel {
            background: rgba(20, 30, 50, 0.8);
            border-radius: 15px;
            padding: 20px;
        }
        .controls-panel h3 {
            color: #48dbfb;
            margin-bottom: 15px;
            font-size: 1.1rem;
            border-bottom: 1px solid rgba(72, 219, 251, 0.3);
            padding-bottom: 10px;
        }
        .control-group {
            margin-bottom: 18px;
        }
        .control-group label {
            display: block;
            color: #a0c4ff;
            margin-bottom: 6px;
            font-size: 0.9rem;
        }
        input[type="range"] {
            width: 100%;
            height: 8px;
            background: #2d3748;
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #48dbfb, #00d9ff);
            border-radius: 50%;
            cursor: pointer;
        }
        .value-display {
            color: #feca57;
            font-size: 0.85rem;
            text-align: right;
            margin-top: 3px;
        }
        .pattern-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }
        .pattern-btn {
            padding: 10px 8px;
            background: rgba(72, 219, 251, 0.2);
            border: 1px solid #48dbfb;
            color: #48dbfb;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s;
        }
        .pattern-btn:hover, .pattern-btn.active {
            background: #48dbfb;
            color: #0f3460;
        }
        .color-presets {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }
        .color-preset {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        .color-preset:hover, .color-preset.active {
            border-color: #fff;
            transform: scale(1.1);
        }
        .toggle-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            border: none;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: bold;
            margin-bottom: 10px;
            transition: all 0.3s;
        }
        .toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }
        .toggle-btn.active {
            background: linear-gradient(135deg, #00b894, #00cec9);
        }
        .bottom-panels {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }
        .panel {
            background: rgba(20, 30, 50, 0.8);
            border-radius: 15px;
            padding: 20px;
        }
        .panel h3 {
            color: #ff6b6b;
            margin-bottom: 12px;
            font-size: 1.1rem;
        }
        .panel p {
            color: #b0c4de;
            line-height: 1.7;
            font-size: 0.95rem;
            margin-bottom: 12px;
        }
        .motion-energy-diagram {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }
        #motionEnergyCanvas {
            width: 100%;
            height: 120px;
            border-radius: 8px;
        }
        .variants-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }
        .variant-card {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        .variant-card:hover {
            transform: scale(1.05);
            border: 1px solid #48dbfb;
        }
        .variant-card canvas {
            border-radius: 8px;
            margin-bottom: 8px;
        }
        .variant-card span {
            color: #a0c4ff;
            font-size: 0.8rem;
        }
        .key-insight {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.2), rgba(254, 202, 87, 0.2));
            border-left: 4px solid #feca57;
            padding: 15px;
            border-radius: 0 10px 10px 0;
            margin: 15px 0;
        }
        .key-insight strong {
            color: #feca57;
        }
        .fixation-dot {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #ff0000;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            pointer-events: none;
            box-shadow: 0 0 10px #ff0000;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        .stat-box {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            color: #48dbfb;
            font-size: 1.5rem;
            font-weight: bold;
        }
        .stat-label {
            color: #a0c4ff;
            font-size: 0.75rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>
            <h1>The Peripheral Drift Illusion</h1>
            <p class="subtitle">
                These images are <strong>completely static</strong>‚Äîyet they appear to ROTATE!
                Akiyoshi Kitaoka's famous "Rotating Snakes" illusion exploits asymmetric luminance gradients
                that fool your brain's motion detectors. The effect is strongest in your peripheral vision‚Äî
                look slightly away and watch the patterns come alive!
            </p>
        </header>

        <div class="main-content">
            <div class="canvas-panel">
                <h2>üêç The Rotating Snakes</h2>
                <div style="position: relative; display: inline-block;">
                    <canvas id="mainCanvas" width="700" height="700"></canvas>
                    <div id="fixationDot" class="fixation-dot" style="display: none;"></div>
                </div>
                <p class="instruction">
                    Look at any area‚Äîperipheral regions will appear to rotate!
                    Move your eyes around to enhance the effect.
                </p>
            </div>

            <div class="controls-panel">
                <h3>‚öôÔ∏è Pattern Controls</h3>

                <div class="pattern-buttons">
                    <button class="pattern-btn active" data-pattern="snakes">Classic Snakes</button>
                    <button class="pattern-btn" data-pattern="wheels">Spiral Wheels</button>
                    <button class="pattern-btn" data-pattern="grid">Motion Grid</button>
                    <button class="pattern-btn" data-pattern="waves">Wavy Lines</button>
                </div>

                <div class="control-group">
                    <label>Number of Rings: <span id="ringsValue">4</span></label>
                    <input type="range" id="rings" min="2" max="8" value="4">
                </div>

                <div class="control-group">
                    <label>Segments per Ring: <span id="segmentsValue">12</span></label>
                    <input type="range" id="segments" min="6" max="24" value="12">
                </div>

                <div class="control-group">
                    <label>Ring Thickness: <span id="thicknessValue">40</span>px</label>
                    <input type="range" id="thickness" min="20" max="80" value="40">
                </div>

                <div class="control-group">
                    <label>Pattern Scale: <span id="scaleValue">1.0</span>x</label>
                    <input type="range" id="scale" min="0.5" max="2" step="0.1" value="1">
                </div>

                <h3>üé® Color Scheme</h3>
                <div class="color-presets">
                    <div class="color-preset active" data-scheme="classic"
                         style="background: linear-gradient(135deg, #000 25%, #1a5a8a 50%, #fff 75%, #8fd14f 100%)"
                         title="Classic (Kitaoka)"></div>
                    <div class="color-preset" data-scheme="fire"
                         style="background: linear-gradient(135deg, #1a0a00 25%, #8b0000 50%, #fff 75%, #ffa500 100%)"
                         title="Fire"></div>
                    <div class="color-preset" data-scheme="ocean"
                         style="background: linear-gradient(135deg, #001428 25%, #004080 50%, #e0f0ff 75%, #40a0c0 100%)"
                         title="Ocean"></div>
                    <div class="color-preset" data-scheme="neon"
                         style="background: linear-gradient(135deg, #0a0015 25%, #6600cc 50%, #fff 75%, #00ffcc 100%)"
                         title="Neon"></div>
                    <div class="color-preset" data-scheme="grayscale"
                         style="background: linear-gradient(135deg, #000 25%, #404040 50%, #fff 75%, #b0b0b0 100%)"
                         title="Grayscale"></div>
                </div>

                <button id="toggleDirection" class="toggle-btn">
                    ‚ü≥ Toggle Rotation Direction
                </button>

                <button id="toggleFixation" class="toggle-btn">
                    üëÅÔ∏è Show Fixation Point
                </button>

                <button id="scrambleBtn" class="toggle-btn">
                    üîÄ Scramble (Kill Illusion)
                </button>

                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-value" id="segmentCount">48</div>
                        <div class="stat-label">Total Segments</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="colorSteps">4</div>
                        <div class="stat-label">Color Steps</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="bottom-panels">
            <div class="panel">
                <h3>üß† Why Does It Move?</h3>
                <p>
                    Your visual cortex contains <strong>motion energy detectors</strong>‚Äîneurons that
                    respond to specific spatial-temporal patterns. The Peripheral Drift Illusion exploits
                    these detectors using a clever 4-step luminance gradient:
                </p>
                <div class="motion-energy-diagram">
                    <canvas id="motionEnergyCanvas"></canvas>
                </div>
                <p>
                    The key is <strong>asymmetric steps</strong>: Black‚ÜíBlue (small step) followed by
                    Blue‚ÜíWhite (large step), then White‚ÜíYellow (small) and Yellow‚ÜíBlack (large).
                    This pattern mimics the spatiotemporal signature of actual motion!
                </p>
                <div class="key-insight">
                    <strong>The Saccade Effect:</strong> Every time your eyes move (saccades),
                    the pattern briefly activates motion detectors. This is why the illusion
                    is strongest when you're NOT fixating directly on any spot!
                </div>
            </div>

            <div class="panel">
                <h3>üé≠ Pattern Variants</h3>
                <p>
                    Kitaoka created dozens of variations. Click any variant to load it:
                </p>
                <div class="variants-grid">
                    <div class="variant-card" data-variant="rotating-rays">
                        <canvas width="100" height="100" id="variant1"></canvas>
                        <span>Rotating Rays</span>
                    </div>
                    <div class="variant-card" data-variant="expanding-rings">
                        <canvas width="100" height="100" id="variant2"></canvas>
                        <span>Expanding Rings</span>
                    </div>
                    <div class="variant-card" data-variant="rollers">
                        <canvas width="100" height="100" id="variant3"></canvas>
                        <span>Rollers</span>
                    </div>
                </div>
                <p style="margin-top: 15px;">
                    <strong>Fun fact:</strong> Kitaoka's original "Rotating Snakes" image from 2003
                    became one of the most shared optical illusions on the internet,
                    inspiring countless variations and scientific studies.
                </p>
            </div>

            <div class="panel">
                <h3>üî¨ The Science</h3>
                <p>
                    <strong>Fraser-Wilcox Effect (1979):</strong> The illusion is based on the observation
                    that asymmetric luminance profiles create illusory motion. Kitaoka refined this into
                    the "optimized" 4-color sequence.
                </p>
                <p>
                    <strong>Why Peripheral?</strong> Peripheral vision has higher motion sensitivity
                    but lower spatial resolution. It detects the motion energy signal but can't
                    resolve the details that would reveal the image is static.
                </p>
                <p>
                    <strong>Motion Energy Model:</strong> Adelson & Bergen (1985) showed that motion
                    detection involves oriented spatiotemporal filters. The 4-color gradient produces
                    non-zero motion energy even in a static image!
                </p>
                <div class="key-insight">
                    <strong>Clinical Note:</strong> Some people with certain visual conditions
                    (migraine aura, visual snow) report enhanced sensitivity to this illusion.
                    About 5% of people see little to no motion‚Äîthis correlates with
                    reduced activity in area V5/MT.
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        // Color schemes: [darkest, dark, lightest, light] - order matters for direction!
        const colorSchemes = {
            classic: ['#000000', '#1a5a8a', '#ffffff', '#8fd14f'],
            fire: ['#1a0a00', '#8b0000', '#ffffff', '#ffa500'],
            ocean: ['#001428', '#004080', '#e0f0ff', '#40a0c0'],
            neon: ['#0a0015', '#6600cc', '#ffffff', '#00ffcc'],
            grayscale: ['#000000', '#404040', '#ffffff', '#b0b0b0']
        };

        let settings = {
            pattern: 'snakes',
            rings: 4,
            segments: 12,
            thickness: 40,
            scale: 1,
            colorScheme: 'classic',
            reversed: false,
            scrambled: false,
            showFixation: false
        };

        function getColors() {
            let colors = [...colorSchemes[settings.colorScheme]];
            if (settings.reversed) {
                colors = [colors[0], colors[3], colors[2], colors[1]];
            }
            if (settings.scrambled) {
                // Shuffle to break the motion energy
                colors = [colors[2], colors[0], colors[3], colors[1]];
            }
            return colors;
        }

        function drawSnakes() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const colors = getColors();
            const baseRadius = 50 * settings.scale;
            const ringWidth = settings.thickness * settings.scale;

            ctx.fillStyle = '#2a2a4a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let ring = 0; ring < settings.rings; ring++) {
                const innerRadius = baseRadius + ring * ringWidth;
                const outerRadius = innerRadius + ringWidth;
                const segmentAngle = (Math.PI * 2) / settings.segments;

                // Alternate direction per ring
                const direction = ring % 2 === 0 ? 1 : -1;

                for (let seg = 0; seg < settings.segments; seg++) {
                    const startAngle = seg * segmentAngle;

                    // Draw 4 color bands within each segment
                    const bandAngle = segmentAngle / 4;
                    for (let band = 0; band < 4; band++) {
                        const colorIndex = (direction > 0) ? band : (3 - band);
                        ctx.fillStyle = colors[colorIndex];

                        const a1 = startAngle + band * bandAngle;
                        const a2 = a1 + bandAngle;

                        ctx.beginPath();
                        ctx.arc(centerX, centerY, outerRadius, a1, a2);
                        ctx.arc(centerX, centerY, innerRadius, a2, a1, true);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }

            // Center circle
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(centerX, centerY, baseRadius - 5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawWheels() {
            const colors = getColors();
            ctx.fillStyle = '#2a2a4a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const gridSize = 3;
            const wheelRadius = (canvas.width / gridSize) * 0.4;

            for (let gx = 0; gx < gridSize; gx++) {
                for (let gy = 0; gy < gridSize; gy++) {
                    const cx = (gx + 0.5) * (canvas.width / gridSize);
                    const cy = (gy + 0.5) * (canvas.height / gridSize);
                    const direction = (gx + gy) % 2 === 0 ? 1 : -1;

                    // Draw spiral wheel
                    const spokes = settings.segments;
                    const spokeAngle = (Math.PI * 2) / spokes;

                    for (let i = 0; i < spokes; i++) {
                        for (let band = 0; band < 4; band++) {
                            const colorIndex = direction > 0 ? band : (3 - band);
                            ctx.fillStyle = colors[colorIndex];

                            const a1 = i * spokeAngle + (band * spokeAngle / 4);
                            const a2 = a1 + spokeAngle / 4;

                            ctx.beginPath();
                            ctx.moveTo(cx, cy);
                            ctx.arc(cx, cy, wheelRadius, a1, a2);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                }
            }
        }

        function drawGrid() {
            const colors = getColors();
            ctx.fillStyle = '#2a2a4a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const cellSize = 35 * settings.scale;
            const cols = Math.ceil(canvas.width / cellSize);
            const rows = Math.ceil(canvas.height / cellSize);

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = col * cellSize;
                    const y = row * cellSize;
                    const direction = (row + col) % 2 === 0 ? 1 : -1;

                    // Draw 2x2 color pattern in each cell
                    const halfCell = cellSize / 2;
                    const pattern = direction > 0 ?
                        [[0, 1], [3, 2]] : [[0, 3], [1, 2]];

                    for (let dy = 0; dy < 2; dy++) {
                        for (let dx = 0; dx < 2; dx++) {
                            ctx.fillStyle = colors[pattern[dy][dx]];
                            ctx.fillRect(x + dx * halfCell, y + dy * halfCell, halfCell, halfCell);
                        }
                    }
                }
            }
        }

        function drawWaves() {
            const colors = getColors();
            ctx.fillStyle = '#2a2a4a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const waveHeight = 40 * settings.scale;
            const waveLength = 80 * settings.scale;
            const rows = Math.ceil(canvas.height / waveHeight) + 1;

            for (let row = 0; row < rows; row++) {
                const baseY = row * waveHeight;
                const direction = row % 2 === 0 ? 1 : -1;
                const phase = row * 0.5;

                // Draw wave with 4-color gradient
                for (let x = 0; x < canvas.width; x += 4) {
                    const progress = (x / waveLength + phase) % 1;
                    const colorIndex = Math.floor(progress * 4) % 4;
                    const actualIndex = direction > 0 ? colorIndex : (3 - colorIndex);

                    ctx.fillStyle = colors[actualIndex];

                    const yOffset = Math.sin((x / waveLength + phase) * Math.PI * 2) * (waveHeight * 0.3);
                    ctx.fillRect(x, baseY + yOffset, 4, waveHeight * 0.8);
                }
            }
        }

        function draw() {
            switch (settings.pattern) {
                case 'snakes': drawSnakes(); break;
                case 'wheels': drawWheels(); break;
                case 'grid': drawGrid(); break;
                case 'waves': drawWaves(); break;
            }

            updateStats();
        }

        function updateStats() {
            const totalSegments = settings.rings * settings.segments * 4;
            document.getElementById('segmentCount').textContent = totalSegments;
        }

        function drawMotionEnergyDiagram() {
            const canvas = document.getElementById('motionEnergyCanvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width = canvas.offsetWidth;
            const h = canvas.height = canvas.offsetHeight;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, w, h);

            const colors = colorSchemes.classic;
            const stepWidth = w / 5;
            const barHeight = h * 0.4;
            const y = h * 0.1;

            // Draw color bars
            for (let i = 0; i < 4; i++) {
                ctx.fillStyle = colors[i];
                ctx.fillRect(i * stepWidth + stepWidth/2, y, stepWidth * 0.8, barHeight);
            }

            // Draw luminance curve
            ctx.strokeStyle = '#feca57';
            ctx.lineWidth = 3;
            ctx.beginPath();

            const luminances = [0, 0.35, 1, 0.6]; // Approximate luminances
            for (let i = 0; i < 4; i++) {
                const x = (i + 0.5) * stepWidth + stepWidth/2;
                const curveY = y + barHeight + 20 + (1 - luminances[i]) * (h - barHeight - 40);
                if (i === 0) ctx.moveTo(x, curveY);
                else ctx.lineTo(x, curveY);
            }
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#a0c4ff';
            ctx.font = '11px Georgia';
            ctx.textAlign = 'center';
            const labels = ['Black', 'Dark', 'White', 'Light'];
            for (let i = 0; i < 4; i++) {
                ctx.fillText(labels[i], (i + 0.5) * stepWidth + stepWidth/2, y + barHeight + 15);
            }

            // Arrows showing motion direction
            ctx.fillStyle = '#ff6b6b';
            ctx.font = 'bold 16px Georgia';
            ctx.fillText('‚Üí Apparent Motion Direction ‚Üí', w/2, h - 5);
        }

        function drawVariants() {
            // Variant 1: Rotating Rays
            const v1 = document.getElementById('variant1');
            const ctx1 = v1.getContext('2d');
            const colors = colorSchemes.classic;
            ctx1.fillStyle = '#2a2a4a';
            ctx1.fillRect(0, 0, 100, 100);

            const rays = 16;
            for (let i = 0; i < rays; i++) {
                const angle = (i / rays) * Math.PI * 2;
                const colorIndex = i % 4;
                ctx1.fillStyle = colors[colorIndex];
                ctx1.beginPath();
                ctx1.moveTo(50, 50);
                ctx1.arc(50, 50, 45, angle, angle + Math.PI / rays);
                ctx1.closePath();
                ctx1.fill();
            }

            // Variant 2: Expanding Rings
            const v2 = document.getElementById('variant2');
            const ctx2 = v2.getContext('2d');
            ctx2.fillStyle = '#2a2a4a';
            ctx2.fillRect(0, 0, 100, 100);

            for (let r = 4; r > 0; r--) {
                ctx2.fillStyle = colors[r % 4];
                ctx2.beginPath();
                ctx2.arc(50, 50, r * 12, 0, Math.PI * 2);
                ctx2.fill();
            }

            // Variant 3: Rollers
            const v3 = document.getElementById('variant3');
            const ctx3 = v3.getContext('2d');
            ctx3.fillStyle = '#2a2a4a';
            ctx3.fillRect(0, 0, 100, 100);

            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 10; col++) {
                    ctx3.fillStyle = colors[(col + row * 2) % 4];
                    ctx3.fillRect(col * 10, row * 25, 10, 25);
                }
            }
        }

        // Event Listeners
        document.querySelectorAll('.pattern-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                settings.pattern = btn.dataset.pattern;
                draw();
            });
        });

        document.querySelectorAll('.color-preset').forEach(preset => {
            preset.addEventListener('click', () => {
                document.querySelectorAll('.color-preset').forEach(p => p.classList.remove('active'));
                preset.classList.add('active');
                settings.colorScheme = preset.dataset.scheme;
                draw();
                drawMotionEnergyDiagram();
            });
        });

        ['rings', 'segments', 'thickness', 'scale'].forEach(id => {
            const input = document.getElementById(id);
            input.addEventListener('input', () => {
                settings[id] = parseFloat(input.value);
                document.getElementById(id + 'Value').textContent =
                    id === 'scale' ? input.value + 'x' :
                    id === 'thickness' ? input.value + 'px' : input.value;
                draw();
            });
        });

        document.getElementById('toggleDirection').addEventListener('click', () => {
            settings.reversed = !settings.reversed;
            draw();
        });

        document.getElementById('toggleFixation').addEventListener('click', function() {
            settings.showFixation = !settings.showFixation;
            const dot = document.getElementById('fixationDot');
            dot.style.display = settings.showFixation ? 'block' : 'none';
            if (settings.showFixation) {
                dot.style.left = (canvas.width / 2) + 'px';
                dot.style.top = (canvas.height / 2) + 'px';
            }
            this.classList.toggle('active', settings.showFixation);
        });

        document.getElementById('scrambleBtn').addEventListener('click', function() {
            settings.scrambled = !settings.scrambled;
            this.textContent = settings.scrambled ? '‚úì Unscramble (Restore)' : 'üîÄ Scramble (Kill Illusion)';
            this.classList.toggle('active', settings.scrambled);
            draw();
        });

        document.querySelectorAll('.variant-card').forEach(card => {
            card.addEventListener('click', () => {
                const variant = card.dataset.variant;
                if (variant === 'rotating-rays') {
                    settings.pattern = 'wheels';
                    settings.segments = 16;
                } else if (variant === 'expanding-rings') {
                    settings.pattern = 'snakes';
                    settings.rings = 6;
                    settings.segments = 1;
                } else if (variant === 'rollers') {
                    settings.pattern = 'waves';
                }

                // Update UI
                document.querySelectorAll('.pattern-btn').forEach(b => {
                    b.classList.toggle('active', b.dataset.pattern === settings.pattern);
                });
                document.getElementById('rings').value = settings.rings;
                document.getElementById('ringsValue').textContent = settings.rings;
                document.getElementById('segments').value = settings.segments;
                document.getElementById('segmentsValue').textContent = settings.segments;

                draw();
            });
        });

        // Initialize
        draw();
        drawMotionEnergyDiagram();
        drawVariants();
    </script>
</body>
</html>
