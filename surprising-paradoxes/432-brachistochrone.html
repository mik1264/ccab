<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Brachistochrone Problem - Surprising Paradoxes - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%);
            min-height: 100vh;
            color: var(--dark-moss);
            line-height: 1.7;
        }
        .organic-shape {
            position: fixed;
            border-radius: 60% 40% 50% 50% / 50% 60% 40% 50%;
            opacity: 0.12;
            z-index: 0;
            animation: morph 30s ease-in-out infinite;
        }
        .shape-1 {
            width: 600px;
            height: 600px;
            background: linear-gradient(135deg, var(--sage), var(--moss));
            top: -200px;
            right: -150px;
        }
        .shape-2 {
            width: 500px;
            height: 500px;
            background: linear-gradient(135deg, var(--earth), var(--terracotta));
            bottom: -150px;
            left: -150px;
            animation-delay: -15s;
        }
        @keyframes morph {
            0%, 100% { border-radius: 60% 40% 50% 50% / 50% 60% 40% 50%; }
            25% { border-radius: 50% 60% 40% 50% / 40% 50% 60% 50%; }
            50% { border-radius: 40% 50% 60% 50% / 50% 40% 50% 60%; }
            75% { border-radius: 50% 40% 50% 60% / 60% 50% 40% 50%; }
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px 80px;
            position: relative;
            z-index: 1;
        }
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
            margin-bottom: 30px;
            padding: 10px 20px;
            background: rgba(255,255,255,0.6);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            transition: all 0.3s ease;
        }
        .back-link:hover {
            background: rgba(255,255,255,0.9);
            transform: translateX(-5px);
        }
        h1 {
            font-family: 'Lora', serif;
            font-size: 2.8rem;
            font-weight: 600;
            color: var(--moss);
            margin-bottom: 20px;
            line-height: 1.2;
        }
        .subtitle {
            font-size: 1.3rem;
            color: var(--terracotta);
            margin-bottom: 40px;
            font-weight: 500;
        }
        .badge {
            display: inline-block;
            background: linear-gradient(135deg, #ffd700, #ffb700);
            color: #1a1a2e;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 25px;
        }
        .card {
            background: rgba(255,255,255,0.7);
            backdrop-filter: blur(15px);
            border-radius: 24px;
            padding: 35px;
            margin-bottom: 35px;
            border: 1px solid rgba(138,154,91,0.2);
            box-shadow: 0 10px 40px rgba(0,0,0,0.08);
        }
        .card h2 {
            font-family: 'Lora', serif;
            font-size: 1.6rem;
            color: var(--moss);
            margin-bottom: 20px;
        }
        .card p {
            color: #555;
            margin-bottom: 18px;
        }
        .card p:last-child { margin-bottom: 0; }
        .highlight {
            background: linear-gradient(120deg, rgba(221,161,94,0.2) 0%, rgba(221,161,94,0.1) 100%);
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: 600;
            color: var(--terracotta);
        }

        /* Simulation */
        .simulation-container {
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 35px;
            box-shadow: 0 15px 50px rgba(0,0,0,0.2);
        }
        .simulation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .simulation-title {
            color: #fff;
            font-family: 'Lora', serif;
            font-size: 1.3rem;
        }
        .controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }
        .btn {
            background: linear-gradient(135deg, var(--earth) 0%, var(--terracotta) 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-family: 'Nunito', sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(188,108,37,0.4);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .btn-secondary {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
        }
        .btn-secondary:hover {
            background: rgba(255,255,255,0.25);
            box-shadow: 0 8px 25px rgba(255,255,255,0.1);
        }
        #raceCanvas {
            display: block;
            width: 100%;
            border-radius: 12px;
            background: linear-gradient(180deg, #0f0f23 0%, #1a1a2e 100%);
        }
        .results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .result-card {
            background: rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            border-left: 4px solid;
        }
        .result-card.cycloid { border-color: #00ff88; }
        .result-card.straight { border-color: #ff6b6b; }
        .result-card.circular { border-color: #4ecdc4; }
        .result-card.parabola { border-color: #ffd93d; }
        .result-label {
            color: rgba(255,255,255,0.7);
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }
        .result-time {
            font-size: 1.5rem;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }
        .result-card.cycloid .result-time { color: #00ff88; }
        .result-card.straight .result-time { color: #ff6b6b; }
        .result-card.circular .result-time { color: #4ecdc4; }
        .result-card.parabola .result-time { color: #ffd93d; }
        .result-rank {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.5);
            margin-top: 5px;
        }
        .winner-badge {
            background: linear-gradient(135deg, #ffd700, #ffb700);
            color: #1a1a2e;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 700;
            margin-left: 5px;
        }

        /* Legend */
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: rgba(255,255,255,0.8);
            font-size: 0.85rem;
        }
        .legend-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
        }
        .legend-dot.cycloid { background: #00ff88; }
        .legend-dot.straight { background: #ff6b6b; }
        .legend-dot.circular { background: #4ecdc4; }
        .legend-dot.parabola { background: #ffd93d; }

        /* Quote */
        .quote {
            border-left: 4px solid var(--earth);
            padding-left: 25px;
            margin: 25px 0;
            font-style: italic;
            color: #666;
        }
        .quote-author {
            font-style: normal;
            font-weight: 600;
            color: var(--moss);
            margin-top: 10px;
        }

        /* Insight box */
        .insight-box {
            background: linear-gradient(135deg, rgba(138,154,91,0.15) 0%, rgba(96,108,56,0.1) 100%);
            border: 2px solid var(--sage);
            border-radius: 16px;
            padding: 25px;
            margin: 25px 0;
        }
        .insight-box h3 {
            color: var(--moss);
            font-family: 'Lora', serif;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Cycloid diagram */
        .cycloid-demo {
            background: rgba(0,0,0,0.05);
            border-radius: 16px;
            padding: 20px;
            margin: 25px 0;
        }
        #cycloidCanvas {
            display: block;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
            border-radius: 8px;
            background: #fff;
        }
        .cycloid-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        }

        /* Timeline */
        .timeline {
            position: relative;
            padding-left: 30px;
            margin: 25px 0;
        }
        .timeline::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--sage);
            border-radius: 2px;
        }
        .timeline-item {
            position: relative;
            margin-bottom: 25px;
        }
        .timeline-item::before {
            content: '';
            position: absolute;
            left: -26px;
            top: 5px;
            width: 14px;
            height: 14px;
            background: var(--earth);
            border-radius: 50%;
            border: 3px solid var(--cream);
        }
        .timeline-date {
            font-weight: 700;
            color: var(--terracotta);
            font-size: 0.9rem;
        }
        .timeline-content {
            color: #555;
            margin-top: 5px;
        }

        /* Applications */
        .applications {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .app-card {
            background: rgba(255,255,255,0.5);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            transition: transform 0.3s ease;
        }
        .app-card:hover { transform: translateY(-5px); }
        .app-icon { font-size: 2.5rem; margin-bottom: 10px; }
        .app-title {
            font-weight: 600;
            color: var(--moss);
            margin-bottom: 8px;
        }
        .app-desc { font-size: 0.85rem; color: #666; }

        /* Math formula */
        .formula {
            background: rgba(0,0,0,0.03);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            color: var(--dark-moss);
            overflow-x: auto;
        }

        .footer {
            text-align: center;
            padding-top: 30px;
            color: #888;
            font-size: 0.85rem;
        }
        .footer a { color: var(--moss); }

        @media (max-width: 600px) {
            h1 { font-size: 2rem; }
            .card { padding: 25px; }
            .simulation-container { padding: 20px; }
        }
    </style>
</head>
<body>
    <div class="organic-shape shape-1"></div>
    <div class="organic-shape shape-2"></div>

    <main class="container">
        <a href="index.html" class="back-link">← Back to Paradoxes</a>

        <span class="badge">Calculus of Variations</span>
        <h1>The Brachistochrone Problem</h1>
        <p class="subtitle">The shortest path isn't the fastest. A curved track beats a straight line—and sometimes the fastest route even goes <em>uphill</em>.</p>

        <!-- Race Simulation -->
        <div class="simulation-container">
            <div class="simulation-header">
                <h2 class="simulation-title">The Great Race</h2>
                <div class="controls">
                    <button class="btn" id="raceBtn">
                        <span>&#9654;</span> Start Race
                    </button>
                    <button class="btn btn-secondary" id="resetBtn">
                        <span>&#8635;</span> Reset
                    </button>
                </div>
            </div>

            <canvas id="raceCanvas" width="800" height="400"></canvas>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-dot cycloid"></div>
                    <span>Cycloid (Brachistochrone)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot straight"></div>
                    <span>Straight Line</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot circular"></div>
                    <span>Circular Arc</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot parabola"></div>
                    <span>Parabola</span>
                </div>
            </div>

            <div class="results" id="results">
                <div class="result-card cycloid">
                    <div class="result-label">Cycloid</div>
                    <div class="result-time" id="cycloidTime">—</div>
                    <div class="result-rank" id="cycloidRank"></div>
                </div>
                <div class="result-card straight">
                    <div class="result-label">Straight</div>
                    <div class="result-time" id="straightTime">—</div>
                    <div class="result-rank" id="straightRank"></div>
                </div>
                <div class="result-card circular">
                    <div class="result-label">Circular</div>
                    <div class="result-time" id="circularTime">—</div>
                    <div class="result-rank" id="circularRank"></div>
                </div>
                <div class="result-card parabola">
                    <div class="result-label">Parabola</div>
                    <div class="result-time" id="parabolaTime">—</div>
                    <div class="result-rank" id="parabolaRank"></div>
                </div>
            </div>
        </div>

        <!-- The Problem -->
        <div class="card">
            <h2>The Fastest Path Problem</h2>
            <p>Imagine a ball rolling from point A to a lower point B under gravity alone (no friction). What shape of track gets it there <em>fastest</em>?</p>
            <p>Your intuition likely says: <span class="highlight">"The straight line—it's the shortest distance!"</span></p>
            <p>But you'd be wrong. The fastest path is a specific curve called a <strong>cycloid</strong>. It dips down steeply at first to build speed, then gradually levels out. The extra distance is more than compensated by the higher velocity.</p>
            <p>Even more surprising: if the endpoint is at the same height or only slightly lower, <span class="highlight">the fastest path actually goes downward and then back UP</span> to reach the destination!</p>
        </div>

        <!-- What is a Cycloid -->
        <div class="card">
            <h2>The Cycloid: A Rolling Circle's Path</h2>
            <p>The brachistochrone curve is a <strong>cycloid</strong>—the curve traced by a point on the rim of a circle as it rolls along a straight line.</p>

            <div class="cycloid-demo">
                <canvas id="cycloidCanvas" width="600" height="200"></canvas>
                <div class="cycloid-controls">
                    <button class="btn btn-secondary" id="rollBtn">
                        <span>&#9654;</span> Roll Circle
                    </button>
                </div>
            </div>

            <div class="formula">
                x(θ) = r(θ - sin θ)<br>
                y(θ) = r(1 - cos θ)
            </div>

            <p>The cycloid has remarkable properties:</p>
            <ul style="margin-left: 25px; color: #555;">
                <li><strong>Brachistochrone:</strong> Path of fastest descent</li>
                <li><strong>Tautochrone:</strong> Time to reach the bottom is the same regardless of starting point!</li>
                <li><strong>Isochrone:</strong> A pendulum swinging along a cycloid has constant period regardless of amplitude</li>
            </ul>
        </div>

        <!-- History -->
        <div class="card">
            <h2>A Mathematical Duel</h2>
            <p>The brachistochrone problem sparked one of history's greatest intellectual rivalries.</p>

            <div class="timeline">
                <div class="timeline-item">
                    <div class="timeline-date">June 1696</div>
                    <div class="timeline-content">Johann Bernoulli publishes the challenge in <em>Acta Eruditorum</em>: "Find the curve of fastest descent." He already knew the answer but wanted to test Europe's mathematicians.</div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">January 1697</div>
                    <div class="timeline-content">Isaac Newton receives the problem at 4 PM after a long day at the Royal Mint. He solves it <strong>before going to bed that night</strong> and sends his anonymous solution the next morning.</div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">May 1697</div>
                    <div class="timeline-content">Solutions arrive from Leibniz, L'Hôpital, and Johann's brother Jakob Bernoulli. Johann recognizes Newton's anonymous solution: "I recognize the lion by his claw."</div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">1766</div>
                    <div class="timeline-content">Euler formalizes the techniques used to solve such problems, creating the <strong>Calculus of Variations</strong>—a new branch of mathematics.</div>
                </div>
            </div>

            <div class="quote">
                "I recognize the lion by his claw."
                <div class="quote-author">— Johann Bernoulli, upon seeing Newton's anonymous solution</div>
            </div>
        </div>

        <!-- Why it works -->
        <div class="card">
            <h2>The Physics: Why Curves Beat Lines</h2>

            <div class="insight-box">
                <h3>&#128161; Key Insight</h3>
                <p>Total travel time depends on both <strong>distance</strong> and <strong>speed</strong>. The straight line minimizes distance but wastes time traveling slowly at the start. The cycloid sacrifices distance to gain speed early, and speed matters more.</p>
            </div>

            <p><strong>Three factors at play:</strong></p>

            <p><strong>1. Steeper = Faster Acceleration</strong><br>
            The cycloid dips down sharply at the beginning. This steep initial descent converts potential energy to kinetic energy quickly, giving the ball high speed for most of its journey.</p>

            <p><strong>2. The Speed Advantage Compounds</strong><br>
            A ball moving at 2× the speed covers ground 2× as fast. The cycloid's early speed boost means it spends less time on each segment of the path, even though the total path is longer.</p>

            <p><strong>3. The Optimal Trade-off</strong><br>
            The cycloid represents the mathematically optimal balance: enough initial steepness to build speed, but not so much extra distance that the advantage is lost. Any other curve is suboptimal.</p>

            <div class="formula">
                Time = ∫ ds/v = ∫ √(1 + (dy/dx)²) / √(2gy) dx
            </div>
            <p style="text-align: center; color: #888; font-size: 0.9rem;">The integral minimized by the brachistochrone curve</p>
        </div>

        <!-- Tautochrone property -->
        <div class="card">
            <h2>The Tautochrone: Equal Time from Anywhere</h2>
            <p>The cycloid has another astounding property: if you release balls from <em>any point</em> along the curve, they all reach the bottom at exactly the same time!</p>
            <p>This "tautochrone" property (Greek for "same time") means a cycloid-shaped bowl is perfectly isochronous. Christiaan Huygens discovered this in 1659 and used it to design more accurate pendulum clocks—if a pendulum swings along a cycloid, its period is constant regardless of amplitude.</p>

            <div class="insight-box">
                <h3>&#9200; Same Time, Any Start</h3>
                <p>Release balls at the top, middle, or near the bottom of a cycloid slide—they all arrive together! Higher starting points give more distance but proportionally more speed.</p>
            </div>
        </div>

        <!-- Real-world applications -->
        <div class="card">
            <h2>Real-World Applications</h2>
            <p>The brachistochrone principle appears throughout engineering and nature:</p>

            <div class="applications">
                <div class="app-card">
                    <div class="app-icon">&#127906;</div>
                    <div class="app-title">Roller Coasters</div>
                    <div class="app-desc">First drops are designed steep to build speed quickly, following brachistochrone-like profiles</div>
                </div>
                <div class="app-card">
                    <div class="app-icon">&#9975;</div>
                    <div class="app-title">Ski Jumping</div>
                    <div class="app-desc">Ramp profiles optimize for maximum speed at takeoff using similar principles</div>
                </div>
                <div class="app-card">
                    <div class="app-icon">&#128664;</div>
                    <div class="app-title">Highway Design</div>
                    <div class="app-desc">Exit ramp curves balance speed and safety using variational calculus</div>
                </div>
                <div class="app-card">
                    <div class="app-icon">&#127776;</div>
                    <div class="app-title">Spacecraft Trajectories</div>
                    <div class="app-desc">Optimal orbital transfers use similar minimum-time path calculations</div>
                </div>
            </div>
        </div>

        <!-- The uphill surprise -->
        <div class="card">
            <h2>The Uphill Surprise</h2>
            <p>Perhaps the most counterintuitive aspect: when the destination is at the same height or only slightly below the start, <span class="highlight">the fastest path goes DOWN and then back UP!</span></p>
            <p>If A and B are at the same altitude, the straight line between them is horizontal—and a ball placed on it wouldn't move at all (infinite travel time). The brachistochrone dips below the line, converts potential energy to kinetic energy, and uses that speed to climb back up to B.</p>
            <p>When the slope from A to B is less than about 32° below horizontal, the brachistochrone will have a portion that goes upward. The mathematics prove this is still faster than any path that only goes downward.</p>
        </div>

        <!-- Try it yourself -->
        <div class="card">
            <h2>Build Your Own</h2>
            <p>You can demonstrate the brachistochrone at home:</p>
            <ol style="margin-left: 25px; color: #555;">
                <li style="margin-bottom: 10px;">Cut a cycloid shape from cardboard (use the parametric equations or trace a rolling coin)</li>
                <li style="margin-bottom: 10px;">Cut a straight ramp of the same start and end points</li>
                <li style="margin-bottom: 10px;">Create smooth tracks using flexible plastic or metal strips</li>
                <li style="margin-bottom: 10px;">Release identical balls simultaneously</li>
                <li>The cycloid ball always wins—even though it travels farther!</li>
            </ol>
            <p style="margin-top: 20px;">Several science museums have large-scale brachistochrone demonstrations. The Exploratorium in San Francisco has a famous racing balls exhibit.</p>
        </div>

        <div class="footer">
            <p>Sources: <a href="https://en.wikipedia.org/wiki/Brachistochrone_curve" target="_blank">Wikipedia</a>,
            <a href="https://mathworld.wolfram.com/BrachistochroneProblem.html" target="_blank">Wolfram MathWorld</a>,
            <a href="http://datagenetics.com/blog/march32014/index.html" target="_blank">DataGenetics</a></p>
            <p style="margin-top: 10px;">Part of <a href="../index.html">CCAB</a> &middot; Surprising Paradoxes Collection</p>
        </div>
    </main>

    <script>
        // === BRACHISTOCHRONE RACE SIMULATION ===
        const raceCanvas = document.getElementById('raceCanvas');
        const raceCtx = raceCanvas.getContext('2d');

        // High DPI
        const dpr = window.devicePixelRatio || 1;
        const raceRect = raceCanvas.getBoundingClientRect();
        raceCanvas.width = raceRect.width * dpr;
        raceCanvas.height = raceRect.height * dpr;
        raceCtx.scale(dpr, dpr);
        raceCanvas.style.width = raceRect.width + 'px';
        raceCanvas.style.height = raceRect.height + 'px';

        const W = raceRect.width;
        const H = raceRect.height;

        // Physics
        const g = 9.81;
        const scale = 200; // pixels per meter

        // Start and end points
        const startX = 80;
        const startY = 60;
        const endX = W - 80;
        const endY = H - 80;

        // Convert to meters
        const x0 = 0;
        const y0 = 0;
        const x1 = (endX - startX) / scale;
        const y1 = (endY - startY) / scale;

        // Curve definitions
        const curves = {
            cycloid: { color: '#00ff88', points: [], ball: null, time: null, finished: false },
            straight: { color: '#ff6b6b', points: [], ball: null, time: null, finished: false },
            circular: { color: '#4ecdc4', points: [], ball: null, time: null, finished: false },
            parabola: { color: '#ffd93d', points: [], ball: null, time: null, finished: false }
        };

        let isRacing = false;
        let raceTime = 0;
        let finishOrder = [];

        // Generate cycloid curve
        function generateCycloid() {
            // Find the cycloid that passes through (x1, y1)
            // Cycloid: x = r(θ - sinθ), y = r(1 - cosθ)
            // We need to find r and θ_end such that x(θ_end) = x1, y(θ_end) = y1

            // Use numerical approach
            const points = [];
            let bestR = 0;
            let bestTheta = 0;
            let bestError = Infinity;

            // Search for best parameters
            for (let r = 0.1; r < 5; r += 0.01) {
                for (let theta = 0.1; theta < Math.PI * 2; theta += 0.01) {
                    const x = r * (theta - Math.sin(theta));
                    const y = r * (1 - Math.cos(theta));
                    const error = Math.sqrt((x - x1) ** 2 + (y - y1) ** 2);
                    if (error < bestError) {
                        bestError = error;
                        bestR = r;
                        bestTheta = theta;
                    }
                }
            }

            // Generate points
            const numPoints = 100;
            for (let i = 0; i <= numPoints; i++) {
                const theta = (i / numPoints) * bestTheta;
                const x = bestR * (theta - Math.sin(theta));
                const y = bestR * (1 - Math.cos(theta));
                points.push({ x, y });
            }

            return points;
        }

        // Generate straight line
        function generateStraight() {
            const points = [];
            const numPoints = 100;
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                points.push({ x: t * x1, y: t * y1 });
            }
            return points;
        }

        // Generate circular arc
        function generateCircular() {
            const points = [];
            // Arc passing through start and end
            // Find center of circle
            const midX = x1 / 2;
            const midY = y1 / 2;
            // Radius that gives a nice arc
            const chord = Math.sqrt(x1 * x1 + y1 * y1);
            const sagitta = chord * 0.3; // How much it dips
            const r = (sagitta * sagitta + (chord / 2) ** 2) / (2 * sagitta);
            const cx = midX;
            const cy = midY - (r - sagitta);

            const startAngle = Math.atan2(y0 - cy, x0 - cx);
            const endAngle = Math.atan2(y1 - cy, x1 - cx);

            const numPoints = 100;
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const angle = startAngle + t * (endAngle - startAngle);
                const x = cx + r * Math.cos(angle);
                const y = cy + r * Math.sin(angle);
                points.push({ x, y });
            }
            return points;
        }

        // Generate parabola
        function generateParabola() {
            const points = [];
            // y = ax² + bx where y(0)=0, y(x1)=y1
            // y1 = ax1² + bx1 => a = (y1 - bx1) / x1²
            // We want the parabola to dip more, so add curvature
            const b = 0;
            const a = y1 / (x1 * x1);

            const numPoints = 100;
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const x = t * x1;
                const y = a * x * x + b * x;
                points.push({ x, y });
            }
            return points;
        }

        // Initialize curves
        function initCurves() {
            curves.cycloid.points = generateCycloid();
            curves.straight.points = generateStraight();
            curves.circular.points = generateCircular();
            curves.parabola.points = generateParabola();

            // Initialize balls
            for (const key in curves) {
                curves[key].ball = { index: 0, x: 0, y: 0, v: 0, s: 0 };
                curves[key].time = null;
                curves[key].finished = false;
            }

            isRacing = false;
            raceTime = 0;
            finishOrder = [];

            updateResults();
            drawRace();
        }

        // Calculate arc length and derivatives for a curve
        function getArcLengthData(points) {
            const data = [{ s: 0, x: points[0].x, y: points[0].y }];
            let totalS = 0;

            for (let i = 1; i < points.length; i++) {
                const dx = points[i].x - points[i - 1].x;
                const dy = points[i].y - points[i - 1].y;
                const ds = Math.sqrt(dx * dx + dy * dy);
                totalS += ds;
                data.push({ s: totalS, x: points[i].x, y: points[i].y });
            }

            return data;
        }

        // Physics step for a ball on a curve
        function updateBall(curve, dt) {
            if (curve.finished) return;

            const ball = curve.ball;
            const points = curve.points;

            if (ball.index >= points.length - 1) {
                curve.finished = true;
                curve.time = raceTime;
                finishOrder.push(curve);
                return;
            }

            // Get current position and next position
            const p0 = points[ball.index];
            const p1 = points[Math.min(ball.index + 1, points.length - 1)];

            // Direction vector
            const dx = p1.x - p0.x;
            const dy = p1.y - p0.y;
            const ds = Math.sqrt(dx * dx + dy * dy);

            if (ds < 0.0001) {
                ball.index++;
                return;
            }

            // Tangent direction (normalized)
            const tx = dx / ds;
            const ty = dy / ds;

            // Component of gravity along tangent
            const gTangent = g * ty; // g * sin(θ) where θ is angle from horizontal

            // Update velocity (v² = v₀² + 2gh for energy conservation, but using acceleration for animation)
            ball.v += gTangent * dt;
            if (ball.v < 0) ball.v = 0.01; // Prevent going backwards

            // Update position along curve
            ball.s += ball.v * dt;

            // Find new index based on arc length
            let arcLength = 0;
            for (let i = 1; i < points.length; i++) {
                const px = points[i].x - points[i - 1].x;
                const py = points[i].y - points[i - 1].y;
                arcLength += Math.sqrt(px * px + py * py);

                if (arcLength >= ball.s) {
                    ball.index = i;
                    ball.x = points[i].x;
                    ball.y = points[i].y;
                    break;
                }
            }

            // Use energy conservation for more accurate velocity
            ball.v = Math.sqrt(2 * g * ball.y + 0.01);
        }

        // Draw race
        function drawRace() {
            raceCtx.clearRect(0, 0, W, H);

            // Background
            const bgGrad = raceCtx.createLinearGradient(0, 0, 0, H);
            bgGrad.addColorStop(0, '#0f0f23');
            bgGrad.addColorStop(1, '#1a1a2e');
            raceCtx.fillStyle = bgGrad;
            raceCtx.fillRect(0, 0, W, H);

            // Grid
            raceCtx.strokeStyle = 'rgba(255,255,255,0.05)';
            raceCtx.lineWidth = 1;
            for (let x = 0; x < W; x += 50) {
                raceCtx.beginPath();
                raceCtx.moveTo(x, 0);
                raceCtx.lineTo(x, H);
                raceCtx.stroke();
            }
            for (let y = 0; y < H; y += 50) {
                raceCtx.beginPath();
                raceCtx.moveTo(0, y);
                raceCtx.lineTo(W, y);
                raceCtx.stroke();
            }

            // Start and end points
            raceCtx.fillStyle = '#fff';
            raceCtx.font = 'bold 16px Nunito';
            raceCtx.textAlign = 'center';
            raceCtx.fillText('A', startX, startY - 25);
            raceCtx.fillText('B', endX, endY + 35);

            // Draw start marker
            raceCtx.beginPath();
            raceCtx.arc(startX, startY, 8, 0, Math.PI * 2);
            raceCtx.fillStyle = '#fff';
            raceCtx.fill();

            // Draw end marker
            raceCtx.beginPath();
            raceCtx.arc(endX, endY, 8, 0, Math.PI * 2);
            raceCtx.fillStyle = '#fff';
            raceCtx.fill();

            // Draw curves
            for (const key in curves) {
                const curve = curves[key];
                raceCtx.strokeStyle = curve.color;
                raceCtx.lineWidth = 3;
                raceCtx.beginPath();

                for (let i = 0; i < curve.points.length; i++) {
                    const px = startX + curve.points[i].x * scale;
                    const py = startY + curve.points[i].y * scale;
                    if (i === 0) {
                        raceCtx.moveTo(px, py);
                    } else {
                        raceCtx.lineTo(px, py);
                    }
                }
                raceCtx.stroke();

                // Draw ball
                const ball = curve.ball;
                const bx = startX + ball.x * scale;
                const by = startY + ball.y * scale;

                raceCtx.beginPath();
                raceCtx.arc(bx, by, 10, 0, Math.PI * 2);
                raceCtx.fillStyle = curve.color;
                raceCtx.fill();

                // Glow effect
                raceCtx.beginPath();
                raceCtx.arc(bx, by, 15, 0, Math.PI * 2);
                raceCtx.strokeStyle = curve.color + '40';
                raceCtx.lineWidth = 3;
                raceCtx.stroke();
            }

            // Time display
            raceCtx.fillStyle = '#fff';
            raceCtx.font = '14px Courier New';
            raceCtx.textAlign = 'left';
            raceCtx.fillText(`Time: ${raceTime.toFixed(3)}s`, 20, 30);

            // Finish flag
            if (finishOrder.length > 0) {
                raceCtx.fillStyle = '#ffd700';
                raceCtx.font = 'bold 14px Nunito';
                raceCtx.textAlign = 'right';
                raceCtx.fillText(`Winner: ${finishOrder[0] === curves.cycloid ? 'CYCLOID' : finishOrder[0] === curves.straight ? 'STRAIGHT' : finishOrder[0] === curves.circular ? 'CIRCULAR' : 'PARABOLA'}!`, W - 20, 30);
            }
        }

        // Update results display
        function updateResults() {
            for (const key in curves) {
                const curve = curves[key];
                const timeEl = document.getElementById(key + 'Time');
                const rankEl = document.getElementById(key + 'Rank');

                if (curve.time !== null) {
                    timeEl.textContent = curve.time.toFixed(3) + 's';
                    const rank = finishOrder.indexOf(curve) + 1;
                    if (rank === 1) {
                        rankEl.innerHTML = '<span class="winner-badge">WINNER</span>';
                    } else {
                        rankEl.textContent = `#${rank}`;
                    }
                } else if (isRacing) {
                    timeEl.textContent = '...';
                    rankEl.textContent = '';
                } else {
                    timeEl.textContent = '—';
                    rankEl.textContent = '';
                }
            }
        }

        // Animation loop
        let lastTime = 0;
        function animate(time) {
            const dt = Math.min((time - lastTime) / 1000, 0.05);
            lastTime = time;

            if (isRacing) {
                raceTime += dt;

                // Update all balls
                const subSteps = 5;
                for (let i = 0; i < subSteps; i++) {
                    for (const key in curves) {
                        updateBall(curves[key], dt / subSteps);
                    }
                }

                updateResults();

                // Check if all finished
                let allDone = true;
                for (const key in curves) {
                    if (!curves[key].finished) allDone = false;
                }
                if (allDone) {
                    isRacing = false;
                    document.getElementById('raceBtn').disabled = false;
                }
            }

            drawRace();
            requestAnimationFrame(animate);
        }

        // Event handlers
        document.getElementById('raceBtn').addEventListener('click', function() {
            if (!isRacing) {
                initCurves();
                isRacing = true;
                this.disabled = true;
            }
        });

        document.getElementById('resetBtn').addEventListener('click', function() {
            initCurves();
            document.getElementById('raceBtn').disabled = false;
        });

        // === CYCLOID DEMONSTRATION ===
        const cycloidCanvas = document.getElementById('cycloidCanvas');
        const cycloidCtx = cycloidCanvas.getContext('2d');

        const cW = 600;
        const cH = 200;
        cycloidCanvas.width = cW * dpr;
        cycloidCanvas.height = cH * dpr;
        cycloidCtx.scale(dpr, dpr);
        cycloidCanvas.style.width = cW + 'px';
        cycloidCanvas.style.height = cH + 'px';

        let circleAngle = 0;
        let isRolling = false;
        let cycloidTrail = [];

        function drawCycloid() {
            cycloidCtx.clearRect(0, 0, cW, cH);

            // Background
            cycloidCtx.fillStyle = '#fafafa';
            cycloidCtx.fillRect(0, 0, cW, cH);

            const r = 30;
            const groundY = cH - 50;
            const startX = 50;

            // Ground line
            cycloidCtx.strokeStyle = '#ccc';
            cycloidCtx.lineWidth = 2;
            cycloidCtx.beginPath();
            cycloidCtx.moveTo(0, groundY);
            cycloidCtx.lineTo(cW, groundY);
            cycloidCtx.stroke();

            // Circle center position
            const cx = startX + r * circleAngle;
            const cy = groundY - r;

            // Draw trail
            if (cycloidTrail.length > 1) {
                cycloidCtx.strokeStyle = '#00aa66';
                cycloidCtx.lineWidth = 3;
                cycloidCtx.beginPath();
                cycloidCtx.moveTo(cycloidTrail[0].x, cycloidTrail[0].y);
                for (let i = 1; i < cycloidTrail.length; i++) {
                    cycloidCtx.lineTo(cycloidTrail[i].x, cycloidTrail[i].y);
                }
                cycloidCtx.stroke();
            }

            // Draw circle
            cycloidCtx.strokeStyle = '#666';
            cycloidCtx.lineWidth = 2;
            cycloidCtx.beginPath();
            cycloidCtx.arc(cx, cy, r, 0, Math.PI * 2);
            cycloidCtx.stroke();

            // Draw radius line
            cycloidCtx.strokeStyle = '#999';
            cycloidCtx.setLineDash([3, 3]);
            cycloidCtx.beginPath();
            cycloidCtx.moveTo(cx, cy);
            cycloidCtx.lineTo(cx + r * Math.sin(circleAngle), cy + r * Math.cos(circleAngle));
            cycloidCtx.stroke();
            cycloidCtx.setLineDash([]);

            // Draw point on rim
            const px = cx - r * Math.sin(circleAngle);
            const py = cy + r * Math.cos(circleAngle);

            cycloidCtx.beginPath();
            cycloidCtx.arc(px, py, 6, 0, Math.PI * 2);
            cycloidCtx.fillStyle = '#ff6b6b';
            cycloidCtx.fill();

            // Labels
            cycloidCtx.fillStyle = '#333';
            cycloidCtx.font = '12px Nunito';
            cycloidCtx.textAlign = 'center';
            cycloidCtx.fillText('Rolling Circle', cx, cy - r - 15);
            cycloidCtx.fillText('Traced Point', px, py - 15);
        }

        function animateCycloid() {
            if (isRolling) {
                circleAngle += 0.03;

                const r = 30;
                const groundY = cH - 50;
                const startX = 50;
                const cx = startX + r * circleAngle;
                const cy = groundY - r;
                const px = cx - r * Math.sin(circleAngle);
                const py = cy + r * Math.cos(circleAngle);

                cycloidTrail.push({ x: px, y: py });

                if (circleAngle > Math.PI * 4) {
                    isRolling = false;
                    document.getElementById('rollBtn').innerHTML = '<span>&#9654;</span> Roll Circle';
                }
            }

            drawCycloid();
            requestAnimationFrame(animateCycloid);
        }

        document.getElementById('rollBtn').addEventListener('click', function() {
            if (!isRolling) {
                circleAngle = 0;
                cycloidTrail = [];
                isRolling = true;
                this.innerHTML = '<span>&#9632;</span> Rolling...';
            }
        });

        // Initialize
        initCurves();
        requestAnimationFrame(animate);
        requestAnimationFrame(animateCycloid);
        drawCycloid();
    </script>
</body>
</html>
