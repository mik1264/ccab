<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Brachistochrone Problem - Surprising Paradoxes - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%);
            min-height: 100vh;
            color: var(--dark-moss);
            line-height: 1.7;
        }
        .organic-shape {
            position: fixed;
            border-radius: 60% 40% 50% 50% / 50% 60% 40% 50%;
            opacity: 0.12;
            z-index: 0;
            animation: morph 30s ease-in-out infinite;
        }
        .shape-1 {
            width: 600px;
            height: 600px;
            background: linear-gradient(135deg, var(--sage), var(--moss));
            top: -200px;
            right: -150px;
        }
        .shape-2 {
            width: 500px;
            height: 500px;
            background: linear-gradient(135deg, var(--earth), var(--terracotta));
            bottom: -150px;
            left: -150px;
            animation-delay: -15s;
        }
        @keyframes morph {
            0%, 100% { border-radius: 60% 40% 50% 50% / 50% 60% 40% 50%; }
            25% { border-radius: 50% 60% 40% 50% / 40% 50% 60% 50%; }
            50% { border-radius: 40% 50% 60% 50% / 50% 40% 50% 60%; }
            75% { border-radius: 50% 40% 50% 60% / 60% 50% 40% 50%; }
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px 80px;
            position: relative;
            z-index: 1;
        }
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
            margin-bottom: 30px;
            padding: 10px 20px;
            background: rgba(255,255,255,0.6);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            transition: all 0.3s ease;
        }
        .back-link:hover {
            background: rgba(255,255,255,0.9);
            transform: translateX(-5px);
        }
        h1 {
            font-family: 'Lora', serif;
            font-size: 2.8rem;
            font-weight: 600;
            color: var(--moss);
            margin-bottom: 20px;
            line-height: 1.2;
        }
        .subtitle {
            font-size: 1.3rem;
            color: var(--terracotta);
            margin-bottom: 40px;
            font-weight: 500;
        }
        .badge {
            display: inline-block;
            background: linear-gradient(135deg, #ffd700, #ffb700);
            color: #1a1a2e;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 25px;
        }
        .card {
            background: rgba(255,255,255,0.7);
            backdrop-filter: blur(15px);
            border-radius: 24px;
            padding: 35px;
            margin-bottom: 35px;
            border: 1px solid rgba(138,154,91,0.2);
            box-shadow: 0 10px 40px rgba(0,0,0,0.08);
        }
        .card h2 {
            font-family: 'Lora', serif;
            font-size: 1.6rem;
            color: var(--moss);
            margin-bottom: 20px;
        }
        .card p {
            color: #555;
            margin-bottom: 18px;
        }
        .card p:last-child { margin-bottom: 0; }
        .highlight {
            background: linear-gradient(120deg, rgba(221,161,94,0.2) 0%, rgba(221,161,94,0.1) 100%);
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: 600;
            color: var(--terracotta);
        }

        /* Simulation */
        .simulation-container {
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 35px;
            box-shadow: 0 15px 50px rgba(0,0,0,0.2);
        }
        .simulation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .simulation-title {
            color: #fff;
            font-family: 'Lora', serif;
            font-size: 1.3rem;
        }
        .controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }
        .btn {
            background: linear-gradient(135deg, var(--earth) 0%, var(--terracotta) 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-family: 'Nunito', sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(188,108,37,0.4);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .btn-secondary {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
        }
        .btn-secondary:hover {
            background: rgba(255,255,255,0.25);
            box-shadow: 0 8px 25px rgba(255,255,255,0.1);
        }
        .btn-small {
            padding: 8px 16px;
            font-size: 0.85rem;
        }
        #raceCanvas {
            display: block;
            width: 100%;
            border-radius: 12px;
            background: linear-gradient(180deg, #0f0f23 0%, #1a1a2e 100%);
            cursor: crosshair;
        }

        /* Control Panel */
        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
            padding: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 16px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .control-label {
            color: rgba(255,255,255,0.8);
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.2);
            outline: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--earth), var(--terracotta));
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        .slider-value {
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            min-width: 60px;
            text-align: right;
        }

        /* Toggle Switch */
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .toggle {
            position: relative;
            width: 50px;
            height: 26px;
            background: rgba(255,255,255,0.2);
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s;
        }
        .toggle.active {
            background: var(--sage);
        }
        .toggle::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        .toggle.active::after {
            transform: translateX(24px);
        }

        /* Speed Graph */
        .speed-graph-container {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
        }
        .speed-graph-title {
            color: rgba(255,255,255,0.8);
            font-size: 0.9rem;
            margin-bottom: 10px;
            font-weight: 600;
        }
        #speedCanvas {
            display: block;
            width: 100%;
            height: 150px;
            border-radius: 8px;
            background: rgba(0,0,0,0.2);
        }

        .results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .result-card {
            background: rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            border-left: 4px solid;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .result-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        }
        .result-card.cycloid { border-color: #00ff88; }
        .result-card.straight { border-color: #ff6b6b; }
        .result-card.circular { border-color: #4ecdc4; }
        .result-card.parabola { border-color: #ffd93d; }
        .result-card.custom { border-color: #ff88ff; }
        .result-label {
            color: rgba(255,255,255,0.7);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }
        .result-time {
            font-size: 1.4rem;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }
        .result-card.cycloid .result-time { color: #00ff88; }
        .result-card.straight .result-time { color: #ff6b6b; }
        .result-card.circular .result-time { color: #4ecdc4; }
        .result-card.parabola .result-time { color: #ffd93d; }
        .result-card.custom .result-time { color: #ff88ff; }
        .result-rank {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.5);
            margin-top: 5px;
        }
        .result-speed {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.6);
            margin-top: 3px;
        }
        .winner-badge {
            background: linear-gradient(135deg, #ffd700, #ffb700);
            color: #1a1a2e;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 700;
            margin-left: 5px;
        }

        /* Legend */
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: rgba(255,255,255,0.8);
            font-size: 0.85rem;
        }
        .legend-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
        }
        .legend-dot.cycloid { background: #00ff88; }
        .legend-dot.straight { background: #ff6b6b; }
        .legend-dot.circular { background: #4ecdc4; }
        .legend-dot.parabola { background: #ffd93d; }
        .legend-dot.custom { background: #ff88ff; }

        /* Custom Path Editor */
        .editor-instructions {
            color: rgba(255,255,255,0.7);
            font-size: 0.85rem;
            text-align: center;
            padding: 10px;
            margin-top: 10px;
            background: rgba(255,136,255,0.1);
            border-radius: 8px;
            border: 1px dashed rgba(255,136,255,0.3);
        }

        /* Quote */
        .quote {
            border-left: 4px solid var(--earth);
            padding-left: 25px;
            margin: 25px 0;
            font-style: italic;
            color: #666;
        }
        .quote-author {
            font-style: normal;
            font-weight: 600;
            color: var(--moss);
            margin-top: 10px;
        }

        /* Insight box */
        .insight-box {
            background: linear-gradient(135deg, rgba(138,154,91,0.15) 0%, rgba(96,108,56,0.1) 100%);
            border: 2px solid var(--sage);
            border-radius: 16px;
            padding: 25px;
            margin: 25px 0;
        }
        .insight-box h3 {
            color: var(--moss);
            font-family: 'Lora', serif;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Cycloid diagram */
        .cycloid-demo {
            background: rgba(0,0,0,0.05);
            border-radius: 16px;
            padding: 20px;
            margin: 25px 0;
        }
        #cycloidCanvas {
            display: block;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
            border-radius: 8px;
            background: #fff;
        }
        .cycloid-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        }

        /* Timeline */
        .timeline {
            position: relative;
            padding-left: 30px;
            margin: 25px 0;
        }
        .timeline::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--sage);
            border-radius: 2px;
        }
        .timeline-item {
            position: relative;
            margin-bottom: 25px;
        }
        .timeline-item::before {
            content: '';
            position: absolute;
            left: -26px;
            top: 5px;
            width: 14px;
            height: 14px;
            background: var(--earth);
            border-radius: 50%;
            border: 3px solid var(--cream);
        }
        .timeline-date {
            font-weight: 700;
            color: var(--terracotta);
            font-size: 0.9rem;
        }
        .timeline-content {
            color: #555;
            margin-top: 5px;
        }

        /* Applications */
        .applications {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .app-card {
            background: rgba(255,255,255,0.5);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            transition: transform 0.3s ease;
        }
        .app-card:hover { transform: translateY(-5px); }
        .app-icon { font-size: 2.5rem; margin-bottom: 10px; }
        .app-title {
            font-weight: 600;
            color: var(--moss);
            margin-bottom: 8px;
        }
        .app-desc { font-size: 0.85rem; color: #666; }

        /* Math formula */
        .formula {
            background: rgba(0,0,0,0.03);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            color: var(--dark-moss);
            overflow-x: auto;
        }

        .footer {
            text-align: center;
            padding-top: 30px;
            color: #888;
            font-size: 0.85rem;
        }
        .footer a { color: var(--moss); }

        @media (max-width: 600px) {
            h1 { font-size: 2rem; }
            .card { padding: 25px; }
            .simulation-container { padding: 20px; }
            .control-panel { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="organic-shape shape-1"></div>
    <div class="organic-shape shape-2"></div>

    <main class="container">
        <a href="index.html" class="back-link">Back to Paradoxes</a>

        <span class="badge">Calculus of Variations</span>
        <h1>The Brachistochrone Problem</h1>
        <p class="subtitle">The shortest path isn't the fastest. A curved track beats a straight line - and the physics proves why.</p>

        <!-- Race Simulation -->
        <div class="simulation-container">
            <div class="simulation-header">
                <h2 class="simulation-title">The Great Race</h2>
                <div class="controls">
                    <button class="btn" id="raceBtn">
                        <span>&#9654;</span> Start Race
                    </button>
                    <button class="btn btn-secondary" id="resetBtn">
                        <span>&#8635;</span> Reset
                    </button>
                    <button class="btn btn-secondary" id="clearCustomBtn">
                        <span>&#10005;</span> Clear Custom
                    </button>
                </div>
            </div>

            <canvas id="raceCanvas" width="800" height="400"></canvas>

            <div class="editor-instructions" id="editorInstructions">
                Click on the canvas to draw your own path! Points will be connected to create a custom curve.
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-dot cycloid"></div>
                    <span>Cycloid (Optimal)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot straight"></div>
                    <span>Straight Line</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot circular"></div>
                    <span>Circular Arc</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot parabola"></div>
                    <span>Parabola</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot custom"></div>
                    <span>Your Path</span>
                </div>
            </div>

            <!-- Control Panel -->
            <div class="control-panel">
                <div class="control-group">
                    <div class="control-label">Gravity</div>
                    <div class="slider-container">
                        <input type="range" class="slider" id="gravitySlider" min="1" max="30" value="10" step="0.5">
                        <span class="slider-value" id="gravityValue">9.81 m/s2</span>
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-label">Planet Presets</div>
                    <div class="controls">
                        <button class="btn btn-secondary btn-small" data-gravity="1.62">Moon</button>
                        <button class="btn btn-secondary btn-small" data-gravity="3.71">Mars</button>
                        <button class="btn btn-secondary btn-small" data-gravity="9.81">Earth</button>
                        <button class="btn btn-secondary btn-small" data-gravity="24.79">Jupiter</button>
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-label">Animation Speed</div>
                    <div class="slider-container">
                        <input type="range" class="slider" id="speedSlider" min="0.25" max="3" value="1" step="0.25">
                        <span class="slider-value" id="speedValue">1.0x</span>
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-label">Show Speed Vectors</div>
                    <div class="toggle-container">
                        <div class="toggle" id="vectorToggle"></div>
                        <span style="color: rgba(255,255,255,0.7);">Velocity arrows</span>
                    </div>
                </div>
            </div>

            <!-- Speed Comparison Graph -->
            <div class="speed-graph-container">
                <div class="speed-graph-title">Real-Time Speed Comparison</div>
                <canvas id="speedCanvas"></canvas>
            </div>

            <div class="results" id="results">
                <div class="result-card cycloid">
                    <div class="result-label">Cycloid</div>
                    <div class="result-time" id="cycloidTime">-</div>
                    <div class="result-speed" id="cycloidSpeed">Speed: -</div>
                    <div class="result-rank" id="cycloidRank"></div>
                </div>
                <div class="result-card straight">
                    <div class="result-label">Straight</div>
                    <div class="result-time" id="straightTime">-</div>
                    <div class="result-speed" id="straightSpeed">Speed: -</div>
                    <div class="result-rank" id="straightRank"></div>
                </div>
                <div class="result-card circular">
                    <div class="result-label">Circular</div>
                    <div class="result-time" id="circularTime">-</div>
                    <div class="result-speed" id="circularSpeed">Speed: -</div>
                    <div class="result-rank" id="circularRank"></div>
                </div>
                <div class="result-card parabola">
                    <div class="result-label">Parabola</div>
                    <div class="result-time" id="parabolaTime">-</div>
                    <div class="result-speed" id="parabolaSpeed">Speed: -</div>
                    <div class="result-rank" id="parabolaRank"></div>
                </div>
                <div class="result-card custom" id="customResultCard" style="display: none;">
                    <div class="result-label">Your Path</div>
                    <div class="result-time" id="customTime">-</div>
                    <div class="result-speed" id="customSpeed">Speed: -</div>
                    <div class="result-rank" id="customRank"></div>
                </div>
            </div>
        </div>

        <!-- The Problem -->
        <div class="card">
            <h2>The Fastest Path Problem</h2>
            <p>Imagine a ball rolling from point A to a lower point B under gravity alone (no friction). What shape of track gets it there <em>fastest</em>?</p>
            <p>Your intuition likely says: <span class="highlight">"The straight line - it's the shortest distance!"</span></p>
            <p>But you'd be wrong. The fastest path is a specific curve called a <strong>cycloid</strong>. It dips down steeply at first to build speed, then gradually levels out. The extra distance is more than compensated by the higher velocity.</p>
            <p>Even more surprising: if the endpoint is at the same height or only slightly lower, <span class="highlight">the fastest path actually goes downward and then back UP</span> to reach the destination!</p>
        </div>

        <!-- What is a Cycloid -->
        <div class="card">
            <h2>The Cycloid: A Rolling Circle's Path</h2>
            <p>The brachistochrone curve is a <strong>cycloid</strong> - the curve traced by a point on the rim of a circle as it rolls along a straight line.</p>

            <div class="cycloid-demo">
                <canvas id="cycloidCanvas" width="600" height="200"></canvas>
                <div class="cycloid-controls">
                    <button class="btn btn-secondary" id="rollBtn">
                        <span>&#9654;</span> Roll Circle
                    </button>
                </div>
            </div>

            <div class="formula">
                x(t) = r(t - sin t)<br>
                y(t) = r(1 - cos t)
            </div>

            <p>The cycloid has remarkable properties:</p>
            <ul style="margin-left: 25px; color: #555;">
                <li><strong>Brachistochrone:</strong> Path of fastest descent</li>
                <li><strong>Tautochrone:</strong> Time to reach the bottom is the same regardless of starting point!</li>
                <li><strong>Isochrone:</strong> A pendulum swinging along a cycloid has constant period regardless of amplitude</li>
            </ul>
        </div>

        <!-- History -->
        <div class="card">
            <h2>A Mathematical Duel</h2>
            <p>The brachistochrone problem sparked one of history's greatest intellectual rivalries.</p>

            <div class="timeline">
                <div class="timeline-item">
                    <div class="timeline-date">June 1696</div>
                    <div class="timeline-content">Johann Bernoulli publishes the challenge in <em>Acta Eruditorum</em>: "Find the curve of fastest descent." He already knew the answer but wanted to test Europe's mathematicians.</div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">January 1697</div>
                    <div class="timeline-content">Isaac Newton receives the problem at 4 PM after a long day at the Royal Mint. He solves it <strong>before going to bed that night</strong> and sends his anonymous solution the next morning.</div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">May 1697</div>
                    <div class="timeline-content">Solutions arrive from Leibniz, L'Hopital, and Johann's brother Jakob Bernoulli. Johann recognizes Newton's anonymous solution: "I recognize the lion by his claw."</div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">1766</div>
                    <div class="timeline-content">Euler formalizes the techniques used to solve such problems, creating the <strong>Calculus of Variations</strong> - a new branch of mathematics.</div>
                </div>
            </div>

            <div class="quote">
                "I recognize the lion by his claw."
                <div class="quote-author">- Johann Bernoulli, upon seeing Newton's anonymous solution</div>
            </div>
        </div>

        <!-- Why it works -->
        <div class="card">
            <h2>The Physics: Why Curves Beat Lines</h2>

            <div class="insight-box">
                <h3>Key Insight</h3>
                <p>Total travel time depends on both <strong>distance</strong> and <strong>speed</strong>. The straight line minimizes distance but wastes time traveling slowly at the start. The cycloid sacrifices distance to gain speed early, and speed matters more.</p>
            </div>

            <p><strong>Three factors at play:</strong></p>

            <p><strong>1. Steeper = Faster Acceleration</strong><br>
            The cycloid dips down sharply at the beginning. This steep initial descent converts potential energy to kinetic energy quickly, giving the ball high speed for most of its journey.</p>

            <p><strong>2. The Speed Advantage Compounds</strong><br>
            A ball moving at 2x the speed covers ground 2x as fast. The cycloid's early speed boost means it spends less time on each segment of the path, even though the total path is longer.</p>

            <p><strong>3. The Optimal Trade-off</strong><br>
            The cycloid represents the mathematically optimal balance: enough initial steepness to build speed, but not so much extra distance that the advantage is lost. Any other curve is suboptimal.</p>

            <div class="formula">
                Time = integral of ds/v = integral of sqrt(1 + (dy/dx)^2) / sqrt(2gy) dx
            </div>
            <p style="text-align: center; color: #888; font-size: 0.9rem;">The integral minimized by the brachistochrone curve</p>
        </div>

        <!-- Tautochrone property -->
        <div class="card">
            <h2>The Tautochrone: Equal Time from Anywhere</h2>
            <p>The cycloid has another astounding property: if you release balls from <em>any point</em> along the curve, they all reach the bottom at exactly the same time!</p>
            <p>This "tautochrone" property (Greek for "same time") means a cycloid-shaped bowl is perfectly isochronous. Christiaan Huygens discovered this in 1659 and used it to design more accurate pendulum clocks - if a pendulum swings along a cycloid, its period is constant regardless of amplitude.</p>

            <div class="insight-box">
                <h3>Same Time, Any Start</h3>
                <p>Release balls at the top, middle, or near the bottom of a cycloid slide - they all arrive together! Higher starting points give more distance but proportionally more speed.</p>
            </div>
        </div>

        <!-- Real-world applications -->
        <div class="card">
            <h2>Real-World Applications</h2>
            <p>The brachistochrone principle appears throughout engineering and nature:</p>

            <div class="applications">
                <div class="app-card">
                    <div class="app-icon">&#127906;</div>
                    <div class="app-title">Roller Coasters</div>
                    <div class="app-desc">First drops are designed steep to build speed quickly, following brachistochrone-like profiles</div>
                </div>
                <div class="app-card">
                    <div class="app-icon">&#9975;</div>
                    <div class="app-title">Ski Jumping</div>
                    <div class="app-desc">Ramp profiles optimize for maximum speed at takeoff using similar principles</div>
                </div>
                <div class="app-card">
                    <div class="app-icon">&#128664;</div>
                    <div class="app-title">Highway Design</div>
                    <div class="app-desc">Exit ramp curves balance speed and safety using variational calculus</div>
                </div>
                <div class="app-card">
                    <div class="app-icon">&#127776;</div>
                    <div class="app-title">Spacecraft Trajectories</div>
                    <div class="app-desc">Optimal orbital transfers use similar minimum-time path calculations</div>
                </div>
            </div>
        </div>

        <div class="footer">
            <p>Sources: <a href="https://en.wikipedia.org/wiki/Brachistochrone_curve" target="_blank">Wikipedia</a>,
            <a href="https://mathworld.wolfram.com/BrachistochroneProblem.html" target="_blank">Wolfram MathWorld</a></p>
            <p style="margin-top: 10px;">Part of <a href="../index.html">CCAB</a> - Surprising Paradoxes Collection</p>
        </div>
    </main>

    <script>
        // === BRACHISTOCHRONE RACE SIMULATION ===
        const raceCanvas = document.getElementById('raceCanvas');
        const raceCtx = raceCanvas.getContext('2d');
        const speedCanvas = document.getElementById('speedCanvas');
        const speedCtx = speedCanvas.getContext('2d');

        // High DPI setup
        const dpr = window.devicePixelRatio || 1;
        const raceRect = raceCanvas.getBoundingClientRect();
        raceCanvas.width = raceRect.width * dpr;
        raceCanvas.height = raceRect.height * dpr;
        raceCtx.scale(dpr, dpr);
        raceCanvas.style.width = raceRect.width + 'px';
        raceCanvas.style.height = raceRect.height + 'px';

        const speedRect = speedCanvas.getBoundingClientRect();
        speedCanvas.width = speedRect.width * dpr;
        speedCanvas.height = 150 * dpr;
        speedCtx.scale(dpr, dpr);
        speedCanvas.style.width = speedRect.width + 'px';
        speedCanvas.style.height = '150px';

        const W = raceRect.width;
        const H = raceRect.height;
        const speedW = speedRect.width;
        const speedH = 150;

        // Physics parameters
        let g = 9.81;
        let animSpeed = 1;
        let showVectors = false;
        const scale = 150; // pixels per meter

        // Start and end points
        const startX = 80;
        const startY = 60;
        const endX = W - 80;
        const endY = H - 80;

        // Convert to meters
        const x0 = 0;
        const y0 = 0;
        const x1 = (endX - startX) / scale;
        const y1 = (endY - startY) / scale;

        // Custom path points
        let customPoints = [];

        // Curve definitions
        const curves = {
            cycloid: { color: '#00ff88', points: [], ball: null, time: null, finished: false, speedHistory: [] },
            straight: { color: '#ff6b6b', points: [], ball: null, time: null, finished: false, speedHistory: [] },
            circular: { color: '#4ecdc4', points: [], ball: null, time: null, finished: false, speedHistory: [] },
            parabola: { color: '#ffd93d', points: [], ball: null, time: null, finished: false, speedHistory: [] },
            custom: { color: '#ff88ff', points: [], ball: null, time: null, finished: false, speedHistory: [] }
        };

        let isRacing = false;
        let raceTime = 0;
        let finishOrder = [];

        // Generate cycloid curve
        function generateCycloid() {
            const points = [];
            let bestR = 0;
            let bestTheta = 0;
            let bestError = Infinity;

            // Search for best parameters
            for (let r = 0.1; r < 5; r += 0.01) {
                for (let theta = 0.1; theta < Math.PI * 2; theta += 0.01) {
                    const x = r * (theta - Math.sin(theta));
                    const y = r * (1 - Math.cos(theta));
                    const error = Math.sqrt((x - x1) ** 2 + (y - y1) ** 2);
                    if (error < bestError) {
                        bestError = error;
                        bestR = r;
                        bestTheta = theta;
                    }
                }
            }

            // Generate points
            const numPoints = 100;
            for (let i = 0; i <= numPoints; i++) {
                const theta = (i / numPoints) * bestTheta;
                const x = bestR * (theta - Math.sin(theta));
                const y = bestR * (1 - Math.cos(theta));
                points.push({ x, y });
            }

            return points;
        }

        // Generate straight line
        function generateStraight() {
            const points = [];
            const numPoints = 100;
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                points.push({ x: t * x1, y: t * y1 });
            }
            return points;
        }

        // Generate circular arc
        function generateCircular() {
            const points = [];
            const midX = x1 / 2;
            const midY = y1 / 2;
            const chord = Math.sqrt(x1 * x1 + y1 * y1);
            const sagitta = chord * 0.3;
            const r = (sagitta * sagitta + (chord / 2) ** 2) / (2 * sagitta);
            const cx = midX;
            const cy = midY - (r - sagitta);

            const startAngle = Math.atan2(y0 - cy, x0 - cx);
            const endAngle = Math.atan2(y1 - cy, x1 - cx);

            const numPoints = 100;
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const angle = startAngle + t * (endAngle - startAngle);
                const x = cx + r * Math.cos(angle);
                const y = cy + r * Math.sin(angle);
                points.push({ x, y });
            }
            return points;
        }

        // Generate parabola
        function generateParabola() {
            const points = [];
            const a = y1 / (x1 * x1);

            const numPoints = 100;
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const x = t * x1;
                const y = a * x * x;
                points.push({ x, y });
            }
            return points;
        }

        // Generate custom curve from points
        function generateCustom() {
            if (customPoints.length < 2) {
                return [];
            }

            // Sort by x coordinate
            const sorted = [...customPoints].sort((a, b) => a.x - b.x);

            // Add start and end if not present
            const pts = [{ x: 0, y: 0 }];
            sorted.forEach(p => {
                const mx = (p.x - startX) / scale;
                const my = (p.y - startY) / scale;
                if (mx > 0 && mx < x1) {
                    pts.push({ x: mx, y: my });
                }
            });
            pts.push({ x: x1, y: y1 });

            // Interpolate to get more points
            const points = [];
            const numPoints = 100;

            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const targetX = t * x1;

                // Find the two points to interpolate between
                let p1 = pts[0];
                let p2 = pts[pts.length - 1];

                for (let j = 0; j < pts.length - 1; j++) {
                    if (pts[j].x <= targetX && pts[j + 1].x >= targetX) {
                        p1 = pts[j];
                        p2 = pts[j + 1];
                        break;
                    }
                }

                const segT = (p2.x - p1.x) > 0 ? (targetX - p1.x) / (p2.x - p1.x) : 0;
                const y = p1.y + segT * (p2.y - p1.y);

                points.push({ x: targetX, y: y });
            }

            return points;
        }

        // Initialize curves
        function initCurves() {
            curves.cycloid.points = generateCycloid();
            curves.straight.points = generateStraight();
            curves.circular.points = generateCircular();
            curves.parabola.points = generateParabola();
            curves.custom.points = generateCustom();

            // Initialize balls
            for (const key in curves) {
                curves[key].ball = { index: 0, x: 0, y: 0, v: 0, s: 0, vx: 0, vy: 0 };
                curves[key].time = null;
                curves[key].finished = false;
                curves[key].speedHistory = [];
            }

            isRacing = false;
            raceTime = 0;
            finishOrder = [];

            // Show/hide custom result card
            const customCard = document.getElementById('customResultCard');
            customCard.style.display = curves.custom.points.length > 0 ? 'block' : 'none';

            updateResults();
            drawRace();
            drawSpeedGraph();
        }

        // Physics step for a ball on a curve
        function updateBall(curve, dt) {
            if (curve.finished || curve.points.length < 2) return;

            const ball = curve.ball;
            const points = curve.points;

            if (ball.index >= points.length - 1) {
                curve.finished = true;
                curve.time = raceTime;
                finishOrder.push(curve);
                return;
            }

            const p0 = points[ball.index];
            const p1 = points[Math.min(ball.index + 1, points.length - 1)];

            const dx = p1.x - p0.x;
            const dy = p1.y - p0.y;
            const ds = Math.sqrt(dx * dx + dy * dy);

            if (ds < 0.0001) {
                ball.index++;
                return;
            }

            const tx = dx / ds;
            const ty = dy / ds;

            // Component of gravity along tangent
            const gTangent = g * ty;

            // Update velocity
            ball.v += gTangent * dt;
            if (ball.v < 0) ball.v = 0.01;

            // Velocity components for drawing
            ball.vx = ball.v * tx;
            ball.vy = ball.v * ty;

            // Update position along curve
            ball.s += ball.v * dt;

            // Find new index based on arc length
            let arcLength = 0;
            for (let i = 1; i < points.length; i++) {
                const px = points[i].x - points[i - 1].x;
                const py = points[i].y - points[i - 1].y;
                arcLength += Math.sqrt(px * px + py * py);

                if (arcLength >= ball.s) {
                    ball.index = i;
                    ball.x = points[i].x;
                    ball.y = points[i].y;
                    break;
                }
            }

            // Use energy conservation for accurate velocity
            ball.v = Math.sqrt(2 * g * Math.max(0, ball.y) + 0.01);

            // Record speed for graph
            curve.speedHistory.push({ time: raceTime, speed: ball.v });
        }

        // Draw race
        function drawRace() {
            raceCtx.clearRect(0, 0, W, H);

            // Background
            const bgGrad = raceCtx.createLinearGradient(0, 0, 0, H);
            bgGrad.addColorStop(0, '#0f0f23');
            bgGrad.addColorStop(1, '#1a1a2e');
            raceCtx.fillStyle = bgGrad;
            raceCtx.fillRect(0, 0, W, H);

            // Grid
            raceCtx.strokeStyle = 'rgba(255,255,255,0.05)';
            raceCtx.lineWidth = 1;
            for (let x = 0; x < W; x += 50) {
                raceCtx.beginPath();
                raceCtx.moveTo(x, 0);
                raceCtx.lineTo(x, H);
                raceCtx.stroke();
            }
            for (let y = 0; y < H; y += 50) {
                raceCtx.beginPath();
                raceCtx.moveTo(0, y);
                raceCtx.lineTo(W, y);
                raceCtx.stroke();
            }

            // Start and end labels
            raceCtx.fillStyle = '#fff';
            raceCtx.font = 'bold 16px Nunito';
            raceCtx.textAlign = 'center';
            raceCtx.fillText('A', startX, startY - 25);
            raceCtx.fillText('B', endX, endY + 35);

            // Start marker
            raceCtx.beginPath();
            raceCtx.arc(startX, startY, 8, 0, Math.PI * 2);
            raceCtx.fillStyle = '#fff';
            raceCtx.fill();

            // End marker
            raceCtx.beginPath();
            raceCtx.arc(endX, endY, 8, 0, Math.PI * 2);
            raceCtx.fillStyle = '#fff';
            raceCtx.fill();

            // Draw custom points if any
            customPoints.forEach(p => {
                raceCtx.beginPath();
                raceCtx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                raceCtx.fillStyle = 'rgba(255,136,255,0.5)';
                raceCtx.fill();
                raceCtx.strokeStyle = '#ff88ff';
                raceCtx.lineWidth = 1;
                raceCtx.stroke();
            });

            // Draw curves
            const drawOrder = ['custom', 'parabola', 'circular', 'straight', 'cycloid'];

            for (const key of drawOrder) {
                const curve = curves[key];
                if (curve.points.length < 2) continue;

                raceCtx.strokeStyle = curve.color;
                raceCtx.lineWidth = key === 'cycloid' ? 4 : 3;
                raceCtx.beginPath();

                for (let i = 0; i < curve.points.length; i++) {
                    const px = startX + curve.points[i].x * scale;
                    const py = startY + curve.points[i].y * scale;
                    if (i === 0) {
                        raceCtx.moveTo(px, py);
                    } else {
                        raceCtx.lineTo(px, py);
                    }
                }
                raceCtx.stroke();

                // Draw ball
                if (curve.points.length > 0) {
                    const ball = curve.ball;
                    const bx = startX + ball.x * scale;
                    const by = startY + ball.y * scale;

                    // Glow effect
                    raceCtx.beginPath();
                    raceCtx.arc(bx, by, 18, 0, Math.PI * 2);
                    raceCtx.fillStyle = curve.color + '30';
                    raceCtx.fill();

                    raceCtx.beginPath();
                    raceCtx.arc(bx, by, 12, 0, Math.PI * 2);
                    raceCtx.fillStyle = curve.color;
                    raceCtx.fill();

                    // Velocity vector
                    if (showVectors && isRacing && ball.v > 0.1) {
                        const arrowScale = 15;
                        const ax = bx + ball.vx * arrowScale;
                        const ay = by + ball.vy * arrowScale;

                        raceCtx.strokeStyle = curve.color;
                        raceCtx.lineWidth = 2;
                        raceCtx.beginPath();
                        raceCtx.moveTo(bx, by);
                        raceCtx.lineTo(ax, ay);
                        raceCtx.stroke();

                        // Arrowhead
                        const angle = Math.atan2(ay - by, ax - bx);
                        raceCtx.beginPath();
                        raceCtx.moveTo(ax, ay);
                        raceCtx.lineTo(ax - 8 * Math.cos(angle - 0.4), ay - 8 * Math.sin(angle - 0.4));
                        raceCtx.lineTo(ax - 8 * Math.cos(angle + 0.4), ay - 8 * Math.sin(angle + 0.4));
                        raceCtx.closePath();
                        raceCtx.fillStyle = curve.color;
                        raceCtx.fill();
                    }
                }
            }

            // Time display
            raceCtx.fillStyle = '#fff';
            raceCtx.font = '16px Courier New';
            raceCtx.textAlign = 'left';
            raceCtx.fillText(`Time: ${raceTime.toFixed(3)}s`, 20, 30);
            raceCtx.fillText(`Gravity: ${g.toFixed(2)} m/s^2`, 20, 50);

            // Winner display
            if (finishOrder.length > 0) {
                const winnerName = Object.keys(curves).find(k => curves[k] === finishOrder[0]);
                raceCtx.fillStyle = finishOrder[0].color;
                raceCtx.font = 'bold 16px Nunito';
                raceCtx.textAlign = 'right';
                raceCtx.fillText(`Winner: ${winnerName.toUpperCase()}!`, W - 20, 30);
            }
        }

        // Draw speed graph
        function drawSpeedGraph() {
            speedCtx.clearRect(0, 0, speedW, speedH);

            // Background
            speedCtx.fillStyle = 'rgba(0,0,0,0.2)';
            speedCtx.fillRect(0, 0, speedW, speedH);

            // Axis labels
            speedCtx.fillStyle = 'rgba(255,255,255,0.5)';
            speedCtx.font = '10px Nunito';
            speedCtx.textAlign = 'left';
            speedCtx.fillText('Speed (m/s)', 5, 15);
            speedCtx.textAlign = 'right';
            speedCtx.fillText('Time', speedW - 5, speedH - 5);

            // Find max speed and time for scaling
            let maxSpeed = 1;
            let maxTime = 1;

            for (const key in curves) {
                const history = curves[key].speedHistory;
                history.forEach(h => {
                    if (h.speed > maxSpeed) maxSpeed = h.speed;
                    if (h.time > maxTime) maxTime = h.time;
                });
            }

            // Draw speed lines
            const padding = 30;
            const graphW = speedW - padding * 2;
            const graphH = speedH - padding;

            for (const key in curves) {
                const curve = curves[key];
                if (curve.speedHistory.length < 2) continue;

                speedCtx.strokeStyle = curve.color;
                speedCtx.lineWidth = 2;
                speedCtx.beginPath();

                curve.speedHistory.forEach((h, i) => {
                    const x = padding + (h.time / maxTime) * graphW;
                    const y = speedH - padding - (h.speed / maxSpeed) * graphH;

                    if (i === 0) {
                        speedCtx.moveTo(x, y);
                    } else {
                        speedCtx.lineTo(x, y);
                    }
                });

                speedCtx.stroke();
            }

            // Current speeds
            let yOffset = 25;
            for (const key in curves) {
                const curve = curves[key];
                if (curve.points.length < 2) continue;

                speedCtx.fillStyle = curve.color;
                speedCtx.font = '11px Courier New';
                speedCtx.textAlign = 'right';
                const currentSpeed = curve.ball ? curve.ball.v.toFixed(2) : '0.00';
                speedCtx.fillText(`${key}: ${currentSpeed} m/s`, speedW - 10, yOffset);
                yOffset += 14;
            }
        }

        // Update results display
        function updateResults() {
            for (const key in curves) {
                const curve = curves[key];
                const timeEl = document.getElementById(key + 'Time');
                const speedEl = document.getElementById(key + 'Speed');
                const rankEl = document.getElementById(key + 'Rank');

                if (!timeEl) continue;

                if (curve.time !== null) {
                    timeEl.textContent = curve.time.toFixed(3) + 's';
                    const rank = finishOrder.indexOf(curve) + 1;
                    if (rank === 1) {
                        rankEl.innerHTML = '<span class="winner-badge">WINNER</span>';
                    } else if (rank > 0) {
                        rankEl.textContent = '#' + rank;
                    }
                } else if (isRacing) {
                    timeEl.textContent = '...';
                    rankEl.textContent = '';
                } else {
                    timeEl.textContent = '-';
                    rankEl.textContent = '';
                }

                if (curve.ball && speedEl) {
                    speedEl.textContent = 'Speed: ' + curve.ball.v.toFixed(2) + ' m/s';
                }
            }
        }

        // Animation loop
        let lastTime = 0;
        function animate(time) {
            const rawDt = (time - lastTime) / 1000;
            const dt = Math.min(rawDt * animSpeed, 0.05);
            lastTime = time;

            if (isRacing) {
                raceTime += dt;

                // Update all balls with sub-steps
                const subSteps = 8;
                for (let i = 0; i < subSteps; i++) {
                    for (const key in curves) {
                        updateBall(curves[key], dt / subSteps);
                    }
                }

                updateResults();
                drawSpeedGraph();

                // Check if all finished
                let allDone = true;
                for (const key in curves) {
                    if (curves[key].points.length > 0 && !curves[key].finished) {
                        allDone = false;
                    }
                }
                if (allDone) {
                    isRacing = false;
                    document.getElementById('raceBtn').disabled = false;
                }
            }

            drawRace();
            requestAnimationFrame(animate);
        }

        // Event handlers
        document.getElementById('raceBtn').addEventListener('click', function() {
            if (!isRacing) {
                initCurves();
                isRacing = true;
                this.disabled = true;
            }
        });

        document.getElementById('resetBtn').addEventListener('click', function() {
            initCurves();
            document.getElementById('raceBtn').disabled = false;
        });

        document.getElementById('clearCustomBtn').addEventListener('click', function() {
            customPoints = [];
            initCurves();
        });

        // Canvas click for custom path
        raceCanvas.addEventListener('click', function(e) {
            if (isRacing) return;

            const rect = raceCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Only add points in valid region
            if (x > startX + 20 && x < endX - 20 && y > startY && y < endY) {
                customPoints.push({ x, y });
                initCurves();
            }
        });

        // Gravity slider
        const gravitySlider = document.getElementById('gravitySlider');
        const gravityValue = document.getElementById('gravityValue');
        gravitySlider.addEventListener('input', function() {
            g = parseFloat(this.value);
            gravityValue.textContent = g.toFixed(2) + ' m/s2';
        });

        // Planet presets
        document.querySelectorAll('[data-gravity]').forEach(btn => {
            btn.addEventListener('click', function() {
                g = parseFloat(this.dataset.gravity);
                gravitySlider.value = g;
                gravityValue.textContent = g.toFixed(2) + ' m/s2';
            });
        });

        // Speed slider
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        speedSlider.addEventListener('input', function() {
            animSpeed = parseFloat(this.value);
            speedValue.textContent = animSpeed.toFixed(2) + 'x';
        });

        // Vector toggle
        const vectorToggle = document.getElementById('vectorToggle');
        vectorToggle.addEventListener('click', function() {
            showVectors = !showVectors;
            this.classList.toggle('active', showVectors);
        });

        // === CYCLOID DEMONSTRATION ===
        const cycloidCanvas = document.getElementById('cycloidCanvas');
        const cycloidCtx = cycloidCanvas.getContext('2d');

        const cW = 600;
        const cH = 200;
        cycloidCanvas.width = cW * dpr;
        cycloidCanvas.height = cH * dpr;
        cycloidCtx.scale(dpr, dpr);
        cycloidCanvas.style.width = cW + 'px';
        cycloidCanvas.style.height = cH + 'px';

        let circleAngle = 0;
        let isRolling = false;
        let cycloidTrail = [];

        function drawCycloidDemo() {
            cycloidCtx.clearRect(0, 0, cW, cH);

            cycloidCtx.fillStyle = '#fafafa';
            cycloidCtx.fillRect(0, 0, cW, cH);

            const r = 30;
            const groundY = cH - 50;
            const startDemoX = 50;

            // Ground line
            cycloidCtx.strokeStyle = '#ccc';
            cycloidCtx.lineWidth = 2;
            cycloidCtx.beginPath();
            cycloidCtx.moveTo(0, groundY);
            cycloidCtx.lineTo(cW, groundY);
            cycloidCtx.stroke();

            // Circle center
            const cx = startDemoX + r * circleAngle;
            const cy = groundY - r;

            // Draw trail
            if (cycloidTrail.length > 1) {
                cycloidCtx.strokeStyle = '#00aa66';
                cycloidCtx.lineWidth = 3;
                cycloidCtx.beginPath();
                cycloidCtx.moveTo(cycloidTrail[0].x, cycloidTrail[0].y);
                for (let i = 1; i < cycloidTrail.length; i++) {
                    cycloidCtx.lineTo(cycloidTrail[i].x, cycloidTrail[i].y);
                }
                cycloidCtx.stroke();
            }

            // Draw circle
            cycloidCtx.strokeStyle = '#666';
            cycloidCtx.lineWidth = 2;
            cycloidCtx.beginPath();
            cycloidCtx.arc(cx, cy, r, 0, Math.PI * 2);
            cycloidCtx.stroke();

            // Radius line
            cycloidCtx.strokeStyle = '#999';
            cycloidCtx.setLineDash([3, 3]);
            cycloidCtx.beginPath();
            cycloidCtx.moveTo(cx, cy);
            cycloidCtx.lineTo(cx + r * Math.sin(circleAngle), cy + r * Math.cos(circleAngle));
            cycloidCtx.stroke();
            cycloidCtx.setLineDash([]);

            // Point on rim
            const px = cx - r * Math.sin(circleAngle);
            const py = cy + r * Math.cos(circleAngle);

            cycloidCtx.beginPath();
            cycloidCtx.arc(px, py, 6, 0, Math.PI * 2);
            cycloidCtx.fillStyle = '#ff6b6b';
            cycloidCtx.fill();

            // Labels
            cycloidCtx.fillStyle = '#333';
            cycloidCtx.font = '12px Nunito';
            cycloidCtx.textAlign = 'center';
            cycloidCtx.fillText('Rolling Circle', cx, cy - r - 15);
            cycloidCtx.fillText('Traced Point', px, py - 15);
        }

        function animateCycloidDemo() {
            if (isRolling) {
                circleAngle += 0.03;

                const r = 30;
                const groundY = cH - 50;
                const startDemoX = 50;
                const cx = startDemoX + r * circleAngle;
                const cy = groundY - r;
                const px = cx - r * Math.sin(circleAngle);
                const py = cy + r * Math.cos(circleAngle);

                cycloidTrail.push({ x: px, y: py });

                if (circleAngle > Math.PI * 4) {
                    isRolling = false;
                    document.getElementById('rollBtn').innerHTML = '<span>&#9654;</span> Roll Circle';
                }
            }

            drawCycloidDemo();
            requestAnimationFrame(animateCycloidDemo);
        }

        document.getElementById('rollBtn').addEventListener('click', function() {
            if (!isRolling) {
                circleAngle = 0;
                cycloidTrail = [];
                isRolling = true;
                this.innerHTML = '<span>&#9632;</span> Rolling...';
            }
        });

        // Handle window resize
        function handleResize() {
            const newRect = raceCanvas.getBoundingClientRect();
            raceCanvas.width = newRect.width * dpr;
            raceCanvas.height = newRect.height * dpr;
            raceCtx.scale(dpr, dpr);
            raceCanvas.style.width = newRect.width + 'px';
            raceCanvas.style.height = newRect.height + 'px';

            const newSpeedRect = speedCanvas.getBoundingClientRect();
            speedCanvas.width = newSpeedRect.width * dpr;
            speedCanvas.height = 150 * dpr;
            speedCtx.scale(dpr, dpr);
            speedCanvas.style.width = newSpeedRect.width + 'px';
            speedCanvas.style.height = '150px';

            initCurves();
        }

        window.addEventListener('resize', handleResize);

        // Initialize
        initCurves();
        requestAnimationFrame(animate);
        requestAnimationFrame(animateCycloidDemo);
        drawCycloidDemo();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
