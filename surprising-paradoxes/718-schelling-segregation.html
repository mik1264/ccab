<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schelling's Segregation Model - How Mild Preferences Create Extreme Patterns</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8f8;
            line-height: 1.8;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 12px 24px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            color: #ffd700;
            text-decoration: none;
            border-radius: 30px;
            font-size: 14px;
            z-index: 1000;
            transition: all 0.3s;
            border: 1px solid rgba(255,215,0,0.3);
        }

        .back-link:hover {
            background: rgba(255,215,0,0.2);
            transform: translateX(-5px);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 80px 30px 60px;
        }

        header {
            text-align: center;
            margin-bottom: 60px;
        }

        h1 {
            font-size: 2.8rem;
            font-weight: 400;
            color: #ffd700;
            margin-bottom: 20px;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 1.4rem;
            color: #a8b2d1;
            font-style: italic;
        }

        .paradox-statement {
            background: linear-gradient(135deg, rgba(255,215,0,0.15) 0%, rgba(255,107,107,0.15) 100%);
            border-left: 4px solid #ffd700;
            padding: 30px 40px;
            margin: 40px 0;
            border-radius: 0 20px 20px 0;
            font-size: 1.3rem;
            text-align: center;
        }

        h2 {
            font-size: 1.8rem;
            color: #ffd700;
            margin: 50px 0 25px;
            font-weight: 400;
        }

        p {
            margin-bottom: 20px;
            color: #c8d0e8;
        }

        .simulation-container {
            background: rgba(0,0,0,0.3);
            border-radius: 20px;
            padding: 30px;
            margin: 40px 0;
            border: 1px solid rgba(255,215,0,0.2);
        }

        .sim-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .sim-title {
            font-size: 1.2rem;
            color: #ffd700;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            background: rgba(255,215,0,0.2);
            border: 1px solid rgba(255,215,0,0.5);
            color: #ffd700;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(255,215,0,0.4);
        }

        button.active {
            background: #ffd700;
            color: #1a1a2e;
        }

        .main-display {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
            margin-top: 20px;
        }

        @media (max-width: 900px) {
            .main-display {
                grid-template-columns: 1fr;
            }
        }

        .grid-container {
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gridCanvas {
            border-radius: 10px;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .parameter-box {
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 20px;
        }

        .parameter-box h4 {
            color: #ffd700;
            margin-bottom: 15px;
            font-weight: normal;
        }

        .slider-group {
            margin-bottom: 15px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            color: #a8b2d1;
            font-size: 0.9rem;
            margin-bottom: 8px;
        }

        .slider-value {
            color: #ffd700;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
            accent-color: #ffd700;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
        }

        .tolerance-highlight {
            background: linear-gradient(135deg, rgba(255,107,107,0.2) 0%, rgba(255,215,0,0.2) 100%);
            border: 1px solid rgba(255,215,0,0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 10px;
        }

        .tolerance-description {
            font-size: 0.85rem;
            color: #c8d0e8;
            line-height: 1.6;
        }

        .stats-box {
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 20px;
        }

        .stats-box h4 {
            color: #ffd700;
            margin-bottom: 15px;
            font-weight: normal;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-name {
            color: #a8b2d1;
            font-size: 0.9rem;
        }

        .stat-value {
            color: #ffd700;
            font-weight: bold;
        }

        .stat-value.good { color: #4ade80; }
        .stat-value.bad { color: #ff6b6b; }
        .stat-value.neutral { color: #a8b2d1; }

        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .legend-color.blue { background: #4a90d9; }
        .legend-color.orange { background: #ff8c42; }
        .legend-color.empty { background: #2a2a4a; border: 1px solid #444; }

        .legend-text {
            color: #a8b2d1;
            font-size: 0.9rem;
        }

        .graphs-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 700px) {
            .graphs-container {
                grid-template-columns: 1fr;
            }
        }

        .graph-box {
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 20px;
        }

        .graph-box h4 {
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 10px;
            font-weight: normal;
        }

        .graph-canvas {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            width: 100%;
            height: 120px;
        }

        .insight-box {
            background: linear-gradient(135deg, rgba(74,222,128,0.1) 0%, rgba(34,211,238,0.1) 100%);
            border-left: 4px solid #4ade80;
            padding: 25px 30px;
            margin: 30px 0;
            border-radius: 0 15px 15px 0;
        }

        .insight-box h4 {
            color: #4ade80;
            margin-bottom: 10px;
        }

        .math-box {
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
            font-family: 'Courier New', monospace;
        }

        .math-box h4 {
            color: #ffd700;
            margin-bottom: 15px;
            font-family: 'Georgia', serif;
        }

        .formula {
            color: #4ade80;
            font-size: 1.1rem;
            margin: 10px 0;
        }

        .explanation {
            color: #888;
            font-size: 0.9rem;
            margin-left: 20px;
        }

        .application {
            display: flex;
            gap: 20px;
            background: rgba(0,0,0,0.2);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            align-items: flex-start;
        }

        .app-icon {
            font-size: 2rem;
            min-width: 50px;
            text-align: center;
        }

        .app-content h5 {
            color: #ffd700;
            margin-bottom: 5px;
        }

        .app-content p {
            color: #a8b2d1;
            font-size: 0.95rem;
            margin: 0;
        }

        footer {
            margin-top: 60px;
            padding-top: 30px;
            border-top: 1px solid rgba(255,255,255,0.1);
            text-align: center;
            color: #666;
            font-size: 0.9rem;
        }

        footer a {
            color: #ffd700;
            text-decoration: none;
        }

        .equilibrium-banner {
            background: linear-gradient(135deg, rgba(74,222,128,0.3) 0%, rgba(34,211,238,0.3) 100%);
            border: 2px solid #4ade80;
            border-radius: 10px;
            padding: 15px 20px;
            text-align: center;
            margin-top: 20px;
            color: #4ade80;
            font-size: 1.1rem;
            display: none;
        }

        .equilibrium-banner.show {
            display: block;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .speed-control input {
            width: 80px;
        }

        .speed-label {
            color: #888;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>Schelling's Segregation Model</h1>
            <p class="subtitle">When Mild Preferences Create Extreme Patterns</p>
        </header>

        <div class="paradox-statement">
            <strong>Even when individuals prefer diversity, the collective outcome is extreme segregation.</strong>
        </div>

        <p>In 1971, economist <strong>Thomas Schelling</strong> (later Nobel laureate) discovered a troubling truth about social dynamics: even when every person in a neighborhood would be perfectly happy with diverse neighbors, the neighborhood can still become completely segregated. The paradox? <em>Nobody wanted this outcome.</em></p>

        <p>Imagine residents who only ask: "Do at least 30% of my neighbors look like me?" This mild preference‚Äîcompatible with 70% different neighbors‚Äîinevitably produces neighborhoods that are 90%+ homogeneous. The model reveals how <strong>individual tolerance and collective segregation can coexist</strong>.</p>

        <h2>Watch Segregation Emerge</h2>

        <div class="simulation-container">
            <div class="sim-header">
                <span class="sim-title">Interactive Simulation</span>
                <div class="controls">
                    <button id="startBtn" class="active">‚ñ∂ Start</button>
                    <button id="stepBtn">Step</button>
                    <button id="resetBtn">‚Ü∫ Reset</button>
                    <div class="speed-control">
                        <span class="speed-label">Speed:</span>
                        <input type="range" id="speedSlider" min="1" max="100" value="50">
                    </div>
                </div>
            </div>

            <div class="main-display">
                <div class="grid-container">
                    <canvas id="gridCanvas" width="500" height="500"></canvas>
                </div>

                <div class="side-panel">
                    <div class="parameter-box">
                        <h4>Parameters</h4>

                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Tolerance Threshold</span>
                                <span class="slider-value" id="toleranceValue">30%</span>
                            </div>
                            <input type="range" id="toleranceSlider" min="0" max="80" value="30">
                            <div class="tolerance-highlight">
                                <div class="tolerance-description" id="toleranceDesc">
                                    Agents are happy if at least <strong>30%</strong> of neighbors are similar. They would accept up to <strong>70%</strong> different neighbors.
                                </div>
                            </div>
                        </div>

                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Population Density</span>
                                <span class="slider-value" id="densityValue">85%</span>
                            </div>
                            <input type="range" id="densitySlider" min="50" max="95" value="85">
                        </div>

                        <div class="slider-group">
                            <div class="slider-label">
                                <span>Grid Size</span>
                                <span class="slider-value" id="sizeValue">50√ó50</span>
                            </div>
                            <input type="range" id="sizeSlider" min="20" max="80" value="50">
                        </div>
                    </div>

                    <div class="stats-box">
                        <h4>Live Statistics</h4>
                        <div class="stat-row">
                            <span class="stat-name">Step</span>
                            <span class="stat-value" id="stepCount">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-name">Unhappy Agents</span>
                            <span class="stat-value" id="unhappyCount">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-name">Happiness Rate</span>
                            <span class="stat-value good" id="happinessRate">100%</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-name">Segregation Index</span>
                            <span class="stat-value" id="segregationIndex">0%</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-name">Moves This Step</span>
                            <span class="stat-value neutral" id="movesCount">0</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color blue"></div>
                    <span class="legend-text">Group A</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color orange"></div>
                    <span class="legend-text">Group B</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color empty"></div>
                    <span class="legend-text">Empty</span>
                </div>
            </div>

            <div class="equilibrium-banner" id="equilibriumBanner">
                Equilibrium Reached! All agents are satisfied.
            </div>

            <div class="graphs-container">
                <div class="graph-box">
                    <h4>Segregation Index Over Time</h4>
                    <canvas class="graph-canvas" id="segregationGraph"></canvas>
                </div>
                <div class="graph-box">
                    <h4>Happiness Rate Over Time</h4>
                    <canvas class="graph-canvas" id="happinessGraph"></canvas>
                </div>
            </div>
        </div>

        <h2>The Mechanism</h2>

        <div class="math-box">
            <h4>How Agents Decide</h4>
            <div class="formula">similar_neighbors / total_neighbors ‚â• tolerance</div>
            <div class="explanation">An agent counts neighbors of the same type and compares to threshold.</div>
            <div class="formula">If unhappy ‚Üí move to random empty cell</div>
            <div class="explanation">Unhappy agents relocate, but their departure may make others unhappy.</div>
            <div class="formula">Cascade effect ‚Üí emergent segregation</div>
            <div class="explanation">Each move changes multiple agents' satisfaction, creating chain reactions.</div>
        </div>

        <h2>Why Does This Happen?</h2>

        <div class="insight-box">
            <h4>The Key Insight: Local Choices, Global Consequences</h4>
            <p>When a few agents at the boundary become unhappy and move, they change the neighborhood composition for everyone nearby. This triggers more moves, creating a <strong>cascade effect</strong>. The boundaries between groups become sharper and sharper until equilibrium‚Äîbut by then, the damage is done.</p>
        </div>

        <p>The model demonstrates a profound truth about <strong>emergent behavior</strong>: the collective pattern is not a simple sum of individual preferences. A population where everyone wants 30% similar neighbors doesn't stabilize at 30% segregation‚Äîit overshoots dramatically.</p>

        <p>Mathematically, this is because the system has multiple stable equilibria. Random mixing is <em>unstable</em>‚Äîany small perturbation grows. Complete segregation is <em>stable</em>‚Äîonce achieved, everyone is happy. The system rolls downhill toward segregation even when no one intended it.</p>

        <h2>Try These Experiments</h2>

        <div class="application">
            <div class="app-icon">üî¨</div>
            <div class="app-content">
                <h5>The Tipping Point</h5>
                <p>Set tolerance to 25%, then slowly increase it. Watch how the segregation index jumps dramatically somewhere between 30-40%. This is the critical threshold where integration becomes unstable.</p>
            </div>
        </div>

        <div class="application">
            <div class="app-icon">üìä</div>
            <div class="app-content">
                <h5>Density Matters</h5>
                <p>Compare high density (90%) vs low density (60%). Lower density means more empty spaces‚Äîmore room to escape‚Äîleading to faster but sometimes less extreme segregation.</p>
            </div>
        </div>

        <div class="application">
            <div class="app-icon">‚öñÔ∏è</div>
            <div class="app-content">
                <h5>The Paradox Zone</h5>
                <p>Set tolerance to exactly 50%. Agents would be happy with half-and-half neighbors‚Äîperfect integration! Yet watch as the system still segregates. Why? Because once a few agents cluster by chance, the cascade begins.</p>
            </div>
        </div>

        <h2>Real-World Implications</h2>

        <div class="application">
            <div class="app-icon">üèòÔ∏è</div>
            <div class="app-content">
                <h5>Residential Segregation</h5>
                <p>Studies of American cities show segregation patterns consistent with Schelling dynamics. Individual prejudice explains some but not all of it‚Äîthe model shows how mild preferences amplify into extreme outcomes.</p>
            </div>
        </div>

        <div class="application">
            <div class="app-icon">üè´</div>
            <div class="app-content">
                <h5>School Choice</h5>
                <p>When families have school choice, even small preferences for "schools like us" can produce highly segregated school systems‚Äîa Schelling effect in education policy.</p>
            </div>
        </div>

        <div class="application">
            <div class="app-icon">üí¨</div>
            <div class="app-content">
                <h5>Online Echo Chambers</h5>
                <p>Social media "unfollowing" based on mild disagreement can create extreme polarization‚Äîa digital Schelling segregation where like-minded users cluster.</p>
            </div>
        </div>

        <div class="application">
            <div class="app-icon">üß™</div>
            <div class="app-content">
                <h5>Policy Design</h5>
                <p>The model suggests that fighting segregation requires understanding tipping points. Small interventions at critical moments may prevent cascades that larger interventions can't reverse.</p>
            </div>
        </div>

        <h2>The Deeper Lesson</h2>

        <p>Schelling's model is a canonical example of <strong>emergence</strong>‚Äîcomplex global patterns arising from simple local rules. It warns us that we cannot judge a system's outcomes by looking at individual intentions. Even a world of tolerant people can produce intolerant-looking outcomes.</p>

        <p>This insight extends far beyond segregation: financial markets, traffic patterns, ecosystem dynamics, and social movements all exhibit emergent behaviors that surprise and sometimes dismay the individuals who create them. The whole is not just different from the sum of its parts‚Äîit can be its opposite.</p>

        <div class="paradox-statement" style="border-left-color: #4ade80; background: linear-gradient(135deg, rgba(74,222,128,0.15) 0%, rgba(34,211,238,0.15) 100%);">
            <strong>In a world of individually tolerant agents, collective intolerance emerges unbidden.</strong>
        </div>

        <footer>
            <p>Discovered by <strong>Thomas Schelling</strong> (1971) | Nobel Prize in Economics (2005) | Sources:
                <a href="https://en.wikipedia.org/wiki/Schelling%27s_model_of_segregation">Wikipedia</a>,
                <a href="https://www.jasss.org/15/1/6.html">JASSS</a>,
                <a href="https://ncase.me/polygons/">Parable of the Polygons</a>
            </p>
        </footer>
    </div>

    <script>
        // ========== CONFIGURATION ==========
        const COLORS = {
            EMPTY: '#2a2a4a',
            GROUP_A: '#4a90d9',
            GROUP_B: '#ff8c42',
            GROUP_A_UNHAPPY: '#2a5080',
            GROUP_B_UNHAPPY: '#994d20'
        };

        // ========== STATE ==========
        let gridSize = 50;
        let tolerance = 0.30;
        let density = 0.85;
        let grid = [];
        let running = false;
        let speed = 50;
        let stepCount = 0;
        let equilibrium = false;

        // History for graphs
        let segregationHistory = [];
        let happinessHistory = [];
        const MAX_HISTORY = 200;

        // Canvas contexts
        const gridCanvas = document.getElementById('gridCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const segGraph = document.getElementById('segregationGraph');
        const segCtx = segGraph.getContext('2d');
        const hapGraph = document.getElementById('happinessGraph');
        const hapCtx = hapGraph.getContext('2d');

        // ========== INITIALIZATION ==========
        function initGrid() {
            grid = [];
            for (let y = 0; y < gridSize; y++) {
                grid[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    if (Math.random() < density) {
                        // Randomly assign to group A or B (equal probability)
                        grid[y][x] = Math.random() < 0.5 ? 1 : 2;
                    } else {
                        grid[y][x] = 0; // Empty
                    }
                }
            }
            stepCount = 0;
            equilibrium = false;
            segregationHistory = [];
            happinessHistory = [];
            document.getElementById('equilibriumBanner').classList.remove('show');
        }

        // ========== NEIGHBOR ANALYSIS ==========
        function getNeighbors(x, y) {
            const neighbors = [];
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                        neighbors.push(grid[ny][nx]);
                    }
                }
            }
            return neighbors;
        }

        function isHappy(x, y) {
            const type = grid[y][x];
            if (type === 0) return true; // Empty cells are "happy"

            const neighbors = getNeighbors(x, y);
            const occupiedNeighbors = neighbors.filter(n => n !== 0);

            if (occupiedNeighbors.length === 0) return true; // No neighbors = happy

            const sameType = occupiedNeighbors.filter(n => n === type).length;
            return (sameType / occupiedNeighbors.length) >= tolerance;
        }

        // ========== STATISTICS ==========
        function calculateStats() {
            let totalAgents = 0;
            let unhappyAgents = 0;
            let totalSimilarNeighbors = 0;
            let totalNeighborPairs = 0;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const type = grid[y][x];
                    if (type === 0) continue;

                    totalAgents++;
                    if (!isHappy(x, y)) unhappyAgents++;

                    // Count similar neighbors for segregation index
                    const neighbors = getNeighbors(x, y);
                    const occupiedNeighbors = neighbors.filter(n => n !== 0);
                    const sameType = occupiedNeighbors.filter(n => n === type).length;

                    totalSimilarNeighbors += sameType;
                    totalNeighborPairs += occupiedNeighbors.length;
                }
            }

            const happinessRate = totalAgents > 0 ?
                ((totalAgents - unhappyAgents) / totalAgents * 100) : 100;

            // Segregation index: % of neighbors that are same type
            // 50% would be random, 100% is complete segregation
            const segregationIndex = totalNeighborPairs > 0 ?
                (totalSimilarNeighbors / totalNeighborPairs * 100) : 50;

            return {
                totalAgents,
                unhappyAgents,
                happinessRate,
                segregationIndex
            };
        }

        // ========== SIMULATION STEP ==========
        function step() {
            if (equilibrium) return 0;

            // Find all unhappy agents
            const unhappyAgents = [];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x] !== 0 && !isHappy(x, y)) {
                        unhappyAgents.push({x, y});
                    }
                }
            }

            if (unhappyAgents.length === 0) {
                equilibrium = true;
                document.getElementById('equilibriumBanner').classList.add('show');
                return 0;
            }

            // Find all empty cells
            const emptyCells = [];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x] === 0) {
                        emptyCells.push({x, y});
                    }
                }
            }

            if (emptyCells.length === 0) {
                equilibrium = true;
                return 0;
            }

            // Move unhappy agents (shuffle for randomness)
            shuffleArray(unhappyAgents);
            let movesMade = 0;
            const maxMoves = Math.min(unhappyAgents.length, emptyCells.length, Math.ceil(gridSize * gridSize * 0.1));

            for (let i = 0; i < maxMoves && i < unhappyAgents.length; i++) {
                const agent = unhappyAgents[i];

                // Find a random empty cell
                if (emptyCells.length === 0) break;

                const emptyIdx = Math.floor(Math.random() * emptyCells.length);
                const empty = emptyCells[emptyIdx];

                // Move agent
                grid[empty.y][empty.x] = grid[agent.y][agent.x];
                grid[agent.y][agent.x] = 0;

                // Update empty cells list
                emptyCells.splice(emptyIdx, 1);
                emptyCells.push({x: agent.x, y: agent.y});

                movesMade++;
            }

            stepCount++;
            return movesMade;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // ========== RENDERING ==========
        function drawGrid() {
            const cellSize = gridCanvas.width / gridSize;

            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const type = grid[y][x];
                    const happy = isHappy(x, y);

                    if (type === 0) {
                        gridCtx.fillStyle = COLORS.EMPTY;
                    } else if (type === 1) {
                        gridCtx.fillStyle = happy ? COLORS.GROUP_A : COLORS.GROUP_A_UNHAPPY;
                    } else {
                        gridCtx.fillStyle = happy ? COLORS.GROUP_B : COLORS.GROUP_B_UNHAPPY;
                    }

                    gridCtx.fillRect(
                        x * cellSize,
                        y * cellSize,
                        cellSize - 0.5,
                        cellSize - 0.5
                    );
                }
            }
        }

        function drawGraph(ctx, canvas, history, color, label, minVal = 0, maxVal = 100) {
            const w = canvas.width;
            const h = canvas.height;
            const dpr = window.devicePixelRatio || 1;

            // Set canvas size for retina
            if (canvas.width !== canvas.clientWidth * dpr) {
                canvas.width = canvas.clientWidth * dpr;
                canvas.height = canvas.clientHeight * dpr;
                ctx.scale(dpr, dpr);
            }

            const width = canvas.clientWidth;
            const height = canvas.clientHeight;

            ctx.clearRect(0, 0, width, height);

            if (history.length < 2) return;

            // Draw reference lines
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width, height / 2);
            ctx.stroke();

            // Draw 50% line for segregation (random baseline)
            if (label === 'seg') {
                ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                const y50 = height - ((50 - minVal) / (maxVal - minVal)) * height;
                ctx.moveTo(0, y50);
                ctx.lineTo(width, y50);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw graph line
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let i = 0; i < history.length; i++) {
                const x = (i / (history.length - 1)) * width;
                const y = height - ((history[i] - minVal) / (maxVal - minVal)) * height;

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw current value
            if (history.length > 0) {
                const lastVal = history[history.length - 1].toFixed(1);
                ctx.fillStyle = color;
                ctx.font = '12px Georgia';
                ctx.textAlign = 'right';
                ctx.fillText(lastVal + '%', width - 5, 15);
            }
        }

        function updateDisplay() {
            const stats = calculateStats();

            // Update stats display
            document.getElementById('stepCount').textContent = stepCount;
            document.getElementById('unhappyCount').textContent = stats.unhappyAgents;
            document.getElementById('happinessRate').textContent = stats.happinessRate.toFixed(1) + '%';
            document.getElementById('segregationIndex').textContent = stats.segregationIndex.toFixed(1) + '%';

            // Color code stats
            const happinessEl = document.getElementById('happinessRate');
            happinessEl.className = 'stat-value ' + (stats.happinessRate >= 95 ? 'good' : stats.happinessRate >= 70 ? '' : 'bad');

            const segEl = document.getElementById('segregationIndex');
            segEl.className = 'stat-value ' + (stats.segregationIndex >= 80 ? 'bad' : stats.segregationIndex >= 60 ? '' : 'good');

            // Update history
            segregationHistory.push(stats.segregationIndex);
            happinessHistory.push(stats.happinessRate);

            if (segregationHistory.length > MAX_HISTORY) {
                segregationHistory.shift();
                happinessHistory.shift();
            }

            // Draw
            drawGrid();
            drawGraph(segCtx, segGraph, segregationHistory, '#ff6b6b', 'seg');
            drawGraph(hapCtx, hapGraph, happinessHistory, '#4ade80', 'hap');
        }

        // ========== CONTROLS ==========
        function reset() {
            running = false;
            document.getElementById('startBtn').textContent = '‚ñ∂ Start';
            document.getElementById('startBtn').classList.remove('active');
            initGrid();
            updateDisplay();
            document.getElementById('movesCount').textContent = '0';
        }

        function singleStep() {
            const moves = step();
            document.getElementById('movesCount').textContent = moves;
            updateDisplay();
        }

        // ========== PARAMETER UPDATES ==========
        document.getElementById('toleranceSlider').addEventListener('input', function() {
            tolerance = parseInt(this.value) / 100;
            document.getElementById('toleranceValue').textContent = this.value + '%';
            document.getElementById('toleranceDesc').innerHTML =
                `Agents are happy if at least <strong>${this.value}%</strong> of neighbors are similar. ` +
                `They would accept up to <strong>${100 - this.value}%</strong> different neighbors.`;
        });

        document.getElementById('densitySlider').addEventListener('input', function() {
            density = parseInt(this.value) / 100;
            document.getElementById('densityValue').textContent = this.value + '%';
        });

        document.getElementById('sizeSlider').addEventListener('input', function() {
            gridSize = parseInt(this.value);
            document.getElementById('sizeValue').textContent = this.value + '√ó' + this.value;
        });

        document.getElementById('speedSlider').addEventListener('input', function() {
            speed = parseInt(this.value);
        });

        document.getElementById('startBtn').addEventListener('click', function() {
            running = !running;
            this.textContent = running ? '‚è∏ Pause' : '‚ñ∂ Start';
            this.classList.toggle('active', running);
        });

        document.getElementById('stepBtn').addEventListener('click', singleStep);
        document.getElementById('resetBtn').addEventListener('click', reset);

        // ========== MAIN LOOP ==========
        function gameLoop() {
            if (running && !equilibrium) {
                const stepsPerFrame = Math.max(1, Math.floor(speed / 20));
                let totalMoves = 0;
                for (let i = 0; i < stepsPerFrame; i++) {
                    totalMoves += step();
                    if (equilibrium) break;
                }
                document.getElementById('movesCount').textContent = totalMoves;
                updateDisplay();
            }

            const delay = Math.max(10, 150 - speed);
            setTimeout(gameLoop, delay);
        }

        // ========== INITIALIZATION ==========
        function init() {
            // Resize canvases
            const dpr = window.devicePixelRatio || 1;
            gridCanvas.width = 500 * dpr;
            gridCanvas.height = 500 * dpr;
            gridCanvas.style.width = '500px';
            gridCanvas.style.height = '500px';
            gridCtx.scale(dpr, dpr);

            initGrid();
            updateDisplay();
            gameLoop();
        }

        window.addEventListener('resize', () => {
            // Redraw on resize
            updateDisplay();
        });

        init();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
