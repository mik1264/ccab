<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parrondo's Paradox - Two Losing Games That Win Together</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8f8;
            line-height: 1.8;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 12px 24px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            color: #ffd700;
            text-decoration: none;
            border-radius: 30px;
            font-size: 14px;
            z-index: 1000;
            transition: all 0.3s;
            border: 1px solid rgba(255,215,0,0.3);
        }

        .back-link:hover {
            background: rgba(255,215,0,0.2);
            transform: translateX(-5px);
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 80px 30px 60px;
        }

        header {
            text-align: center;
            margin-bottom: 60px;
        }

        h1 {
            font-size: 3rem;
            font-weight: 400;
            color: #ffd700;
            margin-bottom: 20px;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 1.4rem;
            color: #a8b2d1;
            font-style: italic;
        }

        .paradox-statement {
            background: linear-gradient(135deg, rgba(255,215,0,0.15) 0%, rgba(255,107,107,0.15) 100%);
            border-left: 4px solid #ffd700;
            padding: 30px 40px;
            margin: 40px 0;
            border-radius: 0 20px 20px 0;
            font-size: 1.3rem;
            text-align: center;
        }

        h2 {
            font-size: 1.8rem;
            color: #ffd700;
            margin: 50px 0 25px;
            font-weight: 400;
        }

        p {
            margin-bottom: 20px;
            color: #c8d0e8;
        }

        .simulation-container {
            background: rgba(0,0,0,0.3);
            border-radius: 20px;
            padding: 30px;
            margin: 40px 0;
            border: 1px solid rgba(255,215,0,0.2);
        }

        .sim-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .sim-title {
            font-size: 1.2rem;
            color: #ffd700;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            background: rgba(255,215,0,0.2);
            border: 1px solid rgba(255,215,0,0.5);
            color: #ffd700;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(255,215,0,0.4);
        }

        button.active {
            background: #ffd700;
            color: #1a1a2e;
        }

        .graphs-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 800px) {
            .graphs-container {
                grid-template-columns: 1fr;
            }
        }

        .graph-box {
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }

        .graph-box h4 {
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 10px;
            font-weight: normal;
        }

        .graph-box.losing h4 { color: #ff6b6b; }
        .graph-box.losing .result { color: #ff6b6b; }
        .graph-box.winning h4 { color: #4ade80; }
        .graph-box.winning .result { color: #4ade80; }

        canvas {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            width: 100%;
            height: 150px;
        }

        .result {
            font-size: 1.5rem;
            font-weight: bold;
            margin-top: 10px;
        }

        .stats-row {
            display: flex;
            justify-content: space-around;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            color: #ffd700;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #888;
            margin-top: 5px;
        }

        .math-box {
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
            font-family: 'Courier New', monospace;
        }

        .math-box h4 {
            color: #ffd700;
            margin-bottom: 15px;
            font-family: 'Georgia', serif;
        }

        .formula {
            color: #4ade80;
            font-size: 1.1rem;
            margin: 10px 0;
        }

        .explanation {
            color: #888;
            font-size: 0.9rem;
            margin-left: 20px;
        }

        .insight-box {
            background: linear-gradient(135deg, rgba(74,222,128,0.1) 0%, rgba(34,211,238,0.1) 100%);
            border-left: 4px solid #4ade80;
            padding: 25px 30px;
            margin: 30px 0;
            border-radius: 0 15px 15px 0;
        }

        .insight-box h4 {
            color: #4ade80;
            margin-bottom: 10px;
        }

        .application {
            display: flex;
            gap: 20px;
            background: rgba(0,0,0,0.2);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            align-items: flex-start;
        }

        .app-icon {
            font-size: 2rem;
            min-width: 50px;
            text-align: center;
        }

        .app-content h5 {
            color: #ffd700;
            margin-bottom: 5px;
        }

        .app-content p {
            color: #a8b2d1;
            font-size: 0.95rem;
            margin: 0;
        }

        .coin-flip {
            display: inline-block;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            line-height: 40px;
            text-align: center;
            font-weight: bold;
            margin: 5px;
            animation: flip 0.5s ease-in-out;
        }

        .coin-flip.win { background: #4ade80; color: #000; }
        .coin-flip.lose { background: #ff6b6b; color: #000; }

        @keyframes flip {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(180deg); }
            100% { transform: rotateY(360deg); }
        }

        .recent-flips {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin: 15px 0;
            min-height: 50px;
            align-items: center;
        }

        footer {
            margin-top: 60px;
            padding-top: 30px;
            border-top: 1px solid rgba(255,255,255,0.1);
            text-align: center;
            color: #666;
            font-size: 0.9rem;
        }

        footer a {
            color: #ffd700;
            text-decoration: none;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .speed-control input {
            width: 100px;
            accent-color: #ffd700;
        }

        .speed-label {
            color: #888;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>Parrondo's Paradox</h1>
            <p class="subtitle">The Counterintuitive Mathematics of Winning by Losing</p>
        </header>

        <div class="paradox-statement">
            <strong>Two losing games, when combined, can produce a winning outcome.</strong>
        </div>

        <p>In 1996, Spanish physicist <strong>Juan Parrondo</strong> discovered something that seems to violate basic logic: two games that are individually guaranteed to lose money can be combined to consistently <em>win</em> money. This isn't a trick or an illusion‚Äîit's a profound mathematical truth with deep connections to physics, biology, and even cancer treatment.</p>

        <h2>The Two Games</h2>

        <div class="math-box">
            <h4>Game A: The Simple Losing Game</h4>
            <div class="formula">Win probability: 49.5%</div>
            <div class="explanation">A coin flip where you're slightly disadvantaged. Win $1 or lose $1.</div>
            <div class="formula">Expected value: -$0.01 per game</div>
            <div class="explanation">Over time, you will slowly but surely lose money.</div>
        </div>

        <div class="math-box">
            <h4>Game B: The Capital-Dependent Game</h4>
            <div class="formula">If your capital is divisible by 3: Win probability = 9.5% (terrible!)</div>
            <div class="formula">Otherwise: Win probability = 74.5% (great!)</div>
            <div class="explanation">This game has a hidden trap. The good odds seem great, but the terrible odds when your capital hits multiples of 3 creates a losing game overall.</div>
            <div class="formula">Expected value: ‚âà -$0.017 per game</div>
        </div>

        <h2>See the Paradox in Action</h2>

        <div class="simulation-container">
            <div class="sim-header">
                <span class="sim-title">Live Simulation</span>
                <div class="controls">
                    <button id="startBtn" class="active">‚ñ∂ Start</button>
                    <button id="resetBtn">‚Ü∫ Reset</button>
                    <div class="speed-control">
                        <span class="speed-label">Speed:</span>
                        <input type="range" id="speedSlider" min="1" max="100" value="50">
                    </div>
                </div>
            </div>

            <div class="recent-flips" id="recentFlips">
                <span style="color: #666">Waiting to start...</span>
            </div>

            <div class="graphs-container">
                <div class="graph-box losing">
                    <h4>Game A Only</h4>
                    <canvas id="graphA"></canvas>
                    <div class="result" id="resultA">$0</div>
                </div>
                <div class="graph-box losing">
                    <h4>Game B Only</h4>
                    <canvas id="graphB"></canvas>
                    <div class="result" id="resultB">$0</div>
                </div>
                <div class="graph-box winning">
                    <h4>A + B Combined</h4>
                    <canvas id="graphAB"></canvas>
                    <div class="result" id="resultAB">$0</div>
                </div>
            </div>

            <div class="stats-row">
                <div class="stat">
                    <div class="stat-value" id="totalGames">0</div>
                    <div class="stat-label">Games Played</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="winRateA">0%</div>
                    <div class="stat-label">Game A Win Rate</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="winRateB">0%</div>
                    <div class="stat-label">Game B Win Rate</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="winRateAB">0%</div>
                    <div class="stat-label">Combined Win Rate</div>
                </div>
            </div>
        </div>

        <h2>Why Does This Work?</h2>

        <div class="insight-box">
            <h4>The Key Insight: Games Are Not Independent</h4>
            <p>The paradox arises because Game B's outcome depends on your current capital. When you alternate between games, Game A's consistent bias <strong>pushes your capital away from multiples of 3</strong>, helping you avoid Game B's terrible odds more often. The games create a feedback loop that benefits the player.</p>
        </div>

        <p>Think of it like a <strong>ratchet mechanism</strong>: Game B has a "sawtooth" structure based on capital modulo 3. Game A acts as a random perturbation that, paradoxically, helps you climb the ratchet rather than fall down it.</p>

        <p>Mathematically, this is related to <strong>Brownian ratchets</strong>‚Äîsystems where random thermal fluctuations can be converted into directed motion through asymmetric periodic potentials. This same principle explains how molecular motors in your cells can convert random chemical energy into directed mechanical work.</p>

        <h2>Real-World Applications</h2>

        <div class="application">
            <div class="app-icon">üß¨</div>
            <div class="app-content">
                <h5>Molecular Motors</h5>
                <p>Proteins like kinesin and myosin use Brownian ratchet mechanisms to walk along cellular structures, carrying cargo despite random thermal noise. Parrondo's paradox helps explain how life extracts order from chaos.</p>
            </div>
        </div>

        <div class="application">
            <div class="app-icon">üíä</div>
            <div class="app-content">
                <h5>Cancer Treatment</h5>
                <p>A 2025 study in Physical Review E showed that alternating between maximum-dose and low-dose chemotherapy regimens‚Äîeach suboptimal alone‚Äîcan produce better outcomes than either approach used consistently.</p>
            </div>
        </div>

        <div class="application">
            <div class="app-icon">ü¶†</div>
            <div class="app-content">
                <h5>Slime Mold Strategy</h5>
                <p>Slime molds alternate between solitary wandering and colonial behavior. Neither strategy is optimal alone, but switching between them at the right times maximizes survival‚Äîa natural Parrondo's paradox.</p>
            </div>
        </div>

        <div class="application">
            <div class="app-icon">üìä</div>
            <div class="app-content">
                <h5>Investment Strategies</h5>
                <p>The paradox suggests that diversifying between individually suboptimal strategies can outperform sticking with any single approach‚Äîthough real markets are far more complex than these idealized games.</p>
            </div>
        </div>

        <h2>The Deeper Lesson</h2>

        <p>Parrondo's paradox challenges our intuition that "two wrongs don't make a right." In systems with <strong>state-dependent feedback</strong> and <strong>nonlinear dynamics</strong>, combining suboptimal strategies can create emergent benefits that neither possesses alone.</p>

        <p>This has profound implications for understanding complex systems‚Äîfrom protein folding to ecosystem dynamics to economic policy. Sometimes the path to success isn't choosing the "best" option, but strategically alternating between seemingly inferior ones.</p>

        <div class="paradox-statement" style="border-left-color: #4ade80; background: linear-gradient(135deg, rgba(74,222,128,0.15) 0%, rgba(34,211,238,0.15) 100%);">
            <strong>In a world of interconnected, state-dependent systems, losing + losing can equal winning.</strong>
        </div>

        <footer>
            <p>Discovered by <strong>Juan Parrondo</strong> (1996) | Sources:
                <a href="https://en.wikipedia.org/wiki/Parrondo's_paradox">Wikipedia</a>,
                <a href="https://www.scientificamerican.com/article/parrondos-paradox-explains-how-two-losing-strategies-combined-can-win/">Scientific American</a>,
                <a href="https://royalsocietypublishing.org/doi/10.1098/rsos.171685">Royal Society</a>
            </p>
        </footer>
    </div>

    <script>
        // Simulation parameters
        const pA = 0.495;           // Game A win probability
        const pB1 = 0.095;          // Game B bad odds (capital % 3 == 0)
        const pB2 = 0.745;          // Game B good odds
        const M = 3;                // Modulus for Game B

        // State
        let capitalA = 0, capitalB = 0, capitalAB = 0;
        let historyA = [0], historyB = [0], historyAB = [0];
        let winsA = 0, winsB = 0, winsAB = 0;
        let gamesPlayed = 0;
        let running = true;
        let speed = 50;
        let abTurn = 0; // 0 = A, 1 = B, 2 = B (pattern: ABB)
        let recentFlips = [];

        // Canvas contexts
        const ctxA = document.getElementById('graphA').getContext('2d');
        const ctxB = document.getElementById('graphB').getContext('2d');
        const ctxAB = document.getElementById('graphAB').getContext('2d');

        function resizeCanvases() {
            [ctxA, ctxB, ctxAB].forEach(ctx => {
                const canvas = ctx.canvas;
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * devicePixelRatio;
                canvas.height = rect.height * devicePixelRatio;
                ctx.scale(devicePixelRatio, devicePixelRatio);
            });
        }

        function playGameA() {
            return Math.random() < pA ? 1 : -1;
        }

        function playGameB(capital) {
            const p = (capital % M === 0) ? pB1 : pB2;
            return Math.random() < p ? 1 : -1;
        }

        function step() {
            gamesPlayed++;

            // Game A only
            const resultA = playGameA();
            capitalA += resultA;
            if (resultA > 0) winsA++;
            historyA.push(capitalA);

            // Game B only
            const resultB = playGameB(capitalB);
            capitalB += resultB;
            if (resultB > 0) winsB++;
            historyB.push(capitalB);

            // Combined: ABB pattern
            let resultAB;
            if (abTurn === 0) {
                resultAB = playGameA();
                recentFlips.push({type: 'A', win: resultAB > 0});
            } else {
                resultAB = playGameB(capitalAB);
                recentFlips.push({type: 'B', win: resultAB > 0});
            }
            capitalAB += resultAB;
            if (resultAB > 0) winsAB++;
            historyAB.push(capitalAB);
            abTurn = (abTurn + 1) % 3;

            // Keep history manageable
            const maxHistory = 500;
            if (historyA.length > maxHistory) {
                historyA = historyA.slice(-maxHistory);
                historyB = historyB.slice(-maxHistory);
                historyAB = historyAB.slice(-maxHistory);
            }

            // Keep recent flips short
            if (recentFlips.length > 10) recentFlips.shift();
        }

        function drawGraph(ctx, history, color) {
            const canvas = ctx.canvas;
            const w = canvas.width / devicePixelRatio;
            const h = canvas.height / devicePixelRatio;

            ctx.clearRect(0, 0, w, h);

            if (history.length < 2) return;

            // Find range
            const min = Math.min(...history);
            const max = Math.max(...history);
            const range = Math.max(Math.abs(min), Math.abs(max), 10);

            // Draw zero line
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.beginPath();
            ctx.moveTo(0, h/2);
            ctx.lineTo(w, h/2);
            ctx.stroke();

            // Draw graph
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let i = 0; i < history.length; i++) {
                const x = (i / (history.length - 1)) * w;
                const y = h/2 - (history[i] / range) * (h/2 - 10);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function updateDisplay() {
            // Update graphs
            drawGraph(ctxA, historyA, '#ff6b6b');
            drawGraph(ctxB, historyB, '#ff6b6b');
            drawGraph(ctxAB, historyAB, '#4ade80');

            // Update results
            document.getElementById('resultA').textContent = (capitalA >= 0 ? '+' : '') + '$' + capitalA;
            document.getElementById('resultB').textContent = (capitalB >= 0 ? '+' : '') + '$' + capitalB;
            document.getElementById('resultAB').textContent = (capitalAB >= 0 ? '+' : '') + '$' + capitalAB;

            // Color results
            document.getElementById('resultA').style.color = capitalA >= 0 ? '#4ade80' : '#ff6b6b';
            document.getElementById('resultB').style.color = capitalB >= 0 ? '#4ade80' : '#ff6b6b';
            document.getElementById('resultAB').style.color = capitalAB >= 0 ? '#4ade80' : '#ff6b6b';

            // Update stats
            document.getElementById('totalGames').textContent = gamesPlayed;
            document.getElementById('winRateA').textContent = gamesPlayed > 0 ? (winsA / gamesPlayed * 100).toFixed(1) + '%' : '0%';
            document.getElementById('winRateB').textContent = gamesPlayed > 0 ? (winsB / gamesPlayed * 100).toFixed(1) + '%' : '0%';
            document.getElementById('winRateAB').textContent = gamesPlayed > 0 ? (winsAB / gamesPlayed * 100).toFixed(1) + '%' : '0%';

            // Update recent flips
            const flipsDiv = document.getElementById('recentFlips');
            flipsDiv.innerHTML = recentFlips.map(f =>
                `<span class="coin-flip ${f.win ? 'win' : 'lose'}">${f.type}</span>`
            ).join('');
        }

        function reset() {
            capitalA = capitalB = capitalAB = 0;
            historyA = [0]; historyB = [0]; historyAB = [0];
            winsA = winsB = winsAB = 0;
            gamesPlayed = 0;
            abTurn = 0;
            recentFlips = [];
            updateDisplay();
        }

        function gameLoop() {
            if (running) {
                const stepsPerFrame = Math.ceil(speed / 10);
                for (let i = 0; i < stepsPerFrame; i++) {
                    step();
                }
                updateDisplay();
            }
            requestAnimationFrame(gameLoop);
        }

        // Expose for enhance.js keyboard shortcuts
        window.reset = reset;

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', function() {
            running = !running;
            this.textContent = running ? '‚è∏ Pause' : '‚ñ∂ Start';
            this.classList.toggle('active', running);
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        document.getElementById('speedSlider').addEventListener('input', function() {
            speed = parseInt(this.value);
        });

        window.addEventListener('resize', resizeCanvases);

        // Initialize
        resizeCanvases();
        gameLoop();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
