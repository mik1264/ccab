<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Friendship Paradox - Your Friends Are More Popular | Surprising Paradoxes #635</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #1a1a2e 100%);
            min-height: 100vh;
            color: #e2e8f0;
            overflow-x: hidden;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #f472b6;
            text-decoration: none;
            font-size: 0.9rem;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 8px 16px;
            background: rgba(244, 114, 182, 0.1);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(244, 114, 182, 0.3);
            transition: all 0.3s ease;
        }
        .back-link:hover {
            background: rgba(244, 114, 182, 0.2);
            transform: translateX(-3px);
        }
        header {
            text-align: center;
            padding: 60px 20px 20px;
        }
        h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, #f472b6, #ec4899, #db2777);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }
        .subtitle {
            color: #94a3b8;
            font-size: 1.1rem;
            max-width: 700px;
            margin: 0 auto;
        }
        .paradox-statement {
            background: linear-gradient(135deg, rgba(244, 114, 182, 0.2), rgba(236, 72, 153, 0.2));
            border: 1px solid rgba(244, 114, 182, 0.4);
            border-radius: 15px;
            padding: 20px;
            max-width: 850px;
            margin: 20px auto;
            text-align: center;
        }
        .paradox-statement h2 {
            color: #f472b6;
            font-size: 1.3rem;
            margin-bottom: 10px;
        }
        .main-container {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        @media (max-width: 1100px) {
            .main-container { grid-template-columns: 1fr; }
        }
        .network-area {
            background: rgba(15, 23, 42, 0.8);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(244, 114, 182, 0.2);
        }
        canvas {
            width: 100%;
            border-radius: 10px;
            background: #0f172a;
            cursor: pointer;
        }
        .network-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            color: #94a3b8;
        }
        .legend-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
        }
        .controls {
            background: rgba(15, 23, 42, 0.8);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(244, 114, 182, 0.2);
        }
        .big-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        .comparison-box {
            background: rgba(30, 41, 59, 0.6);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }
        .comparison-box .label {
            font-size: 0.75rem;
            color: #94a3b8;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .comparison-box .value {
            font-size: 2rem;
            font-weight: bold;
        }
        .comparison-box.you .value { color: #60a5fa; }
        .comparison-box.friends .value { color: #f472b6; }
        .paradox-indicator {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 38, 0.2));
            border: 2px solid rgba(239, 68, 68, 0.4);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            margin-bottom: 20px;
        }
        .paradox-indicator h4 {
            color: #f87171;
            font-size: 1rem;
            margin-bottom: 5px;
        }
        .paradox-indicator .percent {
            font-size: 1.5rem;
            font-weight: bold;
            color: #fca5a5;
        }
        .selected-node-info {
            background: rgba(30, 41, 59, 0.6);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            display: none;
        }
        .selected-node-info.active { display: block; }
        .selected-node-info h4 {
            color: #f472b6;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }
        .node-stat {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .node-stat:last-child { border-bottom: none; }
        .node-stat .label { color: #94a3b8; font-size: 0.85rem; }
        .node-stat .value { color: #e2e8f0; font-weight: bold; }
        .node-stat .value.less { color: #4ade80; }
        .node-stat .value.more { color: #f87171; }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            color: #f472b6;
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }
        .network-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .net-btn {
            padding: 10px;
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid rgba(244, 114, 182, 0.2);
            border-radius: 8px;
            color: #e2e8f0;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .net-btn:hover {
            background: rgba(244, 114, 182, 0.2);
            border-color: #f472b6;
        }
        .net-btn.active {
            background: rgba(244, 114, 182, 0.3);
            border-color: #f472b6;
            color: #f472b6;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #1e3a5f;
            outline: none;
            -webkit-appearance: none;
            margin-top: 10px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #f472b6, #ec4899);
            cursor: pointer;
        }
        .slider-value {
            text-align: center;
            color: #f472b6;
            font-weight: bold;
            margin-top: 5px;
        }
        .insight-box {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.2));
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 15px;
        }
        .insight-box h4 {
            color: #60a5fa;
            font-size: 0.9rem;
            margin-bottom: 8px;
        }
        .insight-box p {
            color: #94a3b8;
            font-size: 0.85rem;
            line-height: 1.5;
        }
        .info-section {
            max-width: 1400px;
            margin: 40px auto;
            padding: 0 20px;
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
        }
        .info-card {
            background: rgba(15, 23, 42, 0.8);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(244, 114, 182, 0.2);
        }
        .info-card h3 {
            color: #f472b6;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        .info-card p {
            color: #94a3b8;
            line-height: 1.7;
            font-size: 0.95rem;
        }
        .formula {
            background: rgba(30, 58, 138, 0.4);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            color: #f472b6;
            text-align: center;
            font-size: 0.9rem;
        }
        .facebook-stat {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
            padding: 15px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 10px;
        }
        .fb-item {
            text-align: center;
        }
        .fb-item .value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #60a5fa;
        }
        .fb-item .label {
            font-size: 0.75rem;
            color: #94a3b8;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <header>
        <h1>üë• The Friendship Paradox</h1>
        <p class="subtitle">Why your friends are more popular than you</p>

        <div class="paradox-statement">
            <h2>THE PARADOX</h2>
            <p>On average, your friends have <strong>MORE friends</strong> than you do. This isn't bad luck‚Äîit's <strong>mathematically guaranteed</strong> for most people in any social network! Click on any person in the network to see.</p>
        </div>
    </header>

    <div class="main-container">
        <div class="network-area">
            <canvas id="networkCanvas" width="800" height="550"></canvas>
            <div class="network-legend">
                <div class="legend-item">
                    <div class="legend-dot" style="background: #60a5fa;"></div>
                    <span>Few friends</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: #a78bfa;"></div>
                    <span>Average</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: #f472b6;"></div>
                    <span>Many friends (popular)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: #fbbf24; border: 3px solid white;"></div>
                    <span>Selected</span>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="big-comparison">
                <div class="comparison-box you">
                    <div class="label">Avg Friends</div>
                    <div class="value" id="avgFriends">-</div>
                </div>
                <div class="comparison-box friends">
                    <div class="label">Avg Friends-of-Friends</div>
                    <div class="value" id="avgFoF">-</div>
                </div>
            </div>

            <div class="paradox-indicator">
                <h4>üéØ Paradox Strength</h4>
                <div class="percent" id="paradoxStrength">-</div>
                <div style="font-size: 0.8rem; color: #94a3b8; margin-top: 5px;" id="paradoxExplain"></div>
            </div>

            <div class="selected-node-info" id="selectedInfo">
                <h4>üë§ Selected Person</h4>
                <div class="node-stat">
                    <span class="label">Their friends</span>
                    <span class="value" id="nodeFriends">-</span>
                </div>
                <div class="node-stat">
                    <span class="label">Friends' avg friends</span>
                    <span class="value" id="nodeFoF">-</span>
                </div>
                <div class="node-stat">
                    <span class="label">Paradox applies?</span>
                    <span class="value" id="nodeParadox">-</span>
                </div>
            </div>

            <div class="control-group">
                <label>üåê Network Type</label>
                <div class="network-buttons">
                    <button class="net-btn active" onclick="generateNetwork('barabasi')">Scale-Free</button>
                    <button class="net-btn" onclick="generateNetwork('random')">Random</button>
                    <button class="net-btn" onclick="generateNetwork('smallworld')">Small World</button>
                    <button class="net-btn" onclick="generateNetwork('star')">Star Hub</button>
                </div>
            </div>

            <div class="control-group">
                <label>üë• Number of People: <span id="nodeCountDisplay">50</span></label>
                <input type="range" id="nodeCount" min="20" max="100" value="50" onchange="updateNodeCount()">
            </div>

            <div class="insight-box">
                <h4>üí° Why Does This Happen?</h4>
                <p>Popular people appear in <strong>many</strong> friend lists, so they're over-represented when averaging "friends of friends." You're more likely to be friends with someone popular than with a hermit!</p>
            </div>
        </div>
    </div>

    <div class="info-section">
        <div class="info-grid">
            <div class="info-card">
                <h3>üìä Facebook Data (721 Million Users)</h3>
                <p>A massive study of the Facebook social graph revealed:</p>
                <div class="facebook-stat">
                    <div class="fb-item">
                        <div class="value">190</div>
                        <div class="label">Avg friends per user</div>
                    </div>
                    <div class="fb-item">
                        <div class="value">635</div>
                        <div class="label">Avg friends of friends</div>
                    </div>
                </div>
                <p>That's a <strong>234% increase</strong>! On Twitter, the paradox holds for <strong>98% of users</strong>.</p>
            </div>

            <div class="info-card">
                <h3>üßÆ The Mathematics</h3>
                <p>Let Œº = average degree (friends) and œÉ¬≤ = variance in degrees. Then:</p>
                <div class="formula">
                    Avg friends-of-friends = Œº + œÉ¬≤/Œº
                </div>
                <p>Since œÉ¬≤ > 0 (unless everyone has exactly the same number of friends), friends-of-friends always exceeds friends!</p>
                <p style="margin-top: 10px;">The more unequal the network, the stronger the paradox.</p>
            </div>

            <div class="info-card">
                <h3>üî¨ Sampling Bias Explanation</h3>
                <p>Imagine randomly picking a friendship edge. The people at each end are:</p>
                <ul style="padding-left: 20px; color: #94a3b8; margin-top: 10px;">
                    <li>More likely to be popular (they have more edges!)</li>
                    <li>Less likely to be unpopular hermits</li>
                </ul>
                <p style="margin-top: 10px;">So when you sample "friends," you're biased toward high-degree nodes. It's not that your friends are special‚Äîit's that popular people appear in everyone's friend lists!</p>
            </div>

            <div class="info-card">
                <h3>ü¶† Epidemic Detection</h3>
                <p>Christakis & Fowler (2010) used this paradox to detect flu outbreaks <strong>2 weeks earlier</strong> than traditional surveillance!</p>
                <p style="margin-top: 10px;"><strong>The trick:</strong> Instead of monitoring random people, monitor their friends. Friends are statistically more connected, so infections reach them sooner.</p>
                <p style="margin-top: 10px;">This "friendship sensor" method requires no knowledge of network structure‚Äîjust ask people to name friends!</p>
            </div>

            <div class="info-card">
                <h3>üòî Psychological Impact</h3>
                <p>The paradox contributes to social media anxiety:</p>
                <ul style="padding-left: 20px; color: #94a3b8; margin-top: 10px;">
                    <li>Your friends seem more popular than you</li>
                    <li>They appear to have more fun</li>
                    <li>Their posts get more engagement</li>
                </ul>
                <p style="margin-top: 10px;">But this is <strong>mathematically inevitable</strong>, not a reflection of your worth! Most people experience this "grass is greener" effect.</p>
            </div>

            <div class="info-card">
                <h3>üìú History</h3>
                <p><strong>1991:</strong> Sociologist Scott L. Feld publishes "Why Your Friends Have More Friends Than You Do" in the American Journal of Sociology</p>
                <p style="margin-top: 10px;"><strong>2010:</strong> Christakis & Fowler apply it to epidemic detection</p>
                <p style="margin-top: 10px;"><strong>2012:</strong> Facebook study of 721 million users confirms the effect at massive scale</p>
                <p style="margin-top: 10px;">The paradox also applies to: sexual partners, Twitter followers, co-authors, and more!</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('networkCanvas');
        const ctx = canvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let selectedNode = null;
        let nodeCount = 50;

        // Generate different network types
        function generateNetwork(type) {
            // Update buttons
            document.querySelectorAll('.net-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            nodes = [];
            edges = [];
            selectedNode = null;

            const n = nodeCount;

            // Create nodes with random positions
            for (let i = 0; i < n; i++) {
                nodes.push({
                    id: i,
                    x: 100 + Math.random() * 600,
                    y: 50 + Math.random() * 450,
                    vx: 0,
                    vy: 0,
                    degree: 0
                });
            }

            if (type === 'barabasi') {
                // Barab√°si-Albert preferential attachment (scale-free)
                // Start with a small connected core
                for (let i = 0; i < 3; i++) {
                    for (let j = i + 1; j < 3; j++) {
                        edges.push([i, j]);
                        nodes[i].degree++;
                        nodes[j].degree++;
                    }
                }

                // Add nodes with preferential attachment
                for (let i = 3; i < n; i++) {
                    const m = 2; // edges per new node
                    const targets = new Set();

                    while (targets.size < m) {
                        // Probability proportional to degree
                        const totalDegree = nodes.slice(0, i).reduce((sum, n) => sum + n.degree + 1, 0);
                        let r = Math.random() * totalDegree;
                        let cumulative = 0;

                        for (let j = 0; j < i; j++) {
                            cumulative += nodes[j].degree + 1;
                            if (r < cumulative && !targets.has(j)) {
                                targets.add(j);
                                break;
                            }
                        }
                    }

                    targets.forEach(j => {
                        edges.push([i, j]);
                        nodes[i].degree++;
                        nodes[j].degree++;
                    });
                }
            } else if (type === 'random') {
                // Erd≈ës-R√©nyi random graph
                const p = 4 / n; // Average degree ~4
                for (let i = 0; i < n; i++) {
                    for (let j = i + 1; j < n; j++) {
                        if (Math.random() < p) {
                            edges.push([i, j]);
                            nodes[i].degree++;
                            nodes[j].degree++;
                        }
                    }
                }
            } else if (type === 'smallworld') {
                // Watts-Strogatz small world
                const k = 4; // Each node connected to k nearest neighbors
                const beta = 0.3; // Rewiring probability

                // Ring lattice
                for (let i = 0; i < n; i++) {
                    for (let j = 1; j <= k / 2; j++) {
                        const neighbor = (i + j) % n;
                        edges.push([i, neighbor]);
                        nodes[i].degree++;
                        nodes[neighbor].degree++;
                    }
                }

                // Rewire with probability beta
                for (let e = 0; e < edges.length; e++) {
                    if (Math.random() < beta) {
                        const [i, j] = edges[e];
                        // Find new target
                        let newJ = Math.floor(Math.random() * n);
                        while (newJ === i || edges.some(([a, b]) => (a === i && b === newJ) || (a === newJ && b === i))) {
                            newJ = Math.floor(Math.random() * n);
                        }
                        nodes[j].degree--;
                        nodes[newJ].degree++;
                        edges[e] = [i, newJ];
                    }
                }
            } else if (type === 'star') {
                // Star network with a few hubs
                const hubs = 3;
                for (let h = 0; h < hubs; h++) {
                    for (let i = hubs; i < n; i++) {
                        if (Math.random() < 0.4) {
                            edges.push([h, i]);
                            nodes[h].degree++;
                            nodes[i].degree++;
                        }
                    }
                }
                // Some random edges among non-hubs
                for (let i = hubs; i < n; i++) {
                    for (let j = i + 1; j < n; j++) {
                        if (Math.random() < 0.05) {
                            edges.push([i, j]);
                            nodes[i].degree++;
                            nodes[j].degree++;
                        }
                    }
                }
            }

            // Run force simulation
            simulateForces();
            calculateStats();
            draw();
        }

        // Simple force-directed layout
        function simulateForces() {
            for (let iter = 0; iter < 100; iter++) {
                // Repulsion between all nodes
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const dx = nodes[j].x - nodes[i].x;
                        const dy = nodes[j].y - nodes[i].y;
                        const dist = Math.sqrt(dx * dx + dy * dy) + 1;
                        const force = 1000 / (dist * dist);

                        nodes[i].vx -= (dx / dist) * force;
                        nodes[i].vy -= (dy / dist) * force;
                        nodes[j].vx += (dx / dist) * force;
                        nodes[j].vy += (dy / dist) * force;
                    }
                }

                // Attraction along edges
                for (const [i, j] of edges) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const force = (dist - 80) * 0.01;

                    nodes[i].vx += (dx / dist) * force;
                    nodes[i].vy += (dy / dist) * force;
                    nodes[j].vx -= (dx / dist) * force;
                    nodes[j].vy -= (dy / dist) * force;
                }

                // Center gravity
                for (const node of nodes) {
                    node.vx += (400 - node.x) * 0.001;
                    node.vy += (275 - node.y) * 0.001;
                }

                // Apply velocities
                for (const node of nodes) {
                    node.x += node.vx * 0.5;
                    node.y += node.vy * 0.5;
                    node.vx *= 0.9;
                    node.vy *= 0.9;

                    // Bounds
                    node.x = Math.max(30, Math.min(770, node.x));
                    node.y = Math.max(30, Math.min(520, node.y));
                }
            }
        }

        // Calculate network statistics
        function calculateStats() {
            const n = nodes.length;
            if (n === 0) return;

            // Average degree
            const avgDegree = nodes.reduce((sum, node) => sum + node.degree, 0) / n;

            // Average friends-of-friends
            let totalFoF = 0;
            let countFoF = 0;

            for (const node of nodes) {
                if (node.degree === 0) continue;

                // Find friends
                const friends = [];
                for (const [i, j] of edges) {
                    if (i === node.id) friends.push(j);
                    if (j === node.id) friends.push(i);
                }

                // Average degree of friends
                const friendsDegreeSum = friends.reduce((sum, fid) => sum + nodes[fid].degree, 0);
                totalFoF += friendsDegreeSum;
                countFoF += friends.length;
            }

            const avgFoF = countFoF > 0 ? totalFoF / countFoF : 0;

            // Update display
            document.getElementById('avgFriends').textContent = avgDegree.toFixed(1);
            document.getElementById('avgFoF').textContent = avgFoF.toFixed(1);

            const paradoxPercent = avgDegree > 0 ? ((avgFoF - avgDegree) / avgDegree * 100).toFixed(0) : 0;
            document.getElementById('paradoxStrength').textContent = `+${paradoxPercent}%`;
            document.getElementById('paradoxExplain').textContent =
                `Friends have ${paradoxPercent}% more friends than average`;

            // Count how many experience the paradox
            let paradoxCount = 0;
            for (const node of nodes) {
                if (node.degree === 0) continue;

                const friends = [];
                for (const [i, j] of edges) {
                    if (i === node.id) friends.push(j);
                    if (j === node.id) friends.push(i);
                }

                const friendsAvgDegree = friends.reduce((sum, fid) => sum + nodes[fid].degree, 0) / friends.length;
                if (friendsAvgDegree > node.degree) paradoxCount++;
            }
        }

        // Draw network
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw edges
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.2)';
            ctx.lineWidth = 1;
            for (const [i, j] of edges) {
                ctx.beginPath();
                ctx.moveTo(nodes[i].x, nodes[i].y);
                ctx.lineTo(nodes[j].x, nodes[j].y);
                ctx.stroke();
            }

            // Highlight selected node's edges
            if (selectedNode !== null) {
                ctx.strokeStyle = 'rgba(251, 191, 36, 0.5)';
                ctx.lineWidth = 2;
                for (const [i, j] of edges) {
                    if (i === selectedNode || j === selectedNode) {
                        ctx.beginPath();
                        ctx.moveTo(nodes[i].x, nodes[i].y);
                        ctx.lineTo(nodes[j].x, nodes[j].y);
                        ctx.stroke();
                    }
                }
            }

            // Find max degree for color scaling
            const maxDegree = Math.max(...nodes.map(n => n.degree), 1);

            // Draw nodes
            for (const node of nodes) {
                const isSelected = node.id === selectedNode;
                const isFriend = selectedNode !== null && edges.some(([i, j]) =>
                    (i === selectedNode && j === node.id) || (j === selectedNode && i === node.id));

                // Size based on degree
                const size = 6 + (node.degree / maxDegree) * 12;

                // Color based on degree
                const t = node.degree / maxDegree;
                let color;
                if (t < 0.33) {
                    color = '#60a5fa'; // Blue - few friends
                } else if (t < 0.66) {
                    color = '#a78bfa'; // Purple - average
                } else {
                    color = '#f472b6'; // Pink - popular
                }

                if (isSelected) {
                    color = '#fbbf24';
                } else if (isFriend) {
                    color = '#22c55e';
                }

                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();

                if (isSelected) {
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }

            // Draw degree labels for larger nodes
            ctx.fillStyle = 'white';
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            for (const node of nodes) {
                if (node.degree >= maxDegree * 0.5) {
                    ctx.fillText(node.degree, node.x, node.y);
                }
            }
        }

        // Handle click
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            // Find clicked node
            let clicked = null;
            for (const node of nodes) {
                const dx = x - node.x;
                const dy = y - node.y;
                if (dx * dx + dy * dy < 400) {
                    clicked = node.id;
                    break;
                }
            }

            selectedNode = clicked;
            updateSelectedInfo();
            draw();
        });

        // Update selected node info
        function updateSelectedInfo() {
            const infoEl = document.getElementById('selectedInfo');

            if (selectedNode === null) {
                infoEl.classList.remove('active');
                return;
            }

            infoEl.classList.add('active');
            const node = nodes[selectedNode];

            // Find friends
            const friends = [];
            for (const [i, j] of edges) {
                if (i === selectedNode) friends.push(j);
                if (j === selectedNode) friends.push(i);
            }

            document.getElementById('nodeFriends').textContent = node.degree;

            if (friends.length > 0) {
                const friendsAvgDegree = friends.reduce((sum, fid) => sum + nodes[fid].degree, 0) / friends.length;
                document.getElementById('nodeFoF').textContent = friendsAvgDegree.toFixed(1);

                const paradoxEl = document.getElementById('nodeParadox');
                if (friendsAvgDegree > node.degree) {
                    paradoxEl.textContent = 'YES (' + ((friendsAvgDegree - node.degree) / node.degree * 100).toFixed(0) + '% more)';
                    paradoxEl.className = 'value more';
                } else {
                    paradoxEl.textContent = 'NO (more popular!)';
                    paradoxEl.className = 'value less';
                }
            } else {
                document.getElementById('nodeFoF').textContent = '-';
                document.getElementById('nodeParadox').textContent = 'No friends';
            }
        }

        // Update node count
        function updateNodeCount() {
            nodeCount = parseInt(document.getElementById('nodeCount').value);
            document.getElementById('nodeCountDisplay').textContent = nodeCount;
            // Re-generate current network type
            const activeBtn = document.querySelector('.net-btn.active');
            if (activeBtn) {
                activeBtn.click();
            }
        }

        // Initialize
        generateNetwork('barabasi');
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
