<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>No-Cloning Theorem - Quantum States Cannot Be Copied</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #0a1a1a 0%, #1a2a1a 50%, #0a1a0a 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 0;
            border-bottom: 1px solid rgba(100, 200, 150, 0.3);
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(135deg, #64c8a0, #a0c864);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2em;
            color: #888;
            font-style: italic;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        @media (max-width: 1000px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .visualization-section {
            background: rgba(20, 40, 30, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(100, 200, 150, 0.3);
        }

        canvas {
            width: 100%;
            border-radius: 10px;
            background: #050a08;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        button {
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            border: none;
            border-radius: 25px;
            background: linear-gradient(135deg, #64c8a0, #408060);
            color: white;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(100, 200, 150, 0.4);
        }

        button.active {
            background: linear-gradient(135deg, #c86464, #804040);
        }

        .state-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .state-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .state-label {
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }

        .state-value {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #64c8a0;
        }

        .result-box {
            grid-column: 1 / -1;
            padding: 20px;
        }

        .result-box.error {
            background: linear-gradient(135deg, rgba(200, 100, 100, 0.2), rgba(150, 50, 50, 0.3));
            border: 1px solid rgba(200, 100, 100, 0.5);
        }

        .result-box .state-value {
            color: #ff8866;
        }

        .essay-section {
            background: rgba(20, 40, 30, 0.6);
            border-radius: 15px;
            padding: 30px;
            border: 1px solid rgba(100, 200, 150, 0.2);
            max-height: 800px;
            overflow-y: auto;
        }

        .essay-section h2 {
            color: #64c8a0;
            margin: 25px 0 15px 0;
            font-size: 1.4em;
        }

        .essay-section h2:first-child {
            margin-top: 0;
        }

        .essay-section p {
            line-height: 1.8;
            margin-bottom: 15px;
            text-align: justify;
        }

        .equation {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
            font-size: 14px;
            overflow-x: auto;
        }

        .highlight {
            color: #a0c864;
            font-weight: bold;
        }

        .warning {
            color: #ff8866;
            font-weight: bold;
        }

        .diagram {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            white-space: pre;
            overflow-x: auto;
        }

        .sources {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(100, 200, 150, 0.3);
            font-size: 0.9em;
        }

        .sources h3 {
            color: #64c8a0;
            margin-bottom: 10px;
        }

        .sources ul {
            list-style: none;
            padding: 0;
        }

        .sources li {
            margin: 8px 0;
            padding-left: 15px;
            border-left: 2px solid #408060;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #64c8a0;
            text-decoration: none;
            font-size: 14px;
        }

        .back-link:hover {
            color: #a0c864;
        }

        .bloch-sphere-info {
            text-align: center;
            margin-top: 10px;
            font-size: 12px;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Paradoxes</a>

        <header>
            <h1>No-Cloning Theorem</h1>
            <p class="subtitle">It is impossible to create an exact copy of an arbitrary unknown quantum state</p>
        </header>

        <div class="main-content">
            <div class="visualization-section">
                <canvas id="canvas" width="600" height="400"></canvas>

                <div class="bloch-sphere-info">
                    Original state on Bloch sphere (left) → Attempted cloning (right)
                </div>

                <div class="controls">
                    <button id="btnRandomState">Random State</button>
                    <button id="btnAttemptClone" class="active">Attempt Clone</button>
                    <button id="btnReset">Reset</button>
                </div>

                <div class="state-display">
                    <div class="state-box">
                        <div class="state-label">Original State |ψ⟩</div>
                        <div class="state-value" id="originalState">α|0⟩ + β|1⟩</div>
                    </div>
                    <div class="state-box">
                        <div class="state-label">Clone Attempt</div>
                        <div class="state-value" id="cloneState">---</div>
                    </div>
                    <div class="state-box result-box error" id="resultBox">
                        <div class="state-label">Cloning Result</div>
                        <div class="state-value" id="resultText">Perfect cloning is impossible!</div>
                    </div>
                </div>
            </div>

            <div class="essay-section">
                <h2>The Impossibility of Quantum Photocopying</h2>
                <p>
                    In the classical world, copying is trivial. You can photocopy a document, duplicate a file,
                    or photograph an object without disturbing the original. But in quantum mechanics,
                    <span class="highlight">perfect copying is fundamentally impossible</span>.
                </p>

                <p>
                    The <span class="highlight">no-cloning theorem</span>, proved independently by Wootters, Zurek,
                    and Dieks in 1982, states that no physical process can create an exact copy of an
                    arbitrary unknown quantum state while leaving the original intact.
                </p>

                <h2>The Proof</h2>
                <p>
                    The proof is elegantly simple, relying only on the linearity of quantum mechanics:
                </p>

                <div class="diagram">
    Suppose a cloning machine U exists such that:

    U|ψ⟩|0⟩ = |ψ⟩|ψ⟩    (clones state ψ)
    U|φ⟩|0⟩ = |φ⟩|φ⟩    (clones state φ)

    Now consider a superposition |χ⟩ = α|ψ⟩ + β|φ⟩

    By linearity of U:
    U|χ⟩|0⟩ = αU|ψ⟩|0⟩ + βU|φ⟩|0⟩
            = α|ψ⟩|ψ⟩ + β|φ⟩|φ⟩

    But if U clones |χ⟩:
    U|χ⟩|0⟩ = |χ⟩|χ⟩ = (α|ψ⟩ + β|φ⟩)(α|ψ⟩ + β|φ⟩)
            = α²|ψ⟩|ψ⟩ + αβ|ψ⟩|φ⟩ + αβ|φ⟩|ψ⟩ + β²|φ⟩|φ⟩

    These are NOT equal! ✗ Contradiction.
                </div>

                <p>
                    The mismatch between the linear combination and the tensor product proves that
                    no unitary operation can clone arbitrary states.
                </p>

                <h2>Origin Story</h2>
                <p>
                    The theorem's discovery has a fascinating backstory. In 1982, physicist
                    <span class="highlight">Nick Herbert</span> proposed a device called FLASH that
                    claimed to use quantum entanglement for faster-than-light communication. The scheme
                    required cloning quantum states.
                </p>

                <p>
                    When Wootters, Zurek, and Dieks examined Herbert's proposal, they independently
                    realized that perfect cloning was impossible—and Herbert's FTL communicator was
                    doomed. As physicist Asher Peres later noted, <span class="highlight">"Nick Herbert's
                    erroneous paper was a spark that generated immense progress."</span>
                </p>

                <p>
                    The title "A single quantum cannot be cloned" was suggested by John Wheeler,
                    becoming one of physics' most cited papers.
                </p>

                <h2>Why It Matters</h2>
                <p>
                    <span class="highlight">Quantum Cryptography:</span> The no-cloning theorem is the
                    foundation of quantum key distribution (QKD). An eavesdropper cannot copy quantum
                    bits without disturbing them—guaranteeing detection of interception.
                </p>

                <div class="equation">
If Eve tries to clone Alice's qubit:
|ψ⟩ → |ψ⟩|ψ⟩ ✗ IMPOSSIBLE

Any measurement disturbs the state!
Alice and Bob detect the intrusion.
                </div>

                <p>
                    <span class="highlight">Quantum Computing:</span> We cannot make backup copies of
                    quantum computations mid-calculation. This makes quantum error correction
                    fundamentally different from classical—we must use entanglement instead.
                </p>

                <p>
                    <span class="highlight">No FTL Communication:</span> Without cloning, quantum
                    entanglement cannot be used to send information faster than light. You can't
                    measure a state, clone it, and compare—each measurement destroys the information.
                </p>

                <h2>What IS Allowed?</h2>
                <p>
                    The theorem doesn't prohibit everything:
                </p>

                <p>
                    <span class="highlight">Known states:</span> You CAN copy a state if you already
                    know what it is. Preparing |0⟩ twice is fine—you're not cloning, just preparing.
                </p>

                <p>
                    <span class="highlight">Approximate cloning:</span> Imperfect "cloning machines"
                    can create approximate copies with fidelity up to 5/6 for qubits. These are called
                    optimal universal quantum cloning machines.
                </p>

                <p>
                    <span class="highlight">Probabilistic cloning:</span> Sometimes succeed in perfect
                    cloning, but with success probability less than 1.
                </p>

                <h2>The No-Deleting Theorem</h2>
                <p>
                    In 2000, Pati and Braunstein proved the complementary <span class="highlight">
                    no-deleting theorem</span>: if you have two copies of an unknown quantum state,
                    you cannot delete one while leaving the other intact. Quantum information can
                    be moved but never created or destroyed from nothing.
                </p>

                <div class="equation">
No-cloning:   |ψ⟩|0⟩ → |ψ⟩|ψ⟩  ✗
No-deleting:  |ψ⟩|ψ⟩ → |ψ⟩|0⟩  ✗

Quantum information is conserved!
                </div>

                <h2>Deeper Implications</h2>
                <p>
                    The no-cloning theorem reveals something profound: quantum information is
                    <span class="highlight">fundamentally different</span> from classical information.
                    A quantum state carries information about possibilities that cannot be extracted
                    without disturbing those possibilities.
                </p>

                <p>
                    This connects to the measurement problem, the nature of observation, and why
                    quantum mechanics is so counterintuitive. The universe protects its secrets—
                    you can't learn about a quantum system without changing it.
                </p>

                <div class="sources">
                    <h3>Sources</h3>
                    <ul>
                        <li>Wootters, W.K. & Zurek, W.H. (1982). "A single quantum cannot be cloned" - Nature 299, 802</li>
                        <li>Dieks, D. (1982). "Communication by EPR devices" - Physics Letters A 92, 271</li>
                        <li>Pati, A.K. & Braunstein, S.L. (2000). "Impossibility of deleting an unknown quantum state" - Nature</li>
                        <li>Wikipedia: No-cloning theorem</li>
                        <li>Physics Today: "The no-cloning theorem" by Wootters (2009)</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // High DPI support
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        const width = rect.width;
        const height = rect.height;

        // State
        let originalState = { theta: Math.PI / 4, phi: Math.PI / 3 };
        let cloneAttempt = null;
        let phase = 'idle'; // idle, cloning, failed
        let phaseTime = 0;

        // Convert Bloch coordinates to Cartesian
        function blochToCartesian(theta, phi) {
            return {
                x: Math.sin(theta) * Math.cos(phi),
                y: Math.sin(theta) * Math.sin(phi),
                z: Math.cos(theta)
            };
        }

        // Project 3D to 2D
        function project(x, y, z, cx, cy, scale, rotation) {
            const cosR = Math.cos(rotation);
            const sinR = Math.sin(rotation);
            const rx = x * cosR - y * sinR;
            const ry = x * sinR + y * cosR;
            return {
                x: cx + rx * scale,
                y: cy - z * scale * 0.8 - ry * scale * 0.3
            };
        }

        // Draw Bloch sphere
        function drawBlochSphere(cx, cy, radius, state, label, isError) {
            const time = Date.now() * 0.001;
            const rotation = time * 0.5;

            // Draw sphere outline
            ctx.strokeStyle = isError ? 'rgba(200, 100, 100, 0.5)' : 'rgba(100, 200, 150, 0.3)';
            ctx.lineWidth = 1;

            // Equator
            ctx.beginPath();
            for (let phi = 0; phi <= Math.PI * 2; phi += 0.1) {
                const p = project(Math.cos(phi), Math.sin(phi), 0, cx, cy, radius, rotation);
                if (phi === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();

            // Meridian
            ctx.beginPath();
            for (let theta = 0; theta <= Math.PI * 2; theta += 0.1) {
                const p = project(Math.cos(theta), 0, Math.sin(theta), cx, cy, radius, rotation);
                if (theta === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();

            // Axes
            ctx.strokeStyle = 'rgba(150, 150, 150, 0.3)';
            const axes = [
                { from: [0, 0, 0], to: [1.3, 0, 0], label: 'x' },
                { from: [0, 0, 0], to: [0, 1.3, 0], label: 'y' },
                { from: [0, 0, 0], to: [0, 0, 1.3], label: '|0⟩' }
            ];

            axes.forEach(axis => {
                const p1 = project(axis.from[0], axis.from[1], axis.from[2], cx, cy, radius, rotation);
                const p2 = project(axis.to[0], axis.to[1], axis.to[2], cx, cy, radius, rotation);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            });

            // |1⟩ label at bottom
            const p1label = project(0, 0, -1.3, cx, cy, radius, rotation);
            ctx.fillStyle = '#888';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('|1⟩', p1label.x, p1label.y);

            // State vector
            if (state) {
                const coords = blochToCartesian(state.theta, state.phi);
                const p = project(coords.x, coords.y, coords.z, cx, cy, radius, rotation);
                const p0 = project(0, 0, 0, cx, cy, radius, rotation);

                // Vector line
                ctx.strokeStyle = isError ? '#c86464' : '#64c8a0';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(p0.x, p0.y);
                ctx.lineTo(p.x, p.y);
                ctx.stroke();

                // Point
                ctx.fillStyle = isError ? '#c86464' : '#64c8a0';
                ctx.beginPath();
                ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                ctx.fill();

                // If error, draw glitch effect
                if (isError && phase === 'failed') {
                    ctx.strokeStyle = 'rgba(200, 100, 100, 0.3)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 5; i++) {
                        const offset = (Math.random() - 0.5) * 20;
                        ctx.beginPath();
                        ctx.moveTo(p0.x + offset, p0.y);
                        ctx.lineTo(p.x + offset, p.y);
                        ctx.stroke();
                    }
                }
            }

            // Label
            ctx.fillStyle = isError ? '#c86464' : '#64c8a0';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label, cx, cy + radius + 30);
        }

        // Draw cloning machine
        function drawCloningMachine() {
            const mx = width / 2;
            const my = height / 2;

            // Machine body
            ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
            ctx.strokeStyle = phase === 'failed' ? '#c86464' : '#64c8a0';
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.moveTo(mx - 40, my - 40);
            ctx.lineTo(mx + 40, my - 40);
            ctx.lineTo(mx + 50, my);
            ctx.lineTo(mx + 40, my + 40);
            ctx.lineTo(mx - 40, my + 40);
            ctx.lineTo(mx - 50, my);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // X mark if failed
            if (phase === 'failed') {
                ctx.strokeStyle = '#ff6666';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(mx - 20, my - 20);
                ctx.lineTo(mx + 20, my + 20);
                ctx.moveTo(mx + 20, my - 20);
                ctx.lineTo(mx - 20, my + 20);
                ctx.stroke();
            } else {
                // Clone symbol
                ctx.fillStyle = '#888';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('U', mx, my + 5);
            }

            // Arrows
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;

            // Input arrow
            ctx.beginPath();
            ctx.moveTo(width * 0.25 + 70, my);
            ctx.lineTo(mx - 55, my);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(mx - 60, my - 5);
            ctx.lineTo(mx - 55, my);
            ctx.lineTo(mx - 60, my + 5);
            ctx.fill();

            // Output arrows
            ctx.beginPath();
            ctx.moveTo(mx + 55, my);
            ctx.lineTo(width * 0.75 - 70, my);
            ctx.stroke();
        }

        // Get state string
        function getStateString(state) {
            const theta = state.theta;
            const phi = state.phi;

            const alpha = Math.cos(theta / 2);
            const betaMag = Math.sin(theta / 2);
            const betaPhase = phi;

            const alphaStr = alpha.toFixed(2);
            const betaStr = `${betaMag.toFixed(2)}e^(i${(betaPhase / Math.PI).toFixed(2)}π)`;

            return `${alphaStr}|0⟩ + ${betaStr}|1⟩`;
        }

        // Main draw
        function draw(time) {
            ctx.fillStyle = '#050a08';
            ctx.fillRect(0, 0, width, height);

            // Title
            ctx.fillStyle = '#64c8a0';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Quantum Cloning Attempt', width/2, 25);

            // Original sphere (left)
            drawBlochSphere(width * 0.25, height * 0.5, 80, originalState, 'Original |ψ⟩', false);

            // Cloning machine
            drawCloningMachine();

            // Clone attempt (right)
            const isError = phase === 'failed' || phase === 'cloning';
            drawBlochSphere(width * 0.75, height * 0.5, 80, cloneAttempt, 'Clone Attempt', isError);

            // Error message
            if (phase === 'failed') {
                ctx.fillStyle = '#ff6666';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('IMPOSSIBLE: Linearity violated!', width/2, height - 20);
            }
        }

        // Update
        function update(deltaTime) {
            if (phase === 'cloning') {
                phaseTime += deltaTime;

                // Animate attempted clone with errors
                if (phaseTime < 1000) {
                    // Attempting...
                    cloneAttempt = {
                        theta: originalState.theta + Math.sin(phaseTime * 0.02) * 0.3,
                        phi: originalState.phi + Math.cos(phaseTime * 0.02) * 0.3
                    };
                } else {
                    // Failed
                    phase = 'failed';
                    cloneAttempt = {
                        theta: originalState.theta + (Math.random() - 0.5) * 0.5,
                        phi: originalState.phi + (Math.random() - 0.5) * 0.5
                    };
                    updateDisplay();
                }
            }
        }

        // Update display
        function updateDisplay() {
            document.getElementById('originalState').textContent = getStateString(originalState);

            if (cloneAttempt) {
                document.getElementById('cloneState').textContent = getStateString(cloneAttempt);
            } else {
                document.getElementById('cloneState').textContent = '---';
            }

            const resultBox = document.getElementById('resultBox');
            const resultText = document.getElementById('resultText');

            if (phase === 'failed') {
                resultBox.classList.add('error');
                resultText.textContent = 'FAILED: No unitary can clone arbitrary states!';
            } else if (phase === 'cloning') {
                resultBox.classList.add('error');
                resultText.textContent = 'Attempting to clone...';
            } else {
                resultBox.classList.remove('error');
                resultText.textContent = 'Perfect cloning is impossible!';
            }
        }

        // Animation loop
        let lastTime = 0;
        function animate(time) {
            const deltaTime = time - lastTime;
            lastTime = time;

            update(deltaTime);
            draw(time);

            requestAnimationFrame(animate);
        }

        // Random state
        function randomState() {
            originalState = {
                theta: Math.random() * Math.PI,
                phi: Math.random() * Math.PI * 2
            };
            cloneAttempt = null;
            phase = 'idle';
            updateDisplay();
        }

        // Attempt clone
        function attemptClone() {
            if (phase === 'idle' || phase === 'failed') {
                phase = 'cloning';
                phaseTime = 0;
                cloneAttempt = null;
                updateDisplay();
            }
        }

        // Reset
        function reset() {
            originalState = { theta: Math.PI / 4, phi: Math.PI / 3 };
            cloneAttempt = null;
            phase = 'idle';
            updateDisplay();
        }

        // Event handlers
        document.getElementById('btnRandomState').addEventListener('click', randomState);
        document.getElementById('btnAttemptClone').addEventListener('click', attemptClone);
        document.getElementById('btnReset').addEventListener('click', reset);

        // Initialize
        updateDisplay();
        animate(0);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
