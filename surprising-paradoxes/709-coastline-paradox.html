<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Coastline Paradox - Surprising Paradoxes</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #0a1628 0%, #1a2a4a 50%, #0d1f3c 100%);
            color: #e8f0ff;
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 {
            font-family: 'Lora', serif;
            font-size: 2.2em;
            text-align: center;
            margin-bottom: 10px;
            color: #6ecfff;
            text-shadow: 0 0 30px rgba(110, 207, 255, 0.3);
        }
        .subtitle {
            text-align: center;
            color: #8ab4d4;
            margin-bottom: 25px;
            font-size: 1.1em;
        }
        .back-link {
            display: inline-block;
            color: #6ecfff;
            text-decoration: none;
            margin-bottom: 20px;
            font-size: 0.95em;
        }
        .back-link:hover { text-decoration: underline; }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-section {
            background: rgba(20, 40, 70, 0.6);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(110, 207, 255, 0.2);
        }

        canvas {
            display: block;
            width: 100%;
            background: #0a1428;
            border-radius: 10px;
        }

        .controls-panel {
            background: rgba(20, 40, 70, 0.6);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(110, 207, 255, 0.2);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #6ecfff;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            background: #1a3050;
            appearance: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6ecfff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(110, 207, 255, 0.5);
        }

        .value-display {
            min-width: 60px;
            text-align: right;
            font-weight: 600;
            color: #ffcc66;
        }

        .stats-box {
            background: rgba(10, 30, 50, 0.7);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid rgba(110, 207, 255, 0.1);
        }

        .stat-row:last-child { border-bottom: none; }

        .stat-label { color: #8ab4d4; }
        .stat-value {
            font-weight: 600;
            color: #ffcc66;
            font-family: 'Courier New', monospace;
        }

        .buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #2d7dd2, #1a5fa8);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(45, 125, 210, 0.4);
        }

        .btn-secondary {
            background: rgba(110, 207, 255, 0.2);
            color: #6ecfff;
            border: 1px solid rgba(110, 207, 255, 0.3);
        }

        .btn-secondary:hover {
            background: rgba(110, 207, 255, 0.3);
        }

        .coastline-select {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            background: #1a3050;
            color: #e8f0ff;
            border: 1px solid rgba(110, 207, 255, 0.3);
            font-family: 'Nunito', sans-serif;
            cursor: pointer;
        }

        .explanation {
            background: rgba(20, 40, 70, 0.6);
            border-radius: 16px;
            padding: 25px;
            border: 1px solid rgba(110, 207, 255, 0.2);
            margin-bottom: 20px;
        }

        .explanation h2 {
            font-family: 'Lora', serif;
            color: #6ecfff;
            margin-bottom: 15px;
        }

        .explanation p {
            line-height: 1.7;
            margin-bottom: 12px;
            color: #c8d8e8;
        }

        .highlight {
            color: #ffcc66;
            font-weight: 600;
        }

        .formula {
            background: rgba(10, 30, 50, 0.7);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            color: #6ecfff;
            margin: 15px 0;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .comparison-item {
            background: rgba(10, 30, 50, 0.7);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .comparison-item h4 {
            color: #6ecfff;
            margin-bottom: 5px;
        }

        .dimension-value {
            font-size: 1.8em;
            font-weight: 600;
            color: #ffcc66;
        }

        .dimension-desc {
            font-size: 0.85em;
            color: #8ab4d4;
        }

        .history-note {
            background: linear-gradient(135deg, rgba(45, 125, 210, 0.2), rgba(30, 80, 150, 0.2));
            border-left: 4px solid #2d7dd2;
            padding: 15px;
            border-radius: 0 10px 10px 0;
            margin: 15px 0;
        }

        .history-note strong {
            color: #6ecfff;
        }

        .log-plot {
            background: rgba(20, 40, 70, 0.6);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(110, 207, 255, 0.2);
        }

        .log-plot h3 {
            font-family: 'Lora', serif;
            color: #6ecfff;
            margin-bottom: 15px;
            text-align: center;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Paradoxes</a>

        <h1>The Coastline Paradox</h1>
        <p class="subtitle">How long is the coast of Britain? It depends on your ruler.</p>

        <div class="main-content">
            <div class="canvas-section">
                <canvas id="coastCanvas" width="700" height="500"></canvas>
            </div>

            <div class="controls-panel">
                <div class="control-group">
                    <label>Coastline Type</label>
                    <select class="coastline-select" id="coastlineType">
                        <option value="britain">Britain-like (D ≈ 1.25)</option>
                        <option value="norway">Norway-like (D ≈ 1.52)</option>
                        <option value="smooth">Smooth Coast (D ≈ 1.05)</option>
                        <option value="fractal">Extreme Fractal (D ≈ 1.7)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Ruler Size</label>
                    <div class="slider-container">
                        <input type="range" id="rulerSize" min="5" max="100" value="50">
                        <span class="value-display" id="rulerValue">50 km</span>
                    </div>
                </div>

                <div class="stats-box">
                    <div class="stat-row">
                        <span class="stat-label">Ruler Size:</span>
                        <span class="stat-value" id="statRuler">50 km</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Segments Used:</span>
                        <span class="stat-value" id="statSegments">—</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Measured Length:</span>
                        <span class="stat-value" id="statLength">—</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Fractal Dimension:</span>
                        <span class="stat-value" id="statDimension">—</span>
                    </div>
                </div>

                <div class="buttons">
                    <button class="btn-primary" id="measureBtn">Measure Coastline</button>
                    <button class="btn-secondary" id="animateBtn">Animate All Sizes</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>
            </div>
        </div>

        <div class="log-plot">
            <h3>Log-Log Plot: Ruler Size vs Measured Length</h3>
            <canvas id="plotCanvas" width="1100" height="250"></canvas>
            <p style="text-align: center; color: #8ab4d4; margin-top: 10px; font-size: 0.9em;">
                The slope of this line equals <span class="highlight">1 - D</span>, where D is the fractal dimension
            </p>
        </div>

        <div class="explanation">
            <h2>The Paradox</h2>
            <p>
                How long is the coast of Britain? The answer seems simple—just measure it! But here's the paradox:
                <span class="highlight">the measured length depends entirely on the size of your measuring stick</span>.
            </p>
            <p>
                Use a 200 km ruler, and Britain's coast is about <span class="highlight">2,400 km</span>.
                Use a 50 km ruler, and it grows to <span class="highlight">3,400 km</span>.
                A 1 km ruler gives <span class="highlight">over 17,000 km</span>!
                As your ruler shrinks toward zero, the measured length approaches <span class="highlight">infinity</span>.
            </p>

            <div class="history-note">
                <strong>Historical Origin:</strong> In 1951, Lewis Fry Richardson noticed that Portugal measured
                its border with Spain as 987 km, while Spain measured it as 1,214 km—a 23% difference!
                Both were "correct" given their different measurement scales.
            </div>

            <p>
                In 1967, Benoit Mandelbrot published his landmark paper
                <em>"How Long Is the Coast of Britain?"</em> explaining this phenomenon using
                <span class="highlight">fractal geometry</span>. Coastlines aren't one-dimensional lines—they have
                a fractional dimension between 1 and 2.
            </p>

            <div class="formula">
                L(ε) = F · ε^(1-D)
                <br><small>Length = constant × ruler_size^(1 - fractal_dimension)</small>
            </div>

            <h2>Fractal Dimensions of Real Coastlines</h2>
            <div class="comparison-grid">
                <div class="comparison-item">
                    <h4>South Africa</h4>
                    <div class="dimension-value">1.02</div>
                    <div class="dimension-desc">Very smooth</div>
                </div>
                <div class="comparison-item">
                    <h4>Australia</h4>
                    <div class="dimension-value">1.13</div>
                    <div class="dimension-desc">Mostly smooth</div>
                </div>
                <div class="comparison-item">
                    <h4>Britain</h4>
                    <div class="dimension-value">1.25</div>
                    <div class="dimension-desc">Moderately jagged</div>
                </div>
                <div class="comparison-item">
                    <h4>Norway</h4>
                    <div class="dimension-value">1.52</div>
                    <div class="dimension-desc">Highly fjorded</div>
                </div>
            </div>

            <h2 style="margin-top: 25px;">Why It Matters</h2>
            <p>
                This isn't just mathematical curiosity. The coastline paradox reveals that
                <span class="highlight">scale matters fundamentally</span> in measurement.
                It affects geography, biology (blood vessels, lungs), and any system with self-similar structure.
                A fern leaf, a lightning bolt, a river network—all exhibit this same property.
            </p>
        </div>
    </div>

    <script>
        const coastCanvas = document.getElementById('coastCanvas');
        const coastCtx = coastCanvas.getContext('2d');
        const plotCanvas = document.getElementById('plotCanvas');
        const plotCtx = plotCanvas.getContext('2d');

        let coastlinePoints = [];
        let measurements = [];
        let currentCoastlineType = 'britain';
        let isAnimating = false;

        // Fractal coastline generation using midpoint displacement
        function generateCoastline(type) {
            const params = {
                britain: { roughness: 0.35, iterations: 8 },
                norway: { roughness: 0.55, iterations: 8 },
                smooth: { roughness: 0.12, iterations: 7 },
                fractal: { roughness: 0.7, iterations: 8 }
            };

            const { roughness, iterations } = params[type];

            // Start with basic shape
            let points = [
                { x: 100, y: 80 },
                { x: 180, y: 100 },
                { x: 220, y: 180 },
                { x: 200, y: 280 },
                { x: 250, y: 350 },
                { x: 200, y: 420 },
                { x: 120, y: 400 },
                { x: 80, y: 320 },
                { x: 100, y: 200 },
                { x: 100, y: 80 }
            ];

            // Scale to canvas
            const scale = Math.min(coastCanvas.width, coastCanvas.height) / 500;
            const offsetX = coastCanvas.width * 0.35;
            const offsetY = 20;

            points = points.map(p => ({
                x: p.x * scale + offsetX,
                y: p.y * scale + offsetY
            }));

            // Midpoint displacement
            for (let iter = 0; iter < iterations; iter++) {
                const newPoints = [];
                const displacement = roughness * Math.pow(0.5, iter * 0.6) * 50 * scale;

                for (let i = 0; i < points.length - 1; i++) {
                    newPoints.push(points[i]);

                    const midX = (points[i].x + points[i + 1].x) / 2;
                    const midY = (points[i].y + points[i + 1].y) / 2;

                    // Perpendicular displacement
                    const dx = points[i + 1].x - points[i].x;
                    const dy = points[i + 1].y - points[i].y;
                    const len = Math.sqrt(dx * dx + dy * dy);

                    if (len > 0) {
                        const perpX = -dy / len;
                        const perpY = dx / len;
                        const offset = (Math.random() - 0.5) * displacement;

                        newPoints.push({
                            x: midX + perpX * offset,
                            y: midY + perpY * offset
                        });
                    }
                }
                newPoints.push(points[points.length - 1]);
                points = newPoints;
            }

            return points;
        }

        function drawCoastline(points, rulerSize = null, segments = null) {
            coastCtx.clearRect(0, 0, coastCanvas.width, coastCanvas.height);

            // Draw water
            coastCtx.fillStyle = '#0a2040';
            coastCtx.fillRect(0, 0, coastCanvas.width, coastCanvas.height);

            // Draw land mass
            coastCtx.beginPath();
            coastCtx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                coastCtx.lineTo(points[i].x, points[i].y);
            }
            coastCtx.closePath();
            coastCtx.fillStyle = '#2a5030';
            coastCtx.fill();

            // Draw coastline
            coastCtx.beginPath();
            coastCtx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                coastCtx.lineTo(points[i].x, points[i].y);
            }
            coastCtx.strokeStyle = '#88ccaa';
            coastCtx.lineWidth = 2;
            coastCtx.stroke();

            // Draw measurement if provided
            if (segments && segments.length > 0) {
                coastCtx.beginPath();
                coastCtx.moveTo(segments[0].x, segments[0].y);
                for (let i = 1; i < segments.length; i++) {
                    coastCtx.lineTo(segments[i].x, segments[i].y);
                }
                coastCtx.strokeStyle = '#ffcc66';
                coastCtx.lineWidth = 3;
                coastCtx.stroke();

                // Draw measurement points
                segments.forEach((p, i) => {
                    coastCtx.beginPath();
                    coastCtx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    coastCtx.fillStyle = '#ff6666';
                    coastCtx.fill();
                });

                // Draw ruler indicator
                if (rulerSize) {
                    coastCtx.fillStyle = '#6ecfff';
                    coastCtx.font = '14px Nunito';
                    coastCtx.fillText(`Ruler: ${rulerSize} km`, 20, 30);
                }
            }

            // Scale indicator
            coastCtx.fillStyle = '#8ab4d4';
            coastCtx.font = '12px Nunito';
            coastCtx.fillText('Scale: ~1000 km', coastCanvas.width - 100, coastCanvas.height - 15);
        }

        function measureCoastline(points, rulerSize) {
            const scaleFactor = 5; // pixels per km (approximate)
            const rulerPixels = rulerSize * scaleFactor;

            const segments = [points[0]];
            let currentPoint = points[0];
            let pointIndex = 0;
            let totalLength = 0;

            while (pointIndex < points.length - 1) {
                // Find next point on coastline at ruler distance
                let found = false;

                for (let i = pointIndex; i < points.length - 1; i++) {
                    // Check segments of coastline
                    const segStart = points[i];
                    const segEnd = points[i + 1];

                    // Find intersection with circle of radius rulerPixels centered at currentPoint
                    const intersection = findCircleLineIntersection(
                        currentPoint, rulerPixels, segStart, segEnd
                    );

                    if (intersection && i >= pointIndex) {
                        segments.push(intersection);
                        totalLength += rulerSize;
                        currentPoint = intersection;
                        pointIndex = i;
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    // Connect to end
                    const dx = points[points.length - 1].x - currentPoint.x;
                    const dy = points[points.length - 1].y - currentPoint.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 5) {
                        segments.push(points[points.length - 1]);
                        totalLength += dist / scaleFactor;
                    }
                    break;
                }
            }

            return { segments, totalLength, count: segments.length - 1 };
        }

        function findCircleLineIntersection(center, radius, lineStart, lineEnd) {
            const dx = lineEnd.x - lineStart.x;
            const dy = lineEnd.y - lineStart.y;
            const fx = lineStart.x - center.x;
            const fy = lineStart.y - center.y;

            const a = dx * dx + dy * dy;
            const b = 2 * (fx * dx + fy * dy);
            const c = fx * fx + fy * fy - radius * radius;

            const discriminant = b * b - 4 * a * c;

            if (discriminant < 0) return null;

            const sqrtDisc = Math.sqrt(discriminant);
            const t1 = (-b - sqrtDisc) / (2 * a);
            const t2 = (-b + sqrtDisc) / (2 * a);

            // Take the larger t that's in range [0, 1]
            let t = t2;
            if (t2 < 0 || t2 > 1) t = t1;
            if (t < 0 || t > 1) return null;

            return {
                x: lineStart.x + t * dx,
                y: lineStart.y + t * dy
            };
        }

        function drawPlot() {
            plotCtx.clearRect(0, 0, plotCanvas.width, plotCanvas.height);

            const padding = { left: 80, right: 40, top: 30, bottom: 50 };
            const plotWidth = plotCanvas.width - padding.left - padding.right;
            const plotHeight = plotCanvas.height - padding.top - padding.bottom;

            // Background
            plotCtx.fillStyle = '#0a1428';
            plotCtx.fillRect(0, 0, plotCanvas.width, plotCanvas.height);

            // Grid
            plotCtx.strokeStyle = 'rgba(110, 207, 255, 0.1)';
            plotCtx.lineWidth = 1;

            for (let i = 0; i <= 5; i++) {
                const x = padding.left + (plotWidth / 5) * i;
                const y = padding.top + (plotHeight / 5) * i;

                plotCtx.beginPath();
                plotCtx.moveTo(x, padding.top);
                plotCtx.lineTo(x, padding.top + plotHeight);
                plotCtx.stroke();

                plotCtx.beginPath();
                plotCtx.moveTo(padding.left, y);
                plotCtx.lineTo(padding.left + plotWidth, y);
                plotCtx.stroke();
            }

            // Axes
            plotCtx.strokeStyle = '#6ecfff';
            plotCtx.lineWidth = 2;
            plotCtx.beginPath();
            plotCtx.moveTo(padding.left, padding.top);
            plotCtx.lineTo(padding.left, padding.top + plotHeight);
            plotCtx.lineTo(padding.left + plotWidth, padding.top + plotHeight);
            plotCtx.stroke();

            // Labels
            plotCtx.fillStyle = '#8ab4d4';
            plotCtx.font = '12px Nunito';
            plotCtx.textAlign = 'center';
            plotCtx.fillText('log(Ruler Size)', padding.left + plotWidth / 2, plotCanvas.height - 10);

            plotCtx.save();
            plotCtx.translate(20, padding.top + plotHeight / 2);
            plotCtx.rotate(-Math.PI / 2);
            plotCtx.fillText('log(Length)', 0, 0);
            plotCtx.restore();

            if (measurements.length < 2) return;

            // Calculate log values
            const logData = measurements.map(m => ({
                logRuler: Math.log10(m.rulerSize),
                logLength: Math.log10(m.length)
            }));

            const minLogRuler = Math.min(...logData.map(d => d.logRuler));
            const maxLogRuler = Math.max(...logData.map(d => d.logRuler));
            const minLogLength = Math.min(...logData.map(d => d.logLength));
            const maxLogLength = Math.max(...logData.map(d => d.logLength));

            const rangeRuler = maxLogRuler - minLogRuler || 1;
            const rangeLength = maxLogLength - minLogLength || 1;

            // Plot points
            plotCtx.fillStyle = '#ffcc66';
            logData.forEach(d => {
                const x = padding.left + ((d.logRuler - minLogRuler) / rangeRuler) * plotWidth;
                const y = padding.top + plotHeight - ((d.logLength - minLogLength) / rangeLength) * plotHeight;

                plotCtx.beginPath();
                plotCtx.arc(x, y, 6, 0, Math.PI * 2);
                plotCtx.fill();
            });

            // Linear regression for dimension estimation
            if (logData.length >= 2) {
                const n = logData.length;
                const sumX = logData.reduce((s, d) => s + d.logRuler, 0);
                const sumY = logData.reduce((s, d) => s + d.logLength, 0);
                const sumXY = logData.reduce((s, d) => s + d.logRuler * d.logLength, 0);
                const sumX2 = logData.reduce((s, d) => s + d.logRuler * d.logRuler, 0);

                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;

                // Draw regression line
                plotCtx.beginPath();
                const x1 = padding.left;
                const y1 = padding.top + plotHeight - ((slope * minLogRuler + intercept - minLogLength) / rangeLength) * plotHeight;
                const x2 = padding.left + plotWidth;
                const y2 = padding.top + plotHeight - ((slope * maxLogRuler + intercept - minLogLength) / rangeLength) * plotHeight;

                plotCtx.moveTo(x1, y1);
                plotCtx.lineTo(x2, y2);
                plotCtx.strokeStyle = '#ff6666';
                plotCtx.lineWidth = 2;
                plotCtx.setLineDash([5, 5]);
                plotCtx.stroke();
                plotCtx.setLineDash([]);

                // Fractal dimension = 1 - slope
                const dimension = 1 - slope;
                document.getElementById('statDimension').textContent = dimension.toFixed(3);
            }
        }

        function updateStats(rulerSize, segments, length) {
            document.getElementById('statRuler').textContent = `${rulerSize} km`;
            document.getElementById('statSegments').textContent = segments;
            document.getElementById('statLength').textContent = `${Math.round(length)} km`;
        }

        function doMeasurement() {
            const rulerSize = parseInt(document.getElementById('rulerSize').value);
            const result = measureCoastline(coastlinePoints, rulerSize);

            drawCoastline(coastlinePoints, rulerSize, result.segments);
            updateStats(rulerSize, result.count, result.totalLength);

            // Add to measurements if not already there
            const existing = measurements.find(m => m.rulerSize === rulerSize);
            if (!existing) {
                measurements.push({ rulerSize, length: result.totalLength });
                measurements.sort((a, b) => b.rulerSize - a.rulerSize);
            }

            drawPlot();
        }

        async function animateAllSizes() {
            if (isAnimating) return;
            isAnimating = true;

            measurements = [];
            const sizes = [100, 80, 60, 50, 40, 30, 25, 20, 15, 10, 8, 6, 5];

            for (const size of sizes) {
                if (!isAnimating) break;

                document.getElementById('rulerSize').value = size;
                document.getElementById('rulerValue').textContent = `${size} km`;

                const result = measureCoastline(coastlinePoints, size);
                drawCoastline(coastlinePoints, size, result.segments);
                updateStats(size, result.count, result.totalLength);

                measurements.push({ rulerSize: size, length: result.totalLength });
                drawPlot();

                await new Promise(r => setTimeout(r, 500));
            }

            isAnimating = false;
        }

        function init() {
            coastlinePoints = generateCoastline(currentCoastlineType);
            measurements = [];
            drawCoastline(coastlinePoints);
            drawPlot();
            document.getElementById('statSegments').textContent = '—';
            document.getElementById('statLength').textContent = '—';
            document.getElementById('statDimension').textContent = '—';
        }

        // Event listeners
        document.getElementById('rulerSize').addEventListener('input', (e) => {
            document.getElementById('rulerValue').textContent = `${e.target.value} km`;
        });

        document.getElementById('measureBtn').addEventListener('click', doMeasurement);

        document.getElementById('animateBtn').addEventListener('click', animateAllSizes);

        document.getElementById('resetBtn').addEventListener('click', () => {
            isAnimating = false;
            init();
        });

        document.getElementById('coastlineType').addEventListener('change', (e) => {
            currentCoastlineType = e.target.value;
            isAnimating = false;
            init();
        });

        // Initialize
        init();
    </script>
</body>
</html>
