<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frame Dragging & The Ergosphere - Surprising Paradoxes</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #0a0a12 0%, #1a1a2e 50%, #0f0f1a 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        .back-link {
            display: inline-block;
            color: #f4a261;
            text-decoration: none;
            margin-bottom: 20px;
            font-size: 0.95rem;
            transition: color 0.3s;
        }

        .back-link:hover { color: #e9c46a; }

        h1 {
            font-size: 2.5rem;
            color: #e9c46a;
            margin-bottom: 15px;
            text-shadow: 0 0 40px rgba(233, 196, 106, 0.3);
        }

        .subtitle {
            font-size: 1.2rem;
            color: #8ecae6;
            font-style: italic;
        }

        .visualization-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 40px;
            border: 1px solid rgba(233, 196, 106, 0.2);
        }

        .canvas-wrapper {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        canvas {
            border-radius: 10px;
            background: #000;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #e9c46a;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group .value {
            text-align: right;
            font-size: 0.8rem;
            color: #8ecae6;
        }

        .mode-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        .mode-btn {
            padding: 10px 20px;
            border: 1px solid rgba(233, 196, 106, 0.5);
            background: rgba(233, 196, 106, 0.1);
            color: #e9c46a;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
        }

        .mode-btn:hover {
            background: rgba(233, 196, 106, 0.2);
        }

        .mode-btn.active {
            background: rgba(233, 196, 106, 0.3);
            border-color: #e9c46a;
        }

        .essay {
            line-height: 1.9;
            font-size: 1.1rem;
        }

        .essay h2 {
            color: #e9c46a;
            margin: 40px 0 20px;
            font-size: 1.6rem;
            border-bottom: 1px solid rgba(233, 196, 106, 0.3);
            padding-bottom: 10px;
        }

        .essay h3 {
            color: #f4a261;
            margin: 30px 0 15px;
            font-size: 1.3rem;
        }

        .essay p {
            margin-bottom: 20px;
            text-align: justify;
        }

        .equation {
            background: rgba(142, 202, 230, 0.1);
            padding: 20px;
            margin: 25px 0;
            border-radius: 10px;
            text-align: center;
            font-family: 'Courier New', monospace;
            color: #8ecae6;
            font-size: 1.1rem;
            overflow-x: auto;
        }

        .highlight-box {
            background: linear-gradient(135deg, rgba(233, 196, 106, 0.1), rgba(244, 162, 97, 0.1));
            border-left: 4px solid #e9c46a;
            padding: 20px;
            margin: 25px 0;
            border-radius: 0 10px 10px 0;
        }

        .highlight-box strong {
            color: #e9c46a;
        }

        .sources {
            background: rgba(0, 0, 0, 0.3);
            padding: 25px;
            border-radius: 10px;
            margin-top: 40px;
        }

        .sources h3 {
            color: #e9c46a;
            margin-bottom: 15px;
        }

        .sources ul {
            list-style: none;
        }

        .sources li {
            margin-bottom: 10px;
        }

        .sources a {
            color: #8ecae6;
            text-decoration: none;
        }

        .sources a:hover {
            text-decoration: underline;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin-top: 15px;
            font-size: 0.85rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 10px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">← Back to Surprising Paradoxes</a>
            <h1>Frame Dragging & The Ergosphere</h1>
            <p class="subtitle">Where spacetime itself is forced to rotate</p>
        </header>

        <div class="visualization-container">
            <div class="mode-buttons">
                <button class="mode-btn active" onclick="setMode('structure')">Structure View</button>
                <button class="mode-btn" onclick="setMode('dragging')">Frame Dragging</button>
                <button class="mode-btn" onclick="setMode('penrose')">Penrose Process</button>
                <button class="mode-btn" onclick="setMode('gyroscope')">Gyroscope Precession</button>
            </div>

            <div class="canvas-wrapper">
                <canvas id="canvas" width="800" height="600"></canvas>
            </div>

            <div class="legend" id="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #1a1a1a; border: 1px solid #333;"></div>
                    <span>Singularity</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(90deg, #220000, #440000);"></div>
                    <span>Event Horizon</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(90deg, rgba(233,196,106,0.3), rgba(233,196,106,0.1));"></div>
                    <span>Ergosphere</span>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Spin Parameter (a/M)</label>
                    <input type="range" id="spinParam" min="0" max="0.998" step="0.001" value="0.9">
                    <div class="value"><span id="spinValue">0.90</span></div>
                </div>

                <div class="control-group">
                    <label>View Angle (degrees)</label>
                    <input type="range" id="viewAngle" min="0" max="90" step="1" value="45">
                    <div class="value"><span id="angleValue">45</span>°</div>
                </div>

                <div class="control-group">
                    <label>Animation Speed</label>
                    <input type="range" id="animSpeed" min="0.1" max="3" step="0.1" value="1">
                    <div class="value"><span id="speedValue">1.0</span>x</div>
                </div>
            </div>
        </div>

        <article class="essay">
            <h2>Spacetime That Drags You Along</h2>

            <p>
                Imagine standing still in space, perfectly motionless relative to distant stars. Near a rotating
                black hole, this becomes <strong>impossible</strong>. The very fabric of spacetime rotates, and
                you are dragged along with it whether you want to move or not. This is <em>frame dragging</em>—one
                of the strangest predictions of general relativity, and one that has now been experimentally confirmed.
            </p>

            <p>
                Roy Kerr discovered the mathematical solution describing rotating black holes in 1963, nearly
                50 years after Einstein's original field equations. The Kerr metric revealed something
                extraordinary: rotation of mass doesn't just create gravity—it twists spacetime itself.
            </p>

            <h2>The Ergosphere: Where Nothing Can Stand Still</h2>

            <p>
                Around every rotating black hole lies a region called the <strong>ergosphere</strong>—from the
                Greek "ergon" meaning work. This region exists between the event horizon (from which nothing
                can escape) and the "stationary limit" surface (beyond which objects can remain stationary
                relative to distant observers).
            </p>

            <div class="highlight-box">
                <strong>The Paradox:</strong> Inside the ergosphere, you can still escape the black hole
                (unlike crossing the event horizon), but you <em>cannot stand still</em>. The dragging of
                spacetime is so extreme that even light must rotate with the black hole. Every particle,
                every photon, is swept along.
            </div>

            <p>
                The shape of the ergosphere is oblate—flattened at the poles and bulging at the equator.
                At the poles, it touches the event horizon. At the equator, it extends farthest, to a
                radius of 2M (twice the black hole's mass in geometric units).
            </p>

            <div class="equation">
                Stationary Limit (equator): r<sub>s</sub> = 2M<br>
                Event Horizon: r<sub>+</sub> = M + √(M² - a²)<br>
                where a = J/Mc (spin parameter)
            </div>

            <h2>The Penrose Process: Mining a Black Hole</h2>

            <p>
                In 1969, Roger Penrose (who would later win the Nobel Prize) discovered something remarkable:
                the ergosphere allows you to <strong>extract energy from a rotating black hole</strong>.
                This seems to violate everything we know about black holes being cosmic vacuum cleaners.
            </p>

            <h3>How It Works</h3>

            <p>
                Send a particle into the ergosphere. Inside, have it split into two fragments. One fragment
                falls into the black hole with <em>negative energy</em> (possible only inside the ergosphere
                due to the twisted spacetime metric). The other fragment escapes with more energy than the
                original particle entered with!
            </p>

            <p>
                Where does this energy come from? The black hole's rotation. The infalling fragment carries
                negative angular momentum, slowing the black hole's spin. Energy is conserved—it's just
                transferred from the black hole's rotation to the escaping particle.
            </p>

            <div class="equation">
                Maximum energy gain per particle: ~20.7% of rest mass<br>
                Maximum total extractable energy: ~29% of black hole mass
            </div>

            <h2>Experimental Confirmation</h2>

            <p>
                For decades, frame dragging was purely theoretical. Then came Gravity Probe B—a NASA
                satellite mission launched in 2004 carrying the most perfect gyroscopes ever made.
                These gyroscopes were spheres of fused quartz, polished to within 40 atomic layers,
                coated with niobium, and cooled to near absolute zero.
            </p>

            <p>
                The result? Earth's rotation (though minuscule compared to a black hole) causes
                spacetime to twist by about 0.000011 degrees per year. Gravity Probe B measured this
                with 19% accuracy, confirming Einstein's century-old prediction.
            </p>

            <h3>Astrophysical Jets</h3>

            <p>
                The most dramatic manifestation of frame dragging may be the <strong>relativistic jets</strong>
                observed erupting from supermassive black holes. These jets extend millions of light-years,
                accelerating particles to 99.9% the speed of light. The energy source? Frame dragging
                and the Penrose process, extracting rotational energy from black holes that spin at
                nearly the maximum possible rate.
            </p>

            <h2>The Mathematics of Twisted Spacetime</h2>

            <p>
                In the Kerr metric, the key term is the "cross term" g<sub>tφ</sub> that mixes time (t)
                with the azimuthal angle (φ). This term is proportional to the black hole's spin
                parameter a = J/Mc. Without rotation (a = 0), this term vanishes, and we recover the
                non-rotating Schwarzschild black hole.
            </p>

            <div class="equation">
                ds² = -(1 - 2Mr/Σ)dt² - (4Mar sin²θ/Σ)dtdφ + (Σ/Δ)dr² + Σdθ² + (r² + a² + 2Ma²r sin²θ/Σ)sin²θ dφ²
            </div>

            <p>
                The dtdφ term is what causes frame dragging. It means that moving forward in time
                <em>automatically</em> involves rotation in φ—you cannot have one without the other
                near a rotating black hole.
            </p>

            <h2>Maximum Spin and Cosmic Censorship</h2>

            <p>
                What happens if a black hole spins too fast? The math predicts that if a/M > 1, the event
                horizon disappears, leaving a "naked singularity" visible to the universe. Penrose's
                <strong>cosmic censorship conjecture</strong> proposes that nature prevents this—real
                black holes always have a/M < 1.
            </p>

            <p>
                Observations support this: the fastest-spinning black holes measured have a/M ≈ 0.998,
                tantalizingly close to but never exceeding the limit. Something (perhaps Hawking
                radiation or other quantum effects) seems to prevent maximum spin.
            </p>

            <div class="highlight-box">
                <strong>The Deep Insight:</strong> Frame dragging reveals that rotation is not just
                motion through space—it warps the structure of spacetime itself. Near a Kerr black
                hole, the very meaning of "standing still" breaks down. You are forced to participate
                in the rotation whether you fire your rockets or not.
            </div>

            <div class="sources">
                <h3>Sources & Further Reading</h3>
                <ul>
                    <li><a href="https://en.wikipedia.org/wiki/Frame-dragging">Frame-dragging - Wikipedia</a></li>
                    <li><a href="https://en.wikipedia.org/wiki/Kerr_metric">Kerr metric - Wikipedia</a></li>
                    <li><a href="https://en.wikipedia.org/wiki/Penrose_process">Penrose process - Wikipedia</a></li>
                    <li><a href="https://www.eftaylor.com/pub/SpinNEW.pdf">The Spinning Black Hole - Taylor & Wheeler</a></li>
                    <li><a href="https://www.sciencealert.com/an-experiment-has-just-demonstrated-how-energy-could-be-extracted-from-a-black-hole">Experimental verification of Penrose process - ScienceAlert</a></li>
                    <li><a href="https://link.springer.com/article/10.1140/epjh/s13129-021-00022-9">Thermodynamics of black holes - European Physical Journal</a></li>
                </ul>
            </div>
        </article>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // High DPI support
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';

        const width = rect.width;
        const height = rect.height;
        const centerX = width / 2;
        const centerY = height / 2;

        // Parameters
        let spinParam = 0.9;
        let viewAngle = 45;
        let animSpeed = 1;
        let currentMode = 'structure';
        let time = 0;

        // Particles for different modes
        let particles = [];
        let penroseParticle = null;
        let gyroscope = { angle: 0, x: 0, y: 0, precession: 0 };

        // Control elements
        const spinSlider = document.getElementById('spinParam');
        const angleSlider = document.getElementById('viewAngle');
        const speedSlider = document.getElementById('animSpeed');

        spinSlider.addEventListener('input', (e) => {
            spinParam = parseFloat(e.target.value);
            document.getElementById('spinValue').textContent = spinParam.toFixed(2);
        });

        angleSlider.addEventListener('input', (e) => {
            viewAngle = parseFloat(e.target.value);
            document.getElementById('angleValue').textContent = viewAngle;
        });

        speedSlider.addEventListener('input', (e) => {
            animSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = animSpeed.toFixed(1);
        });

        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.toLowerCase().includes(mode.split(/(?=[A-Z])/).join(' ').toLowerCase()) ||
                    (mode === 'structure' && btn.textContent.includes('Structure')) ||
                    (mode === 'dragging' && btn.textContent.includes('Dragging')) ||
                    (mode === 'penrose' && btn.textContent.includes('Penrose')) ||
                    (mode === 'gyroscope' && btn.textContent.includes('Gyroscope'))) {
                    btn.classList.add('active');
                }
            });

            // Reset particles for new mode
            particles = [];
            penroseParticle = null;

            if (mode === 'dragging') {
                initDraggingParticles();
            } else if (mode === 'penrose') {
                initPenroseParticle();
            } else if (mode === 'gyroscope') {
                initGyroscope();
            }

            updateLegend();
        }

        function updateLegend() {
            const legend = document.getElementById('legend');
            if (currentMode === 'penrose') {
                legend.innerHTML = `
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4CAF50;"></div>
                        <span>Incoming Particle</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f44336;"></div>
                        <span>Negative Energy (falls in)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00ff88;"></div>
                        <span>Boosted Particle (escapes)</span>
                    </div>
                `;
            } else if (currentMode === 'gyroscope') {
                legend.innerHTML = `
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff6b6b;"></div>
                        <span>Gyroscope Spin Axis</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: rgba(255,107,107,0.3);"></div>
                        <span>Precession Path</span>
                    </div>
                `;
            } else {
                legend.innerHTML = `
                    <div class="legend-item">
                        <div class="legend-color" style="background: #1a1a1a; border: 1px solid #333;"></div>
                        <span>Singularity</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #220000, #440000);"></div>
                        <span>Event Horizon</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, rgba(233,196,106,0.3), rgba(233,196,106,0.1));"></div>
                        <span>Ergosphere</span>
                    </div>
                `;
            }
        }

        function initDraggingParticles() {
            particles = [];
            // Create particles at various radii
            for (let i = 0; i < 60; i++) {
                const r = 80 + Math.random() * 200;
                const theta = Math.random() * Math.PI * 2;
                particles.push({
                    r: r,
                    theta: theta,
                    baseR: r,
                    trail: []
                });
            }
        }

        function initPenroseParticle() {
            penroseParticle = {
                state: 'incoming',
                x: width - 100,
                y: centerY - 50,
                vx: -2,
                vy: 0.5,
                trail: [],
                fragments: null
            };
        }

        function initGyroscope() {
            gyroscope = {
                angle: 0,
                x: centerX + 150,
                y: centerY,
                precession: 0,
                spinAxis: Math.PI / 4
            };
        }

        // Calculate ergosphere and horizon sizes
        function getHorizonRadius(angle) {
            const M = 80; // Mass scale
            const a = spinParam * M;
            const rPlus = M + Math.sqrt(M * M - a * a);
            // Apply viewing angle compression
            const compression = Math.cos(viewAngle * Math.PI / 180);
            const theta = angle;
            // Horizon is slightly oblate for Kerr
            return rPlus * (1 - 0.1 * spinParam * Math.sin(theta) * Math.sin(theta) * compression);
        }

        function getErgosphereRadius(angle) {
            const M = 80;
            // Stationary limit surface
            const theta = angle;
            const rS = 2 * M; // At equator
            const compression = Math.cos(viewAngle * Math.PI / 180);
            // Ergosphere is oblate - larger at equator, touching horizon at poles
            const horizonR = getHorizonRadius(angle);
            const ergoDiff = (rS - horizonR) * Math.sin(theta) * Math.sin(theta);
            return horizonR + ergoDiff * (1 + 0.5 * compression);
        }

        function getFrameDragRate(r) {
            // Frame dragging angular velocity (simplified)
            const M = 80;
            const a = spinParam * M;
            if (r < M) return 0.1;
            const omega = (2 * M * a) / (r * r * r + a * a * r + 2 * M * a * a);
            return omega * 50; // Scale for visualization
        }

        function drawBlackHole() {
            const M = 80;

            // Draw ergosphere
            ctx.beginPath();
            for (let i = 0; i <= 360; i++) {
                const angle = i * Math.PI / 180;
                const r = getErgosphereRadius(angle);
                const x = centerX + r * Math.cos(angle);
                const y = centerY + r * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            const ergoGrad = ctx.createRadialGradient(centerX, centerY, 60, centerX, centerY, 180);
            ergoGrad.addColorStop(0, 'rgba(233, 196, 106, 0.4)');
            ergoGrad.addColorStop(0.5, 'rgba(233, 196, 106, 0.2)');
            ergoGrad.addColorStop(1, 'rgba(233, 196, 106, 0.05)');
            ctx.fillStyle = ergoGrad;
            ctx.fill();
            ctx.strokeStyle = 'rgba(233, 196, 106, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw event horizon
            ctx.beginPath();
            for (let i = 0; i <= 360; i++) {
                const angle = i * Math.PI / 180;
                const r = getHorizonRadius(angle);
                const x = centerX + r * Math.cos(angle);
                const y = centerY + r * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            const horizonGrad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 80);
            horizonGrad.addColorStop(0, '#000');
            horizonGrad.addColorStop(0.7, '#110000');
            horizonGrad.addColorStop(1, '#220000');
            ctx.fillStyle = horizonGrad;
            ctx.fill();
            ctx.strokeStyle = '#440000';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Ring singularity indicator
            if (spinParam > 0.1) {
                ctx.beginPath();
                const ringRadius = spinParam * 30;
                ctx.ellipse(centerX, centerY, ringRadius, ringRadius * Math.cos(viewAngle * Math.PI / 180), 0, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Rotation direction indicator
            ctx.beginPath();
            ctx.arc(centerX, centerY, 200, -0.3, 0.3);
            ctx.strokeStyle = 'rgba(142, 202, 230, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Arrow
            const arrowX = centerX + 200 * Math.cos(0.3);
            const arrowY = centerY + 200 * Math.sin(0.3);
            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - 15, arrowY - 8);
            ctx.lineTo(arrowX - 10, arrowY + 8);
            ctx.closePath();
            ctx.fillStyle = 'rgba(142, 202, 230, 0.7)';
            ctx.fill();

            // Label
            ctx.font = '14px Georgia';
            ctx.fillStyle = '#8ecae6';
            ctx.textAlign = 'center';
            ctx.fillText('Rotation', centerX + 220, centerY - 20);
        }

        function drawFrameDragging() {
            // Draw spiral field lines showing frame dragging
            ctx.strokeStyle = 'rgba(142, 202, 230, 0.3)';
            ctx.lineWidth = 1;

            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                const startAngle = (i / 8) * Math.PI * 2 + time * 0.5;

                for (let r = 100; r < 280; r += 2) {
                    const dragRate = getFrameDragRate(r);
                    const spiralAngle = startAngle + dragRate * (280 - r) * 0.02;
                    const x = centerX + r * Math.cos(spiralAngle);
                    const y = centerY + r * Math.sin(spiralAngle);

                    if (r === 100) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // Update and draw particles
            particles.forEach(p => {
                const dragRate = getFrameDragRate(p.r);
                p.theta += dragRate * 0.02 * animSpeed;

                // Add slight radial oscillation
                p.r = p.baseR + Math.sin(time * 2 + p.theta * 3) * 5;

                const x = centerX + p.r * Math.cos(p.theta);
                const y = centerY + p.r * Math.sin(p.theta);

                // Trail
                p.trail.push({ x, y });
                if (p.trail.length > 20) p.trail.shift();

                // Draw trail
                ctx.beginPath();
                p.trail.forEach((pt, idx) => {
                    if (idx === 0) ctx.moveTo(pt.x, pt.y);
                    else ctx.lineTo(pt.x, pt.y);
                });
                ctx.strokeStyle = `rgba(142, 202, 230, ${0.5 * (p.r - 80) / 200})`;
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw particle
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fillStyle = '#8ecae6';
                ctx.fill();
            });
        }

        function drawPenroseProcess() {
            if (!penroseParticle) return;

            const p = penroseParticle;
            const ergoRadius = getErgosphereRadius(Math.PI / 2);
            const horizonRadius = getHorizonRadius(Math.PI / 2);

            if (p.state === 'incoming') {
                // Move toward ergosphere
                p.x += p.vx * animSpeed;
                p.y += p.vy * animSpeed;

                // Add to trail
                p.trail.push({ x: p.x, y: p.y });
                if (p.trail.length > 100) p.trail.shift();

                const dist = Math.sqrt((p.x - centerX) ** 2 + (p.y - centerY) ** 2);

                // Check if entered ergosphere
                if (dist < ergoRadius - 20) {
                    p.state = 'splitting';
                    p.splitTime = 0;
                }

                // Draw trail
                ctx.beginPath();
                p.trail.forEach((pt, idx) => {
                    if (idx === 0) ctx.moveTo(pt.x, pt.y);
                    else ctx.lineTo(pt.x, pt.y);
                });
                ctx.strokeStyle = 'rgba(76, 175, 80, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw particle
                ctx.beginPath();
                ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#4CAF50';
                ctx.fill();
                ctx.strokeStyle = '#81C784';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label
                ctx.font = '12px Georgia';
                ctx.fillStyle = '#4CAF50';
                ctx.textAlign = 'center';
                ctx.fillText('E = E₀', p.x, p.y - 15);

            } else if (p.state === 'splitting') {
                p.splitTime += 0.02 * animSpeed;

                // Visual effect for splitting
                ctx.beginPath();
                ctx.arc(p.x, p.y, 10 + p.splitTime * 30, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 - p.splitTime * 0.4})`;
                ctx.lineWidth = 2;
                ctx.stroke();

                if (p.splitTime > 0.5) {
                    // Create fragments
                    p.state = 'fragments';
                    p.fragments = {
                        negative: {
                            x: p.x,
                            y: p.y,
                            vx: -1.5,
                            vy: 0.8,
                            trail: []
                        },
                        boosted: {
                            x: p.x,
                            y: p.y,
                            vx: 3,
                            vy: -1.2,
                            trail: []
                        }
                    };
                }

            } else if (p.state === 'fragments') {
                const neg = p.fragments.negative;
                const boost = p.fragments.boosted;

                // Negative energy fragment spirals in
                neg.x += neg.vx * animSpeed;
                neg.y += neg.vy * animSpeed;
                // Curve toward center
                const negDist = Math.sqrt((neg.x - centerX) ** 2 + (neg.y - centerY) ** 2);
                const negAngle = Math.atan2(neg.y - centerY, neg.x - centerX);
                neg.vx += -Math.cos(negAngle) * 0.1;
                neg.vy += -Math.sin(negAngle) * 0.1;

                neg.trail.push({ x: neg.x, y: neg.y });
                if (neg.trail.length > 50) neg.trail.shift();

                // Boosted fragment escapes
                boost.x += boost.vx * animSpeed;
                boost.y += boost.vy * animSpeed;

                boost.trail.push({ x: boost.x, y: boost.y });
                if (boost.trail.length > 50) boost.trail.shift();

                // Draw negative fragment trail
                ctx.beginPath();
                neg.trail.forEach((pt, idx) => {
                    if (idx === 0) ctx.moveTo(pt.x, pt.y);
                    else ctx.lineTo(pt.x, pt.y);
                });
                ctx.strokeStyle = 'rgba(244, 67, 54, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw boosted fragment trail
                ctx.beginPath();
                boost.trail.forEach((pt, idx) => {
                    if (idx === 0) ctx.moveTo(pt.x, pt.y);
                    else ctx.lineTo(pt.x, pt.y);
                });
                ctx.strokeStyle = 'rgba(0, 255, 136, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw fragments
                if (negDist > horizonRadius) {
                    ctx.beginPath();
                    ctx.arc(neg.x, neg.y, 6, 0, Math.PI * 2);
                    ctx.fillStyle = '#f44336';
                    ctx.fill();

                    ctx.font = '11px Georgia';
                    ctx.fillStyle = '#f44336';
                    ctx.textAlign = 'center';
                    ctx.fillText('E < 0', neg.x, neg.y - 12);
                }

                ctx.beginPath();
                ctx.arc(boost.x, boost.y, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#00ff88';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(boost.x, boost.y, 10, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(0, 255, 136, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.font = '11px Georgia';
                ctx.fillStyle = '#00ff88';
                ctx.textAlign = 'center';
                ctx.fillText('E > E₀', boost.x, boost.y - 15);

                // Reset when fragments leave view
                if (boost.x > width + 50 || negDist < horizonRadius - 10) {
                    setTimeout(() => initPenroseParticle(), 1000);
                }
            }

            // Labels
            ctx.font = '14px Georgia';
            ctx.fillStyle = 'rgba(233, 196, 106, 0.8)';
            ctx.textAlign = 'left';
            ctx.fillText('Ergosphere', centerX + ergoRadius + 10, centerY - ergoRadius / 2);
        }

        function drawGyroscope() {
            // Gyroscope orbits the black hole
            gyroscope.precession += 0.003 * spinParam * animSpeed;
            const orbitRadius = 180;
            gyroscope.x = centerX + orbitRadius * Math.cos(gyroscope.precession * 0.5);
            gyroscope.y = centerY + orbitRadius * Math.sin(gyroscope.precession * 0.5);

            // The spin axis precesses due to frame dragging
            const axisLength = 40;
            const precessionAngle = gyroscope.precession;

            // Draw precession cone
            ctx.beginPath();
            ctx.ellipse(gyroscope.x, gyroscope.y - 20, 30, 15, 0, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 107, 107, 0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Draw gyroscope body
            ctx.beginPath();
            ctx.arc(gyroscope.x, gyroscope.y, 15, 0, Math.PI * 2);
            ctx.fillStyle = '#444';
            ctx.fill();
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw spin axis
            const axisX = Math.sin(precessionAngle) * 0.3;
            const axisY = Math.cos(precessionAngle) * 0.3;

            ctx.beginPath();
            ctx.moveTo(gyroscope.x - axisLength * axisX, gyroscope.y + axisLength * axisY);
            ctx.lineTo(gyroscope.x + axisLength * axisX, gyroscope.y - axisLength * axisY);
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 4;
            ctx.stroke();

            // Arrow head
            ctx.beginPath();
            const tipX = gyroscope.x + axisLength * axisX;
            const tipY = gyroscope.y - axisLength * axisY;
            ctx.moveTo(tipX, tipY);
            ctx.lineTo(tipX - 8 * axisX - 8 * axisY, tipY + 8 * axisY - 8 * axisX);
            ctx.lineTo(tipX - 8 * axisX + 8 * axisY, tipY + 8 * axisY + 8 * axisX);
            ctx.closePath();
            ctx.fillStyle = '#ff6b6b';
            ctx.fill();

            // Label
            ctx.font = '12px Georgia';
            ctx.fillStyle = '#ff6b6b';
            ctx.textAlign = 'center';
            ctx.fillText('Gyroscope precesses', gyroscope.x, gyroscope.y + 50);
            ctx.fillText('due to frame dragging', gyroscope.x, gyroscope.y + 65);

            // Show original axis direction (dashed)
            ctx.beginPath();
            ctx.setLineDash([5, 5]);
            ctx.moveTo(gyroscope.x, gyroscope.y - axisLength);
            ctx.lineTo(gyroscope.x, gyroscope.y + axisLength);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawStructure() {
            // Add labels for structure mode
            ctx.font = '14px Georgia';
            ctx.fillStyle = '#8ecae6';
            ctx.textAlign = 'left';

            const ergoRadius = getErgosphereRadius(Math.PI / 2);
            const horizonRadius = getHorizonRadius(Math.PI / 2);

            // Event horizon label
            ctx.fillText('Event Horizon', centerX + horizonRadius + 15, centerY);
            ctx.fillText(`(r = ${(80 + Math.sqrt(6400 - spinParam * spinParam * 6400)).toFixed(0)}M)`, centerX + horizonRadius + 15, centerY + 15);

            // Ergosphere label
            ctx.fillStyle = '#e9c46a';
            ctx.fillText('Ergosphere', centerX + ergoRadius + 15, centerY - 40);
            ctx.fillText('(Stationary limit)', centerX + ergoRadius + 15, centerY - 25);

            // Spin info
            ctx.fillStyle = '#f4a261';
            ctx.textAlign = 'center';
            ctx.fillText(`Spin: a/M = ${spinParam.toFixed(2)}`, centerX, height - 40);

            if (spinParam > 0.95) {
                ctx.fillStyle = '#ff6b6b';
                ctx.fillText('Near-extremal black hole!', centerX, height - 20);
            }
        }

        function animate() {
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(0, 0, width, height);

            time += 0.016 * animSpeed;

            // Draw black hole (common to all modes)
            drawBlackHole();

            // Mode-specific drawing
            switch (currentMode) {
                case 'structure':
                    drawStructure();
                    break;
                case 'dragging':
                    drawFrameDragging();
                    break;
                case 'penrose':
                    drawPenroseProcess();
                    break;
                case 'gyroscope':
                    drawGyroscope();
                    break;
            }

            requestAnimationFrame(animate);
        }

        // Initialize
        initDraggingParticles();
        animate();
    </script>
</body>
</html>
