<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gabriel's Horn - The Painter's Paradox</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --gold: #ffd700;
            --bronze: #cd7f32;
            --deep-purple: #1a0a2e;
            --cosmic: #16213e;
            --accent: #e94560;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #1a0a2e 0%, #16213e 50%, #0f0f23 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            position: relative;
            z-index: 1;
        }
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--gold);
            text-decoration: none;
            font-weight: 500;
            margin-bottom: 30px;
            padding: 10px 20px;
            background: rgba(255,215,0,0.1);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            transition: all 0.3s ease;
            border: 1px solid rgba(255,215,0,0.3);
        }
        .back-link:hover {
            background: rgba(255,215,0,0.2);
            transform: translateX(-5px);
        }
        h1 {
            font-family: 'Lora', serif;
            font-size: 2.8rem;
            font-weight: 600;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #ffd700, #cd7f32);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle {
            font-size: 1.3rem;
            color: rgba(255,255,255,0.7);
            margin-bottom: 40px;
            max-width: 700px;
            line-height: 1.7;
        }
        .intro-box {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 40px;
            border: 1px solid rgba(255,215,0,0.2);
        }
        .intro-box p {
            line-height: 1.8;
            margin-bottom: 15px;
        }
        .intro-box p:last-child { margin-bottom: 0; }
        .highlight {
            color: var(--gold);
            font-weight: 600;
        }
        .paradox-statement {
            background: linear-gradient(135deg, rgba(233,69,96,0.2), rgba(255,215,0,0.1));
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
            border-left: 4px solid var(--accent);
            font-size: 1.2rem;
            font-style: italic;
        }
        .simulation-area {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
            margin-bottom: 40px;
        }
        @media (max-width: 900px) {
            .simulation-area { grid-template-columns: 1fr; }
        }
        .canvas-container {
            background: rgba(0,0,0,0.4);
            border-radius: 20px;
            padding: 20px;
            position: relative;
            min-height: 500px;
        }
        #hornCanvas {
            width: 100%;
            height: 500px;
            border-radius: 12px;
        }
        .controls {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255,215,0,0.2);
        }
        .control-group {
            margin-bottom: 25px;
        }
        .control-label {
            display: block;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--gold);
        }
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ffd700, #cd7f32);
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(255,215,0,0.5);
        }
        .value-display {
            text-align: center;
            font-size: 1.2rem;
            font-weight: 700;
            color: #fff;
            margin-top: 10px;
        }
        .stats-grid {
            display: grid;
            gap: 15px;
            margin-top: 25px;
        }
        .stat-box {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .stat-box.volume {
            border-color: rgba(100,200,100,0.5);
        }
        .stat-box.surface {
            border-color: rgba(233,69,96,0.5);
        }
        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
        }
        .stat-value.converges {
            color: #64c864;
        }
        .stat-value.diverges {
            color: var(--accent);
        }
        .stat-label {
            font-size: 0.85rem;
            color: rgba(255,255,255,0.6);
            margin-top: 5px;
        }
        .stat-limit {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.4);
            margin-top: 3px;
        }
        .formula-section {
            margin-top: 50px;
        }
        .formula-section h2 {
            font-family: 'Lora', serif;
            font-size: 1.8rem;
            color: var(--gold);
            margin-bottom: 25px;
        }
        .formula-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
        }
        .formula-card {
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
        }
        .formula-card h4 {
            color: var(--gold);
            margin-bottom: 15px;
            font-family: 'Lora', serif;
        }
        .formula {
            font-family: 'Georgia', serif;
            font-size: 1.4rem;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
        }
        .formula-result {
            font-size: 1.1rem;
            padding: 10px;
            border-radius: 8px;
        }
        .formula-result.finite {
            background: rgba(100,200,100,0.2);
            color: #90ee90;
        }
        .formula-result.infinite {
            background: rgba(233,69,96,0.2);
            color: #ff6b6b;
        }
        .graph-section {
            margin-top: 50px;
        }
        #graphCanvas {
            width: 100%;
            height: 300px;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
        }
        .history-section {
            margin-top: 50px;
            padding: 30px;
            background: rgba(255,255,255,0.03);
            border-radius: 20px;
            border: 1px solid rgba(255,215,0,0.1);
        }
        .history-section h3 {
            font-family: 'Lora', serif;
            color: var(--gold);
            margin-bottom: 20px;
        }
        .timeline {
            position: relative;
            padding-left: 30px;
            border-left: 3px solid rgba(255,215,0,0.3);
        }
        .timeline-item {
            margin-bottom: 25px;
            position: relative;
        }
        .timeline-item::before {
            content: '';
            position: absolute;
            left: -36px;
            top: 5px;
            width: 12px;
            height: 12px;
            background: var(--gold);
            border-radius: 50%;
        }
        .timeline-year {
            font-weight: 700;
            color: var(--gold);
        }
        .resolution-box {
            background: linear-gradient(135deg, rgba(100,200,100,0.1), rgba(100,200,100,0.05));
            border-radius: 15px;
            padding: 25px;
            margin-top: 40px;
            border: 1px solid rgba(100,200,100,0.3);
        }
        .resolution-box h3 {
            color: #90ee90;
            margin-bottom: 15px;
            font-family: 'Lora', serif;
        }
        .sources {
            margin-top: 50px;
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-radius: 15px;
            font-size: 0.85rem;
        }
        .sources h4 {
            color: var(--gold);
            margin-bottom: 10px;
        }
        .sources a {
            color: rgba(255,255,255,0.6);
            text-decoration: none;
        }
        .sources a:hover {
            color: var(--gold);
        }
        .toggle-btn {
            padding: 12px 24px;
            border: 2px solid var(--gold);
            background: transparent;
            color: var(--gold);
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-top: 15px;
            width: 100%;
        }
        .toggle-btn:hover {
            background: rgba(255,215,0,0.2);
        }
        .toggle-btn.active {
            background: var(--gold);
            color: var(--deep-purple);
        }
    </style>
</head>
<body>
    <canvas class="stars" id="starsCanvas"></canvas>
    
    <div class="container">
        <a href="index.html" class="back-link">← Back to Paradoxes</a>
        
        <h1>Gabriel's Horn</h1>
        <p class="subtitle">A shape with finite volume but infinite surface area—you can fill it with paint, but never paint its surface</p>
        
        <div class="intro-box">
            <p>In 1643, Italian mathematician <span class="highlight">Evangelista Torricelli</span> discovered something that seemed impossible: a three-dimensional object that extends infinitely yet contains a finite amount of space.</p>
            <p>Take the curve y = 1/x and rotate it around the x-axis from x = 1 to infinity. The resulting "horn" shape (also called <span class="highlight">Torricelli's Trumpet</span>) has a volume of exactly <span class="highlight">π cubic units</span>—but its surface area is <span class="highlight">infinite</span>!</p>
        </div>
        
        <div class="paradox-statement">
            "You could fill Gabriel's Horn with a finite amount of paint, yet you would need an infinite amount of paint to coat its surface."
        </div>
        
        <div class="simulation-area">
            <div class="canvas-container">
                <canvas id="hornCanvas"></canvas>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label class="control-label">Extend Horn (x max)</label>
                    <input type="range" id="hornLength" min="2" max="100" value="10">
                    <div class="value-display">x = 1 to <span id="lengthValue">10</span></div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Rotation Speed</label>
                    <input type="range" id="rotationSpeed" min="0" max="100" value="30">
                </div>
                
                <button class="toggle-btn" id="fillBtn">Show Paint Fill</button>
                <button class="toggle-btn" id="wireframeBtn">Toggle Wireframe</button>
                
                <div class="stats-grid">
                    <div class="stat-box volume">
                        <div class="stat-value converges" id="volumeValue">2.83</div>
                        <div class="stat-label">Volume (cubic units)</div>
                        <div class="stat-limit">Limit: π ≈ 3.14159</div>
                    </div>
                    <div class="stat-box surface">
                        <div class="stat-value diverges" id="surfaceValue">14.5</div>
                        <div class="stat-label">Surface Area (sq units)</div>
                        <div class="stat-limit">Limit: ∞</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="ratioValue">5.1</div>
                        <div class="stat-label">Surface/Volume Ratio</div>
                        <div class="stat-limit">Approaches: ∞</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="formula-section">
            <h2>The Mathematics</h2>
            <div class="formula-grid">
                <div class="formula-card">
                    <h4>Volume (Disk Method)</h4>
                    <div class="formula">V = π ∫₁^∞ (1/x)² dx</div>
                    <div class="formula">V = π [-1/x]₁^∞</div>
                    <div class="formula-result finite">V = π (finite!)</div>
                </div>
                <div class="formula-card">
                    <h4>Surface Area</h4>
                    <div class="formula">S = 2π ∫₁^∞ (1/x)√(1 + 1/x⁴) dx</div>
                    <div class="formula">S > 2π ∫₁^∞ (1/x) dx</div>
                    <div class="formula-result infinite">S = ∞ (diverges!)</div>
                </div>
            </div>
        </div>
        
        <div class="graph-section">
            <h2 style="font-family: 'Lora', serif; color: var(--gold); margin-bottom: 20px;">Convergence vs Divergence</h2>
            <p style="color: rgba(255,255,255,0.7); margin-bottom: 20px;">Watch how volume approaches π while surface area grows without bound:</p>
            <canvas id="graphCanvas"></canvas>
        </div>
        
        <div class="resolution-box">
            <h3>Resolving the Paradox</h3>
            <p style="line-height: 1.8; margin-bottom: 15px;">The paradox arises from confusing <strong>mathematical paint</strong> with <strong>physical paint</strong>:</p>
            <p style="line-height: 1.8; margin-bottom: 15px;"><strong>Mathematical paint</strong> has zero thickness. The volume of paint needed to coat a surface is surface area × thickness = ∞ × 0, which is <em>indeterminate</em>, not infinite.</p>
            <p style="line-height: 1.8; margin-bottom: 15px;"><strong>Physical paint</strong> has actual thickness. As you go further down the horn, it eventually becomes narrower than any paint molecule could fit! So physical paint would only cover a finite portion.</p>
            <p style="line-height: 1.8;">The real insight: <em>infinite surface area doesn't require infinite volume to cover it</em>—it only requires that the covering layer become infinitely thin.</p>
        </div>
        
        <div class="history-section">
            <h3>Historical Context</h3>
            <div class="timeline">
                <div class="timeline-item">
                    <div class="timeline-year">1643</div>
                    <p>Evangelista Torricelli publishes "De solido hyperbolico acuto" describing this paradoxical solid. It astounds the mathematical community.</p>
                </div>
                <div class="timeline-item">
                    <div class="timeline-year">1650s</div>
                    <p>Thomas Hobbes and John Wallis engage in fierce debates about the nature of infinity, partly inspired by this discovery.</p>
                </div>
                <div class="timeline-item">
                    <div class="timeline-year">1670s</div>
                    <p>The development of calculus by Newton and Leibniz provides rigorous tools to analyze such infinite processes.</p>
                </div>
                <div class="timeline-item">
                    <div class="timeline-year">Modern Era</div>
                    <p>Gabriel's Horn remains a classic example in calculus courses, illustrating the subtleties of improper integrals and infinity.</p>
                </div>
            </div>
        </div>
        
        <div class="sources">
            <h4>Sources</h4>
            <p>
                <a href="https://en.wikipedia.org/wiki/Gabriel's_horn">Wikipedia: Gabriel's Horn</a> • 
                <a href="https://mathworld.wolfram.com/GabrielsHorn.html">Wolfram MathWorld</a> • 
                <a href="https://thatsmaths.com/2017/04/13/torricellis-trumpet-the-painters-paradox/">That's Maths: Torricelli's Trumpet</a>
            </p>
        </div>
    </div>
    
    <script>
        // Stars background
        const starsCanvas = document.getElementById('starsCanvas');
        const starsCtx = starsCanvas.getContext('2d');
        
        function resizeStars() {
            starsCanvas.width = window.innerWidth;
            starsCanvas.height = window.innerHeight;
            drawStars();
        }
        
        function drawStars() {
            starsCtx.fillStyle = 'transparent';
            starsCtx.fillRect(0, 0, starsCanvas.width, starsCanvas.height);
            
            for (let i = 0; i < 200; i++) {
                const x = Math.random() * starsCanvas.width;
                const y = Math.random() * starsCanvas.height;
                const radius = Math.random() * 1.5;
                const opacity = Math.random() * 0.8 + 0.2;
                
                starsCtx.beginPath();
                starsCtx.arc(x, y, radius, 0, Math.PI * 2);
                starsCtx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                starsCtx.fill();
            }
        }
        
        window.addEventListener('resize', resizeStars);
        resizeStars();
        
        // Main 3D Horn Visualization
        const canvas = document.getElementById('hornCanvas');
        const ctx = canvas.getContext('2d');
        
        let hornLength = 10;
        let rotationSpeed = 0.3;
        let rotation = 0;
        let showFill = false;
        let wireframe = false;
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth - 40;
            canvas.height = 500;
        }
        
        // 3D projection
        function project(x, y, z, rotY) {
            // Rotate around Y axis
            const cosR = Math.cos(rotY);
            const sinR = Math.sin(rotY);
            const rx = x * cosR - z * sinR;
            const rz = x * sinR + z * cosR;
            
            // Simple perspective
            const scale = 400 / (rz + 15);
            const px = canvas.width / 2 + rx * scale;
            const py = canvas.height / 2 - y * scale;
            
            return { x: px, y: py, z: rz, scale };
        }
        
        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const segments = 60;
            const rings = 40;
            const points = [];
            
            // Generate horn points
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const x = 1 + t * (hornLength - 1);
                const r = 1 / x;
                
                const ringPoints = [];
                for (let j = 0; j <= rings; j++) {
                    const angle = (j / rings) * Math.PI * 2;
                    const y = r * Math.cos(angle);
                    const z = r * Math.sin(angle);
                    
                    const projected = project(x - hornLength/2, y * 5, z * 5, rotation);
                    ringPoints.push({ ...projected, x3d: x, r });
                }
                points.push(ringPoints);
            }
            
            // Sort by z for proper rendering
            const faces = [];
            for (let i = 0; i < segments; i++) {
                for (let j = 0; j < rings; j++) {
                    const p1 = points[i][j];
                    const p2 = points[i][j + 1];
                    const p3 = points[i + 1][j + 1];
                    const p4 = points[i + 1][j];
                    
                    const avgZ = (p1.z + p2.z + p3.z + p4.z) / 4;
                    faces.push({ points: [p1, p2, p3, p4], z: avgZ, x3d: p1.x3d });
                }
            }
            
            faces.sort((a, b) => a.z - b.z);
            
            // Draw faces
            for (const face of faces) {
                const [p1, p2, p3, p4] = face.points;
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.lineTo(p3.x, p3.y);
                ctx.lineTo(p4.x, p4.y);
                ctx.closePath();
                
                if (wireframe) {
                    ctx.strokeStyle = `rgba(255, 215, 0, ${0.3 + face.z * 0.03})`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                } else {
                    // Color based on depth and position
                    const brightness = Math.max(0.2, Math.min(1, 0.5 + face.z * 0.05));
                    const hue = showFill ? 200 : 40; // Blue for paint, gold for horn
                    const saturation = showFill ? 70 : 80;
                    
                    ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${brightness * 50}%, 0.9)`;
                    ctx.fill();
                    
                    ctx.strokeStyle = `rgba(255, 215, 0, 0.2)`;
                    ctx.lineWidth = 0.3;
                    ctx.stroke();
                }
            }
            
            // Draw axis
            const axisStart = project(-hornLength/2 - 1, 0, 0, rotation);
            const axisEnd = project(hornLength/2 + 1, 0, 0, rotation);
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(axisStart.x, axisStart.y);
            ctx.lineTo(axisEnd.x, axisEnd.y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Labels
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '14px Nunito';
            ctx.fillText('x = 1', project(-hornLength/2 + 1, -0.8, 0, rotation).x, project(-hornLength/2 + 1, -0.8, 0, rotation).y);
            ctx.fillText('x → ∞', project(hornLength/2 - 1, -0.5, 0, rotation).x, project(hornLength/2 - 1, -0.5, 0, rotation).y);
            
            // Update rotation
            rotation += rotationSpeed * 0.01;
            
            // Update stats
            updateStats();
            
            requestAnimationFrame(draw);
        }
        
        function updateStats() {
            // Volume: π(1 - 1/L) approaches π as L → ∞
            const volume = Math.PI * (1 - 1/hornLength);
            
            // Surface area: 2π * ln(L) + ... (simplified approximation)
            // Actual: 2π ∫ (1/x)√(1 + 1/x⁴) dx, but 2π∫(1/x)dx = 2π*ln(x) is a lower bound
            const surfaceArea = 2 * Math.PI * (Math.log(hornLength) + 1);
            
            document.getElementById('volumeValue').textContent = volume.toFixed(4);
            document.getElementById('surfaceValue').textContent = surfaceArea.toFixed(1);
            document.getElementById('ratioValue').textContent = (surfaceArea / volume).toFixed(1);
        }
        
        // Graph canvas
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');
        
        function resizeGraph() {
            const container = graphCanvas.parentElement;
            graphCanvas.width = container.clientWidth;
            graphCanvas.height = 300;
            drawGraph();
        }
        
        function drawGraph() {
            const margin = { top: 40, right: 40, bottom: 50, left: 70 };
            const width = graphCanvas.width - margin.left - margin.right;
            const height = graphCanvas.height - margin.top - margin.bottom;
            
            graphCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            graphCtx.fillRect(0, 0, graphCanvas.width, graphCanvas.height);
            
            // Axes
            graphCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            graphCtx.lineWidth = 2;
            graphCtx.beginPath();
            graphCtx.moveTo(margin.left, margin.top);
            graphCtx.lineTo(margin.left, margin.top + height);
            graphCtx.lineTo(margin.left + width, margin.top + height);
            graphCtx.stroke();
            
            // Draw π asymptote for volume
            const piY = margin.top + height - (Math.PI / 8) * height;
            graphCtx.strokeStyle = 'rgba(100, 200, 100, 0.5)';
            graphCtx.setLineDash([5, 5]);
            graphCtx.beginPath();
            graphCtx.moveTo(margin.left, piY);
            graphCtx.lineTo(margin.left + width, piY);
            graphCtx.stroke();
            graphCtx.setLineDash([]);
            
            graphCtx.fillStyle = '#64c864';
            graphCtx.font = '12px Nunito';
            graphCtx.fillText('π ≈ 3.14', margin.left + width - 50, piY - 5);
            
            // Volume curve (converges to π)
            graphCtx.strokeStyle = '#64c864';
            graphCtx.lineWidth = 3;
            graphCtx.beginPath();
            for (let i = 0; i <= 100; i++) {
                const x = 1 + i * 0.99;
                const L = 1 + x;
                const vol = Math.PI * (1 - 1/L);
                
                const px = margin.left + (i / 100) * width;
                const py = margin.top + height - (vol / 8) * height;
                
                if (i === 0) graphCtx.moveTo(px, py);
                else graphCtx.lineTo(px, py);
            }
            graphCtx.stroke();
            
            // Highlight current position on volume curve
            const currentVolX = margin.left + ((hornLength - 1) / 99) * width;
            const currentVol = Math.PI * (1 - 1/hornLength);
            const currentVolY = margin.top + height - (currentVol / 8) * height;
            
            graphCtx.fillStyle = '#64c864';
            graphCtx.beginPath();
            graphCtx.arc(Math.min(currentVolX, margin.left + width), currentVolY, 6, 0, Math.PI * 2);
            graphCtx.fill();
            
            // Surface area curve (diverges)
            graphCtx.strokeStyle = '#e94560';
            graphCtx.lineWidth = 3;
            graphCtx.beginPath();
            for (let i = 0; i <= 100; i++) {
                const x = 1 + i * 0.99;
                const L = 1 + x;
                const surf = 2 * Math.PI * (Math.log(L) + 1);
                
                const px = margin.left + (i / 100) * width;
                const py = margin.top + height - (surf / 40) * height;
                
                if (i === 0) graphCtx.moveTo(px, Math.max(py, margin.top));
                else graphCtx.lineTo(px, Math.max(py, margin.top));
            }
            graphCtx.stroke();
            
            // Highlight current position on surface curve
            const currentSurf = 2 * Math.PI * (Math.log(hornLength) + 1);
            const currentSurfY = margin.top + height - (currentSurf / 40) * height;
            
            graphCtx.fillStyle = '#e94560';
            graphCtx.beginPath();
            graphCtx.arc(Math.min(currentVolX, margin.left + width), Math.max(currentSurfY, margin.top), 6, 0, Math.PI * 2);
            graphCtx.fill();
            
            // Labels
            graphCtx.fillStyle = '#fff';
            graphCtx.font = '14px Nunito';
            graphCtx.textAlign = 'center';
            graphCtx.fillText('x (Horn Extension)', margin.left + width / 2, graphCanvas.height - 10);
            
            graphCtx.save();
            graphCtx.translate(20, margin.top + height / 2);
            graphCtx.rotate(-Math.PI / 2);
            graphCtx.fillText('Value', 0, 0);
            graphCtx.restore();
            
            // Legend
            graphCtx.fillStyle = '#64c864';
            graphCtx.fillRect(margin.left + 20, margin.top + 10, 20, 3);
            graphCtx.fillStyle = '#fff';
            graphCtx.textAlign = 'left';
            graphCtx.fillText('Volume (→ π)', margin.left + 50, margin.top + 15);
            
            graphCtx.fillStyle = '#e94560';
            graphCtx.fillRect(margin.left + 20, margin.top + 30, 20, 3);
            graphCtx.fillStyle = '#fff';
            graphCtx.fillText('Surface Area (→ ∞)', margin.left + 50, margin.top + 35);
        }
        
        // Event listeners
        document.getElementById('hornLength').addEventListener('input', (e) => {
            hornLength = parseInt(e.target.value);
            document.getElementById('lengthValue').textContent = hornLength;
            drawGraph();
        });
        
        document.getElementById('rotationSpeed').addEventListener('input', (e) => {
            rotationSpeed = parseInt(e.target.value) / 100;
        });
        
        document.getElementById('fillBtn').addEventListener('click', function() {
            showFill = !showFill;
            this.classList.toggle('active');
            this.textContent = showFill ? 'Hide Paint Fill' : 'Show Paint Fill';
        });
        
        document.getElementById('wireframeBtn').addEventListener('click', function() {
            wireframe = !wireframe;
            this.classList.toggle('active');
        });
        
        // Initialize
        window.addEventListener('resize', () => {
            resizeCanvas();
            resizeGraph();
        });
        
        resizeCanvas();
        resizeGraph();
        draw();
    </script>
</body>
</html>
