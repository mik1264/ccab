<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Dragon Curve - Paper Folding Fractal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a0a2e 0%, #2d1b4e 50%, #1a0a2e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 0;
        }

        h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, #ff6b9d, #c44569, #ff6b9d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #888;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
            margin-top: 20px;
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 107, 157, 0.2);
        }

        canvas {
            display: block;
            width: 100%;
            background: #0a0515;
            border-radius: 10px;
        }

        .controls {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 107, 157, 0.2);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: #ff6b9d;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            background: linear-gradient(90deg, #ff6b9d, #c44569);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #ff6b9d;
            border-radius: 50%;
            cursor: pointer;
        }

        .value-display {
            min-width: 50px;
            text-align: right;
            color: #ff6b9d;
            font-family: monospace;
        }

        .button-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        button {
            padding: 12px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .preset-btn {
            background: linear-gradient(135deg, #2a1a3a, #3a2a4a);
            color: #e0e0e0;
            border: 1px solid rgba(255, 107, 157, 0.3);
        }

        .preset-btn:hover {
            background: linear-gradient(135deg, #3a2a4a, #4a3a5a);
            border-color: #ff6b9d;
        }

        .preset-btn.active {
            background: linear-gradient(135deg, #ff6b9d, #c44569);
            color: #000;
        }

        .stats {
            background: rgba(255, 107, 157, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 107, 157, 0.1);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #ff6b9d;
            font-family: monospace;
        }

        .lsystem-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            border-left: 3px solid #c44569;
        }

        .lsystem-title {
            color: #c44569;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .lsystem-rule {
            font-family: monospace;
            font-size: 0.9rem;
            color: #ddd;
            margin: 5px 0;
            padding: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .explanation {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .exp-card {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 107, 157, 0.2);
        }

        .exp-card h3 {
            color: #ff6b9d;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .exp-card p {
            line-height: 1.7;
            color: #bbb;
        }

        .highlight {
            color: #ff6b9d;
            font-weight: 500;
        }

        .back-link {
            display: inline-block;
            color: #ff6b9d;
            text-decoration: none;
            margin-bottom: 20px;
            transition: transform 0.3s;
        }

        .back-link:hover {
            transform: translateX(-5px);
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

        <header>
            <h1>The Dragon Curve</h1>
            <p class="subtitle">Fold paper in half repeatedly‚Äîunfold to reveal a fractal dragon</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="dragonCanvas" width="800" height="700"></canvas>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Iterations (Folds)</label>
                    <div class="slider-container">
                        <input type="range" id="iterSlider" min="1" max="18" value="12">
                        <span class="value-display" id="iterValue">12</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Dragon Type</label>
                    <div class="button-row">
                        <button class="preset-btn active" data-type="heighway">Heighway</button>
                        <button class="preset-btn" data-type="twindragon">Twindragon</button>
                        <button class="preset-btn" data-type="terdragon">Terdragon</button>
                        <button class="preset-btn" data-type="levy">L√©vy C</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Color Mode</label>
                    <div class="button-row">
                        <button class="preset-btn color-btn active" data-color="rainbow">Rainbow</button>
                        <button class="preset-btn color-btn" data-color="fire">Fire</button>
                        <button class="preset-btn color-btn" data-color="ice">Ice</button>
                        <button class="preset-btn color-btn" data-color="mono">Mono</button>
                    </div>
                </div>

                <div class="stats">
                    <div class="stat-row">
                        <span class="stat-label">Total Segments</span>
                        <span class="stat-value" id="segmentCount">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Turns</span>
                        <span class="stat-value" id="turnCount">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Fractal Dimension</span>
                        <span class="stat-value" id="dimension">2.0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Path Length</span>
                        <span class="stat-value" id="pathLength">-</span>
                    </div>
                </div>

                <div class="lsystem-box">
                    <div class="lsystem-title">L-System Rules</div>
                    <div class="lsystem-rule" id="lsystemAxiom">Axiom: FX</div>
                    <div class="lsystem-rule" id="lsystemRule1">X ‚Üí X+YF+</div>
                    <div class="lsystem-rule" id="lsystemRule2">Y ‚Üí -FX-Y</div>
                    <p style="font-size: 0.8rem; color: #888; margin-top: 10px;">
                        F = draw forward<br>
                        + = turn right 90¬∞<br>
                        - = turn left 90¬∞
                    </p>
                </div>
            </div>
        </div>

        <div class="explanation">
            <div class="exp-card">
                <h3>üìÑ The Surprise</h3>
                <p>
                    Take a strip of paper. Fold it in half, always the same direction. Repeat.
                    Unfold so each crease makes a <span class="highlight">90¬∞ angle</span>.
                    A dragon appears! This simple physical process creates a genuine
                    <span class="highlight">space-filling fractal</span> with dimension exactly 2.
                    Featured in Jurassic Park's chapter headers!
                </p>
            </div>

            <div class="exp-card">
                <h3>üîÑ Self-Similarity</h3>
                <p>
                    Each section of the dragon curve contains <span class="highlight">smaller copies
                    of itself</span>. The curve never crosses itself, yet fills the plane completely
                    when tiled. Two dragons placed tail-to-tail form the "twindragon"‚Äîa more symmetric
                    variant that also tiles the plane.
                </p>
            </div>

            <div class="exp-card">
                <h3>üß¨ L-Systems</h3>
                <p>
                    The curve emerges from <span class="highlight">Lindenmayer systems</span> (1968),
                    originally invented to model plant growth. The dragon uses just two rules applied
                    recursively: X ‚Üí X+YF+ and Y ‚Üí -FX-Y. From these simple string rewrites,
                    infinite complexity unfolds!
                </p>
            </div>

            <div class="exp-card">
                <h3>üìê NASA Origins</h3>
                <p>
                    Discovered by NASA physicists <span class="highlight">Heighway, Banks, and Harter</span>
                    in the 1960s. Martin Gardner popularized it in Scientific American (1967).
                    Davis and Knuth analyzed its properties, showing it tiles the plane and has
                    surprising connections to binary representations and complex analysis.
                </p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('dragonCanvas');
        const ctx = canvas.getContext('2d');

        // High DPI support
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        const W = rect.width;
        const H = rect.height;

        let iterations = 12;
        let dragonType = 'heighway';
        let colorMode = 'rainbow';

        // Generate dragon curve turns using the paper folding sequence
        function generateDragonTurns(n) {
            // Turn sequence: at each iteration, insert a 1 (right turn) in the middle
            // and reverse/complement the existing sequence
            if (n === 0) return [];

            let turns = [1]; // 1 = right, 0 = left
            for (let i = 1; i < n; i++) {
                const newTurns = [...turns, 1];
                for (let j = turns.length - 1; j >= 0; j--) {
                    newTurns.push(1 - turns[j]);
                }
                turns = newTurns;
            }
            return turns;
        }

        // Generate terdragon turns (120¬∞ angles)
        function generateTerdragonTurns(n) {
            if (n === 0) return [];
            let turns = [1]; // 1 = right 120¬∞, -1 = left 120¬∞
            for (let i = 1; i < n; i++) {
                const newTurns = [];
                for (const t of turns) {
                    if (t === 1) {
                        newTurns.push(1, -1, 1);
                    } else {
                        newTurns.push(-1, 1, -1);
                    }
                }
                turns = newTurns;
            }
            return turns;
        }

        // Generate L√©vy C curve turns
        function generateLevyTurns(n) {
            if (n === 0) return [];
            let turns = [1]; // right 45¬∞
            for (let i = 1; i < n; i++) {
                const newTurns = [];
                for (const t of turns) {
                    newTurns.push(1, -1); // right then left
                }
                newTurns.push(1);
                for (let j = turns.length - 1; j >= 0; j--) {
                    newTurns.push(-1, 1);
                }
                turns = newTurns;
            }
            return turns;
        }

        // Get color based on position
        function getColor(i, total) {
            const t = i / total;

            switch (colorMode) {
                case 'rainbow':
                    const hue = (t * 360 + 300) % 360;
                    return `hsl(${hue}, 80%, 60%)`;
                case 'fire':
                    const r = Math.floor(255);
                    const g = Math.floor(t * 200);
                    const b = Math.floor(t * t * 100);
                    return `rgb(${r}, ${g}, ${b})`;
                case 'ice':
                    return `hsl(${200 + t * 60}, 80%, ${50 + t * 30}%)`;
                case 'mono':
                    return '#ff6b9d';
            }
        }

        // Draw the dragon curve
        function drawDragon() {
            ctx.fillStyle = '#0a0515';
            ctx.fillRect(0, 0, W, H);

            let turns, angle, dimension;

            switch (dragonType) {
                case 'heighway':
                    turns = generateDragonTurns(iterations);
                    angle = Math.PI / 2; // 90¬∞
                    dimension = 2;
                    updateLSystemDisplay('FX', 'X ‚Üí X+YF+', 'Y ‚Üí -FX-Y');
                    break;
                case 'twindragon':
                    // Two heighway dragons back to back
                    const turns1 = generateDragonTurns(iterations);
                    const turns2 = generateDragonTurns(iterations).map(t => 1 - t);
                    turns = [...turns1, 1, ...turns2.reverse()];
                    angle = Math.PI / 2;
                    dimension = 2;
                    updateLSystemDisplay('FX+FX', 'X ‚Üí X+YF+', 'Y ‚Üí -FX-Y');
                    break;
                case 'terdragon':
                    turns = generateTerdragonTurns(iterations);
                    angle = 2 * Math.PI / 3; // 120¬∞
                    dimension = Math.log(3) / Math.log(Math.sqrt(3)); // ‚âà 1.26
                    updateLSystemDisplay('F', 'F ‚Üí F+F-F', '¬± ‚Üí turn 120¬∞');
                    break;
                case 'levy':
                    turns = generateLevyTurns(iterations);
                    angle = Math.PI / 4; // 45¬∞
                    dimension = 2;
                    updateLSystemDisplay('F', 'F ‚Üí +F--F+', '¬± ‚Üí turn 45¬∞');
                    break;
            }

            // Calculate path to find bounds
            const path = [];
            let x = 0, y = 0;
            let dir = 0; // Start pointing right
            let minX = 0, maxX = 0, minY = 0, maxY = 0;

            path.push({ x, y });

            for (let i = 0; i < turns.length; i++) {
                // Move forward
                x += Math.cos(dir);
                y += Math.sin(dir);
                path.push({ x, y });

                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);

                // Turn
                if (turns[i] === 1) {
                    dir += angle;
                } else {
                    dir -= angle;
                }
            }

            // Add final segment
            x += Math.cos(dir);
            y += Math.sin(dir);
            path.push({ x, y });
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);

            // Scale and center
            const pathW = maxX - minX;
            const pathH = maxY - minY;
            const scale = Math.min(W * 0.9 / pathW, H * 0.9 / pathH);
            const offsetX = (W - pathW * scale) / 2 - minX * scale;
            const offsetY = (H - pathH * scale) / 2 - minY * scale;

            // Draw path with colors
            ctx.lineWidth = Math.max(0.5, 3 - iterations * 0.15);

            for (let i = 0; i < path.length - 1; i++) {
                ctx.beginPath();
                ctx.moveTo(
                    path[i].x * scale + offsetX,
                    path[i].y * scale + offsetY
                );
                ctx.lineTo(
                    path[i + 1].x * scale + offsetX,
                    path[i + 1].y * scale + offsetY
                );
                ctx.strokeStyle = getColor(i, path.length);
                ctx.stroke();
            }

            // Update stats
            document.getElementById('segmentCount').textContent =
                path.length.toLocaleString();
            document.getElementById('turnCount').textContent =
                turns.length.toLocaleString();
            document.getElementById('dimension').textContent =
                dimension.toFixed(2);
            document.getElementById('pathLength').textContent =
                (path.length * scale / 100).toFixed(1) + ' units';
        }

        function updateLSystemDisplay(axiom, rule1, rule2) {
            document.getElementById('lsystemAxiom').textContent = 'Axiom: ' + axiom;
            document.getElementById('lsystemRule1').textContent = rule1;
            document.getElementById('lsystemRule2').textContent = rule2;
        }

        // Event listeners
        document.getElementById('iterSlider').addEventListener('input', (e) => {
            iterations = parseInt(e.target.value);
            document.getElementById('iterValue').textContent = iterations;
            drawDragon();
        });

        document.querySelectorAll('.preset-btn[data-type]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.preset-btn[data-type]').forEach(b =>
                    b.classList.remove('active'));
                btn.classList.add('active');
                dragonType = btn.dataset.type;
                drawDragon();
            });
        });

        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.color-btn').forEach(b =>
                    b.classList.remove('active'));
                btn.classList.add('active');
                colorMode = btn.dataset.color;
                drawDragon();
            });
        });

        // Initial render
        drawDragon();
    </script>
</body>
</html>
