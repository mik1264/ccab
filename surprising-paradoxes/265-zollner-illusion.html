<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Zöllner Illusion - Parallel Lines That Appear to Diverge</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            color: #e94560;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.2em;
            color: #a0a0a0;
            font-style: italic;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #e94560;
            text-decoration: none;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 100;
            background: rgba(26, 26, 46, 0.9);
            padding: 8px 15px;
            border-radius: 20px;
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(233, 69, 96, 0.2);
            transform: translateX(-3px);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel h2 {
            color: #e94560;
            margin-bottom: 20px;
            font-size: 1.4em;
        }

        .canvas-container {
            text-align: center;
            margin-bottom: 20px;
        }

        canvas {
            border-radius: 10px;
            background: #ffffff;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            color: #a0a0a0;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #e94560;
            cursor: pointer;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .btn-primary {
            background: linear-gradient(135deg, #e94560, #0f3460);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(233, 69, 96, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .explanation {
            line-height: 1.8;
        }

        .explanation p {
            margin-bottom: 15px;
        }

        .highlight {
            color: #e94560;
            font-weight: bold;
        }

        .history-box {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 4px solid #e94560;
        }

        .history-box h3 {
            color: #e94560;
            margin-bottom: 10px;
        }

        .instruction-box {
            background: rgba(233, 69, 96, 0.15);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            border: 1px solid rgba(233, 69, 96, 0.3);
        }

        .variant-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 15px;
        }

        .reveal-text {
            margin-top: 15px;
            padding: 15px;
            background: rgba(233, 69, 96, 0.2);
            border-radius: 10px;
            border: 1px solid #e94560;
            font-weight: bold;
            display: none;
        }

        .reveal-text.visible {
            display: block;
        }

        .theory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .theory-card {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 10px;
        }

        .theory-card h3 {
            color: #4ecdc4;
            margin-bottom: 10px;
        }

        .related-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .related-card {
            background: rgba(255, 255, 255, 0.08);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .related-card h4 {
            color: #4ecdc4;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">
        <span>←</span> Back to Paradoxes
    </a>

    <div class="container">
        <header>
            <h1>The Zöllner Illusion</h1>
            <p class="subtitle">Parallel lines that appear to converge and diverge</p>
        </header>

        <div class="main-content">
            <!-- Classic Zöllner -->
            <div class="panel">
                <h2>Classic Zöllner Pattern</h2>
                <div class="instruction-box">
                    <strong>Look at the long diagonal lines:</strong> They appear to TILT toward
                    or away from each other—but they're perfectly PARALLEL!
                </div>
                <div class="canvas-container">
                    <canvas id="classicCanvas" width="400" height="350"></canvas>
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn btn-primary" onclick="toggleClassicGuides()">Show Guide Lines</button>
                </div>
                <div id="classicReveal" class="reveal-text"></div>
            </div>

            <!-- Adjustable Version -->
            <div class="panel">
                <h2>Adjust the Pattern</h2>
                <div class="canvas-container">
                    <canvas id="customCanvas" width="400" height="350"></canvas>
                </div>
                <div class="controls">
                    <div class="control-group">
                        <label>Hatch Angle: <span id="angleValue">45°</span></label>
                        <input type="range" id="angleSlider" min="10" max="80" value="45" oninput="updateCustom()">
                    </div>
                    <div class="control-group">
                        <label>Hatch Spacing: <span id="spacingValue">8px</span></label>
                        <input type="range" id="spacingSlider" min="4" max="20" value="8" oninput="updateCustom()">
                    </div>
                    <div class="control-group">
                        <label>Hatch Length: <span id="lengthValue">15px</span></label>
                        <input type="range" id="lengthSlider" min="5" max="30" value="15" oninput="updateCustom()">
                    </div>
                </div>
                <p style="margin-top: 15px; color: #a0a0a0; font-size: 0.9em;">
                    The illusion is strongest at ~45° hatch angle. At 0° or 90°, it vanishes!
                </p>
            </div>

            <!-- Horizontal Version -->
            <div class="panel">
                <h2>Horizontal Lines</h2>
                <div class="canvas-container">
                    <canvas id="horizontalCanvas" width="400" height="350"></canvas>
                </div>
                <div class="variant-buttons">
                    <button class="btn btn-secondary" onclick="setHorizontalMode('alternating')">Alternating</button>
                    <button class="btn btn-secondary" onclick="setHorizontalMode('same')">Same Direction</button>
                    <button class="btn btn-secondary" onclick="setHorizontalMode('herringbone')">Herringbone</button>
                </div>
                <p style="text-align: center; color: #a0a0a0; font-size: 0.9em;">
                    Alternating hatch directions create the strongest divergence effect!
                </p>
            </div>

            <!-- Animation -->
            <div class="panel">
                <h2>Animated Rotation</h2>
                <div class="canvas-container">
                    <canvas id="animateCanvas" width="400" height="350"></canvas>
                </div>
                <div class="variant-buttons">
                    <button class="btn btn-primary" id="animateBtn" onclick="toggleAnimation()">Start Animation</button>
                    <button class="btn btn-secondary" onclick="resetAnimation()">Reset</button>
                </div>
                <p style="text-align: center; color: #a0a0a0; font-size: 0.9em;">
                    Watch the apparent tilt REVERSE as the hatch marks rotate!
                </p>
            </div>

            <!-- Breaking the Illusion -->
            <div class="panel">
                <h2>Breaking the Illusion</h2>
                <div class="canvas-container">
                    <canvas id="breakCanvas" width="400" height="350"></canvas>
                </div>
                <div class="variant-buttons">
                    <button class="btn btn-secondary" onclick="setBreakMode('normal')">Normal</button>
                    <button class="btn btn-secondary" onclick="setBreakMode('noHatch')">No Hatches</button>
                    <button class="btn btn-secondary" onclick="setBreakMode('perpendicular')">Perpendicular</button>
                    <button class="btn btn-secondary" onclick="setBreakMode('colored')">Colored</button>
                </div>
                <p style="text-align: center; color: #a0a0a0; font-size: 0.9em;">
                    Remove hatches or make them perpendicular—the illusion vanishes!
                </p>
            </div>

            <!-- Wundt Variant -->
            <div class="panel">
                <h2>The Wundt Illusion</h2>
                <div class="canvas-container">
                    <canvas id="wundtCanvas" width="400" height="350"></canvas>
                </div>
                <p style="text-align: center; color: #a0a0a0; font-size: 0.9em;">
                    The INVERSE of Zöllner! Two parallel lines appear to BOW INWARD when crossed
                    by radiating lines. Same mechanism, opposite effect!
                </p>
            </div>

            <!-- Theory Section -->
            <div class="panel full-width">
                <h2>Why Does This Happen?</h2>
                <div class="theory-grid">
                    <div class="theory-card">
                        <h3>Angle Overestimation</h3>
                        <p>Your visual system systematically overestimates acute angles (< 90°)
                        and underestimates obtuse angles (> 90°). The hatches "push" the perceived
                        orientation of the main lines.</p>
                    </div>
                    <div class="theory-card">
                        <h3>Orientation Columns</h3>
                        <p>Neurons in visual cortex are tuned to specific orientations. When
                        multiple orientations are present nearby, they interact—creating
                        "assimilation" toward the local orientation context.</p>
                    </div>
                    <div class="theory-card">
                        <h3>Lateral Inhibition</h3>
                        <p>Orientation-selective neurons inhibit neighbors with similar
                        orientations. The hatches suppress signals for the main line's true
                        orientation, biasing perception toward the hatch angle.</p>
                    </div>
                    <div class="theory-card">
                        <h3>Gestalt Grouping</h3>
                        <p>Your brain tries to group the hatches with the main line into
                        a unified percept. This "pulls" the perceived orientation of the
                        main line toward the overall pattern direction.</p>
                    </div>
                </div>
            </div>

            <!-- Related Illusions -->
            <div class="panel full-width">
                <h2>Related Illusions</h2>
                <div class="related-grid">
                    <div class="related-card">
                        <canvas id="poggendorffCanvas" width="150" height="120"></canvas>
                        <h4>Poggendorff</h4>
                        <p style="font-size: 0.8em; color: #a0a0a0;">A line behind a rectangle appears misaligned</p>
                    </div>
                    <div class="related-card">
                        <canvas id="heringCanvas" width="150" height="120"></canvas>
                        <h4>Hering</h4>
                        <p style="font-size: 0.8em; color: #a0a0a0;">Parallel lines bow outward at radiating center</p>
                    </div>
                    <div class="related-card">
                        <canvas id="orbissonCanvas" width="150" height="120"></canvas>
                        <h4>Orbison</h4>
                        <p style="font-size: 0.8em; color: #a0a0a0;">A square appears distorted by radiating lines</p>
                    </div>
                </div>
            </div>

            <!-- Measurement Tool -->
            <div class="panel full-width">
                <h2>Prove They're Parallel</h2>
                <div style="display: flex; gap: 30px; flex-wrap: wrap; justify-content: center; align-items: start;">
                    <div class="canvas-container">
                        <canvas id="measureCanvas" width="450" height="350"></canvas>
                    </div>
                    <div style="max-width: 350px;">
                        <p style="margin-bottom: 15px;">
                            <strong>Click two points on any main diagonal line</strong> to measure its angle.
                            All main lines are at exactly the same angle!
                        </p>
                        <div id="measureResult" style="margin-top: 15px; padding: 15px; background: rgba(78, 205, 196, 0.2); border-radius: 10px;">
                            <strong>Click two points to measure...</strong>
                        </div>
                        <button class="btn btn-secondary" style="margin-top: 15px;" onclick="resetMeasure()">Clear Measurements</button>
                    </div>
                </div>
            </div>

            <!-- Explanation -->
            <div class="panel full-width explanation">
                <h2>The History of the Zöllner Illusion</h2>
                <p>
                    The <span class="highlight">Zöllner Illusion</span> was discovered in 1860 by
                    German astrophysicist <span class="highlight">Johann Karl Friedrich Zöllner</span>
                    while examining a cloth pattern. He noticed that parallel lines crossed by
                    short diagonal strokes appeared to converge and diverge.
                </p>
                <p>
                    Zöllner was actually famous for his astronomical work, including measuring
                    the brightness of stars. But his observation of this optical illusion became
                    one of the foundational demonstrations in the new field of experimental
                    psychology.
                </p>
                <p>
                    The illusion is closely related to several others discovered around the same
                    time: the <span class="highlight">Poggendorff illusion</span> (1860),
                    the <span class="highlight">Hering illusion</span> (1861), and the
                    <span class="highlight">Wundt illusion</span> (1898). Together, they reveal
                    how our visual system processes orientation and how context dramatically
                    affects perception.
                </p>

                <div class="history-box">
                    <h3>Practical Implications</h3>
                    <p>
                        The Zöllner illusion affects real-world design. Striped clothing can
                        create perceived body shape changes. Architectural elements with
                        diagonal patterns may appear misaligned. Some optical art deliberately
                        exploits these effects for visual impact. Understanding the illusion
                        helps designers avoid unintended distortions!
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========== CLASSIC ZÖLLNER ==========
        const classicCanvas = document.getElementById('classicCanvas');
        const classicCtx = classicCanvas.getContext('2d');
        let showClassicGuides = false;

        function drawZollner(ctx, width, height, angle = 45, spacing = 8, hatchLength = 15, showGuides = false, lineColor = '#000000') {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, height);

            const lineCount = 8;
            const lineSpacing = height / (lineCount + 1);
            const mainAngle = 20 * Math.PI / 180; // Main lines at 20 degrees
            const hatchAngle = angle * Math.PI / 180;

            ctx.strokeStyle = lineColor;
            ctx.lineWidth = 2;

            for (let i = 1; i <= lineCount; i++) {
                const y = i * lineSpacing;
                const startX = 30;
                const endX = width - 30;

                // Calculate start and end points for angled line
                const yOffset = (endX - startX) * Math.tan(mainAngle);
                const startY = y - yOffset / 2;
                const endY = y + yOffset / 2;

                // Draw main line
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                // Draw hatches
                const hatchDir = (i % 2 === 0) ? 1 : -1;
                const lineLength = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                const numHatches = Math.floor(lineLength / spacing);

                for (let j = 0; j <= numHatches; j++) {
                    const t = j / numHatches;
                    const hx = startX + t * (endX - startX);
                    const hy = startY + t * (endY - startY);

                    // Calculate hatch endpoints
                    const hatchAngleAdjusted = hatchAngle * hatchDir;
                    const dx = Math.cos(mainAngle + hatchAngleAdjusted) * hatchLength;
                    const dy = Math.sin(mainAngle + hatchAngleAdjusted) * hatchLength;

                    ctx.beginPath();
                    ctx.moveTo(hx - dx, hy - dy);
                    ctx.lineTo(hx + dx, hy + dy);
                    ctx.stroke();
                }
            }

            if (showGuides) {
                ctx.strokeStyle = '#e94560';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);

                // Draw parallel reference lines
                for (let i = 1; i <= lineCount; i++) {
                    const y = i * lineSpacing;
                    const startX = 30;
                    const endX = width - 30;
                    const yOffset = (endX - startX) * Math.tan(mainAngle);

                    ctx.beginPath();
                    ctx.moveTo(startX, y - yOffset / 2);
                    ctx.lineTo(endX, y + yOffset / 2);
                    ctx.stroke();
                }

                ctx.setLineDash([]);
            }
        }

        function toggleClassicGuides() {
            showClassicGuides = !showClassicGuides;
            drawZollner(classicCtx, classicCanvas.width, classicCanvas.height, 45, 8, 15, showClassicGuides);

            const reveal = document.getElementById('classicReveal');
            if (showClassicGuides) {
                reveal.innerHTML = '<strong>RED LINES show the TRUE orientation!</strong> All main lines are perfectly parallel at 20°. The hatches create an illusion of convergence/divergence.';
                reveal.classList.add('visible');
            } else {
                reveal.classList.remove('visible');
            }
        }

        // ========== CUSTOM VERSION ==========
        const customCanvas = document.getElementById('customCanvas');
        const customCtx = customCanvas.getContext('2d');

        function updateCustom() {
            const angle = parseInt(document.getElementById('angleSlider').value);
            const spacing = parseInt(document.getElementById('spacingSlider').value);
            const length = parseInt(document.getElementById('lengthSlider').value);

            document.getElementById('angleValue').textContent = angle + '°';
            document.getElementById('spacingValue').textContent = spacing + 'px';
            document.getElementById('lengthValue').textContent = length + 'px';

            drawZollner(customCtx, customCanvas.width, customCanvas.height, angle, spacing, length);
        }

        // ========== HORIZONTAL VERSION ==========
        const horizontalCanvas = document.getElementById('horizontalCanvas');
        const horizontalCtx = horizontalCanvas.getContext('2d');

        function setHorizontalMode(mode) {
            horizontalCtx.fillStyle = '#ffffff';
            horizontalCtx.fillRect(0, 0, horizontalCanvas.width, horizontalCanvas.height);

            const lineCount = 8;
            const lineSpacing = horizontalCanvas.height / (lineCount + 1);
            const hatchAngle = 45 * Math.PI / 180;
            const hatchLength = 15;
            const spacing = 10;

            horizontalCtx.strokeStyle = '#000000';
            horizontalCtx.lineWidth = 2;

            for (let i = 1; i <= lineCount; i++) {
                const y = i * lineSpacing;

                // Draw horizontal main line
                horizontalCtx.beginPath();
                horizontalCtx.moveTo(30, y);
                horizontalCtx.lineTo(horizontalCanvas.width - 30, y);
                horizontalCtx.stroke();

                // Draw hatches based on mode
                let hatchDir;
                if (mode === 'alternating') {
                    hatchDir = (i % 2 === 0) ? 1 : -1;
                } else if (mode === 'same') {
                    hatchDir = 1;
                } else { // herringbone
                    hatchDir = (i % 2 === 0) ? 1 : -1;
                }

                const numHatches = Math.floor((horizontalCanvas.width - 60) / spacing);
                for (let j = 0; j <= numHatches; j++) {
                    const x = 30 + j * spacing;

                    let angle;
                    if (mode === 'herringbone') {
                        // Alternate within each line
                        angle = ((j % 2 === 0) ? 1 : -1) * hatchAngle;
                    } else {
                        angle = hatchDir * hatchAngle;
                    }

                    const dx = Math.cos(angle) * hatchLength;
                    const dy = Math.sin(angle) * hatchLength;

                    horizontalCtx.beginPath();
                    horizontalCtx.moveTo(x, y - dy);
                    horizontalCtx.lineTo(x, y + dy);
                    horizontalCtx.stroke();
                }
            }
        }

        // ========== ANIMATION ==========
        const animateCanvas = document.getElementById('animateCanvas');
        const animateCtx = animateCanvas.getContext('2d');
        let isAnimating = false;
        let animFrame;
        let animAngle = 45;

        function animateZollner(time) {
            animAngle = 45 + 35 * Math.sin(time * 0.002);
            drawZollner(animateCtx, animateCanvas.width, animateCanvas.height, animAngle, 8, 15);

            // Show current angle
            animateCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            animateCtx.fillRect(10, 10, 100, 30);
            animateCtx.fillStyle = '#4ecdc4';
            animateCtx.font = '14px Georgia';
            animateCtx.fillText(`Angle: ${Math.round(animAngle)}°`, 20, 30);

            if (isAnimating) {
                animFrame = requestAnimationFrame(animateZollner);
            }
        }

        function toggleAnimation() {
            isAnimating = !isAnimating;
            document.getElementById('animateBtn').textContent = isAnimating ? 'Stop' : 'Start Animation';

            if (isAnimating) {
                animFrame = requestAnimationFrame(animateZollner);
            } else {
                cancelAnimationFrame(animFrame);
            }
        }

        function resetAnimation() {
            isAnimating = false;
            cancelAnimationFrame(animFrame);
            document.getElementById('animateBtn').textContent = 'Start Animation';
            animAngle = 45;
            drawZollner(animateCtx, animateCanvas.width, animateCanvas.height, 45, 8, 15);
        }

        // ========== BREAK MODE ==========
        const breakCanvas = document.getElementById('breakCanvas');
        const breakCtx = breakCanvas.getContext('2d');

        function setBreakMode(mode) {
            breakCtx.fillStyle = '#ffffff';
            breakCtx.fillRect(0, 0, breakCanvas.width, breakCanvas.height);

            if (mode === 'normal') {
                drawZollner(breakCtx, breakCanvas.width, breakCanvas.height, 45, 8, 15);
            } else if (mode === 'noHatch') {
                // Just parallel lines, no hatches
                const lineCount = 8;
                const lineSpacing = breakCanvas.height / (lineCount + 1);
                const mainAngle = 20 * Math.PI / 180;

                breakCtx.strokeStyle = '#000000';
                breakCtx.lineWidth = 2;

                for (let i = 1; i <= lineCount; i++) {
                    const y = i * lineSpacing;
                    const startX = 30;
                    const endX = breakCanvas.width - 30;
                    const yOffset = (endX - startX) * Math.tan(mainAngle);

                    breakCtx.beginPath();
                    breakCtx.moveTo(startX, y - yOffset / 2);
                    breakCtx.lineTo(endX, y + yOffset / 2);
                    breakCtx.stroke();
                }
            } else if (mode === 'perpendicular') {
                // Hatches perpendicular to main lines (90°)
                drawZollner(breakCtx, breakCanvas.width, breakCanvas.height, 90, 8, 15);
            } else if (mode === 'colored') {
                // Colored version
                breakCtx.fillStyle = '#ffffff';
                breakCtx.fillRect(0, 0, breakCanvas.width, breakCanvas.height);

                const lineCount = 8;
                const lineSpacing = breakCanvas.height / (lineCount + 1);
                const mainAngle = 20 * Math.PI / 180;
                const hatchAngle = 45 * Math.PI / 180;
                const spacing = 8;
                const hatchLength = 15;

                const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12'];

                for (let i = 1; i <= lineCount; i++) {
                    const y = i * lineSpacing;
                    const startX = 30;
                    const endX = breakCanvas.width - 30;
                    const yOffset = (endX - startX) * Math.tan(mainAngle);
                    const startY = y - yOffset / 2;
                    const endY = y + yOffset / 2;

                    breakCtx.strokeStyle = colors[(i - 1) % colors.length];
                    breakCtx.lineWidth = 2;

                    breakCtx.beginPath();
                    breakCtx.moveTo(startX, startY);
                    breakCtx.lineTo(endX, endY);
                    breakCtx.stroke();

                    const hatchDir = (i % 2 === 0) ? 1 : -1;
                    const lineLength = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                    const numHatches = Math.floor(lineLength / spacing);

                    for (let j = 0; j <= numHatches; j++) {
                        const t = j / numHatches;
                        const hx = startX + t * (endX - startX);
                        const hy = startY + t * (endY - startY);

                        const hatchAngleAdjusted = hatchAngle * hatchDir;
                        const dx = Math.cos(mainAngle + hatchAngleAdjusted) * hatchLength;
                        const dy = Math.sin(mainAngle + hatchAngleAdjusted) * hatchLength;

                        breakCtx.beginPath();
                        breakCtx.moveTo(hx - dx, hy - dy);
                        breakCtx.lineTo(hx + dx, hy + dy);
                        breakCtx.stroke();
                    }
                }
            }
        }

        // ========== WUNDT ILLUSION ==========
        const wundtCanvas = document.getElementById('wundtCanvas');
        const wundtCtx = wundtCanvas.getContext('2d');

        function drawWundt() {
            wundtCtx.fillStyle = '#ffffff';
            wundtCtx.fillRect(0, 0, wundtCanvas.width, wundtCanvas.height);

            const centerX = wundtCanvas.width / 2;
            const centerY = wundtCanvas.height / 2;

            wundtCtx.strokeStyle = '#000000';
            wundtCtx.lineWidth = 1;

            // Draw radiating lines
            const numLines = 20;
            for (let i = 0; i < numLines; i++) {
                const angle = (i / numLines) * Math.PI;
                const x = Math.cos(angle) * 200;
                const y = Math.sin(angle) * 200;

                wundtCtx.beginPath();
                wundtCtx.moveTo(centerX - x, centerY - y);
                wundtCtx.lineTo(centerX + x, centerY + y);
                wundtCtx.stroke();
            }

            // Draw two parallel horizontal lines
            wundtCtx.strokeStyle = '#e94560';
            wundtCtx.lineWidth = 3;

            const lineY1 = centerY - 40;
            const lineY2 = centerY + 40;

            wundtCtx.beginPath();
            wundtCtx.moveTo(50, lineY1);
            wundtCtx.lineTo(wundtCanvas.width - 50, lineY1);
            wundtCtx.stroke();

            wundtCtx.beginPath();
            wundtCtx.moveTo(50, lineY2);
            wundtCtx.lineTo(wundtCanvas.width - 50, lineY2);
            wundtCtx.stroke();
        }

        // ========== RELATED ILLUSIONS ==========
        function drawRelatedIllusions() {
            // Poggendorff
            const pogCanvas = document.getElementById('poggendorffCanvas');
            const pogCtx = pogCanvas.getContext('2d');
            pogCtx.fillStyle = '#ffffff';
            pogCtx.fillRect(0, 0, 150, 120);

            // Rectangle
            pogCtx.fillStyle = '#808080';
            pogCtx.fillRect(50, 20, 50, 80);

            // Diagonal line (appears misaligned)
            pogCtx.strokeStyle = '#000000';
            pogCtx.lineWidth = 2;
            pogCtx.beginPath();
            pogCtx.moveTo(20, 90);
            pogCtx.lineTo(50, 60);
            pogCtx.moveTo(100, 30);
            pogCtx.lineTo(130, 0);
            pogCtx.stroke();

            // Hering
            const herCanvas = document.getElementById('heringCanvas');
            const herCtx = herCanvas.getContext('2d');
            herCtx.fillStyle = '#ffffff';
            herCtx.fillRect(0, 0, 150, 120);

            // Radiating lines
            herCtx.strokeStyle = '#000000';
            herCtx.lineWidth = 1;
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI;
                herCtx.beginPath();
                herCtx.moveTo(75 - Math.cos(angle) * 80, 60 - Math.sin(angle) * 80);
                herCtx.lineTo(75 + Math.cos(angle) * 80, 60 + Math.sin(angle) * 80);
                herCtx.stroke();
            }

            // Two horizontal parallel lines
            herCtx.strokeStyle = '#e94560';
            herCtx.lineWidth = 2;
            herCtx.beginPath();
            herCtx.moveTo(10, 40);
            herCtx.lineTo(140, 40);
            herCtx.moveTo(10, 80);
            herCtx.lineTo(140, 80);
            herCtx.stroke();

            // Orbison
            const orbCanvas = document.getElementById('orbissonCanvas');
            const orbCtx = orbCanvas.getContext('2d');
            orbCtx.fillStyle = '#ffffff';
            orbCtx.fillRect(0, 0, 150, 120);

            // Radiating lines
            orbCtx.strokeStyle = '#000000';
            orbCtx.lineWidth = 1;
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                orbCtx.beginPath();
                orbCtx.moveTo(75, 60);
                orbCtx.lineTo(75 + Math.cos(angle) * 70, 60 + Math.sin(angle) * 70);
                orbCtx.stroke();
            }

            // Square
            orbCtx.strokeStyle = '#e94560';
            orbCtx.lineWidth = 2;
            orbCtx.strokeRect(45, 30, 60, 60);
        }

        // ========== MEASUREMENT ==========
        const measureCanvas = document.getElementById('measureCanvas');
        const measureCtx = measureCanvas.getContext('2d');
        let measurePoints = [];

        function drawMeasure() {
            drawZollner(measureCtx, measureCanvas.width, measureCanvas.height, 45, 8, 15);

            // Draw points
            measureCtx.fillStyle = '#e94560';
            measurePoints.forEach(p => {
                measureCtx.beginPath();
                measureCtx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                measureCtx.fill();
            });

            if (measurePoints.length === 2) {
                measureCtx.strokeStyle = '#e94560';
                measureCtx.lineWidth = 3;
                measureCtx.beginPath();
                measureCtx.moveTo(measurePoints[0].x, measurePoints[0].y);
                measureCtx.lineTo(measurePoints[1].x, measurePoints[1].y);
                measureCtx.stroke();

                const dx = measurePoints[1].x - measurePoints[0].x;
                const dy = measurePoints[1].y - measurePoints[0].y;
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;

                document.getElementById('measureResult').innerHTML =
                    `<strong>Measured angle: ${angle.toFixed(1)}°</strong><br>` +
                    `<span style="color: #4ecdc4;">All main lines are at ~20°. The tilt you see is an illusion!</span>`;
            }
        }

        measureCanvas.addEventListener('click', e => {
            const rect = measureCanvas.getBoundingClientRect();
            if (measurePoints.length >= 2) measurePoints = [];
            measurePoints.push({ x: e.clientX - rect.left, y: e.clientY - rect.top });
            drawMeasure();
        });

        function resetMeasure() {
            measurePoints = [];
            document.getElementById('measureResult').innerHTML = '<strong>Click two points to measure...</strong>';
            drawMeasure();
        }

        // Initialize
        drawZollner(classicCtx, classicCanvas.width, classicCanvas.height);
        updateCustom();
        setHorizontalMode('alternating');
        drawZollner(animateCtx, animateCanvas.width, animateCanvas.height);
        setBreakMode('normal');
        drawWundt();
        drawRelatedIllusions();
        drawMeasure();
    </script>
</body>
</html>
