<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Paradox of the Plankton - Surprising Paradoxes</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Nunito:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #051020 0%, #0a2040 50%, #051525 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: #4af;
            text-decoration: none;
            font-weight: 500;
            padding: 10px 20px;
            background: rgba(10,40,80,0.8);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            border: 1px solid rgba(68,170,255,0.3);
            transition: all 0.3s ease;
        }
        .back-link:hover {
            background: rgba(20,60,100,0.9);
            transform: translateX(-5px);
        }
        header {
            text-align: center;
            padding: 80px 20px 20px;
        }
        h1 {
            font-family: 'Lora', serif;
            font-size: 2.8rem;
            background: linear-gradient(135deg, #0af, #4f8, #8ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }
        .subtitle {
            color: #8cf;
            font-size: 1.2rem;
            max-width: 700px;
            margin: 0 auto;
        }
        .paradox-highlight {
            background: linear-gradient(135deg, rgba(0,100,200,0.2), rgba(0,200,100,0.2));
            border: 1px solid rgba(68,170,255,0.4);
            border-radius: 15px;
            padding: 25px;
            margin: 30px auto;
            max-width: 800px;
            text-align: center;
        }
        .paradox-highlight h2 {
            font-family: 'Lora', serif;
            color: #4f8;
            font-size: 1.5rem;
            margin-bottom: 10px;
        }
        .paradox-highlight p {
            color: #cef;
            font-size: 1.1rem;
            line-height: 1.6;
        }
        .simulation-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            padding: 20px;
        }
        .canvas-wrapper {
            background: rgba(10,30,60,0.8);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(68,170,255,0.3);
        }
        .canvas-wrapper h3 {
            text-align: center;
            color: #8cf;
            font-size: 1rem;
            margin-bottom: 10px;
        }
        canvas {
            display: block;
            border-radius: 10px;
            background: #020810;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            padding: 20px;
            max-width: 1000px;
            margin: 0 auto;
        }
        .control-group {
            background: rgba(10,40,80,0.8);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(68,170,255,0.3);
            min-width: 150px;
        }
        .control-group label {
            display: block;
            color: #8cf;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }
        .control-group input[type="range"] {
            width: 100%;
            margin: 8px 0;
            accent-color: #4af;
        }
        .control-group input[type="checkbox"] {
            margin-right: 8px;
            accent-color: #4f8;
        }
        button {
            background: linear-gradient(135deg, #0af, #4f8);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0,170,255,0.4);
        }
        .population-chart {
            background: rgba(10,30,60,0.9);
            border-radius: 15px;
            padding: 15px;
            margin: 20px auto;
            max-width: 900px;
            border: 1px solid rgba(68,170,255,0.3);
        }
        .species-legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.85rem;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        .stats-panel {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            text-align: center;
            margin-top: 15px;
        }
        .stat-item {
            padding: 10px;
            background: rgba(0,50,100,0.3);
            border-radius: 10px;
        }
        .stat-label {
            color: #888;
            font-size: 0.75rem;
            text-transform: uppercase;
        }
        .stat-value {
            color: #4f8;
            font-size: 1.2rem;
            font-family: monospace;
            margin-top: 5px;
        }
        .essay {
            max-width: 800px;
            margin: 40px auto;
            padding: 0 20px;
        }
        .essay h2 {
            font-family: 'Lora', serif;
            color: #4af;
            font-size: 1.8rem;
            margin: 40px 0 20px;
            border-bottom: 1px solid rgba(68,170,255,0.3);
            padding-bottom: 10px;
        }
        .essay p {
            color: #ccc;
            line-height: 1.8;
            margin-bottom: 20px;
            text-align: justify;
        }
        .essay strong {
            color: #4f8;
        }
        .principle-box {
            background: linear-gradient(135deg, rgba(255,50,50,0.2), rgba(100,50,50,0.2));
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 3px solid #f55;
        }
        .principle-box h4 {
            color: #f88;
            margin-bottom: 10px;
        }
        .solution-box {
            background: linear-gradient(135deg, rgba(50,255,100,0.15), rgba(50,100,50,0.15));
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 3px solid #4f8;
        }
        .solution-box h4 {
            color: #8f8;
            margin-bottom: 10px;
        }
        blockquote {
            border-left: 3px solid #4af;
            padding-left: 20px;
            margin: 20px 0;
            font-style: italic;
            color: #adf;
        }
        .sources {
            background: rgba(10,30,60,0.5);
            border-radius: 15px;
            padding: 20px;
            margin-top: 40px;
        }
        .sources h3 {
            color: #4af;
            margin-bottom: 15px;
        }
        .sources ul {
            list-style: none;
        }
        .sources li {
            margin: 10px 0;
        }
        .sources a {
            color: #8ff;
            text-decoration: none;
        }
        .sources a:hover {
            text-decoration: underline;
        }
        @media (max-width: 768px) {
            h1 { font-size: 2rem; }
            .stats-panel { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Paradoxes</a>

    <header>
        <h1>The Paradox of the Plankton</h1>
        <p class="subtitle">How do dozens of species coexist on one resource?</p>
    </header>

    <div class="paradox-highlight">
        <h2>The Paradox</h2>
        <p><strong>Competitive exclusion</strong> says when species compete for the same resource, ONE will win and the others go extinct. Yet in every drop of ocean water, <strong>dozens of plankton species</strong> coexist — all competing for the same light and nutrients. How?</p>
    </div>

    <div class="simulation-container">
        <div class="canvas-wrapper">
            <h3>Ocean Microcosm — Watch Species Compete</h3>
            <canvas id="oceanCanvas" width="800" height="400"></canvas>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Environment</label>
            <label><input type="checkbox" id="fluctuations" checked> Fluctuations</label>
            <label><input type="checkbox" id="viruses"> Viruses (Kill the Winner)</label>
            <label><input type="checkbox" id="grazing"> Predation</label>
        </div>
        <div class="control-group">
            <label>Species Count</label>
            <input type="range" id="speciesCount" min="2" max="12" value="8">
            <div style="text-align:center;color:#8cf;" id="speciesValue">8 species</div>
        </div>
        <div class="control-group">
            <label>Resource Competition</label>
            <input type="range" id="competition" min="0" max="100" value="50">
            <div style="text-align:center;color:#8cf;" id="competitionValue">Moderate</div>
        </div>
        <div class="control-group">
            <label>Simulation</label>
            <button id="btnReset">Reset</button>
            <button id="btnFastForward">⏩ 100 gen</button>
        </div>
    </div>

    <div class="population-chart">
        <canvas id="chartCanvas" width="880" height="200"></canvas>
        <div class="species-legend" id="speciesLegend"></div>
        <div class="stats-panel">
            <div class="stat-item">
                <div class="stat-label">Generation</div>
                <div class="stat-value" id="genValue">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Species Alive</div>
                <div class="stat-value" id="aliveValue">8</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Total Resources</div>
                <div class="stat-value" id="resourceValue">100%</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Dominant Species</div>
                <div class="stat-value" id="dominantValue">—</div>
            </div>
        </div>
    </div>

    <div class="essay">
        <h2>A Drop of Seawater Shouldn't Work</h2>

        <p>In 1961, ecologist G. Evelyn Hutchinson asked a question that haunted biology: in a featureless ocean, where every plankton species competes for the same sunlight and nutrients, why do any species survive besides the single best competitor?</p>

        <div class="principle-box">
            <h4>The Competitive Exclusion Principle (Gause's Law)</h4>
            <p>When two species compete for exactly the same resource, one will always outcompete the other. The inferior competitor will be driven to extinction. In the long run, <strong>one niche = one species</strong>.</p>
        </div>

        <p>This principle works beautifully in the lab. Grow two species of paramecium in the same test tube, and within weeks, one dominates completely. The loser goes extinct.</p>

        <p>But the ocean doesn't read textbooks.</p>

        <h2>The Embarrassing Reality</h2>

        <p>A single liter of seawater can contain <strong>hundreds of phytoplankton species</strong>. They all photosynthesize. They all need nitrogen, phosphorus, silica. The water is well-mixed, homogeneous. There's no place to hide, no separate niches.</p>

        <p>By all rights, ONE species should dominate every ocean basin. The best photosynthesizer, the most efficient nutrient absorber—it should win and drive everything else to extinction.</p>

        <blockquote>"How is it possible for a number of species to coexist in a relatively isotropic or unstructured environment, all competing for the same sorts of materials?" — G. E. Hutchinson, 1961</blockquote>

        <h2>Proposed Solutions</h2>

        <div class="solution-box">
            <h4>1. Environmental Fluctuations</h4>
            <p>Hutchinson's original idea: the environment never stays constant long enough for one species to win. Temperature shifts, storms mix nutrients, seasons change light levels. Different species are favored at different times — nobody dominates for long.</p>
        </div>

        <div class="solution-box">
            <h4>2. "Kill the Winner" (Viral Predation)</h4>
            <p>Marine viruses preferentially attack whichever species becomes most common. As soon as one plankton species starts winning, viral epidemics knock it back. This keeps the playing field level.</p>
        </div>

        <div class="solution-box">
            <h4>3. Zooplankton Grazing</h4>
            <p>Grazers like copepods eat the most abundant prey. Success makes you a target. This density-dependent predation prevents any species from monopolizing resources.</p>
        </div>

        <div class="solution-box">
            <h4>4. Hidden Niche Structure</h4>
            <p>Recent research shows the ocean is more structured than Hutchinson thought. Vertical gradients, micronutrients, light spectra, and temperature layers create distinct niches. Species aren't competing for <em>exactly</em> the same thing.</p>
        </div>

        <h2>The Deeper Lesson</h2>

        <p>The paradox of the plankton taught ecologists that <strong>equilibrium is rare in nature</strong>. Real ecosystems are always in flux — and that instability is precisely what maintains diversity.</p>

        <p>Hutchinson's 1961 paper has been cited over 2,000 times and continues to inspire research. It showed that classical theory, while elegant, missed something fundamental about how nature works.</p>

        <p>The ocean's riotous diversity isn't a bug — it's a feature. Chaos, viruses, predators, and storms conspire to prevent the "best" from winning. In ecology, as in life, the race doesn't always go to the swift.</p>

        <div class="sources">
            <h3>Sources & Further Reading</h3>
            <ul>
                <li><a href="https://en.wikipedia.org/wiki/Paradox_of_the_plankton" target="_blank">Wikipedia: Paradox of the Plankton</a></li>
                <li><a href="https://hahana.soest.hawaii.edu/cmoreserver/summercourse/2007/documents/paradox_of_the_plankton.pdf" target="_blank">Hutchinson's Original 1961 Paper (PDF)</a></li>
                <li><a href="https://royalsocietypublishing.org/doi/full/10.1098/rsbl.2022.0207" target="_blank">Royal Society: How Do Plankton Species Coexist?</a></li>
                <li><a href="https://link.springer.com/article/10.1023/A:1024404804748" target="_blank">Hydrobiologia: Why Plankton Have No Equilibrium</a></li>
                <li><a href="https://www.sciencedirect.com/science/article/abs/pii/S1476945X07000165" target="_blank">ScienceDirect: Towards a Resolution of the Paradox</a></li>
            </ul>
        </div>
    </div>

    <script>
        const oceanCanvas = document.getElementById('oceanCanvas');
        const oceanCtx = oceanCanvas.getContext('2d');
        const chartCanvas = document.getElementById('chartCanvas');
        const chartCtx = chartCanvas.getContext('2d');

        // High DPI
        function setupCanvas(canvas, ctx, width, height) {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
        }

        setupCanvas(oceanCanvas, oceanCtx, 800, 400);
        setupCanvas(chartCanvas, chartCtx, 880, 200);

        // Species colors
        const speciesColors = [
            '#00ff88', '#ff6644', '#44aaff', '#ffcc00',
            '#ff44aa', '#44ffcc', '#aa44ff', '#ff8844',
            '#88ff44', '#4488ff', '#ff4488', '#88ffaa'
        ];

        // Simulation state
        let species = [];
        let history = [];
        let generation = 0;
        let resources = 100;

        // Parameters
        let numSpecies = 8;
        let useFluctuations = true;
        let useViruses = false;
        let useGrazing = false;
        let competitionLevel = 0.5;

        // Plankton individuals for visualization
        let planktonVisuals = [];

        class PlanktonVisual {
            constructor(speciesId) {
                this.speciesId = speciesId;
                this.x = Math.random() * 800;
                this.y = Math.random() * 400;
                this.size = Math.random() * 4 + 2;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.3;
                this.angle = Math.random() * Math.PI * 2;
                this.wobble = Math.random() * Math.PI * 2;
            }

            update(time) {
                this.wobble += 0.05;
                this.x += this.vx + Math.sin(this.wobble) * 0.3;
                this.y += this.vy + Math.cos(this.wobble * 0.7) * 0.2;

                // Wrap around
                if (this.x < 0) this.x = 800;
                if (this.x > 800) this.x = 0;
                if (this.y < 0) this.y = 400;
                if (this.y > 400) this.y = 0;
            }

            draw(ctx) {
                const color = speciesColors[this.speciesId % speciesColors.length];
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.8;

                // Different shapes for different species
                const shapeType = this.speciesId % 4;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.sin(this.wobble * 0.5) * 0.2);

                switch(shapeType) {
                    case 0: // Circle (diatom)
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 1: // Oval (dinoflagellate)
                        ctx.beginPath();
                        ctx.ellipse(0, 0, this.size * 1.5, this.size * 0.7, 0, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 2: // Triangle (chain diatom)
                        ctx.beginPath();
                        ctx.moveTo(0, -this.size);
                        ctx.lineTo(this.size, this.size);
                        ctx.lineTo(-this.size, this.size);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 3: // Star (coccolithophore)
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const angle = (i / 5) * Math.PI * 2 - Math.PI / 2;
                            const r = i % 2 === 0 ? this.size : this.size * 0.5;
                            ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                        }
                        ctx.closePath();
                        ctx.fill();
                        break;
                }

                ctx.restore();
                ctx.globalAlpha = 1;
            }
        }

        function initSimulation() {
            species = [];
            history = [];
            generation = 0;
            planktonVisuals = [];

            // Initialize species with random fitness values
            for (let i = 0; i < numSpecies; i++) {
                species.push({
                    id: i,
                    population: 100,
                    fitness: 0.8 + Math.random() * 0.4, // Base fitness
                    optimalTemp: Math.random(), // Preferred "temperature"
                    viralResistance: Math.random(),
                    grazingResistance: Math.random()
                });
            }

            updateVisuals();
            updateLegend();
        }

        function updateVisuals() {
            planktonVisuals = [];
            species.forEach(sp => {
                const count = Math.min(Math.floor(sp.population / 5), 50);
                for (let i = 0; i < count; i++) {
                    planktonVisuals.push(new PlanktonVisual(sp.id));
                }
            });
        }

        function simulateGeneration() {
            generation++;

            // Environmental condition (fluctuates if enabled)
            const envCondition = useFluctuations ?
                0.5 + 0.4 * Math.sin(generation * 0.1 + Math.random() * 0.5) :
                0.5;

            // Calculate growth rates
            species.forEach(sp => {
                if (sp.population <= 0) return;

                // Base growth based on fitness
                let growth = sp.fitness;

                // Competition effect (density-dependent)
                const totalPop = species.reduce((sum, s) => sum + s.population, 0);
                const competitionPenalty = competitionLevel * (totalPop / 1000);
                growth -= competitionPenalty;

                // Environmental match (if fluctuations enabled)
                if (useFluctuations) {
                    const envMatch = 1 - Math.abs(sp.optimalTemp - envCondition);
                    growth *= envMatch;
                }

                // Viral pressure (kill the winner)
                if (useViruses) {
                    const dominance = sp.population / Math.max(1, totalPop);
                    const viralPressure = dominance * 2 * (1 - sp.viralResistance);
                    growth -= viralPressure;
                }

                // Grazing pressure
                if (useGrazing) {
                    const dominance = sp.population / Math.max(1, totalPop);
                    const grazingPressure = dominance * 1.5 * (1 - sp.grazingResistance);
                    growth -= grazingPressure;
                }

                // Apply growth
                sp.population = Math.max(0, sp.population * (1 + growth * 0.1));

                // Add stochasticity
                sp.population += (Math.random() - 0.5) * 5;
                sp.population = Math.max(0, Math.round(sp.population));
            });

            // Record history
            const snapshot = species.map(sp => sp.population);
            history.push(snapshot);
            if (history.length > 500) history.shift();
        }

        function updateLegend() {
            const legend = document.getElementById('speciesLegend');
            legend.innerHTML = '';
            for (let i = 0; i < numSpecies; i++) {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <span class="legend-color" style="background:${speciesColors[i]}"></span>
                    <span>Species ${i + 1}</span>
                `;
                legend.appendChild(item);
            }
        }

        function drawOcean(time) {
            const ctx = oceanCtx;
            const width = 800;
            const height = 400;

            // Ocean gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#0a3060');
            gradient.addColorStop(0.3, '#051530');
            gradient.addColorStop(1, '#020810');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Light rays from surface
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.05)';
            ctx.lineWidth = 30;
            for (let i = 0; i < 8; i++) {
                const x = (i / 8) * width + Math.sin(time * 0.001 + i) * 30;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x + 50, height);
                ctx.stroke();
            }

            // Update and draw plankton
            planktonVisuals.forEach(p => {
                p.update(time);
                p.draw(ctx);
            });

            // Environmental indicator
            if (useFluctuations) {
                const envCondition = 0.5 + 0.4 * Math.sin(generation * 0.1);
                ctx.fillStyle = `rgba(255, ${Math.floor(envCondition * 200)}, ${Math.floor((1 - envCondition) * 200)}, 0.3)`;
                ctx.fillRect(width - 30, 10, 20, height - 20);
                ctx.fillStyle = '#fff';
                ctx.font = '10px Nunito';
                ctx.save();
                ctx.translate(width - 15, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.textAlign = 'center';
                ctx.fillText('Environment', 0, 0);
                ctx.restore();
            }
        }

        function drawChart() {
            const ctx = chartCtx;
            const width = 880;
            const height = 200;

            ctx.fillStyle = '#020810';
            ctx.fillRect(0, 0, width, height);

            if (history.length < 2) return;

            // Draw population lines
            const padding = 20;
            const chartWidth = width - padding * 2;
            const chartHeight = height - padding * 2;

            // Find max population for scaling
            let maxPop = 0;
            history.forEach(snapshot => {
                snapshot.forEach(pop => {
                    if (pop > maxPop) maxPop = pop;
                });
            });
            maxPop = Math.max(maxPop, 100);

            // Draw grid
            ctx.strokeStyle = 'rgba(100, 150, 200, 0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = padding + (i / 4) * chartHeight;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }

            // Draw each species line
            for (let s = 0; s < numSpecies; s++) {
                ctx.strokeStyle = speciesColors[s];
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let i = 0; i < history.length; i++) {
                    const x = padding + (i / (history.length - 1)) * chartWidth;
                    const pop = history[i][s] || 0;
                    const y = height - padding - (pop / maxPop) * chartHeight;

                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '10px Nunito';
            ctx.textAlign = 'right';
            ctx.fillText(Math.round(maxPop), padding - 5, padding + 5);
            ctx.fillText('0', padding - 5, height - padding + 5);
            ctx.textAlign = 'center';
            ctx.fillText('Generations', width / 2, height - 5);
        }

        function updateStats() {
            const alive = species.filter(sp => sp.population > 0).length;
            const totalPop = species.reduce((sum, sp) => sum + sp.population, 0);
            const dominant = species.reduce((max, sp) => sp.population > max.population ? sp : max, species[0]);

            document.getElementById('genValue').textContent = generation;
            document.getElementById('aliveValue').textContent = alive;
            document.getElementById('resourceValue').textContent = Math.round(Math.min(100, 100 - totalPop / 20)) + '%';
            document.getElementById('dominantValue').textContent = dominant.population > 0 ?
                `#${dominant.id + 1} (${Math.round(dominant.population / totalPop * 100)}%)` : '—';
        }

        // Controls
        document.getElementById('speciesCount').addEventListener('input', (e) => {
            numSpecies = parseInt(e.target.value);
            document.getElementById('speciesValue').textContent = numSpecies + ' species';
            initSimulation();
        });

        document.getElementById('competition').addEventListener('input', (e) => {
            competitionLevel = parseInt(e.target.value) / 100;
            const labels = ['Low', 'Moderate', 'High', 'Extreme'];
            document.getElementById('competitionValue').textContent = labels[Math.floor(competitionLevel * 3.99)];
        });

        document.getElementById('fluctuations').addEventListener('change', (e) => {
            useFluctuations = e.target.checked;
        });

        document.getElementById('viruses').addEventListener('change', (e) => {
            useViruses = e.target.checked;
        });

        document.getElementById('grazing').addEventListener('change', (e) => {
            useGrazing = e.target.checked;
        });

        document.getElementById('btnReset').addEventListener('click', () => {
            initSimulation();
        });

        document.getElementById('btnFastForward').addEventListener('click', () => {
            for (let i = 0; i < 100; i++) {
                simulateGeneration();
            }
            updateVisuals();
        });

        // Animation loop
        let lastUpdate = 0;
        function animate(time) {
            // Simulate every 100ms
            if (time - lastUpdate > 100) {
                simulateGeneration();
                if (generation % 10 === 0) updateVisuals();
                lastUpdate = time;
            }

            drawOcean(time);
            drawChart();
            updateStats();

            requestAnimationFrame(animate);
        }

        // Initialize
        initSimulation();
        animate(0);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
