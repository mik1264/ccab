<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holographic Principle: 3D from 2D | Surprising Paradoxes</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #000508 0%, #050815 50%, #000510 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #aa88ff;
            text-decoration: none;
            font-size: 1rem;
            z-index: 100;
            padding: 8px 16px;
            background: rgba(0,0,0,0.5);
            border-radius: 20px;
            transition: all 0.3s ease;
        }
        .back-link:hover {
            background: rgba(150, 100, 255, 0.2);
            transform: translateX(-3px);
        }
        header {
            text-align: center;
            padding: 80px 20px 30px;
        }
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #8866ff, #aa88ff, #ddbbff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle {
            color: #8877aa;
            font-size: 1.2rem;
            max-width: 700px;
            margin: 0 auto;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        .demo-section {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 30px;
            margin-bottom: 40px;
        }
        @media (max-width: 900px) {
            .demo-section {
                grid-template-columns: 1fr;
            }
        }
        .canvas-container {
            background: linear-gradient(145deg, #000508, #050815);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(100,50,200,0.2);
        }
        canvas {
            display: block;
            width: 100%;
            border-radius: 10px;
        }
        .controls {
            background: linear-gradient(145deg, #050810, #0a0c18);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(100,50,200,0.2);
        }
        .info-display {
            text-align: center;
            padding: 15px;
            background: rgba(100, 80, 200, 0.15);
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .info-display .main-stat {
            font-size: 1.3rem;
            font-weight: bold;
            color: #aa88ff;
            margin-bottom: 5px;
        }
        .info-display .sub-stat {
            font-size: 0.85rem;
            color: #8877aa;
        }
        .concept-box {
            background: rgba(80, 50, 150, 0.15);
            border: 1px solid rgba(150, 100, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .concept-box h3 {
            color: #aa88ff;
            font-size: 0.95rem;
            margin-bottom: 10px;
        }
        .concept-box p {
            font-size: 0.85rem;
            color: #9988aa;
            line-height: 1.5;
        }
        .equation {
            text-align: center;
            padding: 15px;
            background: rgba(50, 30, 80, 0.3);
            border-radius: 8px;
            margin-bottom: 15px;
            font-family: 'Times New Roman', serif;
            font-size: 1.2rem;
            color: #ccaaff;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #aa88ff;
            font-size: 0.9rem;
        }
        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #0a0c18;
            outline: none;
            -webkit-appearance: none;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #aa88ff, #7755cc);
            cursor: pointer;
        }
        .value-display {
            text-align: right;
            font-size: 0.85rem;
            color: #aaa;
            margin-top: 5px;
        }
        button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #7755cc, #5533aa);
            color: white;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }
        button:hover {
            background: linear-gradient(135deg, #9977ee, #7755cc);
            transform: translateY(-2px);
        }
        button.active {
            background: linear-gradient(135deg, #aa88ff, #8866dd);
            box-shadow: 0 0 15px rgba(150, 100, 255, 0.4);
        }
        .view-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }
        .view-buttons button {
            padding: 10px;
            font-size: 0.85rem;
        }
        .essay {
            background: linear-gradient(145deg, #000508, #050815);
            border-radius: 15px;
            padding: 40px;
            line-height: 1.8;
            box-shadow: 0 10px 40px rgba(100,50,200,0.2);
        }
        .essay h2 {
            color: #aa88ff;
            margin: 30px 0 15px;
            font-size: 1.5rem;
        }
        .essay h2:first-child { margin-top: 0; }
        .essay p {
            margin-bottom: 15px;
            color: #b8b0c8;
        }
        .essay strong { color: #ddbbff; }
        .essay em { color: #ffcc88; font-style: italic; }
        .highlight-box {
            background: rgba(100, 50, 200, 0.1);
            border-left: 4px solid #aa88ff;
            padding: 20px;
            margin: 25px 0;
            border-radius: 0 10px 10px 0;
        }
        .highlight-box.paradox {
            background: rgba(150, 80, 255, 0.08);
            border-left-color: #cc99ff;
        }
        .formula {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 20px 0;
            font-family: 'Times New Roman', serif;
            font-size: 1.3rem;
            color: #ccaaff;
        }
        .sources {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #1a1525;
        }
        .sources h3 {
            color: #8877aa;
            margin-bottom: 15px;
        }
        .sources ul {
            list-style: none;
        }
        .sources li {
            margin-bottom: 10px;
        }
        .sources a {
            color: #7766aa;
            text-decoration: none;
        }
        .sources a:hover {
            color: #aa88ff;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Paradoxes</a>

    <header>
        <h1>The Holographic Principle</h1>
        <p class="subtitle">Is our 3D universe encoded on a 2D boundary? Black holes suggest yes.</p>
    </header>

    <div class="container">
        <div class="demo-section">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
            </div>
            <div class="controls">
                <div class="info-display">
                    <div class="main-stat" id="infoMain">3D Volume → 2D Surface</div>
                    <div class="sub-stat" id="infoSub">Information lives on the boundary</div>
                </div>

                <div class="equation">
                    S = A / 4ℓ<sub>P</sub>²
                </div>

                <div class="concept-box">
                    <h3>Bekenstein-Hawking Entropy</h3>
                    <p>Black hole entropy equals surface area divided by 4 Planck lengths squared—not proportional to volume! All 3D information is encoded on the 2D horizon.</p>
                </div>

                <div class="view-buttons">
                    <button id="blackHoleView" class="active">Black Hole</button>
                    <button id="boundaryView">Boundary</button>
                    <button id="adsView">AdS/CFT</button>
                    <button id="universeView">Universe</button>
                </div>

                <div class="control-group">
                    <label>Rotation Speed</label>
                    <input type="range" id="rotSpeed" min="0" max="2" value="1" step="0.1">
                    <div class="value-display" id="rotDisplay">1.0×</div>
                </div>

                <div class="control-group">
                    <label>Information Density</label>
                    <input type="range" id="density" min="20" max="100" value="50" step="5">
                    <div class="value-display" id="densityDisplay">50 bits</div>
                </div>

                <button id="toggleProjection">Toggle Projection Lines</button>
            </div>
        </div>

        <div class="essay">
            <h2>The Most Radical Idea in Physics</h2>
            <p>
                Imagine discovering that a movie screen isn't just displaying a flat image—it
                somehow <em>contains</em> the entire 3D world you thought you were watching.
                The holographic principle suggests something similar about our universe:
                <strong>all the information in a 3D region may be encoded on its 2D boundary</strong>.
            </p>

            <div class="highlight-box paradox">
                <strong>The Paradox:</strong> Volume grows as r³. Surface area grows as r².
                Surely a larger volume can contain more information? Yet black hole physics
                says no—maximum information scales with area, not volume. Our intuition about
                space is fundamentally wrong.
            </div>

            <h2>Black Holes: Nature's Hard Drives</h2>
            <p>
                The principle emerged from an unexpected place: black holes. Jacob Bekenstein
                showed in 1972 that black holes have entropy, and Stephen Hawking calculated
                in 1974 that this entropy is:
            </p>

            <div class="formula">
                S<sub>BH</sub> = (kc³/4Għ) × A = A / (4ℓ<sub>P</sub>²)
            </div>

            <p>
                Here's the shock: entropy (information content) is proportional to the
                <strong>surface area</strong> of the event horizon—not the volume. A black
                hole twice as wide doesn't hold 8× the information (as volume would suggest)
                but only 4× (as area gives).
            </p>

            <h2>'t Hooft and Susskind's Insight</h2>
            <p>
                In 1993, Gerard 't Hooft proposed that quantum gravity in any region can be
                described by a theory living on the region's boundary. Leonard Susskind
                developed this further and named it the <strong>holographic principle</strong>:
                like a hologram that encodes 3D information on a 2D film, the physics of a
                volume can be fully captured by degrees of freedom on its surface.
            </p>
            <p>
                This isn't saying the universe is "fake" or an illusion. Rather, there exists
                a <em>mathematical equivalence</em> between a theory with gravity in the bulk
                and a theory without gravity on the boundary. Both descriptions are equally valid.
            </p>

            <div class="highlight-box">
                <strong>The Bound:</strong> The maximum information content of any region is
                approximately one bit per Planck area (ℓ<sub>P</sub>² ≈ 10⁻⁷⁰ m²) of its
                boundary. Pack more information in, and you'd form a black hole. The boundary
                imposes a fundamental limit on bulk complexity.
            </div>

            <h2>AdS/CFT: Holography Made Precise</h2>
            <p>
                In 1997, Juan Maldacena discovered a stunning example: the <strong>AdS/CFT
                correspondence</strong>. He showed that string theory with gravity in a
                5-dimensional Anti-de Sitter space is exactly equivalent to a 4-dimensional
                quantum field theory (without gravity) on the boundary.
            </p>
            <p>
                This is the holographic principle made mathematically rigorous. Calculations
                in one theory can be translated to the other. Hard problems in one description
                may become easy in the dual description. This tool has revolutionized theoretical
                physics, connecting gravity, quantum mechanics, and even condensed matter physics.
            </p>

            <h2>Implications for Reality</h2>
            <p>
                <strong>Information paradox resolution:</strong> When things fall into black
                holes, is their information destroyed? Holography suggests no—information is
                encoded on the horizon and eventually radiated out via Hawking radiation.
            </p>
            <p>
                <strong>Emergent spacetime:</strong> If boundary physics fully describes bulk
                physics, perhaps spacetime itself is not fundamental but <em>emerges</em> from
                quantum entanglement on the boundary. Space might be "woven" from quantum information.
            </p>
            <p>
                <strong>Our universe?</strong> Our universe has a cosmological horizon—a surface
                beyond which light will never reach us. Could our universe's physics be encoded
                on this cosmic horizon? The holographic principle suggests this is possible,
                though the technical details differ from AdS/CFT.
            </p>

            <h2>Not Science Fiction</h2>
            <p>
                The holographic principle isn't speculative philosophy—it's backed by rigorous
                mathematics and has passed numerous consistency checks. While we can't yet
                test it experimentally (Planck-scale physics is far beyond current technology),
                the theoretical evidence is compelling enough that most string theorists and
                quantum gravity researchers take it seriously.
            </p>

            <div class="sources">
                <h3>Sources & Further Reading</h3>
                <ul>
                    <li><a href="https://en.wikipedia.org/wiki/Holographic_principle">Wikipedia: Holographic Principle</a></li>
                    <li><a href="https://en.wikipedia.org/wiki/AdS/CFT_correspondence">Wikipedia: AdS/CFT Correspondence</a></li>
                    <li><a href="https://en.wikipedia.org/wiki/Black_hole_information_paradox">Wikipedia: Black Hole Information Paradox</a></li>
                    <li>Susskind, L. "The World as a Hologram" (1994) arXiv:hep-th/9409089</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // High DPI setup
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.width * 0.8 * dpr;
        canvas.style.height = rect.width * 0.8 + 'px';
        ctx.scale(dpr, dpr);

        const width = rect.width;
        const height = rect.width * 0.8;
        const centerX = width / 2;
        const centerY = height / 2;

        // State
        let time = 0;
        let rotationSpeed = 1;
        let infoDensity = 50;
        let currentView = 'blackHole';
        let showProjection = true;

        // Controls
        const rotSlider = document.getElementById('rotSpeed');
        const densitySlider = document.getElementById('density');
        const toggleBtn = document.getElementById('toggleProjection');

        const viewButtons = {
            blackHole: document.getElementById('blackHoleView'),
            boundary: document.getElementById('boundaryView'),
            ads: document.getElementById('adsView'),
            universe: document.getElementById('universeView')
        };

        rotSlider.addEventListener('input', e => {
            rotationSpeed = parseFloat(e.target.value);
            document.getElementById('rotDisplay').textContent = rotationSpeed.toFixed(1) + '×';
        });

        densitySlider.addEventListener('input', e => {
            infoDensity = parseInt(e.target.value);
            document.getElementById('densityDisplay').textContent = infoDensity + ' bits';
        });

        toggleBtn.addEventListener('click', () => {
            showProjection = !showProjection;
            toggleBtn.classList.toggle('active', showProjection);
        });

        Object.keys(viewButtons).forEach(key => {
            viewButtons[key].addEventListener('click', () => {
                currentView = key;
                Object.values(viewButtons).forEach(b => b.classList.remove('active'));
                viewButtons[key].classList.add('active');
                updateInfo();
            });
        });

        function updateInfo() {
            const info = document.getElementById('infoMain');
            const sub = document.getElementById('infoSub');

            switch(currentView) {
                case 'blackHole':
                    info.textContent = 'S = A / 4ℓₚ²';
                    sub.textContent = 'Entropy scales with area, not volume';
                    break;
                case 'boundary':
                    info.textContent = 'Bulk ↔ Boundary';
                    sub.textContent = '3D physics encoded on 2D surface';
                    break;
                case 'ads':
                    info.textContent = 'AdS₅ ↔ CFT₄';
                    sub.textContent = 'Gravity = Quantum Field Theory';
                    break;
                case 'universe':
                    info.textContent = 'Cosmic Horizon';
                    sub.textContent = 'Is our universe a hologram?';
                    break;
            }
        }

        function drawBlackHoleView() {
            // Black hole at center
            const bhRadius = 80;

            // Event horizon
            const horizonGrad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, bhRadius);
            horizonGrad.addColorStop(0, '#000');
            horizonGrad.addColorStop(0.8, '#000');
            horizonGrad.addColorStop(1, 'rgba(100, 50, 150, 0.5)');

            ctx.fillStyle = horizonGrad;
            ctx.beginPath();
            ctx.arc(centerX, centerY, bhRadius, 0, Math.PI * 2);
            ctx.fill();

            // Horizon glow
            ctx.strokeStyle = 'rgba(150, 100, 255, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, bhRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Information bits on horizon
            for (let i = 0; i < infoDensity; i++) {
                const angle = (i / infoDensity) * Math.PI * 2 + time * 0.02 * rotationSpeed;
                const x = centerX + Math.cos(angle) * bhRadius;
                const y = centerY + Math.sin(angle) * bhRadius;

                // Bit indicator
                const bitValue = Math.sin(i * 0.5 + time * 0.05) > 0;
                ctx.fillStyle = bitValue ? 'rgba(255, 200, 100, 0.9)' : 'rgba(100, 200, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();

                // Projection lines to interior (if enabled)
                if (showProjection && i % 5 === 0) {
                    const innerR = Math.random() * bhRadius * 0.8;
                    const innerAngle = angle + (Math.random() - 0.5) * 0.5;
                    const innerX = centerX + Math.cos(innerAngle) * innerR;
                    const innerY = centerY + Math.sin(innerAngle) * innerR;

                    ctx.strokeStyle = `rgba(150, 100, 255, ${0.3 * (1 - innerR / bhRadius)})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(innerX, innerY);
                    ctx.stroke();
                }
            }

            // Infalling matter
            for (let i = 0; i < 5; i++) {
                const angle = (time * 0.03 + i * Math.PI * 0.4) * rotationSpeed;
                const dist = 150 - ((time * 0.5 + i * 30) % 100);

                if (dist > bhRadius) {
                    const x = centerX + Math.cos(angle) * dist;
                    const y = centerY + Math.sin(angle) * dist;

                    ctx.fillStyle = 'rgba(200, 150, 100, 0.7)';
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Spiral trajectory
                    ctx.strokeStyle = 'rgba(200, 150, 100, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    for (let t = 0; t < 20; t++) {
                        const tAngle = angle - t * 0.1;
                        const tDist = dist + t * 3;
                        const tx = centerX + Math.cos(tAngle) * Math.min(tDist, 200);
                        const ty = centerY + Math.sin(tAngle) * Math.min(tDist, 200);
                        if (t === 0) ctx.moveTo(tx, ty);
                        else ctx.lineTo(tx, ty);
                    }
                    ctx.stroke();
                }
            }

            // Labels
            ctx.fillStyle = '#aa88ff';
            ctx.font = '14px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText('Event Horizon', centerX, centerY + bhRadius + 25);
            ctx.fillText('(Information encoded here)', centerX, centerY + bhRadius + 42);

            ctx.fillStyle = '#666';
            ctx.fillText('Interior', centerX, centerY);
        }

        function drawBoundaryView() {
            // 3D cube representation
            const cubeSize = 100;
            const perspective = 0.4;

            // Back face (boundary)
            ctx.fillStyle = 'rgba(100, 80, 150, 0.3)';
            ctx.strokeStyle = 'rgba(150, 100, 255, 0.8)';
            ctx.lineWidth = 2;

            const offset = cubeSize * perspective;

            // Back face
            ctx.beginPath();
            ctx.moveTo(centerX - cubeSize + offset, centerY - cubeSize - offset);
            ctx.lineTo(centerX + cubeSize + offset, centerY - cubeSize - offset);
            ctx.lineTo(centerX + cubeSize + offset, centerY + cubeSize - offset);
            ctx.lineTo(centerX - cubeSize + offset, centerY + cubeSize - offset);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Draw information bits on back face (boundary)
            for (let i = 0; i < infoDensity; i++) {
                const row = Math.floor(i / Math.sqrt(infoDensity));
                const col = i % Math.floor(Math.sqrt(infoDensity));
                const spacing = cubeSize * 2 / Math.sqrt(infoDensity);

                const bx = centerX - cubeSize + offset + col * spacing + spacing / 2;
                const by = centerY - cubeSize - offset + row * spacing + spacing / 2;

                const bitValue = Math.sin(i * 0.3 + time * 0.03) > 0;
                ctx.fillStyle = bitValue ? 'rgba(255, 200, 100, 0.8)' : 'rgba(100, 200, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(bx, by, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Front face (transparent, showing bulk)
            ctx.strokeStyle = 'rgba(100, 80, 150, 0.5)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);

            ctx.beginPath();
            ctx.moveTo(centerX - cubeSize, centerY - cubeSize);
            ctx.lineTo(centerX + cubeSize, centerY - cubeSize);
            ctx.lineTo(centerX + cubeSize, centerY + cubeSize);
            ctx.lineTo(centerX - cubeSize, centerY + cubeSize);
            ctx.closePath();
            ctx.stroke();

            ctx.setLineDash([]);

            // Connecting edges
            ctx.strokeStyle = 'rgba(100, 80, 150, 0.3)';
            ctx.beginPath();
            ctx.moveTo(centerX - cubeSize, centerY - cubeSize);
            ctx.lineTo(centerX - cubeSize + offset, centerY - cubeSize - offset);
            ctx.moveTo(centerX + cubeSize, centerY - cubeSize);
            ctx.lineTo(centerX + cubeSize + offset, centerY - cubeSize - offset);
            ctx.moveTo(centerX + cubeSize, centerY + cubeSize);
            ctx.lineTo(centerX + cubeSize + offset, centerY + cubeSize - offset);
            ctx.moveTo(centerX - cubeSize, centerY + cubeSize);
            ctx.lineTo(centerX - cubeSize + offset, centerY + cubeSize - offset);
            ctx.stroke();

            // Objects in bulk
            if (showProjection) {
                for (let i = 0; i < 5; i++) {
                    const x = centerX + (Math.sin(i * 1.5 + time * 0.02) * 0.5) * cubeSize;
                    const y = centerY + (Math.cos(i * 2.1 + time * 0.015) * 0.5) * cubeSize;

                    ctx.fillStyle = 'rgba(255, 150, 100, 0.7)';
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fill();

                    // Projection to boundary
                    const bx = x + offset;
                    const by = y - offset - cubeSize * 0.7;

                    ctx.strokeStyle = 'rgba(150, 100, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(bx, by);
                    ctx.stroke();
                }
            }

            // Labels
            ctx.fillStyle = '#aa88ff';
            ctx.font = '14px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText('2D Boundary', centerX + offset, centerY - cubeSize - offset - 20);
            ctx.fillText('(All information)', centerX + offset, centerY - cubeSize - offset - 5);

            ctx.fillStyle = '#888';
            ctx.fillText('3D Bulk', centerX, centerY + cubeSize + 30);
            ctx.fillText('(Emergent)', centerX, centerY + cubeSize + 45);
        }

        function drawAdsView() {
            // Anti-de Sitter space representation
            const outerRadius = 150;

            // Boundary circle (CFT lives here)
            ctx.strokeStyle = 'rgba(150, 100, 255, 0.9)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(centerX, centerY, outerRadius, 0, Math.PI * 2);
            ctx.stroke();

            // AdS bulk (hyperbolic geometry - concentric circles getting denser toward center)
            for (let r = outerRadius - 20; r > 10; r -= 20) {
                const alpha = 0.1 + 0.2 * (1 - r / outerRadius);
                ctx.strokeStyle = `rgba(80, 60, 120, ${alpha})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Geodesics in AdS (appear curved)
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
            ctx.lineWidth = 2;

            for (let i = 0; i < 6; i++) {
                const startAngle = i * Math.PI / 3 + time * 0.01 * rotationSpeed;
                const endAngle = startAngle + Math.PI;

                ctx.beginPath();
                for (let t = 0; t <= 1; t += 0.02) {
                    const angle = startAngle + t * Math.PI;
                    const r = outerRadius * Math.sin(t * Math.PI);
                    const x = centerX + Math.cos(angle) * (outerRadius - r * 0.7);
                    const y = centerY + Math.sin(angle) * (outerRadius - r * 0.7);
                    if (t === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // CFT degrees of freedom on boundary
            for (let i = 0; i < infoDensity; i++) {
                const angle = (i / infoDensity) * Math.PI * 2 + time * 0.02 * rotationSpeed;
                const x = centerX + Math.cos(angle) * outerRadius;
                const y = centerY + Math.sin(angle) * outerRadius;

                ctx.fillStyle = `hsl(${(i * 7 + time) % 360}, 70%, 60%)`;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Labels
            ctx.fillStyle = '#aa88ff';
            ctx.font = '14px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText('CFT (Quantum Field Theory)', centerX, 30);
            ctx.fillText('No gravity, lives on boundary', centerX, 48);

            ctx.fillStyle = '#6688aa';
            ctx.fillText('AdS (String Theory + Gravity)', centerX, centerY);
            ctx.fillText('Lives in bulk', centerX, centerY + 18);

            ctx.fillStyle = '#ff88aa';
            ctx.font = 'bold 16px Segoe UI';
            ctx.fillText('≡', centerX + outerRadius + 30, centerY);
            ctx.font = '12px Segoe UI';
            ctx.fillText('DUAL', centerX + outerRadius + 30, centerY + 18);
        }

        function drawUniverseView() {
            // Cosmic horizon view

            // Distant horizon
            const horizonRadius = 160;
            const horizonGrad = ctx.createRadialGradient(centerX, centerY, horizonRadius * 0.8, centerX, centerY, horizonRadius);
            horizonGrad.addColorStop(0, 'transparent');
            horizonGrad.addColorStop(0.8, 'rgba(100, 80, 150, 0.2)');
            horizonGrad.addColorStop(1, 'rgba(150, 100, 200, 0.5)');

            ctx.fillStyle = horizonGrad;
            ctx.beginPath();
            ctx.arc(centerX, centerY, horizonRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = 'rgba(150, 100, 255, 0.6)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Galaxies in observable universe
            for (let i = 0; i < 30; i++) {
                const seed = i * 1234.567;
                const r = 20 + (seed % (horizonRadius - 40));
                const angle = (seed * 2.3) % (Math.PI * 2) + time * 0.005 * rotationSpeed;

                const x = centerX + Math.cos(angle) * r;
                const y = centerY + Math.sin(angle) * r;

                // Galaxy
                ctx.fillStyle = `rgba(${200 + (seed % 55)}, ${180 + (seed * 1.3 % 60)}, ${220}, 0.7)`;
                ctx.beginPath();
                ctx.arc(x, y, 2 + (seed % 3), 0, Math.PI * 2);
                ctx.fill();
            }

            // Observer at center
            ctx.fillStyle = '#ffcc88';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
            ctx.fill();

            // Light rays from horizon
            if (showProjection) {
                for (let i = 0; i < 12; i++) {
                    const angle = i * Math.PI / 6 + time * 0.01;
                    const hx = centerX + Math.cos(angle) * horizonRadius;
                    const hy = centerY + Math.sin(angle) * horizonRadius;

                    ctx.strokeStyle = 'rgba(255, 200, 100, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(hx, hy);
                    ctx.lineTo(centerX, centerY);
                    ctx.stroke();
                }
            }

            // Information on cosmological horizon
            for (let i = 0; i < infoDensity / 2; i++) {
                const angle = (i / (infoDensity / 2)) * Math.PI * 2 + time * 0.01 * rotationSpeed;
                const x = centerX + Math.cos(angle) * horizonRadius;
                const y = centerY + Math.sin(angle) * horizonRadius;

                ctx.fillStyle = 'rgba(200, 150, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Labels
            ctx.fillStyle = '#aa88ff';
            ctx.font = '14px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText('Cosmological Horizon', centerX, 25);
            ctx.fillText('(Information boundary?)', centerX, 42);

            ctx.fillStyle = '#ffcc88';
            ctx.fillText('You', centerX, centerY + 25);

            ctx.fillStyle = '#888';
            ctx.fillText('Observable Universe', centerX, height - 20);
        }

        function animate() {
            // Clear
            ctx.fillStyle = '#000508';
            ctx.fillRect(0, 0, width, height);

            // Draw based on current view
            switch(currentView) {
                case 'blackHole':
                    drawBlackHoleView();
                    break;
                case 'boundary':
                    drawBoundaryView();
                    break;
                case 'ads':
                    drawAdsView();
                    break;
                case 'universe':
                    drawUniverseView();
                    break;
            }

            time++;
            requestAnimationFrame(animate);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.width * 0.8 * dpr;
            canvas.style.height = rect.width * 0.8 + 'px';
            ctx.scale(dpr, dpr);
        });

        updateInfo();
        animate();
    </script>
</body>
</html>
