<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Coastline Paradox - Infinite Lengths | Surprising Paradoxes #653</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a1628 0%, #1a3a5c 50%, #0d2847 100%);
            min-height: 100vh;
            color: #e0e7ff;
            overflow-x: hidden;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #60a5fa;
            text-decoration: none;
            font-size: 0.9rem;
            z-index: 100;
            padding: 8px 16px;
            background: rgba(0,0,0,0.4);
            border-radius: 20px;
            transition: all 0.3s;
        }
        .back-link:hover { background: rgba(96,165,250,0.2); }

        header {
            text-align: center;
            padding: 60px 20px 30px;
        }
        h1 {
            font-size: 2.8rem;
            background: linear-gradient(135deg, #60a5fa, #34d399);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        .subtitle {
            color: #94a3b8;
            font-size: 1.2rem;
            max-width: 700px;
            margin: 0 auto;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px 40px;
        }

        .hook {
            background: linear-gradient(135deg, rgba(239,68,68,0.2), rgba(249,115,22,0.2));
            border: 2px solid rgba(239,68,68,0.4);
            border-radius: 16px;
            padding: 25px;
            text-align: center;
            margin-bottom: 30px;
        }
        .hook h2 {
            font-size: 1.6rem;
            color: #f87171;
            margin-bottom: 10px;
        }
        .hook p {
            color: #fca5a5;
            font-size: 1.1rem;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
        }

        .visualization {
            background: rgba(15,23,42,0.8);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(96,165,250,0.2);
        }

        #coastCanvas {
            width: 100%;
            border-radius: 12px;
            background: #0f172a;
            cursor: crosshair;
        }

        .controls-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel {
            background: rgba(15,23,42,0.8);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(96,165,250,0.2);
        }

        .panel h3 {
            color: #60a5fa;
            font-size: 1.1rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ruler-control {
            margin-bottom: 20px;
        }
        .ruler-control label {
            display: block;
            color: #94a3b8;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        .ruler-display {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .ruler-display input[type="range"] {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #ef4444, #f59e0b, #22c55e);
            border-radius: 4px;
            cursor: pointer;
        }
        .ruler-display input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        .ruler-value {
            background: rgba(96,165,250,0.2);
            padding: 8px 15px;
            border-radius: 8px;
            font-weight: 600;
            color: #60a5fa;
            min-width: 80px;
            text-align: center;
        }

        .measurements {
            display: grid;
            gap: 15px;
        }
        .measurement-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: rgba(30,41,59,0.5);
            border-radius: 8px;
        }
        .measurement-row .label {
            color: #94a3b8;
            font-size: 0.9rem;
        }
        .measurement-row .value {
            font-weight: 700;
            font-size: 1.2rem;
        }
        .value.length { color: #34d399; }
        .value.segments { color: #f59e0b; }
        .value.ratio { color: #f87171; }

        .history-panel {
            max-height: 250px;
            overflow-y: auto;
        }
        .history-entry {
            display: grid;
            grid-template-columns: 60px 1fr 80px;
            gap: 10px;
            padding: 10px;
            background: rgba(30,41,59,0.3);
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 0.85rem;
            align-items: center;
        }
        .history-entry .ruler-size {
            color: #60a5fa;
            font-weight: 600;
        }
        .history-entry .length-bar {
            height: 8px;
            background: linear-gradient(90deg, #34d399, #22c55e);
            border-radius: 4px;
            transition: width 0.3s;
        }
        .history-entry .length-val {
            text-align: right;
            color: #34d399;
            font-weight: 600;
        }

        .explanation {
            margin-top: 30px;
        }
        .explanation-card {
            background: rgba(15,23,42,0.8);
            border-radius: 16px;
            padding: 25px;
            border: 1px solid rgba(96,165,250,0.2);
            margin-bottom: 20px;
        }
        .explanation-card h3 {
            color: #60a5fa;
            margin-bottom: 15px;
        }
        .explanation-card p {
            color: #94a3b8;
            line-height: 1.8;
            margin-bottom: 12px;
        }

        .formula {
            background: rgba(30,41,59,0.5);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
        }
        .formula .main {
            font-size: 1.4rem;
            color: #60a5fa;
            margin-bottom: 8px;
        }
        .formula .desc {
            font-size: 0.9rem;
            color: #94a3b8;
        }

        .fractal-dimension {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(96,165,250,0.1), rgba(52,211,153,0.1));
            border-radius: 12px;
            margin-top: 15px;
        }
        .dimension-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: #60a5fa;
        }
        .dimension-label {
            color: #94a3b8;
            font-size: 0.9rem;
        }
        .dimension-meaning {
            text-align: left;
        }
        .dimension-meaning p {
            margin: 0;
            color: #cbd5e1;
        }

        .coastline-selector {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        .coastline-btn {
            padding: 8px 16px;
            background: rgba(30,41,59,0.5);
            border: 1px solid rgba(96,165,250,0.3);
            border-radius: 8px;
            color: #94a3b8;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        .coastline-btn:hover {
            background: rgba(96,165,250,0.2);
            color: #60a5fa;
        }
        .coastline-btn.active {
            background: rgba(96,165,250,0.3);
            border-color: #60a5fa;
            color: #60a5fa;
        }

        .btn-measure {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #34d399, #22c55e);
            border: none;
            border-radius: 10px;
            color: #0f172a;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 15px;
        }
        .btn-measure:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(52,211,153,0.3);
        }

        .btn-animate {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #f59e0b, #ef4444);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: 700;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }
        .btn-animate:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(239,68,68,0.3);
        }

        .comparison {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }
        .compare-card {
            background: rgba(30,41,59,0.5);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        .compare-card .country {
            color: #60a5fa;
            font-weight: 600;
            margin-bottom: 5px;
        }
        .compare-card .dim {
            font-size: 1.5rem;
            font-weight: 700;
            color: #34d399;
        }
        .compare-card .label {
            font-size: 0.75rem;
            color: #64748b;
        }

        @media (max-width: 1000px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            h1 { font-size: 2rem; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <header>
        <h1>The Coastline Paradox</h1>
        <p class="subtitle">The closer you look, the longer it gets. Coastlines have no definite length!</p>
    </header>

    <div class="container">
        <div class="hook">
            <h2>HOW LONG IS BRITAIN'S COASTLINE?</h2>
            <p>It depends on your ruler! With 100km rulers: ~2,800km. With 50km: ~3,500km. With 1km: ~8,000km+. Smaller rulers reveal more detail... forever!</p>
        </div>

        <div class="main-grid">
            <div class="visualization">
                <canvas id="coastCanvas" width="800" height="600"></canvas>
            </div>

            <div class="controls-panel">
                <div class="panel">
                    <h3>Select Coastline</h3>
                    <div class="coastline-selector">
                        <button class="coastline-btn active" data-type="koch">Koch Coast</button>
                        <button class="coastline-btn" data-type="britain">Britain-like</button>
                        <button class="coastline-btn" data-type="norway">Norway Fjords</button>
                        <button class="coastline-btn" data-type="smooth">Smooth Bay</button>
                    </div>

                    <div class="ruler-control">
                        <label>Ruler Size (smaller = more detail)</label>
                        <div class="ruler-display">
                            <input type="range" id="rulerSize" min="5" max="100" value="50">
                            <span class="ruler-value" id="rulerDisplay">50 km</span>
                        </div>
                    </div>

                    <button class="btn-measure" id="measureBtn">Measure Coastline</button>
                    <button class="btn-animate" id="animateBtn">Animate: Watch Length Grow!</button>
                </div>

                <div class="panel">
                    <h3>Current Measurement</h3>
                    <div class="measurements">
                        <div class="measurement-row">
                            <span class="label">Total Length</span>
                            <span class="value length" id="totalLength">--</span>
                        </div>
                        <div class="measurement-row">
                            <span class="label">Segments Used</span>
                            <span class="value segments" id="segmentCount">--</span>
                        </div>
                        <div class="measurement-row">
                            <span class="label">vs. Initial</span>
                            <span class="value ratio" id="lengthRatio">--</span>
                        </div>
                    </div>
                </div>

                <div class="panel history-panel">
                    <h3>Measurement History</h3>
                    <div id="historyContainer"></div>
                </div>
            </div>
        </div>

        <div class="explanation">
            <div class="explanation-card">
                <h3>Richardson's Discovery (1951)</h3>
                <p>Mathematician Lewis Fry Richardson was studying whether shared border length correlates with war probability. He found Spain reported its border with Portugal as 987 km, but Portugal reported 1,214 km!</p>
                <p>The discrepancy wasn't an error - it was a fundamental truth about measurement. Smaller rulers follow more of the coastline's twists and turns, yielding longer measurements.</p>
                <div class="formula">
                    <div class="main">L(s) = F &middot; s<sup>1-D</sup></div>
                    <div class="desc">Length L grows as ruler size s shrinks. D is the fractal dimension.</div>
                </div>
            </div>

            <div class="explanation-card">
                <h3>Mandelbrot's Fractal Dimension</h3>
                <p>In 1967, Benoit Mandelbrot asked "How Long Is the Coast of Britain?" and introduced the concept of fractal dimension. Coastlines aren't 1D lines or 2D areas - they're somewhere in between!</p>

                <div class="fractal-dimension">
                    <div>
                        <div class="dimension-value" id="fractalDim">1.25</div>
                        <div class="dimension-label">Fractal Dimension</div>
                    </div>
                    <div class="dimension-meaning">
                        <p><strong>D = 1:</strong> Smooth line (finite length)</p>
                        <p><strong>D = 2:</strong> Space-filling curve</p>
                        <p><strong>D ~ 1.25:</strong> Britain's jagged coast</p>
                    </div>
                </div>

                <div class="comparison">
                    <div class="compare-card">
                        <div class="country">South Africa</div>
                        <div class="dim">1.02</div>
                        <div class="label">Smooth coast</div>
                    </div>
                    <div class="compare-card">
                        <div class="country">Britain</div>
                        <div class="dim">1.25</div>
                        <div class="label">Jagged coast</div>
                    </div>
                    <div class="compare-card">
                        <div class="country">Norway</div>
                        <div class="dim">1.52</div>
                        <div class="label">Deep fjords</div>
                    </div>
                </div>
            </div>

            <div class="explanation-card">
                <h3>The Paradox</h3>
                <p><strong>Mathematically:</strong> As ruler size approaches zero, the measured length approaches infinity. Coastlines have no "true" length!</p>
                <p><strong>Practically:</strong> Different countries measure at different scales, leading to different answers - all technically correct.</p>
                <p><strong>The lesson:</strong> Nature doesn't obey Euclidean geometry. Fractals are everywhere: coastlines, mountain ranges, blood vessels, tree branches, lightning bolts...</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('coastCanvas');
        const ctx = canvas.getContext('2d');
        const rulerSlider = document.getElementById('rulerSize');
        const rulerDisplay = document.getElementById('rulerDisplay');
        const measureBtn = document.getElementById('measureBtn');
        const animateBtn = document.getElementById('animateBtn');
        const totalLengthEl = document.getElementById('totalLength');
        const segmentCountEl = document.getElementById('segmentCount');
        const lengthRatioEl = document.getElementById('lengthRatio');
        const historyContainer = document.getElementById('historyContainer');
        const fractalDimEl = document.getElementById('fractalDim');

        let coastPoints = [];
        let measurements = [];
        let initialLength = null;
        let currentCoastType = 'koch';
        let isAnimating = false;
        let animationFrame = null;

        const fractalDims = {
            koch: 1.26,
            britain: 1.25,
            norway: 1.52,
            smooth: 1.05
        };

        // Generate Koch-like coastline
        function generateKochCoast(iterations = 4) {
            let points = [
                { x: 50, y: 450 },
                { x: 750, y: 450 }
            ];

            for (let iter = 0; iter < iterations; iter++) {
                const newPoints = [];
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;

                    const a = { x: p1.x + dx / 3, y: p1.y + dy / 3 };
                    const b = { x: p1.x + dx * 2 / 3, y: p1.y + dy * 2 / 3 };

                    // Peak point (perpendicular)
                    const midX = (a.x + b.x) / 2;
                    const midY = (a.y + b.y) / 2;
                    const len = Math.sqrt(dx * dx + dy * dy) / 3;
                    const perpX = -dy / Math.sqrt(dx * dx + dy * dy);
                    const perpY = dx / Math.sqrt(dx * dx + dy * dy);

                    // Randomize direction a bit
                    const dir = (Math.random() > 0.3) ? 1 : -1;
                    const height = len * Math.sqrt(3) / 2 * dir * (0.8 + Math.random() * 0.4);

                    const peak = {
                        x: midX + perpX * height,
                        y: midY + perpY * height
                    };

                    newPoints.push(p1, a, peak, b);
                }
                newPoints.push(points[points.length - 1]);
                points = newPoints;
            }

            return points;
        }

        // Generate Britain-like coast
        function generateBritainCoast() {
            const points = [];
            const numPoints = 200;

            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const baseX = 100 + t * 600;
                let baseY = 300;

                // Multiple frequency noise
                let noise = 0;
                noise += Math.sin(t * 20) * 30;
                noise += Math.sin(t * 50 + 1) * 15;
                noise += Math.sin(t * 100 + 2) * 8;
                noise += Math.sin(t * 200 + 3) * 4;
                noise += (Math.random() - 0.5) * 20;

                points.push({ x: baseX, y: baseY + noise });
            }

            return points;
        }

        // Generate Norway fjord coast
        function generateNorwayCoast() {
            const points = [];
            const numPoints = 300;

            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const baseX = 100 + t * 600;
                let baseY = 300;

                // Deep fjord-like indentations
                let noise = 0;
                noise += Math.sin(t * 15) * 60;
                noise += Math.sin(t * 30 + 0.5) * 40;
                noise += Math.sin(t * 60 + 1) * 25;
                noise += Math.sin(t * 120 + 2) * 15;
                noise += Math.sin(t * 240 + 3) * 8;
                noise += (Math.random() - 0.5) * 15;

                points.push({ x: baseX, y: baseY + noise });
            }

            return points;
        }

        // Generate smooth bay
        function generateSmoothCoast() {
            const points = [];
            const numPoints = 100;

            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const baseX = 100 + t * 600;
                let baseY = 300 + Math.sin(t * Math.PI * 3) * 100;
                baseY += Math.sin(t * Math.PI * 7) * 20;

                points.push({ x: baseX, y: baseY });
            }

            return points;
        }

        function generateCoast(type) {
            switch (type) {
                case 'koch': return generateKochCoast(5);
                case 'britain': return generateBritainCoast();
                case 'norway': return generateNorwayCoast();
                case 'smooth': return generateSmoothCoast();
                default: return generateKochCoast(5);
            }
        }

        function drawCoast(highlight = null) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw water
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1e3a5f');
            gradient.addColorStop(1, '#0f172a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw land (above coastline)
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(coastPoints[0].x, coastPoints[0].y);
            for (const p of coastPoints) {
                ctx.lineTo(p.x, p.y);
            }
            ctx.lineTo(canvas.width, coastPoints[coastPoints.length - 1].y);
            ctx.lineTo(canvas.width, 0);
            ctx.closePath();

            const landGradient = ctx.createLinearGradient(0, 0, 0, 300);
            landGradient.addColorStop(0, '#2d5a3d');
            landGradient.addColorStop(1, '#1a3a2d');
            ctx.fillStyle = landGradient;
            ctx.fill();

            // Draw coastline
            ctx.beginPath();
            ctx.moveTo(coastPoints[0].x, coastPoints[0].y);
            for (const p of coastPoints) {
                ctx.lineTo(p.x, p.y);
            }
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw measurement segments if provided
            if (highlight) {
                ctx.beginPath();
                ctx.moveTo(highlight[0].x, highlight[0].y);
                for (const p of highlight) {
                    ctx.lineTo(p.x, p.y);
                }
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Draw measurement points
                for (const p of highlight) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#ef4444';
                    ctx.fill();
                }
            }
        }

        function measureCoastline(rulerSize) {
            const scale = rulerSize * 3; // Scale for visualization
            const measurePoints = [coastPoints[0]];
            let currentPoint = coastPoints[0];
            let totalLength = 0;

            while (true) {
                // Find next point on coastline that is rulerSize away
                let found = false;
                let bestPoint = null;
                let bestIdx = -1;

                // Find coastline points near the ruler distance
                for (let i = 0; i < coastPoints.length; i++) {
                    const p = coastPoints[i];
                    const dist = Math.sqrt(
                        Math.pow(p.x - currentPoint.x, 2) +
                        Math.pow(p.y - currentPoint.y, 2)
                    );

                    if (dist >= scale * 0.95 && dist <= scale * 1.05) {
                        if (bestIdx < i) {
                            bestPoint = p;
                            bestIdx = i;
                            found = true;
                        }
                    }
                }

                if (!found || bestIdx <= coastPoints.indexOf(currentPoint)) {
                    // No exact match, find closest to ruler distance going forward
                    const currentIdx = coastPoints.indexOf(currentPoint);
                    let minDiff = Infinity;

                    for (let i = currentIdx + 1; i < coastPoints.length; i++) {
                        const p = coastPoints[i];
                        const dist = Math.sqrt(
                            Math.pow(p.x - currentPoint.x, 2) +
                            Math.pow(p.y - currentPoint.y, 2)
                        );
                        const diff = Math.abs(dist - scale);

                        if (dist >= scale * 0.5 && diff < minDiff) {
                            minDiff = diff;
                            bestPoint = p;
                            bestIdx = i;
                            found = true;
                        }
                    }
                }

                if (!found || !bestPoint) break;

                const segLength = Math.sqrt(
                    Math.pow(bestPoint.x - currentPoint.x, 2) +
                    Math.pow(bestPoint.y - currentPoint.y, 2)
                );
                totalLength += segLength;
                measurePoints.push(bestPoint);

                const idx = coastPoints.indexOf(bestPoint);
                if (idx >= coastPoints.length - 2) break;

                currentPoint = bestPoint;
                coastPoints = coastPoints.slice(idx);
            }

            // Reset coast points
            coastPoints = generateCoast(currentCoastType);

            return {
                length: totalLength / 3, // Convert back to km
                segments: measurePoints.length - 1,
                points: measurePoints
            };
        }

        function updateDisplay(result, rulerSize) {
            totalLengthEl.textContent = result.length.toFixed(1) + ' km';
            segmentCountEl.textContent = result.segments;

            if (initialLength === null) {
                initialLength = result.length;
            }

            const ratio = result.length / initialLength;
            lengthRatioEl.textContent = ratio.toFixed(2) + 'x';

            // Add to history
            measurements.push({ rulerSize, length: result.length });
            updateHistory();

            drawCoast(result.points);
        }

        function updateHistory() {
            const maxLen = Math.max(...measurements.map(m => m.length));

            historyContainer.innerHTML = measurements
                .slice().reverse()
                .map(m => `
                    <div class="history-entry">
                        <span class="ruler-size">${m.rulerSize} km</span>
                        <div class="length-bar" style="width: ${(m.length / maxLen) * 100}%"></div>
                        <span class="length-val">${m.length.toFixed(0)} km</span>
                    </div>
                `).join('');
        }

        rulerSlider.addEventListener('input', () => {
            rulerDisplay.textContent = rulerSlider.value + ' km';
        });

        measureBtn.addEventListener('click', () => {
            if (isAnimating) return;
            const rulerSize = parseInt(rulerSlider.value);
            coastPoints = generateCoast(currentCoastType);
            const result = measureCoastline(rulerSize);
            updateDisplay(result, rulerSize);
        });

        animateBtn.addEventListener('click', () => {
            if (isAnimating) {
                isAnimating = false;
                animateBtn.textContent = 'Animate: Watch Length Grow!';
                cancelAnimationFrame(animationFrame);
                return;
            }

            isAnimating = true;
            animateBtn.textContent = 'Stop Animation';
            measurements = [];
            initialLength = null;

            let currentRuler = 100;

            function step() {
                if (!isAnimating || currentRuler < 5) {
                    isAnimating = false;
                    animateBtn.textContent = 'Animate: Watch Length Grow!';
                    return;
                }

                rulerSlider.value = currentRuler;
                rulerDisplay.textContent = currentRuler + ' km';

                coastPoints = generateCoast(currentCoastType);
                const result = measureCoastline(currentRuler);
                updateDisplay(result, currentRuler);

                currentRuler -= 5;
                animationFrame = setTimeout(step, 600);
            }

            step();
        });

        // Coastline type selection
        document.querySelectorAll('.coastline-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.coastline-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentCoastType = btn.dataset.type;
                fractalDimEl.textContent = fractalDims[currentCoastType].toFixed(2);
                measurements = [];
                initialLength = null;
                historyContainer.innerHTML = '';
                coastPoints = generateCoast(currentCoastType);
                drawCoast();
                totalLengthEl.textContent = '--';
                segmentCountEl.textContent = '--';
                lengthRatioEl.textContent = '--';
            });
        });

        // Initialize
        coastPoints = generateCoast(currentCoastType);
        drawCoast();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
