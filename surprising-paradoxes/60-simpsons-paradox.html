<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simpson's Paradox - When Data Lies</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --data-blue: #3498db;
            --data-orange: #e67e22;
            --data-green: #2ecc71;
            --data-purple: #9b59b6;
            --trend-positive: #27ae60;
            --trend-negative: #e74c3c;
            --sage: #8A9A5B;
            --moss: #606C38;
            --cream: #FEFAE0;
            --dark-bg: #1a1a2e;
            --panel-bg: #16213e;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, var(--dark-bg) 0%, #0f3460 50%, var(--panel-bg) 100%);
            min-height: 100vh;
            color: #ecf0f1;
            overflow-x: hidden;
        }

        /* Grid background */
        .grid-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(rgba(52, 152, 219, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(52, 152, 219, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            z-index: 0;
            animation: gridPulse 4s ease-in-out infinite;
        }

        @keyframes gridPulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.8; }
        }

        /* Floating data points */
        .floating-point {
            position: fixed;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            opacity: 0.6;
            z-index: 1;
            animation: float 8s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-30px) scale(1.2); }
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 18px;
            background: rgba(52, 152, 219, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 30px;
            color: var(--data-blue);
            text-decoration: none;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .organic-back-link:hover {
            background: rgba(52, 152, 219, 0.4);
            transform: translateX(-3px);
        }

        .container {
            position: relative;
            z-index: 10;
            max-width: 1200px;
            margin: 0 auto;
            padding: 80px 20px 40px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            font-family: 'Lora', serif;
            font-size: 2.8rem;
            color: var(--data-blue);
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(52, 152, 219, 0.5);
        }

        .header .subtitle {
            font-size: 1.2rem;
            color: #bdc3c7;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(22, 33, 62, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 20px;
            padding: 25px;
        }

        .panel h2 {
            font-family: 'Lora', serif;
            color: var(--data-blue);
            margin-bottom: 15px;
            font-size: 1.4rem;
        }

        .chart-container {
            position: relative;
            height: 350px;
            margin-bottom: 15px;
        }

        canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--data-blue), #2980b9);
            color: white;
        }

        .btn-primary:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(52, 152, 219, 0.4);
        }

        .btn-secondary {
            background: rgba(52, 152, 219, 0.2);
            color: var(--data-blue);
            border: 1px solid var(--data-blue);
        }

        .btn-secondary:hover {
            background: rgba(52, 152, 219, 0.4);
        }

        .btn.active {
            background: var(--data-blue);
            color: white;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .trend-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            border-radius: 15px;
            margin-top: 15px;
            font-weight: 600;
        }

        .trend-positive {
            background: rgba(39, 174, 96, 0.2);
            border: 1px solid var(--trend-positive);
            color: var(--trend-positive);
        }

        .trend-negative {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid var(--trend-negative);
            color: var(--trend-negative);
        }

        .trend-arrow {
            font-size: 1.5rem;
        }

        /* Scenario selector */
        .scenario-tabs {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .scenario-tab {
            padding: 10px 20px;
            background: rgba(52, 152, 219, 0.1);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 25px;
            color: #bdc3c7;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .scenario-tab:hover, .scenario-tab.active {
            background: var(--data-blue);
            color: white;
            border-color: var(--data-blue);
        }

        /* Explanation section */
        .explanation {
            background: rgba(22, 33, 62, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 20px;
            padding: 30px;
            margin-top: 30px;
        }

        .explanation h2 {
            font-family: 'Lora', serif;
            color: var(--data-blue);
            margin-bottom: 20px;
        }

        .explanation p {
            line-height: 1.8;
            margin-bottom: 15px;
            color: #bdc3c7;
        }

        .highlight {
            color: var(--data-orange);
            font-weight: 600;
        }

        .paradox-box {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.2), rgba(52, 152, 219, 0.2));
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            border-left: 4px solid var(--data-orange);
        }

        .paradox-box h3 {
            color: var(--data-orange);
            margin-bottom: 10px;
        }

        .real-world {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .example-card {
            background: rgba(52, 152, 219, 0.1);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .example-card:hover {
            transform: translateY(-5px);
            border-color: var(--data-blue);
        }

        .example-card h4 {
            color: var(--data-blue);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .example-card p {
            font-size: 0.9rem;
            color: #bdc3c7;
            line-height: 1.6;
        }

        .confound-visual {
            text-align: center;
            padding: 30px;
            margin: 30px 0;
        }

        .confound-diagram {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            flex-wrap: wrap;
        }

        .confound-box {
            padding: 20px 30px;
            border-radius: 15px;
            font-weight: 600;
            text-align: center;
        }

        .confound-arrow {
            font-size: 2rem;
            color: var(--data-blue);
        }

        .stats-display {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--data-blue);
        }

        .stat-label {
            font-size: 0.8rem;
            color: #bdc3c7;
        }
    </style>
</head>
<body>
    <div class="grid-bg"></div>

    <!-- Floating data points -->
    <div class="floating-point" style="top: 10%; left: 15%; background: var(--data-blue); animation-delay: 0s;"></div>
    <div class="floating-point" style="top: 20%; left: 80%; background: var(--data-orange); animation-delay: 1s;"></div>
    <div class="floating-point" style="top: 60%; left: 10%; background: var(--data-green); animation-delay: 2s;"></div>
    <div class="floating-point" style="top: 70%; left: 85%; background: var(--data-purple); animation-delay: 3s;"></div>
    <div class="floating-point" style="top: 40%; left: 5%; background: var(--data-blue); animation-delay: 1.5s;"></div>
    <div class="floating-point" style="top: 30%; left: 90%; background: var(--data-orange); animation-delay: 2.5s;"></div>

    <a href="index.html" class="organic-back-link">
        <span class="back-arrow">‚Üê</span>
        <span class="back-text">Gallery</span>
    </a>

    <div class="container">
        <header class="header">
            <h1>Simpson's Paradox</h1>
            <p class="subtitle">When aggregating data reverses the truth</p>
        </header>

        <div class="scenario-tabs">
            <button class="scenario-tab active" data-scenario="treatment">Medical Treatment</button>
            <button class="scenario-tab" data-scenario="admissions">University Admissions</button>
            <button class="scenario-tab" data-scenario="batting">Batting Averages</button>
            <button class="scenario-tab" data-scenario="custom">Custom Data</button>
        </div>

        <div class="main-content">
            <div class="panel">
                <h2>Grouped Data (By Category)</h2>
                <div class="chart-container">
                    <canvas id="groupedChart"></canvas>
                </div>
                <div class="legend" id="groupedLegend"></div>
                <div class="trend-indicator trend-positive" id="groupedTrend">
                    <span class="trend-arrow">‚Üó</span>
                    <span>Treatment A is better in BOTH groups</span>
                </div>
                <div class="stats-display" id="groupedStats"></div>
            </div>

            <div class="panel">
                <h2>Combined Data (All Together)</h2>
                <div class="chart-container">
                    <canvas id="combinedChart"></canvas>
                </div>
                <div class="legend" id="combinedLegend"></div>
                <div class="trend-indicator trend-negative" id="combinedTrend">
                    <span class="trend-arrow">‚Üò</span>
                    <span>But Treatment A looks WORSE overall!</span>
                </div>
                <div class="stats-display" id="combinedStats"></div>
            </div>
        </div>

        <div class="controls" style="justify-content: center; margin-bottom: 30px;">
            <button class="btn btn-primary" id="animateBtn">Animate Paradox</button>
            <button class="btn btn-secondary" id="regenerateBtn">New Random Data</button>
            <button class="btn btn-secondary" id="showMathBtn">Show the Math</button>
        </div>

        <div class="explanation">
            <h2>What's Happening?</h2>

            <div class="paradox-box">
                <h3>The Paradox</h3>
                <p id="paradoxText">
                    Treatment A has a higher success rate in BOTH small kidney stones AND large kidney stones.
                    Yet when we combine the data, Treatment B appears to have a higher overall success rate!
                </p>
            </div>

            <p>
                <span class="highlight">Simpson's Paradox</span> occurs when a trend that appears in separate groups of data
                <strong>reverses or disappears</strong> when the groups are combined. Named after statistician
                Edward H. Simpson (1951), this paradox demonstrates why correlation and causation require careful analysis.
            </p>

            <div class="confound-visual">
                <h3 style="color: var(--data-orange); margin-bottom: 20px;">The Hidden Culprit: Confounding Variables</h3>
                <div class="confound-diagram">
                    <div class="confound-box" style="background: rgba(52, 152, 219, 0.3); border: 2px solid var(--data-blue);">
                        Treatment Choice
                    </div>
                    <span class="confound-arrow">‚Üê</span>
                    <div class="confound-box" style="background: rgba(230, 126, 34, 0.3); border: 2px solid var(--data-orange);">
                        Case Severity<br>(Confounding Variable)
                    </div>
                    <span class="confound-arrow">‚Üí</span>
                    <div class="confound-box" style="background: rgba(46, 204, 113, 0.3); border: 2px solid var(--data-green);">
                        Treatment Outcome
                    </div>
                </div>
                <p style="margin-top: 20px; color: #bdc3c7; font-style: italic;">
                    Doctors choose Treatment A for harder cases. This creates the illusion that A is worse.
                </p>
            </div>

            <p>
                The key insight: when there's a <span class="highlight">confounding variable</span> that influences
                both which group something belongs to AND the outcome, simple aggregation gives misleading results.
                The confounding variable creates different <em>weights</em> when combining groups.
            </p>

            <h3 style="color: var(--data-blue); margin: 30px 0 20px;">Real-World Examples</h3>

            <div class="real-world">
                <div class="example-card">
                    <h4>üè• Kidney Stone Study (1986)</h4>
                    <p>
                        Treatment A: 93% success on small stones, 73% on large.<br>
                        Treatment B: 87% success on small stones, 69% on large.<br>
                        <strong>A wins in both!</strong> But combined, B had 83% vs A's 78%.
                        Why? A was used more on large (hard) stones.
                    </p>
                </div>

                <div class="example-card">
                    <h4>üéì UC Berkeley Admissions (1973)</h4>
                    <p>
                        Overall, 44% of men admitted vs 35% of women‚Äîdiscrimination?
                        But within each department, women had equal or higher rates!
                        Women applied more to competitive departments.
                    </p>
                </div>

                <div class="example-card">
                    <h4>‚öæ Baseball Batting (1995-96)</h4>
                    <p>
                        David Justice beat Derek Jeter in batting average both years.
                        But combined across both years, Jeter's average was higher!
                        Jeter had more at-bats in his better year.
                    </p>
                </div>

                <div class="example-card">
                    <h4>üíâ COVID-19 Vaccines</h4>
                    <p>
                        Vaccine effectiveness seemed lower in highly vaccinated countries!
                        The paradox: elderly (higher risk) got vaccinated first.
                        Age was the confounding variable.
                    </p>
                </div>
            </div>

            <div class="paradox-box" style="margin-top: 30px; border-left-color: var(--data-blue);">
                <h3 style="color: var(--data-blue);">The Lesson</h3>
                <p>
                    <strong>Always ask: "What variables am I not seeing?"</strong><br><br>
                    Before combining data groups, check if there's a confounding variable that creates
                    different sample sizes or affects both the grouping and the outcome.
                    Sometimes the grouped analysis is right; sometimes the combined is right‚Äîcontext is everything.
                </p>
            </div>
        </div>
    </div>

    <script>
        // Data scenarios
        const scenarios = {
            treatment: {
                name: 'Medical Treatment',
                groups: ['Small Stones', 'Large Stones'],
                treatments: ['Treatment A', 'Treatment B'],
                colors: ['#3498db', '#e67e22'],
                // Real kidney stone data (approximately)
                data: {
                    groupA: { success: 81, total: 87 },  // Small stones, Treatment A
                    groupB: { success: 234, total: 270 }, // Small stones, Treatment B
                    groupC: { success: 192, total: 263 }, // Large stones, Treatment A
                    groupD: { success: 55, total: 80 }    // Large stones, Treatment B
                },
                paradoxText: 'Treatment A has a higher success rate in BOTH small kidney stones (93%) AND large kidney stones (73%). Yet when we combine the data, Treatment B appears better (83% vs 78%)! The trick: Treatment A was given to the harder large-stone cases more often.'
            },
            admissions: {
                name: 'University Admissions',
                groups: ['Competitive Dept', 'Easy Dept'],
                treatments: ['Women', 'Men'],
                colors: ['#9b59b6', '#2ecc71'],
                data: {
                    groupA: { success: 20, total: 100 },  // Competitive, Women
                    groupB: { success: 10, total: 40 },   // Competitive, Men
                    groupC: { success: 80, total: 100 },  // Easy, Women
                    groupD: { success: 180, total: 200 }  // Easy, Men
                },
                paradoxText: 'Women have higher admission rates in BOTH departments. But overall, men seem to be admitted more! Why? Women applied more to the competitive department, while men applied more to the easy one.'
            },
            batting: {
                name: 'Batting Averages',
                groups: ['Year 1', 'Year 2'],
                treatments: ['Player A', 'Player B'],
                colors: ['#e74c3c', '#3498db'],
                data: {
                    groupA: { success: 12, total: 48 },   // Year 1, Player A (.250)
                    groupB: { success: 104, total: 411 }, // Year 1, Player B (.253)
                    groupC: { success: 45, total: 140 },  // Year 2, Player A (.321)
                    groupD: { success: 36, total: 112 }   // Year 2, Player B (.321)
                },
                paradoxText: 'Player A beats Player B in Year 1 AND Year 2. But combined, Player B has the higher average! The paradox: Player B had more at-bats in the year when both players performed better.'
            },
            custom: {
                name: 'Custom Data',
                groups: ['Group 1', 'Group 2'],
                treatments: ['Option A', 'Option B'],
                colors: ['#1abc9c', '#f39c12'],
                data: null
            }
        };

        let currentScenario = 'treatment';
        let animating = false;

        // Generate random Simpson's Paradox data
        function generateRandomData() {
            // Create data that exhibits Simpson's Paradox
            const confoundStrength = 0.3 + Math.random() * 0.2;
            const baseRateA1 = 0.6 + Math.random() * 0.3;
            const baseRateA2 = 0.4 + Math.random() * 0.2;
            const baseRateB1 = baseRateA1 - 0.05 - Math.random() * 0.1;
            const baseRateB2 = baseRateA2 - 0.05 - Math.random() * 0.1;

            // A goes more to group 2 (harder), B goes more to group 1 (easier)
            const nA1 = Math.floor(30 + Math.random() * 30);
            const nA2 = Math.floor(100 + Math.random() * 100);
            const nB1 = Math.floor(100 + Math.random() * 100);
            const nB2 = Math.floor(30 + Math.random() * 30);

            return {
                groupA: { success: Math.floor(nA1 * baseRateA1), total: nA1 },
                groupB: { success: Math.floor(nB1 * baseRateB1), total: nB1 },
                groupC: { success: Math.floor(nA2 * baseRateA2), total: nA2 },
                groupD: { success: Math.floor(nB2 * baseRateB2), total: nB2 }
            };
        }

        // Canvas contexts
        const groupedCanvas = document.getElementById('groupedChart');
        const combinedCanvas = document.getElementById('combinedChart');
        const groupedCtx = groupedCanvas.getContext('2d');
        const combinedCtx = combinedCanvas.getContext('2d');

        function resizeCanvas(canvas) {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.getContext('2d').scale(dpr, dpr);
        }

        function clearCanvas(ctx, canvas) {
            const dpr = window.devicePixelRatio || 1;
            ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
        }

        function drawAxes(ctx, width, height, padding) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;

            // X axis
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();

            // Y axis
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();

            // Grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            for (let i = 1; i <= 4; i++) {
                const y = height - padding - (i * (height - 2 * padding) / 4);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }

            // Y axis labels
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = '12px Nunito';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 4; i++) {
                const y = height - padding - (i * (height - 2 * padding) / 4);
                ctx.fillText((i * 25) + '%', padding - 10, y + 4);
            }
        }

        function drawGroupedChart(data, scenario, animProgress = 1) {
            resizeCanvas(groupedCanvas);
            const dpr = window.devicePixelRatio || 1;
            const width = groupedCanvas.width / dpr;
            const height = groupedCanvas.height / dpr;
            const padding = 50;

            clearCanvas(groupedCtx, groupedCanvas);
            drawAxes(groupedCtx, width, height, padding);

            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;
            const barWidth = chartWidth / 6;

            // Calculate rates
            const rateA1 = data.groupA.success / data.groupA.total;
            const rateB1 = data.groupB.success / data.groupB.total;
            const rateA2 = data.groupC.success / data.groupC.total;
            const rateB2 = data.groupD.success / data.groupD.total;

            const groups = [
                { label: scenario.groups[0], bars: [
                    { rate: rateA1, color: scenario.colors[0], label: scenario.treatments[0] },
                    { rate: rateB1, color: scenario.colors[1], label: scenario.treatments[1] }
                ]},
                { label: scenario.groups[1], bars: [
                    { rate: rateA2, color: scenario.colors[0], label: scenario.treatments[0] },
                    { rate: rateB2, color: scenario.colors[1], label: scenario.treatments[1] }
                ]}
            ];

            groups.forEach((group, gIndex) => {
                const groupX = padding + gIndex * (chartWidth / 2) + chartWidth / 4;

                // Group label
                groupedCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                groupedCtx.font = 'bold 14px Nunito';
                groupedCtx.textAlign = 'center';
                groupedCtx.fillText(group.label, groupX, height - 15);

                group.bars.forEach((bar, bIndex) => {
                    const x = groupX + (bIndex - 0.5) * barWidth * 1.2 - barWidth / 2;
                    const barHeight = bar.rate * chartHeight * animProgress;
                    const y = height - padding - barHeight;

                    // Bar
                    groupedCtx.fillStyle = bar.color;
                    groupedCtx.beginPath();
                    groupedCtx.roundRect(x, y, barWidth, barHeight, 5);
                    groupedCtx.fill();

                    // Percentage label
                    groupedCtx.fillStyle = 'white';
                    groupedCtx.font = 'bold 14px Nunito';
                    groupedCtx.fillText((bar.rate * 100).toFixed(0) + '%', x + barWidth / 2, y - 10);
                });
            });

            // Update legend
            document.getElementById('groupedLegend').innerHTML = scenario.treatments.map((t, i) =>
                `<div class="legend-item">
                    <div class="legend-color" style="background: ${scenario.colors[i]}"></div>
                    <span>${t}</span>
                </div>`
            ).join('');

            // Update trend
            const aWinsBoth = rateA1 > rateB1 && rateA2 > rateB2;
            const bWinsBoth = rateB1 > rateA1 && rateB2 > rateA2;
            const trend = document.getElementById('groupedTrend');
            if (aWinsBoth) {
                trend.className = 'trend-indicator trend-positive';
                trend.innerHTML = `<span class="trend-arrow">‚Üó</span><span>${scenario.treatments[0]} wins in BOTH groups!</span>`;
            } else if (bWinsBoth) {
                trend.className = 'trend-indicator trend-positive';
                trend.innerHTML = `<span class="trend-arrow">‚Üó</span><span>${scenario.treatments[1]} wins in BOTH groups!</span>`;
            } else {
                trend.className = 'trend-indicator';
                trend.innerHTML = `<span class="trend-arrow">‚Üî</span><span>Mixed results across groups</span>`;
            }

            // Update stats
            document.getElementById('groupedStats').innerHTML = `
                <div class="stat-box">
                    <div class="stat-value" style="color: ${scenario.colors[0]}">${(rateA1 * 100).toFixed(1)}%</div>
                    <div class="stat-label">${scenario.treatments[0]} in ${scenario.groups[0]}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" style="color: ${scenario.colors[1]}">${(rateB1 * 100).toFixed(1)}%</div>
                    <div class="stat-label">${scenario.treatments[1]} in ${scenario.groups[0]}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" style="color: ${scenario.colors[0]}">${(rateA2 * 100).toFixed(1)}%</div>
                    <div class="stat-label">${scenario.treatments[0]} in ${scenario.groups[1]}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" style="color: ${scenario.colors[1]}">${(rateB2 * 100).toFixed(1)}%</div>
                    <div class="stat-label">${scenario.treatments[1]} in ${scenario.groups[1]}</div>
                </div>
            `;
        }

        function drawCombinedChart(data, scenario, animProgress = 1) {
            resizeCanvas(combinedCanvas);
            const dpr = window.devicePixelRatio || 1;
            const width = combinedCanvas.width / dpr;
            const height = combinedCanvas.height / dpr;
            const padding = 50;

            clearCanvas(combinedCtx, combinedCanvas);
            drawAxes(combinedCtx, width, height, padding);

            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;
            const barWidth = chartWidth / 4;

            // Combined rates
            const totalA = data.groupA.total + data.groupC.total;
            const successA = data.groupA.success + data.groupC.success;
            const rateA = successA / totalA;

            const totalB = data.groupB.total + data.groupD.total;
            const successB = data.groupB.success + data.groupD.success;
            const rateB = successB / totalB;

            const bars = [
                { rate: rateA, color: scenario.colors[0], label: scenario.treatments[0], n: totalA },
                { rate: rateB, color: scenario.colors[1], label: scenario.treatments[1], n: totalB }
            ];

            bars.forEach((bar, i) => {
                const x = padding + chartWidth / 2 + (i - 0.5) * barWidth * 1.5 - barWidth / 2;
                const barHeight = bar.rate * chartHeight * animProgress;
                const y = height - padding - barHeight;

                // Bar
                combinedCtx.fillStyle = bar.color;
                combinedCtx.beginPath();
                combinedCtx.roundRect(x, y, barWidth, barHeight, 5);
                combinedCtx.fill();

                // Percentage label
                combinedCtx.fillStyle = 'white';
                combinedCtx.font = 'bold 16px Nunito';
                combinedCtx.textAlign = 'center';
                combinedCtx.fillText((bar.rate * 100).toFixed(1) + '%', x + barWidth / 2, y - 15);

                // Sample size
                combinedCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                combinedCtx.font = '12px Nunito';
                combinedCtx.fillText(`n = ${bar.n}`, x + barWidth / 2, y - 35);

                // Label
                combinedCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                combinedCtx.font = 'bold 14px Nunito';
                combinedCtx.fillText(bar.label, x + barWidth / 2, height - 15);
            });

            // Update legend
            document.getElementById('combinedLegend').innerHTML = scenario.treatments.map((t, i) =>
                `<div class="legend-item">
                    <div class="legend-color" style="background: ${scenario.colors[i]}"></div>
                    <span>${t} (combined)</span>
                </div>`
            ).join('');

            // Update trend (should be opposite of grouped!)
            const trend = document.getElementById('combinedTrend');
            if (rateA > rateB) {
                trend.className = 'trend-indicator trend-positive';
                trend.innerHTML = `<span class="trend-arrow">‚Üó</span><span>${scenario.treatments[0]} appears better overall</span>`;
            } else {
                trend.className = 'trend-indicator trend-negative';
                trend.innerHTML = `<span class="trend-arrow">‚Üò</span><span>But ${scenario.treatments[1]} appears better overall!</span>`;
            }

            // Update stats
            document.getElementById('combinedStats').innerHTML = `
                <div class="stat-box">
                    <div class="stat-value" style="color: ${scenario.colors[0]}">${(rateA * 100).toFixed(1)}%</div>
                    <div class="stat-label">${scenario.treatments[0]} Combined</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" style="color: ${scenario.colors[1]}">${(rateB * 100).toFixed(1)}%</div>
                    <div class="stat-label">${scenario.treatments[1]} Combined</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value">${totalA}</div>
                    <div class="stat-label">${scenario.treatments[0]} Sample Size</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value">${totalB}</div>
                    <div class="stat-label">${scenario.treatments[1]} Sample Size</div>
                </div>
            `;
        }

        function updateCharts(animProgress = 1) {
            const scenario = scenarios[currentScenario];
            const data = scenario.data || generateRandomData();
            if (!scenario.data && currentScenario === 'custom') {
                scenarios.custom.data = data;
            }

            drawGroupedChart(data, scenario, animProgress);
            drawCombinedChart(data, scenario, animProgress);

            document.getElementById('paradoxText').textContent = scenario.paradoxText ||
                'Watch how the winning option in each group loses when the data is combined!';
        }

        // Animation
        function animateParadox() {
            if (animating) return;
            animating = true;

            let progress = 0;
            const duration = 1500;
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                progress = Math.min(elapsed / duration, 1);

                // Ease out cubic
                const eased = 1 - Math.pow(1 - progress, 3);

                updateCharts(eased);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    animating = false;
                }
            }

            animate();
        }

        // Event listeners
        document.querySelectorAll('.scenario-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.scenario-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                currentScenario = tab.dataset.scenario;
                if (currentScenario === 'custom') {
                    scenarios.custom.data = generateRandomData();
                }
                animateParadox();
            });
        });

        document.getElementById('animateBtn').addEventListener('click', animateParadox);

        document.getElementById('regenerateBtn').addEventListener('click', () => {
            scenarios.custom.data = generateRandomData();
            currentScenario = 'custom';
            document.querySelectorAll('.scenario-tab').forEach(t => t.classList.remove('active'));
            document.querySelector('[data-scenario="custom"]').classList.add('active');
            animateParadox();
        });

        document.getElementById('showMathBtn').addEventListener('click', () => {
            const scenario = scenarios[currentScenario];
            const data = scenario.data || scenarios.custom.data;

            const rateA1 = (data.groupA.success / data.groupA.total * 100).toFixed(1);
            const rateB1 = (data.groupB.success / data.groupB.total * 100).toFixed(1);
            const rateA2 = (data.groupC.success / data.groupC.total * 100).toFixed(1);
            const rateB2 = (data.groupD.success / data.groupD.total * 100).toFixed(1);

            const totalA = data.groupA.total + data.groupC.total;
            const totalB = data.groupB.total + data.groupD.total;
            const combA = ((data.groupA.success + data.groupC.success) / totalA * 100).toFixed(1);
            const combB = ((data.groupB.success + data.groupD.success) / totalB * 100).toFixed(1);

            alert(`The Math Behind the Paradox:

Group 1:
  ${scenario.treatments[0]}: ${data.groupA.success}/${data.groupA.total} = ${rateA1}%
  ${scenario.treatments[1]}: ${data.groupB.success}/${data.groupB.total} = ${rateB1}%

Group 2:
  ${scenario.treatments[0]}: ${data.groupC.success}/${data.groupC.total} = ${rateA2}%
  ${scenario.treatments[1]}: ${data.groupD.success}/${data.groupD.total} = ${rateB2}%

Combined:
  ${scenario.treatments[0]}: ${data.groupA.success + data.groupC.success}/${totalA} = ${combA}%
  ${scenario.treatments[1]}: ${data.groupB.success + data.groupD.success}/${totalB} = ${combB}%

The trick: Different sample sizes in each group create weighted averaging that reverses the trend!`);
        });

        // Handle resize
        window.addEventListener('resize', () => updateCharts());

        // Initial draw
        updateCharts();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
