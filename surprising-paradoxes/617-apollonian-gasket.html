<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Apollonian Gasket - Circle Packing Fractal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }
        .back-link {
            display: inline-flex;
            align-items: center;
            color: #e94560;
            text-decoration: none;
            margin-bottom: 15px;
            font-size: 0.95em;
        }
        .back-link:hover {
            color: #ff6b6b;
            text-decoration: underline;
        }
        h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
            color: #fff;
            text-shadow: 0 0 30px rgba(233, 69, 96, 0.5);
        }
        .subtitle {
            color: #8b949e;
            margin-bottom: 20px;
            font-size: 1.05em;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
        }
        .canvas-container {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            border-radius: 8px;
            background: #0a0a1a;
        }
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .panel {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .panel h3 {
            font-size: 0.9em;
            color: #e94560;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all 0.2s;
        }
        .btn-primary {
            background: linear-gradient(135deg, #e94560, #c23a4f);
            color: white;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
        }
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
        }
        .btn-secondary.active {
            background: rgba(233, 69, 96, 0.3);
            border-color: #e94560;
            color: #e94560;
        }
        .param-group {
            margin-bottom: 12px;
        }
        .param-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .param-name {
            color: #b0b0b0;
            font-size: 0.85em;
        }
        .param-value {
            color: #ffd700;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.9em;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.1);
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #e94560;
            cursor: pointer;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .stat-label {
            color: #8b949e;
            font-size: 0.85em;
        }
        .stat-value {
            color: #ffd700;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.9em;
        }
        .preset-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        .formula {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 6px;
            font-family: 'Monaco', 'Consolas', monospace;
            margin: 8px 0;
            text-align: center;
            color: #ffd700;
            font-size: 0.85em;
        }
        .exp-section {
            margin-top: 20px;
        }
        .exp-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
        }
        .exp-card {
            background: linear-gradient(135deg, rgba(233,69,96,0.1), rgba(194,58,79,0.05));
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(233,69,96,0.2);
        }
        .exp-card h4 {
            color: #e94560;
            margin-bottom: 8px;
            font-size: 0.95em;
        }
        .exp-card p {
            font-size: 0.85em;
            line-height: 1.6;
            color: #8b949e;
        }
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Paradoxes</a>
        <h1>Apollonian Gasket</h1>
        <p class="subtitle">Circle Packing Fractal with Integer Surprises</p>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="mainCanvas" width="700" height="700"></canvas>
            </div>

            <div class="sidebar">
                <div class="panel">
                    <h3>Controls</h3>
                    <div class="controls">
                        <button class="btn btn-primary" id="regenerateBtn">Regenerate</button>
                        <button class="btn btn-secondary" id="animateBtn">Animate</button>
                    </div>
                </div>

                <div class="panel">
                    <h3>Settings</h3>
                    <div class="param-group">
                        <div class="param-label">
                            <span class="param-name">Max depth</span>
                            <span class="param-value" id="depthValue">6</span>
                        </div>
                        <input type="range" id="depthSlider" min="3" max="9" value="6">
                    </div>
                    <div class="param-group">
                        <div class="param-label">
                            <span class="param-name">Min radius (px)</span>
                            <span class="param-value" id="minRadValue">2</span>
                        </div>
                        <input type="range" id="minRadSlider" min="1" max="10" value="2">
                    </div>
                    <label style="display: flex; align-items: center; gap: 8px; margin-top: 10px; cursor: pointer;">
                        <input type="checkbox" id="showCurvature" checked>
                        <span style="font-size: 0.85em; color: #b0b0b0;">Show curvature values</span>
                    </label>
                </div>

                <div class="panel">
                    <h3>Integer Packings</h3>
                    <div class="preset-grid">
                        <button class="btn btn-secondary active" data-curvatures="-1,2,2,3">(-1, 2, 2, 3)</button>
                        <button class="btn btn-secondary" data-curvatures="-2,3,6,7">(-2, 3, 6, 7)</button>
                        <button class="btn btn-secondary" data-curvatures="-3,5,8,8">(-3, 5, 8, 8)</button>
                        <button class="btn btn-secondary" data-curvatures="-6,10,15,19">(-6, 10, 15, 19)</button>
                        <button class="btn btn-secondary" data-curvatures="-11,21,24,28">(-11, 21, 24, 28)</button>
                        <button class="btn btn-secondary" data-curvatures="0,0,1,1">(0, 0, 1, 1)</button>
                    </div>
                </div>

                <div class="panel">
                    <h3>Statistics</h3>
                    <div class="stat-row">
                        <span class="stat-label">Circles drawn</span>
                        <span id="circleCount" class="stat-value">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Fractal dimension</span>
                        <span class="stat-value">~1.3057</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Initial curvatures</span>
                        <span id="initCurvatures" class="stat-value">(-1, 2, 2, 3)</span>
                    </div>
                </div>

                <div class="panel">
                    <h3>Descartes' Theorem</h3>
                    <div class="formula">
                        (k₁+k₂+k₃+k₄)² = 2(k₁²+k₂²+k₃²+k₄²)
                    </div>
                    <p style="font-size: 0.8em; color: #8b949e;">
                        Given 3 mutually tangent circles with curvatures k₁,k₂,k₃, the fourth tangent circle has curvature k₄.
                    </p>
                </div>
            </div>
        </div>

        <div class="exp-section">
            <div class="exp-cards">
                <div class="exp-card">
                    <h4>Ancient Meets Modern</h4>
                    <p>Named after Apollonius of Perga (200 BC), but first described by Leibniz in 1706. Every curved triangle is filled with more circles, forever. The result? A fractal of dimension ~1.3057—between a line and a plane!</p>
                </div>
                <div class="exp-card">
                    <h4>Integer Miracle</h4>
                    <p>If you start with four mutually tangent circles whose curvatures (1/radius) are integers, EVERY circle in the infinite packing will also have integer curvature! The pattern (-1, 2, 2, 3) generates only integers forever.</p>
                </div>
                <div class="exp-card">
                    <h4>Descartes' Magic Formula</h4>
                    <p>In 1643, René Descartes found that for four mutually tangent circles: (k₁+k₂+k₃+k₄)² = 2(k₁²+k₂²+k₃²+k₄²). This lets us compute each new circle algebraically—no geometry needed!</p>
                </div>
                <div class="exp-card">
                    <h4>Which Integers Appear?</h4>
                    <p>In a primitive integral packing, which integers show up as curvatures? The "local-global conjecture" predicted any sufficiently large integer would appear. In 2023, this was DISPROVED—some integers are mysteriously absent!</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;

        let maxDepth = 6;
        let minRadius = 2;
        let showCurvature = true;
        let circleCount = 0;
        let animating = false;
        let animationCircles = [];
        let animationIndex = 0;

        // Initial curvatures (negative for outer circle)
        let k1 = -1, k2 = 2, k3 = 2, k4 = 3;

        // Circle representation: center (complex) and curvature
        class Circle {
            constructor(x, y, k) {
                this.x = x;
                this.y = y;
                this.k = k; // curvature = 1/radius (negative for outer)
                this.r = Math.abs(1 / k);
            }
        }

        // Descartes Circle Theorem
        // Given three mutually tangent circles, find the fourth
        function descartesK(k1, k2, k3) {
            // k4 = k1 + k2 + k3 + 2*sqrt(k1*k2 + k2*k3 + k3*k1)
            // or k4 = k1 + k2 + k3 - 2*sqrt(k1*k2 + k2*k3 + k3*k1)
            const sum = k1 + k2 + k3;
            const disc = Math.sqrt(k1*k2 + k2*k3 + k3*k1);
            return [sum + 2*disc, sum - 2*disc];
        }

        // Find center of fourth circle given three circles
        function descartesCenter(c1, c2, c3, k4) {
            // Complex center formula
            const z1 = { re: c1.x * c1.k, im: c1.y * c1.k };
            const z2 = { re: c2.x * c2.k, im: c2.y * c2.k };
            const z3 = { re: c3.x * c3.k, im: c3.y * c3.k };

            const sum = { re: z1.re + z2.re + z3.re, im: z1.im + z2.im + z3.im };

            // sqrt(z1*z2 + z2*z3 + z3*z1)
            const prod12 = { re: z1.re*z2.re - z1.im*z2.im, im: z1.re*z2.im + z1.im*z2.re };
            const prod23 = { re: z2.re*z3.re - z2.im*z3.im, im: z2.re*z3.im + z2.im*z3.re };
            const prod31 = { re: z3.re*z1.re - z3.im*z1.im, im: z3.re*z1.im + z3.im*z1.re };

            const prodSum = {
                re: prod12.re + prod23.re + prod31.re,
                im: prod12.im + prod23.im + prod31.im
            };

            const sqrtProd = complexSqrt(prodSum);

            // Two possible centers
            const centers = [
                { re: (sum.re + 2*sqrtProd.re) / k4, im: (sum.im + 2*sqrtProd.im) / k4 },
                { re: (sum.re - 2*sqrtProd.re) / k4, im: (sum.im - 2*sqrtProd.im) / k4 }
            ];

            return centers;
        }

        function complexSqrt(z) {
            const r = Math.sqrt(z.re*z.re + z.im*z.im);
            const theta = Math.atan2(z.im, z.re);
            const sqrtR = Math.sqrt(r);
            return {
                re: sqrtR * Math.cos(theta/2),
                im: sqrtR * Math.sin(theta/2)
            };
        }

        // Check if circle is valid (inside bounding and doesn't overlap too much)
        function isValidCircle(newCircle, existing, minR) {
            if (newCircle.r < minR) return false;
            if (isNaN(newCircle.x) || isNaN(newCircle.y) || isNaN(newCircle.r)) return false;

            // Check it's not too far outside
            const dist = Math.sqrt(newCircle.x*newCircle.x + newCircle.y*newCircle.y);
            if (dist > width/2 + newCircle.r) return false;

            return true;
        }

        // Initialize with four mutually tangent circles
        function initializeGasket(k1, k2, k3, k4) {
            const scale = 200; // Scale factor

            // Outer circle (negative curvature means contains others)
            const r1 = Math.abs(scale / k1);
            const c1 = new Circle(0, 0, k1 / scale);

            // Three inner circles - need to solve for positions
            const r2 = scale / k2;
            const r3 = scale / k3;
            const r4 = scale / k4;

            // Place c2 at top
            const c2 = new Circle(0, r1 - r2, k2 / scale);

            // Place c3 and c4 tangent to c1 and c2
            // Using geometry for initial placement
            const d12 = r1 - r2; // c1 to c2 distance (internal tangent)
            const d13 = r1 - r3;
            const d23 = r2 + r3;

            // c3 position using law of cosines
            const cosA = (d12*d12 + d13*d13 - d23*d23) / (2*d12*d13);
            const sinA = Math.sqrt(1 - cosA*cosA);

            const c3 = new Circle(-d13 * sinA, d13 * cosA - r1 + r3 + (r1 - r3) * (1 - cosA), k3 / scale);

            // For c4, similar calculation
            const d14 = r1 - r4;
            const d24 = r2 + r4;
            const cosB = (d12*d12 + d14*d14 - d24*d24) / (2*d12*d14);
            const sinB = Math.sqrt(1 - cosB*cosB);

            const c4 = new Circle(d14 * sinB, d14 * cosB - r1 + r4 + (r1 - r4) * (1 - cosB), k4 / scale);

            return [c1, c2, c3, c4];
        }

        // Generate all circles recursively
        function generateGasket(circles, depth = 0) {
            if (depth >= maxDepth) return [];

            const newCircles = [];
            const processed = new Set();

            // For each triplet of mutually tangent circles, find the fourth
            for (let i = 0; i < circles.length; i++) {
                for (let j = i + 1; j < circles.length; j++) {
                    for (let l = j + 1; l < circles.length; l++) {
                        const c1 = circles[i];
                        const c2 = circles[j];
                        const c3 = circles[l];

                        // Check if they're mutually tangent (approximately)
                        if (!areTangent(c1, c2) || !areTangent(c2, c3) || !areTangent(c1, c3)) continue;

                        // Find fourth curvature
                        const k4s = descartesK(c1.k, c2.k, c3.k);

                        for (const k4 of k4s) {
                            if (Math.abs(k4) < 0.0001) continue;

                            const centers = descartesCenter(c1, c2, c3, k4);

                            for (const center of centers) {
                                const newCircle = new Circle(center.re, center.im, k4);

                                // Check if valid and not duplicate
                                const key = `${Math.round(center.re*100)},${Math.round(center.im*100)},${Math.round(k4*1000)}`;
                                if (processed.has(key)) continue;

                                if (isValidCircle(newCircle, circles.concat(newCircles), minRadius / 200)) {
                                    // Check it's actually tangent to all three
                                    if (areTangent(newCircle, c1) && areTangent(newCircle, c2) && areTangent(newCircle, c3)) {
                                        newCircles.push(newCircle);
                                        processed.add(key);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (newCircles.length > 0) {
                return newCircles.concat(generateGasket(circles.concat(newCircles), depth + 1));
            }

            return newCircles;
        }

        function areTangent(c1, c2) {
            const dist = Math.sqrt((c1.x - c2.x)**2 + (c1.y - c2.y)**2);
            const sumR = c1.r + c2.r;
            const diffR = Math.abs(c1.r - c2.r);

            // Externally tangent or internally tangent
            return Math.abs(dist - sumR) < 0.01 || Math.abs(dist - diffR) < 0.01;
        }

        function drawCircle(c, color = '#e94560') {
            const screenX = centerX + c.x * 200;
            const screenY = centerY - c.y * 200;
            const screenR = c.r * 200;

            if (screenR < 0.5) return;

            ctx.strokeStyle = color;
            ctx.lineWidth = Math.max(0.5, Math.min(2, screenR / 20));
            ctx.beginPath();
            ctx.arc(screenX, screenY, screenR, 0, Math.PI * 2);
            ctx.stroke();

            // Show curvature
            if (showCurvature && screenR > 15) {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                ctx.font = `${Math.min(12, screenR / 3)}px monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const curvText = Math.abs(Math.round(c.k * 200));
                if (curvText > 0 && curvText < 1000) {
                    ctx.fillText(curvText.toString(), screenX, screenY);
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, width, height);

            const initial = initializeGasket(k1, k2, k3, k4);
            const allCircles = initial.concat(generateGasket(initial));

            circleCount = 0;

            // Draw all circles
            allCircles.forEach((c, i) => {
                const hue = (i * 30) % 360;
                const color = `hsl(${hue}, 70%, 60%)`;
                drawCircle(c, color);
                circleCount++;
            });

            document.getElementById('circleCount').textContent = circleCount.toLocaleString();
        }

        function animateDraw() {
            if (!animating) return;

            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, width, height);

            // Draw circles up to current index
            for (let i = 0; i <= animationIndex && i < animationCircles.length; i++) {
                const c = animationCircles[i];
                const hue = (i * 30) % 360;
                const color = `hsl(${hue}, 70%, 60%)`;
                drawCircle(c, color);
            }

            document.getElementById('circleCount').textContent = Math.min(animationIndex + 1, animationCircles.length).toLocaleString();

            animationIndex++;

            if (animationIndex < animationCircles.length) {
                requestAnimationFrame(animateDraw);
            } else {
                animating = false;
                document.getElementById('animateBtn').textContent = 'Animate';
            }
        }

        // Event handlers
        document.getElementById('regenerateBtn').addEventListener('click', () => {
            if (animating) {
                animating = false;
            }
            draw();
        });

        document.getElementById('animateBtn').addEventListener('click', () => {
            animating = !animating;
            document.getElementById('animateBtn').textContent = animating ? 'Stop' : 'Animate';

            if (animating) {
                const initial = initializeGasket(k1, k2, k3, k4);
                animationCircles = initial.concat(generateGasket(initial));
                animationIndex = 0;
                animateDraw();
            }
        });

        document.getElementById('depthSlider').addEventListener('input', (e) => {
            maxDepth = parseInt(e.target.value);
            document.getElementById('depthValue').textContent = maxDepth;
            if (!animating) draw();
        });

        document.getElementById('minRadSlider').addEventListener('input', (e) => {
            minRadius = parseInt(e.target.value);
            document.getElementById('minRadValue').textContent = minRadius;
            if (!animating) draw();
        });

        document.getElementById('showCurvature').addEventListener('change', (e) => {
            showCurvature = e.target.checked;
            if (!animating) draw();
        });

        // Preset buttons
        document.querySelectorAll('[data-curvatures]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-curvatures]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                const curv = btn.dataset.curvatures.split(',').map(Number);
                [k1, k2, k3, k4] = curv;

                document.getElementById('initCurvatures').textContent = `(${curv.join(', ')})`;

                if (!animating) draw();
            });
        });

        // Initial draw
        draw();
    </script>
</body>
</html>
