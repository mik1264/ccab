<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hénon Map - A Discrete Strange Attractor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0d0d1a 0%, #1a1a2e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }
        .back-link {
            display: inline-flex;
            align-items: center;
            color: #8ab4f8;
            text-decoration: none;
            margin-bottom: 15px;
            font-size: 0.95em;
        }
        .back-link:hover {
            color: #aecbfa;
            text-decoration: underline;
        }
        h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
            color: #fff;
            text-shadow: 0 0 30px rgba(255, 107, 157, 0.5);
        }
        .subtitle {
            color: #9aa0a6;
            margin-bottom: 20px;
            font-size: 1.05em;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
        }
        .canvas-container {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 15px;
        }
        canvas {
            display: block;
            width: 100%;
            border-radius: 8px;
            background: #000;
        }
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .panel {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .panel h3 {
            font-size: 0.9em;
            color: #ff6b9d;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all 0.2s;
        }
        .btn-primary {
            background: linear-gradient(135deg, #ff6b9d, #c44569);
            color: white;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 107, 157, 0.4);
        }
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
        }
        .btn-secondary.active {
            background: rgba(255, 107, 157, 0.3);
            border-color: #ff6b9d;
            color: #ff6b9d;
        }
        .param-group {
            margin-bottom: 15px;
        }
        .param-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .param-name {
            color: #b0b0b0;
            font-size: 0.85em;
        }
        .param-value {
            color: #ffd54f;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.9em;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.1);
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ff6b9d;
            cursor: pointer;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .stat-label {
            color: #9aa0a6;
            font-size: 0.85em;
        }
        .stat-value {
            color: #ffd54f;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.9em;
        }
        .preset-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        .mode-toggle {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .exp-section {
            margin-top: 20px;
        }
        .exp-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
        }
        .exp-card {
            background: linear-gradient(135deg, rgba(255,107,157,0.1), rgba(196,69,105,0.05));
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255,107,157,0.2);
        }
        .exp-card h4 {
            color: #ff6b9d;
            margin-bottom: 8px;
            font-size: 0.95em;
        }
        .exp-card p {
            font-size: 0.85em;
            line-height: 1.6;
            color: #b0b0b0;
        }
        .formula {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 6px;
            font-family: 'Monaco', 'Consolas', monospace;
            margin: 8px 0;
            text-align: center;
            color: #ffd54f;
            font-size: 0.9em;
        }
        .zoom-info {
            font-size: 0.8em;
            color: #9aa0a6;
            margin-top: 8px;
        }
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Paradoxes</a>
        <h1>The Hénon Map</h1>
        <p class="subtitle">A Discrete Strange Attractor with Fractal Structure</p>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="mainCanvas"></canvas>
                <p class="zoom-info">Click and drag to zoom. Scroll to zoom in/out. Double-click to reset.</p>
            </div>

            <div class="sidebar">
                <div class="panel">
                    <h3>Controls</h3>
                    <div class="controls">
                        <button class="btn btn-primary" id="resetBtn">Reset View</button>
                        <button class="btn btn-secondary" id="animateBtn">Animate</button>
                    </div>
                    <div class="mode-toggle">
                        <button class="btn btn-secondary active" data-mode="attractor">Attractor</button>
                        <button class="btn btn-secondary" data-mode="basin">Basin</button>
                    </div>
                </div>

                <div class="panel">
                    <h3>Parameters</h3>
                    <div class="param-group">
                        <div class="param-label">
                            <span class="param-name">a (stretching)</span>
                            <span class="param-value" id="aValue">1.4</span>
                        </div>
                        <input type="range" id="aSlider" min="0.5" max="1.6" step="0.01" value="1.4">
                    </div>
                    <div class="param-group">
                        <div class="param-label">
                            <span class="param-name">b (contraction)</span>
                            <span class="param-value" id="bValue">0.3</span>
                        </div>
                        <input type="range" id="bSlider" min="0" max="0.5" step="0.01" value="0.3">
                    </div>
                </div>

                <div class="panel">
                    <h3>Presets</h3>
                    <div class="preset-grid">
                        <button class="btn btn-secondary" data-a="1.4" data-b="0.3">Classic (1.4, 0.3)</button>
                        <button class="btn btn-secondary" data-a="1.2" data-b="0.3">Period-7</button>
                        <button class="btn btn-secondary" data-a="1.06" data-b="0.3">Period-2</button>
                        <button class="btn btn-secondary" data-a="0.9" data-b="0.3">Fixed Point</button>
                        <button class="btn btn-secondary" data-a="1.35" data-b="0.21">Thin Chaos</button>
                        <button class="btn btn-secondary" data-a="1.4" data-b="0.0">1D Map</button>
                    </div>
                </div>

                <div class="panel">
                    <h3>Statistics</h3>
                    <div class="stat-row">
                        <span class="stat-label">Points plotted</span>
                        <span id="pointCount" class="stat-value">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Fractal dimension</span>
                        <span class="stat-value">~1.26</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Lyapunov exponent</span>
                        <span class="stat-value">~0.42</span>
                    </div>
                </div>

                <div class="panel">
                    <h3>Fixed Points</h3>
                    <div class="stat-row">
                        <span class="stat-label">Saddle</span>
                        <span id="fp1" class="stat-value">(0.631, 0.189)</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Repeller</span>
                        <span id="fp2" class="stat-value">(-1.131, -0.339)</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="exp-section">
            <div class="exp-cards">
                <div class="exp-card">
                    <h4>The Equations</h4>
                    <div class="formula">
                        x<sub>n+1</sub> = 1 - ax<sub>n</sub>² + y<sub>n</sub><br>
                        y<sub>n+1</sub> = bx<sub>n</sub>
                    </div>
                    <p>Introduced by Michel Hénon (1976) as a simplified model for the Poincaré section of the Lorenz system. These two equations generate infinite complexity.</p>
                </div>
                <div class="exp-card">
                    <h4>Strange Attractor</h4>
                    <p>For a=1.4, b=0.3, points neither escape to infinity nor settle to a fixed point. Instead, they trace out a FRACTAL structure—smooth in one direction, a Cantor set in another. Zoom in and the detail is infinite!</p>
                </div>
                <div class="exp-card">
                    <h4>Stretch and Fold</h4>
                    <p>Parameter 'a' controls stretching (chaotic mixing), 'b' controls folding (contraction). The attractor emerges from this eternal dance: stretch, fold, stretch, fold—creating layered structure without self-intersections.</p>
                </div>
                <div class="exp-card">
                    <h4>Basin of Attraction</h4>
                    <p>Not all starting points reach the attractor! Some escape to infinity. The boundary between these regions is itself a fractal—infinitely complex, sensitive to the tiniest perturbation. Switch to "Basin" mode to see this.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        // High DPI setup
        function setupCanvas() {
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            return { width: rect.width, height: rect.height };
        }

        // Parameters
        let a = 1.4;
        let b = 0.3;

        // View bounds
        let view = {
            xMin: -1.5,
            xMax: 1.5,
            yMin: -0.5,
            yMax: 0.5
        };

        const defaultView = { ...view };

        // Mode
        let mode = 'attractor';
        let animating = false;
        let animationId = null;

        // Hénon map iteration
        function henon(x, y) {
            return {
                x: 1 - a * x * x + y,
                y: b * x
            };
        }

        // Calculate fixed points
        function getFixedPoints() {
            // Solve: x = 1 - ax² + bx
            // ax² + x(1-b) - 1 = 0
            const c1 = a;
            const c2 = 1 - b;
            const c3 = -1;

            const discriminant = c2 * c2 - 4 * c1 * c3;
            if (discriminant < 0) return [];

            const sqrtD = Math.sqrt(discriminant);
            const x1 = (-c2 + sqrtD) / (2 * c1);
            const x2 = (-c2 - sqrtD) / (2 * c1);

            return [
                { x: x1, y: b * x1 },
                { x: x2, y: b * x2 }
            ];
        }

        // Map coordinates
        function toScreen(x, y, width, height) {
            return {
                px: (x - view.xMin) / (view.xMax - view.xMin) * width,
                py: (1 - (y - view.yMin) / (view.yMax - view.yMin)) * height
            };
        }

        function fromScreen(px, py, width, height) {
            return {
                x: view.xMin + (px / width) * (view.xMax - view.xMin),
                y: view.yMin + (1 - py / height) * (view.yMax - view.yMin)
            };
        }

        // Draw attractor
        function drawAttractor() {
            const { width, height } = setupCanvas();

            // Clear
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, width, height);

            // Draw axes
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;

            // Origin lines if in view
            if (view.xMin < 0 && view.xMax > 0) {
                const { px } = toScreen(0, 0, width, height);
                ctx.beginPath();
                ctx.moveTo(px, 0);
                ctx.lineTo(px, height);
                ctx.stroke();
            }
            if (view.yMin < 0 && view.yMax > 0) {
                const { py } = toScreen(0, 0, width, height);
                ctx.beginPath();
                ctx.moveTo(0, py);
                ctx.lineTo(width, py);
                ctx.stroke();
            }

            // Iterate and plot
            const numPoints = 100000;
            const skip = 100;

            let x = 0.1;
            let y = 0.1;

            // Skip transient
            for (let i = 0; i < skip; i++) {
                const next = henon(x, y);
                x = next.x;
                y = next.y;
                if (Math.abs(x) > 10 || Math.abs(y) > 10) {
                    x = 0.1;
                    y = 0.1;
                }
            }

            // Create image data for fast rendering
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            let plotted = 0;
            for (let i = 0; i < numPoints; i++) {
                const next = henon(x, y);
                x = next.x;
                y = next.y;

                // Check for escape
                if (Math.abs(x) > 10 || Math.abs(y) > 10) {
                    x = 0.1 + Math.random() * 0.01;
                    y = 0.1 + Math.random() * 0.01;
                    continue;
                }

                if (x >= view.xMin && x <= view.xMax && y >= view.yMin && y <= view.yMax) {
                    const { px, py } = toScreen(x, y, width, height);
                    const ix = Math.floor(px);
                    const iy = Math.floor(py);

                    if (ix >= 0 && ix < width && iy >= 0 && iy < height) {
                        const idx = (iy * width + ix) * 4;
                        data[idx] = Math.min(255, data[idx] + 50);     // R
                        data[idx + 1] = Math.min(255, data[idx + 1] + 25); // G
                        data[idx + 2] = Math.min(255, data[idx + 2] + 80); // B
                        data[idx + 3] = 255; // A
                        plotted++;
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw fixed points
            const fps = getFixedPoints();
            fps.forEach((fp, i) => {
                if (fp.x >= view.xMin && fp.x <= view.xMax && fp.y >= view.yMin && fp.y <= view.yMax) {
                    const { px, py } = toScreen(fp.x, fp.y, width, height);
                    ctx.fillStyle = i === 0 ? '#4ade80' : '#f87171';
                    ctx.beginPath();
                    ctx.arc(px, py, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            document.getElementById('pointCount').textContent = plotted.toLocaleString();

            // Update fixed point display
            if (fps.length >= 2) {
                document.getElementById('fp1').textContent = `(${fps[0].x.toFixed(3)}, ${fps[0].y.toFixed(3)})`;
                document.getElementById('fp2').textContent = `(${fps[1].x.toFixed(3)}, ${fps[1].y.toFixed(3)})`;
            }
        }

        // Draw basin of attraction
        function drawBasin() {
            const { width, height } = setupCanvas();

            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, width, height);

            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            const maxIter = 100;
            const escapeRadius = 10;

            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const { x: x0, y: y0 } = fromScreen(px, py, width, height);

                    let x = x0;
                    let y = y0;
                    let escaped = false;
                    let iter = 0;

                    for (iter = 0; iter < maxIter; iter++) {
                        const next = henon(x, y);
                        x = next.x;
                        y = next.y;

                        if (Math.abs(x) > escapeRadius || Math.abs(y) > escapeRadius) {
                            escaped = true;
                            break;
                        }
                    }

                    const idx = (py * width + px) * 4;

                    if (escaped) {
                        // Color by escape time
                        const t = iter / maxIter;
                        data[idx] = Math.floor(30 + 60 * t);     // R
                        data[idx + 1] = Math.floor(20 + 40 * t); // G
                        data[idx + 2] = Math.floor(50 + 100 * t); // B
                    } else {
                        // In basin - bright
                        data[idx] = 255;
                        data[idx + 1] = 107;
                        data[idx + 2] = 157;
                    }
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
            document.getElementById('pointCount').textContent = (width * height).toLocaleString();
        }

        // Animation
        let animX = 0.1;
        let animY = 0.1;
        let trail = [];

        function animate() {
            if (!animating) return;

            const { width, height } = setupCanvas();

            // Semi-transparent clear for trail effect
            ctx.fillStyle = 'rgba(10, 10, 26, 0.1)';
            ctx.fillRect(0, 0, width, height);

            // Iterate
            for (let i = 0; i < 10; i++) {
                const next = henon(animX, animY);
                animX = next.x;
                animY = next.y;

                if (Math.abs(animX) > 10) {
                    animX = 0.1;
                    animY = 0.1;
                    trail = [];
                }

                trail.push({ x: animX, y: animY });
                if (trail.length > 5000) trail.shift();
            }

            // Draw trail
            for (let i = 0; i < trail.length; i++) {
                const p = trail[i];
                if (p.x >= view.xMin && p.x <= view.xMax && p.y >= view.yMin && p.y <= view.yMax) {
                    const { px, py } = toScreen(p.x, p.y, width, height);
                    const alpha = i / trail.length;
                    ctx.fillStyle = `rgba(255, 107, 157, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(px, py, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Current point
            if (animX >= view.xMin && animX <= view.xMax && animY >= view.yMin && animY <= view.yMax) {
                const { px, py } = toScreen(animX, animY, width, height);
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(px, py, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            animationId = requestAnimationFrame(animate);
        }

        function draw() {
            if (mode === 'attractor') {
                drawAttractor();
            } else {
                drawBasin();
            }
        }

        // Event handlers
        const aSlider = document.getElementById('aSlider');
        const bSlider = document.getElementById('bSlider');

        aSlider.addEventListener('input', () => {
            a = parseFloat(aSlider.value);
            document.getElementById('aValue').textContent = a.toFixed(2);
            if (!animating) draw();
        });

        bSlider.addEventListener('input', () => {
            b = parseFloat(bSlider.value);
            document.getElementById('bValue').textContent = b.toFixed(2);
            if (!animating) draw();
        });

        // Mode toggle
        document.querySelectorAll('[data-mode]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-mode]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                mode = btn.dataset.mode;
                if (animating) {
                    animating = false;
                    cancelAnimationFrame(animationId);
                    document.getElementById('animateBtn').textContent = 'Animate';
                }
                draw();
            });
        });

        // Presets
        document.querySelectorAll('[data-a]').forEach(btn => {
            btn.addEventListener('click', () => {
                a = parseFloat(btn.dataset.a);
                b = parseFloat(btn.dataset.b);
                aSlider.value = a;
                bSlider.value = b;
                document.getElementById('aValue').textContent = a.toFixed(2);
                document.getElementById('bValue').textContent = b.toFixed(2);
                view = { ...defaultView };
                if (!animating) draw();
            });
        });

        // Reset button
        document.getElementById('resetBtn').addEventListener('click', () => {
            view = { ...defaultView };
            draw();
        });

        // Animate button
        document.getElementById('animateBtn').addEventListener('click', () => {
            animating = !animating;
            document.getElementById('animateBtn').textContent = animating ? 'Stop' : 'Animate';

            if (animating) {
                animX = 0.1;
                animY = 0.1;
                trail = [];
                animate();
            } else {
                cancelAnimationFrame(animationId);
                draw();
            }
        });

        // Zoom with mouse
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let dragEnd = { x: 0, y: 0 };

        canvas.addEventListener('mousedown', (e) => {
            if (animating) return;
            const rect = canvas.getBoundingClientRect();
            dragStart = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            dragEnd = { ...dragStart };
            isDragging = true;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging || animating) return;
            const rect = canvas.getBoundingClientRect();
            dragEnd = { x: e.clientX - rect.left, y: e.clientY - rect.top };

            // Draw selection rectangle
            draw();
            ctx.strokeStyle = 'rgba(255, 107, 157, 0.8)';
            ctx.fillStyle = 'rgba(255, 107, 157, 0.1)';
            ctx.lineWidth = 2;
            const x = Math.min(dragStart.x, dragEnd.x);
            const y = Math.min(dragStart.y, dragEnd.y);
            const w = Math.abs(dragEnd.x - dragStart.x);
            const h = Math.abs(dragEnd.y - dragStart.y);
            ctx.fillRect(x, y, w, h);
            ctx.strokeRect(x, y, w, h);
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!isDragging || animating) return;
            isDragging = false;

            const rect = canvas.getBoundingClientRect();
            dragEnd = { x: e.clientX - rect.left, y: e.clientY - rect.top };

            const dist = Math.sqrt(
                Math.pow(dragEnd.x - dragStart.x, 2) +
                Math.pow(dragEnd.y - dragStart.y, 2)
            );

            if (dist > 10) {
                const { width, height } = { width: rect.width, height: rect.height };
                const x1 = Math.min(dragStart.x, dragEnd.x);
                const x2 = Math.max(dragStart.x, dragEnd.x);
                const y1 = Math.min(dragStart.y, dragEnd.y);
                const y2 = Math.max(dragStart.y, dragEnd.y);

                const newView = {
                    xMin: view.xMin + (x1 / width) * (view.xMax - view.xMin),
                    xMax: view.xMin + (x2 / width) * (view.xMax - view.xMin),
                    yMax: view.yMin + (1 - y1 / height) * (view.yMax - view.yMin),
                    yMin: view.yMin + (1 - y2 / height) * (view.yMax - view.yMin)
                };

                view = newView;
            }

            draw();
        });

        canvas.addEventListener('dblclick', () => {
            view = { ...defaultView };
            draw();
        });

        canvas.addEventListener('wheel', (e) => {
            if (animating) return;
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const { x: mx, y: my } = fromScreen(mouseX, mouseY, rect.width, rect.height);

            const factor = e.deltaY > 0 ? 1.2 : 0.8;

            view.xMin = mx + (view.xMin - mx) * factor;
            view.xMax = mx + (view.xMax - mx) * factor;
            view.yMin = my + (view.yMin - my) * factor;
            view.yMax = my + (view.yMax - my) * factor;

            draw();
        });

        // Resize handler
        window.addEventListener('resize', draw);

        // Initial draw
        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
