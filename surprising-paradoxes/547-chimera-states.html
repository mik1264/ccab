<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chimera States - Order and Chaos Coexisting | Surprising Paradoxes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #0d1f2d 0%, #1a3d4d 50%, #0a1a25 100%);
            color: #e0f0f8;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #4dd0e1;
            text-decoration: none;
            font-size: 14px;
            z-index: 1000;
            padding: 8px 16px;
            background: rgba(10, 26, 37, 0.9);
            border-radius: 20px;
            border: 1px solid rgba(77, 208, 225, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(77, 208, 225, 0.2);
            border-color: #4dd0e1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 80px 20px 40px;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(135deg, #4dd0e1, #ff7043, #4dd0e1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #80deea;
            font-size: 1.2em;
            font-style: italic;
        }

        .paradox-box {
            background: linear-gradient(135deg, rgba(77, 208, 225, 0.15), rgba(255, 112, 67, 0.1));
            border: 2px solid rgba(77, 208, 225, 0.4);
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
            text-align: center;
        }

        .paradox-box h3 {
            color: #ff7043;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .paradox-box p {
            font-size: 1.15em;
            line-height: 1.7;
            color: #e0f7fa;
        }

        .simulation-area {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 30px;
            margin: 40px 0;
        }

        @media (max-width: 1000px) {
            .simulation-area {
                grid-template-columns: 1fr;
            }
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(77, 208, 225, 0.2);
        }

        .canvas-wrapper {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        canvas {
            display: block;
            width: 100%;
            border-radius: 10px;
        }

        #ringCanvas {
            background: #0a0a15;
        }

        #phaseCanvas {
            background: #0a0a15;
            height: 150px;
        }

        .controls {
            background: rgba(10, 26, 37, 0.8);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(77, 208, 225, 0.2);
        }

        .controls h3 {
            color: #4dd0e1;
            margin-bottom: 20px;
            font-size: 1.2em;
            border-bottom: 1px solid rgba(77, 208, 225, 0.3);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: #80deea;
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #00695c, #26a69a, #4dd0e1);
            border-radius: 4px;
            outline: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #ff7043;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 112, 67, 0.5);
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .preset-btn {
            padding: 12px 8px;
            font-size: 0.85em;
            border: 1px solid rgba(77, 208, 225, 0.5);
            background: rgba(10, 26, 37, 0.8);
            color: #e0f0f8;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .preset-btn.active {
            background: linear-gradient(135deg, rgba(77, 208, 225, 0.3), rgba(255, 112, 67, 0.2));
            border-color: #ff7043;
        }

        .preset-btn:hover {
            background: rgba(77, 208, 225, 0.2);
        }

        .stats-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(77, 208, 225, 0.1);
            font-size: 0.9em;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #26a69a;
        }

        .stat-value {
            color: #ff7043;
            font-weight: bold;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            font-size: 0.85em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .legend-dot.sync {
            background: #4dd0e1;
        }

        .legend-dot.async {
            background: #ff7043;
        }

        .essay {
            background: rgba(10, 26, 37, 0.6);
            border-radius: 15px;
            padding: 40px;
            margin-top: 40px;
            line-height: 1.9;
        }

        .essay h2 {
            color: #4dd0e1;
            margin: 30px 0 20px;
            font-size: 1.5em;
        }

        .essay h2:first-child {
            margin-top: 0;
        }

        .essay p {
            margin-bottom: 20px;
            color: #b2ebf2;
            text-align: justify;
        }

        .essay strong {
            color: #ff7043;
        }

        .essay em {
            color: #80cbc4;
            font-style: italic;
        }

        .highlight-stat {
            display: inline-block;
            background: linear-gradient(135deg, rgba(255, 112, 67, 0.2), rgba(77, 208, 225, 0.2));
            padding: 2px 10px;
            border-radius: 4px;
            color: #ffab91;
            font-weight: bold;
        }

        .analogy-cards {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 30px 0;
        }

        @media (max-width: 768px) {
            .analogy-cards {
                grid-template-columns: 1fr;
            }
        }

        .analogy-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(77, 208, 225, 0.2);
        }

        .analogy-card h4 {
            color: #4dd0e1;
            margin-bottom: 10px;
        }

        .analogy-card p {
            font-size: 0.9em;
            color: #78909c;
            margin: 0;
        }

        .analogy-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        footer {
            text-align: center;
            padding: 40px 20px;
            color: #546e7a;
            font-size: 0.9em;
        }

        footer a {
            color: #4dd0e1;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>üåÄ Chimera States</h1>
            <p class="subtitle">When Identical Oscillators Choose Different Fates</p>
        </header>

        <div class="paradox-box">
            <h3>‚ö° The Synchronization Paradox</h3>
            <p>
                Take a ring of <strong>perfectly identical oscillators</strong>, coupled in exactly the same way.
                Logic says they should either all synchronize together or all oscillate independently. Yet
                something impossible happens: they spontaneously split into <strong>synchronized and
                unsynchronized regions</strong>‚Äîorder and chaos coexisting in the same system. Named after
                the mythological creature with a lion's head, goat's body, and serpent's tail‚Äîmultiple
                identities in one being.
            </p>
        </div>

        <div class="simulation-area">
            <div class="canvas-container">
                <div class="canvas-wrapper">
                    <canvas id="ringCanvas"></canvas>
                    <canvas id="phaseCanvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-dot sync"></div>
                            <span>Synchronized</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot async"></div>
                            <span>Desynchronized</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="controls">
                <h3>üîß Oscillator Parameters</h3>

                <div class="control-group">
                    <label>Coupling Range (r): <span id="rangeValue">0.35</span></label>
                    <input type="range" id="rangeSlider" min="0.1" max="0.5" step="0.01" value="0.35">
                </div>

                <div class="control-group">
                    <label>Coupling Strength (K): <span id="strengthValue">0.10</span></label>
                    <input type="range" id="strengthSlider" min="0.01" max="0.3" step="0.01" value="0.10">
                </div>

                <div class="control-group">
                    <label>Number of Oscillators: <span id="countValue">100</span></label>
                    <input type="range" id="countSlider" min="50" max="200" value="100">
                </div>

                <div class="control-group">
                    <label>Initial Condition</label>
                    <div class="preset-buttons">
                        <button class="preset-btn active" data-preset="chimera">ü¶Å Chimera</button>
                        <button class="preset-btn" data-preset="sync">üîÑ Full Sync</button>
                        <button class="preset-btn" data-preset="random">üé≤ Random</button>
                        <button class="preset-btn" data-preset="gradient">üìà Gradient</button>
                    </div>
                </div>

                <div class="stats-panel">
                    <div class="stat-row">
                        <span class="stat-label">Order Parameter (R)</span>
                        <span class="stat-value" id="orderParam">0.50</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Sync Region</span>
                        <span class="stat-value" id="syncRegion">45%</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Async Region</span>
                        <span class="stat-value" id="asyncRegion">55%</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">State Type</span>
                        <span class="stat-value" id="stateType">Chimera</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="essay">
            <h2>The Myth Made Real</h2>
            <p>
                In Greek mythology, the Chimera was a fire-breathing monster with a lion's head, a goat's
                body, and a serpent's tail‚Äîa creature of impossible combinations. In 2002, physicists
                Yoshiki Kuramoto and Dorjsuren Battogtokh discovered that real dynamical systems could
                embody this mythological absurdity. They found that networks of <strong>identical
                oscillators</strong>, all governed by the same equations and coupled symmetrically, could
                spontaneously split into groups with completely different behavior: some marching in
                lockstep while others wander chaotically. The chimera state was born.
            </p>

            <h2>Why Is This Impossible?</h2>
            <p>
                Consider a ring of metronomes, all identical, all connected to their neighbors in exactly
                the same way. Classical intuition, built on decades of studying synchronization, says
                there are only two possible outcomes. Either the coupling is strong enough and all
                metronomes will eventually synchronize‚Äîticking together in perfect unison. Or the coupling
                is too weak, and they'll all tick independently, their phases drifting randomly. The
                symmetry of the system <em>demands</em> a symmetric outcome. What Kuramoto found was that
                the system could <strong>spontaneously break its own symmetry</strong>‚Äîchoosing to be
                synchronized in one region and chaotic in another, even though nothing distinguishes
                the oscillators themselves.
            </p>

            <div class="analogy-cards">
                <div class="analogy-card">
                    <div class="analogy-icon">üß†</div>
                    <h4>Neural Sleep</h4>
                    <p>During "unihemispheric sleep," dolphins keep half their brain awake while the other half sleeps‚Äîa biological chimera.</p>
                </div>
                <div class="analogy-card">
                    <div class="analogy-icon">üí°</div>
                    <h4>Power Grids</h4>
                    <p>Chimera-like states may explain partial blackouts where some regions fail while others remain stable.</p>
                </div>
                <div class="analogy-card">
                    <div class="analogy-icon">‚ù§Ô∏è</div>
                    <h4>Cardiac Rhythms</h4>
                    <p>Arrhythmias may involve chimera states where parts of the heart beat chaotically while others stay synchronized.</p>
                </div>
            </div>

            <h2>The Mathematics of Coexistence</h2>
            <p>
                The key to chimera states lies in <strong>nonlocal coupling</strong>. Unlike global
                coupling (where every oscillator feels every other equally) or local coupling (where
                only nearest neighbors interact), nonlocal coupling means each oscillator is influenced
                by a neighborhood of finite range. This creates a competition: local effects push toward
                coherence, but the finite range allows different regions to evolve independently. The
                result is a <em>stable coexistence</em> of order and disorder‚Äîneither winning, neither
                losing, locked in eternal balance.
            </p>

            <p>
                The mathematical description uses the <strong>Kuramoto model</strong>: each oscillator
                has a phase Œ∏ that evolves according to its natural frequency plus coupling to neighbors.
                The crucial parameter is the <em>coupling range</em> r‚Äîthe fraction of the ring that
                each oscillator "sees." When r is too small (local coupling), the system fully
                synchronizes. When r is 0.5 (global coupling), the system either syncs or doesn't.
                But at intermediate values‚Äîaround <span class="highlight-stat">r ‚âà 0.35</span>‚Äîchimera
                states emerge spontaneously.
            </p>

            <h2>From Theory to Reality</h2>
            <p>
                For years, chimera states remained theoretical curiosities. Critics wondered if they were
                merely mathematical artifacts that would never appear in real physical systems. Then in
                <span class="highlight-stat">2012</span>, researchers at the Max Planck Institute built
                actual mechanical oscillators‚Äîmetronome-like devices coupled by springs. They observed
                chimera states with their own eyes: half the metronomes ticking together, half ticking
                randomly, in a system with no fundamental difference between them. The impossible had
                become real.
            </p>

            <h2>The Deep Mystery</h2>
            <p>
                What makes chimera states so philosophically disturbing is that they challenge our
                intuitions about <strong>determinism and symmetry</strong>. If every oscillator is
                identical and every coupling is identical, why does one end up in the synchronized
                group while its neighbor ends up chaotic? The answer lies in <em>initial conditions</em>‚Äî
                tiny, unmeasurable differences in starting phases get amplified into macroscopic
                symmetry breaking. It's not that some oscillators are special; it's that the system
                can settle into multiple stable states, and tiny fluctuations decide which one.
            </p>

            <p>
                Today, chimera states are being explored in contexts from <strong>Josephson junction
                arrays</strong> to <strong>chemical oscillators</strong> to <strong>neural networks</strong>.
                They may explain phenomena as diverse as unihemispheric sleep (where one half of a
                dolphin's brain sleeps while the other stays awake) and fibrillation in the heart.
                The mythological monster, it turns out, was hiding in nature all along‚Äîwherever
                identical components choose, against all logic, to behave differently.
            </p>
        </div>

        <footer>
            <p>
                Sources:
                <a href="https://www.pnas.org/doi/10.1073/pnas.1302880110">PNAS - Mechanical Chimera States</a> |
                <a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC3696826/">PMC Research</a> |
                <a href="https://www.researchgate.net/publication/8195658_Chimera_States_for_Coupled_Oscillators">Kuramoto & Battogtokh 2002</a>
            </p>
        </footer>
    </div>

    <script>
        // Ring canvas
        const ringCanvas = document.getElementById('ringCanvas');
        const ringCtx = ringCanvas.getContext('2d');

        // Phase canvas
        const phaseCanvas = document.getElementById('phaseCanvas');
        const phaseCtx = phaseCanvas.getContext('2d');

        const dpr = window.devicePixelRatio || 1;

        // Parameters
        let N = 100; // Number of oscillators
        let r = 0.35; // Coupling range
        let K = 0.10; // Coupling strength
        let phases = [];
        let velocities = [];
        let naturalFreqs = [];
        let time = 0;

        function resizeCanvases() {
            const rect = ringCanvas.parentElement.getBoundingClientRect();
            const size = rect.width - 40;

            ringCanvas.width = size * dpr;
            ringCanvas.height = size * 0.8 * dpr;
            ringCanvas.style.width = size + 'px';
            ringCanvas.style.height = size * 0.8 + 'px';

            phaseCanvas.width = size * dpr;
            phaseCanvas.height = 150 * dpr;
            phaseCanvas.style.width = size + 'px';
            phaseCanvas.style.height = '150px';

            ringCtx.scale(dpr, dpr);
            phaseCtx.scale(dpr, dpr);
        }

        resizeCanvases();
        window.addEventListener('resize', () => {
            ringCtx.setTransform(1, 0, 0, 1, 0, 0);
            phaseCtx.setTransform(1, 0, 0, 1, 0, 0);
            resizeCanvases();
        });

        function initOscillators(preset) {
            phases = new Array(N);
            velocities = new Array(N).fill(0);
            naturalFreqs = new Array(N);

            // Natural frequencies with small spread
            for (let i = 0; i < N; i++) {
                naturalFreqs[i] = 1.0 + (Math.random() - 0.5) * 0.02;
            }

            switch (preset) {
                case 'chimera':
                    // Classic chimera initial condition
                    for (let i = 0; i < N; i++) {
                        const x = i / N;
                        if (x < 0.5) {
                            phases[i] = 6 * Math.exp(-30 * (x - 0.25) ** 2);
                        } else {
                            phases[i] = Math.random() * Math.PI * 2;
                        }
                    }
                    break;

                case 'sync':
                    // Start synchronized
                    for (let i = 0; i < N; i++) {
                        phases[i] = 0;
                    }
                    break;

                case 'random':
                    // Random phases
                    for (let i = 0; i < N; i++) {
                        phases[i] = Math.random() * Math.PI * 2;
                    }
                    break;

                case 'gradient':
                    // Linear gradient
                    for (let i = 0; i < N; i++) {
                        phases[i] = (i / N) * Math.PI * 4;
                    }
                    break;
            }
        }

        function updateOscillators(dt) {
            const newPhases = new Array(N);
            const couplingRange = Math.floor(N * r);

            for (let i = 0; i < N; i++) {
                let coupling = 0;

                // Sum over neighbors within range
                for (let j = -couplingRange; j <= couplingRange; j++) {
                    if (j === 0) continue;
                    const neighbor = (i + j + N) % N;
                    coupling += Math.sin(phases[neighbor] - phases[i]);
                }

                coupling *= K / (2 * couplingRange);

                // Update phase
                newPhases[i] = phases[i] + dt * (naturalFreqs[i] + coupling);
            }

            phases = newPhases;

            // Wrap phases to [0, 2œÄ]
            for (let i = 0; i < N; i++) {
                phases[i] = ((phases[i] % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
            }
        }

        function calculateOrderParameter() {
            // Local order parameter for each oscillator
            const localOrder = new Array(N);
            const windowSize = Math.floor(N * 0.1);

            for (let i = 0; i < N; i++) {
                let sumCos = 0;
                let sumSin = 0;

                for (let j = -windowSize; j <= windowSize; j++) {
                    const neighbor = (i + j + N) % N;
                    sumCos += Math.cos(phases[neighbor]);
                    sumSin += Math.sin(phases[neighbor]);
                }

                const count = 2 * windowSize + 1;
                localOrder[i] = Math.sqrt(sumCos ** 2 + sumSin ** 2) / count;
            }

            return localOrder;
        }

        function drawRing(w, h) {
            ringCtx.fillStyle = '#0a0a15';
            ringCtx.fillRect(0, 0, w, h);

            const cx = w / 2;
            const cy = h / 2;
            const radius = Math.min(w, h) * 0.35;

            const localOrder = calculateOrderParameter();

            // Draw connections (showing coupling range)
            ringCtx.strokeStyle = 'rgba(77, 208, 225, 0.05)';
            ringCtx.lineWidth = 0.5;
            const couplingRange = Math.floor(N * r);

            for (let i = 0; i < N; i += 5) {
                const angle1 = (i / N) * Math.PI * 2 - Math.PI / 2;
                const x1 = cx + Math.cos(angle1) * radius;
                const y1 = cy + Math.sin(angle1) * radius;

                for (let j = 1; j <= couplingRange; j += 3) {
                    const neighbor = (i + j) % N;
                    const angle2 = (neighbor / N) * Math.PI * 2 - Math.PI / 2;
                    const x2 = cx + Math.cos(angle2) * radius;
                    const y2 = cy + Math.sin(angle2) * radius;

                    ringCtx.beginPath();
                    ringCtx.moveTo(x1, y1);
                    ringCtx.lineTo(x2, y2);
                    ringCtx.stroke();
                }
            }

            // Draw oscillators on ring
            for (let i = 0; i < N; i++) {
                const angle = (i / N) * Math.PI * 2 - Math.PI / 2;
                const x = cx + Math.cos(angle) * radius;
                const y = cy + Math.sin(angle) * radius;

                // Color based on local order (synchronized = cyan, desynchronized = orange)
                const order = localOrder[i];
                const r = Math.floor(255 * (1 - order) * 0.9 + 77 * order);
                const g = Math.floor(112 * (1 - order) + 208 * order);
                const b = Math.floor(67 * (1 - order) + 225 * order);

                // Size based on phase
                const phase = phases[i];
                const size = 4 + Math.sin(phase) * 2;

                // Draw oscillator
                ringCtx.beginPath();
                ringCtx.arc(x, y, size, 0, Math.PI * 2);
                ringCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ringCtx.fill();

                // Draw phase indicator (like a pendulum bob)
                const indicatorLen = 12;
                const ix = x + Math.cos(phase - Math.PI / 2) * indicatorLen;
                const iy = y + Math.sin(phase - Math.PI / 2) * indicatorLen;

                ringCtx.beginPath();
                ringCtx.moveTo(x, y);
                ringCtx.lineTo(ix, iy);
                ringCtx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
                ringCtx.lineWidth = 1.5;
                ringCtx.stroke();
            }

            // Draw center label
            ringCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ringCtx.font = '14px Georgia';
            ringCtx.textAlign = 'center';
            ringCtx.fillText('Oscillator Ring', cx, cy);
        }

        function drawPhaseSpace(w, h) {
            phaseCtx.fillStyle = '#0a0a15';
            phaseCtx.fillRect(0, 0, w, h);

            const padding = 40;
            const plotW = w - padding * 2;
            const plotH = h - padding;

            // Axes
            phaseCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            phaseCtx.lineWidth = 1;
            phaseCtx.beginPath();
            phaseCtx.moveTo(padding, plotH);
            phaseCtx.lineTo(padding + plotW, plotH);
            phaseCtx.stroke();

            // Labels
            phaseCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            phaseCtx.font = '11px Georgia';
            phaseCtx.textAlign = 'center';
            phaseCtx.fillText('Oscillator Index', padding + plotW / 2, h - 5);
            phaseCtx.fillText('0', padding, h - 5);
            phaseCtx.fillText(N.toString(), padding + plotW, h - 5);

            phaseCtx.save();
            phaseCtx.translate(15, plotH / 2);
            phaseCtx.rotate(-Math.PI / 2);
            phaseCtx.fillText('Phase', 0, 0);
            phaseCtx.restore();

            const localOrder = calculateOrderParameter();

            // Plot phases
            for (let i = 0; i < N; i++) {
                const x = padding + (i / N) * plotW;
                const y = plotH - (phases[i] / (Math.PI * 2)) * (plotH - 20);

                const order = localOrder[i];
                const r = Math.floor(255 * (1 - order) * 0.9 + 77 * order);
                const g = Math.floor(112 * (1 - order) + 208 * order);
                const b = Math.floor(67 * (1 - order) + 225 * order);

                phaseCtx.beginPath();
                phaseCtx.arc(x, y, 3, 0, Math.PI * 2);
                phaseCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                phaseCtx.fill();
            }

            // Draw 2œÄ line
            phaseCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            phaseCtx.setLineDash([5, 5]);
            phaseCtx.beginPath();
            phaseCtx.moveTo(padding, 20);
            phaseCtx.lineTo(padding + plotW, 20);
            phaseCtx.stroke();
            phaseCtx.setLineDash([]);

            phaseCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            phaseCtx.textAlign = 'left';
            phaseCtx.fillText('2œÄ', padding + plotW + 5, 25);
            phaseCtx.fillText('0', padding + plotW + 5, plotH);
        }

        function updateStats() {
            const localOrder = calculateOrderParameter();

            // Global order parameter
            let sumCos = 0;
            let sumSin = 0;
            for (let i = 0; i < N; i++) {
                sumCos += Math.cos(phases[i]);
                sumSin += Math.sin(phases[i]);
            }
            const globalR = Math.sqrt(sumCos ** 2 + sumSin ** 2) / N;

            // Count sync vs async regions
            const threshold = 0.8;
            let syncCount = 0;
            for (let i = 0; i < N; i++) {
                if (localOrder[i] > threshold) syncCount++;
            }

            const syncPercent = (syncCount / N * 100).toFixed(0);
            const asyncPercent = (100 - syncPercent).toFixed(0);

            // Determine state type
            let stateType;
            if (globalR > 0.9) {
                stateType = 'Synchronized';
            } else if (globalR < 0.3) {
                stateType = 'Desynchronized';
            } else if (syncPercent > 20 && asyncPercent > 20) {
                stateType = 'Chimera';
            } else {
                stateType = 'Transitional';
            }

            document.getElementById('orderParam').textContent = globalR.toFixed(2);
            document.getElementById('syncRegion').textContent = syncPercent + '%';
            document.getElementById('asyncRegion').textContent = asyncPercent + '%';
            document.getElementById('stateType').textContent = stateType;
        }

        function animate() {
            const w = ringCanvas.width / dpr;
            const h = ringCanvas.height / dpr;
            const pw = phaseCanvas.width / dpr;
            const ph = phaseCanvas.height / dpr;

            // Update physics
            for (let i = 0; i < 5; i++) {
                updateOscillators(0.05);
            }

            drawRing(w, h);
            drawPhaseSpace(pw, ph);
            updateStats();

            time++;
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('rangeSlider').addEventListener('input', (e) => {
            r = parseFloat(e.target.value);
            document.getElementById('rangeValue').textContent = r.toFixed(2);
        });

        document.getElementById('strengthSlider').addEventListener('input', (e) => {
            K = parseFloat(e.target.value);
            document.getElementById('strengthValue').textContent = K.toFixed(2);
        });

        document.getElementById('countSlider').addEventListener('input', (e) => {
            N = parseInt(e.target.value);
            document.getElementById('countValue').textContent = N;
            initOscillators('chimera');
        });

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                initOscillators(btn.dataset.preset);
            });
        });

        // Initialize
        initOscillators('chimera');
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
