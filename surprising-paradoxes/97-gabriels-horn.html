<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gabriel's Horn - The Painter's Paradox</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a1a2a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(135deg, #ffd700, #ff6b6b, #ff69b4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.3em;
            color: #aaa;
            font-style: italic;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #ff69b4;
            text-decoration: none;
            font-size: 1.1em;
            z-index: 100;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: #ffd700;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 1000px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(30, 30, 60, 0.8);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 105, 180, 0.3);
        }

        .panel h2 {
            color: #ff69b4;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        canvas {
            width: 100%;
            border-radius: 10px;
            background: #0a0a15;
        }

        .controls {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .control-group label {
            min-width: 120px;
            color: #aaa;
        }

        input[type="range"] {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #ff69b4, #00ffff);
            border-radius: 4px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 105, 180, 0.5);
        }

        .value-display {
            min-width: 80px;
            text-align: right;
            font-family: monospace;
            color: #00ffff;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.9em;
            color: #888;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5em;
            font-family: monospace;
        }

        .stat-value.volume {
            color: #00ff88;
        }

        .stat-value.area {
            color: #ff6b6b;
        }

        .explanation {
            background: rgba(30, 30, 60, 0.8);
            border-radius: 15px;
            padding: 30px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            margin-bottom: 30px;
        }

        .explanation h2 {
            color: #ffd700;
            margin-bottom: 20px;
        }

        .explanation p {
            line-height: 1.8;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .highlight {
            color: #ff69b4;
            font-weight: bold;
        }

        .math {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: #00ffff;
            font-size: 1.1em;
        }

        .formula-box {
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            font-family: 'Times New Roman', serif;
            font-size: 1.3em;
        }

        .formula-box .equals {
            color: #ffd700;
        }

        .formula-box .result {
            color: #00ff88;
            font-weight: bold;
        }

        .formula-box .infinity {
            color: #ff6b6b;
            font-weight: bold;
        }

        .paradox-box {
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.1), rgba(255, 215, 0, 0.1));
            border: 2px solid #ffd700;
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
            text-align: center;
        }

        .paradox-box h3 {
            color: #ffd700;
            font-size: 1.5em;
            margin-bottom: 15px;
        }

        .paradox-box p {
            font-size: 1.2em;
            color: #fff;
        }

        .buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: inherit;
        }

        .btn-primary {
            background: linear-gradient(135deg, #ff69b4, #ff1493);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #00bfff, #00ffff);
            color: #000;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(255, 105, 180, 0.4);
        }

        .history {
            background: rgba(30, 30, 60, 0.8);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .history h2 {
            color: #00ffff;
            margin-bottom: 15px;
        }

        .timeline {
            border-left: 3px solid #ff69b4;
            padding-left: 20px;
            margin-left: 10px;
        }

        .timeline-item {
            margin-bottom: 20px;
            position: relative;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -27px;
            top: 5px;
            width: 12px;
            height: 12px;
            background: #ff69b4;
            border-radius: 50%;
        }

        .timeline-year {
            color: #ffd700;
            font-weight: bold;
        }

        .resolution {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .resolution h3 {
            color: #00ff88;
            margin-bottom: 10px;
        }

        .paint-indicator {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .paint-stat {
            text-align: center;
        }

        .paint-label {
            font-size: 0.9em;
            color: #888;
        }

        .paint-value {
            font-size: 1.2em;
            margin-top: 5px;
        }

        .can-fill {
            color: #00ff88;
        }

        .cannot-paint {
            color: #ff6b6b;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>üé∫ Gabriel's Horn</h1>
            <p class="subtitle">The Painter's Paradox: Infinite Surface, Finite Volume</p>
        </header>

        <div class="main-grid">
            <div class="panel">
                <h2>üé® The Shape You Can Fill But Never Paint</h2>
                <canvas id="hornCanvas" width="600" height="400"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Extend to x =</label>
                        <input type="range" id="extentSlider" min="2" max="100" value="10">
                        <span class="value-display" id="extentValue">10</span>
                    </div>
                    <div class="control-group">
                        <label>Rotation</label>
                        <input type="range" id="rotationSlider" min="0" max="360" value="30">
                        <span class="value-display" id="rotationValue">30¬∞</span>
                    </div>
                </div>
                <div class="buttons">
                    <button class="btn-primary" id="fillBtn">ü™£ Fill with Paint</button>
                    <button class="btn-secondary" id="paintBtn">üñåÔ∏è Try to Paint Surface</button>
                    <button class="btn-secondary" id="resetBtn">‚Ü∫ Reset</button>
                </div>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-label">Volume (œÄ units¬≥)</div>
                        <div class="stat-value volume" id="volumeDisplay">0.900</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Surface Area (units¬≤)</div>
                        <div class="stat-value area" id="areaDisplay">14.5</div>
                    </div>
                </div>
                <div class="paint-indicator">
                    <div class="paint-stat">
                        <div class="paint-label">Paint needed to fill:</div>
                        <div class="paint-value can-fill" id="fillPaint">2.83 units¬≥</div>
                    </div>
                    <div class="paint-stat">
                        <div class="paint-label">Paint to cover surface:</div>
                        <div class="paint-value cannot-paint" id="surfacePaint">‚àû units¬≥</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h2>üìä The Paradox in Numbers</h2>
                <canvas id="graphCanvas" width="600" height="400"></canvas>
                <p style="margin-top: 15px; color: #aaa; text-align: center;">
                    As the horn extends to infinity, volume approaches œÄ while surface area grows without bound
                </p>
            </div>
        </div>

        <div class="explanation">
            <h2>ü§Ø The Mind-Bending Paradox</h2>

            <p>
                <span class="highlight">Gabriel's Horn</span> (also called <span class="highlight">Torricelli's Trumpet</span>)
                is created by rotating the curve <span class="math">y = 1/x</span> around the x-axis, starting at x = 1
                and extending to infinity.
            </p>

            <div class="paradox-box">
                <h3>üé® The Painter's Paradox</h3>
                <p>
                    You can <strong style="color: #00ff88;">FILL</strong> this infinitely long horn with a
                    <strong style="color: #00ff88;">finite</strong> amount of paint...<br>
                    But you can <strong style="color: #ff6b6b;">NEVER</strong> paint its
                    <strong style="color: #ff6b6b;">infinite</strong> inner surface!
                </p>
            </div>

            <p>
                This seems impossible! If you pour paint inside, doesn't the paint touch and cover the surface?
                How can you fill something without painting it?
            </p>

            <div class="formula-box">
                <div style="margin-bottom: 15px;">
                    <strong>Volume:</strong> V = œÄ ‚à´‚ÇÅ^‚àû (1/x¬≤) dx <span class="equals">=</span>
                    <span class="result">œÄ cubic units</span> ‚úì Finite!
                </div>
                <div>
                    <strong>Surface Area:</strong> S = 2œÄ ‚à´‚ÇÅ^‚àû (1/x)‚àö(1 + 1/x‚Å¥) dx <span class="equals">‚â•</span>
                    2œÄ ‚à´‚ÇÅ^‚àû (1/x) dx <span class="equals">=</span> <span class="infinity">‚àû</span> ‚úó Infinite!
                </div>
            </div>

            <div class="resolution">
                <h3>üí° Resolving the Paradox</h3>
                <p>
                    The paradox dissolves when we realize we're mixing <strong>mathematical</strong> and
                    <strong>physical</strong> paint:
                </p>
                <ul style="margin-left: 20px; margin-top: 10px; line-height: 2;">
                    <li><strong>Mathematical paint</strong> has zero thickness‚Äîinfinite surface √ó zero thickness = indeterminate</li>
                    <li><strong>Physical paint</strong> has molecules that can't fit through the narrowing throat</li>
                    <li>As x ‚Üí ‚àû, the radius 1/x becomes smaller than any atom!</li>
                    <li>The paradox exploits our intuition about dimensions: 3D volume vs 2D surface</li>
                </ul>
            </div>
        </div>

        <div class="history">
            <h2>üìú Historical Context</h2>
            <div class="timeline">
                <div class="timeline-item">
                    <span class="timeline-year">1641</span> ‚Äî
                    Evangelista Torricelli discovers this shape and its paradoxical properties
                </div>
                <div class="timeline-item">
                    <span class="timeline-year">1643</span> ‚Äî
                    Publishes "De solido hyperbolico acuto" describing the acute hyperbolic solid
                </div>
                <div class="timeline-item">
                    <span class="timeline-year">1650s</span> ‚Äî
                    Thomas Hobbes and John Wallis debate the nature of infinity sparked by this discovery
                </div>
                <div class="timeline-item">
                    <span class="timeline-year">Today</span> ‚Äî
                    Standard example in calculus courses demonstrating counterintuitive properties of infinity
                </div>
            </div>
            <p style="margin-top: 20px; color: #aaa;">
                <strong>Why "Gabriel's Horn"?</strong> The name references the archangel Gabriel, who in
                Christian tradition blows a horn to announce Judgment Day. An infinitely long horn for
                an infinite proclamation!
            </p>
        </div>
    </div>

    <script>
        // Canvas setup
        const hornCanvas = document.getElementById('hornCanvas');
        const hornCtx = hornCanvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');

        // State
        let extent = 10;
        let rotation = 30;
        let filling = false;
        let fillLevel = 0;
        let painting = false;
        let paintProgress = 0;

        // Sliders
        const extentSlider = document.getElementById('extentSlider');
        const rotationSlider = document.getElementById('rotationSlider');

        extentSlider.addEventListener('input', () => {
            extent = parseFloat(extentSlider.value);
            document.getElementById('extentValue').textContent = extent;
            updateStats();
            drawHorn();
            drawGraph();
        });

        rotationSlider.addEventListener('input', () => {
            rotation = parseFloat(rotationSlider.value);
            document.getElementById('rotationValue').textContent = rotation + '¬∞';
            drawHorn();
        });

        // Buttons
        document.getElementById('fillBtn').addEventListener('click', () => {
            filling = true;
            painting = false;
            fillLevel = 0;
            paintProgress = 0;
            animateFill();
        });

        document.getElementById('paintBtn').addEventListener('click', () => {
            painting = true;
            filling = false;
            fillLevel = 0;
            paintProgress = 0;
            animatePaint();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            filling = false;
            painting = false;
            fillLevel = 0;
            paintProgress = 0;
            drawHorn();
        });

        function calculateVolume(a) {
            // V = œÄ(1 - 1/a)
            return Math.PI * (1 - 1/a);
        }

        function calculateSurfaceArea(a) {
            // S ‚â• 2œÄ ln(a) (lower bound, actual is larger)
            // Using approximation: S ‚âà 2œÄ(ln(a) + some correction)
            return 2 * Math.PI * (Math.log(a) + 0.5 * (1 - 1/(a*a)));
        }

        function updateStats() {
            const vol = calculateVolume(extent);
            const area = calculateSurfaceArea(extent);

            document.getElementById('volumeDisplay').textContent = vol.toFixed(3);
            document.getElementById('areaDisplay').textContent = area.toFixed(1);
            document.getElementById('fillPaint').textContent = vol.toFixed(2) + ' units¬≥';

            if (extent > 50) {
                document.getElementById('surfacePaint').textContent = '‚Üí ‚àû units¬≥';
            } else {
                document.getElementById('surfacePaint').textContent = area.toFixed(1) + '+ units¬≤';
            }
        }

        function drawHorn() {
            const w = hornCanvas.width;
            const h = hornCanvas.height;
            hornCtx.clearRect(0, 0, w, h);

            // Background gradient
            const bgGrad = hornCtx.createLinearGradient(0, 0, w, h);
            bgGrad.addColorStop(0, '#0a0a15');
            bgGrad.addColorStop(1, '#151530');
            hornCtx.fillStyle = bgGrad;
            hornCtx.fillRect(0, 0, w, h);

            const centerY = h / 2;
            const startX = 80;
            const scale = 60;
            const maxX = Math.min(extent, 50);

            // Calculate perspective based on rotation
            const angleRad = (rotation - 30) * Math.PI / 180;
            const perspective = Math.cos(angleRad);
            const verticalSkew = Math.sin(angleRad) * 0.3;

            // Draw the horn shape with 3D effect
            // Upper curve
            hornCtx.beginPath();
            for (let x = 1; x <= maxX; x += 0.1) {
                const y = 1 / x;
                const px = startX + (x - 1) * (w - startX - 20) / (maxX - 1);
                const py = centerY - y * scale * perspective + (x - 1) * verticalSkew;
                if (x === 1) hornCtx.moveTo(px, py);
                else hornCtx.lineTo(px, py);
            }

            // Connect to lower curve
            for (let x = maxX; x >= 1; x -= 0.1) {
                const y = 1 / x;
                const px = startX + (x - 1) * (w - startX - 20) / (maxX - 1);
                const py = centerY + y * scale * perspective + (x - 1) * verticalSkew;
                hornCtx.lineTo(px, py);
            }
            hornCtx.closePath();

            // Fill gradient
            const hornGrad = hornCtx.createLinearGradient(startX, centerY - scale, w, centerY + scale);
            hornGrad.addColorStop(0, '#4a2070');
            hornGrad.addColorStop(0.5, '#2a1050');
            hornGrad.addColorStop(1, '#1a0830');
            hornCtx.fillStyle = hornGrad;
            hornCtx.fill();

            // If filling with paint
            if (fillLevel > 0) {
                hornCtx.beginPath();
                const fillX = 1 + (maxX - 1) * fillLevel;
                for (let x = 1; x <= fillX; x += 0.1) {
                    const y = 1 / x;
                    const px = startX + (x - 1) * (w - startX - 20) / (maxX - 1);
                    const py = centerY - y * scale * perspective * 0.9 + (x - 1) * verticalSkew;
                    if (x === 1) hornCtx.moveTo(px, py);
                    else hornCtx.lineTo(px, py);
                }
                for (let x = fillX; x >= 1; x -= 0.1) {
                    const y = 1 / x;
                    const px = startX + (x - 1) * (w - startX - 20) / (maxX - 1);
                    const py = centerY + y * scale * perspective * 0.9 + (x - 1) * verticalSkew;
                    hornCtx.lineTo(px, py);
                }
                hornCtx.closePath();

                const paintGrad = hornCtx.createLinearGradient(startX, centerY, w * fillLevel, centerY);
                paintGrad.addColorStop(0, '#00ff88');
                paintGrad.addColorStop(1, '#00aa55');
                hornCtx.fillStyle = paintGrad;
                hornCtx.globalAlpha = 0.7;
                hornCtx.fill();
                hornCtx.globalAlpha = 1;
            }

            // If painting surface (shows struggle)
            if (paintProgress > 0) {
                const paintX = 1 + (maxX - 1) * Math.min(paintProgress, 0.3);
                hornCtx.beginPath();
                for (let x = 1; x <= paintX; x += 0.1) {
                    const y = 1 / x;
                    const px = startX + (x - 1) * (w - startX - 20) / (maxX - 1);
                    const py = centerY - y * scale * perspective + (x - 1) * verticalSkew;
                    if (x === 1) hornCtx.moveTo(px, py);
                    else hornCtx.lineTo(px, py);
                }
                hornCtx.strokeStyle = '#ff6b6b';
                hornCtx.lineWidth = 4;
                hornCtx.stroke();

                // Warning message
                if (paintProgress > 0.2) {
                    hornCtx.fillStyle = '#ff6b6b';
                    hornCtx.font = 'bold 16px Georgia';
                    hornCtx.fillText('Surface extends infinitely! ‚àû', w/2 - 80, 30);
                }
            }

            // Draw outline
            hornCtx.beginPath();
            for (let x = 1; x <= maxX; x += 0.1) {
                const y = 1 / x;
                const px = startX + (x - 1) * (w - startX - 20) / (maxX - 1);
                const py = centerY - y * scale * perspective + (x - 1) * verticalSkew;
                if (x === 1) hornCtx.moveTo(px, py);
                else hornCtx.lineTo(px, py);
            }
            hornCtx.strokeStyle = '#ff69b4';
            hornCtx.lineWidth = 2;
            hornCtx.stroke();

            hornCtx.beginPath();
            for (let x = 1; x <= maxX; x += 0.1) {
                const y = 1 / x;
                const px = startX + (x - 1) * (w - startX - 20) / (maxX - 1);
                const py = centerY + y * scale * perspective + (x - 1) * verticalSkew;
                if (x === 1) hornCtx.moveTo(px, py);
                else hornCtx.lineTo(px, py);
            }
            hornCtx.stroke();

            // Draw opening circle at x=1
            hornCtx.beginPath();
            hornCtx.ellipse(startX, centerY, 3, scale * perspective, 0, 0, Math.PI * 2);
            hornCtx.strokeStyle = '#ffd700';
            hornCtx.lineWidth = 2;
            hornCtx.stroke();

            // Draw arrow showing continuation
            if (extent > 10) {
                hornCtx.fillStyle = '#aaa';
                hornCtx.font = '14px Georgia';
                hornCtx.fillText('‚Üí continues to infinity...', w - 150, centerY + verticalSkew * (maxX - 1));
            }

            // Labels
            hornCtx.fillStyle = '#ffd700';
            hornCtx.font = 'italic 14px Georgia';
            hornCtx.fillText('y = 1/x', startX - 10, centerY - scale - 10);
            hornCtx.fillText('x = 1', startX - 5, h - 20);
            hornCtx.fillText('x = ' + extent, w - 60, h - 20);
        }

        function drawGraph() {
            const w = graphCanvas.width;
            const h = graphCanvas.height;
            graphCtx.clearRect(0, 0, w, h);

            // Background
            const bgGrad = graphCtx.createLinearGradient(0, 0, w, h);
            bgGrad.addColorStop(0, '#0a0a15');
            bgGrad.addColorStop(1, '#151530');
            graphCtx.fillStyle = bgGrad;
            graphCtx.fillRect(0, 0, w, h);

            const padding = 60;
            const graphW = w - padding * 2;
            const graphH = h - padding * 2;

            // Draw axes
            graphCtx.strokeStyle = '#555';
            graphCtx.lineWidth = 1;
            graphCtx.beginPath();
            graphCtx.moveTo(padding, padding);
            graphCtx.lineTo(padding, h - padding);
            graphCtx.lineTo(w - padding, h - padding);
            graphCtx.stroke();

            // X-axis labels
            graphCtx.fillStyle = '#888';
            graphCtx.font = '12px Georgia';
            graphCtx.textAlign = 'center';
            for (let x = 1; x <= 100; x += 20) {
                const px = padding + (Math.log(x) / Math.log(100)) * graphW;
                graphCtx.fillText(x.toString(), px, h - padding + 20);
            }
            graphCtx.fillText('x (log scale)', w/2, h - 15);

            // Y-axis label
            graphCtx.save();
            graphCtx.translate(15, h/2);
            graphCtx.rotate(-Math.PI/2);
            graphCtx.fillText('Value', 0, 0);
            graphCtx.restore();

            // Draw volume curve (approaches œÄ)
            graphCtx.beginPath();
            graphCtx.strokeStyle = '#00ff88';
            graphCtx.lineWidth = 3;
            for (let x = 1; x <= 100; x += 0.5) {
                const vol = calculateVolume(x);
                const px = padding + (Math.log(x) / Math.log(100)) * graphW;
                const py = h - padding - (vol / 4) * graphH;
                if (x === 1) graphCtx.moveTo(px, py);
                else graphCtx.lineTo(px, py);
            }
            graphCtx.stroke();

            // Draw œÄ asymptote
            const piY = h - padding - (Math.PI / 4) * graphH;
            graphCtx.strokeStyle = '#00ff8844';
            graphCtx.lineWidth = 1;
            graphCtx.setLineDash([5, 5]);
            graphCtx.beginPath();
            graphCtx.moveTo(padding, piY);
            graphCtx.lineTo(w - padding, piY);
            graphCtx.stroke();
            graphCtx.setLineDash([]);
            graphCtx.fillStyle = '#00ff88';
            graphCtx.fillText('Volume ‚Üí œÄ ‚âà 3.14', w - padding - 60, piY - 5);

            // Draw surface area curve (goes to infinity)
            graphCtx.beginPath();
            graphCtx.strokeStyle = '#ff6b6b';
            graphCtx.lineWidth = 3;
            for (let x = 1; x <= 100; x += 0.5) {
                const area = calculateSurfaceArea(x);
                const px = padding + (Math.log(x) / Math.log(100)) * graphW;
                const py = h - padding - Math.min((area / 35) * graphH, graphH - 10);
                if (x === 1) graphCtx.moveTo(px, py);
                else graphCtx.lineTo(px, py);
            }
            graphCtx.stroke();

            // Arrow showing infinity
            graphCtx.fillStyle = '#ff6b6b';
            graphCtx.font = 'bold 16px Georgia';
            graphCtx.fillText('Surface Area ‚Üí ‚àû', w - padding - 80, padding + 20);

            // Mark current extent
            const currentPx = padding + (Math.log(extent) / Math.log(100)) * graphW;
            graphCtx.strokeStyle = '#ffd700';
            graphCtx.lineWidth = 2;
            graphCtx.setLineDash([3, 3]);
            graphCtx.beginPath();
            graphCtx.moveTo(currentPx, padding);
            graphCtx.lineTo(currentPx, h - padding);
            graphCtx.stroke();
            graphCtx.setLineDash([]);
            graphCtx.fillStyle = '#ffd700';
            graphCtx.fillText('x = ' + extent, currentPx, h - padding + 35);

            // Legend
            graphCtx.fillStyle = '#00ff88';
            graphCtx.fillRect(padding + 10, padding + 10, 15, 15);
            graphCtx.fillStyle = '#ddd';
            graphCtx.textAlign = 'left';
            graphCtx.fillText('Volume (finite)', padding + 30, padding + 22);

            graphCtx.fillStyle = '#ff6b6b';
            graphCtx.fillRect(padding + 10, padding + 35, 15, 15);
            graphCtx.fillStyle = '#ddd';
            graphCtx.fillText('Surface Area (infinite)', padding + 30, padding + 47);
        }

        function animateFill() {
            if (!filling) return;
            fillLevel += 0.02;
            if (fillLevel >= 1) {
                fillLevel = 1;
                filling = false;
            }
            drawHorn();
            if (filling) requestAnimationFrame(animateFill);
        }

        function animatePaint() {
            if (!painting) return;
            paintProgress += 0.005;
            if (paintProgress >= 1) {
                // Reset and show message that it never completes
                paintProgress = 0;
                painting = false;
                drawHorn();
                // Show that painting is impossible
                hornCtx.fillStyle = '#ff6b6b';
                hornCtx.font = 'bold 18px Georgia';
                hornCtx.fillText('‚ùå IMPOSSIBLE! Surface is infinite!', 150, 50);
                return;
            }
            drawHorn();
            if (painting) requestAnimationFrame(animatePaint);
        }

        // Initial draw
        updateStats();
        drawHorn();
        drawGraph();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
