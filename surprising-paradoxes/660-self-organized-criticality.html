<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self-Organized Criticality - The Sandpile Model</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e8e8e8;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.2rem;
            background: linear-gradient(135deg, #f39c12, #e74c3c, #f39c12);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #aaa;
            font-size: 1.1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 25px;
        }

        @media (max-width: 1100px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .viz-section {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 20px;
        }

        .canvas-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .canvas-box {
            text-align: center;
        }

        .canvas-box h3 {
            margin-bottom: 10px;
            color: #f39c12;
        }

        canvas {
            border-radius: 8px;
            cursor: crosshair;
        }

        #sandpileCanvas {
            background: #111;
        }

        #histCanvas {
            background: #111;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: #fff;
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .param-group {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
        }

        .param-group label {
            font-size: 0.85rem;
            color: #aaa;
        }

        .param-value {
            color: #f39c12;
            font-weight: bold;
            min-width: 35px;
        }

        input[type="range"] {
            width: 100px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-box {
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 1.4rem;
            font-weight: bold;
            color: #f39c12;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .exp-card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 18px;
            border-left: 4px solid #f39c12;
        }

        .exp-card h3 {
            color: #f39c12;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .exp-card p {
            color: #ccc;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .formula {
            background: rgba(0,0,0,0.4);
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            color: #f39c12;
            text-align: center;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8rem;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #f39c12;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            opacity: 0.8;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .back-link:hover {
            opacity: 1;
        }

        .highlight {
            color: #e74c3c;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>Self-Organized Criticality</h1>
            <p class="subtitle">The Bak-Tang-Wiesenfeld Sandpile Model (1987)</p>
        </header>

        <div class="main-content">
            <div class="viz-section">
                <div class="canvas-container">
                    <div class="canvas-box">
                        <h3>Sandpile Grid</h3>
                        <canvas id="sandpileCanvas" width="500" height="500"></canvas>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #1a1a2e;"></div>
                                <span>0 grains</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #2e86ab;"></div>
                                <span>1 grain</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a23b72;"></div>
                                <span>2 grains</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #f18f01;"></div>
                                <span>3 grains</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #e74c3c;"></div>
                                <span>Toppling!</span>
                            </div>
                        </div>
                    </div>
                    <div class="canvas-box">
                        <h3>Avalanche Size Distribution</h3>
                        <canvas id="histCanvas" width="350" height="300"></canvas>
                        <p style="color: #888; font-size: 0.8rem; margin-top: 10px;">Log-log scale: Power law appears as straight line</p>
                    </div>
                </div>

                <div class="controls">
                    <button class="btn btn-primary" id="startBtn">Start</button>
                    <button class="btn btn-secondary" id="pauseBtn">Pause</button>
                    <button class="btn btn-secondary" id="stepBtn">Single Step</button>
                    <button class="btn btn-secondary" id="resetBtn">Reset</button>

                    <div class="param-group">
                        <label>Speed:</label>
                        <input type="range" id="speedSlider" min="1" max="100" value="50">
                        <span class="param-value" id="speedValue">50</span>
                    </div>

                    <div class="param-group">
                        <label>Grid Size:</label>
                        <select id="gridSelect" style="padding: 5px; border-radius: 4px;">
                            <option value="25">25√ó25</option>
                            <option value="50" selected>50√ó50</option>
                            <option value="75">75√ó75</option>
                            <option value="100">100√ó100</option>
                        </select>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-label">Total Grains</div>
                        <div class="stat-value" id="totalGrains">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Total Avalanches</div>
                        <div class="stat-value" id="totalAvalanches">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Current Avalanche</div>
                        <div class="stat-value" id="currentAvalanche">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Largest Avalanche</div>
                        <div class="stat-value" id="largestAvalanche">0</div>
                    </div>
                </div>
            </div>

            <div class="sidebar">
                <div class="exp-card">
                    <h3>üèîÔ∏è The Sandpile Paradox</h3>
                    <p>Drop grains of sand one at a time. Eventually the pile reaches a <span class="highlight">critical state</span> where adding ONE grain can trigger avalanches of ANY size‚Äîfrom 1 toppling to millions! The system <span class="highlight">tunes itself</span> to criticality without external adjustment.</p>
                </div>

                <div class="exp-card">
                    <h3>‚ö° The Rules</h3>
                    <p>Each cell holds 0-3 grains. When a cell reaches <span class="highlight">4 grains</span>, it "topples"‚Äîsending 1 grain to each of its 4 neighbors. This can trigger cascading avalanches. Grains at the edge fall off.</p>
                    <div class="formula">
                        z<sub>i</sub> ‚â• 4 ‚Üí z<sub>i</sub> -= 4, neighbors += 1
                    </div>
                </div>

                <div class="exp-card">
                    <h3>üìä Power Law Distribution</h3>
                    <p>Avalanche sizes follow a <span class="highlight">power law</span>: small avalanches are common, large ones rare, but POSSIBLE. This is the signature of criticality‚Äîno characteristic scale!</p>
                    <div class="formula">
                        P(s) ‚àº s<sup>-œÑ</sup>, œÑ ‚âà 1.2
                    </div>
                </div>

                <div class="exp-card">
                    <h3>üåç Ubiquitous in Nature</h3>
                    <p>Earthquakes, forest fires, extinctions, stock crashes, neural avalanches, and even wars show this pattern! Bak, Tang & Wiesenfeld (1987) proposed SOC explains <span class="highlight">1/f noise</span> everywhere in nature.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const sandCanvas = document.getElementById('sandpileCanvas');
        const sandCtx = sandCanvas.getContext('2d');
        const histCanvas = document.getElementById('histCanvas');
        const histCtx = histCanvas.getContext('2d');

        // State
        let gridSize = 50;
        let cellSize = sandCanvas.width / gridSize;
        let grid = [];
        let running = false;
        let animationId = null;
        let speed = 50;

        // Statistics
        let totalGrains = 0;
        let totalAvalanches = 0;
        let currentAvalancheSize = 0;
        let largestAvalanche = 0;
        let avalancheSizes = [];

        // Colors for different grain counts
        const colors = [
            '#1a1a2e', // 0 grains
            '#2e86ab', // 1 grain
            '#a23b72', // 2 grains
            '#f18f01', // 3 grains
            '#e74c3c'  // 4+ grains (toppling)
        ];

        // Initialize grid
        function initGrid() {
            grid = [];
            for (let i = 0; i < gridSize; i++) {
                grid[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    grid[i][j] = 0;
                }
            }
            cellSize = sandCanvas.width / gridSize;
            totalGrains = 0;
            totalAvalanches = 0;
            currentAvalancheSize = 0;
            largestAvalanche = 0;
            avalancheSizes = [];
            updateStats();
        }

        // Draw grid
        function drawGrid() {
            sandCtx.clearRect(0, 0, sandCanvas.width, sandCanvas.height);

            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const val = grid[i][j];
                    sandCtx.fillStyle = colors[Math.min(val, 4)];
                    sandCtx.fillRect(i * cellSize, j * cellSize, cellSize - 0.5, cellSize - 0.5);
                }
            }
        }

        // Add grain at random position
        function addGrain() {
            const x = Math.floor(Math.random() * gridSize);
            const y = Math.floor(Math.random() * gridSize);
            grid[x][y]++;
            totalGrains++;
        }

        // Perform one toppling step
        function topple() {
            let topplings = 0;
            const newGrid = grid.map(row => [...row]);

            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (grid[i][j] >= 4) {
                        newGrid[i][j] -= 4;
                        topplings++;

                        // Distribute to neighbors
                        if (i > 0) newGrid[i-1][j]++;
                        if (i < gridSize - 1) newGrid[i+1][j]++;
                        if (j > 0) newGrid[i][j-1]++;
                        if (j < gridSize - 1) newGrid[i][j+1]++;
                        // Grains at edges fall off
                    }
                }
            }

            grid = newGrid;
            return topplings;
        }

        // Run one complete avalanche
        function runAvalanche() {
            currentAvalancheSize = 0;
            let topplings;

            do {
                topplings = topple();
                currentAvalancheSize += topplings;
                drawGrid();
            } while (topplings > 0);

            if (currentAvalancheSize > 0) {
                totalAvalanches++;
                avalancheSizes.push(currentAvalancheSize);
                if (currentAvalancheSize > largestAvalanche) {
                    largestAvalanche = currentAvalancheSize;
                }
            }

            updateStats();
        }

        // Animate avalanche step by step
        async function animateAvalanche() {
            currentAvalancheSize = 0;
            let topplings;

            do {
                topplings = topple();
                currentAvalancheSize += topplings;
                drawGrid();
                document.getElementById('currentAvalanche').textContent = currentAvalancheSize;

                if (topplings > 0 && speed < 100) {
                    await new Promise(r => setTimeout(r, Math.max(1, 100 - speed)));
                }
            } while (topplings > 0);

            if (currentAvalancheSize > 0) {
                totalAvalanches++;
                avalancheSizes.push(currentAvalancheSize);
                if (currentAvalancheSize > largestAvalanche) {
                    largestAvalanche = currentAvalancheSize;
                }
                drawHistogram();
            }

            updateStats();
        }

        // Main simulation loop
        async function simulate() {
            if (!running) return;

            addGrain();
            await animateAvalanche();

            if (running) {
                const delay = Math.max(1, 200 - speed * 2);
                animationId = setTimeout(simulate, delay);
            }
        }

        // Draw avalanche size histogram (log-log)
        function drawHistogram() {
            histCtx.clearRect(0, 0, histCanvas.width, histCanvas.height);

            if (avalancheSizes.length < 10) {
                histCtx.fillStyle = '#888';
                histCtx.font = '14px sans-serif';
                histCtx.textAlign = 'center';
                histCtx.fillText('Collecting data...', histCanvas.width/2, histCanvas.height/2);
                return;
            }

            // Bin the avalanche sizes logarithmically
            const maxSize = Math.max(...avalancheSizes);
            const minSize = 1;
            const numBins = 20;

            // Create log-spaced bins
            const logMin = Math.log10(minSize);
            const logMax = Math.log10(maxSize + 1);
            const logStep = (logMax - logMin) / numBins;

            const bins = new Array(numBins).fill(0);
            const binCenters = [];

            for (let i = 0; i < numBins; i++) {
                binCenters[i] = Math.pow(10, logMin + (i + 0.5) * logStep);
            }

            // Fill bins
            for (const size of avalancheSizes) {
                const logSize = Math.log10(size);
                const binIndex = Math.min(numBins - 1, Math.floor((logSize - logMin) / logStep));
                bins[binIndex]++;
            }

            // Normalize by bin width for proper PDF
            const binWidths = binCenters.map((c, i) => {
                const low = Math.pow(10, logMin + i * logStep);
                const high = Math.pow(10, logMin + (i + 1) * logStep);
                return high - low;
            });

            const pdf = bins.map((count, i) => count / (avalancheSizes.length * binWidths[i]));

            // Filter out zero values for log plot
            const validData = [];
            for (let i = 0; i < numBins; i++) {
                if (pdf[i] > 0) {
                    validData.push({ x: binCenters[i], y: pdf[i] });
                }
            }

            if (validData.length < 2) return;

            // Calculate plot bounds
            const logXMin = Math.log10(Math.min(...validData.map(d => d.x)));
            const logXMax = Math.log10(Math.max(...validData.map(d => d.x)));
            const logYMin = Math.log10(Math.min(...validData.map(d => d.y)));
            const logYMax = Math.log10(Math.max(...validData.map(d => d.y)));

            const padding = { left: 50, right: 20, top: 30, bottom: 40 };
            const plotWidth = histCanvas.width - padding.left - padding.right;
            const plotHeight = histCanvas.height - padding.top - padding.bottom;

            // Draw axes
            histCtx.strokeStyle = '#444';
            histCtx.lineWidth = 1;
            histCtx.beginPath();
            histCtx.moveTo(padding.left, padding.top);
            histCtx.lineTo(padding.left, histCanvas.height - padding.bottom);
            histCtx.lineTo(histCanvas.width - padding.right, histCanvas.height - padding.bottom);
            histCtx.stroke();

            // Axis labels
            histCtx.fillStyle = '#888';
            histCtx.font = '11px sans-serif';
            histCtx.textAlign = 'center';
            histCtx.fillText('Avalanche Size (log)', histCanvas.width/2, histCanvas.height - 5);

            histCtx.save();
            histCtx.translate(12, histCanvas.height/2);
            histCtx.rotate(-Math.PI/2);
            histCtx.fillText('Probability (log)', 0, 0);
            histCtx.restore();

            // Plot power law reference line (slope ‚âà -1.2)
            histCtx.strokeStyle = 'rgba(231, 76, 60, 0.5)';
            histCtx.lineWidth = 2;
            histCtx.setLineDash([5, 5]);
            histCtx.beginPath();

            const refY0 = logYMax;
            const refY1 = refY0 - 1.2 * (logXMax - logXMin);

            const rx0 = padding.left;
            const ry0 = padding.top + (logYMax - refY0) / (logYMax - logYMin) * plotHeight;
            const rx1 = padding.left + plotWidth;
            const ry1 = padding.top + (logYMax - refY1) / (logYMax - logYMin) * plotHeight;

            histCtx.moveTo(rx0, ry0);
            histCtx.lineTo(rx1, Math.min(ry1, histCanvas.height - padding.bottom));
            histCtx.stroke();
            histCtx.setLineDash([]);

            // Plot data points
            histCtx.fillStyle = '#f39c12';
            for (const d of validData) {
                const px = padding.left + (Math.log10(d.x) - logXMin) / (logXMax - logXMin) * plotWidth;
                const py = padding.top + (logYMax - Math.log10(d.y)) / (logYMax - logYMin) * plotHeight;

                histCtx.beginPath();
                histCtx.arc(px, py, 5, 0, Math.PI * 2);
                histCtx.fill();
            }

            // Legend
            histCtx.fillStyle = '#f39c12';
            histCtx.fillRect(histCanvas.width - 100, 10, 12, 12);
            histCtx.fillStyle = '#888';
            histCtx.font = '10px sans-serif';
            histCtx.textAlign = 'left';
            histCtx.fillText('Data', histCanvas.width - 85, 20);

            histCtx.strokeStyle = 'rgba(231, 76, 60, 0.8)';
            histCtx.setLineDash([5, 5]);
            histCtx.beginPath();
            histCtx.moveTo(histCanvas.width - 100, 35);
            histCtx.lineTo(histCanvas.width - 88, 35);
            histCtx.stroke();
            histCtx.setLineDash([]);
            histCtx.fillText('œÑ ‚âà 1.2', histCanvas.width - 85, 38);
        }

        // Update statistics display
        function updateStats() {
            document.getElementById('totalGrains').textContent = totalGrains.toLocaleString();
            document.getElementById('totalAvalanches').textContent = totalAvalanches.toLocaleString();
            document.getElementById('currentAvalanche').textContent = currentAvalancheSize.toLocaleString();
            document.getElementById('largestAvalanche').textContent = largestAvalanche.toLocaleString();
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            if (!running) {
                running = true;
                document.getElementById('startBtn').textContent = 'Running...';
                simulate();
            }
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            running = false;
            if (animationId) {
                clearTimeout(animationId);
            }
            document.getElementById('startBtn').textContent = 'Start';
        });

        document.getElementById('stepBtn').addEventListener('click', async () => {
            if (!running) {
                addGrain();
                await animateAvalanche();
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            if (animationId) {
                clearTimeout(animationId);
            }
            document.getElementById('startBtn').textContent = 'Start';
            initGrid();
            drawGrid();
            drawHistogram();
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = speed;
        });

        document.getElementById('gridSelect').addEventListener('change', (e) => {
            gridSize = parseInt(e.target.value);
            initGrid();
            drawGrid();
            drawHistogram();
        });

        // Click to add grain
        sandCanvas.addEventListener('click', async (e) => {
            if (running) return;

            const rect = sandCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / cellSize);
            const y = Math.floor((e.clientY - rect.top) / cellSize);

            if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
                grid[x][y]++;
                totalGrains++;
                await animateAvalanche();
            }
        });

        // Initialize
        initGrid();
        drawGrid();
        drawHistogram();
    </script>
</body>
</html>
