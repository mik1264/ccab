<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Newton's Fractal - Surprising Paradoxes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(135deg, #ff6b6b 0%, #4ecdc4 50%, #45b7d1 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2em;
            color: #888;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }

        @media (max-width: 1000px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .canvas-container {
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        #fractalCanvas {
            display: block;
            width: 100%;
            cursor: crosshair;
        }

        .info-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.85em;
            font-family: monospace;
        }

        .info-overlay span {
            color: #4ecdc4;
        }

        .root-markers {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.8em;
        }

        .root-marker {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
        }

        .root-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        .controls {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
        }

        .control-section {
            margin-bottom: 25px;
        }

        .control-section h3 {
            color: #4ecdc4;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 1px solid rgba(78,205,196,0.3);
            padding-bottom: 8px;
        }

        .control-row {
            margin-bottom: 15px;
        }

        .control-row label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 0.9em;
        }

        .control-row input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-row .value {
            text-align: right;
            font-family: monospace;
            color: #4ecdc4;
            font-size: 0.9em;
        }

        select {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
            color: #e0e0e0;
            font-size: 0.95em;
        }

        .btn-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4ecdc4, #45b7d1);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(78,205,196,0.4);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #e0e0e0;
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
        }

        .preset-btn {
            flex: 1;
            min-width: 80px;
            font-size: 0.8em;
            padding: 8px 12px;
        }

        .explanation {
            margin-top: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .exp-card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            border-left: 4px solid #4ecdc4;
        }

        .exp-card h3 {
            color: #4ecdc4;
            margin-bottom: 10px;
        }

        .exp-card p {
            color: #bbb;
            line-height: 1.6;
        }

        .formula {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
            font-family: 'Times New Roman', serif;
            font-size: 1.2em;
            text-align: center;
            margin: 15px 0;
            color: #4ecdc4;
        }

        .back-link {
            display: inline-block;
            color: #4ecdc4;
            text-decoration: none;
            margin-bottom: 20px;
            transition: transform 0.2s;
        }

        .back-link:hover {
            transform: translateX(-5px);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #4ecdc4;
            font-size: 1.2em;
        }

        .instructions {
            font-size: 0.85em;
            color: #888;
            margin-top: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .convergence-display {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            margin-top: 10px;
        }

        .convergence-box {
            width: 30px;
            height: 30px;
            border-radius: 8px;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .convergence-info {
            font-family: monospace;
            font-size: 0.85em;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Paradoxes</a>

        <header>
            <h1>Newton's Fractal</h1>
            <p class="subtitle">When root-finding algorithms produce infinite complexity</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="fractalCanvas" width="900" height="700"></canvas>
                <div class="info-overlay">
                    <div>Center: (<span id="centerX">0</span>, <span id="centerY">0</span>)</div>
                    <div>Zoom: <span id="zoomLevel">1.0</span>x</div>
                    <div>Max Iter: <span id="iterCount">50</span></div>
                </div>
                <div class="root-markers" id="rootMarkers">
                    <!-- Populated dynamically -->
                </div>
                <div class="loading" id="loading" style="display: none;">Rendering...</div>
            </div>

            <div class="controls">
                <div class="control-section">
                    <h3>Polynomial</h3>
                    <select id="polynomialSelect">
                        <option value="z3-1">z³ - 1 (Cube roots of unity)</option>
                        <option value="z4-1">z⁴ - 1 (Fourth roots)</option>
                        <option value="z5-1">z⁵ - 1 (Fifth roots)</option>
                        <option value="z6-1">z⁶ - 1 (Sixth roots)</option>
                        <option value="z3-2z+2">z³ - 2z + 2</option>
                        <option value="z4-z3-1">z⁴ - z³ - 1</option>
                        <option value="z8+15z4-16">z⁸ + 15z⁴ - 16</option>
                    </select>
                </div>

                <div class="control-section">
                    <h3>Navigation</h3>
                    <div class="btn-group">
                        <button class="btn-primary" id="resetBtn">Reset View</button>
                        <button class="btn-secondary" id="zoomOutBtn">Zoom Out</button>
                    </div>
                    <div class="instructions">
                        Click to zoom in. Drag to pan. Scroll to zoom.
                    </div>
                </div>

                <div class="control-section">
                    <h3>Presets (z³-1)</h3>
                    <div class="btn-group">
                        <button class="btn-secondary preset-btn" data-preset="full">Full View</button>
                        <button class="btn-secondary preset-btn" data-preset="boundary">Boundary</button>
                        <button class="btn-secondary preset-btn" data-preset="spiral">Spiral</button>
                        <button class="btn-secondary preset-btn" data-preset="junction">Junction</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Iterations</h3>
                    <div class="control-row">
                        <label>Max Iterations</label>
                        <input type="range" id="iterSlider" min="10" max="200" value="50">
                        <div class="value" id="iterValue">50</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Coloring Mode</h3>
                    <select id="colorMode">
                        <option value="root">By Root (Basin)</option>
                        <option value="iteration">By Iteration Count</option>
                        <option value="both">Root + Iteration</option>
                    </select>
                </div>

                <div class="control-section">
                    <h3>Point Convergence</h3>
                    <div class="convergence-display">
                        <div class="convergence-box" id="convBox"></div>
                        <div class="convergence-info">
                            <div>Root: <span id="convRoot">—</span></div>
                            <div>Iters: <span id="convIters">—</span></div>
                        </div>
                    </div>
                    <div class="instructions">Hover over the fractal to see convergence info</div>
                </div>
            </div>
        </div>

        <div class="explanation">
            <div class="exp-card">
                <h3>Newton's Method</h3>
                <div class="formula">z<sub>n+1</sub> = z<sub>n</sub> - f(z<sub>n</sub>) / f'(z<sub>n</sub>)</div>
                <p>Newton's method is a root-finding algorithm: given a starting point, it iteratively refines guesses to find where f(z) = 0. For real numbers, this works beautifully. But extend it to the complex plane, and something magical happens at the boundaries...</p>
            </div>

            <div class="exp-card">
                <h3>The Paradox of Determinism</h3>
                <p>Newton's method is completely deterministic—the same starting point always produces the same result. Yet the boundaries between basins of attraction are infinitely complex fractals. A tiny change in starting position can lead to converging to a completely different root. This is chaos emerging from simple rules!</p>
            </div>

            <div class="exp-card">
                <h3>The Wada Property</h3>
                <p>For z³-1, every point on the fractal boundary is simultaneously on the boundary of ALL THREE basins. No two colors ever share a simple border without the third squeezing in between. This "Wada property" was discovered by mathematician Kunizō Yoneyama in 1917.</p>
            </div>

            <div class="exp-card">
                <h3>Historical Context</h3>
                <p>Isaac Newton developed his method around 1670. Arthur Cayley first studied basins of attraction in the complex plane in 1879, famously writing he could make no progress on the z³-1 case. The fractal nature wasn't understood until the advent of computer graphics in the 1980s.</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('fractalCanvas');
        const ctx = canvas.getContext('2d');
        const loading = document.getElementById('loading');

        // View parameters
        let centerX = 0;
        let centerY = 0;
        let zoom = 1.0;
        let maxIter = 50;
        let colorMode = 'root';

        // Drag state
        let isDragging = false;
        let dragStartX, dragStartY;
        let dragStartCenterX, dragStartCenterY;

        // Current polynomial
        let currentPoly = 'z3-1';

        // Polynomial definitions
        const polynomials = {
            'z3-1': {
                f: (zr, zi) => {
                    // z³ - 1
                    const r3 = zr*zr*zr - 3*zr*zi*zi;
                    const i3 = 3*zr*zr*zi - zi*zi*zi;
                    return [r3 - 1, i3];
                },
                df: (zr, zi) => {
                    // 3z²
                    return [3*(zr*zr - zi*zi), 6*zr*zi];
                },
                roots: [
                    [1, 0],
                    [-0.5, Math.sqrt(3)/2],
                    [-0.5, -Math.sqrt(3)/2]
                ],
                colors: ['#ff6b6b', '#4ecdc4', '#45b7d1']
            },
            'z4-1': {
                f: (zr, zi) => {
                    // z⁴ - 1
                    const r2 = zr*zr - zi*zi;
                    const i2 = 2*zr*zi;
                    return [r2*r2 - i2*i2 - 1, 2*r2*i2];
                },
                df: (zr, zi) => {
                    // 4z³
                    const r2 = zr*zr - zi*zi;
                    const i2 = 2*zr*zi;
                    return [4*(zr*r2 - zi*i2), 4*(zi*r2 + zr*i2)];
                },
                roots: [[1,0], [0,1], [-1,0], [0,-1]],
                colors: ['#ff6b6b', '#4ecdc4', '#f7dc6f', '#bb8fce']
            },
            'z5-1': {
                f: (zr, zi) => {
                    const r2 = zr*zr - zi*zi;
                    const i2 = 2*zr*zi;
                    const r3 = r2*zr - i2*zi;
                    const i3 = r2*zi + i2*zr;
                    const r4 = r3*zr - i3*zi;
                    const i4 = r3*zi + i3*zr;
                    const r5 = r4*zr - i4*zi;
                    const i5 = r4*zi + i4*zr;
                    return [r5 - 1, i5];
                },
                df: (zr, zi) => {
                    const r2 = zr*zr - zi*zi;
                    const i2 = 2*zr*zi;
                    const r3 = r2*zr - i2*zi;
                    const i3 = r2*zi + i2*zr;
                    const r4 = r3*zr - i3*zi;
                    const i4 = r3*zi + i3*zr;
                    return [5*r4, 5*i4];
                },
                roots: Array.from({length: 5}, (_, k) => [
                    Math.cos(2*Math.PI*k/5),
                    Math.sin(2*Math.PI*k/5)
                ]),
                colors: ['#ff6b6b', '#4ecdc4', '#f7dc6f', '#bb8fce', '#58d68d']
            },
            'z6-1': {
                f: (zr, zi) => {
                    let rn = 1, in_ = 0;
                    for (let i = 0; i < 6; i++) {
                        const tr = rn*zr - in_*zi;
                        in_ = rn*zi + in_*zr;
                        rn = tr;
                    }
                    return [rn - 1, in_];
                },
                df: (zr, zi) => {
                    let rn = 1, in_ = 0;
                    for (let i = 0; i < 5; i++) {
                        const tr = rn*zr - in_*zi;
                        in_ = rn*zi + in_*zr;
                        rn = tr;
                    }
                    return [6*rn, 6*in_];
                },
                roots: Array.from({length: 6}, (_, k) => [
                    Math.cos(2*Math.PI*k/6),
                    Math.sin(2*Math.PI*k/6)
                ]),
                colors: ['#ff6b6b', '#4ecdc4', '#f7dc6f', '#bb8fce', '#58d68d', '#f0b27a']
            },
            'z3-2z+2': {
                f: (zr, zi) => {
                    const r3 = zr*zr*zr - 3*zr*zi*zi;
                    const i3 = 3*zr*zr*zi - zi*zi*zi;
                    return [r3 - 2*zr + 2, i3 - 2*zi];
                },
                df: (zr, zi) => {
                    return [3*(zr*zr - zi*zi) - 2, 6*zr*zi];
                },
                roots: [
                    [-1.769, 0],
                    [0.885, 0.590],
                    [0.885, -0.590]
                ],
                colors: ['#ff6b6b', '#4ecdc4', '#45b7d1']
            },
            'z4-z3-1': {
                f: (zr, zi) => {
                    const r2 = zr*zr - zi*zi;
                    const i2 = 2*zr*zi;
                    const r3 = r2*zr - i2*zi;
                    const i3 = r2*zi + i2*zr;
                    const r4 = r3*zr - i3*zi;
                    const i4 = r3*zi + i3*zr;
                    return [r4 - r3 - 1, i4 - i3];
                },
                df: (zr, zi) => {
                    const r2 = zr*zr - zi*zi;
                    const i2 = 2*zr*zi;
                    const r3 = r2*zr - i2*zi;
                    const i3 = r2*zi + i2*zr;
                    return [4*r3 - 3*r2, 4*i3 - 3*i2];
                },
                roots: [
                    [1.221, 0],
                    [-0.725, 0],
                    [0.252, 1.034],
                    [0.252, -1.034]
                ],
                colors: ['#ff6b6b', '#4ecdc4', '#f7dc6f', '#bb8fce']
            },
            'z8+15z4-16': {
                f: (zr, zi) => {
                    let r4 = 1, i4 = 0;
                    for (let i = 0; i < 4; i++) {
                        const tr = r4*zr - i4*zi;
                        i4 = r4*zi + i4*zr;
                        r4 = tr;
                    }
                    const r8r = r4*r4 - i4*i4;
                    const r8i = 2*r4*i4;
                    return [r8r + 15*r4 - 16, r8i + 15*i4];
                },
                df: (zr, zi) => {
                    let r3 = 1, i3 = 0, r7 = 1, i7 = 0;
                    for (let i = 0; i < 3; i++) {
                        const tr = r3*zr - i3*zi;
                        i3 = r3*zi + i3*zr;
                        r3 = tr;
                    }
                    for (let i = 0; i < 7; i++) {
                        const tr = r7*zr - i7*zi;
                        i7 = r7*zi + i7*zr;
                        r7 = tr;
                    }
                    return [8*r7 + 60*r3, 8*i7 + 60*i3];
                },
                roots: [
                    [1, 0], [-1, 0],
                    [0, 1], [0, -1],
                    [Math.SQRT1_2, Math.SQRT1_2],
                    [-Math.SQRT1_2, Math.SQRT1_2],
                    [Math.SQRT1_2, -Math.SQRT1_2],
                    [-Math.SQRT1_2, -Math.SQRT1_2]
                ],
                colors: ['#ff6b6b', '#4ecdc4', '#f7dc6f', '#bb8fce', '#58d68d', '#f0b27a', '#85c1e9', '#d7bde2']
            }
        };

        const presets = {
            full: { x: 0, y: 0, z: 1.0 },
            boundary: { x: -0.5, y: 0.866, z: 8 },
            spiral: { x: 0.1, y: 0.1, z: 20 },
            junction: { x: 0, y: 0, z: 5 }
        };

        function updateInfo() {
            document.getElementById('centerX').textContent = centerX.toFixed(4);
            document.getElementById('centerY').textContent = centerY.toFixed(4);
            document.getElementById('zoomLevel').textContent = zoom.toFixed(1);
            document.getElementById('iterCount').textContent = maxIter;
            document.getElementById('iterValue').textContent = maxIter;
        }

        function updateRootMarkers() {
            const poly = polynomials[currentPoly];
            const container = document.getElementById('rootMarkers');
            container.innerHTML = '<div style="margin-bottom: 5px; color: #888;">Roots:</div>';

            poly.roots.forEach((root, i) => {
                const div = document.createElement('div');
                div.className = 'root-marker';
                div.innerHTML = `
                    <div class="root-color" style="background: ${poly.colors[i]}"></div>
                    <span>${root[0].toFixed(2)} ${root[1] >= 0 ? '+' : ''}${root[1].toFixed(2)}i</span>
                `;
                container.appendChild(div);
            });
        }

        function newtonIterate(zr, zi, poly) {
            for (let iter = 0; iter < maxIter; iter++) {
                const [fr, fi] = poly.f(zr, zi);
                const [dfr, dfi] = poly.df(zr, zi);

                // Check if we've converged to a root
                for (let r = 0; r < poly.roots.length; r++) {
                    const dr = zr - poly.roots[r][0];
                    const di = zi - poly.roots[r][1];
                    if (dr*dr + di*di < 1e-6) {
                        return { root: r, iterations: iter };
                    }
                }

                // Newton step: z = z - f(z)/f'(z)
                const denom = dfr*dfr + dfi*dfi;
                if (denom < 1e-10) break;

                const nr = (fr*dfr + fi*dfi) / denom;
                const ni = (fi*dfr - fr*dfi) / denom;
                zr -= nr;
                zi -= ni;
            }

            // Didn't converge - find closest root
            let minDist = Infinity, closest = 0;
            for (let r = 0; r < poly.roots.length; r++) {
                const dr = zr - poly.roots[r][0];
                const di = zi - poly.roots[r][1];
                const dist = dr*dr + di*di;
                if (dist < minDist) {
                    minDist = dist;
                    closest = r;
                }
            }
            return { root: closest, iterations: maxIter };
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16),
                parseInt(result[2], 16),
                parseInt(result[3], 16)
            ] : [0, 0, 0];
        }

        function render() {
            loading.style.display = 'block';

            requestAnimationFrame(() => {
                const width = canvas.width;
                const height = canvas.height;
                const imageData = ctx.createImageData(width, height);
                const data = imageData.data;

                const poly = polynomials[currentPoly];
                const scale = 4 / zoom;
                const aspectRatio = width / height;

                for (let py = 0; py < height; py++) {
                    for (let px = 0; px < width; px++) {
                        const zr = centerX + (px / width - 0.5) * scale * aspectRatio;
                        const zi = centerY - (py / height - 0.5) * scale;

                        const result = newtonIterate(zr, zi, poly);
                        const idx = (py * width + px) * 4;

                        const baseColor = hexToRgb(poly.colors[result.root]);
                        let r = baseColor[0], g = baseColor[1], b = baseColor[2];

                        if (colorMode === 'iteration') {
                            const t = result.iterations / maxIter;
                            r = g = b = Math.floor(255 * (1 - t));
                        } else if (colorMode === 'both') {
                            const factor = 1 - (result.iterations / maxIter) * 0.7;
                            r = Math.floor(r * factor);
                            g = Math.floor(g * factor);
                            b = Math.floor(b * factor);
                        }

                        data[idx] = r;
                        data[idx + 1] = g;
                        data[idx + 2] = b;
                        data[idx + 3] = 255;
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                loading.style.display = 'none';
            });
        }

        // Mouse hover for convergence info
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const px = (e.clientX - rect.left) * (canvas.width / rect.width);
            const py = (e.clientY - rect.top) * (canvas.height / rect.height);

            const scale = 4 / zoom;
            const aspectRatio = canvas.width / canvas.height;
            const zr = centerX + (px / canvas.width - 0.5) * scale * aspectRatio;
            const zi = centerY - (py / canvas.height - 0.5) * scale;

            const poly = polynomials[currentPoly];
            const result = newtonIterate(zr, zi, poly);

            const root = poly.roots[result.root];
            document.getElementById('convRoot').textContent =
                `${root[0].toFixed(2)} ${root[1] >= 0 ? '+' : ''}${root[1].toFixed(2)}i`;
            document.getElementById('convIters').textContent = result.iterations;
            document.getElementById('convBox').style.background = poly.colors[result.root];
        });

        // Click to zoom
        canvas.addEventListener('click', (e) => {
            if (isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const px = (e.clientX - rect.left) * (canvas.width / rect.width);
            const py = (e.clientY - rect.top) * (canvas.height / rect.height);

            const scale = 4 / zoom;
            const aspectRatio = canvas.width / canvas.height;

            centerX += (px / canvas.width - 0.5) * scale * aspectRatio;
            centerY -= (py / canvas.height - 0.5) * scale;
            zoom *= 2;

            updateInfo();
            render();
        });

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            dragStartCenterX = centerX;
            dragStartCenterY = centerY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const dx = (e.clientX - dragStartX) / rect.width;
            const dy = (e.clientY - dragStartY) / rect.height;

            const scale = 4 / zoom;
            const aspectRatio = canvas.width / canvas.height;

            centerX = dragStartCenterX - dx * scale * aspectRatio;
            centerY = dragStartCenterY + dy * scale;

            updateInfo();
            render();
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'crosshair';
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'crosshair';
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.8 : 1.25;
            zoom *= factor;
            updateInfo();
            render();
        });

        // Controls
        document.getElementById('resetBtn').addEventListener('click', () => {
            centerX = 0;
            centerY = 0;
            zoom = 1.0;
            updateInfo();
            render();
        });

        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            zoom *= 0.5;
            updateInfo();
            render();
        });

        document.getElementById('iterSlider').addEventListener('input', (e) => {
            maxIter = parseInt(e.target.value);
            updateInfo();
            render();
        });

        document.getElementById('polynomialSelect').addEventListener('change', (e) => {
            currentPoly = e.target.value;
            centerX = 0;
            centerY = 0;
            zoom = 1.0;
            updateInfo();
            updateRootMarkers();
            render();
        });

        document.getElementById('colorMode').addEventListener('change', (e) => {
            colorMode = e.target.value;
            render();
        });

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = presets[btn.dataset.preset];
                centerX = preset.x;
                centerY = preset.y;
                zoom = preset.z;
                currentPoly = 'z3-1';
                document.getElementById('polynomialSelect').value = 'z3-1';
                updateInfo();
                updateRootMarkers();
                render();
            });
        });

        // Initial render
        updateInfo();
        updateRootMarkers();
        render();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
