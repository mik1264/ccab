<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Secretary Problem - The 37% Rule</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e8e8e8;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 25px;
        }

        h1 {
            font-size: 2.2rem;
            background: linear-gradient(135deg, #9b59b6, #3498db, #1abc9c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #aaa;
            font-size: 1.1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 330px;
            gap: 25px;
        }

        @media (max-width: 1100px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .viz-section {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 20px;
        }

        .canvas-container {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
        }

        canvas {
            border-radius: 8px;
            background: #0a0a0a;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: #fff;
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }

        .control-group label {
            font-size: 0.85rem;
            color: #aaa;
        }

        select, input[type="number"] {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.5);
            color: #fff;
            font-size: 0.9rem;
            width: 80px;
        }

        .stats-display {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-box {
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #9b59b6;
        }

        .stat-value.success { color: #2ecc71; }
        .stat-value.failure { color: #e74c3c; }

        .phase-indicator {
            text-align: center;
            padding: 15px;
            margin-top: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            font-size: 1.1rem;
        }

        .phase-indicator.calibrating {
            border-left: 4px solid #f39c12;
        }

        .phase-indicator.selecting {
            border-left: 4px solid #2ecc71;
        }

        .phase-indicator.result {
            border-left: 4px solid #9b59b6;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .exp-card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 18px;
            border-left: 4px solid #9b59b6;
        }

        .exp-card h3 {
            color: #9b59b6;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .exp-card p {
            color: #ccc;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .formula {
            background: rgba(0,0,0,0.4);
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            color: #9b59b6;
            text-align: center;
            font-size: 0.9rem;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #9b59b6;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            opacity: 0.8;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .back-link:hover {
            opacity: 1;
        }

        .highlight {
            color: #f39c12;
            font-weight: bold;
        }

        .candidate-info {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            text-align: center;
        }

        .candidate-info h4 {
            color: #9b59b6;
            margin-bottom: 10px;
        }

        .current-candidate {
            font-size: 2rem;
            font-weight: bold;
            color: #fff;
        }

        .threshold-display {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #aaa;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>The Secretary Problem</h1>
            <p class="subtitle">Martin Gardner (1960) - The 37% Rule</p>
        </header>

        <div class="main-content">
            <div class="viz-section">
                <div class="canvas-container">
                    <canvas id="secretaryCanvas" width="700" height="400"></canvas>
                </div>

                <div class="controls">
                    <button class="btn btn-primary" id="runBtn">Run Single Trial</button>
                    <button class="btn btn-secondary" id="run100Btn">Run 100 Trials</button>
                    <button class="btn btn-secondary" id="resetBtn">Reset Stats</button>

                    <div class="control-group">
                        <label>Candidates:</label>
                        <input type="number" id="candidateCount" value="20" min="5" max="100">
                    </div>

                    <div class="control-group">
                        <label>Speed:</label>
                        <select id="speedSelect">
                            <option value="slow">Slow</option>
                            <option value="medium" selected>Medium</option>
                            <option value="fast">Fast</option>
                            <option value="instant">Instant</option>
                        </select>
                    </div>
                </div>

                <div class="phase-indicator" id="phaseIndicator">
                    Click "Run Single Trial" to begin
                </div>

                <div class="stats-display">
                    <div class="stat-box">
                        <div class="stat-label">Trials</div>
                        <div class="stat-value" id="trialCount">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Successes</div>
                        <div class="stat-value success" id="successCount">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Success Rate</div>
                        <div class="stat-value" id="successRate">--</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Expected (1/e)</div>
                        <div class="stat-value" id="expected">36.8%</div>
                    </div>
                </div>

                <div class="candidate-info">
                    <h4>Current Interview</h4>
                    <div class="current-candidate" id="currentCandidate">--</div>
                    <div class="threshold-display" id="thresholdDisplay">Threshold: --</div>
                </div>
            </div>

            <div class="sidebar">
                <div class="exp-card">
                    <h3>üíº The Problem</h3>
                    <p>You're hiring a secretary from <span class="highlight">n candidates</span>. Each is interviewed once and immediately accepted or rejected. You only know how they compare to those <span class="highlight">already seen</span>. How do you maximize your chance of hiring the <span class="highlight">best</span> candidate?</p>
                </div>

                <div class="exp-card">
                    <h3>üéØ The Optimal Strategy</h3>
                    <p>Reject the first <span class="highlight">n/e ‚âà 37%</span> of candidates (calibration phase). Then hire the <span class="highlight">first candidate better than all</span> those seen so far.</p>
                    <div class="formula">
                        Observe n/e candidates<br>
                        Then pick first > threshold
                    </div>
                </div>

                <div class="exp-card">
                    <h3>üìä The Magic of 1/e</h3>
                    <p>Remarkably, this strategy finds the best candidate with probability <span class="highlight">1/e ‚âà 36.8%</span>‚Äîregardless of whether there are 10 or 10 million candidates! Gilbert & Mosteller proved this at Harvard in the 1960s.</p>
                </div>

                <div class="exp-card">
                    <h3>üíï Real-World Applications</h3>
                    <p>Also called the <span class="highlight">Marriage Problem</span>: date ~37% of potential partners, then commit to the next one better than all previous! Applied to hiring, house hunting, and any sequential decision-making.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('secretaryCanvas');
        const ctx = canvas.getContext('2d');

        let trials = 0;
        let successes = 0;
        let running = false;

        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function drawCandidate(index, value, n, state, best, threshold, selectedIndex) {
            const padding = 40;
            const barWidth = (canvas.width - 2 * padding) / n;
            const maxHeight = canvas.height - 80;

            const x = padding + index * barWidth;
            const height = (value / n) * maxHeight;
            const y = canvas.height - 40 - height;

            // Determine color
            let color;
            if (state === 'pending') {
                color = 'rgba(100, 100, 100, 0.3)';
            } else if (state === 'calibrating') {
                color = '#f39c12';
            } else if (state === 'rejected') {
                color = 'rgba(231, 76, 60, 0.5)';
            } else if (state === 'selected') {
                color = value === n ? '#2ecc71' : '#e74c3c';
            } else if (state === 'passed') {
                color = 'rgba(155, 89, 182, 0.5)';
            }

            ctx.fillStyle = color;
            ctx.fillRect(x + 2, y, barWidth - 4, height);

            // Mark the best candidate
            if (value === n) {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('‚òÖ', x + barWidth / 2, y - 5);
            }

            // Draw threshold line during selection phase
            if (threshold > 0 && state !== 'pending') {
                const thresholdY = canvas.height - 40 - (threshold / n) * maxHeight;
                ctx.strokeStyle = 'rgba(241, 196, 15, 0.8)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(padding, thresholdY);
                ctx.lineTo(canvas.width - padding, thresholdY);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        function draw(candidates, states, threshold, currentIndex, selectedIndex) {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const n = candidates.length;

            // Draw calibration zone
            const calibrationEnd = Math.floor(n / Math.E);
            const padding = 40;
            const barWidth = (canvas.width - 2 * padding) / n;

            ctx.fillStyle = 'rgba(243, 156, 18, 0.1)';
            ctx.fillRect(padding, 40, calibrationEnd * barWidth, canvas.height - 80);

            ctx.fillStyle = '#f39c12';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Calibration (37%)', padding + (calibrationEnd * barWidth) / 2, 30);

            ctx.fillStyle = '#2ecc71';
            ctx.fillText('Selection Phase', padding + calibrationEnd * barWidth + (n - calibrationEnd) * barWidth / 2, 30);

            // Draw candidates
            candidates.forEach((value, i) => {
                drawCandidate(i, value, n, states[i], n, threshold, selectedIndex);
            });

            // Draw current pointer
            if (currentIndex >= 0 && currentIndex < n) {
                const x = padding + currentIndex * barWidth + barWidth / 2;
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(x, canvas.height - 30);
                ctx.lineTo(x - 8, canvas.height - 15);
                ctx.lineTo(x + 8, canvas.height - 15);
                ctx.closePath();
                ctx.fill();
            }
        }

        async function runTrial(animate = true) {
            if (running) return;
            running = true;

            const n = parseInt(document.getElementById('candidateCount').value);
            const speed = document.getElementById('speedSelect').value;

            const delays = {
                slow: 300,
                medium: 100,
                fast: 30,
                instant: 0
            };
            const delay = delays[speed];

            // Generate random order of candidates (1 to n, where n is best)
            const candidates = shuffle([...Array(n)].map((_, i) => i + 1));
            const states = Array(n).fill('pending');

            const calibrationEnd = Math.floor(n / Math.E);
            let threshold = 0;
            let selectedIndex = -1;

            document.getElementById('runBtn').disabled = true;
            document.getElementById('run100Btn').disabled = true;

            // Calibration phase
            document.getElementById('phaseIndicator').className = 'phase-indicator calibrating';
            document.getElementById('phaseIndicator').textContent = `Calibration Phase: Observing first ${calibrationEnd} candidates`;

            for (let i = 0; i < calibrationEnd; i++) {
                states[i] = 'calibrating';
                threshold = Math.max(threshold, candidates[i]);

                document.getElementById('currentCandidate').textContent = `#${i + 1}: Score ${candidates[i]}/${n}`;
                document.getElementById('thresholdDisplay').textContent = `Best so far: ${threshold}`;

                if (animate && delay > 0) {
                    draw(candidates, states, threshold, i, selectedIndex);
                    await new Promise(r => setTimeout(r, delay));
                }
            }

            // Selection phase
            document.getElementById('phaseIndicator').className = 'phase-indicator selecting';
            document.getElementById('phaseIndicator').textContent = `Selection Phase: Looking for candidate > ${threshold}`;

            for (let i = calibrationEnd; i < n; i++) {
                states[i] = 'passed';

                document.getElementById('currentCandidate').textContent = `#${i + 1}: Score ${candidates[i]}/${n}`;

                if (animate && delay > 0) {
                    draw(candidates, states, threshold, i, selectedIndex);
                    await new Promise(r => setTimeout(r, delay));
                }

                if (candidates[i] > threshold) {
                    // Select this candidate
                    selectedIndex = i;
                    states[i] = 'selected';
                    break;
                } else {
                    states[i] = 'rejected';
                }
            }

            // If no one selected, take the last one
            if (selectedIndex === -1) {
                selectedIndex = n - 1;
                states[n - 1] = 'selected';
            }

            // Check if we got the best
            const gotBest = candidates[selectedIndex] === n;
            if (gotBest) successes++;
            trials++;

            // Update display
            document.getElementById('trialCount').textContent = trials;
            document.getElementById('successCount').textContent = successes;
            document.getElementById('successRate').textContent = (successes / trials * 100).toFixed(1) + '%';

            const resultClass = gotBest ? 'success' : 'failure';
            document.getElementById('phaseIndicator').className = 'phase-indicator result';
            document.getElementById('phaseIndicator').innerHTML = gotBest
                ? `<span style="color:#2ecc71">‚úì SUCCESS!</span> Selected candidate #${selectedIndex + 1} (the best!)`
                : `<span style="color:#e74c3c">‚úó Failed</span> Selected #${selectedIndex + 1} (score ${candidates[selectedIndex]}), best was #${candidates.indexOf(n) + 1}`;

            draw(candidates, states, threshold, -1, selectedIndex);

            document.getElementById('runBtn').disabled = false;
            document.getElementById('run100Btn').disabled = false;
            running = false;
        }

        async function run100Trials() {
            if (running) return;

            document.getElementById('runBtn').disabled = true;
            document.getElementById('run100Btn').disabled = true;

            for (let i = 0; i < 100; i++) {
                await runTrialSilent();
            }

            document.getElementById('phaseIndicator').className = 'phase-indicator result';
            document.getElementById('phaseIndicator').textContent = `Completed 100 trials. Success rate: ${(successes / trials * 100).toFixed(1)}%`;

            document.getElementById('runBtn').disabled = false;
            document.getElementById('run100Btn').disabled = false;
        }

        async function runTrialSilent() {
            const n = parseInt(document.getElementById('candidateCount').value);
            const candidates = shuffle([...Array(n)].map((_, i) => i + 1));

            const calibrationEnd = Math.floor(n / Math.E);
            let threshold = 0;
            let selectedIndex = -1;

            // Calibration
            for (let i = 0; i < calibrationEnd; i++) {
                threshold = Math.max(threshold, candidates[i]);
            }

            // Selection
            for (let i = calibrationEnd; i < n; i++) {
                if (candidates[i] > threshold) {
                    selectedIndex = i;
                    break;
                }
            }

            if (selectedIndex === -1) selectedIndex = n - 1;

            const gotBest = candidates[selectedIndex] === n;
            if (gotBest) successes++;
            trials++;

            document.getElementById('trialCount').textContent = trials;
            document.getElementById('successCount').textContent = successes;
            document.getElementById('successRate').textContent = (successes / trials * 100).toFixed(1) + '%';
        }

        function reset() {
            trials = 0;
            successes = 0;
            document.getElementById('trialCount').textContent = '0';
            document.getElementById('successCount').textContent = '0';
            document.getElementById('successRate').textContent = '--';
            document.getElementById('phaseIndicator').className = 'phase-indicator';
            document.getElementById('phaseIndicator').textContent = 'Click "Run Single Trial" to begin';
            document.getElementById('currentCandidate').textContent = '--';
            document.getElementById('thresholdDisplay').textContent = 'Threshold: --';

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Event listeners
        document.getElementById('runBtn').addEventListener('click', () => runTrial(true));
        document.getElementById('run100Btn').addEventListener('click', run100Trials);
        document.getElementById('resetBtn').addEventListener('click', reset);

        // Initialize
        reset();
    </script>
</body>
</html>
