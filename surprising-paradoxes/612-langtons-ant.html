<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Langton's Ant - Surprising Paradoxes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0f0a0a 0%, #1a1515 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(135deg, #e74c3c 0%, #f39c12 50%, #2ecc71 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2em;
            color: #888;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
        }

        @media (max-width: 1000px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .canvas-container {
            background: #111;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        #antCanvas {
            display: block;
            width: 100%;
        }

        .info-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.85em;
            font-family: monospace;
        }

        .info-overlay span {
            color: #f39c12;
        }

        .phase-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9em;
        }

        .phase-simplicity { color: #3498db; }
        .phase-chaos { color: #e74c3c; }
        .phase-highway { color: #2ecc71; }

        .controls {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
        }

        .control-section {
            margin-bottom: 25px;
        }

        .control-section h3 {
            color: #f39c12;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 1px solid rgba(243,156,18,0.3);
            padding-bottom: 8px;
        }

        .control-row {
            margin-bottom: 15px;
        }

        .control-row label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 0.9em;
        }

        .control-row input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-row .value {
            text-align: right;
            font-family: monospace;
            color: #f39c12;
            font-size: 0.9em;
        }

        .btn-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #e74c3c, #f39c12);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(243,156,18,0.4);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #e0e0e0;
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
        }

        .rules-display {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .rule-white { color: #ecf0f1; }
        .rule-black { color: #7f8c8d; }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-box {
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.2em;
            color: #f39c12;
            font-family: monospace;
        }

        .stat-label {
            font-size: 0.75em;
            color: #888;
            margin-top: 4px;
        }

        .phase-timeline {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .phase-bar {
            display: flex;
            height: 20px;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }

        .phase-segment {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            color: white;
        }

        .phase-seg-simple { background: #3498db; width: 5%; }
        .phase-seg-chaos { background: #e74c3c; width: 45%; }
        .phase-seg-highway { background: #2ecc71; width: 50%; }

        .explanation {
            margin-top: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .exp-card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            border-left: 4px solid #f39c12;
        }

        .exp-card h3 {
            color: #f39c12;
            margin-bottom: 10px;
        }

        .exp-card p {
            color: #bbb;
            line-height: 1.6;
        }

        .back-link {
            display: inline-block;
            color: #f39c12;
            text-decoration: none;
            margin-bottom: 20px;
            transition: transform 0.2s;
        }

        .back-link:hover {
            transform: translateX(-5px);
        }

        .skip-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin-top: 10px;
        }

        .skip-btn {
            padding: 8px;
            font-size: 0.75em;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

        <header>
            <h1>Langton's Ant</h1>
            <p class="subtitle">Order emerges from chaos... eventually</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="antCanvas" width="800" height="700"></canvas>
                <div class="info-overlay">
                    <div>Steps: <span id="stepCount">0</span></div>
                    <div>Black cells: <span id="blackCount">0</span></div>
                </div>
                <div class="phase-indicator" id="phaseIndicator">
                    <span class="phase-simplicity">Phase: Simplicity</span>
                </div>
            </div>

            <div class="controls">
                <div class="control-section">
                    <h3>Animation</h3>
                    <div class="btn-group">
                        <button class="btn-primary" id="playBtn">‚ñ∂ Play</button>
                        <button class="btn-secondary" id="stepBtn">Step</button>
                        <button class="btn-secondary" id="resetBtn">Reset</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Speed</h3>
                    <div class="control-row">
                        <label>Steps per frame</label>
                        <input type="range" id="speedSlider" min="1" max="500" value="10">
                        <div class="value"><span id="speedValue">10</span> steps/frame</div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Skip to Phase</h3>
                    <div class="skip-buttons">
                        <button class="btn-secondary skip-btn" data-steps="100">100</button>
                        <button class="btn-secondary skip-btn" data-steps="1000">1K</button>
                        <button class="btn-secondary skip-btn" data-steps="5000">5K</button>
                        <button class="btn-secondary skip-btn" data-steps="10000">10K</button>
                        <button class="btn-secondary skip-btn" data-steps="11000">11K</button>
                        <button class="btn-secondary skip-btn" data-steps="15000">15K</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="stat-value" id="statSteps">0</div>
                            <div class="stat-label">Total Steps</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="statBlack">0</div>
                            <div class="stat-label">Black Cells</div>
                        </div>
                    </div>
                </div>

                <div class="control-section">
                    <h3>The Rules</h3>
                    <div class="rules-display">
                        <span class="rule-white">‚óª White:</span> Turn RIGHT, flip to black, move<br>
                        <span class="rule-black">‚óº Black:</span> Turn LEFT, flip to white, move
                    </div>
                </div>

                <div class="control-section">
                    <h3>Phase Timeline</h3>
                    <div class="phase-timeline">
                        <div style="font-size: 0.8em; color: #888;">Typical progression:</div>
                        <div class="phase-bar">
                            <div class="phase-segment phase-seg-simple">~500</div>
                            <div class="phase-segment phase-seg-chaos">~10,000</div>
                            <div class="phase-segment phase-seg-highway">‚àû</div>
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 0.7em; color: #666; margin-top: 4px;">
                            <span>Simple</span>
                            <span>Chaos</span>
                            <span>Highway</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="explanation">
            <div class="exp-card">
                <h3>The Three Phases</h3>
                <p><strong>1. Simplicity (0-500):</strong> Symmetric, predictable patterns.<br>
                <strong>2. Chaos (500-10,000):</strong> Pseudo-random, seemingly disordered growth.<br>
                <strong>3. Highway (~10,000+):</strong> Suddenly, a perfectly regular diagonal "highway" emerges and continues forever. Why? No one knows!</p>
            </div>

            <div class="exp-card">
                <h3>The Unsolved Mystery</h3>
                <p>Every initial configuration ever tested eventually produces the highway. This "Cohen-Kong conjecture" remains unproven after 40 years! We can't mathematically guarantee that chaos will always give way to order‚Äîwe just observe that it does. Every. Single. Time.</p>
            </div>

            <div class="exp-card">
                <h3>Turing Complete</h3>
                <p>In 2000, mathematicians proved Langton's Ant is Turing-complete‚Äîit can compute anything a regular computer can. From two trivial rules emerges universal computation! This makes the highway conjecture likely unprovable, as it would require solving the halting problem.</p>
            </div>

            <div class="exp-card">
                <h3>The Paradox</h3>
                <p>How does strict order emerge from complete chaos? The ant follows deterministic rules with no randomness, yet produces apparent disorder for thousands of steps‚Äîthen suddenly "decides" to build an infinitely repeating structure. The transition is abrupt and inexplicable.</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('antCanvas');
        const ctx = canvas.getContext('2d');

        // Grid settings
        const gridSize = 300;
        const cellSize = Math.min(canvas.width, canvas.height) / gridSize;

        // State
        let grid = new Map();
        let antX = Math.floor(gridSize / 2);
        let antY = Math.floor(gridSize / 2);
        let antDir = 0; // 0=up, 1=right, 2=down, 3=left
        let steps = 0;
        let blackCount = 0;
        let isPlaying = false;
        let speed = 10;
        let animationFrame = null;

        // Direction vectors
        const dx = [0, 1, 0, -1];
        const dy = [-1, 0, 1, 0];

        function getCell(x, y) {
            return grid.get(`${x},${y}`) || 0;
        }

        function setCell(x, y, val) {
            const key = `${x},${y}`;
            const oldVal = grid.get(key) || 0;

            if (val === 0) {
                grid.delete(key);
            } else {
                grid.set(key, val);
            }

            if (oldVal === 0 && val === 1) blackCount++;
            else if (oldVal === 1 && val === 0) blackCount--;
        }

        function step() {
            const currentCell = getCell(antX, antY);

            if (currentCell === 0) {
                // White: turn right
                antDir = (antDir + 1) % 4;
                setCell(antX, antY, 1);
            } else {
                // Black: turn left
                antDir = (antDir + 3) % 4;
                setCell(antX, antY, 0);
            }

            // Move forward
            antX += dx[antDir];
            antY += dy[antDir];

            steps++;
        }

        function getPhase() {
            if (steps < 500) return 'simplicity';
            if (steps < 10000) return 'chaos';
            return 'highway';
        }

        function updatePhaseIndicator() {
            const phase = getPhase();
            const indicator = document.getElementById('phaseIndicator');

            if (phase === 'simplicity') {
                indicator.innerHTML = '<span class="phase-simplicity">Phase: Simplicity</span>';
            } else if (phase === 'chaos') {
                indicator.innerHTML = '<span class="phase-chaos">Phase: Chaos</span>';
            } else {
                indicator.innerHTML = '<span class="phase-highway">Phase: Highway! üõ£Ô∏è</span>';
            }
        }

        function draw() {
            // Calculate view bounds centered on ant
            const viewCells = Math.floor(Math.min(canvas.width, canvas.height) / cellSize);
            const halfView = Math.floor(viewCells / 2);

            const startX = antX - halfView;
            const startY = antY - halfView;

            // Clear canvas
            ctx.fillStyle = '#ecf0f1';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw black cells
            ctx.fillStyle = '#2c3e50';
            for (const [key, val] of grid) {
                if (val === 1) {
                    const [x, y] = key.split(',').map(Number);
                    const screenX = (x - startX) * cellSize;
                    const screenY = (y - startY) * cellSize;

                    if (screenX >= -cellSize && screenX < canvas.width + cellSize &&
                        screenY >= -cellSize && screenY < canvas.height + cellSize) {
                        ctx.fillRect(screenX, screenY, cellSize, cellSize);
                    }
                }
            }

            // Draw ant
            const antScreenX = (antX - startX) * cellSize + cellSize / 2;
            const antScreenY = (antY - startY) * cellSize + cellSize / 2;

            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(antScreenX, antScreenY, cellSize * 0.8, 0, Math.PI * 2);
            ctx.fill();

            // Draw direction indicator
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(antScreenX, antScreenY);
            ctx.lineTo(
                antScreenX + dx[antDir] * cellSize * 0.6,
                antScreenY + dy[antDir] * cellSize * 0.6
            );
            ctx.stroke();

            updateStats();
            updatePhaseIndicator();
        }

        function updateStats() {
            document.getElementById('stepCount').textContent = steps.toLocaleString();
            document.getElementById('blackCount').textContent = blackCount.toLocaleString();
            document.getElementById('statSteps').textContent = steps.toLocaleString();
            document.getElementById('statBlack').textContent = blackCount.toLocaleString();
        }

        function animate() {
            if (!isPlaying) return;

            for (let i = 0; i < speed; i++) {
                step();
            }

            draw();
            animationFrame = requestAnimationFrame(animate);
        }

        function play() {
            isPlaying = true;
            document.getElementById('playBtn').textContent = '‚è∏ Pause';
            animate();
        }

        function pause() {
            isPlaying = false;
            document.getElementById('playBtn').textContent = '‚ñ∂ Play';
            if (animationFrame) cancelAnimationFrame(animationFrame);
        }

        function reset() {
            pause();
            grid.clear();
            antX = Math.floor(gridSize / 2);
            antY = Math.floor(gridSize / 2);
            antDir = 0;
            steps = 0;
            blackCount = 0;
            draw();
        }

        function skipToStep(targetSteps) {
            pause();
            while (steps < targetSteps) {
                step();
            }
            draw();
        }

        // Event listeners
        document.getElementById('playBtn').addEventListener('click', () => {
            if (isPlaying) pause();
            else play();
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            pause();
            step();
            draw();
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = speed;
        });

        document.querySelectorAll('.skip-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const targetSteps = parseInt(btn.dataset.steps);
                if (steps < targetSteps) {
                    skipToStep(targetSteps);
                }
            });
        });

        // Initialize
        draw();
    </script>
</body>
</html>
