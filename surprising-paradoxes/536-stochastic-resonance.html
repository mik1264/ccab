<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stochastic Resonance - When Noise Improves Signal Detection</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a1a2a 100%);
            min-height: 100vh;
            color: #e0e8f0;
            line-height: 1.9;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 12px 24px;
            background: rgba(0,200,255,0.15);
            backdrop-filter: blur(10px);
            color: #00d4ff;
            text-decoration: none;
            border-radius: 30px;
            font-size: 14px;
            z-index: 1000;
            transition: all 0.3s;
            border: 1px solid rgba(0,212,255,0.3);
        }

        .back-link:hover {
            background: rgba(0,200,255,0.3);
            transform: translateX(-5px);
        }

        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 80px 30px 60px;
        }

        header {
            text-align: center;
            margin-bottom: 60px;
        }

        h1 {
            font-size: 3.2rem;
            font-weight: 400;
            background: linear-gradient(135deg, #00d4ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
            letter-spacing: 1px;
        }

        .subtitle {
            font-size: 1.5rem;
            color: #88a8c8;
            font-style: italic;
        }

        .paradox-statement {
            background: linear-gradient(135deg, rgba(0,212,255,0.15) 0%, rgba(0,255,136,0.1) 100%);
            border-left: 4px solid #00d4ff;
            padding: 35px 45px;
            margin: 50px 0;
            border-radius: 0 20px 20px 0;
            font-size: 1.35rem;
            text-align: center;
            color: #b0d8f0;
        }

        .paradox-statement strong {
            color: #00ff88;
        }

        h2 {
            font-size: 1.9rem;
            color: #00d4ff;
            margin: 60px 0 30px;
            font-weight: 400;
            border-bottom: 1px solid rgba(0,212,255,0.2);
            padding-bottom: 15px;
        }

        h3 {
            font-size: 1.4rem;
            color: #00ff88;
            margin: 40px 0 20px;
            font-weight: 400;
        }

        p {
            margin-bottom: 22px;
            color: #b0c8d8;
            font-size: 1.1rem;
        }

        .highlight {
            color: #00ff88;
            font-weight: 500;
        }

        .simulation-container {
            background: rgba(0,20,40,0.6);
            border-radius: 20px;
            padding: 35px;
            margin: 50px 0;
            border: 1px solid rgba(0,212,255,0.2);
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
        }

        .sim-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .sim-title {
            font-size: 1.3rem;
            color: #00d4ff;
        }

        .controls {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 12px;
            color: #88a8c8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        input[type="range"] {
            width: 150px;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(0,212,255,0.2);
            border-radius: 3px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #00d4ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0,212,255,0.5);
        }

        button {
            background: rgba(0,212,255,0.2);
            border: 1px solid rgba(0,212,255,0.5);
            color: #00d4ff;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            font-family: inherit;
        }

        button:hover {
            background: rgba(0,212,255,0.4);
            transform: translateY(-2px);
        }

        button.active {
            background: linear-gradient(135deg, #00d4ff, #00ff88);
            color: #0a0a1a;
            font-weight: 600;
        }

        canvas {
            width: 100%;
            border-radius: 12px;
            background: rgba(0,0,0,0.4);
        }

        .canvas-row {
            display: grid;
            grid-template-columns: 1fr;
            gap: 25px;
            margin-top: 25px;
        }

        .canvas-box {
            position: relative;
        }

        .canvas-label {
            position: absolute;
            top: 10px;
            left: 15px;
            font-size: 12px;
            color: #00d4ff;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: rgba(0,20,40,0.8);
            padding: 5px 12px;
            border-radius: 15px;
        }

        .stats-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-top: 30px;
            padding-top: 25px;
            border-top: 1px solid rgba(0,212,255,0.2);
        }

        .stat {
            text-align: center;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 300;
            color: #00ff88;
            font-family: 'Courier New', monospace;
        }

        .stat-label {
            font-size: 11px;
            color: #88a8c8;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 5px;
        }

        .resonance-curve {
            background: rgba(0,0,0,0.5);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
        }

        .equation {
            background: rgba(0,100,150,0.2);
            padding: 20px 30px;
            border-radius: 15px;
            font-family: 'Courier New', monospace;
            text-align: center;
            margin: 30px 0;
            font-size: 1.1rem;
            color: #00d4ff;
            border: 1px solid rgba(0,212,255,0.2);
        }

        .biology-box {
            background: linear-gradient(135deg, rgba(0,255,136,0.1) 0%, rgba(0,212,255,0.1) 100%);
            border-radius: 20px;
            padding: 35px;
            margin: 40px 0;
            border: 1px solid rgba(0,255,136,0.2);
        }

        .biology-box h3 {
            margin-top: 0;
        }

        .applications-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }

        .application-card {
            background: rgba(0,0,0,0.3);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(0,212,255,0.15);
            transition: all 0.3s;
        }

        .application-card:hover {
            transform: translateY(-5px);
            border-color: rgba(0,255,136,0.4);
        }

        .application-card h4 {
            color: #00ff88;
            margin-bottom: 12px;
            font-weight: 400;
        }

        .application-card p {
            font-size: 0.95rem;
            color: #88a8c8;
            margin: 0;
        }

        .insight-box {
            background: linear-gradient(135deg, rgba(255,200,0,0.1) 0%, rgba(255,100,0,0.1) 100%);
            border-left: 4px solid #ffcc00;
            padding: 25px 30px;
            margin: 40px 0;
            border-radius: 0 15px 15px 0;
        }

        .insight-box strong {
            color: #ffcc00;
        }

        footer {
            text-align: center;
            margin-top: 80px;
            padding: 40px 0;
            border-top: 1px solid rgba(0,212,255,0.2);
            color: #5a7a8a;
            font-size: 0.9rem;
        }

        footer a {
            color: #00d4ff;
            text-decoration: none;
        }

        @media (max-width: 768px) {
            h1 { font-size: 2.2rem; }
            .container { padding: 60px 20px 40px; }
            .simulation-container { padding: 20px; }
            input[type="range"] { width: 100px; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>Stochastic Resonance</h1>
            <p class="subtitle">The counterintuitive phenomenon where noise improves signal detection</p>
        </header>

        <div class="paradox-statement">
            <strong>The Paradox:</strong> Adding random noise to a weak signal can make it
            <strong>easier</strong> to detect, not harder. There exists an optimal level of noise
            that maximizes signal clarity.
        </div>

        <h2>The Counterintuitive Truth</h2>

        <p>
            Every engineer knows noise is the enemy. Communications systems spend billions fighting it.
            Medical imaging strives to eliminate it. Your ears strain against it. The fundamental assumption
            of signal processing is that noise degrades information.
        </p>

        <p>
            <span class="highlight">But sometimes that assumption is spectacularly wrong.</span>
        </p>

        <p>
            In certain systems, adding noise to a weak signal doesn't drown it out—it <em>reveals</em> it.
            This phenomenon, called <strong>stochastic resonance</strong>, challenges our deepest intuitions
            about randomness and information.
        </p>

        <h2>Experience It Yourself</h2>

        <p>
            Below is a weak periodic signal—so weak it barely crosses the detection threshold.
            Adjust the noise level and watch what happens to the detected output.
        </p>

        <div class="simulation-container">
            <div class="sim-header">
                <div class="sim-title">Interactive Stochastic Resonance Simulator</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Noise Intensity</label>
                        <input type="range" id="noiseSlider" min="0" max="100" value="0">
                    </div>
                    <div class="control-group">
                        <label>Signal Strength</label>
                        <input type="range" id="signalSlider" min="0" max="100" value="30">
                    </div>
                    <button id="resetBtn">Reset</button>
                </div>
            </div>

            <div class="canvas-row">
                <div class="canvas-box">
                    <canvas id="mainCanvas" height="400"></canvas>
                    <span class="canvas-label">Signal + Noise + Threshold Detection</span>
                </div>
            </div>

            <div class="stats-panel">
                <div class="stat">
                    <div class="stat-value" id="snrValue">0.00</div>
                    <div class="stat-label">Output SNR</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="detectRate">0%</div>
                    <div class="stat-label">Detection Rate</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="noiseLevel">0.00</div>
                    <div class="stat-label">Noise Level</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="optimalZone">—</div>
                    <div class="stat-label">Optimal Zone</div>
                </div>
            </div>

            <div class="resonance-curve">
                <canvas id="curveCanvas" height="200"></canvas>
            </div>
        </div>

        <h2>How Does This Magic Work?</h2>

        <p>
            The key is that many detection systems have a <span class="highlight">threshold</span>.
            A neuron fires only when its input exceeds a certain voltage. A detector clicks only when
            the signal crosses a trigger level. A decision is made only when evidence passes a criterion.
        </p>

        <h3>The Three Regimes</h3>

        <div class="insight-box">
            <p><strong>Too Little Noise:</strong> The weak signal never crosses the threshold. Output is flat—no information transmitted.</p>
            <p><strong>Optimal Noise:</strong> Random fluctuations occasionally boost the signal over the threshold, but only when the signal itself is high. The noise "samples" the signal at its peaks.</p>
            <p><strong>Too Much Noise:</strong> Random crossings overwhelm the signal pattern. Output is dominated by noise.</p>
        </div>

        <div class="equation">
            SNR<sub>output</sub> = f(noise) → Maximum at optimal noise level σ<sub>opt</sub>
        </div>

        <p>
            The mathematical beauty is in the <em>resonance</em>: there's a specific noise level where the
            random fluctuations and the periodic signal synchronize. The noise acts like a microscope,
            amplifying what was previously invisible.
        </p>

        <h2>Biology Got There First</h2>

        <div class="biology-box">
            <h3>The Crayfish That Uses Noise</h3>
            <p>
                In 1993, scientists discovered that crayfish mechanoreceptors—the sensory cells in their
                tail that detect water movements from predators—actually work <em>better</em> with background noise.
            </p>
            <p>
                The crayfish's neurons are tuned to be sub-threshold: faint water movements alone don't trigger them.
                But the natural turbulence of water provides just enough random stimulation that when a predator
                approaches, the combined signal crosses the threshold.
            </p>
            <p>
                <span class="highlight">Evolution discovered stochastic resonance millions of years before we did.</span>
            </p>
        </div>

        <h2>Real-World Applications</h2>

        <div class="applications-grid">
            <div class="application-card">
                <h4>Neural Prosthetics</h4>
                <p>Cochlear implants and other neural interfaces can be improved by adding controlled noise, helping weak neural signals cross detection thresholds.</p>
            </div>
            <div class="application-card">
                <h4>Climate Science</h4>
                <p>Ice age cycles may be triggered by stochastic resonance—weak orbital variations amplified by climate noise to cause dramatic shifts.</p>
            </div>
            <div class="application-card">
                <h4>Cancer Treatment</h4>
                <p>2025 research shows alternating between chemotherapy approaches (like switching between losing games) can outperform either alone.</p>
            </div>
            <div class="application-card">
                <h4>Human Perception</h4>
                <p>Adding vibration to the soles of elderly patients' feet improves their balance by enhancing proprioceptive signals.</p>
            </div>
            <div class="application-card">
                <h4>Image Processing</h4>
                <p>Dithering—adding noise to images—allows displays to show more colors than they have pixels, exploiting spatial stochastic resonance.</p>
            </div>
            <div class="application-card">
                <h4>Brain Function</h4>
                <p>The brain's intrinsic noise may not be a bug but a feature—enabling neurons to respond to stimuli they'd otherwise miss.</p>
            </div>
        </div>

        <h2>The Deep Insight</h2>

        <p>
            Stochastic resonance reveals a profound truth: <span class="highlight">imperfection can be optimal</span>.
            Systems that seem poorly designed—noisy, random, unreliable—may actually be exquisitely tuned
            for their environment.
        </p>

        <p>
            The phenomenon challenges us to reconsider our relationship with randomness. In a world that
            prizes precision and control, stochastic resonance whispers that sometimes the path to clarity
            runs through chaos.
        </p>

        <div class="paradox-statement">
            "The right amount of noise doesn't obscure the truth—it illuminates it."
        </div>

        <footer>
            <p>Part of the <a href="../index.html">CCAB</a> Surprising Paradoxes collection</p>
            <p>Sources: <a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC2660436/">PLOS Biology</a> ·
            <a href="https://en.wikipedia.org/wiki/Stochastic_resonance">Wikipedia</a> ·
            <a href="https://www.scientificamerican.com/article/parrondos-paradox-explains-how-two-losing-strategies-combined-can-win/">Scientific American</a></p>
        </footer>
    </div>

    <script>
        // Main simulation
        const mainCanvas = document.getElementById('mainCanvas');
        const mainCtx = mainCanvas.getContext('2d');
        const curveCanvas = document.getElementById('curveCanvas');
        const curveCtx = curveCanvas.getContext('2d');

        // High DPI support
        function setupCanvas(canvas, ctx) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
        }

        // State
        let noiseLevel = 0;
        let signalStrength = 0.3;
        let time = 0;
        let history = [];
        let outputHistory = [];
        let detectionCount = 0;
        let totalSamples = 0;
        const threshold = 0.5;
        const historyLength = 400;

        // Resonance curve data
        const resonanceData = [];
        const resonanceNoiseSteps = 50;

        // Initialize
        function init() {
            setupCanvas(mainCanvas, mainCtx);
            setupCanvas(curveCanvas, curveCtx);

            // Pre-calculate resonance curve
            for (let i = 0; i <= resonanceNoiseSteps; i++) {
                const n = i / resonanceNoiseSteps;
                resonanceData.push(calculateSNR(n, signalStrength));
            }

            requestAnimationFrame(animate);
        }

        // Calculate theoretical SNR for resonance curve
        function calculateSNR(noise, signal) {
            if (noise < 0.01) return 0;
            // Simplified model of stochastic resonance
            const effectiveSignal = signal * 0.8;
            const combined = effectiveSignal + noise;

            // SNR peaks at optimal noise
            const optimalNoise = (threshold - effectiveSignal) * 0.8;
            const resonanceFactor = Math.exp(-Math.pow(noise - optimalNoise, 2) / (2 * 0.15 * 0.15));

            // Clamp and scale
            const crossingProb = Math.min(1, Math.max(0, (combined - threshold + noise * 0.5) / noise));
            return crossingProb * resonanceFactor * (1 - noise * 0.5) * 100;
        }

        // Generate Gaussian noise
        function gaussianNoise() {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        // Main animation loop
        function animate() {
            time += 0.05;

            const w = mainCanvas.getBoundingClientRect().width;
            const h = mainCanvas.getBoundingClientRect().height;

            // Clear
            mainCtx.fillStyle = 'rgba(5, 10, 20, 1)';
            mainCtx.fillRect(0, 0, w, h);

            // Generate signal + noise
            const signal = Math.sin(time * 2) * signalStrength;
            const noise = gaussianNoise() * noiseLevel;
            const combined = signal + noise;
            const output = combined > threshold ? 1 : 0;

            // Track detection
            totalSamples++;
            if (output === 1) detectionCount++;

            // Update history
            history.push({ signal, noise, combined });
            outputHistory.push(output);
            if (history.length > historyLength) {
                history.shift();
                outputHistory.shift();
            }

            // Draw sections
            const sectionHeight = h / 4;

            // Section 1: Pure signal
            drawSection(mainCtx, 0, sectionHeight, w, history.map(h => h.signal), '#00ff88', 'Original Signal (Weak)');

            // Section 2: Noise
            drawSection(mainCtx, sectionHeight, sectionHeight, w, history.map(h => h.noise), '#ff6b6b', 'Added Noise');

            // Section 3: Combined with threshold
            drawSectionWithThreshold(mainCtx, sectionHeight * 2, sectionHeight, w, history.map(h => h.combined), '#00d4ff', 'Combined Signal');

            // Section 4: Output
            drawOutput(mainCtx, sectionHeight * 3, sectionHeight, w, outputHistory, '#ffcc00', 'Detected Output');

            // Update resonance curve
            updateResonanceCurve();

            // Update stats
            updateStats();

            requestAnimationFrame(animate);
        }

        function drawSection(ctx, y, height, width, data, color, label) {
            const padding = 30;
            const graphY = y + padding;
            const graphH = height - padding * 2;
            const midY = graphY + graphH / 2;

            // Background
            ctx.fillStyle = 'rgba(0, 20, 40, 0.5)';
            ctx.fillRect(0, y, width, height);

            // Grid line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.beginPath();
            ctx.moveTo(0, midY);
            ctx.lineTo(width, midY);
            ctx.stroke();

            // Label
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = '11px sans-serif';
            ctx.fillText(label, 10, y + 18);

            // Data
            if (data.length < 2) return;

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let i = 0; i < data.length; i++) {
                const x = (i / data.length) * width;
                const val = Math.max(-1, Math.min(1, data[i]));
                const yPos = midY - val * (graphH / 2) * 0.8;

                if (i === 0) ctx.moveTo(x, yPos);
                else ctx.lineTo(x, yPos);
            }

            ctx.stroke();
            ctx.lineWidth = 1;
        }

        function drawSectionWithThreshold(ctx, y, height, width, data, color, label) {
            drawSection(ctx, y, height, width, data, color, label);

            const padding = 30;
            const graphY = y + padding;
            const graphH = height - padding * 2;
            const midY = graphY + graphH / 2;

            // Threshold line
            const threshY = midY - threshold * (graphH / 2) * 0.8;
            ctx.strokeStyle = '#ff6b6b';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, threshY);
            ctx.lineTo(width, threshY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Label threshold
            ctx.fillStyle = '#ff6b6b';
            ctx.font = '10px sans-serif';
            ctx.fillText('THRESHOLD', width - 75, threshY - 5);
        }

        function drawOutput(ctx, y, height, width, data, color, label) {
            const padding = 30;
            const graphY = y + padding;
            const graphH = height - padding * 2;

            // Background
            ctx.fillStyle = 'rgba(0, 20, 40, 0.5)';
            ctx.fillRect(0, y, width, height);

            // Label
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = '11px sans-serif';
            ctx.fillText(label, 10, y + 18);

            // Draw pulses
            ctx.fillStyle = color;
            for (let i = 0; i < data.length; i++) {
                if (data[i] === 1) {
                    const x = (i / data.length) * width;
                    ctx.fillRect(x, graphY + graphH * 0.2, 3, graphH * 0.6);
                }
            }
        }

        function updateResonanceCurve() {
            const w = curveCanvas.getBoundingClientRect().width;
            const h = curveCanvas.getBoundingClientRect().height;

            // Recalculate with current signal strength
            for (let i = 0; i <= resonanceNoiseSteps; i++) {
                const n = i / resonanceNoiseSteps;
                resonanceData[i] = calculateSNR(n, signalStrength);
            }

            curveCtx.fillStyle = 'rgba(0, 10, 20, 1)';
            curveCtx.fillRect(0, 0, w, h);

            const padding = 40;
            const graphW = w - padding * 2;
            const graphH = h - padding * 2;

            // Grid
            curveCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            for (let i = 0; i <= 4; i++) {
                const y = padding + (i / 4) * graphH;
                curveCtx.beginPath();
                curveCtx.moveTo(padding, y);
                curveCtx.lineTo(w - padding, y);
                curveCtx.stroke();
            }

            // Labels
            curveCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            curveCtx.font = '11px sans-serif';
            curveCtx.fillText('Output Quality (SNR)', padding, 20);
            curveCtx.fillText('Noise Level →', w / 2 - 40, h - 10);
            curveCtx.fillText('Low', padding, h - 10);
            curveCtx.fillText('High', w - padding - 20, h - 10);

            // Curve
            curveCtx.strokeStyle = '#00ff88';
            curveCtx.lineWidth = 3;
            curveCtx.beginPath();

            const maxSNR = Math.max(...resonanceData, 1);

            for (let i = 0; i <= resonanceNoiseSteps; i++) {
                const x = padding + (i / resonanceNoiseSteps) * graphW;
                const y = padding + graphH - (resonanceData[i] / maxSNR) * graphH;

                if (i === 0) curveCtx.moveTo(x, y);
                else curveCtx.lineTo(x, y);
            }

            curveCtx.stroke();
            curveCtx.lineWidth = 1;

            // Current position marker
            const currentX = padding + noiseLevel * graphW;
            const currentIdx = Math.floor(noiseLevel * resonanceNoiseSteps);
            const currentY = padding + graphH - (resonanceData[currentIdx] / maxSNR) * graphH;

            curveCtx.fillStyle = '#00d4ff';
            curveCtx.beginPath();
            curveCtx.arc(currentX, currentY, 8, 0, Math.PI * 2);
            curveCtx.fill();

            // Vertical line
            curveCtx.strokeStyle = 'rgba(0, 212, 255, 0.5)';
            curveCtx.setLineDash([3, 3]);
            curveCtx.beginPath();
            curveCtx.moveTo(currentX, padding);
            curveCtx.lineTo(currentX, h - padding);
            curveCtx.stroke();
            curveCtx.setLineDash([]);

            // Peak marker
            const peakIdx = resonanceData.indexOf(Math.max(...resonanceData));
            const peakX = padding + (peakIdx / resonanceNoiseSteps) * graphW;

            curveCtx.fillStyle = 'rgba(255, 204, 0, 0.3)';
            curveCtx.fillRect(peakX - 15, padding, 30, graphH);

            curveCtx.fillStyle = '#ffcc00';
            curveCtx.font = '10px sans-serif';
            curveCtx.fillText('OPTIMAL', peakX - 22, padding + 15);
        }

        function updateStats() {
            const currentIdx = Math.floor(noiseLevel * resonanceNoiseSteps);
            const snr = resonanceData[currentIdx];
            const detectionRate = totalSamples > 0 ? (detectionCount / totalSamples * 100) : 0;
            const peakIdx = resonanceData.indexOf(Math.max(...resonanceData));
            const optimalNoise = peakIdx / resonanceNoiseSteps;

            document.getElementById('snrValue').textContent = snr.toFixed(1);
            document.getElementById('detectRate').textContent = detectionRate.toFixed(0) + '%';
            document.getElementById('noiseLevel').textContent = noiseLevel.toFixed(2);

            const distFromOptimal = Math.abs(noiseLevel - optimalNoise);
            let zone = '—';
            if (noiseLevel < 0.05) zone = 'TOO LOW';
            else if (distFromOptimal < 0.1) zone = 'OPTIMAL!';
            else if (noiseLevel > optimalNoise + 0.15) zone = 'TOO HIGH';
            else zone = 'CLOSE';

            const optimalEl = document.getElementById('optimalZone');
            optimalEl.textContent = zone;
            optimalEl.style.color = zone === 'OPTIMAL!' ? '#00ff88' : (zone === 'CLOSE' ? '#ffcc00' : '#ff6b6b');
        }

        // Event listeners
        document.getElementById('noiseSlider').addEventListener('input', (e) => {
            noiseLevel = e.target.value / 100;
            resetStats();
        });

        document.getElementById('signalSlider').addEventListener('input', (e) => {
            signalStrength = e.target.value / 100;
            resetStats();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            history = [];
            outputHistory = [];
            resetStats();
            time = 0;
        });

        function resetStats() {
            detectionCount = 0;
            totalSamples = 0;
        }

        // Handle resize
        window.addEventListener('resize', () => {
            setupCanvas(mainCanvas, mainCtx);
            setupCanvas(curveCanvas, curveCtx);
        });

        // Start
        init();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
