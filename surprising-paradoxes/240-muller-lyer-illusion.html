<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Müller-Lyer Illusion - When Arrows Lie</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            color: #e94560;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.2em;
            color: #a0a0a0;
            font-style: italic;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #e94560;
            text-decoration: none;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 100;
            background: rgba(26, 26, 46, 0.9);
            padding: 8px 15px;
            border-radius: 20px;
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(233, 69, 96, 0.2);
            transform: translateX(-3px);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel h2 {
            color: #e94560;
            margin-bottom: 20px;
            font-size: 1.4em;
        }

        .canvas-container {
            text-align: center;
            margin-bottom: 20px;
        }

        #illusionCanvas {
            background: #0a0a15;
            border-radius: 10px;
            cursor: pointer;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            color: #a0a0a0;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #e94560;
            cursor: pointer;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .btn-primary {
            background: linear-gradient(135deg, #e94560, #0f3460);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(233, 69, 96, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .reveal-text {
            margin-top: 15px;
            padding: 15px;
            background: rgba(233, 69, 96, 0.2);
            border-radius: 10px;
            border: 1px solid #e94560;
            font-weight: bold;
            display: none;
        }

        .reveal-text.visible {
            display: block;
        }

        .game-panel {
            grid-column: 1 / -1;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        #gameCanvas {
            background: #0a0a15;
            border-radius: 10px;
        }

        .game-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            width: 100%;
            text-align: center;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.08);
            padding: 15px;
            border-radius: 10px;
        }

        .stat-value {
            font-size: 2em;
            color: #e94560;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.85em;
            color: #a0a0a0;
        }

        .game-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .game-buttons .btn {
            min-width: 120px;
        }

        .explanation {
            grid-column: 1 / -1;
            line-height: 1.8;
        }

        .explanation p {
            margin-bottom: 15px;
        }

        .highlight {
            color: #e94560;
            font-weight: bold;
        }

        .culture-panel {
            grid-column: 1 / -1;
        }

        .culture-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .culture-card {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .culture-name {
            color: #e94560;
            font-size: 1.1em;
            margin-bottom: 10px;
        }

        .culture-effect {
            font-size: 2em;
            color: #4ecdc4;
            margin-bottom: 5px;
        }

        .culture-desc {
            font-size: 0.85em;
            color: #a0a0a0;
        }

        .variants-panel {
            grid-column: 1 / -1;
        }

        #variantsCanvas {
            background: #0a0a15;
            border-radius: 10px;
        }

        .history-box {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 4px solid #e94560;
        }

        .history-box h3 {
            color: #e94560;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">
        <span>←</span> Back to Paradoxes
    </a>

    <div class="container">
        <header>
            <h1>The Müller-Lyer Illusion</h1>
            <p class="subtitle">When arrows trick your brain about length</p>
        </header>

        <div class="main-content">
            <!-- Classic Demonstration -->
            <div class="panel">
                <h2>The Classic Illusion</h2>
                <div class="canvas-container">
                    <canvas id="illusionCanvas" width="450" height="300"></canvas>
                </div>
                <p style="text-align: center; color: #a0a0a0; margin-bottom: 15px;">
                    Which horizontal line appears longer?
                </p>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn btn-secondary" onclick="guessTop()">Top Line</button>
                    <button class="btn btn-secondary" onclick="guessBottom()">Bottom Line</button>
                    <button class="btn btn-primary" onclick="revealTruth()">Reveal Truth</button>
                </div>
                <div id="revealText" class="reveal-text"></div>
            </div>

            <!-- Interactive Adjuster -->
            <div class="panel">
                <h2>Adjust to Match</h2>
                <div class="canvas-container">
                    <canvas id="adjustCanvas" width="450" height="300"></canvas>
                </div>
                <p style="text-align: center; color: #a0a0a0; margin-bottom: 15px;">
                    Drag the slider until both lines LOOK equal
                </p>
                <div class="controls">
                    <div class="control-group">
                        <label>Adjust bottom line length: <span id="adjustValue">100%</span></label>
                        <input type="range" id="adjustSlider" min="60" max="140" value="100" oninput="updateAdjust()">
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn btn-primary" onclick="checkAdjustment()">Check My Perception</button>
                        <button class="btn btn-secondary" onclick="resetAdjust()">Reset</button>
                    </div>
                </div>
                <div id="adjustResult" class="reveal-text"></div>
            </div>

            <!-- Angle Experiment -->
            <div class="panel">
                <h2>Arrow Angle Effect</h2>
                <div class="canvas-container">
                    <canvas id="angleCanvas" width="450" height="300"></canvas>
                </div>
                <div class="controls">
                    <div class="control-group">
                        <label>Arrow Angle: <span id="angleValue">30°</span></label>
                        <input type="range" id="angleSlider" min="10" max="80" value="30" oninput="updateAngle()">
                    </div>
                    <div class="control-group">
                        <label>Arrow Length: <span id="arrowLengthValue">40px</span></label>
                        <input type="range" id="arrowLengthSlider" min="15" max="80" value="40" oninput="updateAngle()">
                    </div>
                </div>
                <p style="margin-top: 15px; color: #a0a0a0; font-size: 0.9em;">
                    Experiment with different angles and arrow lengths to see how the illusion strength changes!
                </p>
            </div>

            <!-- Line Thickness -->
            <div class="panel">
                <h2>Line Properties</h2>
                <div class="canvas-container">
                    <canvas id="thicknessCanvas" width="450" height="300"></canvas>
                </div>
                <div class="controls">
                    <div class="control-group">
                        <label>Line Thickness: <span id="thicknessValue">3px</span></label>
                        <input type="range" id="thicknessSlider" min="1" max="10" value="3" oninput="updateThickness()">
                    </div>
                    <div class="control-group">
                        <label>Color Scheme:</label>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button class="btn btn-secondary" onclick="setColors('#ffffff', '#0a0a15')">White on Black</button>
                            <button class="btn btn-secondary" onclick="setColors('#e94560', '#0a0a15')">Red on Black</button>
                            <button class="btn btn-secondary" onclick="setColors('#000000', '#ffffff')">Black on White</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Perception Game -->
            <div class="panel game-panel">
                <h2>Test Your Perception</h2>
                <div class="game-container">
                    <canvas id="gameCanvas" width="800" height="250"></canvas>
                    <div class="game-stats">
                        <div class="stat-box">
                            <div class="stat-value" id="trialNum">0</div>
                            <div class="stat-label">Trial</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="correctCount">0</div>
                            <div class="stat-label">Correct</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="accuracy">0%</div>
                            <div class="stat-label">Accuracy</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="avgError">0%</div>
                            <div class="stat-label">Avg Error</div>
                        </div>
                    </div>
                    <p id="gameInstruction" style="color: #a0a0a0;">Click "Start Game" to begin. You'll compare line lengths and try to overcome the illusion!</p>
                    <div class="game-buttons">
                        <button class="btn btn-primary" id="startBtn" onclick="startGame()">Start Game</button>
                        <button class="btn btn-secondary" id="leftBtn" onclick="gameAnswer('left')" style="display:none;">Left is Longer</button>
                        <button class="btn btn-secondary" id="sameBtn" onclick="gameAnswer('same')" style="display:none;">They're Equal</button>
                        <button class="btn btn-secondary" id="rightBtn" onclick="gameAnswer('right')" style="display:none;">Right is Longer</button>
                    </div>
                </div>
            </div>

            <!-- Cross-Cultural Research -->
            <div class="panel culture-panel">
                <h2>Cross-Cultural Research</h2>
                <p>The Müller-Lyer illusion's strength varies dramatically across cultures! Segall, Campbell & Herskovits (1966) found:</p>
                <div class="culture-grid">
                    <div class="culture-card">
                        <div class="culture-name">Western Urban</div>
                        <div class="culture-effect">~20%</div>
                        <div class="culture-desc">Strong susceptibility. Raised in "carpentered" environments with corners and right angles.</div>
                    </div>
                    <div class="culture-card">
                        <div class="culture-name">San People (Kalahari)</div>
                        <div class="culture-effect">~5%</div>
                        <div class="culture-desc">Much weaker effect. Circular huts, open desert, few right angles.</div>
                    </div>
                    <div class="culture-card">
                        <div class="culture-name">Torres Strait Islanders</div>
                        <div class="culture-effect">~3%</div>
                        <div class="culture-desc">Minimal effect. Environment with rounded structures and horizon lines.</div>
                    </div>
                    <div class="culture-card">
                        <div class="culture-name">Children (Age 4-6)</div>
                        <div class="culture-effect">~25%</div>
                        <div class="culture-desc">Stronger effect. Still learning depth cues from their environment.</div>
                    </div>
                </div>
                <p style="margin-top: 20px; color: #a0a0a0;">
                    <span class="highlight">The "Carpentered World" Hypothesis:</span> People in industrialized societies, surrounded by buildings with corners and edges, unconsciously interpret the arrows as depth cues—inward arrows suggest a receding corner, outward arrows an approaching edge.
                </p>
            </div>

            <!-- Variants -->
            <div class="panel variants-panel">
                <h2>Illusion Variants</h2>
                <div class="canvas-container">
                    <canvas id="variantsCanvas" width="800" height="400"></canvas>
                </div>
                <p style="color: #a0a0a0; text-align: center;">
                    All horizontal shafts are exactly the same length! Different fin configurations create different perceived lengths.
                </p>
            </div>

            <!-- Explanation -->
            <div class="panel explanation">
                <h2>The Psychology Behind the Illusion</h2>
                <p>
                    The <span class="highlight">Müller-Lyer Illusion</span>, first published by German psychiatrist
                    <span class="highlight">Franz Carl Müller-Lyer in 1889</span>, is one of the most famous and
                    well-studied optical illusions in psychology. Despite knowing both lines are identical,
                    your brain CANNOT stop perceiving them as different.
                </p>
                <p>
                    <strong>The "Depth Cue" Theory:</strong> Richard Gregory proposed that we interpret the arrows
                    as 3D corners. Outward-pointing arrows (><) look like an outside corner of a building coming
                    toward you—making the line appear closer and therefore SHORTER. Inward-pointing arrows (<>)
                    look like an inside corner receding away—making the line appear farther and therefore LONGER.
                </p>
                <p>
                    <strong>The "Centroid" Theory:</strong> Our visual system judges length by comparing the
                    centroids (centers of mass) of the overall figures. The outward arrows extend the centroid
                    beyond the line ends, while inward arrows compress it.
                </p>
                <p>
                    <strong>Why It Matters:</strong> This illusion demonstrates that perception is not passive
                    reception but active CONSTRUCTION. Your brain applies learned assumptions about the 3D world
                    to every 2D image—even simple line drawings. These "shortcuts" usually help but can be fooled.
                </p>

                <div class="history-box">
                    <h3>Historical Note</h3>
                    <p>
                        Müller-Lyer was actually a sociologist, not a vision scientist! He was interested in
                        how "judgment" could be influenced by context. His 1889 paper "Optische Urteilstäuschungen"
                        (Optical Judgment Illusions) included 15 different figures, but the arrow version became
                        the icon. It appears in nearly every introductory psychology textbook and has generated
                        over 1,000 research papers.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global configuration
        let lineColor = '#ffffff';
        let bgColor = '#0a0a15';

        // ========== CLASSIC ILLUSION ==========
        const classicCanvas = document.getElementById('illusionCanvas');
        const classicCtx = classicCanvas.getContext('2d');
        const lineLength = 200;
        const arrowLength = 40;
        const arrowAngle = 30 * Math.PI / 180;

        function drawClassicIllusion() {
            classicCtx.fillStyle = bgColor;
            classicCtx.fillRect(0, 0, classicCanvas.width, classicCanvas.height);

            const centerX = classicCanvas.width / 2;
            const y1 = 100;
            const y2 = 200;
            const startX = centerX - lineLength / 2;
            const endX = centerX + lineLength / 2;

            classicCtx.strokeStyle = lineColor;
            classicCtx.lineWidth = 3;
            classicCtx.lineCap = 'round';

            // Top line with inward arrows (appears longer)
            classicCtx.beginPath();
            classicCtx.moveTo(startX, y1);
            classicCtx.lineTo(endX, y1);
            classicCtx.stroke();

            // Left inward arrows
            classicCtx.beginPath();
            classicCtx.moveTo(startX + arrowLength * Math.cos(arrowAngle), y1 - arrowLength * Math.sin(arrowAngle));
            classicCtx.lineTo(startX, y1);
            classicCtx.lineTo(startX + arrowLength * Math.cos(arrowAngle), y1 + arrowLength * Math.sin(arrowAngle));
            classicCtx.stroke();

            // Right inward arrows
            classicCtx.beginPath();
            classicCtx.moveTo(endX - arrowLength * Math.cos(arrowAngle), y1 - arrowLength * Math.sin(arrowAngle));
            classicCtx.lineTo(endX, y1);
            classicCtx.lineTo(endX - arrowLength * Math.cos(arrowAngle), y1 + arrowLength * Math.sin(arrowAngle));
            classicCtx.stroke();

            // Bottom line with outward arrows (appears shorter)
            classicCtx.beginPath();
            classicCtx.moveTo(startX, y2);
            classicCtx.lineTo(endX, y2);
            classicCtx.stroke();

            // Left outward arrows
            classicCtx.beginPath();
            classicCtx.moveTo(startX - arrowLength * Math.cos(arrowAngle), y2 - arrowLength * Math.sin(arrowAngle));
            classicCtx.lineTo(startX, y2);
            classicCtx.lineTo(startX - arrowLength * Math.cos(arrowAngle), y2 + arrowLength * Math.sin(arrowAngle));
            classicCtx.stroke();

            // Right outward arrows
            classicCtx.beginPath();
            classicCtx.moveTo(endX + arrowLength * Math.cos(arrowAngle), y2 - arrowLength * Math.sin(arrowAngle));
            classicCtx.lineTo(endX, y2);
            classicCtx.lineTo(endX + arrowLength * Math.cos(arrowAngle), y2 + arrowLength * Math.sin(arrowAngle));
            classicCtx.stroke();

            // Labels
            classicCtx.fillStyle = '#a0a0a0';
            classicCtx.font = '14px Georgia';
            classicCtx.fillText('A', centerX - 5, y1 - 50);
            classicCtx.fillText('B', centerX - 5, y2 + 60);
        }

        function guessTop() {
            document.getElementById('revealText').innerHTML =
                'You said TOP (Line A) is longer. Most people agree—but let\'s see the truth!';
            document.getElementById('revealText').classList.add('visible');
        }

        function guessBottom() {
            document.getElementById('revealText').innerHTML =
                'Interesting! You said BOTTOM (Line B) is longer. Let\'s check!';
            document.getElementById('revealText').classList.add('visible');
        }

        function revealTruth() {
            classicCtx.fillStyle = bgColor;
            classicCtx.fillRect(0, 0, classicCanvas.width, classicCanvas.height);

            const centerX = classicCanvas.width / 2;
            const startX = centerX - lineLength / 2;
            const endX = centerX + lineLength / 2;

            // Draw just the lines with measurement marks
            classicCtx.strokeStyle = '#4ecdc4';
            classicCtx.lineWidth = 3;

            // Top line
            classicCtx.beginPath();
            classicCtx.moveTo(startX, 100);
            classicCtx.lineTo(endX, 100);
            classicCtx.stroke();

            // Bottom line
            classicCtx.beginPath();
            classicCtx.moveTo(startX, 200);
            classicCtx.lineTo(endX, 200);
            classicCtx.stroke();

            // Measurement lines
            classicCtx.strokeStyle = '#e94560';
            classicCtx.setLineDash([5, 5]);
            classicCtx.beginPath();
            classicCtx.moveTo(startX, 80);
            classicCtx.lineTo(startX, 220);
            classicCtx.moveTo(endX, 80);
            classicCtx.lineTo(endX, 220);
            classicCtx.stroke();
            classicCtx.setLineDash([]);

            // Labels
            classicCtx.fillStyle = '#e94560';
            classicCtx.font = 'bold 16px Georgia';
            classicCtx.textAlign = 'center';
            classicCtx.fillText('BOTH LINES ARE EXACTLY 200px!', centerX, 150);
            classicCtx.fillText(`${lineLength}px`, centerX, 250);

            document.getElementById('revealText').innerHTML =
                '<strong>THEY\'RE IDENTICAL!</strong> Both lines are exactly ' + lineLength +
                ' pixels long. The inward arrows (<>) make Line A appear 15-25% LONGER, ' +
                'while outward arrows (><) make Line B appear SHORTER. Your brain cannot unsee it!';
            document.getElementById('revealText').classList.add('visible');

            setTimeout(drawClassicIllusion, 4000);
        }

        // ========== ADJUST TO MATCH ==========
        const adjustCanvas = document.getElementById('adjustCanvas');
        const adjustCtx = adjustCanvas.getContext('2d');
        let adjustRatio = 100;

        function drawAdjustIllusion() {
            adjustCtx.fillStyle = '#0a0a15';
            adjustCtx.fillRect(0, 0, adjustCanvas.width, adjustCanvas.height);

            const centerX = adjustCanvas.width / 2;
            const y1 = 100;
            const y2 = 200;
            const baseLength = 180;
            const adjustedLength = baseLength * (adjustRatio / 100);

            adjustCtx.strokeStyle = '#ffffff';
            adjustCtx.lineWidth = 3;
            adjustCtx.lineCap = 'round';

            // Top line with inward arrows (fixed)
            const topStartX = centerX - baseLength / 2;
            const topEndX = centerX + baseLength / 2;

            adjustCtx.beginPath();
            adjustCtx.moveTo(topStartX, y1);
            adjustCtx.lineTo(topEndX, y1);
            classicCtx.stroke();

            // Inward arrows
            const angle = 30 * Math.PI / 180;
            const al = 35;

            adjustCtx.beginPath();
            adjustCtx.moveTo(topStartX + al * Math.cos(angle), y1 - al * Math.sin(angle));
            adjustCtx.lineTo(topStartX, y1);
            adjustCtx.lineTo(topStartX + al * Math.cos(angle), y1 + al * Math.sin(angle));
            adjustCtx.stroke();

            adjustCtx.beginPath();
            adjustCtx.moveTo(topEndX - al * Math.cos(angle), y1 - al * Math.sin(angle));
            adjustCtx.lineTo(topEndX, y1);
            adjustCtx.lineTo(topEndX - al * Math.cos(angle), y1 + al * Math.sin(angle));
            adjustCtx.stroke();

            // Bottom line with outward arrows (adjustable)
            const botStartX = centerX - adjustedLength / 2;
            const botEndX = centerX + adjustedLength / 2;

            adjustCtx.beginPath();
            adjustCtx.moveTo(botStartX, y2);
            adjustCtx.lineTo(botEndX, y2);
            adjustCtx.stroke();

            // Outward arrows
            adjustCtx.beginPath();
            adjustCtx.moveTo(botStartX - al * Math.cos(angle), y2 - al * Math.sin(angle));
            adjustCtx.lineTo(botStartX, y2);
            adjustCtx.lineTo(botStartX - al * Math.cos(angle), y2 + al * Math.sin(angle));
            adjustCtx.stroke();

            adjustCtx.beginPath();
            adjustCtx.moveTo(botEndX + al * Math.cos(angle), y2 - al * Math.sin(angle));
            adjustCtx.lineTo(botEndX, y2);
            adjustCtx.lineTo(botEndX + al * Math.cos(angle), y2 + al * Math.sin(angle));
            adjustCtx.stroke();
        }

        function updateAdjust() {
            adjustRatio = parseInt(document.getElementById('adjustSlider').value);
            document.getElementById('adjustValue').textContent = adjustRatio + '%';
            drawAdjustIllusion();
        }

        function checkAdjustment() {
            const error = Math.abs(adjustRatio - 100);
            let message = '';

            if (error === 0) {
                message = '<strong>PERFECT!</strong> You set them exactly equal. Either you measured, or you have exceptional perception!';
            } else if (adjustRatio > 100) {
                message = `<strong>Illusion confirmed!</strong> You made the bottom line ${adjustRatio - 100}% LONGER to make it "look equal." ` +
                    `The outward arrows made you underestimate its length by ${adjustRatio - 100}%!`;
            } else {
                message = `<strong>Unusual!</strong> You made the bottom line ${100 - adjustRatio}% SHORTER. ` +
                    `Most people make it longer. You may have over-compensated for the expected illusion!`;
            }

            document.getElementById('adjustResult').innerHTML = message;
            document.getElementById('adjustResult').classList.add('visible');
        }

        function resetAdjust() {
            document.getElementById('adjustSlider').value = 100;
            adjustRatio = 100;
            document.getElementById('adjustValue').textContent = '100%';
            document.getElementById('adjustResult').classList.remove('visible');
            drawAdjustIllusion();
        }

        // ========== ANGLE EXPERIMENT ==========
        const angleCanvas = document.getElementById('angleCanvas');
        const angleCtx = angleCanvas.getContext('2d');

        function drawAngleExperiment() {
            angleCtx.fillStyle = '#0a0a15';
            angleCtx.fillRect(0, 0, angleCanvas.width, angleCanvas.height);

            const centerX = angleCanvas.width / 2;
            const angle = parseInt(document.getElementById('angleSlider').value) * Math.PI / 180;
            const arrowLen = parseInt(document.getElementById('arrowLengthSlider').value);
            const lineLen = 180;
            const y1 = 100;
            const y2 = 200;

            angleCtx.strokeStyle = '#ffffff';
            angleCtx.lineWidth = 3;
            angleCtx.lineCap = 'round';

            const startX = centerX - lineLen / 2;
            const endX = centerX + lineLen / 2;

            // Top line with inward arrows
            angleCtx.beginPath();
            angleCtx.moveTo(startX, y1);
            angleCtx.lineTo(endX, y1);
            angleCtx.stroke();

            angleCtx.beginPath();
            angleCtx.moveTo(startX + arrowLen * Math.cos(angle), y1 - arrowLen * Math.sin(angle));
            angleCtx.lineTo(startX, y1);
            angleCtx.lineTo(startX + arrowLen * Math.cos(angle), y1 + arrowLen * Math.sin(angle));
            angleCtx.stroke();

            angleCtx.beginPath();
            angleCtx.moveTo(endX - arrowLen * Math.cos(angle), y1 - arrowLen * Math.sin(angle));
            angleCtx.lineTo(endX, y1);
            angleCtx.lineTo(endX - arrowLen * Math.cos(angle), y1 + arrowLen * Math.sin(angle));
            angleCtx.stroke();

            // Bottom line with outward arrows
            angleCtx.beginPath();
            angleCtx.moveTo(startX, y2);
            angleCtx.lineTo(endX, y2);
            angleCtx.stroke();

            angleCtx.beginPath();
            angleCtx.moveTo(startX - arrowLen * Math.cos(angle), y2 - arrowLen * Math.sin(angle));
            angleCtx.lineTo(startX, y2);
            angleCtx.lineTo(startX - arrowLen * Math.cos(angle), y2 + arrowLen * Math.sin(angle));
            angleCtx.stroke();

            angleCtx.beginPath();
            angleCtx.moveTo(endX + arrowLen * Math.cos(angle), y2 - arrowLen * Math.sin(angle));
            angleCtx.lineTo(endX, y2);
            angleCtx.lineTo(endX + arrowLen * Math.cos(angle), y2 + arrowLen * Math.sin(angle));
            angleCtx.stroke();
        }

        function updateAngle() {
            document.getElementById('angleValue').textContent = document.getElementById('angleSlider').value + '°';
            document.getElementById('arrowLengthValue').textContent = document.getElementById('arrowLengthSlider').value + 'px';
            drawAngleExperiment();
        }

        // ========== THICKNESS EXPERIMENT ==========
        const thicknessCanvas = document.getElementById('thicknessCanvas');
        const thicknessCtx = thicknessCanvas.getContext('2d');

        function drawThicknessExperiment() {
            thicknessCtx.fillStyle = bgColor;
            thicknessCtx.fillRect(0, 0, thicknessCanvas.width, thicknessCanvas.height);

            const centerX = thicknessCanvas.width / 2;
            const thickness = parseInt(document.getElementById('thicknessSlider').value);
            const lineLen = 180;
            const arrowLen = 35;
            const angle = 30 * Math.PI / 180;
            const y1 = 100;
            const y2 = 200;

            thicknessCtx.strokeStyle = lineColor;
            thicknessCtx.lineWidth = thickness;
            thicknessCtx.lineCap = 'round';

            const startX = centerX - lineLen / 2;
            const endX = centerX + lineLen / 2;

            // Top line with inward arrows
            thicknessCtx.beginPath();
            thicknessCtx.moveTo(startX, y1);
            thicknessCtx.lineTo(endX, y1);
            thicknessCtx.stroke();

            thicknessCtx.beginPath();
            thicknessCtx.moveTo(startX + arrowLen * Math.cos(angle), y1 - arrowLen * Math.sin(angle));
            thicknessCtx.lineTo(startX, y1);
            thicknessCtx.lineTo(startX + arrowLen * Math.cos(angle), y1 + arrowLen * Math.sin(angle));
            thicknessCtx.stroke();

            thicknessCtx.beginPath();
            thicknessCtx.moveTo(endX - arrowLen * Math.cos(angle), y1 - arrowLen * Math.sin(angle));
            thicknessCtx.lineTo(endX, y1);
            thicknessCtx.lineTo(endX - arrowLen * Math.cos(angle), y1 + arrowLen * Math.sin(angle));
            thicknessCtx.stroke();

            // Bottom line with outward arrows
            thicknessCtx.beginPath();
            thicknessCtx.moveTo(startX, y2);
            thicknessCtx.lineTo(endX, y2);
            thicknessCtx.stroke();

            thicknessCtx.beginPath();
            thicknessCtx.moveTo(startX - arrowLen * Math.cos(angle), y2 - arrowLen * Math.sin(angle));
            thicknessCtx.lineTo(startX, y2);
            thicknessCtx.lineTo(startX - arrowLen * Math.cos(angle), y2 + arrowLen * Math.sin(angle));
            thicknessCtx.stroke();

            thicknessCtx.beginPath();
            thicknessCtx.moveTo(endX + arrowLen * Math.cos(angle), y2 - arrowLen * Math.sin(angle));
            thicknessCtx.lineTo(endX, y2);
            thicknessCtx.lineTo(endX + arrowLen * Math.cos(angle), y2 + arrowLen * Math.sin(angle));
            thicknessCtx.stroke();
        }

        function updateThickness() {
            document.getElementById('thicknessValue').textContent = document.getElementById('thicknessSlider').value + 'px';
            drawThicknessExperiment();
        }

        function setColors(fg, bg) {
            lineColor = fg;
            bgColor = bg;
            drawThicknessExperiment();
        }

        // ========== PERCEPTION GAME ==========
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCtx = gameCanvas.getContext('2d');
        let gameState = {
            active: false,
            trial: 0,
            correct: 0,
            errors: [],
            currentLeft: 0,
            currentRight: 0,
            correctAnswer: ''
        };

        function drawGameTrial() {
            gameCtx.fillStyle = '#0a0a15';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

            const y = 125;
            const leftX = 150;
            const rightX = 550;
            const arrowLen = 35;
            const angle = 30 * Math.PI / 180;

            // Generate random lengths with small differences
            const baseLength = 150;
            const variation = Math.random() * 40 - 20; // -20 to +20
            const leftArrowsOut = Math.random() < 0.5;
            const rightArrowsOut = Math.random() < 0.5;

            gameState.currentLeft = baseLength + (leftArrowsOut ? 0 : variation);
            gameState.currentRight = baseLength + (rightArrowsOut ? 0 : -variation);

            // Determine correct answer
            if (Math.abs(gameState.currentLeft - gameState.currentRight) < 3) {
                gameState.correctAnswer = 'same';
            } else if (gameState.currentLeft > gameState.currentRight) {
                gameState.correctAnswer = 'left';
            } else {
                gameState.correctAnswer = 'right';
            }

            gameCtx.strokeStyle = '#ffffff';
            gameCtx.lineWidth = 3;
            gameCtx.lineCap = 'round';

            // Left figure
            const leftStart = leftX - gameState.currentLeft / 2;
            const leftEnd = leftX + gameState.currentLeft / 2;

            gameCtx.beginPath();
            gameCtx.moveTo(leftStart, y);
            gameCtx.lineTo(leftEnd, y);
            gameCtx.stroke();

            if (leftArrowsOut) {
                // Outward arrows
                gameCtx.beginPath();
                gameCtx.moveTo(leftStart - arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                gameCtx.lineTo(leftStart, y);
                gameCtx.lineTo(leftStart - arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                gameCtx.stroke();

                gameCtx.beginPath();
                gameCtx.moveTo(leftEnd + arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                gameCtx.lineTo(leftEnd, y);
                gameCtx.lineTo(leftEnd + arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                gameCtx.stroke();
            } else {
                // Inward arrows
                gameCtx.beginPath();
                gameCtx.moveTo(leftStart + arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                gameCtx.lineTo(leftStart, y);
                gameCtx.lineTo(leftStart + arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                gameCtx.stroke();

                gameCtx.beginPath();
                gameCtx.moveTo(leftEnd - arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                gameCtx.lineTo(leftEnd, y);
                gameCtx.lineTo(leftEnd - arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                gameCtx.stroke();
            }

            // Right figure
            const rightStart = rightX - gameState.currentRight / 2;
            const rightEnd = rightX + gameState.currentRight / 2;

            gameCtx.beginPath();
            gameCtx.moveTo(rightStart, y);
            gameCtx.lineTo(rightEnd, y);
            gameCtx.stroke();

            if (rightArrowsOut) {
                gameCtx.beginPath();
                gameCtx.moveTo(rightStart - arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                gameCtx.lineTo(rightStart, y);
                gameCtx.lineTo(rightStart - arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                gameCtx.stroke();

                gameCtx.beginPath();
                gameCtx.moveTo(rightEnd + arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                gameCtx.lineTo(rightEnd, y);
                gameCtx.lineTo(rightEnd + arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                gameCtx.stroke();
            } else {
                gameCtx.beginPath();
                gameCtx.moveTo(rightStart + arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                gameCtx.lineTo(rightStart, y);
                gameCtx.lineTo(rightStart + arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                gameCtx.stroke();

                gameCtx.beginPath();
                gameCtx.moveTo(rightEnd - arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                gameCtx.lineTo(rightEnd, y);
                gameCtx.lineTo(rightEnd - arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                gameCtx.stroke();
            }

            // Labels
            gameCtx.fillStyle = '#a0a0a0';
            gameCtx.font = '16px Georgia';
            gameCtx.textAlign = 'center';
            gameCtx.fillText('LEFT', leftX, y + 60);
            gameCtx.fillText('RIGHT', rightX, y + 60);
        }

        function startGame() {
            gameState = {
                active: true,
                trial: 0,
                correct: 0,
                errors: [],
                currentLeft: 0,
                currentRight: 0,
                correctAnswer: ''
            };

            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('leftBtn').style.display = 'inline-block';
            document.getElementById('sameBtn').style.display = 'inline-block';
            document.getElementById('rightBtn').style.display = 'inline-block';
            document.getElementById('gameInstruction').textContent = 'Which line is LONGER? (or are they equal?)';

            nextTrial();
        }

        function nextTrial() {
            gameState.trial++;
            updateGameStats();
            drawGameTrial();
        }

        function gameAnswer(answer) {
            const isCorrect = answer === gameState.correctAnswer;

            if (isCorrect) {
                gameState.correct++;
            } else {
                const error = Math.abs(gameState.currentLeft - gameState.currentRight) / 150 * 100;
                gameState.errors.push(error);
            }

            // Show feedback briefly
            gameCtx.fillStyle = isCorrect ? 'rgba(78, 205, 196, 0.3)' : 'rgba(233, 69, 96, 0.3)';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

            gameCtx.fillStyle = isCorrect ? '#4ecdc4' : '#e94560';
            gameCtx.font = 'bold 24px Georgia';
            gameCtx.textAlign = 'center';
            gameCtx.fillText(isCorrect ? 'CORRECT!' : `WRONG! Answer: ${gameState.correctAnswer.toUpperCase()}`, 400, 40);

            if (gameState.trial < 10) {
                setTimeout(nextTrial, 1000);
            } else {
                endGame();
            }

            updateGameStats();
        }

        function updateGameStats() {
            document.getElementById('trialNum').textContent = gameState.trial;
            document.getElementById('correctCount').textContent = gameState.correct;
            document.getElementById('accuracy').textContent = gameState.trial > 0
                ? Math.round(gameState.correct / gameState.trial * 100) + '%'
                : '0%';
            document.getElementById('avgError').textContent = gameState.errors.length > 0
                ? Math.round(gameState.errors.reduce((a, b) => a + b, 0) / gameState.errors.length) + '%'
                : '0%';
        }

        function endGame() {
            gameState.active = false;

            document.getElementById('leftBtn').style.display = 'none';
            document.getElementById('sameBtn').style.display = 'none';
            document.getElementById('rightBtn').style.display = 'none';
            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('startBtn').textContent = 'Play Again';

            const accuracy = Math.round(gameState.correct / 10 * 100);
            let message = '';

            if (accuracy >= 80) {
                message = `Amazing! ${accuracy}% accuracy. You've trained your brain to resist the illusion!`;
            } else if (accuracy >= 50) {
                message = `${accuracy}% accuracy. The illusion tricked you on some trials. Keep practicing!`;
            } else {
                message = `${accuracy}% accuracy. The Müller-Lyer illusion is powerful! Your brain couldn't help seeing what isn't there.`;
            }

            document.getElementById('gameInstruction').textContent = message;
        }

        // ========== VARIANTS ==========
        const variantsCanvas = document.getElementById('variantsCanvas');
        const variantsCtx = variantsCanvas.getContext('2d');

        function drawVariants() {
            variantsCtx.fillStyle = '#0a0a15';
            variantsCtx.fillRect(0, 0, variantsCanvas.width, variantsCanvas.height);

            const lineLength = 120;
            const arrowLen = 30;
            const angle = 30 * Math.PI / 180;
            const spacing = 80;

            variantsCtx.strokeStyle = '#ffffff';
            variantsCtx.lineWidth = 2.5;
            variantsCtx.lineCap = 'round';

            const variants = [
                { name: 'Classic Inward', drawArrows: (x, y, len) => drawInwardArrows(x, y, len, arrowLen, angle) },
                { name: 'Classic Outward', drawArrows: (x, y, len) => drawOutwardArrows(x, y, len, arrowLen, angle) },
                { name: 'Circles', drawArrows: (x, y, len) => drawCircleEnds(x, y, len) },
                { name: 'Squares', drawArrows: (x, y, len) => drawSquareEnds(x, y, len) },
                { name: 'No Fins', drawArrows: () => {} }
            ];

            variants.forEach((variant, i) => {
                const y = 60 + i * spacing;
                const startX = 340 - lineLength / 2;
                const endX = 340 + lineLength / 2;

                // Draw the line
                variantsCtx.beginPath();
                variantsCtx.moveTo(startX, y);
                variantsCtx.lineTo(endX, y);
                variantsCtx.stroke();

                // Draw the decorations
                variant.drawArrows(startX, endX, y);

                // Label
                variantsCtx.fillStyle = '#a0a0a0';
                variantsCtx.font = '14px Georgia';
                variantsCtx.textAlign = 'left';
                variantsCtx.fillText(variant.name, 550, y + 5);

                // Length indicator
                variantsCtx.fillStyle = '#e94560';
                variantsCtx.textAlign = 'right';
                variantsCtx.fillText(`${lineLength}px`, 280, y + 5);
            });
        }

        function drawInwardArrows(startX, endX, y, arrowLen, angle) {
            variantsCtx.beginPath();
            variantsCtx.moveTo(startX + arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
            variantsCtx.lineTo(startX, y);
            variantsCtx.lineTo(startX + arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
            variantsCtx.stroke();

            variantsCtx.beginPath();
            variantsCtx.moveTo(endX - arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
            variantsCtx.lineTo(endX, y);
            variantsCtx.lineTo(endX - arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
            variantsCtx.stroke();
        }

        function drawOutwardArrows(startX, endX, y, arrowLen, angle) {
            variantsCtx.beginPath();
            variantsCtx.moveTo(startX - arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
            variantsCtx.lineTo(startX, y);
            variantsCtx.lineTo(startX - arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
            variantsCtx.stroke();

            variantsCtx.beginPath();
            variantsCtx.moveTo(endX + arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
            variantsCtx.lineTo(endX, y);
            variantsCtx.lineTo(endX + arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
            variantsCtx.stroke();
        }

        function drawCircleEnds(startX, endX, y) {
            variantsCtx.beginPath();
            variantsCtx.arc(startX, y, 12, 0, Math.PI * 2);
            variantsCtx.stroke();

            variantsCtx.beginPath();
            variantsCtx.arc(endX, y, 12, 0, Math.PI * 2);
            variantsCtx.stroke();
        }

        function drawSquareEnds(startX, endX, y) {
            const size = 20;
            variantsCtx.strokeRect(startX - size/2, y - size/2, size, size);
            variantsCtx.strokeRect(endX - size/2, y - size/2, size, size);
        }

        // Initialize all canvases
        drawClassicIllusion();
        drawAdjustIllusion();
        drawAngleExperiment();
        drawThicknessExperiment();
        drawVariants();

        // Initial game canvas
        gameCtx.fillStyle = '#0a0a15';
        gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
        gameCtx.fillStyle = '#a0a0a0';
        gameCtx.font = '20px Georgia';
        gameCtx.textAlign = 'center';
        gameCtx.fillText('Click "Start Game" to test your perception!', 400, 125);
    </script>
</body>
</html>
