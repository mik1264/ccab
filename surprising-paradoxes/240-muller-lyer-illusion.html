<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Muller-Lyer Illusion - When Arrows Lie</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            color: #e94560;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.2em;
            color: #a0a0a0;
            font-style: italic;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #e94560;
            text-decoration: none;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 100;
            background: rgba(26, 26, 46, 0.9);
            padding: 8px 15px;
            border-radius: 20px;
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(233, 69, 96, 0.2);
            transform: translateX(-3px);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel h2 {
            color: #e94560;
            margin-bottom: 20px;
            font-size: 1.4em;
        }

        .canvas-container {
            text-align: center;
            margin-bottom: 20px;
        }

        #illusionCanvas {
            background: #0a0a15;
            border-radius: 10px;
            cursor: pointer;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            color: #a0a0a0;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #e94560;
            cursor: pointer;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .btn-primary {
            background: linear-gradient(135deg, #e94560, #0f3460);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(233, 69, 96, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .btn-toggle {
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
            border: 1px solid #4ecdc4;
        }

        .btn-toggle.active {
            background: #4ecdc4;
            color: #0a0a15;
        }

        .reveal-text {
            margin-top: 15px;
            padding: 15px;
            background: rgba(233, 69, 96, 0.2);
            border-radius: 10px;
            border: 1px solid #e94560;
            font-weight: bold;
            display: none;
        }

        .reveal-text.visible {
            display: block;
        }

        .game-panel {
            grid-column: 1 / -1;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        #gameCanvas {
            background: #0a0a15;
            border-radius: 10px;
        }

        .game-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            width: 100%;
            text-align: center;
        }

        @media (max-width: 600px) {
            .game-stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.08);
            padding: 15px;
            border-radius: 10px;
        }

        .stat-value {
            font-size: 2em;
            color: #e94560;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.85em;
            color: #a0a0a0;
        }

        .game-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .game-buttons .btn {
            min-width: 120px;
        }

        .explanation {
            grid-column: 1 / -1;
            line-height: 1.8;
        }

        .explanation p {
            margin-bottom: 15px;
        }

        .highlight {
            color: #e94560;
            font-weight: bold;
        }

        .culture-panel {
            grid-column: 1 / -1;
        }

        .culture-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .culture-card {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .culture-name {
            color: #e94560;
            font-size: 1.1em;
            margin-bottom: 10px;
        }

        .culture-effect {
            font-size: 2em;
            color: #4ecdc4;
            margin-bottom: 5px;
        }

        .culture-desc {
            font-size: 0.85em;
            color: #a0a0a0;
        }

        .variants-panel {
            grid-column: 1 / -1;
        }

        #variantsCanvas {
            background: #0a0a15;
            border-radius: 10px;
        }

        .history-box {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 4px solid #e94560;
        }

        .history-box h3 {
            color: #e94560;
            margin-bottom: 10px;
        }

        /* New measurement panel styles */
        .measurement-panel {
            grid-column: 1 / -1;
        }

        #measureCanvas {
            background: #0a0a15;
            border-radius: 10px;
        }

        .measurement-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 600px) {
            .measurement-display {
                grid-template-columns: 1fr;
            }
        }

        .measure-box {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .measure-value {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .measure-value.actual {
            color: #4ecdc4;
        }

        .measure-value.perceived {
            color: #e94560;
        }

        .measure-value.error {
            color: #ffd93d;
        }

        .measure-label {
            color: #a0a0a0;
            font-size: 0.9em;
        }

        /* Side-by-side comparison styles */
        .comparison-panel {
            grid-column: 1 / -1;
        }

        #comparisonCanvas {
            background: #0a0a15;
            border-radius: 10px;
        }

        .toggle-row {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        /* Statistics panel styles */
        .stats-panel {
            grid-column: 1 / -1;
        }

        .perception-stats {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        @media (max-width: 800px) {
            .perception-stats {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 500px) {
            .perception-stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .perc-stat {
            background: rgba(255, 255, 255, 0.08);
            padding: 15px 10px;
            border-radius: 10px;
            text-align: center;
        }

        .perc-stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #e94560;
        }

        .perc-stat-label {
            font-size: 0.75em;
            color: #a0a0a0;
            margin-top: 5px;
        }

        .accuracy-bar-container {
            margin-top: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
        }

        .accuracy-bar-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            color: #a0a0a0;
        }

        .accuracy-bar {
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        .accuracy-fill {
            height: 100%;
            background: linear-gradient(90deg, #e94560, #4ecdc4);
            border-radius: 15px;
            transition: width 0.5s ease;
        }

        .accuracy-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">
        <span>←</span> Back to Paradoxes
    </a>

    <div class="container">
        <header>
            <h1>The Müller-Lyer Illusion</h1>
            <p class="subtitle">When arrows trick your brain about length</p>
        </header>

        <div class="main-content">
            <!-- Classic Demonstration -->
            <div class="panel">
                <h2>The Classic Illusion</h2>
                <div class="canvas-container">
                    <canvas id="illusionCanvas" width="450" height="300"></canvas>
                </div>
                <p style="text-align: center; color: #a0a0a0; margin-bottom: 15px;">
                    Which horizontal line appears longer?
                </p>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn btn-secondary" onclick="guessTop()">Top Line</button>
                    <button class="btn btn-secondary" onclick="guessBottom()">Bottom Line</button>
                    <button class="btn btn-primary" onclick="revealTruth()">Reveal Truth</button>
                </div>
                <div id="revealText" class="reveal-text"></div>
            </div>

            <!-- Interactive Adjuster -->
            <div class="panel">
                <h2>Adjust to Match</h2>
                <div class="canvas-container">
                    <canvas id="adjustCanvas" width="450" height="300"></canvas>
                </div>
                <p style="text-align: center; color: #a0a0a0; margin-bottom: 15px;">
                    Drag the slider until both lines LOOK equal
                </p>
                <div class="controls">
                    <div class="control-group">
                        <label>Adjust bottom line length: <span id="adjustValue">100%</span></label>
                        <input type="range" id="adjustSlider" min="60" max="140" value="100" oninput="updateAdjust()">
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn btn-primary" onclick="checkAdjustment()">Check My Perception</button>
                        <button class="btn btn-secondary" onclick="resetAdjust()">Reset</button>
                    </div>
                </div>
                <div id="adjustResult" class="reveal-text"></div>
            </div>

            <!-- Measurement Tool Panel -->
            <div class="panel measurement-panel">
                <h2>Measurement Tool: Actual vs Perceived</h2>
                <div class="canvas-container">
                    <canvas id="measureCanvas" width="800" height="300"></canvas>
                </div>
                <p style="text-align: center; color: #a0a0a0; margin-bottom: 15px;">
                    Drag the slider to match what you PERCEIVE as equal lengths. The measurement tool shows the difference.
                </p>
                <div class="controls">
                    <div class="control-group">
                        <label>Adjust perceived equal length: <span id="measureAdjustValue">100%</span></label>
                        <input type="range" id="measureSlider" min="70" max="130" value="100" oninput="updateMeasurement()">
                    </div>
                </div>
                <div class="toggle-row">
                    <button class="btn btn-toggle" id="showRulerBtn" onclick="toggleRuler()">Show Ruler</button>
                    <button class="btn btn-toggle" id="showGuidelinesBtn" onclick="toggleGuidelines()">Show Guidelines</button>
                    <button class="btn btn-primary" onclick="recordMeasurement()">Record Measurement</button>
                    <button class="btn btn-secondary" onclick="resetMeasurement()">Reset</button>
                </div>
                <div class="measurement-display">
                    <div class="measure-box">
                        <div class="measure-value actual" id="actualLengthDisplay">200px</div>
                        <div class="measure-label">Actual Length (Both Lines)</div>
                    </div>
                    <div class="measure-box">
                        <div class="measure-value perceived" id="perceivedLengthDisplay">200px</div>
                        <div class="measure-label">Your Perceived "Equal" Length</div>
                    </div>
                    <div class="measure-box">
                        <div class="measure-value error" id="perceptionErrorDisplay">0%</div>
                        <div class="measure-label">Perception Error</div>
                    </div>
                </div>
            </div>

            <!-- Side-by-Side Comparison Panel -->
            <div class="panel comparison-panel">
                <h2>Side-by-Side Comparison</h2>
                <div class="canvas-container">
                    <canvas id="comparisonCanvas" width="800" height="350"></canvas>
                </div>
                <p style="text-align: center; color: #a0a0a0; margin-bottom: 15px;">
                    Compare the illusion with and without arrows side by side
                </p>
                <div class="toggle-row">
                    <button class="btn btn-toggle active" id="showIllusionBtn" onclick="toggleIllusionView()">With Arrows</button>
                    <button class="btn btn-toggle active" id="showPlainBtn" onclick="togglePlainView()">Without Arrows</button>
                    <button class="btn btn-toggle" id="showOverlayBtn" onclick="toggleOverlay()">Overlay Mode</button>
                    <button class="btn btn-toggle" id="animateCompareBtn" onclick="toggleCompareAnimation()">Animate</button>
                </div>
            </div>

            <!-- Angle Experiment -->
            <div class="panel">
                <h2>Arrow Angle Effect</h2>
                <div class="canvas-container">
                    <canvas id="angleCanvas" width="450" height="300"></canvas>
                </div>
                <div class="controls">
                    <div class="control-group">
                        <label>Arrow Angle: <span id="angleValue">30</span> degrees</label>
                        <input type="range" id="angleSlider" min="10" max="80" value="30" oninput="updateAngle()">
                    </div>
                    <div class="control-group">
                        <label>Arrow Length: <span id="arrowLengthValue">40</span>px</label>
                        <input type="range" id="arrowLengthSlider" min="15" max="80" value="40" oninput="updateAngle()">
                    </div>
                </div>
                <p style="margin-top: 15px; color: #a0a0a0; font-size: 0.9em;">
                    Experiment with different angles and arrow lengths to see how the illusion strength changes!
                </p>
            </div>

            <!-- Line Thickness -->
            <div class="panel">
                <h2>Line Properties</h2>
                <div class="canvas-container">
                    <canvas id="thicknessCanvas" width="450" height="300"></canvas>
                </div>
                <div class="controls">
                    <div class="control-group">
                        <label>Line Thickness: <span id="thicknessValue">3px</span></label>
                        <input type="range" id="thicknessSlider" min="1" max="10" value="3" oninput="updateThickness()">
                    </div>
                    <div class="control-group">
                        <label>Color Scheme:</label>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button class="btn btn-secondary" onclick="setColors('#ffffff', '#0a0a15')">White on Black</button>
                            <button class="btn btn-secondary" onclick="setColors('#e94560', '#0a0a15')">Red on Black</button>
                            <button class="btn btn-secondary" onclick="setColors('#000000', '#ffffff')">Black on White</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Perception Game -->
            <div class="panel game-panel">
                <h2>Test Your Perception</h2>
                <div class="game-container">
                    <canvas id="gameCanvas" width="800" height="250"></canvas>
                    <div class="game-stats">
                        <div class="stat-box">
                            <div class="stat-value" id="trialNum">0</div>
                            <div class="stat-label">Trial</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="correctCount">0</div>
                            <div class="stat-label">Correct</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="accuracy">0%</div>
                            <div class="stat-label">Accuracy</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="avgError">0%</div>
                            <div class="stat-label">Avg Error</div>
                        </div>
                    </div>
                    <p id="gameInstruction" style="color: #a0a0a0;">Click "Start Game" to begin. You'll compare line lengths and try to overcome the illusion!</p>
                    <div class="game-buttons">
                        <button class="btn btn-primary" id="startBtn" onclick="startGame()">Start Game</button>
                        <button class="btn btn-secondary" id="leftBtn" onclick="gameAnswer('left')" style="display:none;">Left is Longer</button>
                        <button class="btn btn-secondary" id="sameBtn" onclick="gameAnswer('same')" style="display:none;">They're Equal</button>
                        <button class="btn btn-secondary" id="rightBtn" onclick="gameAnswer('right')" style="display:none;">Right is Longer</button>
                    </div>
                </div>
            </div>

            <!-- Cross-Cultural Research -->
            <div class="panel culture-panel">
                <h2>Cross-Cultural Research</h2>
                <p>The Müller-Lyer illusion's strength varies dramatically across cultures! Segall, Campbell & Herskovits (1966) found:</p>
                <div class="culture-grid">
                    <div class="culture-card">
                        <div class="culture-name">Western Urban</div>
                        <div class="culture-effect">~20%</div>
                        <div class="culture-desc">Strong susceptibility. Raised in "carpentered" environments with corners and right angles.</div>
                    </div>
                    <div class="culture-card">
                        <div class="culture-name">San People (Kalahari)</div>
                        <div class="culture-effect">~5%</div>
                        <div class="culture-desc">Much weaker effect. Circular huts, open desert, few right angles.</div>
                    </div>
                    <div class="culture-card">
                        <div class="culture-name">Torres Strait Islanders</div>
                        <div class="culture-effect">~3%</div>
                        <div class="culture-desc">Minimal effect. Environment with rounded structures and horizon lines.</div>
                    </div>
                    <div class="culture-card">
                        <div class="culture-name">Children (Age 4-6)</div>
                        <div class="culture-effect">~25%</div>
                        <div class="culture-desc">Stronger effect. Still learning depth cues from their environment.</div>
                    </div>
                </div>
                <p style="margin-top: 20px; color: #a0a0a0;">
                    <span class="highlight">The "Carpentered World" Hypothesis:</span> People in industrialized societies, surrounded by buildings with corners and edges, unconsciously interpret the arrows as depth cues—inward arrows suggest a receding corner, outward arrows an approaching edge.
                </p>
            </div>

            <!-- Variants -->
            <div class="panel variants-panel">
                <h2>Illusion Variants</h2>
                <div class="canvas-container">
                    <canvas id="variantsCanvas" width="800" height="400"></canvas>
                </div>
                <p style="color: #a0a0a0; text-align: center;">
                    All horizontal shafts are exactly the same length! Different fin configurations create different perceived lengths.
                </p>
            </div>

            <!-- Perception Accuracy Statistics -->
            <div class="panel stats-panel">
                <h2>Your Perception Accuracy Statistics</h2>
                <p style="color: #a0a0a0; margin-bottom: 15px;">
                    Track your performance across all measurements and games. How well can you overcome the illusion?
                </p>
                <div class="perception-stats">
                    <div class="perc-stat">
                        <div class="perc-stat-value" id="totalTrials">0</div>
                        <div class="perc-stat-label">Total Trials</div>
                    </div>
                    <div class="perc-stat">
                        <div class="perc-stat-value" id="correctGuesses">0</div>
                        <div class="perc-stat-label">Correct Guesses</div>
                    </div>
                    <div class="perc-stat">
                        <div class="perc-stat-value" id="avgErrorStat">0%</div>
                        <div class="perc-stat-label">Average Error</div>
                    </div>
                    <div class="perc-stat">
                        <div class="perc-stat-value" id="bestAccuracy">--</div>
                        <div class="perc-stat-label">Best Accuracy</div>
                    </div>
                    <div class="perc-stat">
                        <div class="perc-stat-value" id="illusionResistance">--</div>
                        <div class="perc-stat-label">Illusion Resistance</div>
                    </div>
                </div>
                <div class="accuracy-bar-container">
                    <div class="accuracy-bar-label">
                        <span>Illusion Susceptibility</span>
                        <span>Illusion Resistance</span>
                    </div>
                    <div class="accuracy-bar">
                        <div class="accuracy-fill" id="accuracyFill" style="width: 50%;"></div>
                        <div class="accuracy-text" id="accuracyText">50%</div>
                    </div>
                </div>
                <div style="text-align: center; margin-top: 15px;">
                    <button class="btn btn-secondary" onclick="resetAllStats()">Reset All Statistics</button>
                    <button class="btn btn-primary" onclick="exportStats()">Export Stats</button>
                </div>
            </div>

            <!-- Explanation -->
            <div class="panel explanation">
                <h2>The Psychology Behind the Illusion</h2>
                <p>
                    The <span class="highlight">Müller-Lyer Illusion</span>, first published by German psychiatrist
                    <span class="highlight">Franz Carl Müller-Lyer in 1889</span>, is one of the most famous and
                    well-studied optical illusions in psychology. Despite knowing both lines are identical,
                    your brain CANNOT stop perceiving them as different.
                </p>
                <p>
                    <strong>The "Depth Cue" Theory:</strong> Richard Gregory proposed that we interpret the arrows
                    as 3D corners. Outward-pointing arrows (><) look like an outside corner of a building coming
                    toward you—making the line appear closer and therefore SHORTER. Inward-pointing arrows (<>)
                    look like an inside corner receding away—making the line appear farther and therefore LONGER.
                </p>
                <p>
                    <strong>The "Centroid" Theory:</strong> Our visual system judges length by comparing the
                    centroids (centers of mass) of the overall figures. The outward arrows extend the centroid
                    beyond the line ends, while inward arrows compress it.
                </p>
                <p>
                    <strong>Why It Matters:</strong> This illusion demonstrates that perception is not passive
                    reception but active CONSTRUCTION. Your brain applies learned assumptions about the 3D world
                    to every 2D image—even simple line drawings. These "shortcuts" usually help but can be fooled.
                </p>

                <div class="history-box">
                    <h3>Historical Note</h3>
                    <p>
                        Müller-Lyer was actually a sociologist, not a vision scientist! He was interested in
                        how "judgment" could be influenced by context. His 1889 paper "Optische Urteilstäuschungen"
                        (Optical Judgment Illusions) included 15 different figures, but the arrow version became
                        the icon. It appears in nearly every introductory psychology textbook and has generated
                        over 1,000 research papers.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global configuration
        let lineColor = '#ffffff';
        let bgColor = '#0a0a15';

        // ========== CLASSIC ILLUSION ==========
        const classicCanvas = document.getElementById('illusionCanvas');
        const classicCtx = classicCanvas.getContext('2d');
        const lineLength = 200;
        const arrowLength = 40;
        const arrowAngle = 30 * Math.PI / 180;

        function drawClassicIllusion() {
            classicCtx.fillStyle = bgColor;
            classicCtx.fillRect(0, 0, classicCanvas.width, classicCanvas.height);

            const centerX = classicCanvas.width / 2;
            const y1 = 100;
            const y2 = 200;
            const startX = centerX - lineLength / 2;
            const endX = centerX + lineLength / 2;

            classicCtx.strokeStyle = lineColor;
            classicCtx.lineWidth = 3;
            classicCtx.lineCap = 'round';

            // Top line with inward arrows (appears longer)
            classicCtx.beginPath();
            classicCtx.moveTo(startX, y1);
            classicCtx.lineTo(endX, y1);
            classicCtx.stroke();

            // Left inward arrows
            classicCtx.beginPath();
            classicCtx.moveTo(startX + arrowLength * Math.cos(arrowAngle), y1 - arrowLength * Math.sin(arrowAngle));
            classicCtx.lineTo(startX, y1);
            classicCtx.lineTo(startX + arrowLength * Math.cos(arrowAngle), y1 + arrowLength * Math.sin(arrowAngle));
            classicCtx.stroke();

            // Right inward arrows
            classicCtx.beginPath();
            classicCtx.moveTo(endX - arrowLength * Math.cos(arrowAngle), y1 - arrowLength * Math.sin(arrowAngle));
            classicCtx.lineTo(endX, y1);
            classicCtx.lineTo(endX - arrowLength * Math.cos(arrowAngle), y1 + arrowLength * Math.sin(arrowAngle));
            classicCtx.stroke();

            // Bottom line with outward arrows (appears shorter)
            classicCtx.beginPath();
            classicCtx.moveTo(startX, y2);
            classicCtx.lineTo(endX, y2);
            classicCtx.stroke();

            // Left outward arrows
            classicCtx.beginPath();
            classicCtx.moveTo(startX - arrowLength * Math.cos(arrowAngle), y2 - arrowLength * Math.sin(arrowAngle));
            classicCtx.lineTo(startX, y2);
            classicCtx.lineTo(startX - arrowLength * Math.cos(arrowAngle), y2 + arrowLength * Math.sin(arrowAngle));
            classicCtx.stroke();

            // Right outward arrows
            classicCtx.beginPath();
            classicCtx.moveTo(endX + arrowLength * Math.cos(arrowAngle), y2 - arrowLength * Math.sin(arrowAngle));
            classicCtx.lineTo(endX, y2);
            classicCtx.lineTo(endX + arrowLength * Math.cos(arrowAngle), y2 + arrowLength * Math.sin(arrowAngle));
            classicCtx.stroke();

            // Labels
            classicCtx.fillStyle = '#a0a0a0';
            classicCtx.font = '14px Georgia';
            classicCtx.fillText('A', centerX - 5, y1 - 50);
            classicCtx.fillText('B', centerX - 5, y2 + 60);
        }

        function guessTop() {
            document.getElementById('revealText').innerHTML =
                'You said TOP (Line A) is longer. Most people agree—but let\'s see the truth!';
            document.getElementById('revealText').classList.add('visible');
        }

        function guessBottom() {
            document.getElementById('revealText').innerHTML =
                'Interesting! You said BOTTOM (Line B) is longer. Let\'s check!';
            document.getElementById('revealText').classList.add('visible');
        }

        function revealTruth() {
            classicCtx.fillStyle = bgColor;
            classicCtx.fillRect(0, 0, classicCanvas.width, classicCanvas.height);

            const centerX = classicCanvas.width / 2;
            const startX = centerX - lineLength / 2;
            const endX = centerX + lineLength / 2;

            // Draw just the lines with measurement marks
            classicCtx.strokeStyle = '#4ecdc4';
            classicCtx.lineWidth = 3;

            // Top line
            classicCtx.beginPath();
            classicCtx.moveTo(startX, 100);
            classicCtx.lineTo(endX, 100);
            classicCtx.stroke();

            // Bottom line
            classicCtx.beginPath();
            classicCtx.moveTo(startX, 200);
            classicCtx.lineTo(endX, 200);
            classicCtx.stroke();

            // Measurement lines
            classicCtx.strokeStyle = '#e94560';
            classicCtx.setLineDash([5, 5]);
            classicCtx.beginPath();
            classicCtx.moveTo(startX, 80);
            classicCtx.lineTo(startX, 220);
            classicCtx.moveTo(endX, 80);
            classicCtx.lineTo(endX, 220);
            classicCtx.stroke();
            classicCtx.setLineDash([]);

            // Labels
            classicCtx.fillStyle = '#e94560';
            classicCtx.font = 'bold 16px Georgia';
            classicCtx.textAlign = 'center';
            classicCtx.fillText('BOTH LINES ARE EXACTLY 200px!', centerX, 150);
            classicCtx.fillText(`${lineLength}px`, centerX, 250);

            document.getElementById('revealText').innerHTML =
                '<strong>THEY\'RE IDENTICAL!</strong> Both lines are exactly ' + lineLength +
                ' pixels long. The inward arrows (<>) make Line A appear 15-25% LONGER, ' +
                'while outward arrows (><) make Line B appear SHORTER. Your brain cannot unsee it!';
            document.getElementById('revealText').classList.add('visible');

            setTimeout(drawClassicIllusion, 4000);
        }

        // ========== ADJUST TO MATCH ==========
        const adjustCanvas = document.getElementById('adjustCanvas');
        const adjustCtx = adjustCanvas.getContext('2d');
        let adjustRatio = 100;

        function drawAdjustIllusion() {
            adjustCtx.fillStyle = '#0a0a15';
            adjustCtx.fillRect(0, 0, adjustCanvas.width, adjustCanvas.height);

            const centerX = adjustCanvas.width / 2;
            const y1 = 100;
            const y2 = 200;
            const baseLength = 180;
            const adjustedLength = baseLength * (adjustRatio / 100);

            adjustCtx.strokeStyle = '#ffffff';
            adjustCtx.lineWidth = 3;
            adjustCtx.lineCap = 'round';

            // Top line with inward arrows (fixed)
            const topStartX = centerX - baseLength / 2;
            const topEndX = centerX + baseLength / 2;

            adjustCtx.beginPath();
            adjustCtx.moveTo(topStartX, y1);
            adjustCtx.lineTo(topEndX, y1);
            classicCtx.stroke();

            // Inward arrows
            const angle = 30 * Math.PI / 180;
            const al = 35;

            adjustCtx.beginPath();
            adjustCtx.moveTo(topStartX + al * Math.cos(angle), y1 - al * Math.sin(angle));
            adjustCtx.lineTo(topStartX, y1);
            adjustCtx.lineTo(topStartX + al * Math.cos(angle), y1 + al * Math.sin(angle));
            adjustCtx.stroke();

            adjustCtx.beginPath();
            adjustCtx.moveTo(topEndX - al * Math.cos(angle), y1 - al * Math.sin(angle));
            adjustCtx.lineTo(topEndX, y1);
            adjustCtx.lineTo(topEndX - al * Math.cos(angle), y1 + al * Math.sin(angle));
            adjustCtx.stroke();

            // Bottom line with outward arrows (adjustable)
            const botStartX = centerX - adjustedLength / 2;
            const botEndX = centerX + adjustedLength / 2;

            adjustCtx.beginPath();
            adjustCtx.moveTo(botStartX, y2);
            adjustCtx.lineTo(botEndX, y2);
            adjustCtx.stroke();

            // Outward arrows
            adjustCtx.beginPath();
            adjustCtx.moveTo(botStartX - al * Math.cos(angle), y2 - al * Math.sin(angle));
            adjustCtx.lineTo(botStartX, y2);
            adjustCtx.lineTo(botStartX - al * Math.cos(angle), y2 + al * Math.sin(angle));
            adjustCtx.stroke();

            adjustCtx.beginPath();
            adjustCtx.moveTo(botEndX + al * Math.cos(angle), y2 - al * Math.sin(angle));
            adjustCtx.lineTo(botEndX, y2);
            adjustCtx.lineTo(botEndX + al * Math.cos(angle), y2 + al * Math.sin(angle));
            adjustCtx.stroke();
        }

        function updateAdjust() {
            adjustRatio = parseInt(document.getElementById('adjustSlider').value);
            document.getElementById('adjustValue').textContent = adjustRatio + '%';
            drawAdjustIllusion();
        }

        function checkAdjustment() {
            const error = Math.abs(adjustRatio - 100);
            let message = '';

            if (error === 0) {
                message = '<strong>PERFECT!</strong> You set them exactly equal. Either you measured, or you have exceptional perception!';
            } else if (adjustRatio > 100) {
                message = `<strong>Illusion confirmed!</strong> You made the bottom line ${adjustRatio - 100}% LONGER to make it "look equal." ` +
                    `The outward arrows made you underestimate its length by ${adjustRatio - 100}%!`;
            } else {
                message = `<strong>Unusual!</strong> You made the bottom line ${100 - adjustRatio}% SHORTER. ` +
                    `Most people make it longer. You may have over-compensated for the expected illusion!`;
            }

            document.getElementById('adjustResult').innerHTML = message;
            document.getElementById('adjustResult').classList.add('visible');
        }

        function resetAdjust() {
            document.getElementById('adjustSlider').value = 100;
            adjustRatio = 100;
            document.getElementById('adjustValue').textContent = '100%';
            document.getElementById('adjustResult').classList.remove('visible');
            drawAdjustIllusion();
        }

        // ========== ANGLE EXPERIMENT ==========
        const angleCanvas = document.getElementById('angleCanvas');
        const angleCtx = angleCanvas.getContext('2d');

        function drawAngleExperiment() {
            angleCtx.fillStyle = '#0a0a15';
            angleCtx.fillRect(0, 0, angleCanvas.width, angleCanvas.height);

            const centerX = angleCanvas.width / 2;
            const angle = parseInt(document.getElementById('angleSlider').value) * Math.PI / 180;
            const arrowLen = parseInt(document.getElementById('arrowLengthSlider').value);
            const lineLen = 180;
            const y1 = 100;
            const y2 = 200;

            angleCtx.strokeStyle = '#ffffff';
            angleCtx.lineWidth = 3;
            angleCtx.lineCap = 'round';

            const startX = centerX - lineLen / 2;
            const endX = centerX + lineLen / 2;

            // Top line with inward arrows
            angleCtx.beginPath();
            angleCtx.moveTo(startX, y1);
            angleCtx.lineTo(endX, y1);
            angleCtx.stroke();

            angleCtx.beginPath();
            angleCtx.moveTo(startX + arrowLen * Math.cos(angle), y1 - arrowLen * Math.sin(angle));
            angleCtx.lineTo(startX, y1);
            angleCtx.lineTo(startX + arrowLen * Math.cos(angle), y1 + arrowLen * Math.sin(angle));
            angleCtx.stroke();

            angleCtx.beginPath();
            angleCtx.moveTo(endX - arrowLen * Math.cos(angle), y1 - arrowLen * Math.sin(angle));
            angleCtx.lineTo(endX, y1);
            angleCtx.lineTo(endX - arrowLen * Math.cos(angle), y1 + arrowLen * Math.sin(angle));
            angleCtx.stroke();

            // Bottom line with outward arrows
            angleCtx.beginPath();
            angleCtx.moveTo(startX, y2);
            angleCtx.lineTo(endX, y2);
            angleCtx.stroke();

            angleCtx.beginPath();
            angleCtx.moveTo(startX - arrowLen * Math.cos(angle), y2 - arrowLen * Math.sin(angle));
            angleCtx.lineTo(startX, y2);
            angleCtx.lineTo(startX - arrowLen * Math.cos(angle), y2 + arrowLen * Math.sin(angle));
            angleCtx.stroke();

            angleCtx.beginPath();
            angleCtx.moveTo(endX + arrowLen * Math.cos(angle), y2 - arrowLen * Math.sin(angle));
            angleCtx.lineTo(endX, y2);
            angleCtx.lineTo(endX + arrowLen * Math.cos(angle), y2 + arrowLen * Math.sin(angle));
            angleCtx.stroke();
        }

        function updateAngle() {
            document.getElementById('angleValue').textContent = document.getElementById('angleSlider').value + '°';
            document.getElementById('arrowLengthValue').textContent = document.getElementById('arrowLengthSlider').value + 'px';
            drawAngleExperiment();
        }

        // ========== THICKNESS EXPERIMENT ==========
        const thicknessCanvas = document.getElementById('thicknessCanvas');
        const thicknessCtx = thicknessCanvas.getContext('2d');

        function drawThicknessExperiment() {
            thicknessCtx.fillStyle = bgColor;
            thicknessCtx.fillRect(0, 0, thicknessCanvas.width, thicknessCanvas.height);

            const centerX = thicknessCanvas.width / 2;
            const thickness = parseInt(document.getElementById('thicknessSlider').value);
            const lineLen = 180;
            const arrowLen = 35;
            const angle = 30 * Math.PI / 180;
            const y1 = 100;
            const y2 = 200;

            thicknessCtx.strokeStyle = lineColor;
            thicknessCtx.lineWidth = thickness;
            thicknessCtx.lineCap = 'round';

            const startX = centerX - lineLen / 2;
            const endX = centerX + lineLen / 2;

            // Top line with inward arrows
            thicknessCtx.beginPath();
            thicknessCtx.moveTo(startX, y1);
            thicknessCtx.lineTo(endX, y1);
            thicknessCtx.stroke();

            thicknessCtx.beginPath();
            thicknessCtx.moveTo(startX + arrowLen * Math.cos(angle), y1 - arrowLen * Math.sin(angle));
            thicknessCtx.lineTo(startX, y1);
            thicknessCtx.lineTo(startX + arrowLen * Math.cos(angle), y1 + arrowLen * Math.sin(angle));
            thicknessCtx.stroke();

            thicknessCtx.beginPath();
            thicknessCtx.moveTo(endX - arrowLen * Math.cos(angle), y1 - arrowLen * Math.sin(angle));
            thicknessCtx.lineTo(endX, y1);
            thicknessCtx.lineTo(endX - arrowLen * Math.cos(angle), y1 + arrowLen * Math.sin(angle));
            thicknessCtx.stroke();

            // Bottom line with outward arrows
            thicknessCtx.beginPath();
            thicknessCtx.moveTo(startX, y2);
            thicknessCtx.lineTo(endX, y2);
            thicknessCtx.stroke();

            thicknessCtx.beginPath();
            thicknessCtx.moveTo(startX - arrowLen * Math.cos(angle), y2 - arrowLen * Math.sin(angle));
            thicknessCtx.lineTo(startX, y2);
            thicknessCtx.lineTo(startX - arrowLen * Math.cos(angle), y2 + arrowLen * Math.sin(angle));
            thicknessCtx.stroke();

            thicknessCtx.beginPath();
            thicknessCtx.moveTo(endX + arrowLen * Math.cos(angle), y2 - arrowLen * Math.sin(angle));
            thicknessCtx.lineTo(endX, y2);
            thicknessCtx.lineTo(endX + arrowLen * Math.cos(angle), y2 + arrowLen * Math.sin(angle));
            thicknessCtx.stroke();
        }

        function updateThickness() {
            document.getElementById('thicknessValue').textContent = document.getElementById('thicknessSlider').value + 'px';
            drawThicknessExperiment();
        }

        function setColors(fg, bg) {
            lineColor = fg;
            bgColor = bg;
            drawThicknessExperiment();
        }

        // ========== PERCEPTION GAME ==========
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCtx = gameCanvas.getContext('2d');
        let gameState = {
            active: false,
            trial: 0,
            correct: 0,
            errors: [],
            currentLeft: 0,
            currentRight: 0,
            correctAnswer: ''
        };

        function drawGameTrial() {
            gameCtx.fillStyle = '#0a0a15';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

            const y = 125;
            const leftX = 150;
            const rightX = 550;
            const arrowLen = 35;
            const angle = 30 * Math.PI / 180;

            // Generate random lengths with small differences
            const baseLength = 150;
            const variation = Math.random() * 40 - 20; // -20 to +20
            const leftArrowsOut = Math.random() < 0.5;
            const rightArrowsOut = Math.random() < 0.5;

            gameState.currentLeft = baseLength + (leftArrowsOut ? 0 : variation);
            gameState.currentRight = baseLength + (rightArrowsOut ? 0 : -variation);

            // Determine correct answer
            if (Math.abs(gameState.currentLeft - gameState.currentRight) < 3) {
                gameState.correctAnswer = 'same';
            } else if (gameState.currentLeft > gameState.currentRight) {
                gameState.correctAnswer = 'left';
            } else {
                gameState.correctAnswer = 'right';
            }

            gameCtx.strokeStyle = '#ffffff';
            gameCtx.lineWidth = 3;
            gameCtx.lineCap = 'round';

            // Left figure
            const leftStart = leftX - gameState.currentLeft / 2;
            const leftEnd = leftX + gameState.currentLeft / 2;

            gameCtx.beginPath();
            gameCtx.moveTo(leftStart, y);
            gameCtx.lineTo(leftEnd, y);
            gameCtx.stroke();

            if (leftArrowsOut) {
                // Outward arrows
                gameCtx.beginPath();
                gameCtx.moveTo(leftStart - arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                gameCtx.lineTo(leftStart, y);
                gameCtx.lineTo(leftStart - arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                gameCtx.stroke();

                gameCtx.beginPath();
                gameCtx.moveTo(leftEnd + arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                gameCtx.lineTo(leftEnd, y);
                gameCtx.lineTo(leftEnd + arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                gameCtx.stroke();
            } else {
                // Inward arrows
                gameCtx.beginPath();
                gameCtx.moveTo(leftStart + arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                gameCtx.lineTo(leftStart, y);
                gameCtx.lineTo(leftStart + arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                gameCtx.stroke();

                gameCtx.beginPath();
                gameCtx.moveTo(leftEnd - arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                gameCtx.lineTo(leftEnd, y);
                gameCtx.lineTo(leftEnd - arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                gameCtx.stroke();
            }

            // Right figure
            const rightStart = rightX - gameState.currentRight / 2;
            const rightEnd = rightX + gameState.currentRight / 2;

            gameCtx.beginPath();
            gameCtx.moveTo(rightStart, y);
            gameCtx.lineTo(rightEnd, y);
            gameCtx.stroke();

            if (rightArrowsOut) {
                gameCtx.beginPath();
                gameCtx.moveTo(rightStart - arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                gameCtx.lineTo(rightStart, y);
                gameCtx.lineTo(rightStart - arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                gameCtx.stroke();

                gameCtx.beginPath();
                gameCtx.moveTo(rightEnd + arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                gameCtx.lineTo(rightEnd, y);
                gameCtx.lineTo(rightEnd + arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                gameCtx.stroke();
            } else {
                gameCtx.beginPath();
                gameCtx.moveTo(rightStart + arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                gameCtx.lineTo(rightStart, y);
                gameCtx.lineTo(rightStart + arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                gameCtx.stroke();

                gameCtx.beginPath();
                gameCtx.moveTo(rightEnd - arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                gameCtx.lineTo(rightEnd, y);
                gameCtx.lineTo(rightEnd - arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                gameCtx.stroke();
            }

            // Labels
            gameCtx.fillStyle = '#a0a0a0';
            gameCtx.font = '16px Georgia';
            gameCtx.textAlign = 'center';
            gameCtx.fillText('LEFT', leftX, y + 60);
            gameCtx.fillText('RIGHT', rightX, y + 60);
        }

        function startGame() {
            gameState = {
                active: true,
                trial: 0,
                correct: 0,
                errors: [],
                currentLeft: 0,
                currentRight: 0,
                correctAnswer: ''
            };

            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('leftBtn').style.display = 'inline-block';
            document.getElementById('sameBtn').style.display = 'inline-block';
            document.getElementById('rightBtn').style.display = 'inline-block';
            document.getElementById('gameInstruction').textContent = 'Which line is LONGER? (or are they equal?)';

            nextTrial();
        }

        function nextTrial() {
            gameState.trial++;
            updateGameStats();
            drawGameTrial();
        }

        function gameAnswer(answer) {
            const isCorrect = answer === gameState.correctAnswer;

            if (isCorrect) {
                gameState.correct++;
            } else {
                const error = Math.abs(gameState.currentLeft - gameState.currentRight) / 150 * 100;
                gameState.errors.push(error);
            }

            // Show feedback briefly
            gameCtx.fillStyle = isCorrect ? 'rgba(78, 205, 196, 0.3)' : 'rgba(233, 69, 96, 0.3)';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

            gameCtx.fillStyle = isCorrect ? '#4ecdc4' : '#e94560';
            gameCtx.font = 'bold 24px Georgia';
            gameCtx.textAlign = 'center';
            gameCtx.fillText(isCorrect ? 'CORRECT!' : `WRONG! Answer: ${gameState.correctAnswer.toUpperCase()}`, 400, 40);

            if (gameState.trial < 10) {
                setTimeout(nextTrial, 1000);
            } else {
                endGame();
            }

            updateGameStats();
        }

        function updateGameStats() {
            document.getElementById('trialNum').textContent = gameState.trial;
            document.getElementById('correctCount').textContent = gameState.correct;
            document.getElementById('accuracy').textContent = gameState.trial > 0
                ? Math.round(gameState.correct / gameState.trial * 100) + '%'
                : '0%';
            document.getElementById('avgError').textContent = gameState.errors.length > 0
                ? Math.round(gameState.errors.reduce((a, b) => a + b, 0) / gameState.errors.length) + '%'
                : '0%';
        }

        function endGame() {
            gameState.active = false;

            document.getElementById('leftBtn').style.display = 'none';
            document.getElementById('sameBtn').style.display = 'none';
            document.getElementById('rightBtn').style.display = 'none';
            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('startBtn').textContent = 'Play Again';

            const accuracy = Math.round(gameState.correct / 10 * 100);
            let message = '';

            if (accuracy >= 80) {
                message = `Amazing! ${accuracy}% accuracy. You've trained your brain to resist the illusion!`;
            } else if (accuracy >= 50) {
                message = `${accuracy}% accuracy. The illusion tricked you on some trials. Keep practicing!`;
            } else {
                message = `${accuracy}% accuracy. The Müller-Lyer illusion is powerful! Your brain couldn't help seeing what isn't there.`;
            }

            document.getElementById('gameInstruction').textContent = message;
        }

        // ========== VARIANTS ==========
        const variantsCanvas = document.getElementById('variantsCanvas');
        const variantsCtx = variantsCanvas.getContext('2d');

        function drawVariants() {
            variantsCtx.fillStyle = '#0a0a15';
            variantsCtx.fillRect(0, 0, variantsCanvas.width, variantsCanvas.height);

            const lineLength = 120;
            const arrowLen = 30;
            const angle = 30 * Math.PI / 180;
            const spacing = 80;

            variantsCtx.strokeStyle = '#ffffff';
            variantsCtx.lineWidth = 2.5;
            variantsCtx.lineCap = 'round';

            const variants = [
                { name: 'Classic Inward', drawArrows: (x, y, len) => drawInwardArrows(x, y, len, arrowLen, angle) },
                { name: 'Classic Outward', drawArrows: (x, y, len) => drawOutwardArrows(x, y, len, arrowLen, angle) },
                { name: 'Circles', drawArrows: (x, y, len) => drawCircleEnds(x, y, len) },
                { name: 'Squares', drawArrows: (x, y, len) => drawSquareEnds(x, y, len) },
                { name: 'No Fins', drawArrows: () => {} }
            ];

            variants.forEach((variant, i) => {
                const y = 60 + i * spacing;
                const startX = 340 - lineLength / 2;
                const endX = 340 + lineLength / 2;

                // Draw the line
                variantsCtx.beginPath();
                variantsCtx.moveTo(startX, y);
                variantsCtx.lineTo(endX, y);
                variantsCtx.stroke();

                // Draw the decorations
                variant.drawArrows(startX, endX, y);

                // Label
                variantsCtx.fillStyle = '#a0a0a0';
                variantsCtx.font = '14px Georgia';
                variantsCtx.textAlign = 'left';
                variantsCtx.fillText(variant.name, 550, y + 5);

                // Length indicator
                variantsCtx.fillStyle = '#e94560';
                variantsCtx.textAlign = 'right';
                variantsCtx.fillText(`${lineLength}px`, 280, y + 5);
            });
        }

        function drawInwardArrows(startX, endX, y, arrowLen, angle) {
            variantsCtx.beginPath();
            variantsCtx.moveTo(startX + arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
            variantsCtx.lineTo(startX, y);
            variantsCtx.lineTo(startX + arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
            variantsCtx.stroke();

            variantsCtx.beginPath();
            variantsCtx.moveTo(endX - arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
            variantsCtx.lineTo(endX, y);
            variantsCtx.lineTo(endX - arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
            variantsCtx.stroke();
        }

        function drawOutwardArrows(startX, endX, y, arrowLen, angle) {
            variantsCtx.beginPath();
            variantsCtx.moveTo(startX - arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
            variantsCtx.lineTo(startX, y);
            variantsCtx.lineTo(startX - arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
            variantsCtx.stroke();

            variantsCtx.beginPath();
            variantsCtx.moveTo(endX + arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
            variantsCtx.lineTo(endX, y);
            variantsCtx.lineTo(endX + arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
            variantsCtx.stroke();
        }

        function drawCircleEnds(startX, endX, y) {
            variantsCtx.beginPath();
            variantsCtx.arc(startX, y, 12, 0, Math.PI * 2);
            variantsCtx.stroke();

            variantsCtx.beginPath();
            variantsCtx.arc(endX, y, 12, 0, Math.PI * 2);
            variantsCtx.stroke();
        }

        function drawSquareEnds(startX, endX, y) {
            const size = 20;
            variantsCtx.strokeRect(startX - size/2, y - size/2, size, size);
            variantsCtx.strokeRect(endX - size/2, y - size/2, size, size);
        }

        // ========== MEASUREMENT TOOL ==========
        const measureCanvas = document.getElementById('measureCanvas');
        const measureCtx = measureCanvas.getContext('2d');
        let measureRatio = 100;
        let showRuler = false;
        let showGuidelines = false;
        const measureBaseLength = 200;

        function drawMeasurementTool() {
            measureCtx.fillStyle = '#0a0a15';
            measureCtx.fillRect(0, 0, measureCanvas.width, measureCanvas.height);

            const centerX = measureCanvas.width / 2;
            const y1 = 100;
            const y2 = 200;
            const adjustedLength = measureBaseLength * (measureRatio / 100);
            const angle = 30 * Math.PI / 180;
            const arrowLen = 40;

            measureCtx.strokeStyle = '#ffffff';
            measureCtx.lineWidth = 3;
            measureCtx.lineCap = 'round';

            // Top line with inward arrows (fixed reference)
            const topStartX = centerX - measureBaseLength / 2;
            const topEndX = centerX + measureBaseLength / 2;

            measureCtx.beginPath();
            measureCtx.moveTo(topStartX, y1);
            measureCtx.lineTo(topEndX, y1);
            measureCtx.stroke();

            // Inward arrows for top
            measureCtx.beginPath();
            measureCtx.moveTo(topStartX + arrowLen * Math.cos(angle), y1 - arrowLen * Math.sin(angle));
            measureCtx.lineTo(topStartX, y1);
            measureCtx.lineTo(topStartX + arrowLen * Math.cos(angle), y1 + arrowLen * Math.sin(angle));
            measureCtx.stroke();

            measureCtx.beginPath();
            measureCtx.moveTo(topEndX - arrowLen * Math.cos(angle), y1 - arrowLen * Math.sin(angle));
            measureCtx.lineTo(topEndX, y1);
            measureCtx.lineTo(topEndX - arrowLen * Math.cos(angle), y1 + arrowLen * Math.sin(angle));
            measureCtx.stroke();

            // Bottom line with outward arrows (adjustable)
            const botStartX = centerX - adjustedLength / 2;
            const botEndX = centerX + adjustedLength / 2;

            measureCtx.strokeStyle = '#4ecdc4';
            measureCtx.beginPath();
            measureCtx.moveTo(botStartX, y2);
            measureCtx.lineTo(botEndX, y2);
            measureCtx.stroke();

            // Outward arrows for bottom
            measureCtx.beginPath();
            measureCtx.moveTo(botStartX - arrowLen * Math.cos(angle), y2 - arrowLen * Math.sin(angle));
            measureCtx.lineTo(botStartX, y2);
            measureCtx.lineTo(botStartX - arrowLen * Math.cos(angle), y2 + arrowLen * Math.sin(angle));
            measureCtx.stroke();

            measureCtx.beginPath();
            measureCtx.moveTo(botEndX + arrowLen * Math.cos(angle), y2 - arrowLen * Math.sin(angle));
            measureCtx.lineTo(botEndX, y2);
            measureCtx.lineTo(botEndX + arrowLen * Math.cos(angle), y2 + arrowLen * Math.sin(angle));
            measureCtx.stroke();

            // Draw ruler if enabled
            if (showRuler) {
                measureCtx.strokeStyle = '#ffd93d';
                measureCtx.lineWidth = 1;
                measureCtx.setLineDash([]);

                // Ruler for top line
                measureCtx.beginPath();
                measureCtx.moveTo(topStartX, y1 - 40);
                measureCtx.lineTo(topEndX, y1 - 40);
                measureCtx.stroke();

                // Tick marks
                for (let i = 0; i <= measureBaseLength; i += 20) {
                    const x = topStartX + i;
                    const tickHeight = i % 100 === 0 ? 15 : (i % 50 === 0 ? 10 : 5);
                    measureCtx.beginPath();
                    measureCtx.moveTo(x, y1 - 40);
                    measureCtx.lineTo(x, y1 - 40 - tickHeight);
                    measureCtx.stroke();
                }

                // Ruler for bottom line
                measureCtx.beginPath();
                measureCtx.moveTo(botStartX, y2 + 40);
                measureCtx.lineTo(botEndX, y2 + 40);
                measureCtx.stroke();

                for (let i = 0; i <= adjustedLength; i += 20) {
                    const x = botStartX + i;
                    const tickHeight = i % 100 === 0 ? 15 : (i % 50 === 0 ? 10 : 5);
                    measureCtx.beginPath();
                    measureCtx.moveTo(x, y2 + 40);
                    measureCtx.lineTo(x, y2 + 40 + tickHeight);
                    measureCtx.stroke();
                }

                // Length labels
                measureCtx.fillStyle = '#ffd93d';
                measureCtx.font = 'bold 14px Georgia';
                measureCtx.textAlign = 'center';
                measureCtx.fillText(`${measureBaseLength}px`, centerX, y1 - 50);
                measureCtx.fillText(`${Math.round(adjustedLength)}px`, centerX, y2 + 70);
            }

            // Draw guidelines if enabled
            if (showGuidelines) {
                measureCtx.strokeStyle = 'rgba(233, 69, 96, 0.5)';
                measureCtx.lineWidth = 1;
                measureCtx.setLineDash([5, 5]);

                // Vertical guidelines at line endpoints
                measureCtx.beginPath();
                measureCtx.moveTo(topStartX, y1 - 60);
                measureCtx.lineTo(topStartX, y2 + 60);
                measureCtx.stroke();

                measureCtx.beginPath();
                measureCtx.moveTo(topEndX, y1 - 60);
                measureCtx.lineTo(topEndX, y2 + 60);
                measureCtx.stroke();

                measureCtx.setLineDash([]);
            }

            // Labels
            measureCtx.fillStyle = '#a0a0a0';
            measureCtx.font = '14px Georgia';
            measureCtx.textAlign = 'right';
            measureCtx.fillText('Reference (fixed):', topStartX - 60, y1 + 5);
            measureCtx.fillText('Your adjustment:', botStartX - 60, y2 + 5);

            // Update display values
            document.getElementById('actualLengthDisplay').textContent = measureBaseLength + 'px';
            document.getElementById('perceivedLengthDisplay').textContent = Math.round(adjustedLength) + 'px';
            const error = measureRatio - 100;
            const errorSign = error >= 0 ? '+' : '';
            document.getElementById('perceptionErrorDisplay').textContent = errorSign + error + '%';
        }

        function updateMeasurement() {
            measureRatio = parseInt(document.getElementById('measureSlider').value);
            document.getElementById('measureAdjustValue').textContent = measureRatio + '%';
            drawMeasurementTool();
        }

        function toggleRuler() {
            showRuler = !showRuler;
            document.getElementById('showRulerBtn').classList.toggle('active', showRuler);
            drawMeasurementTool();
        }

        function toggleGuidelines() {
            showGuidelines = !showGuidelines;
            document.getElementById('showGuidelinesBtn').classList.toggle('active', showGuidelines);
            drawMeasurementTool();
        }

        function recordMeasurement() {
            const error = Math.abs(measureRatio - 100);
            perceptionStats.totalTrials++;
            perceptionStats.allErrors.push(error);
            if (error <= 5) {
                perceptionStats.correctGuesses++;
            }
            if (error < perceptionStats.bestAccuracy || perceptionStats.bestAccuracy === null) {
                perceptionStats.bestAccuracy = error;
            }
            updatePerceptionStats();
            saveStats();

            alert(`Measurement recorded!\nYour error: ${error}%\n${error <= 5 ? 'Excellent accuracy!' : error <= 15 ? 'Typical illusion effect.' : 'Strong illusion susceptibility.'}`);
        }

        function resetMeasurement() {
            measureRatio = 100;
            document.getElementById('measureSlider').value = 100;
            document.getElementById('measureAdjustValue').textContent = '100%';
            drawMeasurementTool();
        }

        // ========== SIDE-BY-SIDE COMPARISON ==========
        const comparisonCanvas = document.getElementById('comparisonCanvas');
        const comparisonCtx = comparisonCanvas.getContext('2d');
        let showIllusionView = true;
        let showPlainView = true;
        let showOverlay = false;
        let compareAnimating = false;
        let compareAnimationId = null;
        let compareAnimPhase = 0;

        function drawComparison() {
            comparisonCtx.fillStyle = '#0a0a15';
            comparisonCtx.fillRect(0, 0, comparisonCanvas.width, comparisonCanvas.height);

            const lineLen = 180;
            const arrowLen = 35;
            const angle = 30 * Math.PI / 180;

            if (showOverlay) {
                // Overlay mode: both on same position
                const centerX = comparisonCanvas.width / 2;
                const y1 = 120;
                const y2 = 230;

                // Draw with arrows (semi-transparent)
                comparisonCtx.globalAlpha = showIllusionView ? 0.7 : 0;
                comparisonCtx.strokeStyle = '#e94560';
                comparisonCtx.lineWidth = 3;
                comparisonCtx.lineCap = 'round';

                drawMullerLyerFigure(comparisonCtx, centerX, y1, lineLen, arrowLen, angle, 'inward');
                drawMullerLyerFigure(comparisonCtx, centerX, y2, lineLen, arrowLen, angle, 'outward');

                // Draw without arrows
                comparisonCtx.globalAlpha = showPlainView ? 1 : 0;
                comparisonCtx.strokeStyle = '#4ecdc4';
                comparisonCtx.lineWidth = 4;

                comparisonCtx.beginPath();
                comparisonCtx.moveTo(centerX - lineLen / 2, y1);
                comparisonCtx.lineTo(centerX + lineLen / 2, y1);
                comparisonCtx.stroke();

                comparisonCtx.beginPath();
                comparisonCtx.moveTo(centerX - lineLen / 2, y2);
                comparisonCtx.lineTo(centerX + lineLen / 2, y2);
                comparisonCtx.stroke();

                comparisonCtx.globalAlpha = 1;
            } else {
                // Side-by-side mode
                const leftX = 200;
                const rightX = 600;
                const y1 = 120;
                const y2 = 230;

                // Left side: With arrows
                if (showIllusionView) {
                    comparisonCtx.strokeStyle = '#ffffff';
                    comparisonCtx.lineWidth = 3;
                    comparisonCtx.lineCap = 'round';

                    drawMullerLyerFigure(comparisonCtx, leftX, y1, lineLen, arrowLen, angle, 'inward');
                    drawMullerLyerFigure(comparisonCtx, leftX, y2, lineLen, arrowLen, angle, 'outward');

                    comparisonCtx.fillStyle = '#a0a0a0';
                    comparisonCtx.font = '16px Georgia';
                    comparisonCtx.textAlign = 'center';
                    comparisonCtx.fillText('With Arrows', leftX, 30);
                }

                // Right side: Without arrows
                if (showPlainView) {
                    comparisonCtx.strokeStyle = '#4ecdc4';
                    comparisonCtx.lineWidth = 3;

                    comparisonCtx.beginPath();
                    comparisonCtx.moveTo(rightX - lineLen / 2, y1);
                    comparisonCtx.lineTo(rightX + lineLen / 2, y1);
                    comparisonCtx.stroke();

                    comparisonCtx.beginPath();
                    comparisonCtx.moveTo(rightX - lineLen / 2, y2);
                    comparisonCtx.lineTo(rightX + lineLen / 2, y2);
                    comparisonCtx.stroke();

                    comparisonCtx.fillStyle = '#a0a0a0';
                    comparisonCtx.font = '16px Georgia';
                    comparisonCtx.textAlign = 'center';
                    comparisonCtx.fillText('Without Arrows', rightX, 30);
                }

                // Center divider
                comparisonCtx.strokeStyle = 'rgba(255,255,255,0.2)';
                comparisonCtx.lineWidth = 1;
                comparisonCtx.setLineDash([5, 5]);
                comparisonCtx.beginPath();
                comparisonCtx.moveTo(400, 50);
                comparisonCtx.lineTo(400, 300);
                comparisonCtx.stroke();
                comparisonCtx.setLineDash([]);
            }

            // Labels
            comparisonCtx.fillStyle = '#a0a0a0';
            comparisonCtx.font = '12px Georgia';
            comparisonCtx.textAlign = 'center';
            comparisonCtx.fillText(`Both lines: ${lineLen}px`, comparisonCanvas.width / 2, 330);
        }

        function drawMullerLyerFigure(ctx, centerX, y, lineLen, arrowLen, angle, type) {
            const startX = centerX - lineLen / 2;
            const endX = centerX + lineLen / 2;

            // Main line
            ctx.beginPath();
            ctx.moveTo(startX, y);
            ctx.lineTo(endX, y);
            ctx.stroke();

            if (type === 'inward') {
                // Inward arrows (<>)
                ctx.beginPath();
                ctx.moveTo(startX + arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                ctx.lineTo(startX, y);
                ctx.lineTo(startX + arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(endX - arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                ctx.lineTo(endX, y);
                ctx.lineTo(endX - arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                ctx.stroke();
            } else {
                // Outward arrows (><)
                ctx.beginPath();
                ctx.moveTo(startX - arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                ctx.lineTo(startX, y);
                ctx.lineTo(startX - arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(endX + arrowLen * Math.cos(angle), y - arrowLen * Math.sin(angle));
                ctx.lineTo(endX, y);
                ctx.lineTo(endX + arrowLen * Math.cos(angle), y + arrowLen * Math.sin(angle));
                ctx.stroke();
            }
        }

        function toggleIllusionView() {
            showIllusionView = !showIllusionView;
            document.getElementById('showIllusionBtn').classList.toggle('active', showIllusionView);
            drawComparison();
        }

        function togglePlainView() {
            showPlainView = !showPlainView;
            document.getElementById('showPlainBtn').classList.toggle('active', showPlainView);
            drawComparison();
        }

        function toggleOverlay() {
            showOverlay = !showOverlay;
            document.getElementById('showOverlayBtn').classList.toggle('active', showOverlay);
            drawComparison();
        }

        function toggleCompareAnimation() {
            compareAnimating = !compareAnimating;
            document.getElementById('animateCompareBtn').classList.toggle('active', compareAnimating);

            if (compareAnimating) {
                animateComparison();
            } else if (compareAnimationId) {
                cancelAnimationFrame(compareAnimationId);
                compareAnimationId = null;
            }
        }

        function animateComparison() {
            if (!compareAnimating) return;

            compareAnimPhase += 0.02;
            const alpha = (Math.sin(compareAnimPhase) + 1) / 2;

            comparisonCtx.fillStyle = '#0a0a15';
            comparisonCtx.fillRect(0, 0, comparisonCanvas.width, comparisonCanvas.height);

            const lineLen = 180;
            const arrowLen = 35;
            const angle = 30 * Math.PI / 180;
            const centerX = comparisonCanvas.width / 2;
            const y1 = 120;
            const y2 = 230;

            // Animate between with and without arrows
            comparisonCtx.globalAlpha = alpha;
            comparisonCtx.strokeStyle = '#ffffff';
            comparisonCtx.lineWidth = 3;
            comparisonCtx.lineCap = 'round';
            drawMullerLyerFigure(comparisonCtx, centerX, y1, lineLen, arrowLen, angle, 'inward');
            drawMullerLyerFigure(comparisonCtx, centerX, y2, lineLen, arrowLen, angle, 'outward');

            comparisonCtx.globalAlpha = 1 - alpha;
            comparisonCtx.strokeStyle = '#4ecdc4';
            comparisonCtx.lineWidth = 4;

            comparisonCtx.beginPath();
            comparisonCtx.moveTo(centerX - lineLen / 2, y1);
            comparisonCtx.lineTo(centerX + lineLen / 2, y1);
            comparisonCtx.stroke();

            comparisonCtx.beginPath();
            comparisonCtx.moveTo(centerX - lineLen / 2, y2);
            comparisonCtx.lineTo(centerX + lineLen / 2, y2);
            comparisonCtx.stroke();

            comparisonCtx.globalAlpha = 1;

            // Label
            comparisonCtx.fillStyle = '#a0a0a0';
            comparisonCtx.font = '14px Georgia';
            comparisonCtx.textAlign = 'center';
            comparisonCtx.fillText('Watch the lines - they never change length!', centerX, 320);

            compareAnimationId = requestAnimationFrame(animateComparison);
        }

        // ========== PERCEPTION STATISTICS ==========
        let perceptionStats = {
            totalTrials: 0,
            correctGuesses: 0,
            allErrors: [],
            bestAccuracy: null,
            gameResults: []
        };

        // Load saved stats from localStorage
        function loadStats() {
            const saved = localStorage.getItem('mullerLyerStats');
            if (saved) {
                try {
                    perceptionStats = JSON.parse(saved);
                } catch (e) {
                    console.error('Failed to load stats:', e);
                }
            }
        }

        function saveStats() {
            localStorage.setItem('mullerLyerStats', JSON.stringify(perceptionStats));
        }

        function updatePerceptionStats() {
            document.getElementById('totalTrials').textContent = perceptionStats.totalTrials;
            document.getElementById('correctGuesses').textContent = perceptionStats.correctGuesses;

            const avgError = perceptionStats.allErrors.length > 0
                ? Math.round(perceptionStats.allErrors.reduce((a, b) => a + b, 0) / perceptionStats.allErrors.length)
                : 0;
            document.getElementById('avgErrorStat').textContent = avgError + '%';

            document.getElementById('bestAccuracy').textContent = perceptionStats.bestAccuracy !== null
                ? perceptionStats.bestAccuracy + '%'
                : '--';

            // Calculate illusion resistance (inverse of average error, capped at 100%)
            const resistance = perceptionStats.allErrors.length > 0
                ? Math.max(0, Math.min(100, 100 - avgError * 4))
                : 50;
            document.getElementById('illusionResistance').textContent = Math.round(resistance) + '%';

            // Update accuracy bar
            document.getElementById('accuracyFill').style.width = resistance + '%';
            document.getElementById('accuracyText').textContent = Math.round(resistance) + '%';
        }

        function resetAllStats() {
            if (confirm('Reset all perception statistics? This cannot be undone.')) {
                perceptionStats = {
                    totalTrials: 0,
                    correctGuesses: 0,
                    allErrors: [],
                    bestAccuracy: null,
                    gameResults: []
                };
                saveStats();
                updatePerceptionStats();
            }
        }

        function exportStats() {
            const avgError = perceptionStats.allErrors.length > 0
                ? (perceptionStats.allErrors.reduce((a, b) => a + b, 0) / perceptionStats.allErrors.length).toFixed(2)
                : 'N/A';

            const statsText = `Muller-Lyer Illusion Perception Statistics
==========================================
Date: ${new Date().toLocaleString()}

Total Trials: ${perceptionStats.totalTrials}
Correct Guesses (within 5%): ${perceptionStats.correctGuesses}
Average Error: ${avgError}%
Best Accuracy: ${perceptionStats.bestAccuracy !== null ? perceptionStats.bestAccuracy + '%' : 'N/A'}

All Errors: ${perceptionStats.allErrors.join(', ')}%

Interpretation:
- 0-5% error: Excellent resistance to the illusion
- 5-15% error: Typical Western adult susceptibility
- 15-25% error: Strong susceptibility (common in children)
- 25%+ error: Very high susceptibility
`;

            const blob = new Blob([statsText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'muller-lyer-stats.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Hook into game to record stats
        const originalEndGame = endGame;
        endGame = function() {
            originalEndGame();

            // Record game results to stats
            const accuracy = Math.round(gameState.correct / 10 * 100);
            perceptionStats.totalTrials += 10;
            perceptionStats.correctGuesses += gameState.correct;
            perceptionStats.gameResults.push(accuracy);

            gameState.errors.forEach(e => perceptionStats.allErrors.push(e));

            const gameError = 100 - accuracy;
            if (perceptionStats.bestAccuracy === null || gameError < perceptionStats.bestAccuracy) {
                perceptionStats.bestAccuracy = gameError;
            }

            updatePerceptionStats();
            saveStats();
        };

        // Hook into checkAdjustment to record stats
        const originalCheckAdjustment = checkAdjustment;
        checkAdjustment = function() {
            originalCheckAdjustment();

            const error = Math.abs(adjustRatio - 100);
            perceptionStats.totalTrials++;
            perceptionStats.allErrors.push(error);
            if (error <= 5) {
                perceptionStats.correctGuesses++;
            }
            if (perceptionStats.bestAccuracy === null || error < perceptionStats.bestAccuracy) {
                perceptionStats.bestAccuracy = error;
            }
            updatePerceptionStats();
            saveStats();
        };

        // Initialize all canvases
        loadStats();
        drawClassicIllusion();
        drawAdjustIllusion();
        drawMeasurementTool();
        drawComparison();
        drawAngleExperiment();
        drawThicknessExperiment();
        drawVariants();
        updatePerceptionStats();

        // Initial game canvas
        gameCtx.fillStyle = '#0a0a15';
        gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
        gameCtx.fillStyle = '#a0a0a0';
        gameCtx.font = '20px Georgia';
        gameCtx.textAlign = 'center';
        gameCtx.fillText('Click "Start Game" to test your perception!', 400, 125);
    </script>
</body>
</html>
