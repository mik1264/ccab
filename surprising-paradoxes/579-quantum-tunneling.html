<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Tunneling: Walking Through Walls | Surprising Paradoxes</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #050a15 0%, #0a1525 50%, #050815 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #44ddaa;
            text-decoration: none;
            font-size: 1rem;
            z-index: 100;
            padding: 8px 16px;
            background: rgba(0,0,0,0.5);
            border-radius: 20px;
            transition: all 0.3s ease;
        }
        .back-link:hover {
            background: rgba(50, 200, 150, 0.2);
            transform: translateX(-3px);
        }
        header {
            text-align: center;
            padding: 80px 20px 30px;
        }
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #22cc88, #44ddaa, #88ffcc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle {
            color: #66aa88;
            font-size: 1.2rem;
            max-width: 700px;
            margin: 0 auto;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        .demo-section {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 30px;
            margin-bottom: 40px;
        }
        @media (max-width: 900px) {
            .demo-section {
                grid-template-columns: 1fr;
            }
        }
        .canvas-container {
            background: linear-gradient(145deg, #050a15, #0a1525);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(50,200,150,0.15);
        }
        canvas {
            display: block;
            width: 100%;
            border-radius: 10px;
        }
        .controls {
            background: linear-gradient(145deg, #081015, #0c1822);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(50,200,150,0.15);
        }
        .probability-display {
            text-align: center;
            padding: 15px;
            background: rgba(50, 200, 150, 0.15);
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .probability-display .prob {
            font-size: 2rem;
            font-weight: bold;
            color: #44ddaa;
            text-shadow: 0 0 15px rgba(50, 200, 150, 0.5);
        }
        .probability-display .label {
            font-size: 0.85rem;
            color: #66aa88;
            margin-top: 5px;
        }
        .info-panel {
            background: rgba(50, 150, 100, 0.12);
            border: 1px solid rgba(80, 200, 150, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .info-panel h3 {
            color: #44ddaa;
            font-size: 0.95rem;
            margin-bottom: 12px;
            border-bottom: 1px solid rgba(80, 200, 150, 0.2);
            padding-bottom: 8px;
        }
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }
        .info-label { color: #66aa88; }
        .info-value {
            color: #fff;
            font-family: 'Consolas', monospace;
        }
        .info-value.high { color: #44dd88; }
        .info-value.low { color: #ff8866; }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #44ddaa;
            font-size: 0.9rem;
        }
        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #0c1822;
            outline: none;
            -webkit-appearance: none;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #44ddaa, #22aa77);
            cursor: pointer;
        }
        .value-display {
            text-align: right;
            font-size: 0.85rem;
            color: #aaa;
            margin-top: 5px;
        }
        button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #22aa77, #118855);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }
        button:hover {
            background: linear-gradient(135deg, #44cc99, #22aa77);
            transform: translateY(-2px);
        }
        button.active {
            background: linear-gradient(135deg, #44ddaa, #33bb88);
            box-shadow: 0 0 15px rgba(50, 200, 150, 0.4);
        }
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        .comp-box {
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-size: 0.8rem;
        }
        .comp-box.classical {
            background: rgba(255, 100, 100, 0.15);
            border: 1px solid rgba(255, 100, 100, 0.3);
        }
        .comp-box.quantum {
            background: rgba(100, 255, 200, 0.15);
            border: 1px solid rgba(100, 255, 200, 0.3);
        }
        .comp-box .title { font-weight: bold; margin-bottom: 5px; }
        .comp-box.classical .title { color: #ff8888; }
        .comp-box.quantum .title { color: #88ffcc; }
        .essay {
            background: linear-gradient(145deg, #050a15, #0a1525);
            border-radius: 15px;
            padding: 40px;
            line-height: 1.8;
            box-shadow: 0 10px 40px rgba(50,200,150,0.15);
        }
        .essay h2 {
            color: #44ddaa;
            margin: 30px 0 15px;
            font-size: 1.5rem;
        }
        .essay h2:first-child { margin-top: 0; }
        .essay p {
            margin-bottom: 15px;
            color: #b0c8c0;
        }
        .essay strong { color: #88ffcc; }
        .essay em { color: #ffcc88; font-style: italic; }
        .highlight-box {
            background: rgba(50, 200, 150, 0.1);
            border-left: 4px solid #44ddaa;
            padding: 20px;
            margin: 25px 0;
            border-radius: 0 10px 10px 0;
        }
        .highlight-box.paradox {
            background: rgba(80, 220, 180, 0.08);
            border-left-color: #66ffbb;
        }
        .formula {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 20px 0;
            font-family: 'Times New Roman', serif;
            font-size: 1.3rem;
            color: #88ffcc;
        }
        .sources {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #1a2825;
        }
        .sources h3 {
            color: #66aa88;
            margin-bottom: 15px;
        }
        .sources ul {
            list-style: none;
        }
        .sources li {
            margin-bottom: 10px;
        }
        .sources a {
            color: #448866;
            text-decoration: none;
        }
        .sources a:hover {
            color: #66ffaa;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Paradoxes</a>

    <header>
        <h1>Quantum Tunneling</h1>
        <p class="subtitle">Particles pass through barriers they classically cannot surmount—the wave function doesn't care about walls</p>
    </header>

    <div class="container">
        <div class="demo-section">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
            </div>
            <div class="controls">
                <div class="probability-display">
                    <div class="prob" id="probValue">12.5%</div>
                    <div class="label">Transmission Probability</div>
                </div>

                <div class="comparison">
                    <div class="comp-box classical">
                        <div class="title">Classical</div>
                        <div>E &lt; U₀</div>
                        <div>→ 0% through</div>
                    </div>
                    <div class="comp-box quantum">
                        <div class="title">Quantum</div>
                        <div>E &lt; U₀</div>
                        <div>→ Still tunnels!</div>
                    </div>
                </div>

                <div class="info-panel">
                    <h3>Barrier Parameters</h3>
                    <div class="info-row">
                        <span class="info-label">Particle Energy (E)</span>
                        <span class="info-value" id="energyValue">5.0 eV</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Barrier Height (U₀)</span>
                        <span class="info-value" id="heightValue">8.0 eV</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Barrier Width (L)</span>
                        <span class="info-value" id="widthValue">0.5 nm</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Decay constant (κ)</span>
                        <span class="info-value" id="kappaValue">0.89 nm⁻¹</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Particle Energy (eV)</label>
                    <input type="range" id="energy" min="1" max="7" value="5" step="0.1">
                    <div class="value-display" id="energyDisplay">5.0 eV</div>
                </div>

                <div class="control-group">
                    <label>Barrier Height (eV)</label>
                    <input type="range" id="barrierHeight" min="5" max="15" value="8" step="0.5">
                    <div class="value-display" id="barrierDisplay">8.0 eV</div>
                </div>

                <div class="control-group">
                    <label>Barrier Width (nm)</label>
                    <input type="range" id="barrierWidth" min="0.1" max="2" value="0.5" step="0.1">
                    <div class="value-display" id="widthDisplay">0.5 nm</div>
                </div>

                <button id="sendParticle" class="active">Send Wave Packet</button>
                <button id="toggleView">Toggle: Wave Function / Probability</button>
            </div>
        </div>

        <div class="essay">
            <h2>The Classical Impossibility</h2>
            <p>
                Imagine rolling a ball toward a hill. If the ball doesn't have enough energy to
                reach the top, it rolls back—<strong>always</strong>. There's no "small chance"
                it appears on the other side. The energy constraint is absolute.
            </p>

            <div class="highlight-box paradox">
                <strong>Quantum Reality:</strong> In quantum mechanics, particles routinely
                appear on the other side of energy barriers they classically cannot surmount.
                The wave function doesn't stop at the barrier edge—it decays exponentially
                inside, and if the barrier is thin enough, a non-zero amplitude emerges beyond.
            </div>

            <h2>The Wave Function Solution</h2>
            <p>
                The Schrödinger equation describes how quantum states evolve. For a particle
                approaching a barrier higher than its energy, the solution in the barrier
                region is not oscillatory but <em>exponentially decaying</em>:
            </p>

            <div class="formula">
                ψ(x) ∝ e<sup>−κx</sup> where κ = √(2m(U₀−E))/ℏ
            </div>

            <p>
                The key insight: this decay doesn't mean "the particle stops." The wave function
                has continuous value and slope at the barrier boundaries. If the barrier is
                narrow, the decaying exponential hasn't reached zero before exiting—and an
                oscillatory solution continues on the far side.
            </p>

            <h2>Transmission Probability</h2>
            <p>
                The probability of tunneling depends exponentially on the barrier width and
                the decay constant κ (which depends on how much the barrier exceeds the
                particle's energy):
            </p>

            <div class="formula">
                T ≈ e<sup>−2κL</sup>
            </div>

            <p>
                A slight increase in barrier width causes dramatic decrease in transmission.
                This <strong>exponential sensitivity</strong> is crucial: tunneling is
                significant only for atomic-scale barriers or light particles like electrons.
            </p>

            <div class="highlight-box">
                <strong>Historical First:</strong> In 1928, George Gamow used quantum tunneling
                to explain alpha decay of radioactive nuclei. Alpha particles (helium nuclei)
                escape atomic nuclei despite being trapped by the strong nuclear force—they
                tunnel through the Coulomb barrier. This explained why decay rates varied so
                dramatically between isotopes.
            </div>

            <h2>Real-World Manifestations</h2>
            <p>
                <strong>Radioactive decay:</strong> Alpha decay is pure tunneling. The alpha
                particle bounces around inside the nucleus billions of times per second, each
                time having a tiny probability of tunneling out. Decay half-lives range from
                nanoseconds to billions of years—all determined by barrier geometry.
            </p>
            <p>
                <strong>Nuclear fusion in stars:</strong> The Sun fuses hydrogen despite
                temperatures far below what classical physics requires. Protons tunnel through
                their mutual Coulomb repulsion. Without tunneling, stars wouldn't shine.
            </p>
            <p>
                <strong>Scanning Tunneling Microscope (STM):</strong> A sharp metal tip is
                brought within nanometers of a surface. Electrons tunnel between tip and
                surface, creating a current exquisitely sensitive to distance. This allows
                imaging individual atoms—Nobel Prize 1986.
            </p>
            <p>
                <strong>Flash memory:</strong> Your USB drive stores data using quantum
                tunneling. Electrons are forced to tunnel through thin oxide barriers onto
                floating gates, where they're trapped for years, representing stored bits.
            </p>

            <h2>The Time Question</h2>
            <p>
                How long does tunneling take? This question has generated decades of debate.
                Experiments suggest tunneling can occur in less time than it would take light
                to cross the barrier—but this doesn't violate relativity. The particle's
                wave function was already present on both sides; the "tunneling time" doesn't
                correspond to a particle moving through space.
            </p>

            <h2>Macroscopic Tunneling?</h2>
            <p>
                Could you tunnel through a wall? Technically, there's a non-zero probability.
                Practically, for a human-sized object and a meter-thick wall, that probability
                is roughly 10<sup>−10^30</sup>—a number so small it's meaningless. You'd wait
                longer than the age of the universe raised to the power of the age of the
                universe. Quantum tunneling is strictly a nanoscale phenomenon.
            </p>

            <div class="sources">
                <h3>Sources & Further Reading</h3>
                <ul>
                    <li><a href="https://en.wikipedia.org/wiki/Quantum_tunnelling">Wikipedia: Quantum Tunnelling</a></li>
                    <li><a href="https://phys.libretexts.org/Bookshelves/University_Physics/University_Physics_(OpenStax)/University_Physics_III_-_Optics_and_Modern_Physics_(OpenStax)/07:_Quantum_Mechanics/7.07:_Quantum_Tunneling_of_Particles_through_Potential_Barriers">Physics LibreTexts: Quantum Tunneling</a></li>
                    <li><a href="http://hyperphysics.phy-astr.gsu.edu/hbase/quantum/barr.html">HyperPhysics: Barrier Penetration</a></li>
                    <li><a href="https://brilliant.org/wiki/quantum-tunneling/">Brilliant: Quantum Tunneling</a></li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // High DPI setup
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.width * 0.6 * dpr;
        canvas.style.height = rect.width * 0.6 + 'px';
        ctx.scale(dpr, dpr);

        const width = rect.width;
        const height = rect.width * 0.6;

        // State
        let time = 0;
        let particleEnergy = 5.0; // eV
        let barrierHeight = 8.0; // eV
        let barrierWidth = 0.5; // nm
        let showProbability = false;
        let wavePacketX = -100;
        let wavePacketActive = false;

        // Scale factors for display
        const xScale = width / 4; // nm to pixels
        const barrierLeft = width * 0.4;

        // Controls
        const energySlider = document.getElementById('energy');
        const heightSlider = document.getElementById('barrierHeight');
        const widthSlider = document.getElementById('barrierWidth');
        const sendBtn = document.getElementById('sendParticle');
        const toggleBtn = document.getElementById('toggleView');

        energySlider.addEventListener('input', e => {
            particleEnergy = parseFloat(e.target.value);
            document.getElementById('energyDisplay').textContent = particleEnergy.toFixed(1) + ' eV';
            updatePhysics();
        });

        heightSlider.addEventListener('input', e => {
            barrierHeight = parseFloat(e.target.value);
            document.getElementById('barrierDisplay').textContent = barrierHeight.toFixed(1) + ' eV';
            updatePhysics();
        });

        widthSlider.addEventListener('input', e => {
            barrierWidth = parseFloat(e.target.value);
            document.getElementById('widthDisplay').textContent = barrierWidth.toFixed(1) + ' nm';
            updatePhysics();
        });

        sendBtn.addEventListener('click', () => {
            wavePacketX = 0;
            wavePacketActive = true;
        });

        toggleBtn.addEventListener('click', () => {
            showProbability = !showProbability;
            toggleBtn.classList.toggle('active', showProbability);
        });

        function updatePhysics() {
            // Calculate decay constant kappa (in nm^-1)
            // κ = sqrt(2m(U-E)) / ℏ
            // Using electron mass and converting eV to Joules
            const U_minus_E = barrierHeight - particleEnergy;
            const kappa = U_minus_E > 0 ? 5.12 * Math.sqrt(U_minus_E) : 0; // nm^-1 for electron

            document.getElementById('energyValue').textContent = particleEnergy.toFixed(1) + ' eV';
            document.getElementById('heightValue').textContent = barrierHeight.toFixed(1) + ' eV';
            document.getElementById('widthValue').textContent = barrierWidth.toFixed(1) + ' nm';
            document.getElementById('kappaValue').textContent = kappa.toFixed(2) + ' nm⁻¹';

            // Transmission probability T ≈ exp(-2κL)
            let T;
            if (particleEnergy >= barrierHeight) {
                T = 1.0; // Classical transmission
            } else {
                T = Math.exp(-2 * kappa * barrierWidth);
            }

            const probEl = document.getElementById('probValue');
            if (T > 0.99) {
                probEl.textContent = '~100%';
                probEl.className = 'prob';
            } else if (T < 0.0001) {
                probEl.textContent = '<0.01%';
                probEl.className = 'prob';
            } else {
                probEl.textContent = (T * 100).toFixed(2) + '%';
                probEl.className = 'prob';
            }

            return { kappa, T };
        }

        function drawPotentialBarrier() {
            const barrierPixelWidth = barrierWidth * xScale;
            const potentialHeight = height * 0.6;
            const baseY = height * 0.75;

            // Background gradient
            ctx.fillStyle = '#050a15';
            ctx.fillRect(0, 0, width, height);

            // Draw zero potential line
            ctx.strokeStyle = 'rgba(100, 200, 150, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, baseY);
            ctx.lineTo(width, baseY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw barrier
            const barrierPixelHeight = (barrierHeight / 15) * potentialHeight;
            const barrierY = baseY - barrierPixelHeight;

            const barrierGrad = ctx.createLinearGradient(
                barrierLeft, barrierY,
                barrierLeft, baseY
            );
            barrierGrad.addColorStop(0, 'rgba(200, 100, 100, 0.6)');
            barrierGrad.addColorStop(1, 'rgba(150, 50, 50, 0.4)');

            ctx.fillStyle = barrierGrad;
            ctx.fillRect(barrierLeft, barrierY, barrierPixelWidth, barrierPixelHeight);

            ctx.strokeStyle = 'rgba(255, 100, 100, 0.8)';
            ctx.lineWidth = 2;
            ctx.strokeRect(barrierLeft, barrierY, barrierPixelWidth, barrierPixelHeight);

            // Draw energy level
            const energyPixelHeight = (particleEnergy / 15) * potentialHeight;
            const energyY = baseY - energyPixelHeight;

            ctx.strokeStyle = 'rgba(100, 255, 200, 0.8)';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.moveTo(0, energyY);
            ctx.lineTo(width, energyY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Labels
            ctx.fillStyle = '#ff8888';
            ctx.font = '12px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText('U₀ = ' + barrierHeight.toFixed(1) + ' eV', barrierLeft + barrierPixelWidth / 2, barrierY - 10);
            ctx.fillText('Barrier', barrierLeft + barrierPixelWidth / 2, baseY + 20);

            ctx.fillStyle = '#88ffcc';
            ctx.textAlign = 'left';
            ctx.fillText('E = ' + particleEnergy.toFixed(1) + ' eV', 10, energyY - 5);

            ctx.fillStyle = '#666';
            ctx.fillText('Region I', 50, baseY + 40);
            ctx.fillText('Region II', barrierLeft + barrierPixelWidth / 2 - 30, baseY + 40);
            ctx.fillText('Region III', barrierLeft + barrierPixelWidth + 50, baseY + 40);

            return { barrierLeft, barrierPixelWidth, baseY, energyY, barrierY };
        }

        function drawWaveFunction(barrier) {
            const { kappa, T } = updatePhysics();
            const { barrierLeft, barrierPixelWidth, baseY, energyY } = barrier;

            const k = 2 * Math.PI / 30; // Wave number in region I/III
            const amplitude = 40;
            const barrierRight = barrierLeft + barrierPixelWidth;

            ctx.lineWidth = 2;

            // Region I: Incident + reflected wave
            ctx.strokeStyle = showProbability ? 'rgba(100, 255, 200, 0.8)' : 'rgba(100, 200, 255, 0.8)';
            ctx.beginPath();

            for (let x = 0; x < barrierLeft; x++) {
                let y;
                if (showProbability) {
                    // |ψ|² - standing wave pattern due to reflection
                    const R = 1 - T;
                    y = energyY - amplitude * (1 + R - 2 * Math.sqrt(R) * Math.cos(2 * k * (x - barrierLeft) + time * 0.1));
                } else {
                    // Real part of ψ
                    y = energyY + amplitude * Math.sin(k * x - time * 0.1);
                }
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Region II: Exponential decay (if E < U)
            if (particleEnergy < barrierHeight && kappa > 0) {
                ctx.strokeStyle = showProbability ? 'rgba(255, 200, 100, 0.8)' : 'rgba(255, 150, 100, 0.8)';
                ctx.beginPath();

                const decayScale = kappa * xScale / 5; // Scale for visualization

                for (let x = barrierLeft; x < barrierRight; x++) {
                    const relX = x - barrierLeft;
                    const decay = Math.exp(-decayScale * relX / xScale);
                    let y;
                    if (showProbability) {
                        y = energyY - amplitude * decay * decay;
                    } else {
                        y = energyY + amplitude * decay * Math.cos(time * 0.1);
                    }
                    if (x === barrierLeft) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // Region III: Transmitted wave
            if (T > 0.001) {
                ctx.strokeStyle = showProbability ? 'rgba(100, 255, 150, 0.8)' : 'rgba(150, 255, 200, 0.8)';
                ctx.beginPath();

                const transmittedAmplitude = amplitude * Math.sqrt(T);

                for (let x = barrierRight; x < width; x++) {
                    const relX = x - barrierRight;
                    let y;
                    if (showProbability) {
                        y = energyY - transmittedAmplitude * transmittedAmplitude / amplitude;
                    } else {
                        y = energyY + transmittedAmplitude * Math.sin(k * relX - time * 0.1);
                    }
                    if (x === barrierRight) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Transmitted wave indicator
                ctx.fillStyle = 'rgba(100, 255, 150, 0.5)';
                ctx.font = '11px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('Tunneled!', barrierRight + 60, energyY - 50);
                ctx.fillText('T = ' + (T * 100).toFixed(2) + '%', barrierRight + 60, energyY - 35);
            }

            // Legend
            ctx.fillStyle = '#88ccff';
            ctx.font = '12px Segoe UI';
            ctx.textAlign = 'left';
            ctx.fillText(showProbability ? '|ψ|² (Probability density)' : 'Re(ψ) (Wave function)', 10, 25);
        }

        function drawWavePacket(barrier) {
            if (!wavePacketActive) return;

            const { T } = updatePhysics();
            const { barrierLeft, barrierPixelWidth, energyY } = barrier;
            const barrierRight = barrierLeft + barrierPixelWidth;

            // Wave packet parameters
            const packetWidth = 40;

            // Main packet
            if (wavePacketX < barrierLeft) {
                // Approaching barrier
                const gradient = ctx.createRadialGradient(
                    wavePacketX, energyY, 0,
                    wavePacketX, energyY, packetWidth
                );
                gradient.addColorStop(0, 'rgba(100, 255, 200, 0.8)');
                gradient.addColorStop(0.5, 'rgba(100, 255, 200, 0.4)');
                gradient.addColorStop(1, 'rgba(100, 255, 200, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(wavePacketX, energyY, packetWidth, 0, Math.PI * 2);
                ctx.fill();
            } else if (wavePacketX >= barrierLeft && wavePacketX < barrierRight) {
                // Inside barrier - decaying
                const relX = wavePacketX - barrierLeft;
                const progress = relX / barrierPixelWidth;
                const decayedSize = packetWidth * Math.exp(-progress * 2);

                const gradient = ctx.createRadialGradient(
                    wavePacketX, energyY, 0,
                    wavePacketX, energyY, decayedSize
                );
                gradient.addColorStop(0, 'rgba(255, 180, 100, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 180, 100, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(wavePacketX, energyY, decayedSize, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Beyond barrier - split into transmitted and reflected
                if (Math.random() < T) {
                    // Show transmitted packet
                    const gradient = ctx.createRadialGradient(
                        wavePacketX, energyY, 0,
                        wavePacketX, energyY, packetWidth * Math.sqrt(T)
                    );
                    gradient.addColorStop(0, 'rgba(100, 255, 180, 0.8)');
                    gradient.addColorStop(1, 'rgba(100, 255, 180, 0)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(wavePacketX, energyY, packetWidth * Math.sqrt(T), 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Update position
            wavePacketX += 3;
            if (wavePacketX > width + 50) {
                wavePacketActive = false;
            }
        }

        function animate() {
            const barrier = drawPotentialBarrier();
            drawWaveFunction(barrier);
            drawWavePacket(barrier);

            time++;
            requestAnimationFrame(animate);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.width * 0.6 * dpr;
            canvas.style.height = rect.width * 0.6 + 'px';
            ctx.scale(dpr, dpr);
        });

        updatePhysics();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
