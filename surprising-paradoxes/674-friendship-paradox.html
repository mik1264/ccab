<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>674 - The Friendship Paradox | Surprising Paradoxes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e8e8e8;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            padding: 20px 0 30px;
        }

        h1 {
            font-size: 2.4rem;
            background: linear-gradient(135deg, #e056fd 0%, #686de0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.1rem;
            color: #a8a8a8;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .main-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 1.4rem;
            color: #e056fd;
            margin-bottom: 20px;
            text-align: center;
        }

        .network-area {
            display: flex;
            gap: 25px;
            flex-wrap: wrap;
        }

        .canvas-container {
            flex: 2;
            min-width: 400px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 15px;
        }

        canvas {
            display: block;
            margin: 0 auto;
            cursor: pointer;
            border-radius: 8px;
        }

        .info-panel {
            flex: 1;
            min-width: 280px;
        }

        .stats-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .stats-card h3 {
            color: #e056fd;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #a8a8a8;
        }

        .stat-value {
            font-weight: bold;
            color: #fff;
        }

        .stat-value.highlight {
            color: #e056fd;
            font-size: 1.2rem;
        }

        .selected-node {
            background: linear-gradient(135deg, rgba(224, 86, 253, 0.2), rgba(104, 109, 224, 0.1));
            border: 1px solid #e056fd;
        }

        .comparison {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 15px 0;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .comparison-item {
            text-align: center;
        }

        .comparison-value {
            font-size: 2rem;
            font-weight: bold;
        }

        .comparison-value.you { color: #686de0; }
        .comparison-value.friends { color: #e056fd; }

        .comparison-label {
            font-size: 0.9rem;
            color: #a8a8a8;
        }

        .vs {
            font-size: 1.5rem;
            color: #666;
        }

        .paradox-indicator {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-weight: bold;
        }

        .paradox-indicator.true {
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
        }

        .paradox-indicator.false {
            background: rgba(82, 183, 136, 0.2);
            color: #52b788;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            font-size: 0.95rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #e056fd, #686de0);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(224, 86, 253, 0.4);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #e8e8e8;
            border: 2px solid #686de0;
        }

        .btn-secondary:hover {
            background: rgba(104, 109, 224, 0.2);
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0,0,0,0.2);
            padding: 10px 15px;
            border-radius: 8px;
        }

        .slider-group label {
            color: #a8a8a8;
            font-size: 0.9rem;
            white-space: nowrap;
        }

        .slider-group input[type="range"] {
            width: 120px;
            accent-color: #e056fd;
        }

        .explanation {
            background: linear-gradient(135deg, rgba(224, 86, 253, 0.1), rgba(104, 109, 224, 0.05));
            border-left: 4px solid #e056fd;
            padding: 20px;
            border-radius: 0 10px 10px 0;
            margin: 20px 0;
        }

        .explanation h3 {
            color: #e056fd;
            margin-bottom: 10px;
        }

        .explanation p {
            color: #ccc;
            line-height: 1.7;
        }

        .formula-box {
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: center;
        }

        .formula {
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            color: #e056fd;
        }

        .network-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .network-stat {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .network-stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #e056fd;
        }

        .network-stat-label {
            font-size: 0.85rem;
            color: #a8a8a8;
            margin-top: 5px;
        }

        .histogram {
            display: flex;
            align-items: flex-end;
            height: 100px;
            gap: 3px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            margin-top: 15px;
        }

        .hist-bar {
            flex: 1;
            background: linear-gradient(180deg, #e056fd, #686de0);
            border-radius: 3px 3px 0 0;
            transition: height 0.3s ease;
            position: relative;
        }

        .hist-bar:hover::after {
            content: attr(data-count);
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            color: #fff;
        }

        .applications {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .app-card {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 20px;
        }

        .app-card h4 {
            color: #686de0;
            margin-bottom: 10px;
        }

        .app-card p {
            color: #a8a8a8;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #e056fd;
            text-decoration: none;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 100;
            background: rgba(0,0,0,0.5);
            padding: 8px 15px;
            border-radius: 20px;
        }

        .back-link:hover {
            background: rgba(224, 86, 253, 0.2);
        }

        .instructions {
            text-align: center;
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 15px;
        }

        @media (max-width: 768px) {
            h1 { font-size: 1.8rem; }
            .canvas-container { min-width: 100%; }
            .network-stats { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>The Friendship Paradox</h1>
            <p class="subtitle">On average, your friends have more friends than you do.
            This isn't your imagination ‚Äî it's a mathematical certainty discovered by Scott Feld in 1991.
            It explains why social media makes everyone feel inadequate!</p>
        </header>

        <div class="main-section">
            <div class="section-title">Interactive Social Network</div>
            <p class="instructions">Click on any person (node) to see the paradox in action!</p>

            <div class="controls">
                <div class="slider-group">
                    <label>People: <span id="node-count">30</span></label>
                    <input type="range" id="nodes-slider" min="15" max="60" value="30" oninput="updateNodeCount()">
                </div>
                <div class="slider-group">
                    <label>Connections: <span id="edge-density">Medium</span></label>
                    <input type="range" id="density-slider" min="1" max="3" value="2" oninput="updateDensity()">
                </div>
                <button class="btn btn-primary" onclick="generateNetwork()">New Network</button>
                <button class="btn btn-secondary" onclick="runFullAnalysis()">Analyze All</button>
            </div>

            <div class="network-area">
                <div class="canvas-container">
                    <canvas id="network-canvas" width="550" height="400"></canvas>
                </div>

                <div class="info-panel">
                    <div class="stats-card selected-node" id="node-info" style="display: none;">
                        <h3>Selected: <span id="selected-name">Person</span></h3>
                        <div class="comparison">
                            <div class="comparison-item">
                                <div class="comparison-value you" id="your-friends">-</div>
                                <div class="comparison-label">Your Friends</div>
                            </div>
                            <div class="vs">vs</div>
                            <div class="comparison-item">
                                <div class="comparison-value friends" id="friends-avg">-</div>
                                <div class="comparison-label">Friends' Average</div>
                            </div>
                        </div>
                        <div class="paradox-indicator" id="paradox-status">
                            Click a node to see the paradox
                        </div>
                    </div>

                    <div class="stats-card">
                        <h3>Network Statistics</h3>
                        <div class="stat-row">
                            <span class="stat-label">Total People</span>
                            <span class="stat-value" id="total-nodes">30</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Total Friendships</span>
                            <span class="stat-value" id="total-edges">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Avg Friends/Person</span>
                            <span class="stat-value" id="avg-degree">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Paradox Victims</span>
                            <span class="stat-value highlight" id="paradox-pct">0%</span>
                        </div>
                    </div>

                    <div class="stats-card">
                        <h3>Friend Count Distribution</h3>
                        <div class="histogram" id="histogram"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="explanation">
            <h3>Why Does This Happen?</h3>
            <p><strong>Sampling Bias:</strong> Popular people appear in MORE friend lists.
            If Alice has 100 friends, she shows up in 100 people's "friends of friends" calculation.
            If Bob has 2 friends, he only shows up twice.<br><br>
            When you calculate "average friends of my friends," the popular people are
            <em>over-represented</em> because they're more likely to BE your friend in the first place!<br><br>
            <strong>Mathematical Proof:</strong> The average degree of a random neighbor equals
            the average degree PLUS the variance divided by the average. Since variance is always ‚â• 0,
            your friends' average is always ‚â• your network's average.</p>
        </div>

        <div class="formula-box">
            <div class="formula">E[neighbor's degree] = E[degree] + Var[degree] / E[degree]</div>
            <p style="color: #888; margin-top: 10px; font-size: 0.9rem;">
                Since variance ‚â• 0, your friends always have at least as many friends as the network average
            </p>
        </div>

        <div class="main-section">
            <div class="section-title">Real-World Applications</div>

            <div class="applications">
                <div class="app-card">
                    <h4>ü¶† Epidemic Detection</h4>
                    <p>Christakis & Fowler (2010) used the paradox to detect flu outbreaks
                    2 weeks earlier than traditional surveillance by monitoring friends of random people.</p>
                </div>
                <div class="app-card">
                    <h4>üì± Social Media Anxiety</h4>
                    <p>On Instagram/Facebook, you see the highlight reels of your most connected friends,
                    making everyone seem more popular and successful than they really are.</p>
                </div>
                <div class="app-card">
                    <h4>üó≥Ô∏è Election Forecasting</h4>
                    <p>Pollsters can reach well-connected "information hubs" by asking random people
                    to nominate friends, improving prediction accuracy.</p>
                </div>
                <div class="app-card">
                    <h4>üíâ Vaccination Strategy</h4>
                    <p>To slow pandemics, vaccinate friends of random people instead of random people
                    directly ‚Äî you'll reach super-spreaders more efficiently!</p>
                </div>
            </div>
        </div>

        <div class="explanation">
            <h3>The Generalized Friendship Paradox</h3>
            <p>It's not just friends! On average, your friends are also:<br><br>
            ‚Ä¢ <strong>Richer</strong> than you (wealth correlates with connections)<br>
            ‚Ä¢ <strong>More attractive</strong> (attractive people have more social ties)<br>
            ‚Ä¢ <strong>Happier</strong> on social media (selection bias in what gets posted)<br>
            ‚Ä¢ <strong>More sexually active</strong> (same network sampling effect)<br><br>
            This is why comparison on social media is so toxic ‚Äî you're not comparing yourself
            to average people, but to a biased sample of the most connected individuals!</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('network-canvas');
        const ctx = canvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let selectedNode = null;
        let numNodes = 30;
        let density = 2;

        function generateNetwork() {
            nodes = [];
            edges = [];
            selectedNode = null;

            // Create nodes with random positions
            for (let i = 0; i < numNodes; i++) {
                nodes.push({
                    id: i,
                    x: 50 + Math.random() * (canvas.width - 100),
                    y: 50 + Math.random() * (canvas.height - 100),
                    vx: 0,
                    vy: 0,
                    friends: []
                });
            }

            // Create edges using preferential attachment (rich get richer)
            const edgeCount = Math.floor(numNodes * density);
            for (let e = 0; e < edgeCount; e++) {
                // Source: random node
                const i = Math.floor(Math.random() * numNodes);

                // Target: preferential attachment (more likely to connect to popular nodes)
                let j;
                if (Math.random() < 0.7 && edges.length > 0) {
                    // Pick a random existing edge and connect to one of its endpoints
                    const randomEdge = edges[Math.floor(Math.random() * edges.length)];
                    j = Math.random() < 0.5 ? randomEdge.source : randomEdge.target;
                } else {
                    j = Math.floor(Math.random() * numNodes);
                }

                if (i !== j && !nodes[i].friends.includes(j)) {
                    nodes[i].friends.push(j);
                    nodes[j].friends.push(i);
                    edges.push({ source: i, target: j });
                }
            }

            // Add some guaranteed "hub" nodes
            const hubCount = Math.floor(numNodes / 10);
            for (let h = 0; h < hubCount; h++) {
                const hub = Math.floor(Math.random() * numNodes);
                const connections = 5 + Math.floor(Math.random() * 10);
                for (let c = 0; c < connections; c++) {
                    const target = Math.floor(Math.random() * numNodes);
                    if (hub !== target && !nodes[hub].friends.includes(target)) {
                        nodes[hub].friends.push(target);
                        nodes[target].friends.push(hub);
                        edges.push({ source: hub, target: target });
                    }
                }
            }

            applyForceLayout();
            updateStats();
            drawNetwork();
            document.getElementById('node-info').style.display = 'none';
        }

        function applyForceLayout() {
            // Simple force-directed layout
            for (let iter = 0; iter < 100; iter++) {
                // Repulsion between all nodes
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const dx = nodes[j].x - nodes[i].x;
                        const dy = nodes[j].y - nodes[i].y;
                        const dist = Math.sqrt(dx * dx + dy * dy) + 1;
                        const force = 500 / (dist * dist);
                        nodes[i].vx -= dx / dist * force;
                        nodes[i].vy -= dy / dist * force;
                        nodes[j].vx += dx / dist * force;
                        nodes[j].vy += dy / dist * force;
                    }
                }

                // Attraction along edges
                edges.forEach(edge => {
                    const ni = nodes[edge.source];
                    const nj = nodes[edge.target];
                    const dx = nj.x - ni.x;
                    const dy = nj.y - ni.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) + 1;
                    const force = dist * 0.01;
                    ni.vx += dx / dist * force;
                    ni.vy += dy / dist * force;
                    nj.vx -= dx / dist * force;
                    nj.vy -= dy / dist * force;
                });

                // Apply velocities
                nodes.forEach(node => {
                    node.x += node.vx * 0.1;
                    node.y += node.vy * 0.1;
                    node.vx *= 0.9;
                    node.vy *= 0.9;

                    // Keep in bounds
                    node.x = Math.max(30, Math.min(canvas.width - 30, node.x));
                    node.y = Math.max(30, Math.min(canvas.height - 30, node.y));
                });
            }
        }

        function drawNetwork() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw edges
            ctx.strokeStyle = 'rgba(150, 150, 180, 0.3)';
            ctx.lineWidth = 1;
            edges.forEach(edge => {
                const ni = nodes[edge.source];
                const nj = nodes[edge.target];

                // Highlight edges of selected node
                if (selectedNode !== null &&
                    (edge.source === selectedNode || edge.target === selectedNode)) {
                    ctx.strokeStyle = 'rgba(224, 86, 253, 0.6)';
                    ctx.lineWidth = 2;
                } else {
                    ctx.strokeStyle = 'rgba(150, 150, 180, 0.3)';
                    ctx.lineWidth = 1;
                }

                ctx.beginPath();
                ctx.moveTo(ni.x, ni.y);
                ctx.lineTo(nj.x, nj.y);
                ctx.stroke();
            });

            // Draw nodes
            nodes.forEach((node, i) => {
                const friendCount = node.friends.length;
                const radius = 6 + friendCount * 0.8;

                // Determine color
                let color = '#686de0';
                if (selectedNode === i) {
                    color = '#e056fd';
                } else if (selectedNode !== null && nodes[selectedNode].friends.includes(i)) {
                    color = '#a29bfe';
                }

                ctx.beginPath();
                ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw friend count
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                if (friendCount > 0) {
                    ctx.fillText(friendCount, node.x, node.y);
                }
            });
        }

        function selectNode(index) {
            selectedNode = index;
            const node = nodes[index];

            document.getElementById('node-info').style.display = 'block';
            document.getElementById('selected-name').textContent = `Person #${index + 1}`;

            const yourFriends = node.friends.length;
            document.getElementById('your-friends').textContent = yourFriends;

            // Calculate friends' average
            let friendsTotal = 0;
            node.friends.forEach(friendId => {
                friendsTotal += nodes[friendId].friends.length;
            });
            const friendsAvg = yourFriends > 0 ? (friendsTotal / yourFriends).toFixed(1) : 0;
            document.getElementById('friends-avg').textContent = friendsAvg;

            // Update paradox indicator
            const indicator = document.getElementById('paradox-status');
            if (yourFriends < parseFloat(friendsAvg)) {
                indicator.className = 'paradox-indicator true';
                indicator.textContent = `üòî PARADOX! Your ${yourFriends} friends have ${friendsAvg} friends on average`;
            } else {
                indicator.className = 'paradox-indicator false';
                indicator.textContent = `üéâ Lucky! You have more friends than your friends' average`;
            }

            drawNetwork();
        }

        function updateStats() {
            document.getElementById('total-nodes').textContent = nodes.length;
            document.getElementById('total-edges').textContent = edges.length;

            const totalDegree = nodes.reduce((sum, n) => sum + n.friends.length, 0);
            const avgDegree = (totalDegree / nodes.length).toFixed(1);
            document.getElementById('avg-degree').textContent = avgDegree;

            // Calculate paradox percentage
            let paradoxCount = 0;
            nodes.forEach(node => {
                if (node.friends.length === 0) return;
                let friendsTotal = 0;
                node.friends.forEach(fid => friendsTotal += nodes[fid].friends.length);
                const friendsAvg = friendsTotal / node.friends.length;
                if (node.friends.length < friendsAvg) paradoxCount++;
            });
            const paradoxPct = ((paradoxCount / nodes.length) * 100).toFixed(0);
            document.getElementById('paradox-pct').textContent = paradoxPct + '%';

            // Update histogram
            updateHistogram();
        }

        function updateHistogram() {
            const histogram = document.getElementById('histogram');
            histogram.innerHTML = '';

            const maxDegree = Math.max(...nodes.map(n => n.friends.length));
            const counts = new Array(maxDegree + 1).fill(0);
            nodes.forEach(n => counts[n.friends.length]++);

            const maxCount = Math.max(...counts);

            for (let d = 0; d <= maxDegree; d++) {
                const bar = document.createElement('div');
                bar.className = 'hist-bar';
                bar.style.height = (counts[d] / maxCount * 80) + 'px';
                bar.setAttribute('data-count', `${d}: ${counts[d]}`);
                histogram.appendChild(bar);
            }
        }

        function runFullAnalysis() {
            let results = [];
            nodes.forEach((node, i) => {
                if (node.friends.length === 0) return;
                let friendsTotal = 0;
                node.friends.forEach(fid => friendsTotal += nodes[fid].friends.length);
                const friendsAvg = friendsTotal / node.friends.length;
                results.push({
                    id: i,
                    yourFriends: node.friends.length,
                    friendsAvg: friendsAvg,
                    paradox: node.friends.length < friendsAvg
                });
            });

            const paradoxCount = results.filter(r => r.paradox).length;
            alert(`Analysis Complete!\n\n` +
                  `${paradoxCount} out of ${results.length} people (${(paradoxCount/results.length*100).toFixed(0)}%) ` +
                  `experience the friendship paradox.\n\n` +
                  `This confirms: on average, your friends have more friends than you!`);
        }

        function updateNodeCount() {
            numNodes = parseInt(document.getElementById('nodes-slider').value);
            document.getElementById('node-count').textContent = numNodes;
        }

        function updateDensity() {
            density = parseInt(document.getElementById('density-slider').value);
            const labels = ['Sparse', 'Medium', 'Dense'];
            document.getElementById('edge-density').textContent = labels[density - 1];
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Find clicked node
            for (let i = 0; i < nodes.length; i++) {
                const dx = nodes[i].x - x;
                const dy = nodes[i].y - y;
                const radius = 6 + nodes[i].friends.length * 0.8;
                if (dx * dx + dy * dy < radius * radius) {
                    selectNode(i);
                    return;
                }
            }
        });

        // Initialize
        generateNetwork();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
