<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Counterfactual Quantum Communication - Messages Without Particles</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #0a1a2e 50%, #1a0a1a 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 0;
            border-bottom: 1px solid rgba(64, 150, 200, 0.3);
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.4em;
            background: linear-gradient(135deg, #4096c8, #c84096);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2em;
            color: #888;
            font-style: italic;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        @media (max-width: 1000px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .visualization-section {
            background: rgba(20, 30, 40, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(64, 150, 200, 0.3);
        }

        canvas {
            width: 100%;
            border-radius: 10px;
            background: #050810;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        button {
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            border: none;
            border-radius: 25px;
            background: linear-gradient(135deg, #4096c8, #306090);
            color: white;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(64, 150, 200, 0.4);
        }

        button.active {
            background: linear-gradient(135deg, #c84096, #902060);
        }

        .message-input {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .bit-btn {
            padding: 8px 20px;
            font-size: 16px;
            font-weight: bold;
            background: rgba(64, 150, 200, 0.2);
            border: 1px solid rgba(64, 150, 200, 0.3);
        }

        .bit-btn.selected {
            background: linear-gradient(135deg, #4096c8, #306090);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-label {
            font-size: 10px;
            color: #888;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 16px;
            font-weight: bold;
            color: #4096c8;
        }

        .success-box {
            background: linear-gradient(135deg, rgba(100, 200, 150, 0.2), rgba(50, 150, 100, 0.3));
            border: 1px solid rgba(100, 200, 150, 0.5);
        }

        .success-box .stat-value {
            color: #64c896;
        }

        .message-display {
            text-align: center;
            padding: 15px;
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .message-bits {
            font-family: 'Courier New', monospace;
            font-size: 20px;
            letter-spacing: 5px;
            margin-top: 5px;
        }

        .essay-section {
            background: rgba(20, 30, 40, 0.6);
            border-radius: 15px;
            padding: 30px;
            border: 1px solid rgba(64, 150, 200, 0.2);
            max-height: 800px;
            overflow-y: auto;
        }

        .essay-section h2 {
            color: #4096c8;
            margin: 25px 0 15px 0;
            font-size: 1.4em;
        }

        .essay-section h2:first-child {
            margin-top: 0;
        }

        .essay-section p {
            line-height: 1.8;
            margin-bottom: 15px;
            text-align: justify;
        }

        .equation {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
            font-size: 14px;
            overflow-x: auto;
        }

        .highlight {
            color: #64c8ff;
            font-weight: bold;
        }

        .warning {
            color: #ff8866;
            font-weight: bold;
        }

        .diagram {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.4;
            white-space: pre;
            overflow-x: auto;
        }

        .sources {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(64, 150, 200, 0.3);
            font-size: 0.9em;
        }

        .sources h3 {
            color: #4096c8;
            margin-bottom: 10px;
        }

        .sources ul {
            list-style: none;
            padding: 0;
        }

        .sources li {
            margin: 8px 0;
            padding-left: 15px;
            border-left: 2px solid #306090;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #4096c8;
            text-decoration: none;
            font-size: 14px;
        }

        .back-link:hover {
            color: #64c8ff;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Paradoxes</a>

        <header>
            <h1>Counterfactual Quantum Communication</h1>
            <p class="subtitle">Transmitting messages without sending any particles</p>
        </header>

        <div class="main-content">
            <div class="visualization-section">
                <canvas id="canvas" width="600" height="400"></canvas>

                <div class="message-input">
                    <span style="color: #888; padding: 8px;">Bob's blocker:</span>
                    <button class="bit-btn selected" data-bit="0">ABSENT (bit 0)</button>
                    <button class="bit-btn" data-bit="1">PRESENT (bit 1)</button>
                </div>

                <div class="controls">
                    <button id="btnSend" class="active">Send Bit</button>
                    <button id="btnAuto">Auto Mode</button>
                    <button id="btnReset">Reset</button>
                </div>

                <div class="message-display">
                    <div style="color: #888; font-size: 12px;">Transmitted Message:</div>
                    <div class="message-bits" id="messageBits">_</div>
                    <div style="color: #666; font-size: 11px; margin-top: 5px;">
                        Particles that crossed: <span id="particlesCrossed">0</span>
                    </div>
                </div>

                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">Bits Sent</div>
                        <div class="stat-value" id="bitsSent">0</div>
                    </div>
                    <div class="stat-box success-box">
                        <div class="stat-label">Success Rate</div>
                        <div class="stat-value" id="successRate">100%</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Zeno Cycles</div>
                        <div class="stat-value" id="zenoCycles">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Protocol</div>
                        <div class="stat-value" id="protocolType">CFC</div>
                    </div>
                </div>
            </div>

            <div class="essay-section">
                <h2>The Impossible Channel</h2>
                <p>
                    Imagine sending a message to someone across a room without ANY physical carrier—
                    no photons, no electrons, no sound waves, nothing traveling between you.
                    <span class="highlight">Counterfactual communication</span> achieves exactly this.
                </p>

                <p>
                    This isn't science fiction. In 2017, researchers at the University of Science and
                    Technology of China achieved <span class="highlight">direct counterfactual quantum
                    communication</span>, transmitting a black-and-white image between two parties
                    with zero particles crossing the channel.
                </p>

                <h2>How Does It Work?</h2>
                <p>
                    The protocol exploits two quantum phenomena: the <span class="highlight">quantum Zeno
                    effect</span> and <span class="highlight">interaction-free measurement</span>.
                </p>

                <div class="diagram">
        ALICE (Sender)                    BOB (Receiver)
              │                                │
              │       Nested Interferometer    │
              │    ┌──────────────────────┐    │
        ──────┼────│   M─────────────────M│────┼──────
              │    │   │    CHANNEL     │ │    │
              │    │   M─────────────────M│    │
              │    └──────────────────────┘    │
              │                                │
                                          [BLOCKER?]

    M = 50/50 beam splitter (mirror)
    Bob places blocker to send "1", removes it for "0"
                </div>

                <h2>The Quantum Zeno Effect</h2>
                <p>
                    When you repeatedly measure an unstable quantum system, you <span class="warning">
                    freeze</span> its evolution. It's like the watched pot that never boils—
                    but real.
                </p>

                <p>
                    In counterfactual communication, Alice's photon exists in superposition of being
                    in the inner and outer parts of a nested interferometer. Each cycle, a "measurement"
                    checks whether the photon is present. If Bob's blocker is in place, it would absorb
                    any photon—but through the Zeno effect, the photon's amplitude is gradually
                    <span class="highlight">transferred without it ever being there</span>.
                </p>

                <div class="equation">
After N Zeno cycles:

If Bob's blocker PRESENT:
    Photon → Alice's detector D₁ (bit = 1)
    Probability in channel → 0 as N → ∞

If Bob's blocker ABSENT:
    Photon → Alice's detector D₀ (bit = 0)
    (Photon travels normally)
                </div>

                <h2>The Paradox</h2>
                <p>
                    Here's the mind-bending part: When Bob sends a "1" by placing his blocker,
                    <span class="warning">the photon never enters the channel</span>. The blocker
                    is never triggered. Yet Alice receives the information perfectly.
                </p>

                <p>
                    Information is transmitted through what <span class="highlight">could have happened
                    but didn't</span>—hence "counterfactual." The photon's wave function explores
                    the possibility of being blocked, and this possibility alone carries the message.
                </p>

                <h2>Experimental Milestones</h2>
                <p>
                    <span class="highlight">2013:</span> First theoretical proposal by Salih et al.
                    for direct counterfactual communication without entanglement.
                </p>
                <p>
                    <span class="highlight">2017:</span> First experimental demonstration in China,
                    transmitting a 100×100 pixel image counterfactually.
                </p>
                <p>
                    <span class="highlight">2023:</span> "Trace-free" counterfactual communication
                    demonstrated, eliminating even the subtle environmental trace of previous protocols.
                </p>
                <p>
                    <span class="highlight">2024:</span> Counterfactual quantum networks proposed,
                    including secure direct communication and dialogue protocols.
                </p>

                <h2>Information in the Phase</h2>
                <p>
                    Classically, information requires a physical carrier. In counterfactual communication,
                    <span class="highlight">information is carried in the phase</span> of the wave function.
                    The phase accumulates differently depending on whether Bob's blocker is present,
                    even though no particle ever interacts with it.
                </p>

                <div class="equation">
Phase shift:  φ = ∮ A·dl  (line integral around path)

Bob's choice affects the phase through paths
the photon "doesn't take" (counterfactual)
                </div>

                <h2>Security Implications</h2>
                <p>
                    Counterfactual quantum key distribution (CQKD) offers <span class="highlight">
                    ultimate security</span>. Since no particle travels between Alice and Bob,
                    there's nothing to intercept. Any eavesdropper (Eve) attempting to measure
                    the channel would disrupt the delicate Zeno dynamics, immediately revealing
                    her presence.
                </p>

                <h2>Philosophical Implications</h2>
                <p>
                    Counterfactual communication challenges our understanding of causality and locality.
                    How can a decision at Bob's location affect Alice's measurement instantaneously,
                    without any physical connection? The answer lies in quantum mechanics'
                    <span class="highlight">nonlocal correlations</span>—not through signaling, but
                    through the structure of possibility itself.
                </p>

                <p>
                    As physicist Yakir Aharonov noted, quantum mechanics tells us that "what could
                    have happened, but didn't" is just as real as what actually happened.
                </p>

                <div class="sources">
                    <h3>Sources</h3>
                    <ul>
                        <li>Salih, H. et al. (2013). "Protocol for Direct Counterfactual Quantum Communication" - Physical Review Letters</li>
                        <li>Cao, Y. et al. (2017). "Direct counterfactual communication via quantum Zeno effect" - PNAS</li>
                        <li>Hance, J.R. et al. (2023). "Counterfactual communication without a trace in the transmission channel" - npj Quantum Information</li>
                        <li>Salih, H. et al. (2024). "Quantum networks using counterfactual quantum communication" - arXiv</li>
                        <li>Science Alert: "Scientists Have Finally Achieved Direct Counterfactual Quantum Communication"</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // High DPI support
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        const width = rect.width;
        const height = rect.height;

        // State
        let bobBit = 0; // 0 = blocker absent, 1 = blocker present
        let phase = 'idle'; // idle, sending, detecting, result
        let phaseTime = 0;
        let zenoCycle = 0;
        const maxZenoCycles = 8;

        let photonAmplitude = { inner: 0, outer: 1 }; // Amplitude in inner/outer paths
        let photonPhase = 0;
        let detectedBit = -1;

        let stats = { sent: 0, success: 0, particlesCrossed: 0 };
        let message = [];
        let autoMode = false;

        // Geometry
        const aliceX = 80;
        const bobX = width - 80;
        const centerY = height * 0.5;

        // Beam splitter positions for nested interferometer
        const bs = [
            { x: 150, y: centerY - 60 },
            { x: 150, y: centerY + 60 },
            { x: width - 150, y: centerY - 60 },
            { x: width - 150, y: centerY + 60 }
        ];

        // Detectors
        const d0 = { x: 100, y: centerY + 100, label: 'D₀' };
        const d1 = { x: 100, y: centerY - 100, label: 'D₁' };

        // Draw beam splitter
        function drawBeamSplitter(x, y) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.PI / 4);
            ctx.fillStyle = 'rgba(64, 150, 200, 0.3)';
            ctx.fillRect(-12, -2, 24, 4);
            ctx.strokeStyle = '#4096c8';
            ctx.lineWidth = 1;
            ctx.strokeRect(-12, -2, 24, 4);
            ctx.restore();
        }

        // Draw detector
        function drawDetector(d, active) {
            ctx.fillStyle = active ? '#64c896' : 'rgba(100, 100, 100, 0.5)';
            ctx.beginPath();
            ctx.arc(d.x, d.y, 15, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = active ? '#fff' : '#666';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(d.label, d.x, d.y + 4);
        }

        // Draw blocker
        function drawBlocker(present) {
            const x = bobX - 30;
            const y = centerY;

            if (present) {
                ctx.fillStyle = 'rgba(200, 64, 96, 0.8)';
                ctx.fillRect(x - 8, y - 30, 16, 60);
                ctx.strokeStyle = '#c84060';
                ctx.lineWidth = 2;
                ctx.strokeRect(x - 8, y - 30, 16, 60);

                ctx.fillStyle = '#fff';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('BLOCK', x, y + 45);
            } else {
                ctx.strokeStyle = 'rgba(100, 200, 150, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(x - 8, y - 30, 16, 60);
                ctx.setLineDash([]);

                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('(open)', x, y + 45);
            }
        }

        // Draw photon wave
        function drawPhotonWave(time) {
            const outerAmp = photonAmplitude.outer;
            const innerAmp = photonAmplitude.inner;

            // Outer path (doesn't enter inner interferometer)
            if (outerAmp > 0.01) {
                ctx.globalAlpha = outerAmp;

                // Draw wave packet on outer path
                const outerProgress = Math.min(1, phaseTime / 2000);
                const outerPath = [
                    { x: aliceX + 30, y: centerY },
                    { x: bs[0].x, y: centerY },
                    { x: bs[0].x, y: bs[0].y },
                    { x: bs[1].x, y: bs[1].y },
                    { x: bs[1].x, y: centerY },
                    { x: aliceX + 30, y: centerY }
                ];

                drawWaveOnPath(outerPath, outerProgress, '#4096c8', time);
                ctx.globalAlpha = 1;
            }

            // Inner path (enters channel toward Bob)
            if (innerAmp > 0.01) {
                ctx.globalAlpha = innerAmp;

                const innerProgress = Math.min(1, phaseTime / 2000);
                const innerPath = [
                    { x: bs[0].x, y: centerY - 30 },
                    { x: bs[2].x, y: centerY - 30 },
                    { x: bs[2].x, y: centerY },
                    { x: bobBit === 1 ? bobX - 40 : bobX, y: centerY },
                ];

                drawWaveOnPath(innerPath, innerProgress * 0.5, '#c84096', time);
                ctx.globalAlpha = 1;
            }
        }

        // Draw wave on path
        function drawWaveOnPath(path, progress, color, time) {
            // Calculate total path length
            let totalLength = 0;
            for (let i = 0; i < path.length - 1; i++) {
                const dx = path[i + 1].x - path[i].x;
                const dy = path[i + 1].y - path[i].y;
                totalLength += Math.sqrt(dx * dx + dy * dy);
            }

            // Find position along path
            const targetDist = progress * totalLength;
            let currentDist = 0;
            let pos = path[0];

            for (let i = 0; i < path.length - 1; i++) {
                const dx = path[i + 1].x - path[i].x;
                const dy = path[i + 1].y - path[i].y;
                const segLength = Math.sqrt(dx * dx + dy * dy);

                if (currentDist + segLength >= targetDist) {
                    const t = (targetDist - currentDist) / segLength;
                    pos = {
                        x: path[i].x + dx * t,
                        y: path[i].y + dy * t
                    };
                    break;
                }
                currentDist += segLength;
            }

            // Draw glow
            const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 30);
            gradient.addColorStop(0, color);
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 30, 0, Math.PI * 2);
            ctx.fill();

            // Draw core
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 8, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw paths
        function drawPaths() {
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.3)';
            ctx.lineWidth = 1;

            // Outer loop (Alice's side)
            ctx.beginPath();
            ctx.moveTo(aliceX + 30, centerY);
            ctx.lineTo(bs[0].x, centerY);
            ctx.lineTo(bs[0].x, bs[0].y);
            ctx.moveTo(bs[0].x, centerY);
            ctx.lineTo(bs[1].x, centerY);
            ctx.lineTo(bs[1].x, bs[1].y);
            ctx.stroke();

            // Inner path (through channel)
            ctx.beginPath();
            ctx.moveTo(bs[0].x, bs[0].y);
            ctx.lineTo(bs[2].x, bs[0].y);
            ctx.lineTo(bs[2].x, centerY);
            ctx.lineTo(bobX - 30, centerY);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(bs[1].x, bs[1].y);
            ctx.lineTo(bs[3].x, bs[1].y);
            ctx.lineTo(bs[3].x, centerY);
            ctx.lineTo(bobX - 30, centerY);
            ctx.stroke();

            // To detectors
            ctx.beginPath();
            ctx.moveTo(bs[1].x, bs[1].y);
            ctx.lineTo(d0.x, d0.y);
            ctx.moveTo(bs[0].x, bs[0].y);
            ctx.lineTo(d1.x, d1.y);
            ctx.stroke();
        }

        // Draw Zeno indicator
        function drawZenoIndicator(time) {
            if (phase !== 'sending') return;

            const x = width / 2;
            const y = 30;

            ctx.fillStyle = '#888';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Zeno Cycle: ${zenoCycle + 1}/${maxZenoCycles}`, x, y);

            // Progress bar
            const barWidth = 150;
            ctx.fillStyle = 'rgba(100, 100, 150, 0.3)';
            ctx.fillRect(x - barWidth/2, y + 10, barWidth, 8);

            ctx.fillStyle = '#4096c8';
            ctx.fillRect(x - barWidth/2, y + 10, barWidth * (zenoCycle / maxZenoCycles), 8);
        }

        // Main draw
        function draw(time) {
            ctx.fillStyle = '#050810';
            ctx.fillRect(0, 0, width, height);

            // Labels
            ctx.fillStyle = '#4096c8';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ALICE', aliceX, 25);
            ctx.fillStyle = '#c84096';
            ctx.fillText('BOB', bobX, 25);

            // Channel label
            ctx.fillStyle = '#666';
            ctx.font = '11px Arial';
            ctx.fillText('Quantum Channel', width/2, height - 15);
            ctx.fillText('(no particles cross when bit=1)', width/2, height - 3);

            // Draw paths
            drawPaths();

            // Draw beam splitters
            bs.forEach(b => drawBeamSplitter(b.x, b.y));

            // Draw blocker
            drawBlocker(bobBit === 1);

            // Draw detectors
            const d0Active = phase === 'result' && detectedBit === 0;
            const d1Active = phase === 'result' && detectedBit === 1;
            drawDetector(d0, d0Active);
            drawDetector(d1, d1Active);

            // Draw photon wave
            if (phase === 'sending') {
                drawPhotonWave(time);
            }

            // Zeno indicator
            drawZenoIndicator(time);

            // Result
            if (phase === 'result') {
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';

                if (detectedBit === bobBit) {
                    ctx.fillStyle = '#64c896';
                    ctx.fillText(`Received: ${detectedBit}`, width/2, height/2 - 20);

                    if (bobBit === 1) {
                        ctx.font = '12px Arial';
                        ctx.fillStyle = '#ff8866';
                        ctx.fillText('No particle crossed the channel!', width/2, height/2);
                    }
                } else {
                    ctx.fillStyle = '#ff6666';
                    ctx.fillText('Error!', width/2, height/2);
                }
            }

            // Alice source
            ctx.fillStyle = '#4096c8';
            ctx.beginPath();
            ctx.arc(aliceX, centerY, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = '8px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('SRC', aliceX, centerY + 3);
        }

        // Update simulation
        function update(deltaTime) {
            if (phase === 'sending') {
                phaseTime += deltaTime;

                // Zeno effect: gradually transfer amplitude based on Bob's choice
                const cycleLength = 250; // ms per Zeno cycle
                const newCycle = Math.floor(phaseTime / cycleLength);

                if (newCycle > zenoCycle && zenoCycle < maxZenoCycles) {
                    zenoCycle = newCycle;

                    if (bobBit === 1) {
                        // Blocker present: Zeno effect keeps photon out of inner path
                        // Amplitude transfers to D1 path
                        photonAmplitude.inner *= 0.7;
                        photonAmplitude.outer = Math.sqrt(1 - photonAmplitude.inner * photonAmplitude.inner);
                    } else {
                        // Blocker absent: photon can travel through
                        // Normal interference leads to D0
                        photonAmplitude.outer *= 0.85;
                        photonAmplitude.inner = Math.sqrt(1 - photonAmplitude.outer * photonAmplitude.outer);
                    }
                }

                if (zenoCycle >= maxZenoCycles) {
                    phase = 'detecting';
                    phaseTime = 0;
                }
            } else if (phase === 'detecting') {
                phaseTime += deltaTime;

                if (phaseTime > 500) {
                    // Determine detection
                    if (bobBit === 1) {
                        detectedBit = 1; // Photon at D1, never crossed channel
                    } else {
                        detectedBit = 0; // Photon at D0, crossed channel
                        stats.particlesCrossed++;
                    }

                    stats.sent++;
                    if (detectedBit === bobBit) stats.success++;

                    message.push(detectedBit);
                    updateStats();

                    phase = 'result';
                    phaseTime = 0;
                }
            } else if (phase === 'result') {
                phaseTime += deltaTime;

                if (phaseTime > 1500 && autoMode) {
                    // Auto mode: randomly flip Bob's bit and continue
                    bobBit = Math.random() < 0.5 ? 0 : 1;
                    updateBitButtons();
                    startSending();
                }
            }
        }

        // Start sending
        function startSending() {
            phase = 'sending';
            phaseTime = 0;
            zenoCycle = 0;
            photonAmplitude = { inner: 0.1, outer: 0.99 };
            detectedBit = -1;
        }

        // Update stats
        function updateStats() {
            document.getElementById('bitsSent').textContent = stats.sent;
            const rate = stats.sent > 0 ? Math.round(stats.success / stats.sent * 100) : 100;
            document.getElementById('successRate').textContent = rate + '%';
            document.getElementById('zenoCycles').textContent = zenoCycle;
            document.getElementById('particlesCrossed').textContent = stats.particlesCrossed;

            const bits = message.slice(-16).map(b => b.toString()).join('');
            document.getElementById('messageBits').textContent = bits || '_';
        }

        // Update bit buttons
        function updateBitButtons() {
            document.querySelectorAll('.bit-btn').forEach(btn => {
                btn.classList.toggle('selected', parseInt(btn.dataset.bit) === bobBit);
            });
        }

        // Animation loop
        let lastTime = 0;
        function animate(time) {
            const deltaTime = time - lastTime;
            lastTime = time;

            update(deltaTime);
            draw(time);

            requestAnimationFrame(animate);
        }

        // Event handlers
        document.querySelectorAll('.bit-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                bobBit = parseInt(this.dataset.bit);
                updateBitButtons();
            });
        });

        document.getElementById('btnSend').addEventListener('click', function() {
            if (phase === 'idle' || phase === 'result') {
                startSending();
            }
        });

        document.getElementById('btnAuto').addEventListener('click', function() {
            autoMode = !autoMode;
            this.classList.toggle('active', autoMode);
            this.textContent = autoMode ? 'Stop Auto' : 'Auto Mode';

            if (autoMode && (phase === 'idle' || phase === 'result')) {
                startSending();
            }
        });

        document.getElementById('btnReset').addEventListener('click', function() {
            stats = { sent: 0, success: 0, particlesCrossed: 0 };
            message = [];
            phase = 'idle';
            autoMode = false;
            document.getElementById('btnAuto').classList.remove('active');
            document.getElementById('btnAuto').textContent = 'Auto Mode';
            updateStats();
        });

        // Start
        animate(0);
    </script>
</body>
</html>
