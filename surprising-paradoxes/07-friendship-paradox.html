<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Friendship Paradox - Why Your Friends Are More Popular Than You</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #1e3a5f 100%);
            min-height: 100vh;
            color: #e8e8f8;
            line-height: 1.8;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 12px 24px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            color: #00d9ff;
            text-decoration: none;
            border-radius: 30px;
            font-size: 14px;
            z-index: 1000;
            transition: all 0.3s;
            border: 1px solid rgba(0,217,255,0.3);
        }

        .back-link:hover {
            background: rgba(0,217,255,0.2);
            transform: translateX(-5px);
        }

        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 80px 30px 60px;
        }

        header {
            text-align: center;
            margin-bottom: 50px;
        }

        h1 {
            font-size: 2.8rem;
            font-weight: 400;
            color: #00d9ff;
            margin-bottom: 20px;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 1.4rem;
            color: #a8b2d1;
            font-style: italic;
        }

        .paradox-statement {
            background: linear-gradient(135deg, rgba(0,217,255,0.15) 0%, rgba(255,215,0,0.1) 100%);
            border-left: 4px solid #00d9ff;
            padding: 30px 40px;
            margin: 40px 0;
            border-radius: 0 20px 20px 0;
            font-size: 1.25rem;
            text-align: center;
        }

        h2 {
            font-size: 1.8rem;
            color: #00d9ff;
            margin: 50px 0 25px;
            font-weight: 400;
        }

        p {
            margin-bottom: 20px;
            color: #c8d0e8;
        }

        .highlight {
            color: #ffd700;
            font-weight: 600;
        }

        .cyan {
            color: #00d9ff;
            font-weight: 600;
        }

        .simulation-container {
            background: rgba(0,0,0,0.4);
            border-radius: 20px;
            padding: 30px;
            margin: 40px 0;
            border: 1px solid rgba(0,217,255,0.2);
        }

        .sim-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .sim-title {
            font-size: 1.4rem;
            color: #00d9ff;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00d9ff 0%, #0099cc 100%);
            color: #1a1a2e;
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #a8b2d1;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0,217,255,0.3);
        }

        #network-canvas {
            width: 100%;
            height: 450px;
            background: #0a0a1a;
            border-radius: 15px;
            cursor: pointer;
        }

        .network-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }

        .slider-container {
            flex: 1;
            min-width: 200px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: #a8b2d1;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00d9ff;
            cursor: pointer;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 30px;
        }

        .stat-box {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: #00d9ff;
            font-family: 'Courier New', monospace;
        }

        .stat-label {
            font-size: 0.85rem;
            color: #8892b0;
            margin-top: 5px;
        }

        .stat-value.highlight-stat { color: #ffd700; }
        .stat-value.paradox { color: #ff6b6b; }

        .comparison-visual {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 60px;
            margin: 40px 0;
            flex-wrap: wrap;
        }

        .bar-column {
            text-align: center;
        }

        .bar-container {
            width: 80px;
            height: 200px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            position: relative;
            margin: 0 auto 15px;
            overflow: hidden;
        }

        .bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            border-radius: 0 0 10px 10px;
            transition: height 0.5s ease;
        }

        .bar.you {
            background: linear-gradient(180deg, #00d9ff, #0077aa);
        }

        .bar.friends {
            background: linear-gradient(180deg, #ffd700, #cc9900);
        }

        .bar-label {
            font-weight: 700;
            font-size: 1.1rem;
        }

        .bar-value {
            font-size: 0.9rem;
            color: #a8b2d1;
            margin-top: 5px;
        }

        .explanation-box {
            background: rgba(255,215,0,0.1);
            border: 1px solid rgba(255,215,0,0.3);
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
        }

        .explanation-box h3 {
            color: #ffd700;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .math-box {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            text-align: center;
        }

        .formula {
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            color: #00d9ff;
            margin-bottom: 15px;
        }

        .formula-caption {
            color: #8892b0;
            font-size: 0.95rem;
        }

        .impact-box {
            background: rgba(255,107,107,0.1);
            border: 1px solid rgba(255,107,107,0.3);
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
        }

        .impact-box h3 {
            color: #ff6b6b;
            margin-bottom: 15px;
        }

        .application-box {
            background: rgba(78,205,196,0.1);
            border: 1px solid rgba(78,205,196,0.3);
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
        }

        .application-box h3 {
            color: #4ecdc4;
            margin-bottom: 15px;
        }

        .node-info {
            position: fixed;
            background: rgba(0,0,0,0.9);
            border: 1px solid #00d9ff;
            border-radius: 10px;
            padding: 15px;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        footer {
            text-align: center;
            margin-top: 60px;
            padding-top: 40px;
            border-top: 1px solid rgba(255,255,255,0.1);
            color: #5a6a8a;
        }

        footer a {
            color: #00d9ff;
            text-decoration: none;
        }

        @media (max-width: 768px) {
            h1 { font-size: 2rem; }
            #network-canvas { height: 350px; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="node-info" id="node-info"></div>

    <div class="container">
        <header>
            <h1>üë• The Friendship Paradox</h1>
            <p class="subtitle">Why your friends are more popular than you</p>
        </header>

        <div class="paradox-statement">
            <strong>The Paradox:</strong> On average, your friends have <span class="highlight">more friends than you do</span>.
            On Facebook, <span class="highlight">93%</span> of users experience this. On Twitter, it's <span class="highlight">99%</span>.
        </div>

        <h2>The Uncomfortable Truth</h2>
        <p>
            Look at your social media. Count your followers or friends. Now look at your friends' profiles‚Äî
            most of them have more connections than you. This isn't because you're unpopular.
            It's a <span class="cyan">mathematical certainty</span>.
        </p>
        <p>
            Discovered by sociologist Scott Feld in 1991, the friendship paradox shows that in almost any
            social network, most people's friends have more friends than they do. This isn't a bug‚Äîit's a
            fundamental property of how networks work.
        </p>

        <div class="simulation-container">
            <div class="sim-header">
                <div class="sim-title">üåê Interactive Social Network</div>
                <div class="controls">
                    <button class="btn btn-primary" id="generate-network">Generate New Network</button>
                    <button class="btn btn-secondary" id="highlight-you">Select Random "You"</button>
                </div>
            </div>

            <canvas id="network-canvas"></canvas>

            <div class="network-controls">
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Network Size</span>
                        <span id="size-value">50</span>
                    </div>
                    <input type="range" class="slider" id="size-slider" min="20" max="100" value="50">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Connection Density</span>
                        <span id="density-value">15%</span>
                    </div>
                    <input type="range" class="slider" id="density-slider" min="5" max="40" value="15">
                </div>
            </div>

            <div class="comparison-visual">
                <div class="bar-column">
                    <div class="bar-container">
                        <div class="bar you" id="your-bar" style="height: 0%;"></div>
                    </div>
                    <div class="bar-label" style="color: #00d9ff;">YOUR Friends</div>
                    <div class="bar-value" id="your-count">-</div>
                </div>
                <div class="bar-column">
                    <div class="bar-container">
                        <div class="bar friends" id="friends-bar" style="height: 0%;"></div>
                    </div>
                    <div class="bar-label" style="color: #ffd700;">Friends' Average</div>
                    <div class="bar-value" id="friends-avg">-</div>
                </div>
            </div>

            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-value" id="total-nodes">0</div>
                    <div class="stat-label">People in Network</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="avg-friends">0</div>
                    <div class="stat-label">Avg Friends/Person</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="avg-friends-of-friends">0</div>
                    <div class="stat-label">Avg Friends of Friends</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value paradox" id="paradox-pct">0%</div>
                    <div class="stat-label">Experience Paradox</div>
                </div>
            </div>
        </div>

        <div class="explanation-box">
            <h3>üß† Why Does This Happen?</h3>
            <p>
                The key is <span class="highlight">sampling bias</span>. Popular people appear in many friend lists.
                So when you sample "friends of a random person," you're more likely to hit the popular nodes.
            </p>
            <p>
                Think of it this way: Imagine a party where one person knows everyone (100 connections),
                and everyone else knows only that one person (1 connection each). If you pick a random person,
                their friend (the popular one) has 100 friends. Their friend is more popular than them!
            </p>
            <p>
                This happens because <span class="cyan">high-degree nodes are over-represented</span> when you
                sample through friendships. You're not picking random people‚Äîyou're picking friends of random
                people, which biases toward the highly connected.
            </p>
        </div>

        <div class="math-box">
            <div class="formula">
                Mean(friends of friends) = Mean(friends) + Variance / Mean
            </div>
            <div class="formula-caption">
                The variance term is always positive, so friends of friends always have more friends on average.
                <br>This is known as the "inspection paradox" or "length-biased sampling."
            </div>
        </div>

        <h2>The Generalized Friendship Paradox</h2>
        <p>
            It gets worse. Researchers found that this paradox extends to <em>any property correlated with
            popularity</em>:
        </p>
        <p>
            ‚Ä¢ Your friends are probably <span class="cyan">richer</span> than you<br>
            ‚Ä¢ Your friends are probably <span class="cyan">happier</span> than you<br>
            ‚Ä¢ Your friends are probably <span class="cyan">more attractive</span> than you<br>
            ‚Ä¢ Your friends probably have <span class="cyan">better vacations</span> than you
        </p>
        <p>
            This isn't because you're unlucky. It's because the same network dynamics that make popular
            people over-represented also make any trait they have over-represented in your feed.
        </p>

        <div class="impact-box">
            <h3>üòî The Social Media Depression Connection</h3>
            <p>
                Researchers believe the friendship paradox contributes to social media depression.
                When you scroll through feeds, you're seeing a biased sample of the most active,
                most connected people‚Äîmaking your life seem worse by comparison.
            </p>
            <p>
                Studies show that <span class="highlight">heavy social media users have higher rates of depression</span>,
                partly because they're constantly comparing themselves to a mathematically skewed sample
                of their network's most successful members.
            </p>
        </div>

        <div class="application-box">
            <h3>ü¶† Practical Applications</h3>
            <p>
                <strong>Epidemic Detection:</strong> In 2010, Christakis and Fowler showed that monitoring
                friends of random people can detect flu outbreaks 2 weeks earlier than traditional surveillance.
                Friends are more connected and get infected first!
            </p>
            <p>
                <strong>Vaccination Strategy:</strong> Vaccinating friends of random people is more efficient
                than vaccinating random people‚Äîyou're targeting the network hubs.
            </p>
            <p>
                <strong>Viral Marketing:</strong> Reaching friends of random customers spreads messages
                faster than reaching random customers directly.
            </p>
        </div>

        <h2>The Enmity Paradox</h2>
        <p>
            In 2023, researchers discovered a parallel paradox for negative ties:
            <span class="cyan">Your enemies have more enemies than you do, too.</span>
            The same mathematical principle applies to any network relationship.
        </p>

        <footer>
            <p>
                Discovered by Scott L. Feld (1991) ¬∑
                <a href="https://en.wikipedia.org/wiki/Friendship_paradox" target="_blank">Learn more on Wikipedia</a>
            </p>
            <p style="margin-top: 15px; font-size: 0.9rem;">
                Sources:
                <a href="https://blogs.cornell.edu/info2040/2012/10/03/the-friendship-paradox-why-your-friends-have-more-friends-than-you-do/" target="_blank">Cornell Networks Blog</a> ¬∑
                <a href="https://www.technologyreview.com/2014/01/14/174587/how-the-friendship-paradox-makes-your-friends-better-than-you-are/" target="_blank">MIT Technology Review</a> ¬∑
                <a href="https://www.sciencefocus.com/science/the-friendship-paradox-youll-never-be-as-popular-on-social-media-as-your-friends" target="_blank">BBC Science Focus</a>
            </p>
        </footer>
    </div>

    <script>
        const canvas = document.getElementById('network-canvas');
        const ctx = canvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let selectedNode = null;
        let hoveredNode = null;

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        resizeCanvas();
        window.addEventListener('resize', () => { resizeCanvas(); draw(); });

        function generateNetwork() {
            const n = parseInt(document.getElementById('size-slider').value);
            const density = parseInt(document.getElementById('density-slider').value) / 100;

            // Generate nodes with power-law-ish popularity distribution
            nodes = [];
            const rect = canvas.getBoundingClientRect();
            for (let i = 0; i < n; i++) {
                const angle = (i / n) * Math.PI * 2;
                const radius = 120 + Math.random() * 80;
                nodes.push({
                    id: i,
                    x: rect.width / 2 + Math.cos(angle) * radius + (Math.random() - 0.5) * 60,
                    y: rect.height / 2 + Math.sin(angle) * radius + (Math.random() - 0.5) * 60,
                    friends: [],
                    popularity: Math.pow(Math.random(), 2) // Creates uneven distribution
                });
            }

            // Generate edges with preferential attachment
            edges = [];
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    // Higher popularity = more likely to connect
                    const prob = density * (1 + nodes[i].popularity * 3) * (1 + nodes[j].popularity * 3);
                    if (Math.random() < prob) {
                        edges.push([i, j]);
                        nodes[i].friends.push(j);
                        nodes[j].friends.push(i);
                    }
                }
            }

            // Ensure everyone has at least one friend
            nodes.forEach((node, i) => {
                if (node.friends.length === 0) {
                    const j = Math.floor(Math.random() * n);
                    if (j !== i) {
                        edges.push([i, j]);
                        nodes[i].friends.push(j);
                        nodes[j].friends.push(i);
                    }
                }
            });

            selectedNode = null;
            updateStats();
            draw();
        }

        function selectRandomNode() {
            selectedNode = Math.floor(Math.random() * nodes.length);
            updateComparison();
            draw();
        }

        function calculateFriendsOfFriendsAvg(nodeIndex) {
            const node = nodes[nodeIndex];
            if (node.friends.length === 0) return 0;

            let total = 0;
            node.friends.forEach(friendIdx => {
                total += nodes[friendIdx].friends.length;
            });
            return total / node.friends.length;
        }

        function updateStats() {
            const n = nodes.length;
            document.getElementById('total-nodes').textContent = n;

            // Average friends per person
            const totalFriends = nodes.reduce((sum, node) => sum + node.friends.length, 0);
            const avgFriends = totalFriends / n;
            document.getElementById('avg-friends').textContent = avgFriends.toFixed(1);

            // Average friends of friends (network-wide)
            let totalFoF = 0;
            nodes.forEach(node => {
                totalFoF += calculateFriendsOfFriendsAvg(node.id);
            });
            const avgFoF = totalFoF / n;
            document.getElementById('avg-friends-of-friends').textContent = avgFoF.toFixed(1);

            // Percentage experiencing paradox
            let paradoxCount = 0;
            nodes.forEach(node => {
                if (calculateFriendsOfFriendsAvg(node.id) > node.friends.length) {
                    paradoxCount++;
                }
            });
            const paradoxPct = (paradoxCount / n * 100).toFixed(0);
            document.getElementById('paradox-pct').textContent = paradoxPct + '%';
        }

        function updateComparison() {
            if (selectedNode === null) return;

            const node = nodes[selectedNode];
            const yourCount = node.friends.length;
            const friendsAvg = calculateFriendsOfFriendsAvg(selectedNode);

            document.getElementById('your-count').textContent = yourCount + ' friends';
            document.getElementById('friends-avg').textContent = friendsAvg.toFixed(1) + ' friends';

            const maxVal = Math.max(yourCount, friendsAvg, 1);
            document.getElementById('your-bar').style.height = (yourCount / maxVal * 100) + '%';
            document.getElementById('friends-bar').style.height = (friendsAvg / maxVal * 100) + '%';
        }

        function draw() {
            const rect = canvas.getBoundingClientRect();
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, rect.width, rect.height);

            // Draw edges
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            edges.forEach(([i, j]) => {
                // Highlight edges connected to selected node
                if (selectedNode !== null && (i === selectedNode || j === selectedNode)) {
                    ctx.strokeStyle = 'rgba(0, 217, 255, 0.5)';
                    ctx.lineWidth = 2;
                } else {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                }
                ctx.beginPath();
                ctx.moveTo(nodes[i].x, nodes[i].y);
                ctx.lineTo(nodes[j].x, nodes[j].y);
                ctx.stroke();
            });

            // Draw nodes
            nodes.forEach((node, i) => {
                const radius = 4 + node.friends.length * 0.5;

                ctx.beginPath();
                ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);

                if (i === selectedNode) {
                    ctx.fillStyle = '#00ff88';
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 15;
                } else if (selectedNode !== null && nodes[selectedNode].friends.includes(i)) {
                    ctx.fillStyle = '#ffd700';
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 10;
                } else if (i === hoveredNode) {
                    ctx.fillStyle = '#00d9ff';
                    ctx.shadowBlur = 10;
                } else {
                    ctx.fillStyle = `rgba(0, 217, 255, ${0.3 + node.friends.length * 0.05})`;
                    ctx.shadowBlur = 0;
                }
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            // Legend
            if (selectedNode !== null) {
                ctx.font = '12px Georgia';
                ctx.fillStyle = '#00ff88';
                ctx.fillRect(15, 15, 12, 12);
                ctx.fillStyle = '#fff';
                ctx.fillText('You', 32, 25);

                ctx.fillStyle = '#ffd700';
                ctx.fillRect(15, 32, 12, 12);
                ctx.fillStyle = '#fff';
                ctx.fillText('Your Friends', 32, 42);
            }
        }

        // Event listeners
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            hoveredNode = null;
            nodes.forEach((node, i) => {
                const dx = node.x - x;
                const dy = node.y - y;
                if (Math.sqrt(dx*dx + dy*dy) < 15) {
                    hoveredNode = i;
                }
            });

            if (hoveredNode !== null) {
                const node = nodes[hoveredNode];
                const info = document.getElementById('node-info');
                info.style.display = 'block';
                info.style.left = (e.clientX + 15) + 'px';
                info.style.top = (e.clientY + 15) + 'px';
                info.innerHTML = `
                    <strong>Person #${hoveredNode + 1}</strong><br>
                    Friends: ${node.friends.length}<br>
                    Friends' avg: ${calculateFriendsOfFriendsAvg(hoveredNode).toFixed(1)}
                `;
            } else {
                document.getElementById('node-info').style.display = 'none';
            }

            draw();
        });

        canvas.addEventListener('click', (e) => {
            if (hoveredNode !== null) {
                selectedNode = hoveredNode;
                updateComparison();
                draw();
            }
        });

        canvas.addEventListener('mouseleave', () => {
            hoveredNode = null;
            document.getElementById('node-info').style.display = 'none';
            draw();
        });

        document.getElementById('generate-network').addEventListener('click', generateNetwork);
        document.getElementById('highlight-you').addEventListener('click', selectRandomNode);

        document.getElementById('size-slider').addEventListener('input', function() {
            document.getElementById('size-value').textContent = this.value;
        });

        document.getElementById('density-slider').addEventListener('input', function() {
            document.getElementById('density-value').textContent = this.value + '%';
        });

        // Initialize
        generateNetwork();
    </script>
</body>
</html>
