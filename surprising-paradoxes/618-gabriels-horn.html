<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gabriel's Horn - Infinite Surface, Finite Volume</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f3460 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }
        .back-link {
            display: inline-flex;
            align-items: center;
            color: #e94560;
            text-decoration: none;
            margin-bottom: 15px;
            font-size: 0.95em;
        }
        .back-link:hover {
            color: #ff6b6b;
            text-decoration: underline;
        }
        h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
            color: #fff;
            text-shadow: 0 0 30px rgba(233, 69, 96, 0.5);
        }
        .subtitle {
            color: #8b949e;
            margin-bottom: 20px;
            font-size: 1.05em;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        .canvas-container {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 15px;
        }
        canvas {
            display: block;
            width: 100%;
            border-radius: 8px;
            background: #0a0a1a;
        }
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .panel {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .panel h3 {
            font-size: 0.9em;
            color: #e94560;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all 0.2s;
        }
        .btn-primary {
            background: linear-gradient(135deg, #e94560, #c23a4f);
            color: white;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
        }
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
        }
        .btn-secondary.active {
            background: rgba(233, 69, 96, 0.3);
            border-color: #e94560;
        }
        .param-group {
            margin-bottom: 15px;
        }
        .param-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .param-name {
            color: #b0b0b0;
            font-size: 0.85em;
        }
        .param-value {
            color: #ffd700;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.9em;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.1);
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #e94560;
            cursor: pointer;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .stat-label {
            color: #8b949e;
            font-size: 0.85em;
        }
        .stat-value {
            color: #ffd700;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.9em;
        }
        .finite {
            color: #4ade80 !important;
        }
        .infinite {
            color: #f87171 !important;
        }
        .formula {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 6px;
            font-family: 'Monaco', 'Consolas', monospace;
            margin: 8px 0;
            text-align: center;
            color: #ffd700;
            font-size: 0.85em;
        }
        .exp-section {
            margin-top: 20px;
        }
        .exp-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
        }
        .exp-card {
            background: linear-gradient(135deg, rgba(233,69,96,0.1), rgba(15,52,96,0.2));
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(233,69,96,0.2);
        }
        .exp-card h4 {
            color: #e94560;
            margin-bottom: 8px;
            font-size: 0.95em;
        }
        .exp-card p {
            font-size: 0.85em;
            line-height: 1.6;
            color: #8b949e;
        }
        .drag-hint {
            font-size: 0.8em;
            color: #8b949e;
            margin-top: 8px;
            text-align: center;
        }
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Paradoxes</a>
        <h1>Gabriel's Horn</h1>
        <p class="subtitle">Torricelli's Trumpet: Finite Volume, Infinite Surface</p>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="mainCanvas"></canvas>
                <p class="drag-hint">Drag to rotate. Scroll to zoom.</p>
            </div>

            <div class="sidebar">
                <div class="panel">
                    <h3>Controls</h3>
                    <div class="controls">
                        <button class="btn btn-primary" id="resetBtn">Reset View</button>
                        <button class="btn btn-secondary" id="animateBtn">Animate</button>
                        <button class="btn btn-secondary" id="wireframeBtn">Wireframe</button>
                    </div>
                </div>

                <div class="panel">
                    <h3>Horn Length</h3>
                    <div class="param-group">
                        <div class="param-label">
                            <span class="param-name">Truncation point (x)</span>
                            <span class="param-value" id="truncValue">10</span>
                        </div>
                        <input type="range" id="truncSlider" min="2" max="100" value="10">
                    </div>
                    <p style="font-size: 0.8em; color: #8b949e;">As x → ∞, volume → π but surface → ∞</p>
                </div>

                <div class="panel">
                    <h3>The Paradox</h3>
                    <div class="stat-row">
                        <span class="stat-label">Volume (truncated)</span>
                        <span id="volume" class="stat-value finite">2.827</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Volume (x → ∞)</span>
                        <span class="stat-value finite">π ≈ 3.14159</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Surface (truncated)</span>
                        <span id="surface" class="stat-value infinite">15.71</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Surface (x → ∞)</span>
                        <span class="stat-value infinite">∞ (INFINITE!)</span>
                    </div>
                </div>

                <div class="panel">
                    <h3>The Function</h3>
                    <div class="formula">y = 1/x rotated around x-axis</div>
                    <div class="formula">
                        V = π ∫₁^∞ (1/x)² dx = π<br>
                        S = 2π ∫₁^∞ (1/x)√(1+1/x⁴) dx = ∞
                    </div>
                </div>

                <div class="panel">
                    <h3>Painter's Paradox</h3>
                    <p style="font-size: 0.85em; color: #b0b0b0; line-height: 1.5;">
                        You can <span class="finite">FILL</span> Gabriel's Horn with π cubic units of paint...
                        but you can <span class="infinite">NEVER PAINT</span> its surface—it requires infinite paint!
                    </p>
                </div>
            </div>
        </div>

        <div class="exp-section">
            <div class="exp-cards">
                <div class="exp-card">
                    <h4>Torricelli's Discovery (1641)</h4>
                    <p>Evangelista Torricelli was astonished to find this shape with finite volume but infinite surface area. It sparked philosophical debates involving Hobbes, Wallis, and Galileo about the nature of infinity!</p>
                </div>
                <div class="exp-card">
                    <h4>The Math Behind It</h4>
                    <p>Volume integral: ∫(1/x²)dx converges. Surface integral: ∫(1/x)dx diverges. The function 1/x decreases slowly enough to make the surface infinite, but 1/x² decreases fast enough for finite volume.</p>
                </div>
                <div class="exp-card">
                    <h4>Resolution of Paradox</h4>
                    <p>With "mathematical paint" (zero thickness), filling the horn also coats its interior—so you DO paint the surface by filling! With physical paint, the horn narrows until no molecule can fit, making the question moot.</p>
                </div>
                <div class="exp-card">
                    <h4>Dough Analogy</h4>
                    <p>Roll dough into an infinitely long snake. Volume stays constant (same dough), but surface area grows without bound. Gabriel's Horn is this idea made mathematically precise—same intuition, rigorous proof!</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        // High DPI setup
        function setupCanvas() {
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            return { width: rect.width, height: rect.height };
        }

        let truncPoint = 10;
        let rotationX = 0.3;
        let rotationY = 0.5;
        let zoom = 1;
        let wireframe = false;
        let animating = false;

        // 3D point rotation
        function rotatePoint(x, y, z) {
            // Rotate around Y axis
            let x1 = x * Math.cos(rotationY) - z * Math.sin(rotationY);
            let z1 = x * Math.sin(rotationY) + z * Math.cos(rotationY);

            // Rotate around X axis
            let y1 = y * Math.cos(rotationX) - z1 * Math.sin(rotationX);
            let z2 = y * Math.sin(rotationX) + z1 * Math.cos(rotationX);

            return { x: x1, y: y1, z: z2 };
        }

        // Project 3D to 2D
        function project(x, y, z, width, height) {
            const scale = 80 * zoom;
            const perspective = 5;

            const rotated = rotatePoint(x, y, z);
            const factor = perspective / (perspective + rotated.z);

            return {
                x: width / 2 + rotated.x * scale * factor,
                y: height / 2 - rotated.y * scale * factor,
                z: rotated.z
            };
        }

        // Generate horn points
        function generateHorn(truncation) {
            const rings = [];
            const segments = 32;
            const lengthSteps = 50;

            for (let i = 0; i < lengthSteps; i++) {
                const t = i / (lengthSteps - 1);
                const x = 1 + t * (truncation - 1);
                const radius = 1 / x;

                const ring = [];
                for (let j = 0; j <= segments; j++) {
                    const angle = (j / segments) * Math.PI * 2;
                    const y = radius * Math.cos(angle);
                    const z = radius * Math.sin(angle);
                    ring.push({ x: x - truncation / 2, y, z });
                }
                rings.push(ring);
            }

            return rings;
        }

        // Calculate volume (truncated)
        function calculateVolume(truncation) {
            // V = π ∫₁^T (1/x²) dx = π [1 - 1/T]
            return Math.PI * (1 - 1 / truncation);
        }

        // Calculate surface area (truncated, approximation)
        function calculateSurface(truncation) {
            // S = 2π ∫₁^T (1/x) √(1 + 1/x⁴) dx ≈ 2π ln(T) for large T
            // More accurate: use numerical integration
            let sum = 0;
            const steps = 1000;
            const dx = (truncation - 1) / steps;

            for (let i = 0; i < steps; i++) {
                const x = 1 + i * dx;
                const y = 1 / x;
                const dydx = -1 / (x * x);
                const ds = Math.sqrt(1 + dydx * dydx) * dx;
                sum += 2 * Math.PI * y * ds;
            }

            return sum;
        }

        function draw() {
            const { width, height } = setupCanvas();

            // Clear
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, width, height);

            const rings = generateHorn(truncPoint);

            // Collect faces for depth sorting
            const faces = [];

            for (let i = 0; i < rings.length - 1; i++) {
                for (let j = 0; j < rings[i].length - 1; j++) {
                    const p1 = rings[i][j];
                    const p2 = rings[i][j + 1];
                    const p3 = rings[i + 1][j + 1];
                    const p4 = rings[i + 1][j];

                    const avgZ = (
                        rotatePoint(p1.x, p1.y, p1.z).z +
                        rotatePoint(p2.x, p2.y, p2.z).z +
                        rotatePoint(p3.x, p3.y, p3.z).z +
                        rotatePoint(p4.x, p4.y, p4.z).z
                    ) / 4;

                    faces.push({
                        points: [p1, p2, p3, p4],
                        z: avgZ,
                        i, j
                    });
                }
            }

            // Sort by depth (back to front)
            faces.sort((a, b) => a.z - b.z);

            // Draw faces
            for (const face of faces) {
                const projected = face.points.map(p => project(p.x, p.y, p.z, width, height));

                if (wireframe) {
                    ctx.strokeStyle = `hsla(${(face.i / rings.length) * 60 + 330}, 70%, 60%, 0.6)`;
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(projected[0].x, projected[0].y);
                    for (let k = 1; k < projected.length; k++) {
                        ctx.lineTo(projected[k].x, projected[k].y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    // Calculate normal for lighting
                    const v1 = {
                        x: face.points[1].x - face.points[0].x,
                        y: face.points[1].y - face.points[0].y,
                        z: face.points[1].z - face.points[0].z
                    };
                    const v2 = {
                        x: face.points[3].x - face.points[0].x,
                        y: face.points[3].y - face.points[0].y,
                        z: face.points[3].z - face.points[0].z
                    };
                    const normal = {
                        x: v1.y * v2.z - v1.z * v2.y,
                        y: v1.z * v2.x - v1.x * v2.z,
                        z: v1.x * v2.y - v1.y * v2.x
                    };
                    const len = Math.sqrt(normal.x*normal.x + normal.y*normal.y + normal.z*normal.z);
                    normal.x /= len; normal.y /= len; normal.z /= len;

                    // Light direction
                    const light = { x: 0.5, y: 0.5, z: -1 };
                    const lightLen = Math.sqrt(light.x*light.x + light.y*light.y + light.z*light.z);
                    light.x /= lightLen; light.y /= lightLen; light.z /= lightLen;

                    const dot = Math.abs(normal.x * light.x + normal.y * light.y + normal.z * light.z);
                    const brightness = 30 + dot * 50;

                    const hue = (face.i / rings.length) * 60 + 330;
                    ctx.fillStyle = `hsl(${hue}, 70%, ${brightness}%)`;

                    ctx.beginPath();
                    ctx.moveTo(projected[0].x, projected[0].y);
                    for (let k = 1; k < projected.length; k++) {
                        ctx.lineTo(projected[k].x, projected[k].y);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // Draw axis
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            const axisStart = project(-truncPoint / 2 - 1, 0, 0, width, height);
            const axisEnd = project(truncPoint / 2 + 1, 0, 0, width, height);
            ctx.beginPath();
            ctx.moveTo(axisStart.x, axisStart.y);
            ctx.lineTo(axisEnd.x, axisEnd.y);
            ctx.stroke();

            // Labels
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '12px sans-serif';
            ctx.fillText('x = 1', project(-truncPoint / 2 + 1, 0.2, 0, width, height).x,
                        project(-truncPoint / 2 + 1, 0.2, 0, width, height).y);
            ctx.fillText(`x = ${truncPoint}`, project(truncPoint / 2, 0.1, 0, width, height).x,
                        project(truncPoint / 2, 0.1, 0, width, height).y);

            // Update stats
            const vol = calculateVolume(truncPoint);
            const surf = calculateSurface(truncPoint);
            document.getElementById('volume').textContent = vol.toFixed(4);
            document.getElementById('surface').textContent = surf.toFixed(2);
        }

        // Animation
        function animate() {
            if (!animating) return;
            rotationY += 0.01;
            draw();
            requestAnimationFrame(animate);
        }

        // Mouse interaction
        let isDragging = false;
        let lastMouse = { x: 0, y: 0 };

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouse = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - lastMouse.x;
            const dy = e.clientY - lastMouse.y;
            rotationY += dx * 0.01;
            rotationX += dy * 0.01;
            lastMouse = { x: e.clientX, y: e.clientY };
            if (!animating) draw();
        });

        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => isDragging = false);

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            zoom *= e.deltaY > 0 ? 0.9 : 1.1;
            zoom = Math.max(0.3, Math.min(3, zoom));
            if (!animating) draw();
        });

        // Controls
        document.getElementById('truncSlider').addEventListener('input', (e) => {
            truncPoint = parseInt(e.target.value);
            document.getElementById('truncValue').textContent = truncPoint;
            if (!animating) draw();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            rotationX = 0.3;
            rotationY = 0.5;
            zoom = 1;
            draw();
        });

        document.getElementById('animateBtn').addEventListener('click', () => {
            animating = !animating;
            document.getElementById('animateBtn').textContent = animating ? 'Stop' : 'Animate';
            if (animating) animate();
        });

        document.getElementById('wireframeBtn').addEventListener('click', () => {
            wireframe = !wireframe;
            document.getElementById('wireframeBtn').classList.toggle('active', wireframe);
            if (!animating) draw();
        });

        // Resize handler
        window.addEventListener('resize', () => {
            if (!animating) draw();
        });

        // Initial draw
        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
