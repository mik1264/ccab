<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Halting Problem - The Limits of Computation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            color: #e94560;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.2em;
            color: #a0a0a0;
            font-style: italic;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #e94560;
            text-decoration: none;
            font-size: 1.1em;
            z-index: 1000;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .panel {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .panel h2 {
            color: #e94560;
            margin-bottom: 20px;
            font-size: 1.4em;
        }

        /* Code Display */
        .code-box {
            background: #0d1117;
            border-radius: 10px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            margin: 15px 0;
            border: 1px solid #30363d;
            overflow-x: auto;
        }

        .code-line {
            display: block;
            padding: 3px 0;
        }

        .keyword { color: #ff7b72; }
        .function { color: #d2a8ff; }
        .string { color: #a5d6ff; }
        .comment { color: #8b949e; }
        .number { color: #79c0ff; }
        .variable { color: #ffa657; }

        /* Program Cards */
        .program-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .program-card {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .program-card:hover {
            border-color: #e94560;
            transform: translateY(-2px);
        }

        .program-card.selected {
            border-color: #2ecc71;
            background: rgba(46, 204, 113, 0.1);
        }

        .program-title {
            font-weight: bold;
            color: #f1c40f;
            margin-bottom: 8px;
        }

        .program-code {
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            color: #a0a0a0;
        }

        /* Prediction Buttons */
        .prediction-section {
            text-align: center;
            margin: 20px 0;
        }

        .prediction-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 15px 0;
        }

        button {
            background: linear-gradient(145deg, #e94560, #c73550);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1em;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: inherit;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(233,69,96,0.4);
        }

        button.halt-btn {
            background: linear-gradient(145deg, #2ecc71, #27ae60);
        }

        button.loop-btn {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
        }

        button.secondary {
            background: linear-gradient(145deg, #3498db, #2980b9);
        }

        /* Result Display */
        .result-box {
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin: 20px 0;
            display: none;
        }

        .result-box.correct {
            background: rgba(46, 204, 113, 0.2);
            border: 2px solid #2ecc71;
        }

        .result-box.incorrect {
            background: rgba(231, 76, 60, 0.2);
            border: 2px solid #e74c3c;
        }

        /* The Proof Section */
        .proof-step {
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            border-left: 4px solid #e94560;
        }

        .step-number {
            background: #e94560;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 10px;
        }

        /* Diagonal Argument Visualization */
        .diagonal-container {
            margin: 20px 0;
        }

        #diagonalCanvas {
            width: 100%;
            height: 300px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
        }

        /* Stats */
        .stats-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .stat-box {
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #f1c40f;
        }

        .stat-label {
            font-size: 0.85em;
            color: #a0a0a0;
        }

        /* Explanation */
        .explanation {
            line-height: 1.8;
        }

        .explanation h3 {
            color: #e94560;
            margin: 20px 0 10px 0;
        }

        .quote {
            border-left: 4px solid #e94560;
            padding-left: 20px;
            margin: 20px 0;
            font-style: italic;
            color: #b0b0b0;
        }

        .math-box {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
        }

        .highlight {
            color: #f1c40f;
            font-weight: bold;
        }

        .contradiction {
            color: #e74c3c;
            font-weight: bold;
        }

        ul {
            margin-left: 30px;
            line-height: 2;
        }

        /* Responsive */
        @media (max-width: 900px) {
            .main-grid {
                grid-template-columns: 1fr;
            }

            .program-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .running {
            animation: pulse 0.5s infinite;
        }

        .execution-trace {
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            margin: 10px 0;
        }

        .trace-line {
            padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .trace-line.highlight-line {
            background: rgba(233, 69, 96, 0.2);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>The Halting Problem</h1>
            <p class="subtitle">Some questions are mathematically impossible to answer</p>
        </header>

        <div class="main-grid">
            <div class="panel">
                <h2>Can You Predict If It Halts?</h2>
                <p>Select a program, then predict: will it eventually HALT (finish), or LOOP forever?</p>

                <div class="program-grid" id="programGrid">
                    <!-- Programs will be generated by JS -->
                </div>

                <div class="prediction-section">
                    <p id="selectedProgram">Select a program above</p>
                    <div class="prediction-buttons">
                        <button class="halt-btn" id="predictHalt" disabled>HALTS ✓</button>
                        <button class="loop-btn" id="predictLoop" disabled>LOOPS ∞</button>
                    </div>
                </div>

                <div class="result-box" id="resultBox">
                    <p id="resultText"></p>
                </div>

                <div class="execution-trace" id="executionTrace" style="display: none;">
                    <!-- Execution steps will appear here -->
                </div>

                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-value" id="correctCount">0</div>
                        <div class="stat-label">Correct</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="incorrectCount">0</div>
                        <div class="stat-label">Incorrect</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="accuracy">-%</div>
                        <div class="stat-label">Accuracy</div>
                    </div>
                </div>

                <button id="runProofBtn" class="secondary" style="width: 100%; margin-top: 10px;">
                    See Why No Algorithm Can Solve This →
                </button>
            </div>

            <div class="panel">
                <h2>The Impossible Algorithm</h2>
                <p>Suppose we HAD an algorithm <code>HALTS(P, I)</code> that correctly determines if program P halts on input I...</p>

                <div class="code-box">
                    <span class="code-line"><span class="keyword">def</span> <span class="function">HALTS</span>(program, input):</span>
                    <span class="code-line">    <span class="comment"># Magic oracle that always works</span></span>
                    <span class="code-line">    <span class="keyword">if</span> program_halts_on_input:</span>
                    <span class="code-line">        <span class="keyword">return</span> <span class="number">True</span></span>
                    <span class="code-line">    <span class="keyword">else</span>:</span>
                    <span class="code-line">        <span class="keyword">return</span> <span class="number">False</span></span>
                </div>

                <p style="margin: 15px 0;">Now construct this <span class="contradiction">EVIL</span> program:</p>

                <div class="code-box" style="border-color: #e74c3c;">
                    <span class="code-line"><span class="keyword">def</span> <span class="function" style="color: #e74c3c;">EVIL</span>(program):</span>
                    <span class="code-line">    <span class="keyword">if</span> HALTS(program, program):</span>
                    <span class="code-line">        <span class="keyword">while</span> <span class="number">True</span>:  <span class="comment"># Loop forever</span></span>
                    <span class="code-line">            <span class="keyword">pass</span></span>
                    <span class="code-line">    <span class="keyword">else</span>:</span>
                    <span class="code-line">        <span class="keyword">return</span>  <span class="comment"># Halt immediately</span></span>
                </div>

                <div class="proof-step">
                    <span class="step-number">?</span>
                    <strong>What happens when we run EVIL(EVIL)?</strong>
                </div>

                <div class="math-box">
                    <strong>Case 1:</strong> HALTS says EVIL(EVIL) halts<br>
                    → EVIL enters infinite loop<br>
                    → EVIL does NOT halt<br>
                    → <span class="contradiction">CONTRADICTION!</span><br><br>

                    <strong>Case 2:</strong> HALTS says EVIL(EVIL) loops<br>
                    → EVIL returns immediately<br>
                    → EVIL DOES halt<br>
                    → <span class="contradiction">CONTRADICTION!</span>
                </div>

                <p style="margin-top: 15px;">Either way, <code>HALTS</code> gives the <span class="contradiction">WRONG ANSWER</span>. Therefore, no such algorithm can exist!</p>
            </div>
        </div>

        <div class="panel">
            <h2>The Diagonal Argument (Visual)</h2>
            <p>This proof uses the same diagonal technique as Cantor's proof of uncountable infinities:</p>

            <div class="diagonal-container">
                <canvas id="diagonalCanvas" width="800" height="300"></canvas>
            </div>

            <div style="display: flex; gap: 30px; margin-top: 15px;">
                <div>
                    <span style="color: #2ecc71;">■</span> H = Halts
                </div>
                <div>
                    <span style="color: #e74c3c;">■</span> L = Loops forever
                </div>
                <div>
                    <span style="color: #f1c40f;">■</span> Diagonal (what HALTS predicts for P(P))
                </div>
                <div>
                    <span style="color: #9b59b6;">■</span> EVIL = Opposite of diagonal
                </div>
            </div>

            <button id="animateDiagonal" class="secondary" style="margin-top: 15px;">Animate Diagonal Argument</button>
        </div>

        <div class="panel explanation">
            <h2>The Paradox Explained</h2>

            <div class="quote">
                "We can never have a complete, consistent theory of mathematics. Some truths will always be beyond proof."
                <br><br>— Paraphrase of Gödel's and Turing's results
            </div>

            <h3>The Question</h3>
            <p>Given any computer program and its input, can we determine whether the program will eventually stop (halt) or run forever?</p>

            <p>At first, this seems like it should be possible — just analyze the code! But Alan Turing proved in 1936 that <span class="highlight">no algorithm can solve this for ALL programs</span>.</p>

            <h3>Why It Matters</h3>
            <ul>
                <li><strong>Virus detection</strong> — We can't perfectly detect all malware (it might be a halting-based bomb)</li>
                <li><strong>Program verification</strong> — We can't automatically verify all software is bug-free</li>
                <li><strong>Compiler optimization</strong> — We can't always determine if code is dead</li>
                <li><strong>Mathematical proofs</strong> — Some mathematical statements are undecidable</li>
            </ul>

            <h3>The Self-Reference Trick</h3>
            <p>The proof works by creating a program that <span class="highlight">asks about itself</span>. This is similar to:</p>

            <div class="math-box">
                <strong>The Liar Paradox:</strong> "This sentence is false."<br><br>
                <strong>Russell's Paradox:</strong> The set of all sets that don't contain themselves.<br><br>
                <strong>Gödel's Incompleteness:</strong> "This statement cannot be proven."<br><br>
                <strong>The Halting Problem:</strong> A program that does the opposite of what HALTS predicts.
            </div>

            <h3>What We CAN Do</h3>
            <p>While we can't solve the general halting problem, we can:</p>
            <ul>
                <li>Prove specific programs halt (through careful analysis)</li>
                <li>Use heuristics that work for "most" programs</li>
                <li>Set timeouts (if it hasn't halted in X seconds, give up)</li>
                <li>Require programmers to provide proofs of termination</li>
            </ul>

            <h3>Connection to Other Paradoxes</h3>
            <p>The Halting Problem is equivalent to many other undecidable problems:</p>
            <ul>
                <li><strong>Rice's Theorem:</strong> ANY non-trivial property of programs is undecidable</li>
                <li><strong>The Entscheidungsproblem:</strong> Decidability of first-order logic (answered "no" by Turing)</li>
                <li><strong>Post's Correspondence Problem:</strong> String matching puzzle</li>
                <li><strong>Busy Beaver:</strong> Finding the longest-running terminating program</li>
            </ul>

            <div class="quote">
                "The halting problem is undecidable not because we're not smart enough, but because the universe of computation contains inherent limits. This is as fundamental as the speed of light in physics."
            </div>

            <h3>Historical Note</h3>
            <p>Turing published this result in 1936, before electronic computers existed! He invented the theoretical "Turing Machine" specifically to prove this impossibility result. The paper "On Computable Numbers" is one of the most important in computer science history.</p>
        </div>
    </div>

    <script>
        // Sample programs for the game
        const PROGRAMS = [
            {
                id: 1,
                name: "Simple Counter",
                code: "for i in range(10):\n    print(i)",
                halts: true,
                explanation: "Counts from 0 to 9, then stops."
            },
            {
                id: 2,
                name: "Infinite Loop",
                code: "while True:\n    pass",
                halts: false,
                explanation: "The condition is always True, so it never stops."
            },
            {
                id: 3,
                name: "Conditional Loop",
                code: "x = 100\nwhile x > 0:\n    x = x - 1",
                halts: true,
                explanation: "x decreases by 1 each iteration until it reaches 0."
            },
            {
                id: 4,
                name: "Collatz-like",
                code: "n = 27\nwhile n != 1:\n    if n % 2 == 0:\n        n = n // 2\n    else:\n        n = 3*n + 1",
                halts: true,
                explanation: "This is the Collatz sequence! 27 eventually reaches 1."
            },
            {
                id: 5,
                name: "Mystery Loop",
                code: "x = 1\nwhile x != 0:\n    x = (x * 2) % 7",
                halts: false,
                explanation: "x cycles through 1,2,4,1,2,4... never hitting 0."
            },
            {
                id: 6,
                name: "Goldbach Check",
                code: "# Check first 1000 evens\nfor n in range(4, 1000, 2):\n    # ... prime check",
                halts: true,
                explanation: "Checks a finite range, so it terminates."
            },
            {
                id: 7,
                name: "Prime Search",
                code: "n = 2\nwhile True:\n    if is_prime(n):\n        if n > 1000000:\n            break\n    n += 1",
                halts: true,
                explanation: "Searches for primes > 1M. The 78498th prime is 999983."
            },
            {
                id: 8,
                name: "Self-Reference",
                code: "def f():\n    if halts(f):\n        while True: pass\n    else:\n        return\nf()",
                halts: null,
                explanation: "This is the EVIL program! It creates a paradox."
            }
        ];

        // State
        let selectedProgram = null;
        let correctCount = 0;
        let incorrectCount = 0;

        // DOM elements
        const programGrid = document.getElementById('programGrid');
        const predictHalt = document.getElementById('predictHalt');
        const predictLoop = document.getElementById('predictLoop');
        const resultBox = document.getElementById('resultBox');
        const resultText = document.getElementById('resultText');
        const executionTrace = document.getElementById('executionTrace');
        const diagonalCanvas = document.getElementById('diagonalCanvas');
        const diagonalCtx = diagonalCanvas.getContext('2d');

        // Initialize
        renderPrograms();
        drawDiagonalArgument();
        setupEventListeners();

        function renderPrograms() {
            programGrid.innerHTML = PROGRAMS.map(p => `
                <div class="program-card" data-id="${p.id}">
                    <div class="program-title">Program ${p.id}: ${p.name}</div>
                    <div class="program-code">${escapeHtml(p.code.split('\n')[0])}...</div>
                </div>
            `).join('');

            document.querySelectorAll('.program-card').forEach(card => {
                card.addEventListener('click', () => selectProgram(parseInt(card.dataset.id)));
            });
        }

        function escapeHtml(text) {
            return text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        function selectProgram(id) {
            selectedProgram = PROGRAMS.find(p => p.id === id);

            document.querySelectorAll('.program-card').forEach(card => {
                card.classList.toggle('selected', parseInt(card.dataset.id) === id);
            });

            document.getElementById('selectedProgram').innerHTML = `
                <strong>Program ${id}: ${selectedProgram.name}</strong><br>
                <div class="code-box" style="text-align: left; margin-top: 10px;">
                    ${selectedProgram.code.split('\n').map(line =>
                        `<span class="code-line">${escapeHtml(line)}</span>`
                    ).join('')}
                </div>
            `;

            predictHalt.disabled = false;
            predictLoop.disabled = false;
            resultBox.style.display = 'none';
            executionTrace.style.display = 'none';
        }

        function setupEventListeners() {
            predictHalt.addEventListener('click', () => makePrediction(true));
            predictLoop.addEventListener('click', () => makePrediction(false));

            document.getElementById('runProofBtn').addEventListener('click', showProofAnimation);
            document.getElementById('animateDiagonal').addEventListener('click', animateDiagonal);
        }

        function makePrediction(predictedHalt) {
            if (!selectedProgram) return;

            const actualHalts = selectedProgram.halts;

            resultBox.style.display = 'block';
            executionTrace.style.display = 'block';

            if (actualHalts === null) {
                // The paradox program
                resultBox.className = 'result-box incorrect';
                resultText.innerHTML = `
                    <strong>PARADOX!</strong><br><br>
                    This is the EVIL program from Turing's proof!<br>
                    If we say it halts → it loops. If we say it loops → it halts.<br>
                    <span style="color: #e74c3c;">No correct answer exists!</span>
                `;
                executionTrace.innerHTML = `
                    <div class="trace-line">→ Calling halts(EVIL, EVIL)...</div>
                    <div class="trace-line highlight-line">→ If halts returns TRUE: enter infinite loop</div>
                    <div class="trace-line highlight-line">→ If halts returns FALSE: return immediately</div>
                    <div class="trace-line" style="color: #e74c3c;">→ Either way, halts() is WRONG!</div>
                `;
            } else {
                const correct = predictedHalt === actualHalts;

                if (correct) {
                    correctCount++;
                    resultBox.className = 'result-box correct';
                    resultText.innerHTML = `
                        <strong>CORRECT!</strong><br>
                        The program ${actualHalts ? 'HALTS' : 'LOOPS FOREVER'}.<br>
                        ${selectedProgram.explanation}
                    `;
                } else {
                    incorrectCount++;
                    resultBox.className = 'result-box incorrect';
                    resultText.innerHTML = `
                        <strong>INCORRECT!</strong><br>
                        The program actually ${actualHalts ? 'HALTS' : 'LOOPS FOREVER'}.<br>
                        ${selectedProgram.explanation}
                    `;
                }

                // Show execution trace
                showExecutionTrace(selectedProgram);

                // Update stats
                document.getElementById('correctCount').textContent = correctCount;
                document.getElementById('incorrectCount').textContent = incorrectCount;
                const total = correctCount + incorrectCount;
                document.getElementById('accuracy').textContent =
                    total > 0 ? Math.round(correctCount / total * 100) + '%' : '-%';
            }
        }

        function showExecutionTrace(program) {
            let trace = '';
            if (program.halts) {
                trace = `
                    <div class="trace-line">→ Starting execution...</div>
                    <div class="trace-line">→ Processing...</div>
                    <div class="trace-line">→ ...</div>
                    <div class="trace-line" style="color: #2ecc71;">→ Program terminated normally ✓</div>
                `;
            } else {
                trace = `
                    <div class="trace-line">→ Starting execution...</div>
                    <div class="trace-line">→ Iteration 1...</div>
                    <div class="trace-line">→ Iteration 2...</div>
                    <div class="trace-line">→ Iteration 1000...</div>
                    <div class="trace-line">→ Iteration 1000000...</div>
                    <div class="trace-line running" style="color: #e74c3c;">→ Still running... ∞</div>
                `;
            }
            executionTrace.innerHTML = trace;
        }

        function drawDiagonalArgument() {
            const w = diagonalCanvas.width;
            const h = diagonalCanvas.height;
            diagonalCtx.clearRect(0, 0, w, h);

            const programs = ['P₁', 'P₂', 'P₃', 'P₄', 'P₅', 'EVIL'];
            const n = programs.length;
            const cellSize = 40;
            const startX = 100;
            const startY = 50;

            // Draw column headers (inputs)
            diagonalCtx.fillStyle = '#a0a0a0';
            diagonalCtx.font = '14px Georgia';
            diagonalCtx.fillText('Input →', startX - 80, startY - 10);

            programs.forEach((p, i) => {
                diagonalCtx.fillText(p, startX + i * cellSize + 10, startY - 10);
            });

            // Draw row headers (programs)
            diagonalCtx.fillText('Program ↓', startX - 80, startY + 20);

            // Generate random halting matrix (for visualization)
            const matrix = [];
            for (let i = 0; i < n - 1; i++) {
                matrix[i] = [];
                for (let j = 0; j < n; j++) {
                    matrix[i][j] = Math.random() > 0.5;
                }
            }

            // Draw the matrix
            for (let i = 0; i < n - 1; i++) {
                // Row label
                diagonalCtx.fillStyle = '#a0a0a0';
                diagonalCtx.fillText(programs[i], startX - 30, startY + i * cellSize + 25);

                for (let j = 0; j < n - 1; j++) {
                    const x = startX + j * cellSize;
                    const y = startY + i * cellSize;

                    // Cell color
                    if (i === j) {
                        // Diagonal - yellow
                        diagonalCtx.fillStyle = '#f1c40f';
                    } else {
                        diagonalCtx.fillStyle = matrix[i][j] ? '#2ecc71' : '#e74c3c';
                    }

                    diagonalCtx.fillRect(x, y, cellSize - 2, cellSize - 2);

                    // Cell text
                    diagonalCtx.fillStyle = '#000';
                    diagonalCtx.font = 'bold 14px Georgia';
                    diagonalCtx.fillText(matrix[i][j] ? 'H' : 'L', x + 15, y + 25);
                }
            }

            // Draw EVIL row
            const evilY = startY + (n - 1) * cellSize;
            diagonalCtx.fillStyle = '#9b59b6';
            diagonalCtx.font = '14px Georgia';
            diagonalCtx.fillText('EVIL', startX - 35, evilY + 25);

            for (let j = 0; j < n - 1; j++) {
                const x = startX + j * cellSize;

                // EVIL does opposite of diagonal
                const diagonalHalts = matrix[j] ? matrix[j][j] : true;
                diagonalCtx.fillStyle = '#9b59b6';
                diagonalCtx.fillRect(x, evilY, cellSize - 2, cellSize - 2);

                diagonalCtx.fillStyle = '#fff';
                diagonalCtx.font = 'bold 14px Georgia';
                diagonalCtx.fillText(diagonalHalts ? 'L' : 'H', x + 15, evilY + 25);
            }

            // Draw EVIL(EVIL) cell with question mark
            const evilX = startX + (n - 1) * cellSize;
            diagonalCtx.fillStyle = '#e74c3c';
            diagonalCtx.fillRect(evilX, evilY, cellSize - 2, cellSize - 2);
            diagonalCtx.fillStyle = '#fff';
            diagonalCtx.font = 'bold 20px Georgia';
            diagonalCtx.fillText('?', evilX + 13, evilY + 28);

            // Explanation text
            diagonalCtx.fillStyle = '#e0e0e0';
            diagonalCtx.font = '12px Georgia';
            const explanationX = startX + n * cellSize + 20;
            diagonalCtx.fillText('EVIL does the OPPOSITE', explanationX, startY + 20);
            diagonalCtx.fillText('of what HALTS predicts', explanationX, startY + 40);
            diagonalCtx.fillText('for P(P).', explanationX, startY + 60);
            diagonalCtx.fillText('', explanationX, startY + 90);
            diagonalCtx.fillStyle = '#e74c3c';
            diagonalCtx.fillText('EVIL(EVIL) = ?', explanationX, startY + 110);
            diagonalCtx.fillText('No answer works!', explanationX, startY + 130);
        }

        function animateDiagonal() {
            // Redraw with animation highlighting the diagonal construction
            let step = 0;
            const maxSteps = 6;

            function animateStep() {
                if (step > maxSteps) {
                    setTimeout(drawDiagonalArgument, 1000);
                    return;
                }

                drawDiagonalArgument();

                // Highlight current step
                const cellSize = 40;
                const startX = 100;
                const startY = 50;

                if (step < 5) {
                    // Highlight diagonal element
                    diagonalCtx.strokeStyle = '#fff';
                    diagonalCtx.lineWidth = 3;
                    diagonalCtx.strokeRect(startX + step * cellSize, startY + step * cellSize, cellSize - 2, cellSize - 2);

                    // Draw arrow to EVIL row
                    diagonalCtx.beginPath();
                    diagonalCtx.strokeStyle = '#9b59b6';
                    diagonalCtx.moveTo(startX + step * cellSize + cellSize/2, startY + step * cellSize + cellSize);
                    diagonalCtx.lineTo(startX + step * cellSize + cellSize/2, startY + 5 * cellSize + cellSize/2);
                    diagonalCtx.stroke();
                }

                step++;
                setTimeout(animateStep, 800);
            }

            animateStep();
        }

        function showProofAnimation() {
            // Scroll to and highlight the proof section
            document.querySelector('.main-grid').scrollIntoView({ behavior: 'smooth' });

            // Flash the proof steps
            const proofSteps = document.querySelectorAll('.proof-step, .math-box');
            let i = 0;

            function flashNext() {
                if (i > 0) {
                    proofSteps[i - 1].style.boxShadow = 'none';
                }
                if (i < proofSteps.length) {
                    proofSteps[i].style.boxShadow = '0 0 20px #e94560';
                    i++;
                    setTimeout(flashNext, 1500);
                }
            }

            flashNext();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
