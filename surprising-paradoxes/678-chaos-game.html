<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Chaos Game - Order from Randomness</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e8e8e8;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1500px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 25px;
        }

        h1 {
            font-size: 2.2rem;
            background: linear-gradient(135deg, #e74c3c, #f39c12, #2ecc71);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #aaa;
            font-size: 1.1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 25px;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .viz-section {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 20px;
        }

        .canvas-container {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
            position: relative;
        }

        canvas {
            border-radius: 8px;
            background: #0a0a0a;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.3s;
            position: relative;
        }

        .btn-primary {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: #fff;
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .btn-export {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: #fff;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .btn.active {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            position: relative;
        }

        .control-group label {
            font-size: 0.85rem;
            color: #aaa;
        }

        select {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.5);
            color: #fff;
            font-size: 0.9rem;
        }

        input[type="range"] {
            width: 100px;
            accent-color: #e74c3c;
        }

        .stats-display {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-box {
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #e74c3c;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .exp-card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 18px;
            border-left: 4px solid #e74c3c;
            position: relative;
        }

        .exp-card h3 {
            color: #e74c3c;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .exp-card p {
            color: #ccc;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .formula {
            background: rgba(0,0,0,0.4);
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            color: #e74c3c;
            text-align: center;
            font-size: 0.9rem;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #e74c3c;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            opacity: 0.8;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .back-link:hover {
            opacity: 1;
        }

        .highlight {
            color: #f39c12;
            font-weight: bold;
        }

        .vertices-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 15px;
            justify-content: center;
        }

        .vertex-tag {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        /* Tooltip styles */
        .tooltip {
            position: relative;
            cursor: help;
        }

        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 1000;
            max-width: 250px;
            white-space: normal;
            text-align: center;
        }

        .tooltip:hover::after {
            opacity: 1;
        }

        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            font-size: 0.7rem;
            color: #fff;
            margin-left: 4px;
            cursor: help;
        }

        /* Statistics Panel */
        .statistics-panel {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .statistics-panel h4 {
            color: #f39c12;
            margin-bottom: 12px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 0.85rem;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-row .label {
            color: #888;
        }

        .stat-row .value {
            color: #2ecc71;
            font-family: 'Courier New', monospace;
        }

        /* Color scheme indicator */
        .color-preview {
            display: flex;
            gap: 3px;
            margin-left: 8px;
        }

        .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.3);
        }

        /* Step indicator overlay */
        .step-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            color: #fff;
            pointer-events: none;
        }

        /* Educational overlay */
        .edu-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.8rem;
            color: #fff;
            max-width: 200px;
            border: 1px solid rgba(231, 76, 60, 0.5);
            transition: opacity 0.3s;
        }

        .edu-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .edu-overlay h5 {
            color: #e74c3c;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }

        .edu-toggle {
            font-size: 0.75rem;
            padding: 6px 12px;
        }

        /* Export modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .modal {
            background: #1a1a2e;
            border-radius: 15px;
            padding: 25px;
            max-width: 400px;
            width: 90%;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .modal h3 {
            color: #e74c3c;
            margin-bottom: 15px;
        }

        .modal-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .modal-option {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-option label {
            color: #aaa;
            font-size: 0.9rem;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        /* Iteration count display */
        .iteration-display {
            font-family: 'Courier New', monospace;
            color: #f39c12;
            font-size: 0.9rem;
            min-width: 60px;
            text-align: right;
        }

        /* Progress bar */
        .progress-container {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12);
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>The Chaos Game</h1>
            <p class="subtitle">Michael Barnsley - Order Emerges from Random Jumps</p>
        </header>

        <div class="main-content">
            <div class="viz-section">
                <div class="canvas-container">
                    <canvas id="chaosCanvas" width="700" height="600"></canvas>
                    <div class="step-indicator" id="stepIndicator">Click Start to begin</div>
                    <div class="edu-overlay" id="eduOverlay">
                        <h5>Current Step</h5>
                        <p id="eduText">The chaos game starts by picking a random point inside the polygon. Each iteration, we jump halfway toward a randomly chosen vertex.</p>
                    </div>
                </div>

                <div class="controls">
                    <button class="btn btn-primary" id="startBtn">Start</button>
                    <button class="btn btn-secondary" id="stepBtn">Step x100</button>
                    <button class="btn btn-secondary" id="resetBtn">Reset</button>
                    <button class="btn btn-export" id="exportBtn">Export PNG</button>
                    <button class="btn edu-toggle" id="eduToggle">Hide Tips</button>

                    <div class="control-group tooltip" data-tooltip="More vertices create different fractal patterns">
                        <label>Shape:</label>
                        <select id="shapeSelect">
                            <option value="3">Triangle (Sierpinski)</option>
                            <option value="4">Square</option>
                            <option value="5">Pentagon</option>
                            <option value="6">Hexagon</option>
                            <option value="8">Octagon</option>
                        </select>
                        <span class="info-icon">?</span>
                    </div>

                    <div class="control-group tooltip" data-tooltip="The fraction of distance to jump toward each vertex. 0.5 gives the classic Sierpinski triangle">
                        <label>Ratio:</label>
                        <input type="range" id="ratioSlider" min="0.3" max="0.7" step="0.01" value="0.5">
                        <span id="ratioValue">0.50</span>
                        <span class="info-icon">?</span>
                    </div>

                    <div class="control-group tooltip" data-tooltip="How many points to plot per animation frame">
                        <label>Speed:</label>
                        <select id="speedSelect">
                            <option value="1">Slow (1/frame)</option>
                            <option value="10">Medium (10/frame)</option>
                            <option value="100" selected>Fast (100/frame)</option>
                            <option value="1000">Turbo (1000/frame)</option>
                        </select>
                    </div>

                    <div class="control-group tooltip" data-tooltip="Total iterations to run. More iterations reveal finer fractal detail">
                        <label>Iterations:</label>
                        <input type="range" id="iterSlider" min="1000" max="100000" step="1000" value="50000">
                        <span class="iteration-display" id="iterValue">50,000</span>
                    </div>

                    <div class="control-group tooltip" data-tooltip="Different color schemes for visualization">
                        <label>Colors:</label>
                        <select id="colorSelect">
                            <option value="vertex">By Vertex</option>
                            <option value="rainbow">Rainbow Gradient</option>
                            <option value="heat">Heat Map</option>
                            <option value="cool">Cool Tones</option>
                            <option value="mono">Monochrome</option>
                            <option value="neon">Neon</option>
                        </select>
                        <div class="color-preview" id="colorPreview"></div>
                    </div>
                </div>

                <div class="progress-container">
                    <div class="progress-bar" id="progressBar"></div>
                </div>

                <div class="stats-display">
                    <div class="stat-box">
                        <div class="stat-label">Points</div>
                        <div class="stat-value" id="pointCount">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Jump Ratio</div>
                        <div class="stat-value" id="jumpRatio">1/2</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Vertices</div>
                        <div class="stat-value" id="vertexCount">3</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Target</div>
                        <div class="stat-value" id="targetCount">50K</div>
                    </div>
                </div>

                <div class="vertices-legend" id="verticesLegend"></div>

                <div class="statistics-panel">
                    <h4>Detailed Statistics</h4>
                    <div class="stat-row">
                        <span class="label">Points per Second:</span>
                        <span class="value" id="pps">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="label">Vertex Distribution:</span>
                        <span class="value" id="vertexDist">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="label">Fractal Dimension (est):</span>
                        <span class="value" id="fractalDim">~1.585</span>
                    </div>
                    <div class="stat-row">
                        <span class="label">Coverage Area:</span>
                        <span class="value" id="coverageArea">0%</span>
                    </div>
                    <div class="stat-row">
                        <span class="label">Last Vertex:</span>
                        <span class="value" id="lastVertex">-</span>
                    </div>
                </div>
            </div>

            <div class="sidebar">
                <div class="exp-card">
                    <h3>The Paradox of Random Order</h3>
                    <p>Pick <span class="highlight">any starting point</span>. Repeatedly jump <span class="highlight">halfway</span> toward a randomly chosen vertex. After thousands of jumps, a perfect <span class="highlight">Sierpinski Triangle</span> emerges! Pure randomness creates exact structure.</p>
                </div>

                <div class="exp-card">
                    <h3>The Algorithm</h3>
                    <p>Start at point P. Each step:</p>
                    <div class="formula">
                        P_new = P + r * (V - P)
                    </div>
                    <p>Where V is a random vertex and r is the ratio (typically 0.5). For triangles, r=0.5 gives the Sierpinski gasket.</p>
                </div>

                <div class="exp-card">
                    <h3>Iterated Function Systems</h3>
                    <p>Michael Barnsley's book <span class="highlight">"Fractals Everywhere"</span> (1988) proved this works because fractals are attractors of IFS. Any starting point converges to the same fractal pattern!</p>
                </div>

                <div class="exp-card">
                    <h3>Different Shapes</h3>
                    <p>With a <span class="highlight">square</span>, ratio 0.5 fills everything. But with restrictions (can't jump to previous vertex), beautiful patterns emerge. Pentagons and hexagons create stunning variations with the right ratios!</p>
                </div>

                <div class="exp-card">
                    <h3>Why Does This Work?</h3>
                    <p>The key insight: points that would land <span class="highlight">outside</span> the attractor become increasingly rare. The "forbidden regions" (like the center of the Sierpinski triangle) are self-similar - they appear at every scale, creating the fractal structure.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="modal-overlay" id="exportModal">
        <div class="modal">
            <h3>Export Pattern</h3>
            <div class="modal-options">
                <div class="modal-option">
                    <label>Resolution:</label>
                    <select id="exportResolution">
                        <option value="1">Standard (1x)</option>
                        <option value="2" selected>High (2x)</option>
                        <option value="4">Ultra (4x)</option>
                    </select>
                </div>
                <div class="modal-option">
                    <label>Background:</label>
                    <select id="exportBackground">
                        <option value="black">Black</option>
                        <option value="white">White</option>
                        <option value="transparent">Transparent</option>
                    </select>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-secondary" id="cancelExport">Cancel</button>
                <button class="btn btn-primary" id="confirmExport">Download</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('chaosCanvas');
        const ctx = canvas.getContext('2d');

        let vertices = [];
        let currentPoint = null;
        let points = [];
        let running = false;
        let animationId = null;
        let lastVertexIndex = -1;
        let vertexCounts = [];
        let startTime = null;
        let pointsAtStart = 0;

        // Color schemes
        const colorSchemes = {
            vertex: null, // Uses vertex colors
            rainbow: (i, total) => `hsl(${(i / total) * 360}, 80%, 60%)`,
            heat: (i, total) => {
                const t = i / total;
                if (t < 0.5) return `rgb(${Math.floor(t * 2 * 255)}, 0, 0)`;
                return `rgb(255, ${Math.floor((t - 0.5) * 2 * 255)}, 0)`;
            },
            cool: (i, total) => {
                const t = i / total;
                return `hsl(${200 + t * 80}, 70%, ${40 + t * 30}%)`;
            },
            mono: () => '#e8e8e8',
            neon: (i, total) => {
                const hues = [320, 180, 60, 280, 120];
                return `hsl(${hues[i % hues.length]}, 100%, 60%)`;
            }
        };

        const vertexColors = [
            '#e74c3c', '#f39c12', '#2ecc71',
            '#3498db', '#9b59b6', '#1abc9c',
            '#e67e22', '#1abc9c'
        ];

        // Educational texts
        const eduTexts = {
            start: "The chaos game starts by picking a random point inside the polygon. Each iteration, we jump halfway toward a randomly chosen vertex.",
            running: "Watch as points accumulate! Notice how certain regions never get filled - these 'forbidden zones' create the fractal structure.",
            triangle: "The triangle creates the famous Sierpinski Gasket - a fractal with dimension log(3)/log(2) ≈ 1.585",
            square: "With a square and ratio 0.5, the entire area fills uniformly. Try changing the ratio!",
            pentagon: "Pentagons create beautiful 5-fold symmetric patterns. The ratio affects which regions remain empty.",
            hexagon: "Hexagonal patterns show 6-fold symmetry. Lower ratios create more intricate designs.",
            octagon: "Octagons reveal 8-fold symmetric fractals with fascinating self-similar patterns."
        };

        function generateVertices(n) {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const radius = Math.min(cx, cy) - 40;
            const verts = [];

            for (let i = 0; i < n; i++) {
                const angle = (i / n) * Math.PI * 2 - Math.PI / 2;
                verts.push({
                    x: cx + radius * Math.cos(angle),
                    y: cy + radius * Math.sin(angle),
                    color: vertexColors[i % vertexColors.length]
                });
            }
            return verts;
        }

        function drawVertices() {
            vertices.forEach((v, i) => {
                ctx.beginPath();
                ctx.arc(v.x, v.y, 8, 0, Math.PI * 2);
                ctx.fillStyle = v.color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const labelRadius = Math.min(canvas.width, canvas.height) / 2 - 15;
                const angle = (i / vertices.length) * Math.PI * 2 - Math.PI / 2;
                ctx.fillText(
                    String.fromCharCode(65 + i),
                    canvas.width / 2 + labelRadius * Math.cos(angle),
                    canvas.height / 2 + labelRadius * Math.sin(angle)
                );
            });
        }

        function getPointColor(index) {
            const scheme = document.getElementById('colorSelect').value;
            if (scheme === 'vertex') {
                return points[index].vertexColor;
            }
            return colorSchemes[scheme](index, points.length);
        }

        function drawPoints() {
            const scheme = document.getElementById('colorSelect').value;

            if (scheme === 'vertex') {
                points.forEach(p => {
                    ctx.fillStyle = p.vertexColor;
                    ctx.fillRect(p.x, p.y, 1, 1);
                });
            } else {
                points.forEach((p, i) => {
                    ctx.fillStyle = colorSchemes[scheme](i, points.length);
                    ctx.fillRect(p.x, p.y, 1, 1);
                });
            }
        }

        function drawCurrentPoint() {
            if (currentPoint) {
                ctx.beginPath();
                ctx.arc(currentPoint.x, currentPoint.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
            }
        }

        function draw() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < vertices.length; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            ctx.stroke();

            drawPoints();
            drawVertices();
            drawCurrentPoint();

            updateStats();
        }

        function updateStats() {
            document.getElementById('pointCount').textContent = points.length.toLocaleString();

            const maxIter = parseInt(document.getElementById('iterSlider').value);
            const progress = (points.length / maxIter) * 100;
            document.getElementById('progressBar').style.width = progress + '%';

            // Points per second
            if (running && startTime) {
                const elapsed = (Date.now() - startTime) / 1000;
                const pps = Math.floor((points.length - pointsAtStart) / elapsed);
                document.getElementById('pps').textContent = pps.toLocaleString();
            }

            // Vertex distribution
            if (vertexCounts.length > 0) {
                const total = vertexCounts.reduce((a, b) => a + b, 0);
                if (total > 0) {
                    const dist = vertexCounts.map(c => Math.round((c / total) * 100));
                    document.getElementById('vertexDist').textContent = dist.join('% / ') + '%';
                }
            }

            // Last vertex
            if (lastVertexIndex >= 0) {
                document.getElementById('lastVertex').textContent = String.fromCharCode(65 + lastVertexIndex);
            }

            // Estimated coverage
            const coveragePercent = Math.min(100, (points.length / 10000) * 100).toFixed(1);
            document.getElementById('coverageArea').textContent = coveragePercent + '%';

            // Fractal dimension estimate
            const n = vertices.length;
            const ratio = parseFloat(document.getElementById('ratioSlider').value);
            const dim = Math.log(n) / Math.log(1 / ratio);
            document.getElementById('fractalDim').textContent = '~' + dim.toFixed(3);
        }

        function step(count = 1) {
            if (!currentPoint) {
                currentPoint = {
                    x: canvas.width / 2 + (Math.random() - 0.5) * 100,
                    y: canvas.height / 2 + (Math.random() - 0.5) * 100
                };
            }

            const ratio = parseFloat(document.getElementById('ratioSlider').value);
            const maxIter = parseInt(document.getElementById('iterSlider').value);

            for (let i = 0; i < count && points.length < maxIter; i++) {
                const vertexIndex = Math.floor(Math.random() * vertices.length);
                const vertex = vertices[vertexIndex];
                lastVertexIndex = vertexIndex;
                vertexCounts[vertexIndex]++;

                currentPoint = {
                    x: currentPoint.x + ratio * (vertex.x - currentPoint.x),
                    y: currentPoint.y + ratio * (vertex.y - currentPoint.y)
                };

                points.push({
                    x: currentPoint.x,
                    y: currentPoint.y,
                    vertexColor: vertex.color
                });
            }

            // Check if we've reached the target
            if (points.length >= maxIter) {
                running = false;
                document.getElementById('startBtn').textContent = 'Complete';
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stepIndicator').textContent = 'Simulation complete!';
                updateEduText('complete');
            }
        }

        function animate() {
            if (!running) return;

            const speed = parseInt(document.getElementById('speedSelect').value);
            step(speed);
            draw();

            if (running) {
                animationId = requestAnimationFrame(animate);
            }
        }

        function start() {
            if (running) {
                running = false;
                document.getElementById('startBtn').textContent = 'Start';
                document.getElementById('stepIndicator').textContent = 'Paused';
                if (animationId) cancelAnimationFrame(animationId);
            } else {
                running = true;
                document.getElementById('startBtn').textContent = 'Pause';
                document.getElementById('stepIndicator').textContent = 'Running...';
                updateEduText('running');
                if (!startTime) {
                    startTime = Date.now();
                    pointsAtStart = points.length;
                }
                animate();
            }
        }

        function reset() {
            running = false;
            document.getElementById('startBtn').textContent = 'Start';
            document.getElementById('startBtn').disabled = false;
            if (animationId) cancelAnimationFrame(animationId);

            const n = parseInt(document.getElementById('shapeSelect').value);
            vertices = generateVertices(n);
            currentPoint = null;
            points = [];
            lastVertexIndex = -1;
            vertexCounts = new Array(n).fill(0);
            startTime = null;
            pointsAtStart = 0;

            document.getElementById('vertexCount').textContent = n;
            document.getElementById('stepIndicator').textContent = 'Click Start to begin';
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('pps').textContent = '0';
            document.getElementById('vertexDist').textContent = '-';
            document.getElementById('lastVertex').textContent = '-';

            // Update target display
            const maxIter = parseInt(document.getElementById('iterSlider').value);
            document.getElementById('targetCount').textContent = formatNumber(maxIter);

            updateLegend();
            updateColorPreview();
            updateEduText(n === 3 ? 'triangle' : n === 4 ? 'square' : n === 5 ? 'pentagon' : n === 6 ? 'hexagon' : 'octagon');
            draw();
        }

        function formatNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(0) + 'K';
            return num.toString();
        }

        function updateLegend() {
            const legend = document.getElementById('verticesLegend');
            legend.innerHTML = '';
            vertices.forEach((v, i) => {
                const tag = document.createElement('span');
                tag.className = 'vertex-tag';
                tag.style.background = v.color;
                tag.style.color = '#fff';
                tag.textContent = String.fromCharCode(65 + i);
                legend.appendChild(tag);
            });
        }

        function updateColorPreview() {
            const preview = document.getElementById('colorPreview');
            const scheme = document.getElementById('colorSelect').value;
            preview.innerHTML = '';

            let colors;
            if (scheme === 'vertex') {
                colors = vertices.slice(0, 4).map(v => v.color);
            } else if (scheme === 'rainbow') {
                colors = ['#ff0000', '#ffff00', '#00ff00', '#00ffff'];
            } else if (scheme === 'heat') {
                colors = ['#330000', '#ff0000', '#ff8800', '#ffff00'];
            } else if (scheme === 'cool') {
                colors = ['#0066aa', '#00aacc', '#00ccee', '#66eeff'];
            } else if (scheme === 'mono') {
                colors = ['#e8e8e8', '#cccccc', '#aaaaaa', '#888888'];
            } else if (scheme === 'neon') {
                colors = ['#ff00aa', '#00ffff', '#ffff00', '#aa00ff'];
            }

            colors.forEach(c => {
                const dot = document.createElement('div');
                dot.className = 'color-dot';
                dot.style.background = c;
                preview.appendChild(dot);
            });
        }

        function updateEduText(key) {
            const text = eduTexts[key] || eduTexts.start;
            document.getElementById('eduText').textContent = text;
        }

        function toggleEduOverlay() {
            const overlay = document.getElementById('eduOverlay');
            const btn = document.getElementById('eduToggle');
            overlay.classList.toggle('hidden');
            btn.textContent = overlay.classList.contains('hidden') ? 'Show Tips' : 'Hide Tips';
        }

        // Export functionality
        function showExportModal() {
            document.getElementById('exportModal').classList.add('visible');
        }

        function hideExportModal() {
            document.getElementById('exportModal').classList.remove('visible');
        }

        function exportImage() {
            const scale = parseInt(document.getElementById('exportResolution').value);
            const bgOption = document.getElementById('exportBackground').value;

            // Create high-res canvas
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = canvas.width * scale;
            exportCanvas.height = canvas.height * scale;
            const exportCtx = exportCanvas.getContext('2d');

            // Background
            if (bgOption === 'black') {
                exportCtx.fillStyle = '#0a0a0a';
                exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            } else if (bgOption === 'white') {
                exportCtx.fillStyle = '#ffffff';
                exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            }

            // Draw scaled points
            const scheme = document.getElementById('colorSelect').value;
            points.forEach((p, i) => {
                if (scheme === 'vertex') {
                    exportCtx.fillStyle = p.vertexColor;
                } else {
                    exportCtx.fillStyle = colorSchemes[scheme](i, points.length);
                }
                exportCtx.fillRect(p.x * scale, p.y * scale, scale, scale);
            });

            // Draw vertices
            vertices.forEach((v, i) => {
                exportCtx.beginPath();
                exportCtx.arc(v.x * scale, v.y * scale, 8 * scale, 0, Math.PI * 2);
                exportCtx.fillStyle = v.color;
                exportCtx.fill();
                exportCtx.strokeStyle = '#fff';
                exportCtx.lineWidth = 2 * scale;
                exportCtx.stroke();
            });

            // Download
            const link = document.createElement('a');
            link.download = `chaos-game-${vertices.length}gon-${points.length}pts.png`;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();

            hideExportModal();
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', start);
        document.getElementById('stepBtn').addEventListener('click', () => {
            step(100);
            draw();
        });
        document.getElementById('resetBtn').addEventListener('click', reset);
        document.getElementById('exportBtn').addEventListener('click', showExportModal);
        document.getElementById('cancelExport').addEventListener('click', hideExportModal);
        document.getElementById('confirmExport').addEventListener('click', exportImage);
        document.getElementById('eduToggle').addEventListener('click', toggleEduOverlay);

        document.getElementById('shapeSelect').addEventListener('change', reset);

        document.getElementById('colorSelect').addEventListener('change', () => {
            updateColorPreview();
            draw();
        });

        document.getElementById('ratioSlider').addEventListener('input', (e) => {
            const ratio = parseFloat(e.target.value);
            document.getElementById('ratioValue').textContent = ratio.toFixed(2);

            let fractionStr;
            if (Math.abs(ratio - 0.5) < 0.01) fractionStr = '1/2';
            else if (Math.abs(ratio - 0.333) < 0.01) fractionStr = '1/3';
            else if (Math.abs(ratio - 0.667) < 0.01) fractionStr = '2/3';
            else fractionStr = ratio.toFixed(2);

            document.getElementById('jumpRatio').textContent = fractionStr;
        });

        document.getElementById('iterSlider').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            document.getElementById('iterValue').textContent = val.toLocaleString();
            document.getElementById('targetCount').textContent = formatNumber(val);
        });

        // Close modal on overlay click
        document.getElementById('exportModal').addEventListener('click', (e) => {
            if (e.target === document.getElementById('exportModal')) {
                hideExportModal();
            }
        });

        // Initialize
        reset();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
