<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Scars - Order in Chaos | Surprising Paradoxes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #0a0014 0%, #1a0a2e 50%, #0d0020 100%);
            color: #e0d8f0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #bb86fc;
            text-decoration: none;
            font-size: 14px;
            z-index: 1000;
            padding: 8px 16px;
            background: rgba(20, 10, 40, 0.9);
            border-radius: 20px;
            border: 1px solid rgba(187, 134, 252, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(187, 134, 252, 0.2);
            border-color: #bb86fc;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 80px 20px 40px;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(135deg, #bb86fc, #03dac6, #cf6679);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #bb86fc;
            font-size: 1.2em;
            font-style: italic;
        }

        .paradox-box {
            background: linear-gradient(135deg, rgba(187, 134, 252, 0.15), rgba(3, 218, 198, 0.1));
            border: 2px solid rgba(187, 134, 252, 0.4);
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
            text-align: center;
        }

        .paradox-box h3 {
            color: #03dac6;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .paradox-box p {
            font-size: 1.15em;
            line-height: 1.7;
            color: #e8ddf5;
        }

        .simulation-area {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 30px;
            margin: 40px 0;
        }

        @media (max-width: 1000px) {
            .simulation-area {
                grid-template-columns: 1fr;
            }
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(187, 134, 252, 0.2);
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            border-radius: 10px;
        }

        .mode-toggle {
            position: absolute;
            top: 30px;
            right: 30px;
            display: flex;
            gap: 10px;
        }

        .mode-btn {
            padding: 8px 16px;
            font-size: 0.85em;
            border: 1px solid rgba(187, 134, 252, 0.5);
            background: rgba(20, 10, 40, 0.8);
            color: #bb86fc;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: rgba(187, 134, 252, 0.3);
            border-color: #bb86fc;
        }

        .mode-btn:hover {
            background: rgba(187, 134, 252, 0.2);
        }

        .controls {
            background: rgba(20, 10, 40, 0.8);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(187, 134, 252, 0.2);
        }

        .controls h3 {
            color: #bb86fc;
            margin-bottom: 20px;
            font-size: 1.2em;
            border-bottom: 1px solid rgba(187, 134, 252, 0.3);
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: #ce93d8;
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #4a148c, #7b1fa2, #ab47bc);
            border-radius: 4px;
            outline: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #03dac6;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(3, 218, 198, 0.5);
        }

        .shape-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .shape-btn {
            padding: 12px 8px;
            font-size: 0.85em;
            border: 1px solid rgba(187, 134, 252, 0.5);
            background: rgba(20, 10, 40, 0.8);
            color: #e0d8f0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .shape-btn.active {
            background: linear-gradient(135deg, rgba(187, 134, 252, 0.3), rgba(3, 218, 198, 0.2));
            border-color: #03dac6;
        }

        .shape-btn:hover {
            background: rgba(187, 134, 252, 0.2);
        }

        .stats-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(187, 134, 252, 0.1);
            font-size: 0.9em;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #9575cd;
        }

        .stat-value {
            color: #03dac6;
            font-weight: bold;
        }

        .discovery-badge {
            display: inline-block;
            background: linear-gradient(135deg, #ff5722, #ff9800);
            color: white;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            margin-top: 15px;
        }

        .essay {
            background: rgba(20, 10, 40, 0.6);
            border-radius: 15px;
            padding: 40px;
            margin-top: 40px;
            line-height: 1.9;
        }

        .essay h2 {
            color: #bb86fc;
            margin: 30px 0 20px;
            font-size: 1.5em;
        }

        .essay h2:first-child {
            margin-top: 0;
        }

        .essay p {
            margin-bottom: 20px;
            color: #d1c4e9;
            text-align: justify;
        }

        .essay strong {
            color: #03dac6;
        }

        .essay em {
            color: #f48fb1;
            font-style: italic;
        }

        .highlight-stat {
            display: inline-block;
            background: linear-gradient(135deg, rgba(3, 218, 198, 0.2), rgba(187, 134, 252, 0.2));
            padding: 2px 10px;
            border-radius: 4px;
            color: #80cbc4;
            font-weight: bold;
        }

        .orbit-gallery {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 30px 0;
        }

        @media (max-width: 768px) {
            .orbit-gallery {
                grid-template-columns: 1fr;
            }
        }

        .orbit-card {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(187, 134, 252, 0.2);
        }

        .orbit-card h4 {
            color: #bb86fc;
            margin-bottom: 10px;
        }

        .orbit-card p {
            font-size: 0.9em;
            color: #9e9e9e;
            margin: 0;
        }

        .orbit-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .timeline {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 30px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            overflow-x: auto;
        }

        .timeline-item {
            text-align: center;
            flex: 1;
            min-width: 100px;
        }

        .timeline-year {
            color: #03dac6;
            font-weight: bold;
            font-size: 1.2em;
        }

        .timeline-event {
            color: #9575cd;
            font-size: 0.85em;
            margin-top: 5px;
        }

        footer {
            text-align: center;
            padding: 40px 20px;
            color: #7c4dff;
            font-size: 0.9em;
        }

        footer a {
            color: #bb86fc;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Paradoxes</a>

    <div class="container">
        <header>
            <h1>‚àû Quantum Scars</h1>
            <p class="subtitle">Order Emerges from Chaos: Electrons Remember Their Paths</p>
        </header>

        <div class="paradox-box">
            <h3>üåÄ The Scar Paradox</h3>
            <p>
                In classical chaos, a particle bouncing inside a "stadium" billiard would eventually cover
                every point randomly‚Äîpure chaos. Yet in the <strong>quantum realm</strong>, electrons
                mysteriously concentrate along specific paths, creating beautiful "scars" that persist
                forever. <em>"Returns have no long-term consequence in our normal classical world‚Äîthey
                are soon forgotten. But they are remembered forever in the quantum world."</em> ‚Äî Eric Heller
            </p>
            <span class="discovery-badge">üî¨ Confirmed November 2024</span>
        </div>

        <div class="simulation-area">
            <div class="canvas-container">
                <canvas id="scarCanvas"></canvas>
                <div class="mode-toggle">
                    <button class="mode-btn active" data-mode="quantum">Quantum</button>
                    <button class="mode-btn" data-mode="classical">Classical</button>
                </div>
            </div>

            <div class="controls">
                <h3>‚öõÔ∏è Quantum Billiard Controls</h3>

                <div class="control-group">
                    <label>Wave Energy (n): <span id="energyValue">5</span></label>
                    <input type="range" id="energySlider" min="1" max="15" value="5">
                </div>

                <div class="control-group">
                    <label>Visualization Intensity</label>
                    <input type="range" id="intensitySlider" min="1" max="10" value="5">
                </div>

                <div class="control-group">
                    <label>Billiard Shape</label>
                    <div class="shape-buttons">
                        <button class="shape-btn active" data-shape="stadium">üèüÔ∏è Stadium</button>
                        <button class="shape-btn" data-shape="circle">‚≠ï Circle</button>
                        <button class="shape-btn" data-shape="ellipse">ü•ö Ellipse</button>
                        <button class="shape-btn" data-shape="bunimovich">üåô Bunimovich</button>
                    </div>
                </div>

                <div class="stats-panel">
                    <div class="stat-row">
                        <span class="stat-label">System Type</span>
                        <span class="stat-value" id="systemType">Chaotic</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Scar Visibility</span>
                        <span class="stat-value" id="scarVisibility">High</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Orbit Period</span>
                        <span class="stat-value" id="orbitPeriod">‚àû-shaped</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Wave Coherence</span>
                        <span class="stat-value" id="waveCoherence">98%</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="essay">
            <h2>The Stadium Billiard: Chaos in a Simple Shape</h2>
            <p>
                Imagine a pool table shaped like a stadium‚Äîtwo semicircles connected by straight edges.
                Drop a ball inside and let it bounce forever. In classical physics, the ball's path becomes
                <strong>chaotic</strong>: tiny differences in starting position lead to wildly different
                trajectories. Given enough time, the ball will visit every point equally‚Äîthis is called
                <em>ergodicity</em>. The system "forgets" where it started and explores all possibilities
                uniformly. This is the essence of classical chaos.
            </p>

            <h2>Quantum Defiance: Scars That Never Fade</h2>
            <p>
                Now shrink this stadium to the nanometer scale and replace the ball with an electron.
                Quantum mechanics takes over, and something extraordinary happens: instead of spreading
                uniformly everywhere, the electron's probability density <strong>concentrates along
                specific classical orbits</strong>. These enhanced probability regions are called
                <em>quantum scars</em>‚Äîpatterns that classical chaos says should not exist. The electron
                "remembers" certain periodic orbits, defying the ergodic principle that governs its
                classical counterpart.
            </p>

            <div class="orbit-gallery">
                <div class="orbit-card">
                    <div class="orbit-icon">‚àû</div>
                    <h4>Lemniscate Scars</h4>
                    <p>Figure-8 shaped orbits that bounce off curved ends, creating infinity symbols of high probability.</p>
                </div>
                <div class="orbit-card">
                    <div class="orbit-icon">‚îÇ</div>
                    <h4>Bouncing Ball Orbits</h4>
                    <p>Vertical paths between parallel walls, the simplest periodic orbits in the stadium.</p>
                </div>
                <div class="orbit-card">
                    <div class="orbit-icon">‚óá</div>
                    <h4>Diamond Patterns</h4>
                    <p>More complex orbits touching all four "corners" of the stadium in diamond shapes.</p>
                </div>
            </div>

            <h2>The 40-Year Journey to Proof</h2>
            <p>
                In <span class="highlight-stat">1984</span>, Harvard physicist Eric Heller used computer
                simulations to predict quantum scarring. His images showed unmistakable patterns‚Äîelectrons
                concentrated along unstable periodic orbits instead of filling space uniformly. But
                directly <em>imaging</em> these quantum scars in a real physical system remained beyond
                reach for four decades. The challenge: quantum systems are fragile, scars are subtle,
                and the resolution needed was extreme.
            </p>

            <div class="timeline">
                <div class="timeline-item">
                    <div class="timeline-year">1984</div>
                    <div class="timeline-event">Heller predicts quantum scars</div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-year">1990s</div>
                    <div class="timeline-event">Indirect evidence in microwave cavities</div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-year">2010s</div>
                    <div class="timeline-event">Graphene quantum dots emerge</div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-year">Nov 2024</div>
                    <div class="timeline-event">First direct visualization!</div>
                </div>
            </div>

            <h2>The Breakthrough: Seeing Scars in Graphene</h2>
            <p>
                In November 2024, an international team led by UC Santa Cruz physicist Jairo Velasco Jr.
                achieved the first direct visualization of quantum scars. They created stadium-shaped
                quantum dots on atomically thin graphene‚Äîjust <span class="highlight-stat">400 nanometers</span>
                long. Using a scanning tunneling microscope with millielectronvolt energy resolution, they
                mapped the electron wavefunctions directly. The result: beautiful <strong>‚àû-shaped and
                streak-like patterns</strong> exactly matching Heller's 40-year-old predictions.
            </p>

            <h2>Why Scars Form: Constructive Interference</h2>
            <p>
                The secret lies in <strong>wave interference</strong>. Electrons are not just particles‚Äîthey
                are waves. When an electron wave follows a periodic orbit and returns to its starting point,
                it can interfere with itself. If the interference is <em>constructive</em>‚Äîpeaks aligning
                with peaks‚Äîthe probability density is amplified along that orbit. The orbit becomes "scarred"
                into the quantum state. Unlike classical chaos where returns are "forgotten," quantum waves
                remember them forever through this interference mechanism.
            </p>

            <h2>Implications: Harnessing Quantum Chaos</h2>
            <p>
                The ability to visualize and eventually manipulate quantum scars opens new frontiers.
                Researchers envision using scar states for <strong>selective electron delivery</strong>
                at the nanoscale‚Äîdirecting electrons along specific paths in quantum devices. This could
                lead to new forms of <em>quantum control</em>, where chaotic systems are tamed by exploiting
                their hidden order. The scars that classical physics said shouldn't exist may become
                tools for the next generation of quantum technology.
            </p>

            <p>
                As Heller reflected on seeing his prediction confirmed: <em>"Scarring is a localization
                around orbits that come back on themselves. These returns have no long-term consequence
                in our normal classical world‚Äîthey are soon forgotten. But they are remembered forever
                in the quantum world."</em> The quantum realm, it seems, has a better memory than we
                ever imagined.
            </p>
        </div>

        <footer>
            <p>
                Sources:
                <a href="https://news.ucsc.edu/2024/12/quantum-scars-proven/">UC Santa Cruz News</a> |
                <a href="https://phys.org/news/2024-12-physics-patterns-chaos-peculiar-quantum.html">Phys.org</a> |
                <a href="https://scitechdaily.com/scientists-solve-a-40-year-quantum-mystery-that-could-change-electronics-forever/">SciTechDaily</a>
            </p>
        </footer>
    </div>

    <script>
        const canvas = document.getElementById('scarCanvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        let currentShape = 'stadium';
        let currentMode = 'quantum';
        let energyLevel = 5;
        let intensity = 5;
        let time = 0;

        // Classical particles for comparison
        let particles = [];

        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const size = Math.min(rect.width - 40, 600);
            canvas.width = size * dpr;
            canvas.height = size * 0.7 * dpr;
            canvas.style.width = size + 'px';
            canvas.style.height = size * 0.7 + 'px';
            ctx.scale(dpr, dpr);
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Shape boundary functions
        const shapes = {
            stadium: {
                isInside: (x, y, w, h) => {
                    const cx = w / 2;
                    const cy = h / 2;
                    const rx = x - cx;
                    const ry = y - cy;
                    const straightLen = w * 0.3;
                    const radius = h * 0.4;

                    // Check straight middle section
                    if (Math.abs(rx) < straightLen && Math.abs(ry) < radius) return true;

                    // Check semicircular ends
                    const leftCenter = -straightLen;
                    const rightCenter = straightLen;

                    if (rx < 0) {
                        const dist = Math.sqrt((rx - leftCenter) ** 2 + ry ** 2);
                        return dist < radius;
                    } else {
                        const dist = Math.sqrt((rx - rightCenter) ** 2 + ry ** 2);
                        return dist < radius;
                    }
                },
                getOrbit: (t, type) => {
                    // Generate different orbit types
                    if (type === 'lemniscate') {
                        const scale = 0.35;
                        const x = scale * Math.sin(t);
                        const y = scale * Math.sin(t) * Math.cos(t);
                        return { x: 0.5 + x, y: 0.5 + y };
                    } else if (type === 'bounce') {
                        const y = 0.5 + 0.35 * Math.sin(t * 2);
                        return { x: 0.5, y };
                    } else {
                        const x = 0.5 + 0.3 * Math.cos(t * 1.5);
                        const y = 0.5 + 0.3 * Math.sin(t);
                        return { x, y };
                    }
                },
                chaotic: true
            },
            circle: {
                isInside: (x, y, w, h) => {
                    const cx = w / 2;
                    const cy = h / 2;
                    const r = Math.min(w, h) * 0.4;
                    return Math.sqrt((x - cx) ** 2 + (y - cy) ** 2) < r;
                },
                getOrbit: (t, type) => {
                    const r = 0.3;
                    return { x: 0.5 + r * Math.cos(t), y: 0.5 + r * Math.sin(t) };
                },
                chaotic: false
            },
            ellipse: {
                isInside: (x, y, w, h) => {
                    const cx = w / 2;
                    const cy = h / 2;
                    const a = w * 0.4;
                    const b = h * 0.35;
                    return ((x - cx) / a) ** 2 + ((y - cy) / b) ** 2 < 1;
                },
                getOrbit: (t, type) => {
                    const a = 0.35;
                    const b = 0.25;
                    return { x: 0.5 + a * Math.cos(t), y: 0.5 + b * Math.sin(t) };
                },
                chaotic: false
            },
            bunimovich: {
                isInside: (x, y, w, h) => {
                    const cx = w / 2;
                    const cy = h / 2;
                    const rx = x - cx;
                    const ry = y - cy;
                    const radius = h * 0.4;

                    // Semi-circular stadium (Bunimovich)
                    if (ry > 0) {
                        return Math.sqrt(rx ** 2 + ry ** 2) < radius;
                    } else {
                        return Math.abs(rx) < radius && ry > -radius;
                    }
                },
                getOrbit: (t, type) => {
                    const x = 0.5 + 0.3 * Math.sin(t * 1.3);
                    const y = 0.5 + 0.25 * Math.cos(t) * Math.abs(Math.sin(t * 0.5));
                    return { x, y };
                },
                chaotic: true
            }
        };

        // Initialize classical particles
        function initParticles() {
            particles = [];
            for (let i = 0; i < 50; i++) {
                particles.push({
                    x: 0.3 + Math.random() * 0.4,
                    y: 0.3 + Math.random() * 0.4,
                    vx: (Math.random() - 0.5) * 0.02,
                    vy: (Math.random() - 0.5) * 0.02,
                    trail: []
                });
            }
        }

        function updateParticles(w, h) {
            const shape = shapes[currentShape];

            particles.forEach(p => {
                // Store trail
                p.trail.push({ x: p.x * w, y: p.y * h });
                if (p.trail.length > 100) p.trail.shift();

                // Move
                p.x += p.vx;
                p.y += p.vy;

                // Reflect off boundaries (simplified)
                const px = p.x * w;
                const py = p.y * h;

                if (!shape.isInside(px, py, w, h)) {
                    // Simple reflection
                    if (p.x < 0.1 || p.x > 0.9) p.vx *= -1;
                    if (p.y < 0.1 || p.y > 0.9) p.vy *= -1;
                    p.x = Math.max(0.15, Math.min(0.85, p.x));
                    p.y = Math.max(0.15, Math.min(0.85, p.y));
                }
            });
        }

        // Generate quantum wavefunction visualization
        function drawQuantumState(w, h) {
            const shape = shapes[currentShape];
            const imageData = ctx.createImageData(w, h);
            const data = imageData.data;

            const n = energyLevel;
            const int = intensity / 5;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = (y * w + x) * 4;

                    if (!shape.isInside(x, y, w, h)) {
                        data[idx] = 10;
                        data[idx + 1] = 5;
                        data[idx + 2] = 20;
                        data[idx + 3] = 255;
                        continue;
                    }

                    // Normalized coordinates
                    const nx = x / w;
                    const ny = y / h;

                    // Calculate wavefunction (superposition of modes creating scars)
                    let psi = 0;

                    // Standing wave modes
                    for (let m = 1; m <= n; m++) {
                        for (let k = 1; k <= n; k++) {
                            const phase = time * 0.002 * (m + k);
                            psi += Math.sin(m * Math.PI * nx * 3 + phase) *
                                   Math.sin(k * Math.PI * ny * 3 + phase * 0.7);
                        }
                    }

                    // Add scarring effect along periodic orbits
                    if (shape.chaotic) {
                        // Lemniscate scar
                        const scarStrength = 2.5 * int;
                        for (let t = 0; t < Math.PI * 4; t += 0.1) {
                            const orbit = shape.getOrbit(t, 'lemniscate');
                            const dist = Math.sqrt((nx - orbit.x) ** 2 + (ny - orbit.y) ** 2);
                            psi += scarStrength * Math.exp(-dist * dist * 200) * Math.sin(t * n + time * 0.001);
                        }

                        // Bouncing ball scar
                        for (let t = 0; t < Math.PI * 4; t += 0.1) {
                            const orbit = shape.getOrbit(t, 'bounce');
                            const dist = Math.sqrt((nx - orbit.x) ** 2 + (ny - orbit.y) ** 2);
                            psi += scarStrength * 0.5 * Math.exp(-dist * dist * 300) * Math.cos(t * n);
                        }
                    }

                    // Probability density
                    const prob = psi * psi;
                    const normalized = Math.min(1, Math.abs(prob) / (n * n * 0.5) * int);

                    // Color mapping: purple to cyan gradient for quantum
                    const hue = 280 - normalized * 100; // Purple to cyan
                    const sat = 0.7 + normalized * 0.3;
                    const light = 0.1 + normalized * 0.6;

                    // HSL to RGB conversion
                    const c = (1 - Math.abs(2 * light - 1)) * sat;
                    const hue2 = hue / 60;
                    const x2 = c * (1 - Math.abs(hue2 % 2 - 1));
                    const m = light - c / 2;

                    let r, g, b;
                    if (hue2 < 1) { r = c; g = x2; b = 0; }
                    else if (hue2 < 2) { r = x2; g = c; b = 0; }
                    else if (hue2 < 3) { r = 0; g = c; b = x2; }
                    else if (hue2 < 4) { r = 0; g = x2; b = c; }
                    else if (hue2 < 5) { r = x2; g = 0; b = c; }
                    else { r = c; g = 0; b = x2; }

                    data[idx] = Math.floor((r + m) * 255);
                    data[idx + 1] = Math.floor((g + m) * 255);
                    data[idx + 2] = Math.floor((b + m) * 255);
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw scar overlay with glow
            if (shape.chaotic) {
                ctx.globalCompositeOperation = 'screen';

                // Lemniscate path
                ctx.beginPath();
                ctx.strokeStyle = `rgba(3, 218, 198, ${0.3 * int})`;
                ctx.lineWidth = 3;
                for (let t = 0; t < Math.PI * 4; t += 0.05) {
                    const orbit = shape.getOrbit(t, 'lemniscate');
                    const px = orbit.x * w;
                    const py = orbit.y * h;
                    if (t === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();

                ctx.globalCompositeOperation = 'source-over';
            }
        }

        function drawClassicalState(w, h) {
            const shape = shapes[currentShape];

            // Dark background
            ctx.fillStyle = '#0a0014';
            ctx.fillRect(0, 0, w, h);

            // Draw boundary
            ctx.strokeStyle = 'rgba(187, 134, 252, 0.5)';
            ctx.lineWidth = 2;

            if (currentShape === 'stadium') {
                const cx = w / 2;
                const cy = h / 2;
                const straightLen = w * 0.3;
                const radius = h * 0.4;

                ctx.beginPath();
                ctx.arc(cx - straightLen, cy, radius, Math.PI / 2, -Math.PI / 2);
                ctx.lineTo(cx + straightLen, cy - radius);
                ctx.arc(cx + straightLen, cy, radius, -Math.PI / 2, Math.PI / 2);
                ctx.lineTo(cx - straightLen, cy + radius);
                ctx.stroke();
            } else if (currentShape === 'circle') {
                ctx.beginPath();
                ctx.arc(w / 2, h / 2, Math.min(w, h) * 0.4, 0, Math.PI * 2);
                ctx.stroke();
            } else if (currentShape === 'ellipse') {
                ctx.beginPath();
                ctx.ellipse(w / 2, h / 2, w * 0.4, h * 0.35, 0, 0, Math.PI * 2);
                ctx.stroke();
            } else if (currentShape === 'bunimovich') {
                const cx = w / 2;
                const cy = h / 2;
                const radius = h * 0.4;
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI);
                ctx.lineTo(cx - radius, cy - radius);
                ctx.lineTo(cx + radius, cy - radius);
                ctx.closePath();
                ctx.stroke();
            }

            // Draw particles and trails
            updateParticles(w, h);

            particles.forEach(p => {
                // Draw trail
                if (p.trail.length > 1) {
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 0.5;
                    p.trail.forEach((pt, i) => {
                        if (i === 0) ctx.moveTo(pt.x, pt.y);
                        else ctx.lineTo(pt.x, pt.y);
                    });
                    ctx.stroke();
                }

                // Draw particle
                ctx.beginPath();
                ctx.arc(p.x * w, p.y * h, 3, 0, Math.PI * 2);
                ctx.fillStyle = '#03dac6';
                ctx.fill();
            });
        }

        function updateStats() {
            const shape = shapes[currentShape];
            document.getElementById('systemType').textContent = shape.chaotic ? 'Chaotic' : 'Integrable';
            document.getElementById('scarVisibility').textContent =
                shape.chaotic ? (intensity > 5 ? 'Very High' : 'High') : 'None (Regular)';
            document.getElementById('orbitPeriod').textContent =
                currentShape === 'stadium' ? '‚àû-shaped' :
                currentShape === 'bunimovich' ? 'Mixed' : 'Circular';
            document.getElementById('waveCoherence').textContent =
                Math.floor(90 + Math.random() * 10) + '%';
        }

        function draw() {
            const w = canvas.width / dpr;
            const h = canvas.height / dpr;

            if (currentMode === 'quantum') {
                drawQuantumState(w, h);
            } else {
                drawClassicalState(w, h);
            }

            updateStats();
            time++;
            requestAnimationFrame(draw);
        }

        // Event listeners
        document.getElementById('energySlider').addEventListener('input', (e) => {
            energyLevel = parseInt(e.target.value);
            document.getElementById('energyValue').textContent = energyLevel;
        });

        document.getElementById('intensitySlider').addEventListener('input', (e) => {
            intensity = parseInt(e.target.value);
        });

        document.querySelectorAll('.shape-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentShape = btn.dataset.shape;
                initParticles();
            });
        });

        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMode = btn.dataset.mode;
                if (currentMode === 'classical') initParticles();
            });
        });

        // Initialize
        initParticles();
        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
