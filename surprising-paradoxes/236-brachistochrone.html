<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Brachistochrone Problem - Fastest Path Isn't Straight</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 30px; }
        .back-link { color: #f39c12; text-decoration: none; margin-bottom: 20px; display: inline-block; }
        h1 {
            font-size: 2.4rem;
            background: linear-gradient(135deg, #f39c12, #e74c3c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }
        .subtitle { font-size: 1.1rem; color: #f0c040; max-width: 800px; margin: 0 auto; line-height: 1.6; }
        .main-grid { display: grid; grid-template-columns: 2fr 1fr; gap: 30px; margin-bottom: 30px; }
        .panel {
            background: rgba(30, 40, 60, 0.7);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(243, 156, 18, 0.3);
        }
        .panel h2 { color: #f39c12; font-size: 1.3rem; margin-bottom: 15px; }
        canvas { width: 100%; height: 450px; background: rgba(10, 15, 30, 0.8); border-radius: 10px; cursor: crosshair; }
        .controls { display: flex; gap: 15px; margin: 20px 0; justify-content: center; flex-wrap: wrap; }
        .control-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-family: inherit;
            font-size: 1rem;
            transition: all 0.3s;
        }
        .control-btn.primary { background: linear-gradient(135deg, #f39c12, #e67e22); color: white; }
        .control-btn.secondary { background: rgba(243, 156, 18, 0.2); color: #f39c12; border: 1px solid rgba(243, 156, 18, 0.5); }
        .control-btn:hover { transform: scale(1.05); }
        .results-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0; }
        .result-box { background: rgba(10, 15, 30, 0.6); padding: 15px; border-radius: 10px; text-align: center; }
        .result-value { font-size: 1.5rem; font-weight: bold; }
        .result-label { color: #f0c040; font-size: 0.85rem; margin-top: 5px; }
        .straight { color: #e74c3c; }
        .cycloid { color: #2ecc71; }
        .custom { color: #3498db; }
        .path-info { background: rgba(10, 15, 30, 0.6); border-radius: 10px; padding: 15px; margin-top: 15px; }
        .path-info h3 { color: #f39c12; margin-bottom: 10px; font-size: 1rem; }
        .path-info p { color: #b0c0d0; font-size: 0.9rem; line-height: 1.6; }
        .history-item { display: flex; justify-content: space-between; padding: 8px; margin: 5px 0; background: rgba(20, 30, 50, 0.5); border-radius: 5px; }
        .insight-box {
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.2), rgba(231, 76, 60, 0.1));
            border-left: 4px solid #f39c12;
            padding: 20px;
            border-radius: 0 10px 10px 0;
            margin: 25px 0;
        }
        .insight-box h3 { color: #f39c12; margin-bottom: 10px; }
        .explanation { background: rgba(30, 40, 60, 0.5); border-radius: 15px; padding: 25px; margin-top: 30px; }
        .explanation h2 { color: #f39c12; margin-bottom: 15px; }
        .explanation p { color: #b0c0d0; line-height: 1.8; margin-bottom: 15px; }
        .legend { display: flex; gap: 20px; justify-content: center; margin: 15px 0; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 8px; }
        .legend-color { width: 20px; height: 4px; border-radius: 2px; }
        @media (max-width: 900px) { .main-grid { grid-template-columns: 1fr; } .results-grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">‚Üê Back to Surprising Paradoxes</a>
            <h1>The Brachistochrone Problem</h1>
            <p class="subtitle">The fastest path between two points is NOT a straight line! It's a cycloid‚Äîthe curve traced by a point on a rolling circle. Watch balls race down different paths under gravity.</p>
        </header>

        <div class="main-grid">
            <div class="panel">
                <h2>üèÅ The Race Track</h2>
                <canvas id="raceCanvas"></canvas>
                <div class="legend">
                    <div class="legend-item"><div class="legend-color" style="background: #e74c3c;"></div><span>Straight Line</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #2ecc71;"></div><span>Cycloid (Optimal)</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #3498db;"></div><span>Your Path</span></div>
                </div>
                <div class="controls">
                    <button class="control-btn primary" id="startRace">‚ñ∂ Start Race</button>
                    <button class="control-btn secondary" id="resetRace">‚Üª Reset</button>
                    <button class="control-btn secondary" id="clearCustom">Clear Custom Path</button>
                </div>
                <div class="results-grid">
                    <div class="result-box">
                        <div class="result-value straight" id="timeStraight">--</div>
                        <div class="result-label">Straight Line</div>
                    </div>
                    <div class="result-box">
                        <div class="result-value cycloid" id="timeCycloid">--</div>
                        <div class="result-label">Cycloid (Winner!)</div>
                    </div>
                    <div class="result-box">
                        <div class="result-value custom" id="timeCustom">--</div>
                        <div class="result-label">Your Path</div>
                    </div>
                </div>
            </div>
            <div class="panel">
                <h2>üìê The Paths</h2>
                <div class="path-info">
                    <h3 style="color: #e74c3c;">Straight Line</h3>
                    <p>The intuitive choice. Shortest distance, but ball accelerates slowly on the gentle slope. Not optimal!</p>
                </div>
                <div class="path-info">
                    <h3 style="color: #2ecc71;">Cycloid (Brachistochrone)</h3>
                    <p>Steeper initial drop builds speed early. Despite longer distance, the higher velocity wins. This is the mathematically OPTIMAL curve‚Äîproven by Newton, Bernoulli, and Leibniz.</p>
                </div>
                <div class="path-info">
                    <h3 style="color: #3498db;">Your Custom Path</h3>
                    <p>Click on the canvas to draw your own curve! Can you beat the straight line? The cycloid?</p>
                </div>
                <div class="path-info" style="background: rgba(243, 156, 18, 0.15); border: 1px solid rgba(243, 156, 18, 0.4);">
                    <h3 style="color: #f39c12;">The Physics</h3>
                    <p>Under gravity, a steeper initial slope builds velocity faster (v = ‚àö(2gh)). The cycloid optimally trades distance for speed‚Äîenough early acceleration to overcome the longer path.</p>
                </div>
            </div>
        </div>

        <div class="insight-box">
            <h3>üß† Why Curves Beat Lines</h3>
            <p>Galileo thought the answer was a circular arc (wrong!). In 1696, Johann Bernoulli posed the challenge. Newton solved it overnight (and published anonymously, but Bernoulli recognized "the claw of the lion"). The optimal curve is a <strong>cycloid</strong>‚Äîtraced by a point on a wheel's rim as it rolls. The cycloid is also <strong>tautochrone</strong>: a ball released from ANY point on it reaches the bottom in the same time!</p>
        </div>

        <div class="explanation">
            <h2>The Mathematics</h2>
            <p><strong>The Problem:</strong> Find the curve connecting two points such that a frictionless bead sliding under gravity reaches the endpoint in minimum time.</p>
            <p><strong>The Solution:</strong> Using calculus of variations, minimize T = ‚à´‚àö(1+y'¬≤)/(2gy) dx. The Euler-Lagrange equation yields the cycloid: x = r(Œ∏ - sinŒ∏), y = r(1 - cosŒ∏).</p>
            <p><strong>Historical Impact:</strong> This problem launched the calculus of variations and inspired Lagrangian mechanics, optimal control theory, and the principle of least action‚Äîfoundations of modern physics.</p>
            <p style="font-style: italic; color: #8a9ab0;">The word "brachistochrone" comes from Greek: Œ≤œÅŒ¨œáŒπœÉœÑŒøœÇ (shortest) + œáœÅœåŒΩŒøœÇ (time).</p>
        </div>
    </div>

    <script>
        var canvas = document.getElementById('raceCanvas');
        var ctx = canvas.getContext('2d');
        
        var g = 500;
        var startX = 50;
        var startY = 50;
        var endX, endY;
        
        var balls = [];
        var paths = { straight: [], cycloid: [], custom: [] };
        var times = { straight: null, cycloid: null, custom: null };
        var racing = false;
        var customPoints = [];

        function initCanvas() {
            var dpr = window.devicePixelRatio || 1;
            var rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            
            endX = rect.width - 50;
            endY = rect.height - 50;
            
            generatePaths();
            draw();
        }

        function generateCycloidPath(x1, y1, x2, y2) {
            var path = [];
            var dx = x2 - x1;
            var dy = y2 - y1;
            
            var r = dy / 2;
            var theta_end = Math.PI;
            
            for (var i = 0; i <= 1; i += 0.01) {
                var theta = i * theta_end;
                var cx = (theta - Math.sin(theta)) / theta_end;
                var cy = (1 - Math.cos(theta)) / 2;
                path.push({
                    x: x1 + cx * dx,
                    y: y1 + cy * dy
                });
            }
            path.push({ x: x2, y: y2 });
            return path;
        }

        function generateStraightPath(x1, y1, x2, y2) {
            var path = [];
            for (var i = 0; i <= 1; i += 0.01) {
                path.push({
                    x: x1 + i * (x2 - x1),
                    y: y1 + i * (y2 - y1)
                });
            }
            return path;
        }

        function generatePaths() {
            paths.straight = generateStraightPath(startX, startY, endX, endY);
            paths.cycloid = generateCycloidPath(startX, startY, endX, endY);
            
            if (customPoints.length >= 2) {
                paths.custom = [{ x: startX, y: startY }];
                for (var i = 0; i < customPoints.length; i++) {
                    paths.custom.push(customPoints[i]);
                }
                paths.custom.push({ x: endX, y: endY });
            } else {
                paths.custom = [];
            }
        }

        function drawPath(path, color, width) {
            if (path.length < 2) return;
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (var i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();
        }

        function draw() {
            var width = canvas.width / (window.devicePixelRatio || 1);
            var height = canvas.height / (window.devicePixelRatio || 1);
            
            ctx.clearRect(0, 0, width, height);
            
            ctx.fillStyle = '#f39c12';
            ctx.beginPath();
            ctx.arc(startX, startY, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(endX, endY, 8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.font = '12px Georgia';
            ctx.fillStyle = '#f0c040';
            ctx.fillText('START', startX - 20, startY - 15);
            ctx.fillText('FINISH', endX - 20, endY + 25);
            
            drawPath(paths.straight, '#e74c3c', 3);
            drawPath(paths.cycloid, '#2ecc71', 3);
            if (paths.custom.length > 0) {
                drawPath(paths.custom, '#3498db', 3);
            }
            
            for (var i = 0; i < customPoints.length; i++) {
                ctx.fillStyle = '#3498db';
                ctx.beginPath();
                ctx.arc(customPoints[i].x, customPoints[i].y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            for (var j = 0; j < balls.length; j++) {
                var ball = balls[j];
                ctx.fillStyle = ball.color;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function getPathLength(path) {
            var len = 0;
            for (var i = 1; i < path.length; i++) {
                var dx = path[i].x - path[i-1].x;
                var dy = path[i].y - path[i-1].y;
                len += Math.sqrt(dx * dx + dy * dy);
            }
            return len;
        }

        function simulateBall(path, color, name) {
            if (path.length < 2) return null;
            
            return {
                path: path,
                pathIndex: 0,
                progress: 0,
                x: path[0].x,
                y: path[0].y,
                velocity: 0,
                color: color,
                name: name,
                finished: false,
                time: 0
            };
        }

        function updateBall(ball, dt) {
            if (ball.finished || ball.pathIndex >= ball.path.length - 1) {
                ball.finished = true;
                return;
            }
            
            ball.time += dt;
            
            var height = ball.y - startY;
            ball.velocity = Math.sqrt(2 * g * Math.max(0, height));
            
            var curr = ball.path[ball.pathIndex];
            var next = ball.path[ball.pathIndex + 1];
            var dx = next.x - curr.x;
            var dy = next.y - curr.y;
            var segLen = Math.sqrt(dx * dx + dy * dy);
            
            if (segLen > 0) {
                var move = ball.velocity * dt;
                ball.progress += move / segLen;
                
                while (ball.progress >= 1 && ball.pathIndex < ball.path.length - 2) {
                    ball.progress -= 1;
                    ball.pathIndex++;
                    curr = ball.path[ball.pathIndex];
                    next = ball.path[ball.pathIndex + 1];
                    dx = next.x - curr.x;
                    dy = next.y - curr.y;
                    segLen = Math.sqrt(dx * dx + dy * dy);
                }
                
                ball.x = curr.x + ball.progress * dx;
                ball.y = curr.y + ball.progress * dy;
            }
            
            if (ball.pathIndex >= ball.path.length - 2 && ball.progress >= 1) {
                ball.finished = true;
                ball.x = ball.path[ball.path.length - 1].x;
                ball.y = ball.path[ball.path.length - 1].y;
            }
        }

        function startRace() {
            if (racing) return;
            
            times = { straight: null, cycloid: null, custom: null };
            balls = [];
            
            var straightBall = simulateBall(paths.straight, '#e74c3c', 'straight');
            var cycloidBall = simulateBall(paths.cycloid, '#2ecc71', 'cycloid');
            
            if (straightBall) balls.push(straightBall);
            if (cycloidBall) balls.push(cycloidBall);
            
            if (paths.custom.length > 0) {
                var customBall = simulateBall(paths.custom, '#3498db', 'custom');
                if (customBall) balls.push(customBall);
            }
            
            racing = true;
            var lastTime = performance.now();
            
            function animate(currentTime) {
                var dt = (currentTime - lastTime) / 1000;
                lastTime = currentTime;
                
                var allFinished = true;
                for (var i = 0; i < balls.length; i++) {
                    var ball = balls[i];
                    if (!ball.finished) {
                        updateBall(ball, dt);
                        allFinished = false;
                        
                        if (ball.finished && times[ball.name] === null) {
                            times[ball.name] = ball.time;
                        }
                    }
                }
                
                draw();
                updateResults();
                
                if (!allFinished) {
                    requestAnimationFrame(animate);
                } else {
                    racing = false;
                }
            }
            
            requestAnimationFrame(animate);
        }

        function updateResults() {
            var straightEl = document.getElementById('timeStraight');
            var cycloidEl = document.getElementById('timeCycloid');
            var customEl = document.getElementById('timeCustom');
            
            straightEl.textContent = times.straight !== null ? times.straight.toFixed(3) + 's' : '--';
            cycloidEl.textContent = times.cycloid !== null ? times.cycloid.toFixed(3) + 's' : '--';
            customEl.textContent = times.custom !== null ? times.custom.toFixed(3) + 's' : (paths.custom.length > 0 ? '--' : 'No path');
        }

        function resetRace() {
            racing = false;
            balls = [];
            times = { straight: null, cycloid: null, custom: null };
            updateResults();
            draw();
        }

        function clearCustomPath() {
            customPoints = [];
            paths.custom = [];
            resetRace();
        }

        canvas.addEventListener('click', function(e) {
            if (racing) return;
            
            var rect = canvas.getBoundingClientRect();
            var x = e.clientX - rect.left;
            var y = e.clientY - rect.top;
            
            if (x > startX + 20 && x < endX - 20 && y > startY && y < endY) {
                customPoints.push({ x: x, y: y });
                customPoints.sort(function(a, b) { return a.x - b.x; });
                generatePaths();
                draw();
            }
        });

        document.getElementById('startRace').addEventListener('click', startRace);
        document.getElementById('resetRace').addEventListener('click', resetRace);
        document.getElementById('clearCustom').addEventListener('click', clearCustomPath);

        window.addEventListener('load', initCanvas);
        window.addEventListener('resize', function() {
            initCanvas();
            resetRace();
        });
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
