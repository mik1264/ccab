<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aristotle's Wheel Paradox - Surprising Paradoxes - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%);
            min-height: 100vh;
            color: var(--dark-moss);
            line-height: 1.7;
        }
        .organic-shape {
            position: fixed;
            border-radius: 60% 40% 50% 50% / 50% 60% 40% 50%;
            opacity: 0.12;
            z-index: 0;
            animation: morph 30s ease-in-out infinite;
        }
        .shape-1 {
            width: 600px;
            height: 600px;
            background: linear-gradient(135deg, var(--sage), var(--moss));
            top: -200px;
            right: -150px;
        }
        .shape-2 {
            width: 500px;
            height: 500px;
            background: linear-gradient(135deg, var(--earth), var(--terracotta));
            bottom: -150px;
            left: -150px;
            animation-delay: -15s;
        }
        @keyframes morph {
            0%, 100% { border-radius: 60% 40% 50% 50% / 50% 60% 40% 50%; }
            25% { border-radius: 50% 60% 40% 50% / 40% 50% 60% 50%; }
            50% { border-radius: 40% 50% 60% 50% / 50% 40% 50% 60%; }
            75% { border-radius: 50% 40% 50% 60% / 60% 50% 40% 50%; }
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px 80px;
            position: relative;
            z-index: 1;
        }
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--moss);
            text-decoration: none;
            font-weight: 500;
            margin-bottom: 30px;
            padding: 10px 20px;
            background: rgba(255,255,255,0.6);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            transition: all 0.3s ease;
        }
        .back-link:hover {
            background: rgba(255,255,255,0.9);
            transform: translateX(-5px);
        }
        h1 {
            font-family: 'Lora', serif;
            font-size: 2.8rem;
            font-weight: 600;
            color: var(--moss);
            margin-bottom: 20px;
            line-height: 1.2;
        }
        .subtitle {
            font-size: 1.3rem;
            color: var(--terracotta);
            margin-bottom: 40px;
            font-weight: 500;
        }
        .badge {
            display: inline-block;
            background: linear-gradient(135deg, #ffd700, #ffb700);
            color: #1a1a2e;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 25px;
        }
        .card {
            background: rgba(255,255,255,0.7);
            backdrop-filter: blur(15px);
            border-radius: 24px;
            padding: 35px;
            margin-bottom: 35px;
            border: 1px solid rgba(138,154,91,0.2);
            box-shadow: 0 10px 40px rgba(0,0,0,0.08);
        }
        .card h2 {
            font-family: 'Lora', serif;
            font-size: 1.6rem;
            color: var(--moss);
            margin-bottom: 20px;
        }
        .card p {
            color: #555;
            margin-bottom: 18px;
        }
        .card p:last-child { margin-bottom: 0; }
        .highlight {
            background: linear-gradient(120deg, rgba(221,161,94,0.2) 0%, rgba(221,161,94,0.1) 100%);
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: 600;
            color: var(--terracotta);
        }

        /* Simulation */
        .simulation-container {
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 35px;
            box-shadow: 0 15px 50px rgba(0,0,0,0.2);
        }
        .simulation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .simulation-title {
            color: #fff;
            font-family: 'Lora', serif;
            font-size: 1.3rem;
        }
        .controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }
        .btn {
            background: linear-gradient(135deg, var(--earth) 0%, var(--terracotta) 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-family: 'Nunito', sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(188,108,37,0.4);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .btn-secondary {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
        }
        .btn-secondary:hover {
            background: rgba(255,255,255,0.25);
            box-shadow: 0 8px 25px rgba(255,255,255,0.1);
        }
        .btn.active {
            background: linear-gradient(135deg, #00aa66, #00cc77);
        }
        #wheelCanvas {
            display: block;
            width: 100%;
            border-radius: 12px;
            background: linear-gradient(180deg, #0f0f23 0%, #1a1a2e 100%);
        }

        /* Info panel */
        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .info-box {
            background: rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }
        .info-label {
            color: rgba(255,255,255,0.6);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }
        .info-value {
            font-size: 1.2rem;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }
        .info-value.outer { color: #ff6b6b; }
        .info-value.inner { color: #4ecdc4; }
        .info-value.paradox { color: #ffd93d; }

        /* Toggle */
        .toggle-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .toggle-btn {
            background: rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.7);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .toggle-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        .toggle-btn.active {
            background: var(--earth);
            border-color: var(--earth);
            color: white;
        }

        /* Legend */
        .legend {
            display: flex;
            gap: 25px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: rgba(255,255,255,0.8);
            font-size: 0.85rem;
        }
        .legend-line {
            width: 25px;
            height: 3px;
            border-radius: 2px;
        }
        .legend-line.outer { background: #ff6b6b; }
        .legend-line.inner { background: #4ecdc4; }
        .legend-line.slip { background: repeating-linear-gradient(90deg, #ffd93d, #ffd93d 4px, transparent 4px, transparent 8px); }

        /* Quote */
        .quote {
            border-left: 4px solid var(--earth);
            padding-left: 25px;
            margin: 25px 0;
            font-style: italic;
            color: #666;
        }
        .quote-author {
            font-style: normal;
            font-weight: 600;
            color: var(--moss);
            margin-top: 10px;
        }

        /* Insight box */
        .insight-box {
            background: linear-gradient(135deg, rgba(138,154,91,0.15) 0%, rgba(96,108,56,0.1) 100%);
            border: 2px solid var(--sage);
            border-radius: 16px;
            padding: 25px;
            margin: 25px 0;
        }
        .insight-box h3 {
            color: var(--moss);
            font-family: 'Lora', serif;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Hexagon demo */
        .hexagon-demo {
            background: rgba(0,0,0,0.05);
            border-radius: 16px;
            padding: 20px;
            margin: 25px 0;
        }
        #hexagonCanvas {
            display: block;
            width: 100%;
            max-width: 700px;
            margin: 0 auto;
            border-radius: 8px;
            background: #fff;
        }
        .hexagon-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        .sides-display {
            color: var(--moss);
            font-weight: 600;
            min-width: 80px;
            text-align: center;
        }

        /* Formula */
        .formula {
            background: rgba(0,0,0,0.03);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            color: var(--dark-moss);
        }

        /* Comparison table */
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 25px 0;
        }
        .comparison-col {
            background: rgba(255,255,255,0.5);
            border-radius: 12px;
            padding: 20px;
        }
        .comparison-col h4 {
            color: var(--moss);
            margin-bottom: 10px;
            font-family: 'Lora', serif;
        }
        .comparison-col.outer { border-top: 4px solid #ff6b6b; }
        .comparison-col.inner { border-top: 4px solid #4ecdc4; }

        .footer {
            text-align: center;
            padding-top: 30px;
            color: #888;
            font-size: 0.85rem;
        }
        .footer a { color: var(--moss); }

        @media (max-width: 600px) {
            h1 { font-size: 2rem; }
            .card { padding: 25px; }
            .simulation-container { padding: 20px; }
            .comparison { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="organic-shape shape-1"></div>
    <div class="organic-shape shape-2"></div>

    <main class="container">
        <a href="index.html" class="back-link">← Back to Paradoxes</a>

        <span class="badge">Ancient Mechanics</span>
        <h1>Aristotle's Wheel Paradox</h1>
        <p class="subtitle">A wheel within a wheel—both travel the same distance, yet their circumferences differ. How can this be?</p>

        <!-- Main Simulation -->
        <div class="simulation-container">
            <div class="simulation-header">
                <h2 class="simulation-title">The Rolling Wheel</h2>
                <div class="controls">
                    <button class="btn" id="rollBtn">
                        <span>&#9654;</span> Roll Wheel
                    </button>
                    <button class="btn btn-secondary" id="resetBtn">
                        <span>&#8635;</span> Reset
                    </button>
                </div>
            </div>

            <canvas id="wheelCanvas" width="800" height="400"></canvas>

            <div class="toggle-group">
                <button class="toggle-btn active" id="showTracksBtn">Show Tracks</button>
                <button class="toggle-btn" id="showSlipBtn">Reveal Slipping</button>
                <button class="toggle-btn" id="showTrochoidBtn">Show Trochoid Path</button>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-line outer"></div>
                    <span>Outer Circle (rolling)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line inner"></div>
                    <span>Inner Circle</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line slip"></div>
                    <span>Slip Distance</span>
                </div>
            </div>

            <div class="info-panel">
                <div class="info-box">
                    <div class="info-label">Outer Circumference</div>
                    <div class="info-value outer" id="outerCirc">2πR</div>
                </div>
                <div class="info-box">
                    <div class="info-label">Inner Circumference</div>
                    <div class="info-value inner" id="innerCirc">2πr</div>
                </div>
                <div class="info-box">
                    <div class="info-label">Distance Traveled</div>
                    <div class="info-value paradox" id="distTraveled">0</div>
                </div>
                <div class="info-box">
                    <div class="info-label">Inner Slip</div>
                    <div class="info-value" id="slipDist" style="color: #ffd93d;">0</div>
                </div>
            </div>
        </div>

        <!-- The Paradox -->
        <div class="card">
            <h2>The 2,400-Year-Old Mystery</h2>
            <p>Imagine a wheel with a smaller wheel fixed at its center—like a tire with a hubcap. Both are rigidly connected and rotate together.</p>
            <p>When the outer wheel rolls one full revolution on the ground, it travels a distance equal to its circumference: <span class="highlight">2πR</span>.</p>
            <p>But here's the puzzle: the inner wheel also moves that same distance—yet its circumference is only <span class="highlight">2πr</span>, which is smaller!</p>
            <p>How can a circle travel farther than its own circumference in a single revolution? Does this prove that different-sized circles have the same circumference? Clearly not—so where is the error?</p>

            <div class="quote">
                "The problem seems to be such that, if the larger one has been moved forward by its own diameter, the smaller one has been moved forward by its own diameter; but the path of the smaller circle is less."
                <div class="quote-author">— Mechanica (attributed to Aristotle), ~4th century BC</div>
            </div>
        </div>

        <!-- The Resolution -->
        <div class="card">
            <h2>The Resolution: Slipping in Disguise</h2>

            <div class="insight-box">
                <h3>&#128161; Key Insight</h3>
                <p>The inner circle is NOT purely rolling—it's <strong>sliding</strong> while rotating. The sliding is invisible because the inner circle doesn't touch the ground, but it's there!</p>
            </div>

            <p>When you roll a wheel on the ground, the point of contact momentarily has zero velocity—it's pure rolling with no slipping. But the inner circle can't do this. It's forced to move at the same horizontal speed as the outer circle, so it must slip along its imaginary track.</p>

            <div class="comparison">
                <div class="comparison-col outer">
                    <h4>Outer Circle</h4>
                    <p><strong>Motion:</strong> Pure rolling</p>
                    <p><strong>Distance:</strong> 2πR (its circumference)</p>
                    <p><strong>Slipping:</strong> None</p>
                </div>
                <div class="comparison-col inner">
                    <h4>Inner Circle</h4>
                    <p><strong>Motion:</strong> Rolling + Sliding</p>
                    <p><strong>Distance:</strong> 2πR (forced by outer)</p>
                    <p><strong>Slipping:</strong> 2π(R - r)</p>
                </div>
            </div>

            <p>If you've ever parked too close to a curb and heard your hubcap <em>screech</em> against it, you've witnessed this paradox in action! The hubcap (inner circle) slips along the curb while your tire (outer circle) rolls on the pavement.</p>
        </div>

        <!-- Galileo's Approach -->
        <div class="card">
            <h2>Galileo's Hexagon: The Atomic Insight</h2>
            <p>In his 1638 masterwork <em>Two New Sciences</em>, Galileo explored this paradox using polygons instead of circles. His approach led to profound insights about infinity and the nature of matter.</p>

            <div class="hexagon-demo">
                <canvas id="hexagonCanvas" width="700" height="250"></canvas>
                <div class="hexagon-controls">
                    <button class="btn btn-secondary" id="rollHexBtn">Roll Polygon</button>
                    <input type="range" id="sidesSlider" min="3" max="60" value="6" style="width: 150px;">
                    <span class="sides-display" id="sidesDisplay">6 sides</span>
                </div>
            </div>

            <p>Watch what happens: when a hexagon "rolls," each face lands flat on the ground in sequence. But the inner hexagon <strong>jumps</strong> over gaps with each step!</p>
            <p>Galileo realized that as the number of sides increases toward infinity (approaching a circle), these gaps become infinitesimally small—an infinite number of infinitely small gaps. This was one of the earliest explorations of infinitesimals, predating calculus.</p>

            <div class="insight-box">
                <h3>&#127758; Galileo's Leap</h3>
                <p>Galileo used this paradox to argue for atomism—that matter is made of indivisible atoms separated by tiny voids. He proposed that even continuous curves might be composed of infinitely many points with infinitely many infinitesimal gaps.</p>
            </div>
        </div>

        <!-- Mathematical Resolution -->
        <div class="card">
            <h2>The Mathematical Fallacy</h2>
            <p>There's a deeper mathematical error lurking in the paradox. The argument seems to imply:</p>
            <ol style="margin-left: 25px; color: #555; margin-bottom: 20px;">
                <li>Each point on the outer circle corresponds to exactly one point on the inner circle (they're connected by radii)</li>
                <li>As the wheel rolls, each point on the outer circle touches exactly one point on the ground track</li>
                <li>Therefore, the inner circle's track must have the same number of points</li>
                <li>Therefore, both tracks are the same length</li>
            </ol>

            <p><strong>The fallacy is in step 4.</strong> Having the same number of points does NOT mean having the same length!</p>

            <div class="formula">
                |[0, 1]| = |[0, 2]| = ℵ₁<br>
                <span style="font-size: 0.9rem; color: #888;">Both intervals have the same cardinality (number of points), but different lengths</span>
            </div>

            <p>This is a fundamental insight from set theory: the <strong>cardinality</strong> (count of elements) of a set is different from its <strong>measure</strong> (length, area, volume). Any line segment, no matter how short, contains exactly as many points as any other line segment—even an infinite line!</p>
        </div>

        <!-- The Trochoid -->
        <div class="card">
            <h2>The Path of a Point: Trochoids</h2>
            <p>If you track a point on the rim of each circle as the wheel rolls, you see different curves:</p>
            <ul style="margin-left: 25px; color: #555; margin-bottom: 20px;">
                <li><strong>Outer circle:</strong> The point traces a <strong>cycloid</strong>—the same curve as the brachistochrone!</li>
                <li><strong>Inner circle:</strong> The point traces a <strong>curtate trochoid</strong>—a squashed, looping curve</li>
            </ul>
            <p>The curtate trochoid clearly shows the combination of rotation and horizontal translation that constitutes the inner circle's "sliding" motion. Toggle "Show Trochoid Path" in the simulation above to see it!</p>
        </div>

        <!-- Real World -->
        <div class="card">
            <h2>Where You'll See This</h2>
            <p>The wheel paradox appears whenever concentric circles rotate together:</p>
            <ul style="margin-left: 25px; color: #555;">
                <li><strong>Car wheels:</strong> Hubcaps slide against curbs while tires roll</li>
                <li><strong>Gear systems:</strong> Inner and outer gear teeth experience different wear patterns</li>
                <li><strong>Record players:</strong> The inner groove moves slower (angularly) but the arm moves at constant linear speed</li>
                <li><strong>Figure skating:</strong> A spinning skater's hands travel faster than their core</li>
            </ul>
        </div>

        <div class="footer">
            <p>Sources: <a href="https://en.wikipedia.org/wiki/Aristotle's_wheel_paradox" target="_blank">Wikipedia</a>,
            <a href="https://mathworld.wolfram.com/AristotlesWheelParadox.html" target="_blank">Wolfram MathWorld</a>,
            <a href="https://scholarship.claremont.edu/cgi/viewcontent.cgi?article=1104&context=jhm" target="_blank">Galileo and Aristotle's Wheel</a></p>
            <p style="margin-top: 10px;">Part of <a href="../index.html">CCAB</a> &middot; Surprising Paradoxes Collection</p>
        </div>
    </main>

    <script>
        // === ARISTOTLE'S WHEEL SIMULATION ===
        const wheelCanvas = document.getElementById('wheelCanvas');
        const wheelCtx = wheelCanvas.getContext('2d');

        // High DPI
        const dpr = window.devicePixelRatio || 1;
        const wheelRect = wheelCanvas.getBoundingClientRect();
        wheelCanvas.width = wheelRect.width * dpr;
        wheelCanvas.height = wheelRect.height * dpr;
        wheelCtx.scale(dpr, dpr);
        wheelCanvas.style.width = wheelRect.width + 'px';
        wheelCanvas.style.height = wheelRect.height + 'px';

        const W = wheelRect.width;
        const H = wheelRect.height;

        // Wheel parameters
        const outerR = 80;
        const innerR = 40;
        const groundY = H - 100;
        const innerTrackY = groundY - outerR + innerR;
        const startX = 120;

        let wheelAngle = 0;
        let isRolling = false;
        let showTracks = true;
        let showSlip = false;
        let showTrochoid = false;

        // Trails
        let outerTrail = [];
        let innerTrail = [];

        // Calculate wheel center X from angle
        function getWheelX(angle) {
            return startX + outerR * angle;
        }

        // Draw wheel
        function drawWheel() {
            wheelCtx.clearRect(0, 0, W, H);

            // Background
            const bgGrad = wheelCtx.createLinearGradient(0, 0, 0, H);
            bgGrad.addColorStop(0, '#0f0f23');
            bgGrad.addColorStop(1, '#1a1a2e');
            wheelCtx.fillStyle = bgGrad;
            wheelCtx.fillRect(0, 0, W, H);

            // Ground line (outer track)
            wheelCtx.strokeStyle = '#ff6b6b';
            wheelCtx.lineWidth = 3;
            wheelCtx.beginPath();
            wheelCtx.moveTo(0, groundY);
            wheelCtx.lineTo(W, groundY);
            wheelCtx.stroke();

            // Inner track line
            wheelCtx.strokeStyle = '#4ecdc4';
            wheelCtx.lineWidth = 3;
            wheelCtx.beginPath();
            wheelCtx.moveTo(0, innerTrackY);
            wheelCtx.lineTo(W, innerTrackY);
            wheelCtx.stroke();

            // Labels
            wheelCtx.fillStyle = 'rgba(255,255,255,0.5)';
            wheelCtx.font = '12px Nunito';
            wheelCtx.textAlign = 'left';
            wheelCtx.fillText('Outer track (ground)', 10, groundY + 20);
            wheelCtx.fillText('Inner track', 10, innerTrackY - 10);

            const cx = getWheelX(wheelAngle);
            const cy = groundY - outerR;

            // Show slip distance if enabled
            if (showSlip && wheelAngle > 0) {
                const outerDist = outerR * wheelAngle;
                const innerCircum = innerR * wheelAngle;
                const slipDist = outerDist - innerCircum;

                // Highlight slip region on inner track
                wheelCtx.fillStyle = 'rgba(255, 217, 61, 0.3)';
                wheelCtx.fillRect(startX + innerCircum, innerTrackY - 5, slipDist, 10);

                // Slip markers
                wheelCtx.strokeStyle = '#ffd93d';
                wheelCtx.setLineDash([4, 4]);
                wheelCtx.lineWidth = 2;
                wheelCtx.beginPath();
                wheelCtx.moveTo(startX + innerCircum, innerTrackY - 15);
                wheelCtx.lineTo(startX + innerCircum, innerTrackY + 15);
                wheelCtx.moveTo(startX + outerDist, innerTrackY - 15);
                wheelCtx.lineTo(startX + outerDist, innerTrackY + 15);
                wheelCtx.stroke();
                wheelCtx.setLineDash([]);

                // Slip label
                if (slipDist > 30) {
                    wheelCtx.fillStyle = '#ffd93d';
                    wheelCtx.font = 'bold 11px Nunito';
                    wheelCtx.textAlign = 'center';
                    wheelCtx.fillText('SLIP', startX + innerCircum + slipDist/2, innerTrackY - 20);
                }
            }

            // Draw trochoid trails if enabled
            if (showTrochoid) {
                // Outer (cycloid)
                if (outerTrail.length > 1) {
                    wheelCtx.strokeStyle = 'rgba(255, 107, 107, 0.6)';
                    wheelCtx.lineWidth = 2;
                    wheelCtx.beginPath();
                    wheelCtx.moveTo(outerTrail[0].x, outerTrail[0].y);
                    for (let i = 1; i < outerTrail.length; i++) {
                        wheelCtx.lineTo(outerTrail[i].x, outerTrail[i].y);
                    }
                    wheelCtx.stroke();
                }

                // Inner (curtate trochoid)
                if (innerTrail.length > 1) {
                    wheelCtx.strokeStyle = 'rgba(78, 205, 196, 0.6)';
                    wheelCtx.lineWidth = 2;
                    wheelCtx.beginPath();
                    wheelCtx.moveTo(innerTrail[0].x, innerTrail[0].y);
                    for (let i = 1; i < innerTrail.length; i++) {
                        wheelCtx.lineTo(innerTrail[i].x, innerTrail[i].y);
                    }
                    wheelCtx.stroke();
                }
            }

            // Draw outer circle
            wheelCtx.strokeStyle = '#ff6b6b';
            wheelCtx.lineWidth = 4;
            wheelCtx.beginPath();
            wheelCtx.arc(cx, cy, outerR, 0, Math.PI * 2);
            wheelCtx.stroke();

            // Draw inner circle
            wheelCtx.strokeStyle = '#4ecdc4';
            wheelCtx.lineWidth = 4;
            wheelCtx.beginPath();
            wheelCtx.arc(cx, cy, innerR, 0, Math.PI * 2);
            wheelCtx.stroke();

            // Draw spokes
            wheelCtx.strokeStyle = 'rgba(255,255,255,0.3)';
            wheelCtx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                const angle = wheelAngle + (i * Math.PI / 4);
                wheelCtx.beginPath();
                wheelCtx.moveTo(cx, cy);
                wheelCtx.lineTo(cx + outerR * Math.cos(angle), cy + outerR * Math.sin(angle));
                wheelCtx.stroke();
            }

            // Draw center
            wheelCtx.fillStyle = '#fff';
            wheelCtx.beginPath();
            wheelCtx.arc(cx, cy, 5, 0, Math.PI * 2);
            wheelCtx.fill();

            // Marker points on circles
            const outerPx = cx + outerR * Math.cos(wheelAngle + Math.PI/2);
            const outerPy = cy + outerR * Math.sin(wheelAngle + Math.PI/2);
            wheelCtx.fillStyle = '#ff6b6b';
            wheelCtx.beginPath();
            wheelCtx.arc(outerPx, outerPy, 8, 0, Math.PI * 2);
            wheelCtx.fill();

            const innerPx = cx + innerR * Math.cos(wheelAngle + Math.PI/2);
            const innerPy = cy + innerR * Math.sin(wheelAngle + Math.PI/2);
            wheelCtx.fillStyle = '#4ecdc4';
            wheelCtx.beginPath();
            wheelCtx.arc(innerPx, innerPy, 8, 0, Math.PI * 2);
            wheelCtx.fill();

            // Add to trails
            if (isRolling && showTrochoid) {
                outerTrail.push({ x: outerPx, y: outerPy });
                innerTrail.push({ x: innerPx, y: innerPy });
            }

            // Contact points
            if (showTracks) {
                // Outer contact
                wheelCtx.fillStyle = '#ff6b6b';
                wheelCtx.beginPath();
                wheelCtx.arc(cx, groundY, 6, 0, Math.PI * 2);
                wheelCtx.fill();

                // Inner "contact" (where it would touch)
                wheelCtx.fillStyle = '#4ecdc4';
                wheelCtx.beginPath();
                wheelCtx.arc(cx, innerTrackY, 6, 0, Math.PI * 2);
                wheelCtx.fill();
            }

            // Distance markers
            if (wheelAngle > 0.1) {
                const dist = outerR * wheelAngle;

                // Start marker
                wheelCtx.strokeStyle = 'rgba(255,255,255,0.5)';
                wheelCtx.lineWidth = 1;
                wheelCtx.setLineDash([3, 3]);
                wheelCtx.beginPath();
                wheelCtx.moveTo(startX, groundY + 30);
                wheelCtx.lineTo(startX, groundY + 50);
                wheelCtx.moveTo(startX + dist, groundY + 30);
                wheelCtx.lineTo(startX + dist, groundY + 50);
                wheelCtx.moveTo(startX, groundY + 40);
                wheelCtx.lineTo(startX + dist, groundY + 40);
                wheelCtx.stroke();
                wheelCtx.setLineDash([]);

                wheelCtx.fillStyle = 'rgba(255,255,255,0.7)';
                wheelCtx.font = '12px Courier New';
                wheelCtx.textAlign = 'center';
                wheelCtx.fillText(`Distance: ${dist.toFixed(0)}px`, startX + dist/2, groundY + 60);
            }

            // Update info
            document.getElementById('outerCirc').textContent = `${(2 * Math.PI * outerR).toFixed(0)}px`;
            document.getElementById('innerCirc').textContent = `${(2 * Math.PI * innerR).toFixed(0)}px`;
            document.getElementById('distTraveled').textContent = `${(outerR * wheelAngle).toFixed(0)}px`;
            document.getElementById('slipDist').textContent = `${((outerR - innerR) * wheelAngle).toFixed(0)}px`;
        }

        // Animation
        function animateWheel() {
            if (isRolling) {
                wheelAngle += 0.02;
                if (wheelAngle >= Math.PI * 2) {
                    wheelAngle = Math.PI * 2;
                    isRolling = false;
                    document.getElementById('rollBtn').disabled = false;
                }
            }
            drawWheel();
            requestAnimationFrame(animateWheel);
        }

        // Event handlers
        document.getElementById('rollBtn').addEventListener('click', function() {
            if (!isRolling && wheelAngle < Math.PI * 2) {
                isRolling = true;
                this.disabled = true;
            }
        });

        document.getElementById('resetBtn').addEventListener('click', function() {
            wheelAngle = 0;
            isRolling = false;
            outerTrail = [];
            innerTrail = [];
            document.getElementById('rollBtn').disabled = false;
            drawWheel();
        });

        document.getElementById('showTracksBtn').addEventListener('click', function() {
            showTracks = !showTracks;
            this.classList.toggle('active');
        });

        document.getElementById('showSlipBtn').addEventListener('click', function() {
            showSlip = !showSlip;
            this.classList.toggle('active');
        });

        document.getElementById('showTrochoidBtn').addEventListener('click', function() {
            showTrochoid = !showTrochoid;
            this.classList.toggle('active');
        });

        // === HEXAGON DEMO ===
        const hexCanvas = document.getElementById('hexagonCanvas');
        const hexCtx = hexCanvas.getContext('2d');

        const hW = 700;
        const hH = 250;
        hexCanvas.width = hW * dpr;
        hexCanvas.height = hH * dpr;
        hexCtx.scale(dpr, dpr);
        hexCanvas.style.width = hW + 'px';
        hexCanvas.style.height = hH + 'px';

        let numSides = 6;
        let hexAngle = 0;
        let hexRolling = false;
        const hexOuterR = 50;
        const hexInnerR = 25;
        const hexGroundY = hH - 70;
        const hexStartX = 80;

        function drawPolygon(ctx, cx, cy, r, sides, rotation, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i <= sides; i++) {
                const angle = rotation + (i * 2 * Math.PI / sides) - Math.PI / 2;
                const x = cx + r * Math.cos(angle);
                const y = cy + r * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function drawHexagonDemo() {
            hexCtx.clearRect(0, 0, hW, hH);

            // Background
            hexCtx.fillStyle = '#fafafa';
            hexCtx.fillRect(0, 0, hW, hH);

            // Calculate position based on rolling
            const sideAngle = 2 * Math.PI / numSides;
            const apothem = hexOuterR * Math.cos(Math.PI / numSides);
            const sideLength = 2 * hexOuterR * Math.sin(Math.PI / numSides);

            // How many complete sides have we rolled?
            const completeSides = Math.floor(hexAngle / sideAngle);
            const partialAngle = hexAngle % sideAngle;

            // Calculate center position
            let cx = hexStartX + completeSides * sideLength;
            let pivotAngle = -Math.PI/2 + completeSides * sideAngle;

            // During partial roll, pivot around corner
            if (partialAngle > 0) {
                const pivotX = cx + hexOuterR * Math.cos(pivotAngle);
                const pivotY = hexGroundY;
                cx = pivotX + apothem * Math.sin(partialAngle);
            }

            const cy = hexGroundY - apothem;

            // Ground line
            hexCtx.strokeStyle = '#ccc';
            hexCtx.lineWidth = 2;
            hexCtx.beginPath();
            hexCtx.moveTo(0, hexGroundY);
            hexCtx.lineTo(hW, hexGroundY);
            hexCtx.stroke();

            // Inner track
            const innerApothem = hexInnerR * Math.cos(Math.PI / numSides);
            const innerTrackY = hexGroundY - apothem + innerApothem;
            hexCtx.strokeStyle = '#4ecdc4';
            hexCtx.lineWidth = 1;
            hexCtx.setLineDash([5, 5]);
            hexCtx.beginPath();
            hexCtx.moveTo(0, innerTrackY);
            hexCtx.lineTo(hW, innerTrackY);
            hexCtx.stroke();
            hexCtx.setLineDash([]);

            // Show gaps for inner polygon
            if (completeSides > 0 && numSides < 20) {
                const innerSideLength = 2 * hexInnerR * Math.sin(Math.PI / numSides);
                const gapSize = sideLength - innerSideLength;

                hexCtx.fillStyle = 'rgba(255, 217, 61, 0.4)';
                for (let i = 0; i < completeSides; i++) {
                    const gapX = hexStartX + i * sideLength + innerSideLength;
                    hexCtx.fillRect(gapX, innerTrackY - 5, gapSize, 10);
                }

                // Label
                if (gapSize > 10) {
                    hexCtx.fillStyle = '#b8860b';
                    hexCtx.font = '10px Nunito';
                    hexCtx.textAlign = 'center';
                    hexCtx.fillText('gaps', hexStartX + sideLength/2, innerTrackY - 15);
                }
            }

            // Draw outer polygon
            drawPolygon(hexCtx, cx, cy, hexOuterR, numSides, hexAngle, '#ff6b6b');

            // Draw inner polygon
            drawPolygon(hexCtx, cx, cy, hexInnerR, numSides, hexAngle, '#4ecdc4');

            // Center dot
            hexCtx.fillStyle = '#333';
            hexCtx.beginPath();
            hexCtx.arc(cx, cy, 4, 0, Math.PI * 2);
            hexCtx.fill();

            // Labels
            hexCtx.fillStyle = '#666';
            hexCtx.font = '12px Nunito';
            hexCtx.textAlign = 'left';
            hexCtx.fillText('Outer polygon rolls on ground', 10, 20);
            hexCtx.fillText('Inner polygon jumps over gaps!', 10, 38);
        }

        function animateHexagon() {
            if (hexRolling) {
                hexAngle += 0.03;
                const maxAngle = (2 * Math.PI / numSides) * Math.min(numSides, 8);
                if (hexAngle >= maxAngle) {
                    hexAngle = maxAngle;
                    hexRolling = false;
                    document.getElementById('rollHexBtn').innerHTML = '<span>&#9654;</span> Roll Polygon';
                }
            }
            drawHexagonDemo();
            requestAnimationFrame(animateHexagon);
        }

        document.getElementById('rollHexBtn').addEventListener('click', function() {
            if (!hexRolling) {
                hexAngle = 0;
                hexRolling = true;
                this.innerHTML = '<span>&#9632;</span> Rolling...';
            }
        });

        document.getElementById('sidesSlider').addEventListener('input', function() {
            numSides = parseInt(this.value);
            document.getElementById('sidesDisplay').textContent = numSides + ' sides';
            hexAngle = 0;
            hexRolling = false;
            document.getElementById('rollHexBtn').innerHTML = '<span>&#9654;</span> Roll Polygon';
            drawHexagonDemo();
        });

        // Initialize
        drawWheel();
        drawHexagonDemo();
        requestAnimationFrame(animateWheel);
        requestAnimationFrame(animateHexagon);
    </script>
</body>
</html>
