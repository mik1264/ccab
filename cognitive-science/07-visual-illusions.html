<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Illusions | Cognitive Science</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e2e8f0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        .back-link {
            display: inline-block;
            color: #c084fc;
            text-decoration: none;
            margin-bottom: 20px;
            padding: 8px 16px;
            border: 1px solid rgba(192, 132, 252, 0.3);
            border-radius: 20px;
            transition: all 0.3s;
        }

        .back-link:hover {
            background: rgba(192, 132, 252, 0.1);
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #c084fc, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #94a3b8;
            font-size: 1.1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
        }

        .simulation-area {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid rgba(192, 132, 252, 0.2);
        }

        .illusion-display {
            background: #ffffff;
            border-radius: 15px;
            min-height: 450px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #canvas {
            max-width: 100%;
            max-height: 450px;
        }

        .illusion-name {
            text-align: center;
            margin-top: 20px;
            font-size: 1.3rem;
            color: #c084fc;
        }

        .controls {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(192, 132, 252, 0.2);
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group label {
            display: block;
            margin-bottom: 10px;
            color: #c084fc;
            font-weight: 600;
        }

        .task-select {
            width: 100%;
            padding: 12px;
            font-size: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(192, 132, 252, 0.3);
            border-radius: 8px;
            color: white;
        }

        .task-select option {
            background: #1a1a2e;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(192, 132, 252, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #c084fc;
            cursor: pointer;
        }

        .control-value {
            text-align: center;
            margin-top: 8px;
            font-size: 0.9rem;
            color: #94a3b8;
        }

        .btn {
            width: 100%;
            padding: 15px 30px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #c084fc, #a855f7);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(192, 132, 252, 0.4);
        }

        .info-box {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 0.9rem;
            line-height: 1.6;
            color: #94a3b8;
        }

        .info-box strong {
            color: #c084fc;
        }

        .explanation {
            background: rgba(192, 132, 252, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .explanation h3 {
            color: #c084fc;
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .explanation p {
            color: #94a3b8;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .toggle-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
        }

        .toggle-label {
            color: #94a3b8;
        }

        .toggle {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 26px;
            transition: 0.3s;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background: white;
            border-radius: 50%;
            transition: 0.3s;
        }

        .toggle input:checked + .toggle-slider {
            background: #c084fc;
        }

        .toggle input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">← Back to Cognitive Science</a>
            <h1>Visual Illusions</h1>
            <p class="subtitle">Discover how your brain constructs visual reality</p>
        </header>

        <div class="main-content">
            <div class="simulation-area">
                <div class="illusion-display">
                    <canvas id="canvas" width="600" height="450"></canvas>
                </div>
                <div class="illusion-name" id="illusionName">Müller-Lyer Illusion</div>
            </div>

            <div class="controls">
                <div class="info-box">
                    <strong>Visual Illusions:</strong><br>
                    These demonstrate that perception is an active construction by your brain, not a passive recording of reality.
                </div>

                <div class="control-group">
                    <label>Select Illusion</label>
                    <select class="task-select" id="illusionType">
                        <option value="muller-lyer">Müller-Lyer (Line Length)</option>
                        <option value="ebbinghaus">Ebbinghaus (Size Contrast)</option>
                        <option value="ponzo">Ponzo (Perspective)</option>
                        <option value="checker-shadow">Checker Shadow</option>
                        <option value="cafe-wall">Café Wall</option>
                        <option value="rotating-snakes">Rotating Snakes</option>
                        <option value="hermann-grid">Hermann Grid</option>
                        <option value="kanizsa">Kanizsa Triangle</option>
                    </select>
                </div>

                <div class="control-group" id="paramControl">
                    <label>Illusion Strength: <span id="paramValue">50</span>%</label>
                    <input type="range" id="param" min="0" max="100" value="50">
                </div>

                <div class="toggle-row">
                    <span class="toggle-label">Show Solution</span>
                    <label class="toggle">
                        <input type="checkbox" id="showSolution">
                        <span class="toggle-slider"></span>
                    </label>
                </div>

                <button class="btn btn-primary" id="animateBtn">Toggle Animation</button>

                <div class="explanation" id="explanation">
                    <h3>How It Works</h3>
                    <p id="explanationText">
                        The Müller-Lyer illusion: The lines are the same length, but the arrow directions create an illusion of different lengths. Your brain uses the arrows as depth cues.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let currentIllusion = 'muller-lyer';
        let param = 50;
        let showSolution = false;
        let animating = false;
        let animationId;
        let frame = 0;

        const illusionType = document.getElementById('illusionType');
        const paramSlider = document.getElementById('param');
        const paramValue = document.getElementById('paramValue');
        const showSolutionToggle = document.getElementById('showSolution');
        const animateBtn = document.getElementById('animateBtn');
        const illusionName = document.getElementById('illusionName');
        const explanationText = document.getElementById('explanationText');

        const explanations = {
            'muller-lyer': 'The Müller-Lyer illusion: The horizontal lines are identical in length, but the arrow directions create an illusion of different lengths. Your brain interprets the outward arrows as corners pointing away (like an outside corner of a building) and inward arrows as corners pointing toward you.',
            'ebbinghaus': 'The Ebbinghaus illusion: The two central circles are exactly the same size! The surrounding circles create a size contrast effect. When surrounded by larger circles, the central circle appears smaller, and vice versa.',
            'ponzo': 'The Ponzo illusion: Both horizontal lines are the same length. The converging lines create a sense of depth (like railroad tracks), making the upper line appear larger because your brain interprets it as being "farther away."',
            'checker-shadow': 'The checker shadow illusion: Squares A and B are exactly the same shade of gray! Your visual system compensates for the shadow by brightening the perceived color of squares within it. Toggle "Show Solution" to see the truth.',
            'cafe-wall': 'The Café Wall illusion: All the horizontal lines are perfectly parallel! The offset pattern of dark and light tiles, combined with the gray mortar lines, creates an illusion of slanted lines.',
            'rotating-snakes': 'The rotating snakes illusion: This static image appears to move due to the specific arrangement of colors and shapes. Your peripheral vision processes motion differently than your central vision, creating phantom movement.',
            'hermann-grid': 'The Hermann Grid illusion: You see gray dots at the intersections of the white lines, but when you look directly at any intersection, the dot disappears! This is due to lateral inhibition in your retinal ganglion cells.',
            'kanizsa': 'The Kanizsa Triangle: You perceive a bright white triangle even though no triangle is actually drawn! Your brain "fills in" the edges based on the pac-man shapes, demonstrating how perception creates objects from incomplete information.'
        };

        function draw() {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            switch (currentIllusion) {
                case 'muller-lyer': drawMullerLyer(); break;
                case 'ebbinghaus': drawEbbinghaus(); break;
                case 'ponzo': drawPonzo(); break;
                case 'checker-shadow': drawCheckerShadow(); break;
                case 'cafe-wall': drawCafeWall(); break;
                case 'rotating-snakes': drawRotatingSnakes(); break;
                case 'hermann-grid': drawHermannGrid(); break;
                case 'kanizsa': drawKanizsa(); break;
            }
        }

        function drawMullerLyer() {
            const centerY1 = 180;
            const centerY2 = 320;
            const lineLength = 200;
            const arrowLength = 30 + param * 0.3;
            const arrowAngle = 30 * Math.PI / 180;

            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 4;

            // Top line with outward arrows
            ctx.beginPath();
            ctx.moveTo(200, centerY1);
            ctx.lineTo(400, centerY1);
            ctx.stroke();

            // Outward arrows
            ctx.beginPath();
            ctx.moveTo(200, centerY1);
            ctx.lineTo(200 - arrowLength * Math.cos(arrowAngle), centerY1 - arrowLength * Math.sin(arrowAngle));
            ctx.moveTo(200, centerY1);
            ctx.lineTo(200 - arrowLength * Math.cos(arrowAngle), centerY1 + arrowLength * Math.sin(arrowAngle));
            ctx.moveTo(400, centerY1);
            ctx.lineTo(400 + arrowLength * Math.cos(arrowAngle), centerY1 - arrowLength * Math.sin(arrowAngle));
            ctx.moveTo(400, centerY1);
            ctx.lineTo(400 + arrowLength * Math.cos(arrowAngle), centerY1 + arrowLength * Math.sin(arrowAngle));
            ctx.stroke();

            // Bottom line with inward arrows
            ctx.beginPath();
            ctx.moveTo(200, centerY2);
            ctx.lineTo(400, centerY2);
            ctx.stroke();

            // Inward arrows
            ctx.beginPath();
            ctx.moveTo(200, centerY2);
            ctx.lineTo(200 + arrowLength * Math.cos(arrowAngle), centerY2 - arrowLength * Math.sin(arrowAngle));
            ctx.moveTo(200, centerY2);
            ctx.lineTo(200 + arrowLength * Math.cos(arrowAngle), centerY2 + arrowLength * Math.sin(arrowAngle));
            ctx.moveTo(400, centerY2);
            ctx.lineTo(400 - arrowLength * Math.cos(arrowAngle), centerY2 - arrowLength * Math.sin(arrowAngle));
            ctx.moveTo(400, centerY2);
            ctx.lineTo(400 - arrowLength * Math.cos(arrowAngle), centerY2 + arrowLength * Math.sin(arrowAngle));
            ctx.stroke();

            if (showSolution) {
                ctx.strokeStyle = '#c084fc';
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(200, centerY1 - 40);
                ctx.lineTo(200, centerY2 + 40);
                ctx.moveTo(400, centerY1 - 40);
                ctx.lineTo(400, centerY2 + 40);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = '#c084fc';
                ctx.font = '16px sans-serif';
                ctx.fillText('Same length!', 260, 260);
            }
        }

        function drawEbbinghaus() {
            const centerRadius = 25;
            const smallRadius = 12 + param * 0.1;
            const largeRadius = 40 + param * 0.2;

            // Left group (large surrounding)
            ctx.fillStyle = '#a855f7';
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = 180 + Math.cos(angle) * 80;
                const y = 225 + Math.sin(angle) * 80;
                ctx.beginPath();
                ctx.arc(x, y, largeRadius, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.fillStyle = '#f97316';
            ctx.beginPath();
            ctx.arc(180, 225, centerRadius, 0, Math.PI * 2);
            ctx.fill();

            // Right group (small surrounding)
            ctx.fillStyle = '#a855f7';
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = 420 + Math.cos(angle) * 50;
                const y = 225 + Math.sin(angle) * 50;
                ctx.beginPath();
                ctx.arc(x, y, smallRadius, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.fillStyle = '#f97316';
            ctx.beginPath();
            ctx.arc(420, 225, centerRadius, 0, Math.PI * 2);
            ctx.fill();

            if (showSolution) {
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(180, 225, centerRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(420, 225, centerRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = '#22c55e';
                ctx.font = '14px sans-serif';
                ctx.fillText('Same size!', 270, 380);
            }
        }

        function drawPonzo() {
            // Converging lines
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(150, 400);
            ctx.lineTo(300, 50);
            ctx.moveTo(450, 400);
            ctx.lineTo(300, 50);
            ctx.stroke();

            const lineWidth = 100;
            const topY = 120;
            const bottomY = 320;

            // Horizontal lines
            ctx.lineWidth = 8;
            ctx.strokeStyle = '#ef4444';
            ctx.beginPath();
            ctx.moveTo(300 - lineWidth/2, topY);
            ctx.lineTo(300 + lineWidth/2, topY);
            ctx.stroke();

            ctx.strokeStyle = '#3b82f6';
            ctx.beginPath();
            ctx.moveTo(300 - lineWidth/2, bottomY);
            ctx.lineTo(300 + lineWidth/2, bottomY);
            ctx.stroke();

            if (showSolution) {
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(300 - lineWidth/2, topY - 20);
                ctx.lineTo(300 - lineWidth/2, bottomY + 20);
                ctx.moveTo(300 + lineWidth/2, topY - 20);
                ctx.lineTo(300 + lineWidth/2, bottomY + 20);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        function drawCheckerShadow() {
            const tileSize = 40;
            const startX = 120;
            const startY = 80;

            // Draw checkerboard
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const isDark = (row + col) % 2 === 0;
                    let color = isDark ? '#585858' : '#a8a8a8';

                    // Apply shadow gradient
                    const shadowStrength = Math.max(0, (col - 2) / 5);
                    if (col > 2) {
                        const r = parseInt(color.slice(1, 3), 16);
                        const g = parseInt(color.slice(3, 5), 16);
                        const b = parseInt(color.slice(5, 7), 16);
                        const factor = 1 - shadowStrength * 0.5;
                        color = `rgb(${Math.round(r * factor)}, ${Math.round(g * factor)}, ${Math.round(b * factor)})`;
                    }

                    ctx.fillStyle = color;
                    ctx.fillRect(startX + col * tileSize, startY + row * tileSize, tileSize, tileSize);
                }
            }

            // Mark squares A and B
            ctx.font = 'bold 20px sans-serif';
            ctx.fillStyle = '#c084fc';
            ctx.fillText('A', startX + 3.5 * tileSize + 12, startY + 3.5 * tileSize + 8);
            ctx.fillText('B', startX + 5.5 * tileSize + 12, startY + 5.5 * tileSize + 8);

            if (showSolution) {
                // Show that A and B are the same color
                ctx.fillStyle = '#787878';
                ctx.fillRect(480, 200, 60, 60);
                ctx.fillRect(480, 280, 60, 60);
                ctx.fillStyle = '#c084fc';
                ctx.font = '14px sans-serif';
                ctx.fillText('A & B:', 480, 190);
                ctx.fillText('Same!', 485, 360);
            }
        }

        function drawCafeWall() {
            const tileWidth = 40;
            const tileHeight = 25;
            const mortarHeight = 3;
            const offset = param * 0.4;

            for (let row = 0; row < 12; row++) {
                // Draw mortar line
                ctx.fillStyle = '#888888';
                ctx.fillRect(50, 60 + row * (tileHeight + mortarHeight), 500, mortarHeight);

                // Draw tiles with offset
                const rowOffset = (row % 2 === 0) ? offset : -offset;
                for (let col = -1; col < 14; col++) {
                    const isDark = col % 2 === 0;
                    ctx.fillStyle = isDark ? '#1a1a2e' : '#ffffff';
                    ctx.fillRect(
                        50 + col * tileWidth + rowOffset,
                        60 + row * (tileHeight + mortarHeight) + mortarHeight,
                        tileWidth,
                        tileHeight
                    );
                }
            }

            if (showSolution) {
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 2;
                for (let row = 0; row < 12; row++) {
                    ctx.beginPath();
                    ctx.moveTo(50, 60 + row * (tileHeight + mortarHeight) + tileHeight / 2);
                    ctx.lineTo(550, 60 + row * (tileHeight + mortarHeight) + tileHeight / 2);
                    ctx.stroke();
                }
            }
        }

        function drawRotatingSnakes() {
            const colors = ['#00ff00', '#000000', '#ff00ff', '#ffffff'];
            const cellSize = 20;
            const offset = animating ? frame * 0.02 : 0;

            for (let ring = 0; ring < 4; ring++) {
                const radius = 60 + ring * 50;
                const circumference = 2 * Math.PI * radius;
                const numCells = Math.floor(circumference / cellSize);

                for (let i = 0; i < numCells; i++) {
                    const angle = (i / numCells) * Math.PI * 2 + offset * (ring % 2 === 0 ? 1 : -1);
                    const x = 300 + Math.cos(angle) * radius;
                    const y = 225 + Math.sin(angle) * radius;

                    ctx.fillStyle = colors[(i + ring) % 4];
                    ctx.beginPath();
                    ctx.arc(x, y, cellSize / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawHermannGrid() {
            const squareSize = 50;
            const gap = 10;
            const startX = 100;
            const startY = 75;

            ctx.fillStyle = '#1a1a2e';
            for (let row = 0; row < 6; row++) {
                for (let col = 0; col < 7; col++) {
                    ctx.fillRect(
                        startX + col * (squareSize + gap),
                        startY + row * (squareSize + gap),
                        squareSize,
                        squareSize
                    );
                }
            }

            if (showSolution) {
                ctx.fillStyle = '#c084fc';
                ctx.font = '12px sans-serif';
                ctx.fillText('Look at intersections - gray dots appear!', 150, 420);
                ctx.fillText('But they disappear when you look directly.', 150, 440);
            }
        }

        function drawKanizsa() {
            const centerX = 300;
            const centerY = 225;
            const radius = 60;
            const triangleSize = 150;

            // Draw pac-man shapes
            ctx.fillStyle = '#1a1a2e';

            const corners = [
                { x: centerX, y: centerY - triangleSize * 0.6, angle: Math.PI / 2 },
                { x: centerX - triangleSize * 0.5, y: centerY + triangleSize * 0.4, angle: -Math.PI / 6 },
                { x: centerX + triangleSize * 0.5, y: centerY + triangleSize * 0.4, angle: Math.PI + Math.PI / 6 }
            ];

            corners.forEach(corner => {
                ctx.beginPath();
                ctx.moveTo(corner.x, corner.y);
                ctx.arc(corner.x, corner.y, radius, corner.angle - Math.PI * 0.8, corner.angle + Math.PI * 0.8);
                ctx.closePath();
                ctx.fill();
            });

            // Draw outline triangles
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX - 100, centerY + 80);
            ctx.lineTo(centerX, centerY - 100);
            ctx.lineTo(centerX + 100, centerY + 80);
            ctx.closePath();
            ctx.stroke();

            if (showSolution) {
                ctx.strokeStyle = '#c084fc';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(centerX, centerY - triangleSize * 0.6 + radius);
                ctx.lineTo(centerX - triangleSize * 0.5 + radius * 0.5, centerY + triangleSize * 0.4 - radius * 0.5);
                ctx.lineTo(centerX + triangleSize * 0.5 - radius * 0.5, centerY + triangleSize * 0.4 - radius * 0.5);
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = '#c084fc';
                ctx.font = '14px sans-serif';
                ctx.fillText('No white triangle exists!', 220, 400);
            }
        }

        function animate() {
            if (!animating) return;
            frame++;
            draw();
            animationId = requestAnimationFrame(animate);
        }

        illusionType.addEventListener('change', () => {
            currentIllusion = illusionType.value;
            const names = {
                'muller-lyer': 'Müller-Lyer Illusion',
                'ebbinghaus': 'Ebbinghaus Illusion',
                'ponzo': 'Ponzo Illusion',
                'checker-shadow': 'Checker Shadow Illusion',
                'cafe-wall': 'Café Wall Illusion',
                'rotating-snakes': 'Rotating Snakes',
                'hermann-grid': 'Hermann Grid',
                'kanizsa': 'Kanizsa Triangle'
            };
            illusionName.textContent = names[currentIllusion];
            explanationText.textContent = explanations[currentIllusion];
            draw();
        });

        paramSlider.addEventListener('input', () => {
            param = parseInt(paramSlider.value);
            paramValue.textContent = param;
            draw();
        });

        showSolutionToggle.addEventListener('change', () => {
            showSolution = showSolutionToggle.checked;
            draw();
        });

        animateBtn.addEventListener('click', () => {
            animating = !animating;
            if (animating) {
                animate();
            } else {
                cancelAnimationFrame(animationId);
            }
        });

        draw();
    </script>
</body>
</html>
