<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ising Model Simulation - CCAB</title>
    <link rel="stylesheet" href="../assets/css/navigation.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Spectral:ital,wght@0,400;0,600;1,400&family=Space+Mono:wght@400;700&display=swap');

        :root {
            /* Color scheme matching main index */
            --bg-primary: #0a0e1a;
            --bg-secondary: #111827;
            --text-primary: #e0e0ff;
            --text-secondary: #a0a0c0;
            --text-accent: #fbbf24;
            --theme-color: #667eea;

            /* Spacing */
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;
            --spacing-2xl: 4rem;

            /* Typography */
            --font-display: 'Orbitron', sans-serif;
            --font-heading: 'Spectral', serif;
            --font-mono: 'Space Mono', monospace;
            --font-body: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

            /* Layout */
            --max-width: 1600px;
            --header-height: 64px;

            /* Transitions */
            --transition-base: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: linear-gradient(135deg, var(--bg-primary) 0%, #0f172a 50%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            padding: 20px;
            padding-top: calc(var(--header-height) + 20px);
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            font-family: var(--font-display);
            text-align: center;
            margin-bottom: 10px;
            font-size: clamp(2rem, 5vw, 3rem);
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 50%, var(--theme-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            padding: 12px 24px;
            background: rgba(224, 224, 255, 0.1);
            border: 2px solid rgba(224, 224, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
            color: var(--text-primary);
        }

        .tab:hover {
            background: rgba(224, 224, 255, 0.2);
            transform: translateY(-2px);
        }

        .tab.active {
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border-color: var(--theme-color);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .view {
            display: none;
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .view.active {
            display: block;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        input[type="range"] {
            width: 200px;
        }

        input[type="number"],
        select {
            width: 100px;
            padding: 8px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 1em;
        }

        select {
            cursor: pointer;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
        }

        canvas {
            display: block;
            margin: 20px auto;
            background: #000;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 100%;
        }

        .stats-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: var(--theme-color);
        }

        .stat-label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid var(--theme-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .info-box h3 {
            margin-bottom: 10px;
            color: var(--theme-color);
        }

        .info-box ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        .info-box p {
            line-height: 1.8;
            margin-bottom: 10px;
        }

        .phase-indicator {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            margin-left: 10px;
            font-size: 0.9em;
        }

        .phase-ordered {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            color: white;
        }

        .phase-critical {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: white;
        }

        .phase-disordered {
            background: linear-gradient(135deg, #f87171 0%, #dc2626 100%);
            color: white;
        }

        .critical-marker {
            position: absolute;
            width: 3px;
            height: 20px;
            background: var(--text-accent);
            pointer-events: none;
        }

        .chart-container {
            position: relative;
            margin: 20px 0;
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.8);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .tabs {
                font-size: 0.9em;
            }

            .tab {
                padding: 8px 16px;
            }

            input[type="range"] {
                width: 150px;
            }
        }
    
        /* Organic Nature Back Link */
        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10000;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #BC6C25;
            text-decoration: none;
            font-family: 'Nunito', -apple-system, BlinkMacSystemFont, sans-serif;
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: rgba(254, 250, 224, 0.95);
            border-radius: 20px;
            border: 2px solid rgba(138, 154, 91, 0.3);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(96, 108, 56, 0.15);
        }
        .organic-back-link:hover {
            background: rgba(254, 250, 224, 1);
            transform: translateX(-5px);
            border-color: #DDA15E;
            box-shadow: 0 6px 20px rgba(96, 108, 56, 0.25);
        }

    </style>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>

    <a href="../index.html" class="organic-back-link">← Back to Gallery</a>

    <!-- Navigation Header -->
    <nav class="ccab-nav">
        <div class="nav-container">
            <a href="../index.html" class="nav-home">
                <span class="nav-logo">CCAB</span>
                <span class="nav-tagline">Claude Code and Algorithmic Beauty</span>
            </a>
            <div class="nav-breadcrumb"></div>
        </div>
    </nav>

    <div class="container">
        <h1>Ising Model Simulation</h1>
        <p class="subtitle">Exploring Ferromagnetism, Phase Transitions, and Critical Phenomena</p>

        <div class="tabs">
            <div class="tab active" data-view="simulation">Real-Time Simulation</div>
            <div class="tab" data-view="phase">Phase Transition Sweep</div>
            <div class="tab" data-view="magnetization">Magnetization Plot</div>
        </div>

        <!-- Real-Time Simulation View -->
        <div class="view active" id="simulation">
            <div class="info-box">
                <h3>The Ising Model</h3>
                <p>The Ising model is a mathematical model of ferromagnetism in statistical mechanics. Each site on a lattice
                has a magnetic spin that can be either up (+1) or down (-1). Spins interact with their nearest neighbors,
                preferring to align. At low temperatures, all spins align (ordered/ferromagnetic). At high temperatures,
                thermal fluctuations randomize spins (disordered/paramagnetic).</p>
                <p><strong>Critical Temperature T<sub>c</sub> = 2.269</strong>: The system undergoes a continuous phase transition
                from ordered to disordered state. At this precise temperature, the system exhibits scale-invariant fluctuations
                and critical opalescence - domains of all sizes appear and disappear.</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="temperature">Temperature: <span id="tempVal">2.27</span></label>
                    <input type="range" id="temperature" min="0.1" max="5.0" step="0.01" value="2.27">
                </div>
                <div class="control-group">
                    <label for="externalField">External Field: <span id="fieldVal">0.00</span></label>
                    <input type="range" id="externalField" min="-2.0" max="2.0" step="0.01" value="0.0">
                </div>
                <div class="control-group">
                    <label for="gridSize">Grid Size:</label>
                    <select id="gridSize">
                        <option value="50">50x50</option>
                        <option value="100" selected>100x100</option>
                        <option value="150">150x150</option>
                        <option value="200">200x200</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="stepsPerFrame">Steps/Frame:</label>
                    <select id="stepsPerFrame">
                        <option value="100">100</option>
                        <option value="500">500</option>
                        <option value="1000" selected>1000</option>
                        <option value="5000">5000</option>
                        <option value="10000">10000</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="colorMode">Color Mode:</label>
                    <select id="colorMode">
                        <option value="binary">Binary (B/W)</option>
                        <option value="gradient" selected>Gradient</option>
                        <option value="domain">Domain Coloring</option>
                    </select>
                </div>
                <button onclick="toggleSimulation()">Start</button>
                <button onclick="resetSimulation()" class="secondary">Reset</button>
                <button onclick="randomizeSpins()" class="secondary">Randomize</button>
                <button onclick="setTemperature(2.269)" class="secondary">Go to T<sub>c</sub></button>
            </div>

            <canvas id="latticeCanvas"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="displayTemp">2.27</div>
                        <div class="stat-label">Temperature (kT/J)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="magnetization">0.00</div>
                        <div class="stat-label">Magnetization (M)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="energy">0.00</div>
                        <div class="stat-label">Energy (E/J)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="susceptibility">0.00</div>
                        <div class="stat-label">Susceptibility (χ)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="steps">0</div>
                        <div class="stat-label">Monte Carlo Steps</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="phase">
                            <span class="phase-indicator phase-critical">Critical</span>
                        </div>
                        <div class="stat-label">Phase</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Phase Transition Sweep View -->
        <div class="view" id="phase">
            <div class="info-box">
                <h3>Phase Transition Analysis</h3>
                <p>Watch the dramatic phase transition as temperature sweeps from cold to hot. Below T<sub>c</sub> ≈ 2.269,
                the system spontaneously magnetizes (symmetry breaking). Above T<sub>c</sub>, thermal fluctuations destroy
                order. At T<sub>c</sub>, the system exhibits critical behavior with diverging correlation length and
                susceptibility.</p>
                <ul>
                    <li><strong>Low T (T &lt; 2.0):</strong> Ordered phase - spins aligned, high magnetization</li>
                    <li><strong>Critical T (T ≈ 2.27):</strong> Critical point - domains of all sizes, maximum fluctuations</li>
                    <li><strong>High T (T &gt; 2.5):</strong> Disordered phase - random spins, zero net magnetization</li>
                </ul>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="sweepSpeed">Sweep Speed:</label>
                    <select id="sweepSpeed">
                        <option value="slow">Slow</option>
                        <option value="medium" selected>Medium</option>
                        <option value="fast">Fast</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="sweepDirection">Direction:</label>
                    <select id="sweepDirection">
                        <option value="up">Cold → Hot</option>
                        <option value="down">Hot → Cold</option>
                        <option value="both" selected>Both (Cycle)</option>
                    </select>
                </div>
                <button onclick="startPhaseSweep()">Start Sweep</button>
                <button onclick="stopPhaseSweep()" class="secondary">Stop</button>
            </div>

            <div class="chart-container">
                <canvas id="phaseCanvas"></canvas>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="sweepTemp">0.10</div>
                        <div class="stat-label">Current Temperature</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="sweepMag">0.00</div>
                        <div class="stat-label">Current Magnetization</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Magnetization Plot View -->
        <div class="view" id="magnetization">
            <div class="info-box">
                <h3>Time Evolution of Order Parameter</h3>
                <p>The magnetization M = |Σ spins| / N is the order parameter for the ferromagnetic transition.
                At low temperatures, M approaches 1 (all spins aligned). At high temperatures, M fluctuates around 0.
                Near T<sub>c</sub>, you'll see critical fluctuations where M oscillates dramatically as the system
                explores both ordered and disordered configurations.</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="plotTemp">Temperature: <span id="plotTempVal">2.27</span></label>
                    <input type="range" id="plotTemp" min="0.1" max="5.0" step="0.01" value="2.27">
                </div>
                <button onclick="startMagPlot()">Start Recording</button>
                <button onclick="stopMagPlot()" class="secondary">Stop</button>
                <button onclick="clearMagPlot()" class="secondary">Clear</button>
            </div>

            <canvas id="magPlotCanvas"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="avgMag">0.00</div>
                        <div class="stat-label">Average |M|</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="stdMag">0.00</div>
                        <div class="stat-label">Fluctuations (σ)</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Core Ising Model Implementation
        class IsingModel {
            constructor(size) {
                this.size = size;
                this.lattice = this.initializeLattice();
                this.temperature = 2.27;
                this.externalField = 0.0;
                this.J = 1.0; // Coupling constant
                this.k = 1.0; // Boltzmann constant (absorbed into T)
                this.steps = 0;
                this.magnetizationHistory = [];
                this.energyHistory = [];
            }

            initializeLattice() {
                const lattice = [];
                for (let i = 0; i < this.size; i++) {
                    lattice[i] = [];
                    for (let j = 0; j < this.size; j++) {
                        // Start with ordered state (all up)
                        lattice[i][j] = 1;
                    }
                }
                return lattice;
            }

            randomizeLattice() {
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        this.lattice[i][j] = Math.random() < 0.5 ? 1 : -1;
                    }
                }
            }

            // Metropolis algorithm - single spin flip
            metropolisStep() {
                // Pick random spin
                const i = Math.floor(Math.random() * this.size);
                const j = Math.floor(Math.random() * this.size);

                // Calculate energy change
                const spin = this.lattice[i][j];
                const neighbors = this.getNeighborSum(i, j);

                // ΔE = 2 * J * spin * (sum_neighbors + h)
                const deltaE = 2 * this.J * spin * (neighbors + this.externalField);

                // Metropolis acceptance criterion
                if (deltaE < 0 || Math.random() < Math.exp(-deltaE / (this.k * this.temperature))) {
                    this.lattice[i][j] = -spin; // Flip spin
                }

                this.steps++;
            }

            getNeighborSum(i, j) {
                const up = this.lattice[(i - 1 + this.size) % this.size][j];
                const down = this.lattice[(i + 1) % this.size][j];
                const left = this.lattice[i][(j - 1 + this.size) % this.size];
                const right = this.lattice[i][(j + 1) % this.size];
                return up + down + left + right;
            }

            getMagnetization() {
                let sum = 0;
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        sum += this.lattice[i][j];
                    }
                }
                return sum / (this.size * this.size);
            }

            getEnergy() {
                let energy = 0;
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        const spin = this.lattice[i][j];
                        const neighbors = this.getNeighborSum(i, j);
                        energy -= this.J * spin * neighbors / 2; // Divide by 2 to avoid double counting
                        energy -= this.externalField * spin;
                    }
                }
                return energy / (this.size * this.size);
            }

            getSusceptibility() {
                const N = this.magnetizationHistory.length;
                if (N < 10) return 0;

                const recentMags = this.magnetizationHistory.slice(-100);
                const avgM = recentMags.reduce((a, b) => a + b, 0) / recentMags.length;
                const avgM2 = recentMags.reduce((a, b) => a + b * b, 0) / recentMags.length;

                // χ = N * (<M²> - <M>²) / T
                const chi = (this.size * this.size) * (avgM2 - avgM * avgM) / this.temperature;
                return chi;
            }

            getPhase() {
                const Tc = 2.269;
                const T = this.temperature;

                if (Math.abs(T - Tc) < 0.05) {
                    return 'critical';
                } else if (T < Tc) {
                    return 'ordered';
                } else {
                    return 'disordered';
                }
            }
        }

        // Global state
        let model;
        let simulationRunning = false;
        let animationFrame;
        let phaseSweepInterval;
        let magPlotInterval;
        let magPlotData = [];
        let sweepData = [];
        const Tc = 2.269; // Critical temperature for 2D Ising model

        // Initialize
        function init() {
            const size = parseInt(document.getElementById('gridSize').value);
            model = new IsingModel(size);

            setupControls();
            drawLattice();
            updateStats();

            // Setup canvases
            const latticeCanvas = document.getElementById('latticeCanvas');
            const phaseCanvas = document.getElementById('phaseCanvas');
            const magPlotCanvas = document.getElementById('magPlotCanvas');

            latticeCanvas.width = Math.min(800, window.innerWidth - 100);
            latticeCanvas.height = latticeCanvas.width;

            phaseCanvas.width = Math.min(800, window.innerWidth - 100);
            phaseCanvas.height = 400;

            magPlotCanvas.width = Math.min(800, window.innerWidth - 100);
            magPlotCanvas.height = 400;
        }

        function setupControls() {
            // Temperature slider
            document.getElementById('temperature').addEventListener('input', (e) => {
                const temp = parseFloat(e.target.value);
                model.temperature = temp;
                document.getElementById('tempVal').textContent = temp.toFixed(2);
                updateStats();
            });

            // External field slider
            document.getElementById('externalField').addEventListener('input', (e) => {
                const field = parseFloat(e.target.value);
                model.externalField = field;
                document.getElementById('fieldVal').textContent = field.toFixed(2);
            });

            // Grid size selector
            document.getElementById('gridSize').addEventListener('change', (e) => {
                const wasRunning = simulationRunning;
                if (wasRunning) toggleSimulation();

                const size = parseInt(e.target.value);
                model = new IsingModel(size);
                drawLattice();
                updateStats();

                if (wasRunning) toggleSimulation();
            });

            // Color mode
            document.getElementById('colorMode').addEventListener('change', () => {
                drawLattice();
            });

            // Plot temperature
            document.getElementById('plotTemp').addEventListener('input', (e) => {
                const temp = parseFloat(e.target.value);
                model.temperature = temp;
                document.getElementById('plotTempVal').textContent = temp.toFixed(2);
            });

            // Tab switching
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.view).classList.add('active');
                });
            });
        }

        function drawLattice() {
            const canvas = document.getElementById('latticeCanvas');
            const ctx = canvas.getContext('2d');
            const cellSize = canvas.width / model.size;
            const colorMode = document.getElementById('colorMode').value;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < model.size; i++) {
                for (let j = 0; j < model.size; j++) {
                    const spin = model.lattice[i][j];

                    if (colorMode === 'binary') {
                        ctx.fillStyle = spin === 1 ? '#ffffff' : '#000000';
                    } else if (colorMode === 'gradient') {
                        // Purple to gold gradient
                        const hue = spin === 1 ? 260 : 45;
                        const lightness = spin === 1 ? 60 : 50;
                        ctx.fillStyle = `hsl(${hue}, 70%, ${lightness}%)`;
                    } else { // domain coloring
                        // Color based on local domain alignment
                        const neighbors = model.getNeighborSum(i, j);
                        const alignment = (neighbors * spin + 4) / 8; // Normalize to 0-1
                        const hue = 260 - alignment * 220; // Purple to gold
                        const saturation = 70 + alignment * 20;
                        const lightness = 40 + alignment * 30;
                        ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    }

                    ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                }
            }
        }

        function updateStats() {
            const mag = model.getMagnetization();
            const energy = model.getEnergy();
            const chi = model.getSusceptibility();
            const phase = model.getPhase();

            document.getElementById('displayTemp').textContent = model.temperature.toFixed(2);
            document.getElementById('magnetization').textContent = mag.toFixed(3);
            document.getElementById('energy').textContent = energy.toFixed(2);
            document.getElementById('susceptibility').textContent = chi.toFixed(2);
            document.getElementById('steps').textContent = model.steps.toLocaleString();

            // Update phase indicator
            const phaseEl = document.getElementById('phase');
            phaseEl.innerHTML = '';
            const indicator = document.createElement('span');
            indicator.className = 'phase-indicator';

            if (phase === 'ordered') {
                indicator.classList.add('phase-ordered');
                indicator.textContent = 'Ordered';
            } else if (phase === 'critical') {
                indicator.classList.add('phase-critical');
                indicator.textContent = 'Critical';
            } else {
                indicator.classList.add('phase-disordered');
                indicator.textContent = 'Disordered';
            }

            phaseEl.appendChild(indicator);
        }

        function toggleSimulation() {
            if (simulationRunning) {
                stopSimulation();
            } else {
                startSimulation();
            }
        }

        function startSimulation() {
            simulationRunning = true;
            event.target.textContent = 'Stop';
            animate();
        }

        function stopSimulation() {
            simulationRunning = false;
            cancelAnimationFrame(animationFrame);
            document.querySelector('#simulation button').textContent = 'Start';
        }

        function animate() {
            if (!simulationRunning) return;

            const stepsPerFrame = parseInt(document.getElementById('stepsPerFrame').value);

            // Perform multiple Metropolis steps per frame
            for (let i = 0; i < stepsPerFrame; i++) {
                model.metropolisStep();
            }

            // Update magnetization history
            model.magnetizationHistory.push(Math.abs(model.getMagnetization()));
            if (model.magnetizationHistory.length > 1000) {
                model.magnetizationHistory.shift();
            }

            drawLattice();
            updateStats();

            animationFrame = requestAnimationFrame(animate);
        }

        function resetSimulation() {
            stopSimulation();
            model.steps = 0;
            model.magnetizationHistory = [];
            model.energyHistory = [];
            model.lattice = model.initializeLattice();
            drawLattice();
            updateStats();
        }

        function randomizeSpins() {
            model.randomizeLattice();
            drawLattice();
            updateStats();
        }

        function setTemperature(temp) {
            model.temperature = temp;
            document.getElementById('temperature').value = temp;
            document.getElementById('tempVal').textContent = temp.toFixed(2);
            updateStats();
        }

        // Phase Transition Sweep
        let sweepTemp = 0.1;
        let sweepDirection = 1;

        function startPhaseSweep() {
            sweepData = [];
            sweepTemp = 0.1;
            sweepDirection = 1;

            const direction = document.getElementById('sweepDirection').value;
            if (direction === 'down') {
                sweepTemp = 5.0;
                sweepDirection = -1;
            }

            // Create new model for sweep
            const size = 100;
            const sweepModel = new IsingModel(size);
            sweepModel.temperature = sweepTemp;

            const speed = document.getElementById('sweepSpeed').value;
            const delay = speed === 'slow' ? 200 : speed === 'medium' ? 100 : 50;

            phaseSweepInterval = setInterval(() => {
                // Equilibrate at current temperature
                for (let i = 0; i < 5000; i++) {
                    sweepModel.metropolisStep();
                }

                // Measure magnetization
                const mag = Math.abs(sweepModel.getMagnetization());
                sweepData.push({ temp: sweepTemp, mag: mag });

                document.getElementById('sweepTemp').textContent = sweepTemp.toFixed(2);
                document.getElementById('sweepMag').textContent = mag.toFixed(3);

                drawPhaseDiagram();

                // Update temperature
                sweepTemp += sweepDirection * 0.05;
                sweepModel.temperature = sweepTemp;

                // Check bounds and reverse if needed
                const direction = document.getElementById('sweepDirection').value;
                if (direction === 'both') {
                    if (sweepTemp > 5.0) {
                        sweepDirection = -1;
                    } else if (sweepTemp < 0.1) {
                        sweepDirection = 1;
                    }
                } else {
                    if ((sweepDirection === 1 && sweepTemp > 5.0) ||
                        (sweepDirection === -1 && sweepTemp < 0.1)) {
                        stopPhaseSweep();
                    }
                }
            }, delay);
        }

        function stopPhaseSweep() {
            clearInterval(phaseSweepInterval);
        }

        function drawPhaseDiagram() {
            const canvas = document.getElementById('phaseCanvas');
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (sweepData.length === 0) return;

            // Draw grid
            ctx.strokeStyle = 'rgba(224, 224, 255, 0.1)';
            ctx.lineWidth = 1;

            // Horizontal lines
            for (let i = 0; i <= 10; i++) {
                const y = (i / 10) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Vertical lines
            for (let i = 0; i <= 10; i++) {
                const x = (i / 10) * canvas.width;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            // Draw critical temperature line
            const Tc_x = (Tc / 5.0) * canvas.width;
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(Tc_x, 0);
            ctx.lineTo(Tc_x, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw Tc label
            ctx.fillStyle = '#fbbf24';
            ctx.font = 'bold 14px monospace';
            ctx.fillText(`Tc = ${Tc.toFixed(3)}`, Tc_x + 5, 20);

            // Draw data
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.beginPath();

            for (let i = 0; i < sweepData.length; i++) {
                const x = (sweepData[i].temp / 5.0) * canvas.width;
                const y = canvas.height - (sweepData[i].mag * canvas.height);

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();

            // Draw points
            ctx.fillStyle = '#667eea';
            for (let i = 0; i < sweepData.length; i++) {
                const x = (sweepData[i].temp / 5.0) * canvas.width;
                const y = canvas.height - (sweepData[i].mag * canvas.height);
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Axis labels
            ctx.fillStyle = '#e0e0ff';
            ctx.font = '12px monospace';
            ctx.fillText('0', 5, canvas.height - 5);
            ctx.fillText('5.0', canvas.width - 25, canvas.height - 5);
            ctx.fillText('M', 5, 15);
            ctx.fillText('Temperature (kT/J)', canvas.width / 2 - 60, canvas.height - 5);
        }

        // Magnetization Plot
        function startMagPlot() {
            magPlotData = [];

            const plotModel = model; // Use current model
            plotModel.temperature = parseFloat(document.getElementById('plotTemp').value);

            magPlotInterval = setInterval(() => {
                // Perform Monte Carlo steps
                for (let i = 0; i < 1000; i++) {
                    plotModel.metropolisStep();
                }

                const mag = plotModel.getMagnetization();
                magPlotData.push(mag);

                if (magPlotData.length > 500) {
                    magPlotData.shift();
                }

                drawMagPlot();
                updateMagStats();
            }, 50);
        }

        function stopMagPlot() {
            clearInterval(magPlotInterval);
        }

        function clearMagPlot() {
            stopMagPlot();
            magPlotData = [];
            drawMagPlot();
            updateMagStats();
        }

        function drawMagPlot() {
            const canvas = document.getElementById('magPlotCanvas');
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (magPlotData.length === 0) return;

            // Draw grid
            ctx.strokeStyle = 'rgba(224, 224, 255, 0.1)';
            ctx.lineWidth = 1;

            for (let i = 0; i <= 10; i++) {
                const y = (i / 10) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw zero line
            const zeroY = canvas.height / 2;
            ctx.strokeStyle = 'rgba(224, 224, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, zeroY);
            ctx.lineTo(canvas.width, zeroY);
            ctx.stroke();

            // Draw data
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let i = 0; i < magPlotData.length; i++) {
                const x = (i / 500) * canvas.width;
                const mag = magPlotData[i];
                const y = canvas.height / 2 - (mag * canvas.height / 2);

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();

            // Axis labels
            ctx.fillStyle = '#e0e0ff';
            ctx.font = '12px monospace';
            ctx.fillText('-1', 5, canvas.height - 5);
            ctx.fillText('+1', 5, 15);
            ctx.fillText('M', 5, canvas.height / 2);
            ctx.fillText('Time (Monte Carlo Steps)', canvas.width / 2 - 80, canvas.height - 5);
        }

        function updateMagStats() {
            if (magPlotData.length === 0) {
                document.getElementById('avgMag').textContent = '0.00';
                document.getElementById('stdMag').textContent = '0.00';
                return;
            }

            const absMags = magPlotData.map(m => Math.abs(m));
            const avg = absMags.reduce((a, b) => a + b, 0) / absMags.length;

            const variance = absMags.reduce((sum, m) => sum + (m - avg) ** 2, 0) / absMags.length;
            const std = Math.sqrt(variance);

            document.getElementById('avgMag').textContent = avg.toFixed(3);
            document.getElementById('stdMag').textContent = std.toFixed(3);
        }

        // Initialize on load
        window.addEventListener('load', init);
        window.addEventListener('resize', () => {
            if (!simulationRunning) {
                const latticeCanvas = document.getElementById('latticeCanvas');
                latticeCanvas.width = Math.min(800, window.innerWidth - 100);
                latticeCanvas.height = latticeCanvas.width;
                drawLattice();
            }
        });
    </script>
    <script src="../assets/js/navigation.js"></script>
</body>
</html>
