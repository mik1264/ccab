<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magnetic Reconnection - Flare Trigger</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #fff;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 5px;
            max-width: 250px;
            backdrop-filter: blur(10px);
        }
        h3 {
            margin: 0 0 10px 0;
            color: #00ff00;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="info">
        <h3>Magnetic Reconnection</h3>
        <p>Opposing magnetic field lines break and reconnect, releasing enormous energy</p>
        <p>Energy Release: 10^25 joules</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        class FieldLine {
            constructor(side, index, total) {
                this.side = side; // 'left' or 'right'
                this.index = index;
                this.total = total;
                this.reconnecting = false;
                this.reconnectProgress = 0;
            }

            getPoints(time) {
                const points = [];
                const steps = 40;
                const offset = (this.index / this.total) * 100 - 50;

                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    let x, y;

                    if (this.side === 'left') {
                        x = centerX - 300 + t * 280;
                        y = centerY + offset + Math.sin(t * Math.PI) * 80;
                    } else {
                        x = centerX + 20 + t * 280;
                        y = centerY + offset - Math.sin(t * Math.PI) * 80;
                    }

                    // Reconnection effect
                    if (this.reconnecting) {
                        const reconnectX = Math.abs(x - centerX);
                        if (reconnectX < 50) {
                            const warp = Math.sin(this.reconnectProgress * Math.PI) * 30;
                            y += warp * Math.sin(t * Math.PI * 2);
                        }
                    }

                    points.push({x, y});
                }

                return points;
            }

            draw(time) {
                const points = this.getPoints(time);

                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);

                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }

                const color = this.side === 'left' ?
                    'rgba(255, 50, 50, 0.8)' :
                    'rgba(50, 50, 255, 0.8)';

                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw arrow
                if (!this.reconnecting) {
                    const lastPoint = points[points.length - 1];
                    const secondLast = points[points.length - 2];
                    const angle = Math.atan2(lastPoint.y - secondLast.y, lastPoint.x - secondLast.x);

                    ctx.save();
                    ctx.translate(lastPoint.x, lastPoint.y);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-10, -5);
                    ctx.lineTo(-10, 5);
                    ctx.closePath();
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.restore();
                }
            }
        }

        class EnergyParticle {
            constructor() {
                this.x = centerX;
                this.y = centerY;
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = (Math.random() - 0.5) * 10;
                this.life = 1;
                this.size = Math.random() * 4 + 2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.02;
                return this.life > 0;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 100, ${this.life})`;
                ctx.fill();
            }
        }

        const leftLines = [];
        const rightLines = [];
        const particles = [];

        for (let i = 0; i < 8; i++) {
            leftLines.push(new FieldLine('left', i, 8));
            rightLines.push(new FieldLine('right', i, 8));
        }

        let time = 0;
        let reconnectPhase = 0;

        function animate() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Trigger reconnection periodically
            if (time % 200 === 0) {
                reconnectPhase = 1;
                leftLines.forEach(line => line.reconnecting = true);
                rightLines.forEach(line => line.reconnecting = true);
            }

            if (reconnectPhase > 0) {
                reconnectPhase += 0.02;
                leftLines.forEach(line => line.reconnectProgress = reconnectPhase);
                rightLines.forEach(line => line.reconnectProgress = reconnectPhase);

                // Emit particles during reconnection
                if (reconnectPhase < 1) {
                    for (let i = 0; i < 5; i++) {
                        particles.push(new EnergyParticle());
                    }
                } else {
                    leftLines.forEach(line => line.reconnecting = false);
                    rightLines.forEach(line => line.reconnecting = false);
                    reconnectPhase = 0;
                }
            }

            // Draw field lines
            leftLines.forEach(line => line.draw(time));
            rightLines.forEach(line => line.draw(time));

            // Draw reconnection point
            ctx.beginPath();
            ctx.arc(centerX, centerY, 10, 0, Math.PI * 2);
            const glowIntensity = reconnectPhase > 0 ? Math.sin(reconnectPhase * Math.PI) : 0.3;
            ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity})`;
            ctx.fill();

            // Draw energy particles
            for (let i = particles.length - 1; i >= 0; i--) {
                if (!particles[i].update()) {
                    particles.splice(i, 1);
                } else {
                    particles[i].draw();
                }
            }

            time++;
            requestAnimationFrame(animate);
        }

        window.reset = function() { time = 0; reconnectPhase = 0; particles.length = 0; };

        animate();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
