<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CME Propagation to Earth</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 5px;
        }
        .eta {
            font-size: 24px;
            color: #ff6600;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="info">
        <h3>Coronal Mass Ejection</h3>
        <div>Speed: 1,200 km/s</div>
        <div>Mass: 10ยนโต kg</div>
        <div class="eta">ETA: 15-18 hours</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const sunX = canvas.width * 0.15;
        const sunY = canvas.height / 2;
        const earthX = canvas.width * 0.85;
        const earthY = canvas.height / 2;

        class CMEParticle {
            constructor(angle, distance, speed) {
                this.angle = angle;
                this.distance = distance;
                this.speed = speed;
                this.size = Math.random() * 2 + 1;
                this.opacity = 1;
                this.baseAngle = angle;
                this.wobble = (Math.random() - 0.5) * 0.1;
            }

            update() {
                this.distance += this.speed;
                this.angle += this.wobble * 0.01;
                this.opacity = 1 - (this.distance / (earthX - sunX));
            }

            draw() {
                const x = sunX + Math.cos(this.angle) * this.distance;
                const y = sunY + Math.sin(this.angle) * this.distance * 0.4; // Flatten vertically

                if (this.opacity > 0 && this.distance < earthX - sunX) {
                    ctx.beginPath();
                    ctx.arc(x, y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 50, ${this.opacity})`;
                    ctx.fill();
                    return true;
                }
                return false;
            }
        }

        class CMEWave {
            constructor() {
                this.frontDistance = 0;
                this.speed = 3;
                this.width = Math.PI / 3;
                this.centerAngle = 0;
            }

            update() {
                this.frontDistance += this.speed;
            }

            draw() {
                if (this.frontDistance > earthX - sunX + 50) return;

                // Draw CME cone/cloud
                const steps = 50;

                for (let i = 0; i < steps; i++) {
                    const angle = this.centerAngle - this.width / 2 + (i / steps) * this.width;
                    const distance = this.frontDistance - Math.abs(i - steps / 2) * 2;

                    if (distance > 0) {
                        const x = sunX + Math.cos(angle) * distance;
                        const y = sunY + Math.sin(angle) * distance * 0.4;

                        const intensity = 1 - (distance / (earthX - sunX));
                        const size = 20 + (steps / 2 - Math.abs(i - steps / 2)) * 2;

                        const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                        gradient.addColorStop(0, `rgba(255, 150, 50, ${intensity * 0.3})`);
                        gradient.addColorStop(1, `rgba(255, 50, 0, 0)`);

                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fillStyle = gradient;
                        ctx.fill();
                    }
                }

                // Draw leading edge
                ctx.beginPath();
                ctx.arc(
                    sunX + this.frontDistance,
                    sunY,
                    40,
                    this.centerAngle - this.width / 2,
                    this.centerAngle + this.width / 2
                );
                ctx.strokeStyle = 'rgba(255, 255, 100, 0.8)';
                ctx.lineWidth = 4;
                ctx.stroke();
            }
        }

        const particles = [];
        const cmeWave = new CMEWave();
        let time = 0;
        let emitting = true;

        function drawSun() {
            const gradient = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, 40);
            gradient.addColorStop(0, '#ffff88');
            gradient.addColorStop(0.7, '#ffaa44');
            gradient.addColorStop(1, '#ff6600');

            ctx.beginPath();
            ctx.arc(sunX, sunY, 40, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
        }

        function drawEarth() {
            // Earth
            const gradient = ctx.createRadialGradient(earthX, earthY, 0, earthX, earthY, 25);
            gradient.addColorStop(0, '#6699ff');
            gradient.addColorStop(0.7, '#3366cc');
            gradient.addColorStop(1, '#1a3d7a');

            ctx.beginPath();
            ctx.arc(earthX, earthY, 25, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Magnetosphere bow shock
            if (cmeWave.frontDistance > earthX - sunX - 100) {
                const impact = Math.min(1, (cmeWave.frontDistance - (earthX - sunX - 100)) / 100);

                ctx.beginPath();
                ctx.arc(earthX - 40, earthY, 60 * (1 + impact * 0.5), Math.PI / 2, -Math.PI / 2, true);
                ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 + impact * 0.5})`;
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        function drawOrbit() {
            ctx.beginPath();
            ctx.ellipse(sunX, sunY, earthX - sunX, (earthX - sunX) * 0.15, 0, 0, Math.PI * 2);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawSolarWind() {
            // Background solar wind
            for (let i = 0; i < 50; i++) {
                const t = (time * 2 + i * 20) % (earthX - sunX);
                const x = sunX + t;
                const y = sunY + Math.sin(t * 0.1 + i) * 150;

                ctx.beginPath();
                ctx.arc(x, y, 1, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 200, 100, 0.2)';
                ctx.fill();
            }
        }

        function animate() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawOrbit();
            drawSolarWind();
            drawSun();
            drawEarth();

            // Emit CME particles
            if (emitting && time < 200) {
                for (let i = 0; i < 5; i++) {
                    const angle = (Math.random() - 0.5) * 0.6;
                    const speed = 2 + Math.random() * 2;
                    particles.push(new CMEParticle(angle, 50, speed));
                }
            }

            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (!particles[i].draw()) {
                    particles.splice(i, 1);
                }
            }

            // Update and draw CME wave
            cmeWave.update();
            cmeWave.draw();

            // Reset animation
            if (cmeWave.frontDistance > earthX - sunX + 100) {
                setTimeout(() => {
                    cmeWave.frontDistance = 0;
                    particles.length = 0;
                }, 1000);
            }

            time++;
            requestAnimationFrame(animate);
        }

        animate();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>
