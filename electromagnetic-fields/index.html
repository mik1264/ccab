<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electromagnetic Field Lines - Interactive Visualization - CCAB</title>
    <meta name="description" content="Interactive electric field line visualization. Place positive and negative charges and watch field lines form in real-time using Coulomb's law.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 100%);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.6);
            color: #00e5ff;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 229, 255, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(0, 229, 255, 0.2);
            transform: translateX(-4px);
        }

        #info {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            color: #00e5ff;
            font-size: 13px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 229, 255, 0.2);
            z-index: 1000;
            max-width: 280px;
        }

        #info h3 {
            margin-bottom: 10px;
            color: #fff;
        }

        #info .stat {
            margin: 5px 0;
        }

        #info .stat-label {
            color: #aaa;
            font-size: 11px;
        }

        #info .stat-value {
            color: #00e5ff;
            font-weight: bold;
        }

        #info p {
            font-size: 11px;
            opacity: 0.8;
            line-height: 1.5;
            margin-top: 10px;
            color: #ddd;
        }

        #info .formula {
            background: rgba(0, 229, 255, 0.1);
            padding: 8px;
            border-radius: 6px;
            margin-top: 10px;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-size: 12px;
            color: #80deea;
        }

        #presets {
            position: fixed;
            top: 290px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }

        button {
            background: rgba(0, 229, 255, 0.15);
            border: 1px solid rgba(0, 229, 255, 0.4);
            color: #00e5ff;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(0, 229, 255, 0.3);
        }

        button.active {
            background: rgba(0, 229, 255, 0.4);
            border-color: #00e5ff;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 16px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 229, 255, 0.2);
        }

        .control-group label {
            color: #00e5ff;
            font-size: 11px;
            display: block;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 100px;
            accent-color: #00e5ff;
        }

        .control-group span {
            color: #fff;
            font-size: 10px;
            margin-left: 6px;
        }

        .charge-selector {
            display: flex;
            gap: 8px;
        }

        .charge-btn {
            padding: 8px 16px;
            font-size: 16px;
            font-weight: bold;
        }

        .charge-btn.positive {
            color: #ff5722;
            border-color: rgba(255, 87, 34, 0.4);
        }

        .charge-btn.positive.active {
            background: rgba(255, 87, 34, 0.4);
            border-color: #ff5722;
        }

        .charge-btn.negative {
            color: #2196f3;
            border-color: rgba(33, 150, 243, 0.4);
        }

        .charge-btn.negative.active {
            background: rgba(33, 150, 243, 0.4);
            border-color: #2196f3;
        }

        .instructions {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            color: #aaa;
            font-size: 12px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 229, 255, 0.2);
        }

        #fps-display {
            position: fixed;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 6px;
            color: #00e5ff;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">← Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div id="info">
        <h3>Electromagnetic Fields</h3>
        <div class="stat">
            <span class="stat-label">Charges</span>
            <span class="stat-value" id="charge-count">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Field Lines</span>
            <span class="stat-value" id="line-count">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Net Charge</span>
            <span class="stat-value" id="net-charge">0</span>
        </div>
        <p>Click to place charges. Field lines show the direction a positive test charge would move. Lines originate from positive charges and terminate at negative ones.</p>
        <div class="formula">
            E = k·Q/r² (Coulomb's Law)
        </div>
    </div>

    <div id="presets">
        <button data-preset="dipole">Dipole</button>
        <button data-preset="quadrupole">Quadrupole</button>
        <button data-preset="capacitor">Parallel Plate</button>
        <button data-preset="triangle">Three Charges</button>
        <button data-preset="clear">Clear All</button>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>Charge Type:</label>
            <div class="charge-selector">
                <button class="charge-btn positive active" data-charge="1">+</button>
                <button class="charge-btn negative" data-charge="-1">−</button>
            </div>
        </div>
        <div class="control-group">
            <label>Lines per Charge: <span id="lines-val">8</span></label>
            <input type="range" id="lines" min="4" max="24" step="2" value="8">
        </div>
        <div class="control-group">
            <label>Line Length: <span id="length-val">200</span></label>
            <input type="range" id="length" min="50" max="500" step="25" value="200">
        </div>
        <div class="control-group">
            <label>Show Vectors: <span id="vectors-val">Off</span></label>
            <input type="range" id="vectors" min="0" max="1" step="1" value="0">
        </div>
    </div>

    <div class="instructions">Click to place charges. Drag to move them. Right-click or double-click to remove.</div>

    <div id="fps-display">FPS: <span id="fps">0</span></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // DOM elements
        const chargeCountDisplay = document.getElementById('charge-count');
        const lineCountDisplay = document.getElementById('line-count');
        const netChargeDisplay = document.getElementById('net-charge');
        const fpsDisplay = document.getElementById('fps');
        const linesSlider = document.getElementById('lines');
        const linesVal = document.getElementById('lines-val');
        const lengthSlider = document.getElementById('length');
        const lengthVal = document.getElementById('length-val');
        const vectorsSlider = document.getElementById('vectors');
        const vectorsVal = document.getElementById('vectors-val');

        // Configuration
        let config = {
            linesPerCharge: 8,
            maxLength: 200,
            showVectors: false,
            selectedCharge: 1,
            stepSize: 5,
            k: 1000 // Coulomb constant (scaled for visualization)
        };

        // Charges
        let charges = [];
        let draggedCharge = null;
        let fieldLines = [];

        // Charge class
        class Charge {
            constructor(x, y, q) {
                this.x = x;
                this.y = y;
                this.q = q; // +1 or -1
                this.radius = 20;
            }

            draw() {
                // Glow effect
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.radius * 2
                );

                if (this.q > 0) {
                    gradient.addColorStop(0, 'rgba(255, 87, 34, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 87, 34, 0.3)');
                    gradient.addColorStop(1, 'rgba(255, 87, 34, 0)');
                } else {
                    gradient.addColorStop(0, 'rgba(33, 150, 243, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(33, 150, 243, 0.3)');
                    gradient.addColorStop(1, 'rgba(33, 150, 243, 0)');
                }

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
                ctx.fill();

                // Main circle
                ctx.fillStyle = this.q > 0 ? '#ff5722' : '#2196f3';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Symbol
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.q > 0 ? '+' : '−', this.x, this.y);
            }

            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return dx * dx + dy * dy <= this.radius * this.radius;
            }
        }

        // Calculate electric field at a point
        function getFieldAt(x, y) {
            let Ex = 0;
            let Ey = 0;

            for (const charge of charges) {
                const dx = x - charge.x;
                const dy = y - charge.y;
                const r2 = dx * dx + dy * dy;
                const r = Math.sqrt(r2);

                if (r < 10) continue; // Avoid singularity at charge location

                // E = kQ/r² in direction away from charge
                const E = config.k * charge.q / r2;
                Ex += E * dx / r;
                Ey += E * dy / r;
            }

            return { x: Ex, y: Ey };
        }

        // Trace a field line from a starting point
        function traceFieldLine(startX, startY, direction) {
            const points = [{ x: startX, y: startY }];
            let x = startX;
            let y = startY;

            for (let i = 0; i < config.maxLength; i++) {
                const field = getFieldAt(x, y);
                const magnitude = Math.sqrt(field.x * field.x + field.y * field.y);

                if (magnitude < 0.1) break; // Field too weak

                // Normalize and step
                const nx = field.x / magnitude * direction;
                const ny = field.y / magnitude * direction;

                x += nx * config.stepSize;
                y += ny * config.stepSize;

                // Boundary check
                if (x < 0 || x > canvas.width || y < 0 || y > canvas.height) break;

                // Check if we hit a charge of opposite sign
                for (const charge of charges) {
                    const dx = x - charge.x;
                    const dy = y - charge.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < charge.radius + 5) {
                        if ((direction > 0 && charge.q < 0) || (direction < 0 && charge.q > 0)) {
                            points.push({ x: charge.x, y: charge.y });
                            return points;
                        }
                        return points; // Same sign, stop
                    }
                }

                points.push({ x, y });
            }

            return points;
        }

        // Generate all field lines
        function generateFieldLines() {
            fieldLines = [];

            for (const charge of charges) {
                if (charge.q > 0) {
                    // Lines emanate from positive charges
                    for (let i = 0; i < config.linesPerCharge; i++) {
                        const angle = (i / config.linesPerCharge) * Math.PI * 2;
                        const startX = charge.x + Math.cos(angle) * (charge.radius + 5);
                        const startY = charge.y + Math.sin(angle) * (charge.radius + 5);

                        const points = traceFieldLine(startX, startY, 1);
                        if (points.length > 1) {
                            fieldLines.push({
                                points,
                                charge
                            });
                        }
                    }
                }
            }

            // If no positive charges, trace from negative (reversed)
            const hasPositive = charges.some(c => c.q > 0);
            if (!hasPositive) {
                for (const charge of charges) {
                    if (charge.q < 0) {
                        for (let i = 0; i < config.linesPerCharge; i++) {
                            const angle = (i / config.linesPerCharge) * Math.PI * 2;
                            const startX = charge.x + Math.cos(angle) * (charge.radius + 5);
                            const startY = charge.y + Math.sin(angle) * (charge.radius + 5);

                            const points = traceFieldLine(startX, startY, -1);
                            if (points.length > 1) {
                                fieldLines.push({
                                    points,
                                    charge
                                });
                            }
                        }
                    }
                }
            }
        }

        // Draw field lines
        function drawFieldLines() {
            for (const line of fieldLines) {
                if (line.points.length < 2) continue;

                ctx.beginPath();
                ctx.moveTo(line.points[0].x, line.points[0].y);

                for (let i = 1; i < line.points.length; i++) {
                    ctx.lineTo(line.points[i].x, line.points[i].y);
                }

                // Gradient color based on field strength
                const gradient = ctx.createLinearGradient(
                    line.points[0].x, line.points[0].y,
                    line.points[line.points.length - 1].x, line.points[line.points.length - 1].y
                );
                gradient.addColorStop(0, 'rgba(0, 229, 255, 0.8)');
                gradient.addColorStop(1, 'rgba(0, 229, 255, 0.2)');

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw arrow heads
                if (line.points.length > 10) {
                    const arrowInterval = Math.floor(line.points.length / 3);
                    for (let i = arrowInterval; i < line.points.length - 5; i += arrowInterval) {
                        drawArrowHead(line.points[i], line.points[i + 1]);
                    }
                }
            }
        }

        // Draw arrow head
        function drawArrowHead(from, to) {
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const angle = Math.atan2(dy, dx);
            const size = 8;

            ctx.fillStyle = 'rgba(0, 229, 255, 0.9)';
            ctx.beginPath();
            ctx.moveTo(to.x, to.y);
            ctx.lineTo(
                to.x - size * Math.cos(angle - Math.PI / 6),
                to.y - size * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                to.x - size * Math.cos(angle + Math.PI / 6),
                to.y - size * Math.sin(angle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fill();
        }

        // Draw field vectors on a grid
        function drawFieldVectors() {
            const gridSize = 50;

            for (let x = gridSize; x < canvas.width; x += gridSize) {
                for (let y = gridSize; y < canvas.height; y += gridSize) {
                    // Skip if too close to a charge
                    let tooClose = false;
                    for (const charge of charges) {
                        const dx = x - charge.x;
                        const dy = y - charge.y;
                        if (dx * dx + dy * dy < 2500) {
                            tooClose = true;
                            break;
                        }
                    }
                    if (tooClose) continue;

                    const field = getFieldAt(x, y);
                    const magnitude = Math.sqrt(field.x * field.x + field.y * field.y);

                    if (magnitude < 0.5) continue;

                    // Normalize and scale arrow
                    const scale = Math.min(20, Math.log(magnitude + 1) * 8);
                    const ax = field.x / magnitude * scale;
                    const ay = field.y / magnitude * scale;

                    // Draw arrow
                    const alpha = Math.min(1, magnitude / 10);
                    ctx.strokeStyle = `rgba(0, 229, 255, ${alpha * 0.6})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x - ax / 2, y - ay / 2);
                    ctx.lineTo(x + ax / 2, y + ay / 2);
                    ctx.stroke();

                    // Arrow head
                    const angle = Math.atan2(ay, ax);
                    const headSize = 4;
                    ctx.fillStyle = `rgba(0, 229, 255, ${alpha * 0.6})`;
                    ctx.beginPath();
                    ctx.moveTo(x + ax / 2, y + ay / 2);
                    ctx.lineTo(
                        x + ax / 2 - headSize * Math.cos(angle - Math.PI / 6),
                        y + ay / 2 - headSize * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.lineTo(
                        x + ax / 2 - headSize * Math.cos(angle + Math.PI / 6),
                        y + ay / 2 - headSize * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        // Draw function
        function draw() {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw field vectors if enabled
            if (config.showVectors && charges.length > 0) {
                drawFieldVectors();
            }

            // Draw field lines
            drawFieldLines();

            // Draw charges
            for (const charge of charges) {
                charge.draw();
            }

            // Update stats
            chargeCountDisplay.textContent = charges.length;
            lineCountDisplay.textContent = fieldLines.length;
            const netCharge = charges.reduce((sum, c) => sum + c.q, 0);
            netChargeDisplay.textContent = (netCharge >= 0 ? '+' : '') + netCharge;
        }

        // Preset configurations
        function loadPreset(preset) {
            charges = [];
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            switch (preset) {
                case 'dipole':
                    charges.push(new Charge(cx - 100, cy, 1));
                    charges.push(new Charge(cx + 100, cy, -1));
                    break;

                case 'quadrupole':
                    charges.push(new Charge(cx - 80, cy - 80, 1));
                    charges.push(new Charge(cx + 80, cy - 80, -1));
                    charges.push(new Charge(cx - 80, cy + 80, -1));
                    charges.push(new Charge(cx + 80, cy + 80, 1));
                    break;

                case 'capacitor':
                    // Parallel plate capacitor
                    for (let i = 0; i < 5; i++) {
                        charges.push(new Charge(cx - 150, cy - 120 + i * 60, 1));
                        charges.push(new Charge(cx + 150, cy - 120 + i * 60, -1));
                    }
                    break;

                case 'triangle':
                    const radius = 120;
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2 - Math.PI / 2;
                        charges.push(new Charge(
                            cx + Math.cos(angle) * radius,
                            cy + Math.sin(angle) * radius,
                            i === 0 ? 1 : (i === 1 ? 1 : -1)
                        ));
                    }
                    break;

                case 'clear':
                    break;
            }

            generateFieldLines();
        }

        // Animation loop
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;

        function animate(currentTime) {
            requestAnimationFrame(animate);

            // FPS calculation
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                fpsDisplay.textContent = fps;
            }

            draw();
        }

        // Find charge at position
        function findChargeAt(x, y) {
            for (const charge of charges) {
                if (charge.contains(x, y)) {
                    return charge;
                }
            }
            return null;
        }

        // Event listeners
        canvas.addEventListener('mousedown', (e) => {
            const x = e.clientX;
            const y = e.clientY;

            draggedCharge = findChargeAt(x, y);

            if (!draggedCharge && e.button === 0) {
                // Add new charge
                charges.push(new Charge(x, y, config.selectedCharge));
                generateFieldLines();
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (draggedCharge) {
                draggedCharge.x = e.clientX;
                draggedCharge.y = e.clientY;
                generateFieldLines();
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggedCharge = null;
        });

        canvas.addEventListener('dblclick', (e) => {
            const charge = findChargeAt(e.clientX, e.clientY);
            if (charge) {
                charges = charges.filter(c => c !== charge);
                generateFieldLines();
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const charge = findChargeAt(e.clientX, e.clientY);
            if (charge) {
                charges = charges.filter(c => c !== charge);
                generateFieldLines();
            }
        });

        // Control listeners
        linesSlider.addEventListener('input', (e) => {
            config.linesPerCharge = parseInt(e.target.value);
            linesVal.textContent = config.linesPerCharge;
            generateFieldLines();
        });

        lengthSlider.addEventListener('input', (e) => {
            config.maxLength = parseInt(e.target.value);
            lengthVal.textContent = config.maxLength;
            generateFieldLines();
        });

        vectorsSlider.addEventListener('input', (e) => {
            config.showVectors = parseInt(e.target.value) === 1;
            vectorsVal.textContent = config.showVectors ? 'On' : 'Off';
        });

        // Charge selector
        document.querySelectorAll('.charge-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.charge-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                config.selectedCharge = parseInt(btn.dataset.charge);
            });
        });

        // Preset buttons
        document.querySelectorAll('#presets button').forEach(btn => {
            btn.addEventListener('click', () => {
                loadPreset(btn.dataset.preset);
            });
        });

        // Expose functions for enhance.js keyboard shortcuts
        window.reset = function() { loadPreset('dipole'); };

        // Initialize with dipole
        loadPreset('dipole');
        requestAnimationFrame(animate);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
