<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pollinator Network</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: sans-serif; }
canvas { display: block; cursor: pointer; }
#title {
    position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
    color: #fbbf24; font-size: 22px; font-weight: bold; text-align: center;
    text-shadow: 0 0 20px rgba(251,191,36,0.3); z-index: 10; pointer-events: none;
}
#info {
    position: fixed; top: 85px; left: 50%; transform: translateX(-50%);
    color: #999; font-size: 12px; z-index: 10; pointer-events: none; text-align: center;
}
#controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 20px; z-index: 10; background: rgba(0,0,0,0.7);
    padding: 12px 20px; border-radius: 10px; align-items: center;
}
button {
    background: rgba(251,191,36,0.2); color: #fbbf24; border: 1px solid #fbbf24;
    padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 12px;
}
button:hover { background: rgba(251,191,36,0.4); }
#stats {
    position: fixed; top: 50px; right: 20px; color: #ccc; font-size: 13px;
    background: rgba(0,0,0,0.7); padding: 10px 16px; border-radius: 8px; z-index: 10;
    line-height: 1.8;
}
#tooltip {
    position: fixed; display: none; background: rgba(0,0,0,0.9); color: #fbbf24;
    padding: 8px 12px; border-radius: 6px; font-size: 12px; z-index: 20;
    pointer-events: none; border: 1px solid rgba(251,191,36,0.3);
}
#legend {
    position: fixed; top: 50px; left: 140px; color: #ccc; font-size: 12px;
    background: rgba(0,0,0,0.7); padding: 10px 14px; border-radius: 8px; z-index: 10;
    line-height: 1.8;
}
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">‚Üê Back to Gallery</a>
<div id="title">Pollinator-Plant Mutualistic Network</div>
<div id="info">Click on any species to remove it and see cascading effects on the network</div>
<div id="legend">
    <span style="color:#f472b6;">Flowers (left)</span><br>
    <span style="color:#fbbf24;">Pollinators (right)</span>
</div>
<div id="stats">
    <span style="color:#f472b6;">Flowers: <span id="flowerCount">0</span></span><br>
    <span style="color:#fbbf24;">Pollinators: <span id="pollinatorCount">0</span></span><br>
    <span style="color:#60a5fa;">Links: <span id="linkCount">0</span></span><br>
    <span style="color:#a78bfa;">Network Health: <span id="netHealth">100</span>%</span>
</div>
<div id="tooltip"></div>
<div id="controls">
    <button id="resetBtn">Reset Network</button>
    <button id="removeFlower">Remove Random Flower</button>
    <button id="removePollinator">Remove Random Pollinator</button>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    if (flowers.length > 0) layoutNodes();
}
resize();
window.addEventListener('resize', resize);

const FLOWER_DATA = [
    { name: 'Rose', hue: 350 },
    { name: 'Lavender', hue: 270 },
    { name: 'Sunflower', hue: 45 },
    { name: 'Daisy', hue: 55 },
    { name: 'Orchid', hue: 300 },
    { name: 'Tulip', hue: 0 },
    { name: 'Lily', hue: 30 },
    { name: 'Violet', hue: 280 },
    { name: 'Jasmine', hue: 60 },
    { name: 'Bluebell', hue: 230 },
    { name: 'Marigold', hue: 35 },
    { name: 'Clover', hue: 140 }
];

const POLLINATOR_DATA = [
    { name: 'Honeybee', hue: 45, emoji: '' },
    { name: 'Bumblebee', hue: 40, emoji: '' },
    { name: 'Monarch', hue: 25, emoji: '' },
    { name: 'Swallowtail', hue: 55, emoji: '' },
    { name: 'Hummingbird', hue: 150, emoji: '' },
    { name: 'Moth', hue: 200, emoji: '' },
    { name: 'Wasp', hue: 50, emoji: '' },
    { name: 'Beetle', hue: 120, emoji: '' },
    { name: 'Hoverfly', hue: 80, emoji: '' },
    { name: 'Mason Bee', hue: 30, emoji: '' }
];

// Generate connections (which pollinators visit which flowers)
const CONNECTIONS = [
    [0, 0], [0, 1], [0, 4],         // Rose: honeybee, bumblebee, hummingbird
    [1, 0], [1, 1], [1, 5], [1, 2], // Lavender: honeybee, bumblebee, moth, monarch
    [2, 0], [2, 1], [2, 3], [2, 8], // Sunflower: honeybee, bumblebee, swallowtail, hoverfly
    [3, 0], [3, 8], [3, 7],         // Daisy: honeybee, hoverfly, beetle
    [4, 4], [4, 5], [4, 2],         // Orchid: hummingbird, moth, monarch
    [5, 0], [5, 1], [5, 6],         // Tulip: honeybee, bumblebee, wasp
    [6, 0], [6, 5], [6, 7],         // Lily: honeybee, moth, beetle
    [7, 2], [7, 3], [7, 1],         // Violet: monarch, swallowtail, bumblebee
    [8, 0], [8, 5], [8, 9],         // Jasmine: honeybee, moth, mason bee
    [9, 1], [9, 8], [9, 9],         // Bluebell: bumblebee, hoverfly, mason bee
    [10, 0], [10, 6], [10, 8],      // Marigold: honeybee, wasp, hoverfly
    [11, 0], [11, 1], [11, 9],      // Clover: honeybee, bumblebee, mason bee
];

let flowers = [];
let pollinators = [];
let links = [];
let removedFlowers = new Set();
let removedPollinators = new Set();
let cascadeEffects = [];
let particles = [];

class Node {
    constructor(data, index, type) {
        this.name = data.name;
        this.hue = data.hue;
        this.index = index;
        this.type = type;
        this.x = 0; this.y = 0;
        this.tx = 0; this.ty = 0;
        this.alive = true;
        this.dying = false;
        this.dyingTimer = 0;
        this.health = 1.0;
        this.pulse = Math.random() * Math.PI * 2;
        this.radius = 18;
    }

    update() {
        this.pulse += 0.03;
        this.x += (this.tx - this.x) * 0.05;
        this.y += (this.ty - this.y) * 0.05;

        if (this.dying) {
            this.dyingTimer++;
            this.health -= 0.015;
            if (this.health <= 0) {
                this.alive = false;
                this.health = 0;
                if (this.type === 'flower') removedFlowers.add(this.index);
                else removedPollinators.add(this.index);
                checkCascade();
            }
        }
    }

    draw(ctx) {
        if (!this.alive) return;
        let r = this.radius + Math.sin(this.pulse) * 2;
        let alpha = this.dying ? 0.3 + Math.sin(this.dyingTimer * 0.2) * 0.2 : 0.85;
        let shake = this.dying ? Math.sin(this.dyingTimer * 0.5) * 3 : 0;
        let dx = this.x + shake;

        // Glow
        let glow = ctx.createRadialGradient(dx, this.y, 0, dx, this.y, r * 2.5);
        glow.addColorStop(0, `hsla(${this.hue}, 70%, 60%, ${alpha * 0.2})`);
        glow.addColorStop(1, `hsla(${this.hue}, 70%, 60%, 0)`);
        ctx.beginPath();
        ctx.arc(dx, this.y, r * 2.5, 0, Math.PI * 2);
        ctx.fillStyle = glow;
        ctx.fill();

        if (this.type === 'flower') {
            // Draw flower shape
            let petals = 5 + Math.floor(this.hue / 80);
            for (let p = 0; p < petals; p++) {
                let angle = (p / petals) * Math.PI * 2 + this.pulse * 0.1;
                let px = dx + Math.cos(angle) * r * 0.6;
                let py = this.y + Math.sin(angle) * r * 0.6;
                ctx.beginPath();
                ctx.arc(px, py, r * 0.45, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${this.hue}, 70%, 55%, ${alpha})`;
                ctx.fill();
            }
            ctx.beginPath();
            ctx.arc(dx, this.y, r * 0.35, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${(this.hue + 40) % 360}, 80%, 70%, ${alpha})`;
            ctx.fill();
        } else {
            // Draw pollinator as circle with wings
            ctx.beginPath();
            ctx.arc(dx, this.y, r * 0.6, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${this.hue}, 60%, 50%, ${alpha})`;
            ctx.fill();
            // Wings
            let wingAngle = Math.sin(this.pulse * 3) * 0.3;
            ctx.beginPath();
            ctx.ellipse(dx - r * 0.5, this.y - r * 0.2, r * 0.5, r * 0.25, -0.3 + wingAngle, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${this.hue}, 40%, 70%, ${alpha * 0.5})`;
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(dx + r * 0.5, this.y - r * 0.2, r * 0.5, r * 0.25, 0.3 - wingAngle, 0, Math.PI * 2);
            ctx.fill();
        }

        // Name label
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(this.name, dx, this.y + r + 14);

        // Health bar
        let barW = r * 1.5;
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.fillRect(dx - barW / 2, this.y + r + 18, barW, 3);
        let hColor = this.health > 0.5 ? '#4ade80' : this.health > 0.25 ? '#fbbf24' : '#ef4444';
        ctx.fillStyle = hColor;
        ctx.fillRect(dx - barW / 2, this.y + r + 18, barW * this.health, 3);
    }
}

function checkCascade() {
    // Flowers that have lost all pollinators
    for (let f of flowers) {
        if (!f.alive || f.dying) continue;
        let activePollinators = CONNECTIONS.filter(
            c => c[0] === f.index && !removedPollinators.has(c[1]) && pollinators[c[1]].alive && !pollinators[c[1]].dying
        );
        if (activePollinators.length === 0) {
            f.dying = true;
            cascadeEffects.push({ x: f.x, y: f.y, timer: 30 });
        } else {
            let original = CONNECTIONS.filter(c => c[0] === f.index).length;
            f.health = Math.max(0.1, activePollinators.length / original);
        }
    }

    // Pollinators that have lost all flowers
    for (let p of pollinators) {
        if (!p.alive || p.dying) continue;
        let activeFlowers = CONNECTIONS.filter(
            c => c[1] === p.index && !removedFlowers.has(c[0]) && flowers[c[0]].alive && !flowers[c[0]].dying
        );
        if (activeFlowers.length === 0) {
            p.dying = true;
            cascadeEffects.push({ x: p.x, y: p.y, timer: 30 });
        } else {
            let original = CONNECTIONS.filter(c => c[1] === p.index).length;
            p.health = Math.max(0.1, activeFlowers.length / original);
        }
    }
}

function layoutNodes() {
    let w = canvas.width;
    let h = canvas.height;
    let flowerX = w * 0.25;
    let pollinatorX = w * 0.75;
    let startY = 130;
    let endY = h - 100;

    for (let i = 0; i < flowers.length; i++) {
        flowers[i].tx = flowerX;
        flowers[i].ty = startY + (endY - startY) * (i / (flowers.length - 1));
    }
    for (let i = 0; i < pollinators.length; i++) {
        pollinators[i].tx = pollinatorX;
        pollinators[i].ty = startY + (endY - startY) * (i / (pollinators.length - 1));
    }
}

function init() {
    flowers = [];
    pollinators = [];
    removedFlowers.clear();
    removedPollinators.clear();
    cascadeEffects = [];
    particles = [];

    for (let i = 0; i < FLOWER_DATA.length; i++) {
        flowers.push(new Node(FLOWER_DATA[i], i, 'flower'));
    }
    for (let i = 0; i < POLLINATOR_DATA.length; i++) {
        pollinators.push(new Node(POLLINATOR_DATA[i], i, 'pollinator'));
    }
    layoutNodes();
    for (let f of flowers) { f.x = f.tx; f.y = f.ty; }
    for (let p of pollinators) { p.x = p.tx; p.y = p.ty; }
}

init();

document.getElementById('resetBtn').onclick = init;
document.getElementById('removeFlower').onclick = function() {
    let alive = flowers.filter(f => f.alive && !f.dying);
    if (alive.length > 0) {
        alive[Math.floor(Math.random() * alive.length)].dying = true;
    }
};
document.getElementById('removePollinator').onclick = function() {
    let alive = pollinators.filter(p => p.alive && !p.dying);
    if (alive.length > 0) {
        alive[Math.floor(Math.random() * alive.length)].dying = true;
    }
};

canvas.addEventListener('click', function(e) {
    let mx = e.clientX, my = e.clientY;
    for (let f of flowers) {
        if (!f.alive || f.dying) continue;
        let dx = mx - f.x, dy = my - f.y;
        if (dx * dx + dy * dy < 600) { f.dying = true; return; }
    }
    for (let p of pollinators) {
        if (!p.alive || p.dying) continue;
        let dx = mx - p.x, dy = my - p.y;
        if (dx * dx + dy * dy < 600) { p.dying = true; return; }
    }
});

canvas.addEventListener('mousemove', function(e) {
    let mx = e.clientX, my = e.clientY;
    let found = false;
    let allNodes = [...flowers, ...pollinators];
    for (let n of allNodes) {
        if (!n.alive) continue;
        let dx = mx - n.x, dy = my - n.y;
        if (dx * dx + dy * dy < 600) {
            tooltip.style.display = 'block';
            tooltip.style.left = (mx + 15) + 'px';
            tooltip.style.top = (my - 10) + 'px';
            let connections;
            if (n.type === 'flower') {
                connections = CONNECTIONS.filter(c => c[0] === n.index && !removedPollinators.has(c[1]) && pollinators[c[1]].alive)
                    .map(c => pollinators[c[1]].name).join(', ');
            } else {
                connections = CONNECTIONS.filter(c => c[1] === n.index && !removedFlowers.has(c[0]) && flowers[c[0]].alive)
                    .map(c => flowers[c[0]].name).join(', ');
            }
            tooltip.innerHTML = `<strong>${n.name}</strong> (${n.type})<br>Health: ${Math.round(n.health * 100)}%<br>Connected to: ${connections || 'none'}`;
            found = true;
            break;
        }
    }
    if (!found) tooltip.style.display = 'none';
});

let frameCount = 0;

function drawLinks(ctx) {
    for (let conn of CONNECTIONS) {
        let f = flowers[conn[0]];
        let p = pollinators[conn[1]];
        if (!f.alive || !p.alive) continue;

        let alpha = 0.2;
        if (f.dying || p.dying) alpha = 0.05;

        // Curved connection
        let midX = (f.x + p.x) / 2;
        let midY = (f.y + p.y) / 2 + (Math.sin(conn[0] * 0.5 + conn[1] * 0.3) * 30);

        ctx.beginPath();
        ctx.moveTo(f.x, f.y);
        ctx.quadraticCurveTo(midX, midY, p.x, p.y);

        let grad = ctx.createLinearGradient(f.x, f.y, p.x, p.y);
        grad.addColorStop(0, `hsla(${f.hue}, 70%, 60%, ${alpha})`);
        grad.addColorStop(1, `hsla(${p.hue}, 60%, 50%, ${alpha})`);
        ctx.strokeStyle = grad;
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Pollen particles traveling along links
        if (!f.dying && !p.dying && Math.random() < 0.01) {
            let t = (frameCount * 0.005 + conn[0] * 0.3 + conn[1] * 0.2) % 1;
            let tt = 1 - t;
            let px = tt * tt * f.x + 2 * tt * t * midX + t * t * p.x;
            let py = tt * tt * f.y + 2 * tt * t * midY + t * t * p.y;
            ctx.beginPath();
            ctx.arc(px, py, 2, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(50, 90%, 70%, 0.7)`;
            ctx.fill();
        }
    }
}

function update() {
    frameCount++;

    for (let f of flowers) f.update();
    for (let p of pollinators) p.update();

    // Update cascade effects
    cascadeEffects = cascadeEffects.filter(e => {
        e.timer--;
        return e.timer > 0;
    });

    // Update stats
    let aliveFlowers = flowers.filter(f => f.alive).length;
    let alivePollinators = pollinators.filter(p => p.alive).length;
    let aliveLinks = CONNECTIONS.filter(c =>
        flowers[c[0]].alive && pollinators[c[1]].alive
    ).length;
    document.getElementById('flowerCount').textContent = aliveFlowers;
    document.getElementById('pollinatorCount').textContent = alivePollinators;
    document.getElementById('linkCount').textContent = aliveLinks;
    let maxLinks = CONNECTIONS.length;
    document.getElementById('netHealth').textContent = Math.round(aliveLinks / maxLinks * 100);
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Background
    let grad = ctx.createRadialGradient(
        canvas.width / 2, canvas.height / 2, 0,
        canvas.width / 2, canvas.height / 2, canvas.width * 0.5
    );
    grad.addColorStop(0, 'rgba(20, 15, 30, 0.5)');
    grad.addColorStop(1, 'rgba(10, 14, 26, 0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Column labels
    ctx.fillStyle = '#f472b6';
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('FLOWERS', canvas.width * 0.25, 115);
    ctx.fillStyle = '#fbbf24';
    ctx.fillText('POLLINATORS', canvas.width * 0.75, 115);

    drawLinks(ctx);

    // Cascade effects
    for (let e of cascadeEffects) {
        let r = (30 - e.timer) * 3;
        ctx.beginPath();
        ctx.arc(e.x, e.y, r, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(239, 68, 68, ${e.timer / 30 * 0.5})`;
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    for (let f of flowers) f.draw(ctx);
    for (let p of pollinators) p.draw(ctx);
}

function animate() {
    update();
    draw();
    requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
