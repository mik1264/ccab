<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolutionary Walkers - CCAB</title>
    <meta name="description" content="Watch bipedal creatures learn to walk through genetic algorithms and neural networks. Evolution in action as walkers compete for the best gait.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.6);
            color: #4fc3f7;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(79, 195, 247, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(79, 195, 247, 0.2);
            transform: translateX(-4px);
        }

        #info {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            border-radius: 12px;
            color: #4fc3f7;
            font-size: 13px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(79, 195, 247, 0.2);
            z-index: 1000;
            max-width: 300px;
        }

        #info h3 {
            margin-bottom: 10px;
            color: #fff;
        }

        #info .stat {
            margin: 5px 0;
        }

        #info .stat-label {
            color: #aaa;
            font-size: 11px;
        }

        #info .stat-value {
            color: #4fc3f7;
            font-weight: bold;
        }

        #info p {
            font-size: 11px;
            opacity: 0.8;
            line-height: 1.5;
            margin-top: 10px;
            color: #ddd;
        }

        #presets {
            position: fixed;
            top: 250px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }

        button {
            background: rgba(79, 195, 247, 0.15);
            border: 1px solid rgba(79, 195, 247, 0.4);
            color: #4fc3f7;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(79, 195, 247, 0.3);
        }

        button.active {
            background: rgba(79, 195, 247, 0.4);
            border-color: #4fc3f7;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 16px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(79, 195, 247, 0.2);
        }

        .control-group label {
            color: #4fc3f7;
            font-size: 11px;
            display: block;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 100px;
            accent-color: #4fc3f7;
        }

        .control-group span {
            color: #fff;
            font-size: 10px;
            margin-left: 6px;
        }

        #fps-display {
            position: fixed;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 6px;
            color: #4fc3f7;
            font-size: 12px;
            z-index: 1000;
        }

        #generation-bar {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 20px;
            border-radius: 8px;
            color: #4fc3f7;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(79, 195, 247, 0.2);
        }

        .progress-bar {
            width: 200px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            margin-top: 6px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4fc3f7, #81d4fa);
            border-radius: 3px;
            transition: width 0.1s;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div id="info">
        <h3>Evolutionary Walkers</h3>
        <div class="stat">
            <span class="stat-label">Generation</span>
            <span class="stat-value" id="generation">1</span>
        </div>
        <div class="stat">
            <span class="stat-label">Best Fitness (All Time)</span>
            <span class="stat-value" id="best-fitness">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Alive</span>
            <span class="stat-value" id="alive-count">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Population</span>
            <span class="stat-value" id="population">50</span>
        </div>
        <p>Bipedal walkers evolve using genetic algorithms. Neural networks control joint motors. Fitness = distance traveled while staying upright.</p>
    </div>

    <div id="generation-bar">
        <span>Generation Progress: <span id="time-left">10.0</span>s</span>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
    </div>

    <div id="presets">
        <button class="active" data-preset="standard">Standard Evolution</button>
        <button data-preset="fast">Fast Evolution</button>
        <button data-preset="hardcore">Hardcore Terrain</button>
        <button data-preset="giants">Giant Walkers</button>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>Mutation Rate: <span id="mutation-val">0.1</span></label>
            <input type="range" id="mutation" min="0.01" max="0.5" step="0.01" value="0.1">
        </div>
        <div class="control-group">
            <label>Population: <span id="pop-val">50</span></label>
            <input type="range" id="pop-size" min="20" max="100" step="10" value="50">
        </div>
        <div class="control-group">
            <label>Speed: <span id="speed-val">1x</span></label>
            <input type="range" id="speed" min="1" max="5" step="1" value="1">
        </div>
    </div>

    <div id="fps-display">FPS: <span id="fps">0</span></div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // DOM elements
        const genDisplay = document.getElementById('generation');
        const bestFitnessDisplay = document.getElementById('best-fitness');
        const aliveDisplay = document.getElementById('alive-count');
        const populationDisplay = document.getElementById('population');
        const timeLeftDisplay = document.getElementById('time-left');
        const progressFill = document.getElementById('progress-fill');
        const fpsDisplay = document.getElementById('fps');
        const mutationSlider = document.getElementById('mutation');
        const mutationVal = document.getElementById('mutation-val');
        const popSlider = document.getElementById('pop-size');
        const popVal = document.getElementById('pop-val');
        const speedSlider = document.getElementById('speed');
        const speedVal = document.getElementById('speed-val');

        // Configuration
        let config = {
            populationSize: 50,
            mutationRate: 0.1,
            generationTime: 10000, // ms
            gravity: 0.5,
            groundFriction: 0.8,
            speed: 1,
            terrain: 'normal'
        };

        // Physics constants
        const GROUND_Y = canvas.height - 100;
        const DT = 1 / 60;

        // Neural Network
        class NeuralNetwork {
            constructor(inputSize, hiddenSize, outputSize) {
                this.inputSize = inputSize;
                this.hiddenSize = hiddenSize;
                this.outputSize = outputSize;

                // Initialize weights randomly
                this.weightsIH = this.randomMatrix(hiddenSize, inputSize);
                this.weightsHO = this.randomMatrix(outputSize, hiddenSize);
                this.biasH = this.randomArray(hiddenSize);
                this.biasO = this.randomArray(outputSize);
            }

            randomMatrix(rows, cols) {
                const matrix = [];
                for (let i = 0; i < rows; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < cols; j++) {
                        matrix[i][j] = (Math.random() - 0.5) * 2;
                    }
                }
                return matrix;
            }

            randomArray(size) {
                return Array(size).fill(0).map(() => (Math.random() - 0.5) * 2);
            }

            tanh(x) {
                return Math.tanh(x);
            }

            forward(inputs) {
                // Hidden layer
                const hidden = [];
                for (let i = 0; i < this.hiddenSize; i++) {
                    let sum = this.biasH[i];
                    for (let j = 0; j < this.inputSize; j++) {
                        sum += this.weightsIH[i][j] * inputs[j];
                    }
                    hidden[i] = this.tanh(sum);
                }

                // Output layer
                const outputs = [];
                for (let i = 0; i < this.outputSize; i++) {
                    let sum = this.biasO[i];
                    for (let j = 0; j < this.hiddenSize; j++) {
                        sum += this.weightsHO[i][j] * hidden[j];
                    }
                    outputs[i] = this.tanh(sum);
                }

                return outputs;
            }

            copy() {
                const nn = new NeuralNetwork(this.inputSize, this.hiddenSize, this.outputSize);
                nn.weightsIH = this.weightsIH.map(row => [...row]);
                nn.weightsHO = this.weightsHO.map(row => [...row]);
                nn.biasH = [...this.biasH];
                nn.biasO = [...this.biasO];
                return nn;
            }

            mutate(rate) {
                const mutateValue = (val) => {
                    if (Math.random() < rate) {
                        return val + (Math.random() - 0.5) * 0.5;
                    }
                    return val;
                };

                this.weightsIH = this.weightsIH.map(row => row.map(mutateValue));
                this.weightsHO = this.weightsHO.map(row => row.map(mutateValue));
                this.biasH = this.biasH.map(mutateValue);
                this.biasO = this.biasO.map(mutateValue);
            }

            crossover(other) {
                const child = this.copy();
                for (let i = 0; i < this.hiddenSize; i++) {
                    for (let j = 0; j < this.inputSize; j++) {
                        if (Math.random() < 0.5) {
                            child.weightsIH[i][j] = other.weightsIH[i][j];
                        }
                    }
                }
                for (let i = 0; i < this.outputSize; i++) {
                    for (let j = 0; j < this.hiddenSize; j++) {
                        if (Math.random() < 0.5) {
                            child.weightsHO[i][j] = other.weightsHO[i][j];
                        }
                    }
                }
                for (let i = 0; i < this.hiddenSize; i++) {
                    if (Math.random() < 0.5) child.biasH[i] = other.biasH[i];
                }
                for (let i = 0; i < this.outputSize; i++) {
                    if (Math.random() < 0.5) child.biasO[i] = other.biasO[i];
                }
                return child;
            }
        }

        // Walker body part
        class BodyPart {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.vx = 0;
                this.vy = 0;
                this.angle = 0;
                this.angularVel = 0;
            }

            getEndPoint() {
                return {
                    x: this.x + Math.sin(this.angle) * this.height,
                    y: this.y + Math.cos(this.angle) * this.height
                };
            }
        }

        // Walker creature
        class Walker {
            constructor(x, brain = null, scale = 1) {
                this.startX = x;
                this.scale = scale;

                // Body parts (scaled)
                const s = scale;
                this.torso = new BodyPart(x, GROUND_Y - 80 * s, 20 * s, 40 * s);
                this.head = new BodyPart(x, GROUND_Y - 120 * s, 15 * s, 15 * s);

                // Legs: thigh + shin for each leg
                this.leftThigh = new BodyPart(x, GROUND_Y - 80 * s, 8 * s, 30 * s);
                this.leftShin = new BodyPart(x, GROUND_Y - 50 * s, 6 * s, 30 * s);
                this.rightThigh = new BodyPart(x, GROUND_Y - 80 * s, 8 * s, 30 * s);
                this.rightShin = new BodyPart(x, GROUND_Y - 50 * s, 6 * s, 30 * s);

                // Joint angles
                this.leftHipAngle = 0;
                this.leftKneeAngle = 0;
                this.rightHipAngle = 0;
                this.rightKneeAngle = 0;

                // Motor targets
                this.leftHipTarget = 0;
                this.leftKneeTarget = 0;
                this.rightHipTarget = 0;
                this.rightKneeTarget = 0;

                // State
                this.alive = true;
                this.fitness = 0;
                this.groundContact = { left: false, right: false };

                // Neural network: 8 inputs, 10 hidden, 4 outputs
                // Inputs: torso angle, torso angular vel, 4 joint angles, 2 ground contacts
                // Outputs: 4 joint motor targets
                this.brain = brain || new NeuralNetwork(8, 10, 4);

                // Color based on brain (hash of weights)
                this.color = this.generateColor();
            }

            generateColor() {
                let hash = 0;
                const weights = this.brain.weightsIH.flat();
                for (let i = 0; i < Math.min(10, weights.length); i++) {
                    hash += weights[i] * 1000;
                }
                const hue = Math.abs(hash % 360);
                return `hsl(${hue}, 70%, 60%)`;
            }

            think() {
                // Gather inputs
                const inputs = [
                    this.torso.angle / Math.PI,
                    this.torso.angularVel / 5,
                    this.leftHipAngle / Math.PI,
                    this.leftKneeAngle / Math.PI,
                    this.rightHipAngle / Math.PI,
                    this.rightKneeAngle / Math.PI,
                    this.groundContact.left ? 1 : -1,
                    this.groundContact.right ? 1 : -1
                ];

                const outputs = this.brain.forward(inputs);

                // Set motor targets (scaled to angle range)
                this.leftHipTarget = outputs[0] * Math.PI / 3;
                this.leftKneeTarget = outputs[1] * Math.PI / 3;
                this.rightHipTarget = outputs[2] * Math.PI / 3;
                this.rightKneeTarget = outputs[3] * Math.PI / 3;
            }

            update(terrain) {
                if (!this.alive) return;

                // Think
                this.think();

                // Apply motor forces to joints
                const motorStrength = 0.1;
                this.leftHipAngle += (this.leftHipTarget - this.leftHipAngle) * motorStrength;
                this.leftKneeAngle += (this.leftKneeTarget - this.leftKneeAngle) * motorStrength;
                this.rightHipAngle += (this.rightHipTarget - this.rightHipAngle) * motorStrength;
                this.rightKneeAngle += (this.rightKneeTarget - this.rightKneeAngle) * motorStrength;

                // Clamp joint angles
                const hipRange = Math.PI / 2;
                const kneeRange = Math.PI / 2;
                this.leftHipAngle = Math.max(-hipRange, Math.min(hipRange, this.leftHipAngle));
                this.leftKneeAngle = Math.max(-0.1, Math.min(kneeRange, this.leftKneeAngle));
                this.rightHipAngle = Math.max(-hipRange, Math.min(hipRange, this.rightHipAngle));
                this.rightKneeAngle = Math.max(-0.1, Math.min(kneeRange, this.rightKneeAngle));

                // Apply gravity to torso
                this.torso.vy += config.gravity;
                this.torso.x += this.torso.vx;
                this.torso.y += this.torso.vy;

                // Apply angular dynamics
                this.torso.angle += this.torso.angularVel;
                this.torso.angularVel *= 0.98; // Damping

                // Update leg positions based on torso and joint angles
                const torsoBottom = {
                    x: this.torso.x,
                    y: this.torso.y + this.torso.height / 2
                };

                // Left leg
                const leftHipX = torsoBottom.x - 5 * this.scale;
                const leftHipY = torsoBottom.y;
                const leftThighEnd = {
                    x: leftHipX + Math.sin(this.torso.angle + this.leftHipAngle) * this.leftThigh.height,
                    y: leftHipY + Math.cos(this.torso.angle + this.leftHipAngle) * this.leftThigh.height
                };
                const leftFootX = leftThighEnd.x + Math.sin(this.torso.angle + this.leftHipAngle + this.leftKneeAngle) * this.leftShin.height;
                const leftFootY = leftThighEnd.y + Math.cos(this.torso.angle + this.leftHipAngle + this.leftKneeAngle) * this.leftShin.height;

                // Right leg
                const rightHipX = torsoBottom.x + 5 * this.scale;
                const rightHipY = torsoBottom.y;
                const rightThighEnd = {
                    x: rightHipX + Math.sin(this.torso.angle + this.rightHipAngle) * this.rightThigh.height,
                    y: rightHipY + Math.cos(this.torso.angle + this.rightHipAngle) * this.rightThigh.height
                };
                const rightFootX = rightThighEnd.x + Math.sin(this.torso.angle + this.rightHipAngle + this.rightKneeAngle) * this.rightShin.height;
                const rightFootY = rightThighEnd.y + Math.cos(this.torso.angle + this.rightHipAngle + this.rightKneeAngle) * this.rightShin.height;

                // Store leg positions for drawing
                this.leftLeg = { hip: { x: leftHipX, y: leftHipY }, knee: leftThighEnd, foot: { x: leftFootX, y: leftFootY } };
                this.rightLeg = { hip: { x: rightHipX, y: rightHipY }, knee: rightThighEnd, foot: { x: rightFootX, y: rightFootY } };

                // Ground collision for feet
                const groundAtLeft = terrain(leftFootX);
                const groundAtRight = terrain(rightFootX);

                this.groundContact.left = false;
                this.groundContact.right = false;

                if (leftFootY > groundAtLeft) {
                    this.groundContact.left = true;
                    // Push torso up and apply friction
                    const penetration = leftFootY - groundAtLeft;
                    this.torso.y -= penetration * 0.5;
                    this.torso.vy = Math.min(0, this.torso.vy);
                    this.torso.vx *= config.groundFriction;

                    // Walking push
                    if (this.leftHipAngle > 0) {
                        this.torso.vx += 0.3;
                    }
                }

                if (rightFootY > groundAtRight) {
                    this.groundContact.right = true;
                    const penetration = rightFootY - groundAtRight;
                    this.torso.y -= penetration * 0.5;
                    this.torso.vy = Math.min(0, this.torso.vy);
                    this.torso.vx *= config.groundFriction;

                    if (this.rightHipAngle > 0) {
                        this.torso.vx += 0.3;
                    }
                }

                // Balance torque from leg positions
                const avgFootX = (leftFootX + rightFootX) / 2;
                const torqueFactor = (this.torso.x - avgFootX) * 0.001;
                this.torso.angularVel += torqueFactor;

                // Update head position
                this.head.x = this.torso.x - Math.sin(this.torso.angle) * (this.torso.height / 2 + this.head.height);
                this.head.y = this.torso.y - Math.cos(this.torso.angle) * (this.torso.height / 2 + this.head.height) - this.head.height;

                // Check if fallen (head too low or torso too tilted)
                const groundAtTorso = terrain(this.torso.x);
                if (this.head.y > groundAtTorso - 20 || Math.abs(this.torso.angle) > Math.PI / 2) {
                    this.alive = false;
                }

                // Update fitness (distance traveled + height bonus)
                this.fitness = Math.max(0, this.torso.x - this.startX);
                const heightBonus = Math.max(0, (groundAtTorso - this.torso.y) / 100);
                this.fitness += heightBonus * 10;
            }

            draw(ctx, cameraX) {
                const offsetX = -cameraX;
                const alpha = this.alive ? 1 : 0.3;

                ctx.save();
                ctx.globalAlpha = alpha;

                // Draw legs
                ctx.strokeStyle = this.color;
                ctx.lineWidth = this.leftThigh.width;
                ctx.lineCap = 'round';

                // Left leg
                ctx.beginPath();
                ctx.moveTo(this.leftLeg.hip.x + offsetX, this.leftLeg.hip.y);
                ctx.lineTo(this.leftLeg.knee.x + offsetX, this.leftLeg.knee.y);
                ctx.lineTo(this.leftLeg.foot.x + offsetX, this.leftLeg.foot.y);
                ctx.stroke();

                // Right leg
                ctx.lineWidth = this.rightThigh.width;
                ctx.beginPath();
                ctx.moveTo(this.rightLeg.hip.x + offsetX, this.rightLeg.hip.y);
                ctx.lineTo(this.rightLeg.knee.x + offsetX, this.rightLeg.knee.y);
                ctx.lineTo(this.rightLeg.foot.x + offsetX, this.rightLeg.foot.y);
                ctx.stroke();

                // Draw torso
                ctx.save();
                ctx.translate(this.torso.x + offsetX, this.torso.y);
                ctx.rotate(this.torso.angle);
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.torso.width / 2, -this.torso.height / 2, this.torso.width, this.torso.height);
                ctx.restore();

                // Draw head
                ctx.beginPath();
                ctx.arc(this.head.x + offsetX, this.head.y + this.head.height / 2, this.head.width, 0, Math.PI * 2);
                ctx.fill();

                // Draw ground contact indicators
                if (this.groundContact.left) {
                    ctx.fillStyle = '#4fc3f7';
                    ctx.beginPath();
                    ctx.arc(this.leftLeg.foot.x + offsetX, this.leftLeg.foot.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                if (this.groundContact.right) {
                    ctx.fillStyle = '#4fc3f7';
                    ctx.beginPath();
                    ctx.arc(this.rightLeg.foot.x + offsetX, this.rightLeg.foot.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        // Population management
        let population = [];
        let generation = 1;
        let generationStartTime = 0;
        let bestFitnessEver = 0;
        let cameraX = 0;
        let terrainPoints = [];

        function generateTerrain() {
            terrainPoints = [];
            const segments = Math.ceil(canvas.width * 10 / 50);
            let x = -1000;
            let y = GROUND_Y;

            for (let i = 0; i < segments; i++) {
                if (config.terrain === 'hardcore' && i > 10) {
                    // Add bumps and valleys
                    y = GROUND_Y + Math.sin(i * 0.3) * 30 + Math.random() * 20 - 10;
                } else {
                    y = GROUND_Y + Math.sin(i * 0.1) * 5;
                }
                terrainPoints.push({ x, y });
                x += 50;
            }
        }

        function getGroundY(x) {
            // Find terrain segment
            for (let i = 0; i < terrainPoints.length - 1; i++) {
                if (x >= terrainPoints[i].x && x < terrainPoints[i + 1].x) {
                    // Interpolate
                    const t = (x - terrainPoints[i].x) / (terrainPoints[i + 1].x - terrainPoints[i].x);
                    return terrainPoints[i].y + t * (terrainPoints[i + 1].y - terrainPoints[i].y);
                }
            }
            return GROUND_Y;
        }

        function initPopulation() {
            population = [];
            for (let i = 0; i < config.populationSize; i++) {
                const scale = config.terrain === 'giants' ? 1.5 : 1;
                population.push(new Walker(200 + Math.random() * 100, null, scale));
            }
            generationStartTime = performance.now();
            generateTerrain();
        }

        function nextGeneration() {
            // Sort by fitness
            population.sort((a, b) => b.fitness - a.fitness);

            // Update best fitness
            if (population[0].fitness > bestFitnessEver) {
                bestFitnessEver = population[0].fitness;
            }

            // Selection: keep top 20%
            const survivors = Math.floor(config.populationSize * 0.2);
            const elite = population.slice(0, survivors);

            // Create new population
            const newPopulation = [];

            // Keep elite unchanged
            for (let i = 0; i < Math.min(2, elite.length); i++) {
                const scale = config.terrain === 'giants' ? 1.5 : 1;
                newPopulation.push(new Walker(200 + Math.random() * 100, elite[i].brain.copy(), scale));
            }

            // Fill rest with offspring
            while (newPopulation.length < config.populationSize) {
                // Tournament selection
                const parent1 = elite[Math.floor(Math.random() * elite.length)];
                const parent2 = elite[Math.floor(Math.random() * elite.length)];

                // Crossover
                const childBrain = parent1.brain.crossover(parent2.brain);

                // Mutation
                childBrain.mutate(config.mutationRate);

                const scale = config.terrain === 'giants' ? 1.5 : 1;
                newPopulation.push(new Walker(200 + Math.random() * 100, childBrain, scale));
            }

            population = newPopulation;
            generation++;
            generationStartTime = performance.now();

            // Regenerate terrain for variety
            if (config.terrain === 'hardcore') {
                generateTerrain();
            }
        }

        function drawTerrain(cameraX) {
            ctx.fillStyle = '#2d3436';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);

            for (const point of terrainPoints) {
                const screenX = point.x - cameraX;
                if (screenX > -100 && screenX < canvas.width + 100) {
                    ctx.lineTo(screenX, point.y);
                }
            }

            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();

            // Draw grass on top
            ctx.strokeStyle = '#4a6741';
            ctx.lineWidth = 2;
            for (const point of terrainPoints) {
                const screenX = point.x - cameraX;
                if (screenX > -100 && screenX < canvas.width + 100) {
                    ctx.beginPath();
                    ctx.moveTo(screenX, point.y);
                    ctx.lineTo(screenX, point.y - 5);
                    ctx.stroke();
                }
            }
        }

        function drawDistanceMarkers(cameraX) {
            ctx.fillStyle = 'rgba(79, 195, 247, 0.3)';
            ctx.font = '12px monospace';

            for (let x = 0; x < 5000; x += 100) {
                const screenX = x + 200 - cameraX;
                if (screenX > 0 && screenX < canvas.width) {
                    ctx.beginPath();
                    ctx.moveTo(screenX, GROUND_Y - 50);
                    ctx.lineTo(screenX, GROUND_Y + 20);
                    ctx.strokeStyle = 'rgba(79, 195, 247, 0.2)';
                    ctx.stroke();
                    ctx.fillText(`${x}m`, screenX - 15, GROUND_Y + 35);
                }
            }
        }

        // FPS tracking
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;

        function animate(currentTime) {
            requestAnimationFrame(animate);

            // FPS calculation
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                fpsDisplay.textContent = fps;
            }

            // Clear
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update generation timer
            const elapsed = currentTime - generationStartTime;
            const timeLeft = Math.max(0, (config.generationTime - elapsed) / 1000);
            timeLeftDisplay.textContent = timeLeft.toFixed(1);
            progressFill.style.width = `${(elapsed / config.generationTime) * 100}%`;

            // Check for generation end
            const allDead = population.every(w => !w.alive);
            if (elapsed > config.generationTime || allDead) {
                nextGeneration();
            }

            // Update walkers
            for (let i = 0; i < config.speed; i++) {
                for (const walker of population) {
                    walker.update(getGroundY);
                }
            }

            // Camera follows best alive walker
            const aliveWalkers = population.filter(w => w.alive);
            if (aliveWalkers.length > 0) {
                const best = aliveWalkers.reduce((a, b) => a.torso.x > b.torso.x ? a : b);
                cameraX += (best.torso.x - canvas.width / 3 - cameraX) * 0.05;
            }

            // Draw terrain
            drawTerrain(cameraX);
            drawDistanceMarkers(cameraX);

            // Draw walkers
            for (const walker of population) {
                walker.draw(ctx, cameraX);
            }

            // Update stats
            genDisplay.textContent = generation;
            bestFitnessDisplay.textContent = bestFitnessEver.toFixed(1);
            aliveDisplay.textContent = aliveWalkers.length;
            populationDisplay.textContent = config.populationSize;
        }

        // Control handlers
        mutationSlider.addEventListener('input', (e) => {
            config.mutationRate = parseFloat(e.target.value);
            mutationVal.textContent = config.mutationRate.toFixed(2);
        });

        popSlider.addEventListener('input', (e) => {
            config.populationSize = parseInt(e.target.value);
            popVal.textContent = config.populationSize;
        });

        speedSlider.addEventListener('input', (e) => {
            config.speed = parseInt(e.target.value);
            speedVal.textContent = `${config.speed}x`;
        });

        // Preset buttons
        document.querySelectorAll('#presets button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('#presets button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                const preset = btn.dataset.preset;
                switch (preset) {
                    case 'standard':
                        config.generationTime = 10000;
                        config.terrain = 'normal';
                        break;
                    case 'fast':
                        config.generationTime = 5000;
                        config.terrain = 'normal';
                        break;
                    case 'hardcore':
                        config.generationTime = 15000;
                        config.terrain = 'hardcore';
                        break;
                    case 'giants':
                        config.generationTime = 12000;
                        config.terrain = 'giants';
                        break;
                }

                // Reset simulation
                generation = 1;
                bestFitnessEver = 0;
                cameraX = 0;
                initPopulation();
            });
        });

        // Expose functions for enhance.js keyboard shortcuts
        window.reset = function() { generation = 1; bestFitnessEver = 0; cameraX = 0; initPopulation(); };

        // Initialize and start
        initPopulation();
        requestAnimationFrame(animate);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
