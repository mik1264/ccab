<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voronoi & Delaunay - CCAB</title>
    <link rel="stylesheet" href="../assets/css/navigation.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Spectral:ital,wght@0,400;0,600;1,400&family=Space+Mono:wght@400;700&display=swap');

        :root {
            /* CCAB Color scheme */
            --bg-primary: #0a0e1a;
            --bg-secondary: #111827;
            --text-primary: #e0e0ff;
            --text-secondary: #a0a0c0;
            --text-accent: #fbbf24;
            --theme-color: #667eea;

            /* Spacing */
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            /* Typography */
            --font-display: 'Orbitron', sans-serif;
            --font-heading: 'Spectral', serif;
            --font-mono: 'Space Mono', monospace;
            --font-body: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

            /* Layout */
            --header-height: 64px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: linear-gradient(135deg, var(--bg-primary) 0%, #0f172a 50%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            padding: 20px;
            padding-top: calc(var(--header-height) + 20px);
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            font-family: var(--font-display);
            text-align: center;
            margin-bottom: 10px;
            font-size: clamp(2rem, 5vw, 3rem);
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 50%, var(--theme-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            padding: 12px 24px;
            background: rgba(224, 224, 255, 0.1);
            border: 2px solid rgba(224, 224, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
            color: var(--text-primary);
        }

        .tab:hover {
            background: rgba(224, 224, 255, 0.2);
            transform: translateY(-2px);
        }

        .tab.active {
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border-color: var(--theme-color);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .view {
            display: none;
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .view.active {
            display: block;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        input[type="range"] {
            width: 150px;
        }

        input[type="number"] {
            width: 80px;
            padding: 8px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 1em;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .canvas-container {
            position: relative;
            display: flex;
            justify-content: center;
            margin: 20px auto;
        }

        canvas {
            display: block;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            cursor: crosshair;
            background: #000;
        }

        .stats-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--theme-color);
            font-family: var(--font-mono);
        }

        .stat-label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid var(--theme-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .info-box h3 {
            margin-bottom: 10px;
            color: var(--theme-color);
        }

        .toggle-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .toggle:hover {
            background: rgba(224, 224, 255, 0.2);
        }

        .toggle.active {
            background: rgba(102, 126, 234, 0.3);
            border-color: var(--theme-color);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .tabs {
                font-size: 0.9em;
            }

            .tab {
                padding: 8px 16px;
            }

            canvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation Header -->
    <nav class="ccab-nav">
        <div class="nav-container">
            <a href="../index.html" class="nav-home">
                <span class="nav-logo">CCAB</span>
                <span class="nav-tagline">Claude Code and Algorithmic Beauty</span>
            </a>
            <div class="nav-breadcrumb"></div>
        </div>
    </nav>

    <div class="container">
        <h1>Voronoi & Delaunay</h1>
        <p class="subtitle">Geometric Tessellations and Triangulations</p>

        <div class="tabs">
            <div class="tab active" data-view="voronoi">Voronoi Diagram</div>
            <div class="tab" data-view="delaunay">Delaunay Triangulation</div>
            <div class="tab" data-view="lloyd">Lloyd Relaxation</div>
            <div class="tab" data-view="dual">Dual Graph</div>
        </div>

        <!-- Voronoi View -->
        <div class="view active" id="voronoi">
            <div class="info-box">
                <h3>Voronoi Diagram</h3>
                <p>A Voronoi diagram partitions a plane into regions based on distance to seed points.
                Each cell contains all points closer to its seed than to any other seed. Named after
                Georgy Voronoi, these diagrams appear everywhere in nature - from cell structures to
                territorial boundaries.</p>
            </div>

            <div class="controls">
                <button onclick="addRandomPoints(10)">Add 10 Random Points</button>
                <button onclick="addRandomPoints(50)">Add 50 Random Points</button>
                <button onclick="clearPoints()">Clear All</button>
                <div class="toggle-group">
                    <div class="toggle active" id="colorToggle" onclick="toggleCellColors()">
                        <span>Cell Colors</span>
                    </div>
                    <div class="toggle" id="pointsToggle" onclick="toggleShowPoints()">
                        <span>Show Points</span>
                    </div>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="voronoiCanvas" width="800" height="600"></canvas>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="pointCount">0</div>
                        <div class="stat-label">Points</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="cellCount">0</div>
                        <div class="stat-label">Cells</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="avgArea">0</div>
                        <div class="stat-label">Avg Cell Area (px²)</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Delaunay View -->
        <div class="view" id="delaunay">
            <div class="info-box">
                <h3>Delaunay Triangulation</h3>
                <p>The Delaunay triangulation maximizes the minimum angle of all triangles, avoiding
                sliver triangles. It's the dual graph of the Voronoi diagram - each Voronoi edge
                corresponds to a Delaunay edge connecting the adjacent seed points. Used extensively
                in mesh generation, terrain modeling, and finite element analysis.</p>
            </div>

            <div class="controls">
                <button onclick="addRandomPoints(10)">Add 10 Random Points</button>
                <button onclick="addRandomPoints(50)">Add 50 Random Points</button>
                <button onclick="clearPoints()">Clear All</button>
                <div class="toggle-group">
                    <div class="toggle active" id="triangleToggle" onclick="toggleTriangleFill()">
                        <span>Fill Triangles</span>
                    </div>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="delaunayCanvas" width="800" height="600"></canvas>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="triCount">0</div>
                        <div class="stat-label">Triangles</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="edgeCount">0</div>
                        <div class="stat-label">Edges</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="avgAngle">60.0°</div>
                        <div class="stat-label">Avg Triangle Angle</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Lloyd Relaxation View -->
        <div class="view" id="lloyd">
            <div class="info-box">
                <h3>Lloyd Relaxation</h3>
                <p>Lloyd's algorithm iteratively moves each point to the centroid of its Voronoi cell,
                creating a more uniform distribution. After many iterations, points converge to a
                centroidal Voronoi tessellation (CVT) - widely used in image stippling, mesh generation,
                and optimal facility placement.</p>
            </div>

            <div class="controls">
                <button onclick="addRandomPoints(50)">Add 50 Random Points</button>
                <button onclick="clearPoints()">Clear All</button>
                <button onclick="relaxStep()">Single Step</button>
                <button onclick="toggleAutoRelax()">Auto Relax</button>
                <div class="control-group">
                    <label for="relaxSpeed">Speed: <span id="relaxSpeedVal">1</span></label>
                    <input type="range" id="relaxSpeed" min="1" max="10" value="1">
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="lloydCanvas" width="800" height="600"></canvas>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="iterations">0</div>
                        <div class="stat-label">Iterations</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="maxMovement">0.00</div>
                        <div class="stat-label">Max Movement (px)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="uniformity">0.00</div>
                        <div class="stat-label">Uniformity</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Dual Graph View -->
        <div class="view" id="dual">
            <div class="info-box">
                <h3>Dual Graph Overlay</h3>
                <p>The Voronoi diagram and Delaunay triangulation are mathematical duals. Each
                Voronoi vertex is the circumcenter of a Delaunay triangle, and Voronoi edges are
                perpendicular bisectors of Delaunay edges. This duality is fundamental in
                computational geometry.</p>
            </div>

            <div class="controls">
                <button onclick="addRandomPoints(10)">Add 10 Random Points</button>
                <button onclick="addRandomPoints(50)">Add 50 Random Points</button>
                <button onclick="clearPoints()">Clear All</button>
                <div class="toggle-group">
                    <div class="toggle active" id="voronoiOverlay" onclick="toggleVoronoiOverlay()">
                        <span>Voronoi</span>
                    </div>
                    <div class="toggle active" id="delaunayOverlay" onclick="toggleDelaunayOverlay()">
                        <span>Delaunay</span>
                    </div>
                    <div class="toggle" id="circumcircles" onclick="toggleCircumcircles()">
                        <span>Circumcircles</span>
                    </div>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="dualCanvas" width="800" height="600"></canvas>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="dualPoints">0</div>
                        <div class="stat-label">Points</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="voronoiEdges">0</div>
                        <div class="stat-label">Voronoi Edges</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="delaunayEdges">0</div>
                        <div class="stat-label">Delaunay Edges</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let points = [];
        let showCellColors = true;
        let showPoints = false;
        let showTriangleFill = true;
        let autoRelaxing = false;
        let relaxIterations = 0;
        let showVoronoi = true;
        let showDelaunay = true;
        let showCircumcircles = false;

        // Canvas contexts
        const canvases = {
            voronoi: document.getElementById('voronoiCanvas'),
            delaunay: document.getElementById('delaunayCanvas'),
            lloyd: document.getElementById('lloydCanvas'),
            dual: document.getElementById('dualCanvas')
        };

        const ctxs = {
            voronoi: canvases.voronoi.getContext('2d'),
            delaunay: canvases.delaunay.getContext('2d'),
            lloyd: canvases.lloyd.getContext('2d'),
            dual: canvases.dual.getContext('2d')
        };

        // Setup event listeners
        Object.values(canvases).forEach(canvas => {
            canvas.addEventListener('click', handleClick);
            canvas.addEventListener('contextmenu', handleRightClick);
        });

        document.getElementById('relaxSpeed').addEventListener('input', (e) => {
            document.getElementById('relaxSpeedVal').textContent = e.target.value;
        });

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.view).classList.add('active');
                updateAll();
            });
        });

        // Handle clicks
        function handleClick(e) {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            points.push({ x, y });
            relaxIterations = 0;
            updateAll();
        }

        function handleRightClick(e) {
            e.preventDefault();
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Find and remove nearest point
            let minDist = Infinity;
            let minIndex = -1;
            points.forEach((p, i) => {
                const dist = Math.sqrt((p.x - x) ** 2 + (p.y - y) ** 2);
                if (dist < minDist) {
                    minDist = dist;
                    minIndex = i;
                }
            });

            if (minIndex >= 0 && minDist < 20) {
                points.splice(minIndex, 1);
                relaxIterations = 0;
                updateAll();
            }
        }

        // Point management
        function addRandomPoints(n) {
            const width = 800;
            const height = 600;
            for (let i = 0; i < n; i++) {
                points.push({
                    x: Math.random() * width,
                    y: Math.random() * height
                });
            }
            relaxIterations = 0;
            updateAll();
        }

        function clearPoints() {
            points = [];
            relaxIterations = 0;
            autoRelaxing = false;
            updateAll();
        }

        // Toggles
        function toggleCellColors() {
            showCellColors = !showCellColors;
            document.getElementById('colorToggle').classList.toggle('active');
            updateAll();
        }

        function toggleShowPoints() {
            showPoints = !showPoints;
            document.getElementById('pointsToggle').classList.toggle('active');
            updateAll();
        }

        function toggleTriangleFill() {
            showTriangleFill = !showTriangleFill;
            document.getElementById('triangleToggle').classList.toggle('active');
            updateAll();
        }

        function toggleVoronoiOverlay() {
            showVoronoi = !showVoronoi;
            document.getElementById('voronoiOverlay').classList.toggle('active');
            updateAll();
        }

        function toggleDelaunayOverlay() {
            showDelaunay = !showDelaunay;
            document.getElementById('delaunayOverlay').classList.toggle('active');
            updateAll();
        }

        function toggleCircumcircles() {
            showCircumcircles = !showCircumcircles;
            document.getElementById('circumcircles').classList.toggle('active');
            updateAll();
        }

        function toggleAutoRelax() {
            autoRelaxing = !autoRelaxing;
            if (autoRelaxing) {
                requestAnimationFrame(autoRelaxLoop);
            }
        }

        function autoRelaxLoop() {
            if (!autoRelaxing) return;

            const speed = parseInt(document.getElementById('relaxSpeed').value);
            for (let i = 0; i < speed; i++) {
                relaxStep();
            }

            requestAnimationFrame(autoRelaxLoop);
        }

        function relaxStep() {
            if (points.length === 0) return;

            const cells = computeVoronoi();
            let maxMovement = 0;

            const newPoints = points.map((p, i) => {
                const cell = cells[i];
                if (!cell || cell.length === 0) return p;

                // Calculate centroid
                let cx = 0, cy = 0;
                cell.forEach(v => {
                    cx += v.x;
                    cy += v.y;
                });
                cx /= cell.length;
                cy /= cell.length;

                // Clamp to canvas
                cx = Math.max(10, Math.min(790, cx));
                cy = Math.max(10, Math.min(590, cy));

                const movement = Math.sqrt((cx - p.x) ** 2 + (cy - p.y) ** 2);
                maxMovement = Math.max(maxMovement, movement);

                return { x: cx, y: cy };
            });

            points = newPoints;
            relaxIterations++;

            document.getElementById('iterations').textContent = relaxIterations;
            document.getElementById('maxMovement').textContent = maxMovement.toFixed(2);

            updateAll();
        }

        // Bowyer-Watson Delaunay triangulation
        function computeDelaunay() {
            if (points.length < 3) return [];

            // Super triangle
            const superTriangle = [
                { x: -1000, y: -1000 },
                { x: 2000, y: -1000 },
                { x: 400, y: 2000 }
            ];

            let triangles = [superTriangle];

            // Add each point
            points.forEach(point => {
                let badTriangles = [];

                // Find all triangles whose circumcircle contains the point
                triangles.forEach(tri => {
                    if (inCircumcircle(point, tri)) {
                        badTriangles.push(tri);
                    }
                });

                // Find boundary of polygonal hole
                let polygon = [];
                badTriangles.forEach(tri => {
                    for (let i = 0; i < 3; i++) {
                        const edge = [tri[i], tri[(i + 1) % 3]];
                        let isShared = false;

                        badTriangles.forEach(otherTri => {
                            if (tri === otherTri) return;
                            if (hasEdge(otherTri, edge)) {
                                isShared = true;
                            }
                        });

                        if (!isShared) {
                            polygon.push(edge);
                        }
                    }
                });

                // Remove bad triangles
                triangles = triangles.filter(tri => !badTriangles.includes(tri));

                // Add new triangles from point to polygon boundary
                polygon.forEach(edge => {
                    triangles.push([edge[0], edge[1], point]);
                });
            });

            // Remove triangles that share vertices with super triangle
            triangles = triangles.filter(tri => {
                return !tri.some(v => superTriangle.includes(v));
            });

            return triangles;
        }

        function inCircumcircle(point, triangle) {
            const [a, b, c] = triangle;

            const ax = a.x - point.x;
            const ay = a.y - point.y;
            const bx = b.x - point.x;
            const by = b.y - point.y;
            const cx = c.x - point.x;
            const cy = c.y - point.y;

            const det =
                (ax * ax + ay * ay) * (bx * cy - cx * by) -
                (bx * bx + by * by) * (ax * cy - cx * ay) +
                (cx * cx + cy * cy) * (ax * by - bx * ay);

            return det > 0;
        }

        function hasEdge(triangle, edge) {
            for (let i = 0; i < 3; i++) {
                const v1 = triangle[i];
                const v2 = triangle[(i + 1) % 3];
                if ((v1 === edge[0] && v2 === edge[1]) || (v1 === edge[1] && v2 === edge[0])) {
                    return true;
                }
            }
            return false;
        }

        function circumcenter(triangle) {
            const [a, b, c] = triangle;

            const ax = a.x, ay = a.y;
            const bx = b.x, by = b.y;
            const cx = c.x, cy = c.y;

            const d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));

            const ux = ((ax * ax + ay * ay) * (by - cy) + (bx * bx + by * by) * (cy - ay) + (cx * cx + cy * cy) * (ay - by)) / d;
            const uy = ((ax * ax + ay * ay) * (cx - bx) + (bx * bx + by * by) * (ax - cx) + (cx * cx + cy * cy) * (bx - ax)) / d;

            return { x: ux, y: uy };
        }

        // Compute Voronoi from Delaunay
        function computeVoronoi() {
            if (points.length < 3) return [];

            const triangles = computeDelaunay();
            const cells = points.map(() => []);

            triangles.forEach(tri => {
                const center = circumcenter(tri);

                tri.forEach(vertex => {
                    const index = points.indexOf(vertex);
                    if (index >= 0) {
                        cells[index].push(center);
                    }
                });
            });

            // Sort vertices counter-clockwise
            cells.forEach((cell, i) => {
                if (cell.length < 3) return;

                const centroid = {
                    x: cell.reduce((sum, v) => sum + v.x, 0) / cell.length,
                    y: cell.reduce((sum, v) => sum + v.y, 0) / cell.length
                };

                cell.sort((a, b) => {
                    const angleA = Math.atan2(a.y - centroid.y, a.x - centroid.x);
                    const angleB = Math.atan2(b.y - centroid.y, b.x - centroid.x);
                    return angleA - angleB;
                });
            });

            return cells;
        }

        // Drawing functions
        function drawVoronoi(ctx) {
            ctx.clearRect(0, 0, 800, 600);

            if (points.length === 0) return;

            const cells = computeVoronoi();

            // Draw cells
            cells.forEach((cell, i) => {
                if (cell.length < 3) return;

                ctx.beginPath();
                ctx.moveTo(cell[0].x, cell[0].y);
                cell.forEach(v => ctx.lineTo(v.x, v.y));
                ctx.closePath();

                if (showCellColors) {
                    const hue = (i * 137.508) % 360; // Golden angle
                    ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.3)`;
                    ctx.fill();
                }

                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Draw points
            if (showPoints) {
                points.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fill();
                });
            }

            updateStats();
        }

        function drawDelaunay(ctx) {
            ctx.clearRect(0, 0, 800, 600);

            if (points.length < 3) return;

            const triangles = computeDelaunay();

            // Draw triangles
            triangles.forEach((tri, i) => {
                ctx.beginPath();
                ctx.moveTo(tri[0].x, tri[0].y);
                ctx.lineTo(tri[1].x, tri[1].y);
                ctx.lineTo(tri[2].x, tri[2].y);
                ctx.closePath();

                if (showTriangleFill) {
                    const hue = (i * 137.508) % 360;
                    ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.2)`;
                    ctx.fill();
                }

                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Draw points
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#fbbf24';
                ctx.fill();
            });

            updateDelaunayStats(triangles);
        }

        function drawLloyd(ctx) {
            ctx.clearRect(0, 0, 800, 600);

            if (points.length === 0) return;

            const cells = computeVoronoi();

            // Draw cells
            cells.forEach((cell, i) => {
                if (cell.length < 3) return;

                ctx.beginPath();
                ctx.moveTo(cell[0].x, cell[0].y);
                cell.forEach(v => ctx.lineTo(v.x, v.y));
                ctx.closePath();

                const hue = (i * 137.508) % 360;
                ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.3)`;
                ctx.fill();

                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            // Draw points
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#fbbf24';
                ctx.fill();
            });

            // Calculate uniformity
            if (cells.length > 0) {
                const areas = cells.map(cell => {
                    if (cell.length < 3) return 0;
                    let area = 0;
                    for (let i = 0; i < cell.length; i++) {
                        const j = (i + 1) % cell.length;
                        area += cell[i].x * cell[j].y - cell[j].x * cell[i].y;
                    }
                    return Math.abs(area / 2);
                });

                const avgArea = areas.reduce((a, b) => a + b, 0) / areas.length;
                const variance = areas.reduce((sum, a) => sum + (a - avgArea) ** 2, 0) / areas.length;
                const uniformity = avgArea > 0 ? 1 / (1 + Math.sqrt(variance) / avgArea) : 0;

                document.getElementById('uniformity').textContent = uniformity.toFixed(2);
            }
        }

        function drawDual(ctx) {
            ctx.clearRect(0, 0, 800, 600);

            if (points.length < 3) return;

            const triangles = computeDelaunay();
            const cells = computeVoronoi();

            // Draw Voronoi
            if (showVoronoi) {
                cells.forEach(cell => {
                    if (cell.length < 3) return;

                    ctx.beginPath();
                    ctx.moveTo(cell[0].x, cell[0].y);
                    cell.forEach(v => ctx.lineTo(v.x, v.y));
                    ctx.closePath();

                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            }

            // Draw Delaunay
            if (showDelaunay) {
                triangles.forEach(tri => {
                    ctx.beginPath();
                    ctx.moveTo(tri[0].x, tri[0].y);
                    ctx.lineTo(tri[1].x, tri[1].y);
                    ctx.lineTo(tri[2].x, tri[2].y);
                    ctx.closePath();

                    ctx.strokeStyle = '#fbbf24';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });
            }

            // Draw circumcircles
            if (showCircumcircles) {
                triangles.forEach(tri => {
                    const center = circumcenter(tri);
                    const radius = Math.sqrt((tri[0].x - center.x) ** 2 + (tri[0].y - center.y) ** 2);

                    ctx.beginPath();
                    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(225, 29, 72, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });
            }

            // Draw points
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#fbbf24';
                ctx.fill();
            });

            updateDualStats(cells, triangles);
        }

        function updateStats() {
            const cells = computeVoronoi();

            document.getElementById('pointCount').textContent = points.length;
            document.getElementById('cellCount').textContent = cells.filter(c => c.length >= 3).length;

            if (cells.length > 0) {
                const areas = cells.map(cell => {
                    if (cell.length < 3) return 0;
                    let area = 0;
                    for (let i = 0; i < cell.length; i++) {
                        const j = (i + 1) % cell.length;
                        area += cell[i].x * cell[j].y - cell[j].x * cell[i].y;
                    }
                    return Math.abs(area / 2);
                });

                const avgArea = areas.reduce((a, b) => a + b, 0) / areas.length;
                document.getElementById('avgArea').textContent = avgArea.toFixed(0);
            }
        }

        function updateDelaunayStats(triangles) {
            document.getElementById('triCount').textContent = triangles.length;

            const edges = new Set();
            triangles.forEach(tri => {
                for (let i = 0; i < 3; i++) {
                    const v1 = tri[i];
                    const v2 = tri[(i + 1) % 3];
                    const key = v1.x < v2.x ? `${v1.x},${v1.y}-${v2.x},${v2.y}` : `${v2.x},${v2.y}-${v1.x},${v1.y}`;
                    edges.add(key);
                }
            });
            document.getElementById('edgeCount').textContent = edges.size;

            // Calculate average angle
            let totalAngle = 0;
            let angleCount = 0;
            triangles.forEach(tri => {
                for (let i = 0; i < 3; i++) {
                    const a = tri[i];
                    const b = tri[(i + 1) % 3];
                    const c = tri[(i + 2) % 3];

                    const v1 = { x: b.x - a.x, y: b.y - a.y };
                    const v2 = { x: c.x - a.x, y: c.y - a.y };

                    const dot = v1.x * v2.x + v1.y * v2.y;
                    const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
                    const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);

                    const angle = Math.acos(dot / (mag1 * mag2)) * 180 / Math.PI;
                    totalAngle += angle;
                    angleCount++;
                }
            });

            document.getElementById('avgAngle').textContent = angleCount > 0 ?
                (totalAngle / angleCount).toFixed(1) + '°' : '60.0°';
        }

        function updateDualStats(cells, triangles) {
            document.getElementById('dualPoints').textContent = points.length;

            const voronoiEdges = new Set();
            cells.forEach(cell => {
                for (let i = 0; i < cell.length; i++) {
                    const v1 = cell[i];
                    const v2 = cell[(i + 1) % cell.length];
                    const key = v1.x < v2.x ? `${v1.x},${v1.y}-${v2.x},${v2.y}` : `${v2.x},${v2.y}-${v1.x},${v1.y}`;
                    voronoiEdges.add(key);
                }
            });
            document.getElementById('voronoiEdges').textContent = voronoiEdges.size;

            const delaunayEdges = new Set();
            triangles.forEach(tri => {
                for (let i = 0; i < 3; i++) {
                    const v1 = tri[i];
                    const v2 = tri[(i + 1) % 3];
                    const key = v1.x < v2.x ? `${v1.x},${v1.y}-${v2.x},${v2.y}` : `${v2.x},${v2.y}-${v1.x},${v1.y}`;
                    delaunayEdges.add(key);
                }
            });
            document.getElementById('delaunayEdges').textContent = delaunayEdges.size;
        }

        function updateAll() {
            drawVoronoi(ctxs.voronoi);
            drawDelaunay(ctxs.delaunay);
            drawLloyd(ctxs.lloyd);
            drawDual(ctxs.dual);
        }

        // Initial draw
        updateAll();
    </script>
    <script src="../assets/js/navigation.js"></script>
</body>
</html>
