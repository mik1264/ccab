<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Borsuk-Ulam Antipodes Game - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e8e6e1;
            min-height: 100vh;
            overflow: hidden;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            color: #fbbf24;
            text-decoration: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 500;
            z-index: 1000;
            transition: all 0.3s ease;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .back-link:hover {
            background: rgba(251, 191, 36, 0.2);
            transform: translateX(-5px);
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .controls {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            z-index: 1000;
            max-width: 320px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls h2 {
            font-size: 16px;
            color: #fbbf24;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 5px;
        }

        .control-group select,
        .control-group input[type="range"] {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-size: 13px;
        }

        .control-group select option {
            background: #1a1a2e;
        }

        .control-group input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            padding: 0;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #fbbf24;
            border-radius: 50%;
            cursor: pointer;
        }

        button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            border: none;
            border-radius: 8px;
            color: #1a1a2e;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(251, 191, 36, 0.4);
        }

        .info-panel {
            position: fixed;
            bottom: 15px;
            left: 15px;
            right: 15px;
            max-width: 600px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-panel h3 {
            color: #fbbf24;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .info-panel p {
            font-size: 12px;
            color: #ccc;
            line-height: 1.6;
        }

        .result-box {
            margin-top: 15px;
            padding: 12px;
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid rgba(16, 185, 129, 0.5);
            border-radius: 8px;
        }

        .result-box.searching {
            background: rgba(251, 191, 36, 0.2);
            border-color: rgba(251, 191, 36, 0.5);
        }

        .result-box h4 {
            font-size: 13px;
            color: #10b981;
            margin-bottom: 5px;
        }

        .result-box.searching h4 {
            color: #fbbf24;
        }

        .result-box .values {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #fff;
        }

        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: #aaa;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        @media (max-width: 768px) {
            .controls {
                max-width: 260px;
                padding: 15px;
            }

            .info-panel {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div class="controls">
        <h2>Borsuk-Ulam Explorer</h2>

        <div class="control-group">
            <label>Function Type</label>
            <select id="functionType">
                <option value="temperature">Temperature & Pressure</option>
                <option value="height">Height & Wind</option>
                <option value="custom">Custom Wave Pattern</option>
                <option value="gradient">Gradient Field</option>
            </select>
        </div>

        <div class="control-group">
            <label>Complexity: <span id="complexityVal">3</span></label>
            <input type="range" id="complexity" min="1" max="8" value="3">
        </div>

        <div class="control-group">
            <label>Animation Speed: <span id="speedVal">1.0</span>x</label>
            <input type="range" id="speed" min="0" max="20" value="10">
        </div>

        <button id="findAntipodes">Find Antipodal Match</button>
        <button id="reset" style="background: rgba(255,255,255,0.1); color: #fff;">Reset View</button>
    </div>

    <div class="info-panel">
        <h3>Borsuk-Ulam Theorem</h3>
        <p>
            For any continuous function f: S² → R², there exist antipodal points
            (points on opposite sides of a sphere) that map to the same value.
            <br><br>
            <strong>In practice:</strong> At any moment, there are two opposite points on Earth
            with identical temperature AND pressure!
        </p>

        <div id="resultBox" class="result-box searching">
            <h4>Searching for Antipodal Match...</h4>
            <div class="values" id="resultValues">
                Rotate sphere or click "Find Antipodal Match"
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-dot" style="background: #fbbf24;"></div>
                Point A
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #f472b6;"></div>
                Antipode B (-A)
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #10b981;"></div>
                Match Found
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // State
        let width, height;
        let dpr = window.devicePixelRatio || 1;
        let time = 0;
        let rotationX = 0.3;
        let rotationY = 0;
        let isDragging = false;
        let lastMouse = { x: 0, y: 0 };
        let autoRotate = true;
        let animSpeed = 1.0;
        let complexity = 3;
        let functionType = 'temperature';

        // Antipodal search state
        let searchPoint = null;
        let antipodePoint = null;
        let matchFound = false;
        let searchTheta = 0;
        let searchPhi = 0;
        let minDifference = Infinity;
        let bestMatch = null;

        // Resize handler
        function resize() {
            const rect = canvas.getBoundingClientRect();
            width = rect.width;
            height = rect.height;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
        }

        window.addEventListener('resize', resize);
        resize();

        // Continuous function on sphere mapping to R²
        function sphereFunction(theta, phi, t) {
            const x = Math.sin(phi) * Math.cos(theta);
            const y = Math.sin(phi) * Math.sin(theta);
            const z = Math.cos(phi);

            let val1, val2;

            switch (functionType) {
                case 'temperature':
                    // Temperature-like: varies with latitude and has wave pattern
                    val1 = Math.cos(phi) * 50 +
                           Math.sin(complexity * theta + t) * 20 * Math.sin(phi) +
                           Math.cos(complexity * phi + t * 0.7) * 15;
                    // Pressure-like: different wave pattern
                    val2 = Math.sin(phi * 2) * 40 +
                           Math.cos(complexity * theta - t * 0.5) * 25 * Math.cos(phi) +
                           Math.sin((complexity + 1) * phi) * 10;
                    break;

                case 'height':
                    // Height-like terrain
                    val1 = Math.sin(complexity * theta) * Math.cos(complexity * phi) * 50 +
                           Math.cos(2 * theta + t) * Math.sin(phi) * 30;
                    // Wind-like
                    val2 = Math.cos(complexity * theta - phi) * 40 +
                           Math.sin(theta * 3 + t * 1.5) * 20;
                    break;

                case 'custom':
                    // Custom wave interference
                    val1 = Math.sin(complexity * (x + y) + t) * 50 +
                           Math.cos(complexity * (y + z) - t * 0.8) * 30;
                    val2 = Math.cos(complexity * (x + z) + t * 0.5) * 40 +
                           Math.sin(complexity * (x - y + z)) * 25;
                    break;

                case 'gradient':
                    // Smooth gradient field
                    val1 = x * 50 + y * 30 + Math.sin(t) * z * 20;
                    val2 = y * 40 - z * 35 + Math.cos(t * 0.7) * x * 25;
                    break;
            }

            return { val1, val2 };
        }

        // Convert spherical to 3D coordinates
        function sphericalTo3D(theta, phi, radius) {
            return {
                x: radius * Math.sin(phi) * Math.cos(theta),
                y: radius * Math.sin(phi) * Math.sin(theta),
                z: radius * Math.cos(phi)
            };
        }

        // Rotate point
        function rotatePoint(p, rx, ry) {
            // Rotate around Y axis
            let x = p.x * Math.cos(ry) - p.z * Math.sin(ry);
            let z = p.x * Math.sin(ry) + p.z * Math.cos(ry);
            let y = p.y;

            // Rotate around X axis
            let y2 = y * Math.cos(rx) - z * Math.sin(rx);
            let z2 = y * Math.sin(rx) + z * Math.cos(rx);

            return { x, y: y2, z: z2 };
        }

        // Project 3D to 2D
        function project(p, centerX, centerY, scale) {
            const perspective = 800;
            const factor = perspective / (perspective + p.z);
            return {
                x: centerX + p.x * scale * factor,
                y: centerY + p.y * scale * factor,
                scale: factor,
                z: p.z
            };
        }

        // Value to color
        function valueToColor(val1, val2) {
            // Normalize values to 0-1 range
            const n1 = (val1 + 100) / 200;
            const n2 = (val2 + 100) / 200;

            const r = Math.floor(n1 * 255);
            const g = Math.floor(Math.abs(n1 - n2) * 255);
            const b = Math.floor(n2 * 255);

            return `rgb(${Math.min(255, r)}, ${Math.min(255, g)}, ${Math.min(255, b)})`;
        }

        // Draw sphere
        function drawSphere(centerX, centerY, radius) {
            const resolution = 30;
            const points = [];

            // Generate points on sphere
            for (let i = 0; i <= resolution; i++) {
                for (let j = 0; j <= resolution * 2; j++) {
                    const phi = (i / resolution) * Math.PI;
                    const theta = (j / (resolution * 2)) * Math.PI * 2;

                    const p3d = sphericalTo3D(theta, phi, radius);
                    const rotated = rotatePoint(p3d, rotationX, rotationY);
                    const projected = project(rotated, centerX, centerY, 1);

                    const values = sphereFunction(theta, phi, time);

                    points.push({
                        x: projected.x,
                        y: projected.y,
                        z: projected.z,
                        scale: projected.scale,
                        theta,
                        phi,
                        values,
                        color: valueToColor(values.val1, values.val2)
                    });
                }
            }

            // Sort by z-depth
            points.sort((a, b) => a.z - b.z);

            // Draw points
            for (const p of points) {
                if (p.z > -radius * 0.3) { // Only draw front-facing points
                    const size = 3 * p.scale;
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = 0.7 + p.scale * 0.3;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;

            // Draw wireframe
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 0.5;

            // Latitude lines
            for (let i = 1; i < 6; i++) {
                const phi = (i / 6) * Math.PI;
                ctx.beginPath();
                for (let j = 0; j <= 60; j++) {
                    const theta = (j / 60) * Math.PI * 2;
                    const p3d = sphericalTo3D(theta, phi, radius);
                    const rotated = rotatePoint(p3d, rotationX, rotationY);
                    const projected = project(rotated, centerX, centerY, 1);

                    if (j === 0) {
                        ctx.moveTo(projected.x, projected.y);
                    } else {
                        ctx.lineTo(projected.x, projected.y);
                    }
                }
                ctx.stroke();
            }

            // Longitude lines
            for (let j = 0; j < 12; j++) {
                const theta = (j / 12) * Math.PI * 2;
                ctx.beginPath();
                for (let i = 0; i <= 30; i++) {
                    const phi = (i / 30) * Math.PI;
                    const p3d = sphericalTo3D(theta, phi, radius);
                    const rotated = rotatePoint(p3d, rotationX, rotationY);
                    const projected = project(rotated, centerX, centerY, 1);

                    if (i === 0) {
                        ctx.moveTo(projected.x, projected.y);
                    } else {
                        ctx.lineTo(projected.x, projected.y);
                    }
                }
                ctx.stroke();
            }
        }

        // Draw antipodal points
        function drawAntipodalPoints(centerX, centerY, radius) {
            if (!searchPoint) return;

            const p1_3d = sphericalTo3D(searchPoint.theta, searchPoint.phi, radius * 1.02);
            const p1_rotated = rotatePoint(p1_3d, rotationX, rotationY);
            const p1_projected = project(p1_rotated, centerX, centerY, 1);

            // Antipode is at (theta + PI, PI - phi)
            const antiTheta = searchPoint.theta + Math.PI;
            const antiPhi = Math.PI - searchPoint.phi;

            const p2_3d = sphericalTo3D(antiTheta, antiPhi, radius * 1.02);
            const p2_rotated = rotatePoint(p2_3d, rotationX, rotationY);
            const p2_projected = project(p2_rotated, centerX, centerY, 1);

            // Get function values
            const val1 = sphereFunction(searchPoint.theta, searchPoint.phi, time);
            const val2 = sphereFunction(antiTheta, antiPhi, time);

            const difference = Math.sqrt(
                Math.pow(val1.val1 - val2.val1, 2) +
                Math.pow(val1.val2 - val2.val2, 2)
            );

            // Check if this is a match
            const isMatch = difference < 5;

            // Draw point A
            ctx.fillStyle = isMatch ? '#10b981' : '#fbbf24';
            ctx.shadowColor = isMatch ? '#10b981' : '#fbbf24';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(p1_projected.x, p1_projected.y, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Label A
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText('A', p1_projected.x + 15, p1_projected.y + 5);

            // Draw point B (antipode)
            ctx.fillStyle = isMatch ? '#10b981' : '#f472b6';
            ctx.shadowColor = isMatch ? '#10b981' : '#f472b6';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(p2_projected.x, p2_projected.y, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Label B
            ctx.fillStyle = '#fff';
            ctx.fillText('B', p2_projected.x + 15, p2_projected.y + 5);

            // Draw connecting line through center
            ctx.strokeStyle = isMatch ? 'rgba(16, 185, 129, 0.4)' : 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(p1_projected.x, p1_projected.y);
            ctx.lineTo(p2_projected.x, p2_projected.y);
            ctx.stroke();
            ctx.setLineDash([]);

            // Update result display
            updateResultDisplay(val1, val2, difference, isMatch);

            return { val1, val2, difference, isMatch };
        }

        // Update result display
        function updateResultDisplay(val1, val2, difference, isMatch) {
            const resultBox = document.getElementById('resultBox');
            const resultValues = document.getElementById('resultValues');

            if (isMatch) {
                resultBox.className = 'result-box';
                resultBox.querySelector('h4').textContent = 'Antipodal Match Found!';
                matchFound = true;
            } else {
                resultBox.className = 'result-box searching';
                resultBox.querySelector('h4').textContent = 'Searching for Antipodal Match...';
            }

            resultValues.innerHTML = `
                Point A: (${val1.val1.toFixed(2)}, ${val1.val2.toFixed(2)})<br>
                Point B: (${val2.val1.toFixed(2)}, ${val2.val2.toFixed(2)})<br>
                Difference: ${difference.toFixed(3)}
            `;
        }

        // Find antipodal match using search algorithm
        function findAntipodalMatch() {
            let bestDiff = Infinity;
            let bestTheta = 0;
            let bestPhi = Math.PI / 2;

            // Grid search
            const resolution = 50;
            for (let i = 1; i < resolution; i++) {
                for (let j = 0; j < resolution * 2; j++) {
                    const phi = (i / resolution) * Math.PI;
                    const theta = (j / (resolution * 2)) * Math.PI * 2;

                    const antiTheta = theta + Math.PI;
                    const antiPhi = Math.PI - phi;

                    const val1 = sphereFunction(theta, phi, time);
                    const val2 = sphereFunction(antiTheta, antiPhi, time);

                    const diff = Math.sqrt(
                        Math.pow(val1.val1 - val2.val1, 2) +
                        Math.pow(val1.val2 - val2.val2, 2)
                    );

                    if (diff < bestDiff) {
                        bestDiff = diff;
                        bestTheta = theta;
                        bestPhi = phi;
                    }
                }
            }

            // Gradient descent refinement
            let theta = bestTheta;
            let phi = bestPhi;
            const step = 0.01;

            for (let iter = 0; iter < 100; iter++) {
                const current = computeDiff(theta, phi);
                const dTheta = (computeDiff(theta + step, phi) - current) / step;
                const dPhi = (computeDiff(theta, phi + step) - current) / step;

                theta -= dTheta * 0.5;
                phi -= dPhi * 0.5;

                // Clamp phi
                phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));
            }

            searchPoint = { theta, phi };

            // Rotate sphere to show the match
            const p3d = sphericalTo3D(theta, phi, 1);
            rotationY = -Math.atan2(p3d.x, p3d.z);
            rotationX = Math.asin(p3d.y) * 0.5;
            autoRotate = false;
        }

        function computeDiff(theta, phi) {
            const antiTheta = theta + Math.PI;
            const antiPhi = Math.PI - phi;

            const val1 = sphereFunction(theta, phi, time);
            const val2 = sphereFunction(antiTheta, antiPhi, time);

            return Math.sqrt(
                Math.pow(val1.val1 - val2.val1, 2) +
                Math.pow(val1.val2 - val2.val2, 2)
            );
        }

        // Draw mini function space visualization
        function drawFunctionSpace(x, y, w, h) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(x, y, w, h);

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.strokeRect(x, y, w, h);

            // Draw axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.moveTo(x + w/2, y);
            ctx.lineTo(x + w/2, y + h);
            ctx.moveTo(x, y + h/2);
            ctx.lineTo(x + w, y + h/2);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#aaa';
            ctx.font = '10px sans-serif';
            ctx.fillText('val1', x + w - 25, y + h/2 - 5);
            ctx.fillText('val2', x + w/2 + 5, y + 12);

            // If we have search points, plot them
            if (searchPoint) {
                const val1 = sphereFunction(searchPoint.theta, searchPoint.phi, time);
                const antiTheta = searchPoint.theta + Math.PI;
                const antiPhi = Math.PI - searchPoint.phi;
                const val2 = sphereFunction(antiTheta, antiPhi, time);

                // Scale to fit in box
                const scale = w / 200;

                const px1 = x + w/2 + val1.val1 * scale;
                const py1 = y + h/2 - val1.val2 * scale;

                const px2 = x + w/2 + val2.val1 * scale;
                const py2 = y + h/2 - val2.val2 * scale;

                // Point A
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                ctx.arc(px1, py1, 5, 0, Math.PI * 2);
                ctx.fill();

                // Point B
                ctx.fillStyle = '#f472b6';
                ctx.beginPath();
                ctx.arc(px2, py2, 5, 0, Math.PI * 2);
                ctx.fill();

                // Line between them
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.moveTo(px1, py1);
                ctx.lineTo(px2, py2);
                ctx.stroke();
            }
        }

        // Main render loop
        function render() {
            ctx.fillStyle = '#0f0f1a';
            ctx.fillRect(0, 0, width, height);

            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.3;

            // Auto-rotate
            if (autoRotate) {
                rotationY += 0.005 * animSpeed;
            }

            // Update time
            time += 0.02 * animSpeed;

            // Draw sphere
            drawSphere(centerX, centerY, radius);

            // Draw antipodal points if active
            if (searchPoint) {
                drawAntipodalPoints(centerX, centerY, radius);
            }

            // Draw function space visualization
            drawFunctionSpace(width - 170, height - 280, 150, 150);

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 18px sans-serif';
            ctx.fillText('R² Space', width - 115, height - 295);

            requestAnimationFrame(render);
        }

        // Mouse/touch interaction
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouse = { x: e.clientX, y: e.clientY };
            autoRotate = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const dx = e.clientX - lastMouse.x;
            const dy = e.clientY - lastMouse.y;

            rotationY += dx * 0.005;
            rotationX += dy * 0.005;
            rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotationX));

            lastMouse = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDragging = true;
            lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            autoRotate = false;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isDragging) return;

            const dx = e.touches[0].clientX - lastMouse.x;
            const dy = e.touches[0].clientY - lastMouse.y;

            rotationY += dx * 0.005;
            rotationX += dy * 0.005;
            rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotationX));

            lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
        });

        // Click to place search point
        canvas.addEventListener('dblclick', (e) => {
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.3;

            // Convert click to spherical coordinates (approximate)
            const dx = (e.clientX - centerX) / radius;
            const dy = (e.clientY - centerY) / radius;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist <= 1) {
                // Point is on visible hemisphere
                const theta = Math.atan2(dx, Math.sqrt(1 - dist * dist)) + rotationY;
                const phi = Math.acos(-dy / Math.max(dist, 0.01));

                searchPoint = { theta, phi };
            }
        });

        // Controls
        document.getElementById('findAntipodes').addEventListener('click', findAntipodalMatch);

        document.getElementById('reset').addEventListener('click', () => {
            rotationX = 0.3;
            rotationY = 0;
            autoRotate = true;
            searchPoint = null;
            matchFound = false;

            const resultBox = document.getElementById('resultBox');
            resultBox.className = 'result-box searching';
            resultBox.querySelector('h4').textContent = 'Searching for Antipodal Match...';
            document.getElementById('resultValues').textContent = 'Rotate sphere or click "Find Antipodal Match"';
        });

        document.getElementById('functionType').addEventListener('change', (e) => {
            functionType = e.target.value;
            if (searchPoint) {
                // Re-search with new function
                findAntipodalMatch();
            }
        });

        document.getElementById('complexity').addEventListener('input', (e) => {
            complexity = parseInt(e.target.value);
            document.getElementById('complexityVal').textContent = complexity;
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            animSpeed = e.target.value / 10;
            document.getElementById('speedVal').textContent = animSpeed.toFixed(1);
        });

        // Initialize with a search point
        searchPoint = { theta: Math.PI / 3, phi: Math.PI / 2 };

        // Start
        render();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
