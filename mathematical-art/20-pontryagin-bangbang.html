<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pontryagin Bang-Bang Control - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            color: var(--cream);
            min-height: 100vh;
            overflow: hidden;
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: rgba(138, 154, 91, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(138, 154, 91, 0.3);
            border-radius: 25px;
            color: var(--sage);
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .organic-back-link:hover {
            background: rgba(138, 154, 91, 0.3);
            transform: translateX(-3px);
        }

        .container {
            display: flex;
            height: 100vh;
            padding: 20px;
            gap: 20px;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .canvas-row {
            display: flex;
            flex: 1;
            gap: 10px;
        }

        .canvas-wrapper {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 15px;
            display: flex;
            flex-direction: column;
        }

        .canvas-title {
            font-family: 'Lora', serif;
            font-size: 0.9rem;
            color: var(--earth);
            margin-bottom: 10px;
            text-align: center;
        }

        canvas {
            flex: 1;
            width: 100%;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
        }

        .controls {
            width: 320px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px;
            overflow-y: auto;
        }

        h1 {
            font-family: 'Lora', serif;
            font-size: 1.5rem;
            color: var(--earth);
            margin-bottom: 8px;
        }

        .subtitle {
            font-size: 0.85rem;
            color: var(--sage);
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            font-size: 0.85rem;
            color: var(--sage);
            margin-bottom: 6px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(138, 154, 91, 0.3);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--earth);
            cursor: pointer;
        }

        .value-display {
            font-size: 0.8rem;
            color: var(--cream);
            margin-top: 4px;
        }

        .button-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            flex: 1;
            padding: 10px 16px;
            background: linear-gradient(135deg, var(--sage), var(--moss));
            border: none;
            border-radius: 8px;
            color: white;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(138, 154, 91, 0.4);
        }

        button.secondary {
            background: rgba(138, 154, 91, 0.2);
            border: 1px solid var(--sage);
        }

        .info-box {
            background: rgba(138, 154, 91, 0.1);
            border: 1px solid rgba(138, 154, 91, 0.3);
            border-radius: 10px;
            padding: 12px;
            margin-top: 15px;
        }

        .info-box h3 {
            font-family: 'Lora', serif;
            font-size: 0.9rem;
            color: var(--earth);
            margin-bottom: 8px;
        }

        .info-box p {
            font-size: 0.8rem;
            line-height: 1.5;
            color: var(--cream);
            opacity: 0.9;
        }

        .state-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .state-item {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .state-label {
            font-size: 0.75rem;
            color: var(--sage);
            margin-bottom: 4px;
        }

        .state-value {
            font-family: 'Lora', serif;
            font-size: 1.2rem;
            color: var(--earth);
        }

        .legend {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(138, 154, 91, 0.2);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 0.8rem;
        }

        .legend-color {
            width: 20px;
            height: 4px;
            border-radius: 2px;
        }

        @media (max-width: 900px) {
            .container {
                flex-direction: column;
            }
            .controls {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link">
        <span>←</span>
        <span>Gallery</span>
    </a>

    <div class="container">
        <div class="canvas-container">
            <div class="canvas-row">
                <div class="canvas-wrapper">
                    <div class="canvas-title">Phase Portrait (Position vs Velocity)</div>
                    <canvas id="phaseCanvas"></canvas>
                </div>
                <div class="canvas-wrapper">
                    <div class="canvas-title">Switching Surface & Optimal Trajectories</div>
                    <canvas id="switchCanvas"></canvas>
                </div>
            </div>
            <div class="canvas-row">
                <div class="canvas-wrapper">
                    <div class="canvas-title">Time History: Position & Velocity</div>
                    <canvas id="timeCanvas"></canvas>
                </div>
                <div class="canvas-wrapper">
                    <div class="canvas-title">Control Signal (Bang-Bang)</div>
                    <canvas id="controlCanvas"></canvas>
                </div>
            </div>
        </div>

        <div class="controls">
            <h1>Pontryagin Bang-Bang</h1>
            <p class="subtitle">Minimal-time control for a double integrator with saturated control ±u_max</p>

            <div class="state-display">
                <div class="state-item">
                    <div class="state-label">Position x</div>
                    <div class="state-value" id="posValue">0.00</div>
                </div>
                <div class="state-item">
                    <div class="state-label">Velocity v</div>
                    <div class="state-value" id="velValue">0.00</div>
                </div>
                <div class="state-item">
                    <div class="state-label">Control u</div>
                    <div class="state-value" id="ctrlValue">0</div>
                </div>
                <div class="state-item">
                    <div class="state-label">Time t</div>
                    <div class="state-value" id="timeValue">0.00</div>
                </div>
            </div>

            <div class="control-group">
                <label>Initial Position: x₀</label>
                <input type="range" id="x0Slider" min="-5" max="5" step="0.1" value="3">
                <div class="value-display" id="x0Display">3.0</div>
            </div>

            <div class="control-group">
                <label>Initial Velocity: v₀</label>
                <input type="range" id="v0Slider" min="-4" max="4" step="0.1" value="1">
                <div class="value-display" id="v0Display">1.0</div>
            </div>

            <div class="control-group">
                <label>Max Control: u_max</label>
                <input type="range" id="umaxSlider" min="0.5" max="3" step="0.1" value="1">
                <div class="value-display" id="umaxDisplay">1.0</div>
            </div>

            <div class="control-group">
                <label>Simulation Speed</label>
                <input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1">
                <div class="value-display" id="speedDisplay">1.0×</div>
            </div>

            <div class="button-row">
                <button id="startBtn">Start</button>
                <button id="resetBtn" class="secondary">Reset</button>
            </div>

            <div class="button-row">
                <button id="trajectoryBtn" class="secondary">Show All Trajectories</button>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>Trajectory</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF5722;"></div>
                    <span>u = +u_max (accelerate)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #2196F3;"></div>
                    <span>u = -u_max (brake)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFC107;"></div>
                    <span>Switching curve</span>
                </div>
            </div>

            <div class="info-box">
                <h3>The Double Integrator</h3>
                <p>
                    The system ẍ = u models a point mass with unit mass. The goal is to bring
                    the system from (x₀, v₀) to the origin (0, 0) in minimal time using bounded
                    control |u| ≤ u_max.
                </p>
            </div>

            <div class="info-box">
                <h3>Pontryagin's Principle</h3>
                <p>
                    The optimal control switches at most once between +u_max and -u_max.
                    The switching curve consists of two parabolas: the system follows one
                    parabola until reaching the switching curve, then follows the other to the origin.
                </p>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const phaseCanvas = document.getElementById('phaseCanvas');
        const switchCanvas = document.getElementById('switchCanvas');
        const timeCanvas = document.getElementById('timeCanvas');
        const controlCanvas = document.getElementById('controlCanvas');

        const phaseCtx = phaseCanvas.getContext('2d');
        const switchCtx = switchCanvas.getContext('2d');
        const timeCtx = timeCanvas.getContext('2d');
        const controlCtx = controlCanvas.getContext('2d');

        // State variables
        let x = 3, v = 1;
        let x0 = 3, v0 = 1;
        let umax = 1;
        let speed = 1;
        let t = 0;
        let running = false;
        let showAllTrajectories = false;

        // History for time plots
        let history = [];
        const maxHistory = 500;

        // Controls
        const x0Slider = document.getElementById('x0Slider');
        const v0Slider = document.getElementById('v0Slider');
        const umaxSlider = document.getElementById('umaxSlider');
        const speedSlider = document.getElementById('speedSlider');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const trajectoryBtn = document.getElementById('trajectoryBtn');

        function resizeCanvases() {
            [phaseCanvas, switchCanvas, timeCanvas, controlCanvas].forEach(canvas => {
                const wrapper = canvas.parentElement;
                const rect = wrapper.getBoundingClientRect();
                canvas.width = rect.width - 30;
                canvas.height = rect.height - 50;
            });
            draw();
        }

        // Optimal control law based on Pontryagin's principle
        function optimalControl(x, v, umax) {
            // Switching curves: v² = 2*umax*|x| (parabolas)
            // For x > 0 and v > 0: need to brake (u = -umax)
            // For x < 0 and v < 0: need to accelerate (u = +umax)
            // Switch when we hit the parabola that goes to origin

            // Switching curve for u = -umax: v² = 2*umax*x (upper parabola, v >= 0)
            // Switching curve for u = +umax: v² = -2*umax*x (lower parabola, v <= 0)

            const eps = 1e-6;

            // Check if on or past the switching curve
            if (v >= 0) {
                // Above x-axis: switching curve is v² = 2*umax*x
                const switchX = v * v / (2 * umax);
                if (x > switchX + eps) {
                    return -umax; // Brake
                } else if (x < switchX - eps) {
                    return umax; // Accelerate
                } else {
                    return -umax; // On curve, follow to origin
                }
            } else {
                // Below x-axis: switching curve is v² = -2*umax*x
                const switchX = -v * v / (2 * umax);
                if (x < switchX - eps) {
                    return umax; // Accelerate
                } else if (x > switchX + eps) {
                    return -umax; // Brake
                } else {
                    return umax; // On curve, follow to origin
                }
            }
        }

        // Transform coordinates for phase plane
        function phaseTransform(canvas, x, v, scale = 40) {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            return {
                x: cx + x * scale,
                y: cy - v * scale
            };
        }

        // Draw phase portrait
        function drawPhasePortrait() {
            const ctx = phaseCtx;
            const w = phaseCanvas.width;
            const h = phaseCanvas.height;
            const scale = Math.min(w, h) / 14;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, w, h);

            // Grid
            ctx.strokeStyle = 'rgba(138, 154, 91, 0.2)';
            ctx.lineWidth = 1;
            for (let i = -6; i <= 6; i++) {
                const p1 = phaseTransform(phaseCanvas, i, -5, scale);
                const p2 = phaseTransform(phaseCanvas, i, 5, scale);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();

                const p3 = phaseTransform(phaseCanvas, -6, i, scale);
                const p4 = phaseTransform(phaseCanvas, 6, i, scale);
                ctx.beginPath();
                ctx.moveTo(p3.x, p3.y);
                ctx.lineTo(p4.x, p4.y);
                ctx.stroke();
            }

            // Axes
            ctx.strokeStyle = 'rgba(254, 250, 224, 0.5)';
            ctx.lineWidth = 2;
            const origin = phaseTransform(phaseCanvas, 0, 0, scale);
            ctx.beginPath();
            ctx.moveTo(0, origin.y);
            ctx.lineTo(w, origin.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(origin.x, 0);
            ctx.lineTo(origin.x, h);
            ctx.stroke();

            // Axis labels
            ctx.fillStyle = 'rgba(254, 250, 224, 0.7)';
            ctx.font = '12px Nunito';
            ctx.fillText('x', w - 20, origin.y - 10);
            ctx.fillText('v', origin.x + 10, 20);

            // Switching curves
            ctx.strokeStyle = '#FFC107';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);

            // Upper parabola: v² = 2*umax*x (v >= 0, x >= 0)
            ctx.beginPath();
            for (let vv = 0; vv <= 5; vv += 0.05) {
                const xx = vv * vv / (2 * umax);
                const p = phaseTransform(phaseCanvas, xx, vv, scale);
                if (vv === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();

            // Lower parabola: v² = -2*umax*x (v <= 0, x <= 0)
            ctx.beginPath();
            for (let vv = 0; vv >= -5; vv -= 0.05) {
                const xx = -vv * vv / (2 * umax);
                const p = phaseTransform(phaseCanvas, xx, vv, scale);
                if (vv === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();

            ctx.setLineDash([]);

            // Draw trajectory history
            if (history.length > 1) {
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < history.length; i++) {
                    const p = phaseTransform(phaseCanvas, history[i].x, history[i].v, scale);
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                }
                ctx.stroke();
            }

            // Current state
            const curr = phaseTransform(phaseCanvas, x, v, scale);
            const u = optimalControl(x, v, umax);
            ctx.fillStyle = u > 0 ? '#FF5722' : '#2196F3';
            ctx.beginPath();
            ctx.arc(curr.x, curr.y, 8, 0, Math.PI * 2);
            ctx.fill();

            // Initial state
            const init = phaseTransform(phaseCanvas, x0, v0, scale);
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(init.x, init.y, 10, 0, Math.PI * 2);
            ctx.stroke();

            // Origin target
            ctx.fillStyle = '#FFC107';
            ctx.beginPath();
            ctx.arc(origin.x, origin.y, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw switching surface with multiple trajectories
        function drawSwitchingSurface() {
            const ctx = switchCtx;
            const w = switchCanvas.width;
            const h = switchCanvas.height;
            const scale = Math.min(w, h) / 14;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, w, h);

            // Grid
            ctx.strokeStyle = 'rgba(138, 154, 91, 0.15)';
            ctx.lineWidth = 1;
            for (let i = -6; i <= 6; i++) {
                const p1 = phaseTransform(switchCanvas, i, -5, scale);
                const p2 = phaseTransform(switchCanvas, i, 5, scale);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }

            // Axes
            ctx.strokeStyle = 'rgba(254, 250, 224, 0.4)';
            ctx.lineWidth = 1;
            const origin = phaseTransform(switchCanvas, 0, 0, scale);
            ctx.beginPath();
            ctx.moveTo(0, origin.y);
            ctx.lineTo(w, origin.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(origin.x, 0);
            ctx.lineTo(origin.x, h);
            ctx.stroke();

            // Draw sample trajectories
            if (showAllTrajectories) {
                const startPoints = [
                    [-4, 2], [-4, -2], [4, 2], [4, -2],
                    [-3, 3], [-3, -3], [3, 3], [3, -3],
                    [-2, 0], [2, 0], [0, 2], [0, -2],
                    [-5, 1], [5, -1], [-1, 4], [1, -4]
                ];

                ctx.lineWidth = 1.5;
                for (const [sx, sv] of startPoints) {
                    let tx = sx, tv = sv;
                    ctx.strokeStyle = 'rgba(76, 175, 80, 0.4)';
                    ctx.beginPath();
                    const startP = phaseTransform(switchCanvas, tx, tv, scale);
                    ctx.moveTo(startP.x, startP.y);

                    for (let step = 0; step < 500; step++) {
                        const u = optimalControl(tx, tv, umax);
                        const dt = 0.02;
                        tx += tv * dt;
                        tv += u * dt;

                        const p = phaseTransform(switchCanvas, tx, tv, scale);
                        ctx.lineTo(p.x, p.y);

                        if (Math.abs(tx) < 0.01 && Math.abs(tv) < 0.01) break;
                        if (Math.abs(tx) > 10 || Math.abs(tv) > 10) break;
                    }
                    ctx.stroke();
                }
            }

            // Switching curves (thicker)
            ctx.strokeStyle = '#FFC107';
            ctx.lineWidth = 3;

            // Upper parabola
            ctx.beginPath();
            for (let vv = 0; vv <= 5; vv += 0.02) {
                const xx = vv * vv / (2 * umax);
                const p = phaseTransform(switchCanvas, xx, vv, scale);
                if (vv === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();

            // Lower parabola
            ctx.beginPath();
            for (let vv = 0; vv >= -5; vv -= 0.02) {
                const xx = -vv * vv / (2 * umax);
                const p = phaseTransform(switchCanvas, xx, vv, scale);
                if (vv === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();

            // Color regions
            ctx.font = '14px Nunito';
            ctx.fillStyle = 'rgba(255, 87, 34, 0.6)';
            ctx.fillText('u = +u_max', w * 0.2, h * 0.7);
            ctx.fillStyle = 'rgba(33, 150, 243, 0.6)';
            ctx.fillText('u = -u_max', w * 0.65, h * 0.3);

            // Origin
            ctx.fillStyle = '#FFC107';
            ctx.beginPath();
            ctx.arc(origin.x, origin.y, 6, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw time history
        function drawTimeHistory() {
            const ctx = timeCtx;
            const w = timeCanvas.width;
            const h = timeCanvas.height;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, w, h);

            // Time axis
            ctx.strokeStyle = 'rgba(254, 250, 224, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(50, h - 30);
            ctx.lineTo(w - 20, h - 30);
            ctx.stroke();

            // Zero line
            const zeroY = h / 2;
            ctx.strokeStyle = 'rgba(254, 250, 224, 0.2)';
            ctx.beginPath();
            ctx.moveTo(50, zeroY);
            ctx.lineTo(w - 20, zeroY);
            ctx.stroke();

            // Labels
            ctx.fillStyle = 'rgba(254, 250, 224, 0.7)';
            ctx.font = '11px Nunito';
            ctx.fillText('time', w - 40, h - 15);
            ctx.fillText('0', 35, zeroY + 4);

            if (history.length < 2) return;

            const plotW = w - 80;
            const plotH = h - 60;
            const maxT = Math.max(history[history.length - 1].t, 5);
            const scaleX = plotW / maxT;
            const scaleY = plotH / 12; // ±6 range

            // Position
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < history.length; i++) {
                const px = 50 + history[i].t * scaleX;
                const py = zeroY - history[i].x * scaleY;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Velocity
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < history.length; i++) {
                const px = 50 + history[i].t * scaleX;
                const py = zeroY - history[i].v * scaleY;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Legend
            ctx.fillStyle = '#4CAF50';
            ctx.fillText('x(t)', 60, 20);
            ctx.fillStyle = '#2196F3';
            ctx.fillText('v(t)', 100, 20);
        }

        // Draw control signal
        function drawControlSignal() {
            const ctx = controlCtx;
            const w = controlCanvas.width;
            const h = controlCanvas.height;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, w, h);

            // Time axis
            ctx.strokeStyle = 'rgba(254, 250, 224, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(50, h - 30);
            ctx.lineTo(w - 20, h - 30);
            ctx.stroke();

            // Zero line
            const zeroY = h / 2;
            ctx.strokeStyle = 'rgba(254, 250, 224, 0.2)';
            ctx.beginPath();
            ctx.moveTo(50, zeroY);
            ctx.lineTo(w - 20, zeroY);
            ctx.stroke();

            // +umax and -umax lines
            const scaleY = (h - 80) / (2 * umax * 1.2);
            const plusY = zeroY - umax * scaleY;
            const minusY = zeroY + umax * scaleY;

            ctx.strokeStyle = 'rgba(255, 87, 34, 0.3)';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(50, plusY);
            ctx.lineTo(w - 20, plusY);
            ctx.stroke();

            ctx.strokeStyle = 'rgba(33, 150, 243, 0.3)';
            ctx.beginPath();
            ctx.moveTo(50, minusY);
            ctx.lineTo(w - 20, minusY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Labels
            ctx.fillStyle = 'rgba(254, 250, 224, 0.7)';
            ctx.font = '11px Nunito';
            ctx.fillText('time', w - 40, h - 15);
            ctx.fillText('+u', 20, plusY + 4);
            ctx.fillText('-u', 20, minusY + 4);
            ctx.fillText('0', 35, zeroY + 4);

            if (history.length < 2) return;

            const plotW = w - 80;
            const maxT = Math.max(history[history.length - 1].t, 5);
            const scaleX = plotW / maxT;

            // Draw control steps
            ctx.lineWidth = 3;
            for (let i = 1; i < history.length; i++) {
                const u = history[i].u;
                ctx.strokeStyle = u > 0 ? '#FF5722' : '#2196F3';

                const px1 = 50 + history[i-1].t * scaleX;
                const px2 = 50 + history[i].t * scaleX;
                const py = zeroY - u * scaleY;

                ctx.beginPath();
                ctx.moveTo(px1, py);
                ctx.lineTo(px2, py);
                ctx.stroke();
            }
        }

        function draw() {
            drawPhasePortrait();
            drawSwitchingSurface();
            drawTimeHistory();
            drawControlSignal();

            // Update displays
            document.getElementById('posValue').textContent = x.toFixed(2);
            document.getElementById('velValue').textContent = v.toFixed(2);
            document.getElementById('ctrlValue').textContent = optimalControl(x, v, umax) > 0 ? '+' + umax.toFixed(1) : '-' + umax.toFixed(1);
            document.getElementById('timeValue').textContent = t.toFixed(2);
        }

        function update(dt) {
            const u = optimalControl(x, v, umax);

            // Euler integration
            x += v * dt;
            v += u * dt;
            t += dt;

            // Record history
            history.push({ x, v, u, t });
            if (history.length > maxHistory) history.shift();

            // Check if reached origin
            if (Math.abs(x) < 0.02 && Math.abs(v) < 0.02) {
                running = false;
                startBtn.textContent = 'Start';
            }
        }

        function reset() {
            x = x0;
            v = v0;
            t = 0;
            history = [{ x, v, u: optimalControl(x, v, umax), t: 0 }];
            running = false;
            startBtn.textContent = 'Start';
            draw();
        }

        // Animation loop
        let lastTime = 0;
        function animate(timestamp) {
            if (running) {
                const dt = Math.min((timestamp - lastTime) / 1000, 0.05) * speed;
                if (dt > 0) {
                    update(dt);
                }
            }
            lastTime = timestamp;
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        x0Slider.addEventListener('input', () => {
            x0 = parseFloat(x0Slider.value);
            document.getElementById('x0Display').textContent = x0.toFixed(1);
            if (!running) reset();
        });

        v0Slider.addEventListener('input', () => {
            v0 = parseFloat(v0Slider.value);
            document.getElementById('v0Display').textContent = v0.toFixed(1);
            if (!running) reset();
        });

        umaxSlider.addEventListener('input', () => {
            umax = parseFloat(umaxSlider.value);
            document.getElementById('umaxDisplay').textContent = umax.toFixed(1);
            draw();
        });

        speedSlider.addEventListener('input', () => {
            speed = parseFloat(speedSlider.value);
            document.getElementById('speedDisplay').textContent = speed.toFixed(1) + '×';
        });

        startBtn.addEventListener('click', () => {
            running = !running;
            startBtn.textContent = running ? 'Pause' : 'Start';
        });

        resetBtn.addEventListener('click', reset);

        trajectoryBtn.addEventListener('click', () => {
            showAllTrajectories = !showAllTrajectories;
            trajectoryBtn.textContent = showAllTrajectories ? 'Hide Trajectories' : 'Show All Trajectories';
            draw();
        });

        // Initialize
        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();
        reset();
        requestAnimationFrame(animate);
    </script>
</body>
</html>
