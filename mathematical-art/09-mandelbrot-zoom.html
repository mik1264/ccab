<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mandelbrot Set Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
            cursor: crosshair;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            color: white;
            max-width: 250px;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
        }
        button:hover {
            background: #764ba2;
        }
        .control-group {
            margin-top: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        input[type="range"] {
            width: 100%;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <h2>Mandelbrot Set</h2>
        <p style="font-size: 12px; color: #aaa;">Click to zoom in, right-click to zoom out</p>
        <div class="control-group">
            <label>Max Iterations: <span id="iter-val">100</span></label>
            <input type="range" id="iterations" min="50" max="500" value="100">
        </div>
        <button id="reset">Reset View</button>
        <button id="auto-zoom">Auto Zoom</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = 800;
        canvas.height = 600;

        let centerX = -0.5;
        let centerY = 0;
        let zoom = 1;
        let maxIterations = 100;
        let autoZooming = false;
        let zoomTarget = { x: -0.7, y: 0 };

        document.getElementById('iterations').addEventListener('input', (e) => {
            maxIterations = parseInt(e.target.value);
            document.getElementById('iter-val').textContent = maxIterations;
            render();
        });

        document.getElementById('reset').addEventListener('click', () => {
            centerX = -0.5;
            centerY = 0;
            zoom = 1;
            autoZooming = false;
            render();
        });

        document.getElementById('auto-zoom').addEventListener('click', () => {
            autoZooming = !autoZooming;
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / canvas.width;
            const y = (e.clientY - rect.top) / canvas.height;

            const width = 4 / zoom;
            const height = 3 / zoom;

            centerX = centerX - width/2 + x * width;
            centerY = centerY - height/2 + y * height;
            zoom *= 2;

            render();
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            zoom /= 2;
            render();
        });

        function mandelbrot(cx, cy) {
            let x = 0;
            let y = 0;
            let iteration = 0;

            while (x*x + y*y <= 4 && iteration < maxIterations) {
                const xTemp = x*x - y*y + cx;
                y = 2*x*y + cy;
                x = xTemp;
                iteration++;
            }

            return iteration;
        }

        function getColor(iterations) {
            if (iterations === maxIterations) {
                return [0, 0, 0];
            }

            const t = iterations / maxIterations;
            const r = Math.floor(9 * (1-t) * t * t * t * 255);
            const g = Math.floor(15 * (1-t) * (1-t) * t * t * 255);
            const b = Math.floor(8.5 * (1-t) * (1-t) * (1-t) * t * 255);

            return [r, g, b];
        }

        function render() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            const width = 4 / zoom;
            const height = 3 / zoom;

            for (let py = 0; py < canvas.height; py++) {
                for (let px = 0; px < canvas.width; px++) {
                    const x = centerX - width/2 + (px / canvas.width) * width;
                    const y = centerY - height/2 + (py / canvas.height) * height;

                    const iterations = mandelbrot(x, y);
                    const [r, g, b] = getColor(iterations);

                    const index = (py * canvas.width + px) * 4;
                    data[index] = r;
                    data[index + 1] = g;
                    data[index + 2] = b;
                    data[index + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function animate() {
            if (autoZooming) {
                centerX += (zoomTarget.x - centerX) * 0.1;
                centerY += (zoomTarget.y - centerY) * 0.1;
                zoom *= 1.02;
                render();
            }
            requestAnimationFrame(animate);
        }

        render();
        animate();

        window.addEventListener('resize', () => {
            const maxWidth = window.innerWidth - 40;
            const maxHeight = window.innerHeight - 40;
            const aspectRatio = 4 / 3;

            if (maxWidth / aspectRatio <= maxHeight) {
                canvas.width = maxWidth;
                canvas.height = maxWidth / aspectRatio;
            } else {
                canvas.height = maxHeight;
                canvas.width = maxHeight * aspectRatio;
            }

            render();
        });
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>