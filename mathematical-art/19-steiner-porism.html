<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Steiner Porism / Chain Simulator - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e8e6e1;
            min-height: 100vh;
            overflow: hidden;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            color: #fbbf24;
            text-decoration: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 500;
            z-index: 1000;
            transition: all 0.3s ease;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .back-link:hover {
            background: rgba(251, 191, 36, 0.2);
            transform: translateX(-5px);
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .controls {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            z-index: 1000;
            max-width: 280px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls h2 {
            font-size: 16px;
            color: #fbbf24;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #fbbf24;
            border-radius: 50%;
            cursor: pointer;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 12px;
            color: #ccc;
            margin-bottom: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #fbbf24;
        }

        button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            border: none;
            border-radius: 8px;
            color: #1a1a2e;
            font-weight: 600;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s ease;
            margin-top: 8px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(251, 191, 36, 0.4);
        }

        button.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .info-panel {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px 20px;
            z-index: 1000;
            max-width: 420px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-panel h3 {
            color: #fbbf24;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .info-panel p {
            font-size: 11px;
            color: #aaa;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 12px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-item .label {
            font-size: 9px;
            color: #888;
        }

        .stat-item .value {
            font-size: 14px;
            color: #fbbf24;
            font-family: 'Courier New', monospace;
        }

        .closure-status {
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            text-align: center;
            font-weight: bold;
        }

        .closure-status.closed {
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
            border: 1px solid rgba(78, 205, 196, 0.5);
        }

        .closure-status.open {
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
            border: 1px solid rgba(255, 107, 107, 0.5);
        }

        .legend {
            display: flex;
            gap: 15px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: #aaa;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 50%;
        }

        @media (max-width: 768px) {
            .controls {
                max-width: 240px;
                padding: 15px;
            }

            .info-panel {
                max-width: calc(100% - 30px);
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div class="controls">
        <h2>Steiner Chain Controls</h2>

        <div class="control-group">
            <label>Chain Circles: <span id="numVal">6</span></label>
            <input type="range" id="numCircles" min="3" max="20" value="6">
        </div>

        <div class="control-group">
            <label>Inner Circle Radius: <span id="innerVal">80</span></label>
            <input type="range" id="innerRadius" min="30" max="150" value="80">
        </div>

        <div class="control-group">
            <label>Outer Circle Radius: <span id="outerVal">200</span></label>
            <input type="range" id="outerRadius" min="100" max="300" value="200">
        </div>

        <div class="control-group">
            <label>Starting Angle: <span id="startVal">0</span>°</label>
            <input type="range" id="startAngle" min="0" max="360" value="0">
        </div>

        <div class="control-group checkbox-group">
            <label>
                <input type="checkbox" id="showTangentPoints" checked>
                Show Tangent Points
            </label>
            <label>
                <input type="checkbox" id="animate">
                Animate Chain
            </label>
            <label>
                <input type="checkbox" id="showInversion">
                Show Inversion View
            </label>
        </div>

        <button id="findClosure">Find Closed Chain</button>
        <button id="reset" class="secondary">Reset</button>
    </div>

    <div class="info-panel">
        <h3>Steiner's Porism</h3>
        <p>
            <strong>The Theorem:</strong> Given two non-intersecting circles, if a chain of n circles
            exists where each is tangent to both given circles and to its neighbors, and the chain
            closes (first tangent to last), then <em>infinitely many</em> such chains exist.
        </p>
        <p>
            <strong>The Magic:</strong> You can start the chain at any point on the outer circle,
            and it will still close! This is proven using <em>circle inversion</em> to transform
            the problem into concentric circles where the result is obvious by symmetry.
        </p>

        <div class="closure-status" id="closureStatus">
            Checking closure...
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="label">Chain Length</div>
                <div class="value" id="chainLength">6</div>
            </div>
            <div class="stat-item">
                <div class="label">Gap/Overlap</div>
                <div class="value" id="gapValue">-</div>
            </div>
            <div class="stat-item">
                <div class="label">Closure Error</div>
                <div class="value" id="errorValue">-</div>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 107, 107, 0.8);"></div>
                Outer Circle
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(78, 205, 196, 0.8);"></div>
                Inner Circle
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(251, 191, 36, 0.8);"></div>
                Chain Circles
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // State
        let width, height, cx, cy;
        let dpr = window.devicePixelRatio || 1;

        let numCircles = 6;
        let innerRadius = 80;
        let outerRadius = 200;
        let startAngle = 0;
        let showTangentPoints = true;
        let animating = false;
        let showInversion = false;

        // Resize
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            cx = width / 2;
            cy = height / 2;
        }

        window.addEventListener('resize', () => {
            resize();
            draw();
        });
        resize();

        // Calculate Steiner chain circles
        // Using the formula for chain between two concentric circles, then we'll handle eccentric case
        function calculateSteinerChain() {
            const circles = [];

            // For eccentric circles, we use the inversive distance
            // d = sqrt(R^2 + r^2 - 2Rr*cosh(delta)) where delta is inversive distance

            // Simplified: assume inner circle is centered at origin, outer at origin too
            // For true eccentric case, would need Möbius transformation

            const R = outerRadius; // Outer radius
            const r = innerRadius; // Inner radius

            // Gap where chain circles fit
            const gap = R - r;

            // For n circles in a closed chain between concentric circles:
            // radius of each chain circle = (R - r) * sin(π/n) / (1 + sin(π/n))
            const chainRadius = gap * Math.sin(Math.PI / numCircles) / (1 + Math.sin(Math.PI / numCircles));

            // Center distance from origin
            const centerDist = r + chainRadius;

            // Generate circles
            const angleStep = (2 * Math.PI) / numCircles;
            const startRad = startAngle * Math.PI / 180;

            for (let i = 0; i < numCircles; i++) {
                const angle = startRad + i * angleStep;
                circles.push({
                    x: cx + centerDist * Math.cos(angle),
                    y: cy + centerDist * Math.sin(angle),
                    radius: chainRadius,
                    angle: angle
                });
            }

            return circles;
        }

        // Check if chain closes properly
        function checkClosure(circles) {
            if (circles.length < 2) return { closed: false, error: Infinity };

            const first = circles[0];
            const last = circles[circles.length - 1];

            // Distance between centers
            const dx = last.x - first.x;
            const dy = last.y - first.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // For tangent circles, distance should equal sum of radii
            const expectedDist = first.radius + last.radius;
            const error = Math.abs(dist - expectedDist);

            // Threshold for "closed"
            const closed = error < 1;

            return { closed, error, gap: dist - expectedDist };
        }

        // Find parameters for closed chain
        function findClosedChain() {
            // For concentric circles, any n works if properly sized
            // The key is: sin(π/n) = (R-r)/(R+r) for perfect closure

            const R = outerRadius;
            const r = innerRadius;

            // Solve for n: n = π / arcsin((R-r)/(R+r))
            const ratio = (R - r) / (R + r);
            if (ratio > 1 || ratio < 0) {
                alert("Invalid configuration - circles may be intersecting");
                return;
            }

            const n = Math.PI / Math.asin(ratio);

            // Round to nearest integer
            const closestN = Math.round(n);

            if (closestN >= 3 && closestN <= 20) {
                numCircles = closestN;
                document.getElementById('numCircles').value = closestN;
                document.getElementById('numVal').textContent = closestN;
            } else {
                // Adjust radii instead
                const targetN = numCircles;
                const sinVal = Math.sin(Math.PI / targetN);
                // (R-r)/(R+r) = sin(π/n)
                // R - r = sinVal * (R + r)
                // R - r = sinVal*R + sinVal*r
                // R(1 - sinVal) = r(1 + sinVal)
                // R/r = (1 + sinVal)/(1 - sinVal)

                const newRatio = (1 + sinVal) / (1 - sinVal);
                const newOuter = innerRadius * newRatio;

                if (newOuter <= 300 && newOuter >= 100) {
                    outerRadius = Math.round(newOuter);
                    document.getElementById('outerRadius').value = outerRadius;
                    document.getElementById('outerVal').textContent = outerRadius;
                }
            }

            draw();
        }

        // Draw everything
        function draw() {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, width, height);

            // Background grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for (let x = 0; x < width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            for (let y = 0; y < height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // Draw outer circle
            ctx.strokeStyle = 'rgba(255, 107, 107, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(cx, cy, outerRadius, 0, Math.PI * 2);
            ctx.stroke();

            ctx.fillStyle = 'rgba(255, 107, 107, 0.05)';
            ctx.fill();

            // Draw inner circle
            ctx.strokeStyle = 'rgba(78, 205, 196, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2);
            ctx.stroke();

            ctx.fillStyle = 'rgba(78, 205, 196, 0.1)';
            ctx.fill();

            // Calculate and draw chain
            const chainCircles = calculateSteinerChain();

            // Draw chain circles
            chainCircles.forEach((circle, i) => {
                // Fill
                ctx.fillStyle = `hsla(${40 + i * 10}, 80%, 60%, 0.2)`;
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
                ctx.fill();

                // Stroke
                ctx.strokeStyle = `hsla(${40 + i * 10}, 80%, 60%, 0.9)`;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Center point
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, 3, 0, Math.PI * 2);
                ctx.fill();

                // Number
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText((i + 1).toString(), circle.x, circle.y);
            });

            // Draw tangent points
            if (showTangentPoints) {
                chainCircles.forEach((circle, i) => {
                    // Tangent to outer circle
                    const outerTangentDist = outerRadius;
                    const dirX = (circle.x - cx) / Math.sqrt((circle.x - cx) ** 2 + (circle.y - cy) ** 2);
                    const dirY = (circle.y - cy) / Math.sqrt((circle.x - cx) ** 2 + (circle.y - cy) ** 2);

                    const outerTx = cx + dirX * outerRadius;
                    const outerTy = cy + dirY * outerRadius;

                    ctx.fillStyle = '#ff6b6b';
                    ctx.beginPath();
                    ctx.arc(outerTx, outerTy, 5, 0, Math.PI * 2);
                    ctx.fill();

                    // Tangent to inner circle
                    const innerTx = cx + dirX * innerRadius;
                    const innerTy = cy + dirY * innerRadius;

                    ctx.fillStyle = '#4ecdc4';
                    ctx.beginPath();
                    ctx.arc(innerTx, innerTy, 5, 0, Math.PI * 2);
                    ctx.fill();

                    // Tangent to neighbor
                    if (i < chainCircles.length - 1) {
                        const next = chainCircles[i + 1];
                        const mx = (circle.x + next.x) / 2;
                        const my = (circle.y + next.y) / 2;

                        ctx.fillStyle = '#fbbf24';
                        ctx.beginPath();
                        ctx.arc(mx, my, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                // First-last tangent point
                if (chainCircles.length > 0) {
                    const first = chainCircles[0];
                    const last = chainCircles[chainCircles.length - 1];
                    const mx = (first.x + last.x) / 2;
                    const my = (first.y + last.y) / 2;

                    ctx.fillStyle = '#fbbf24';
                    ctx.beginPath();
                    ctx.arc(mx, my, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Check and display closure
            const closure = checkClosure(chainCircles);
            updateClosureStatus(closure);

            // Watermark
            ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.font = 'bold 60px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('STEINER', cx, cy - 30);
            ctx.fillText('PORISM', cx, cy + 40);
        }

        // Update closure status display
        function updateClosureStatus(closure) {
            const statusEl = document.getElementById('closureStatus');

            if (closure.closed) {
                statusEl.textContent = '✓ CLOSED CHAIN - Porism holds!';
                statusEl.className = 'closure-status closed';
            } else {
                statusEl.textContent = '✗ Open chain - adjust parameters';
                statusEl.className = 'closure-status open';
            }

            document.getElementById('chainLength').textContent = numCircles;
            document.getElementById('gapValue').textContent = closure.gap ? closure.gap.toFixed(2) : '-';
            document.getElementById('errorValue').textContent = closure.error ? closure.error.toFixed(3) : '-';
        }

        // Animation loop
        function animate() {
            if (animating) {
                startAngle = (startAngle + 0.5) % 360;
                document.getElementById('startAngle').value = startAngle;
                document.getElementById('startVal').textContent = Math.round(startAngle);
                draw();
            }
            requestAnimationFrame(animate);
        }

        // Controls
        document.getElementById('numCircles').addEventListener('input', (e) => {
            numCircles = parseInt(e.target.value);
            document.getElementById('numVal').textContent = numCircles;
            draw();
        });

        document.getElementById('innerRadius').addEventListener('input', (e) => {
            innerRadius = parseInt(e.target.value);
            document.getElementById('innerVal').textContent = innerRadius;
            draw();
        });

        document.getElementById('outerRadius').addEventListener('input', (e) => {
            outerRadius = parseInt(e.target.value);
            document.getElementById('outerVal').textContent = outerRadius;
            draw();
        });

        document.getElementById('startAngle').addEventListener('input', (e) => {
            startAngle = parseInt(e.target.value);
            document.getElementById('startVal').textContent = startAngle;
            draw();
        });

        document.getElementById('showTangentPoints').addEventListener('change', (e) => {
            showTangentPoints = e.target.checked;
            draw();
        });

        document.getElementById('animate').addEventListener('change', (e) => {
            animating = e.target.checked;
        });

        document.getElementById('showInversion').addEventListener('change', (e) => {
            showInversion = e.target.checked;
            draw();
        });

        document.getElementById('findClosure').addEventListener('click', findClosedChain);

        document.getElementById('reset').addEventListener('click', () => {
            numCircles = 6;
            innerRadius = 80;
            outerRadius = 200;
            startAngle = 0;

            document.getElementById('numCircles').value = 6;
            document.getElementById('innerRadius').value = 80;
            document.getElementById('outerRadius').value = 200;
            document.getElementById('startAngle').value = 0;

            document.getElementById('numVal').textContent = 6;
            document.getElementById('innerVal').textContent = 80;
            document.getElementById('outerVal').textContent = 200;
            document.getElementById('startVal').textContent = 0;

            draw();
        });

        // Initialize
        draw();
        animate();
    </script>
</body>
</html>
