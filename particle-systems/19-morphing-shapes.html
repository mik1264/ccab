<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Morphing Particle Shapes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            background: #1a1a2e;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        class MorphingParticle {
            constructor(index, total) {
                this.index = index;
                this.total = total;
                this.angle = (Math.PI * 2 * index) / total;
                this.size = 3;
                this.currentShape = 0; // 0: circle, 1: square, 2: star
                this.morphProgress = 0;
            }

            getPosition(shapeType, radius) {
                switch(shapeType) {
                    case 0: // Circle
                        return {
                            x: centerX + Math.cos(this.angle) * radius,
                            y: centerY + Math.sin(this.angle) * radius
                        };
                    case 1: // Square
                        const side = (this.index / this.total) * 4;
                        const t = (this.index % (this.total / 4)) / (this.total / 4);
                        if (side < 1) {
                            return { x: centerX + radius * (t * 2 - 1), y: centerY - radius };
                        } else if (side < 2) {
                            return { x: centerX + radius, y: centerY + radius * (t * 2 - 1) };
                        } else if (side < 3) {
                            return { x: centerX - radius * (t * 2 - 1), y: centerY + radius };
                        } else {
                            return { x: centerX - radius, y: centerY - radius * (t * 2 - 1) };
                        }
                    case 2: // Star
                        const points = 5;
                        const pointIndex = (this.index / this.total) * points;
                        const isOuter = Math.floor(pointIndex * 2) % 2 === 0;
                        const r = isOuter ? radius : radius * 0.5;
                        return {
                            x: centerX + Math.cos(this.angle) * r,
                            y: centerY + Math.sin(this.angle) * r
                        };
                }
            }

            update(targetShape, morphSpeed) {
                if (this.currentShape !== targetShape) {
                    this.morphProgress += morphSpeed;
                    if (this.morphProgress >= 1) {
                        this.currentShape = targetShape;
                        this.morphProgress = 0;
                    }
                }
            }

            draw(targetShape, radius) {
                const pos1 = this.getPosition(this.currentShape, radius);
                const pos2 = this.getPosition(targetShape, radius);

                const x = pos1.x + (pos2.x - pos1.x) * this.morphProgress;
                const y = pos1.y + (pos2.y - pos1.y) * this.morphProgress;

                const hue = (this.angle * 180 / Math.PI) % 360;
                ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                ctx.shadowBlur = 10;
                ctx.shadowColor = `hsl(${hue}, 70%, 60%)`;
                ctx.beginPath();
                ctx.arc(x, y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        const particles = [];
        const particleCount = 60;

        for (let i = 0; i < particleCount; i++) {
            particles.push(new MorphingParticle(i, particleCount));
        }

        let targetShape = 0;
        let shapeTimer = 0;
        const shapeDuration = 120; // frames

        function animate() {
            ctx.fillStyle = 'rgba(26, 26, 46, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            shapeTimer++;
            if (shapeTimer > shapeDuration) {
                targetShape = (targetShape + 1) % 3;
                shapeTimer = 0;
            }

            const radius = 150 + Math.sin(Date.now() * 0.001) * 30;

            particles.forEach(particle => {
                particle.update(targetShape, 0.02);
                particle.draw(targetShape, radius);
            });

            // Draw connecting lines
            ctx.strokeStyle = 'rgba(100, 150, 255, 0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i < particles.length; i++) {
                const p1 = particles[i];
                const p2 = particles[(i + 1) % particles.length];

                const pos1_curr = p1.getPosition(p1.currentShape, radius);
                const pos1_target = p1.getPosition(targetShape, radius);
                const x1 = pos1_curr.x + (pos1_target.x - pos1_curr.x) * p1.morphProgress;
                const y1 = pos1_curr.y + (pos1_target.y - pos1_curr.y) * p1.morphProgress;

                const pos2_curr = p2.getPosition(p2.currentShape, radius);
                const pos2_target = p2.getPosition(targetShape, radius);
                const x2 = pos2_curr.x + (pos2_target.x - pos2_curr.x) * p2.morphProgress;
                const y2 = pos2_curr.y + (pos2_target.y - pos2_curr.y) * p2.morphProgress;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            ctx.shadowBlur = 0;
            requestAnimationFrame(animate);
        }

        animate();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
