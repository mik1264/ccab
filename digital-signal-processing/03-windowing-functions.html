<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Windowing Functions - Spectral Leakage Control</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #00aaff;
            min-height: 100vh;
            padding: 20px;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00aaff;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(0,170,255,0.1);
            border: 1px solid #00aaff;
            border-radius: 5px;
            z-index: 100;
        }
        .back-link:hover { background: rgba(0,170,255,0.2); }
        .container {
            max-width: 1200px;
            margin: 60px auto 0;
        }
        h1 { font-size: 2rem; margin-bottom: 10px; text-align: center; }
        .subtitle { color: #888; margin-bottom: 30px; text-align: center; }
        .viz-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        .panel {
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid #00aaff;
        }
        .panel h3 { color: #00ccff; margin-bottom: 15px; text-align: center; font-size: 1rem; }
        canvas {
            width: 100%;
            height: 200px;
            background: rgba(0,20,40,0.5);
            border-radius: 10px;
        }
        .window-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 30px;
        }
        button {
            padding: 10px 20px;
            font-family: inherit;
            background: rgba(0,170,255,0.1);
            border: 1px solid #00aaff;
            color: #00aaff;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover { background: rgba(0,170,255,0.3); }
        button.active { background: rgba(0,170,255,0.4); border-color: #00ffff; color: #00ffff; }
        .properties {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 30px;
        }
        .property-box {
            background: rgba(0,170,255,0.05);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        .property-box h4 { color: #888; font-size: 0.8rem; margin-bottom: 5px; }
        .property-box .value { color: #00ffff; font-size: 1.2rem; }
        .info {
            background: rgba(0,170,255,0.05);
            padding: 20px;
            border-radius: 10px;
        }
        .info h3 { color: #00ccff; margin-bottom: 10px; }
        .info p { color: #aaa; line-height: 1.6; margin-bottom: 10px; }
        @media (max-width: 768px) {
            .viz-grid { grid-template-columns: 1fr; }
            .properties { grid-template-columns: 1fr 1fr; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div class="container">
        <h1>Windowing Functions</h1>
        <p class="subtitle">Control spectral leakage in frequency analysis</p>

        <div class="window-selector">
            <button onclick="setWindow('rectangular')" id="btnRectangular" class="active">Rectangular</button>
            <button onclick="setWindow('hann')" id="btnHann">Hann</button>
            <button onclick="setWindow('hamming')" id="btnHamming">Hamming</button>
            <button onclick="setWindow('blackman')" id="btnBlackman">Blackman</button>
            <button onclick="setWindow('kaiser')" id="btnKaiser">Kaiser</button>
            <button onclick="setWindow('gaussian')" id="btnGaussian">Gaussian</button>
        </div>

        <div class="viz-grid">
            <div class="panel">
                <h3>Window Function (Time Domain)</h3>
                <canvas id="windowCanvas"></canvas>
            </div>
            <div class="panel">
                <h3>Signal with Window Applied</h3>
                <canvas id="signalCanvas"></canvas>
            </div>
            <div class="panel">
                <h3>Window Spectrum (dB)</h3>
                <canvas id="spectrumCanvas"></canvas>
            </div>
            <div class="panel">
                <h3>Windowed Signal Spectrum</h3>
                <canvas id="resultCanvas"></canvas>
            </div>
        </div>

        <div class="properties">
            <div class="property-box">
                <h4>Main Lobe Width</h4>
                <div class="value" id="mainLobe">2 bins</div>
            </div>
            <div class="property-box">
                <h4>Side Lobe Level</h4>
                <div class="value" id="sideLobe">-13 dB</div>
            </div>
            <div class="property-box">
                <h4>Side Lobe Falloff</h4>
                <div class="value" id="falloff">6 dB/oct</div>
            </div>
            <div class="property-box">
                <h4>Coherent Gain</h4>
                <div class="value" id="gain">1.00</div>
            </div>
        </div>

        <div class="info">
            <h3>Why Window Functions?</h3>
            <p>When analyzing a finite segment of a signal, the FFT assumes the segment repeats infinitely. If the signal doesn't complete exact cycles within the window, discontinuities cause <strong>spectral leakage</strong> - energy spreads to adjacent frequency bins.</p>
            <p><strong>Rectangular:</strong> Best frequency resolution, worst leakage (-13 dB sidelobes)</p>
            <p><strong>Hann:</strong> Good general-purpose window, -31 dB sidelobes</p>
            <p><strong>Hamming:</strong> Optimized for minimum near-sidelobe level, -42 dB</p>
            <p><strong>Blackman:</strong> Excellent sidelobe suppression (-58 dB), wider main lobe</p>
            <p><strong>Kaiser:</strong> Adjustable tradeoff via β parameter</p>
        </div>
    </div>

    <script>
        const windowCanvas = document.getElementById('windowCanvas');
        const signalCanvas = document.getElementById('signalCanvas');
        const spectrumCanvas = document.getElementById('spectrumCanvas');
        const resultCanvas = document.getElementById('resultCanvas');

        const N = 256;
        let currentWindow = 'rectangular';

        const windowProperties = {
            rectangular: { mainLobe: '2 bins', sideLobe: '-13 dB', falloff: '6 dB/oct', gain: '1.00' },
            hann: { mainLobe: '4 bins', sideLobe: '-31 dB', falloff: '18 dB/oct', gain: '0.50' },
            hamming: { mainLobe: '4 bins', sideLobe: '-42 dB', falloff: '6 dB/oct', gain: '0.54' },
            blackman: { mainLobe: '6 bins', sideLobe: '-58 dB', falloff: '18 dB/oct', gain: '0.42' },
            kaiser: { mainLobe: '5 bins', sideLobe: '-50 dB', falloff: '6 dB/oct', gain: '0.48' },
            gaussian: { mainLobe: '4 bins', sideLobe: '-44 dB', falloff: '6 dB/oct', gain: '0.47' }
        };

        function getWindow(type, N) {
            const w = new Array(N);
            for (let n = 0; n < N; n++) {
                switch (type) {
                    case 'rectangular':
                        w[n] = 1;
                        break;
                    case 'hann':
                        w[n] = 0.5 * (1 - Math.cos(2 * Math.PI * n / (N - 1)));
                        break;
                    case 'hamming':
                        w[n] = 0.54 - 0.46 * Math.cos(2 * Math.PI * n / (N - 1));
                        break;
                    case 'blackman':
                        w[n] = 0.42 - 0.5 * Math.cos(2 * Math.PI * n / (N - 1)) +
                               0.08 * Math.cos(4 * Math.PI * n / (N - 1));
                        break;
                    case 'kaiser':
                        const beta = 5;
                        const alpha = (N - 1) / 2;
                        const x = (n - alpha) / alpha;
                        w[n] = bessel0(beta * Math.sqrt(1 - x * x)) / bessel0(beta);
                        break;
                    case 'gaussian':
                        const sigma = 0.4;
                        const center = (N - 1) / 2;
                        w[n] = Math.exp(-0.5 * Math.pow((n - center) / (sigma * center), 2));
                        break;
                }
            }
            return w;
        }

        function bessel0(x) {
            let sum = 1, term = 1;
            for (let k = 1; k <= 20; k++) {
                term *= (x / 2 / k) * (x / 2 / k);
                sum += term;
            }
            return sum;
        }

        function fft(signal) {
            const n = signal.length;
            if (n <= 1) return signal.map(x => ({ re: x, im: 0 }));

            const even = fft(signal.filter((_, i) => i % 2 === 0));
            const odd = fft(signal.filter((_, i) => i % 2 === 1));

            const result = new Array(n);
            for (let k = 0; k < n / 2; k++) {
                const angle = -2 * Math.PI * k / n;
                const t = {
                    re: Math.cos(angle) * odd[k].re - Math.sin(angle) * odd[k].im,
                    im: Math.cos(angle) * odd[k].im + Math.sin(angle) * odd[k].re
                };
                result[k] = { re: even[k].re + t.re, im: even[k].im + t.im };
                result[k + n / 2] = { re: even[k].re - t.re, im: even[k].im - t.im };
            }
            return result;
        }

        function magnitude(complex) {
            return Math.sqrt(complex.re * complex.re + complex.im * complex.im);
        }

        function resizeCanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.getContext('2d').scale(dpr, dpr);
        }

        function drawCurve(canvas, data, color, label) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            // Grid
            ctx.strokeStyle = 'rgba(0,170,255,0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                ctx.beginPath();
                ctx.moveTo(0, h * i / 4);
                ctx.lineTo(w, h * i / 4);
                ctx.stroke();
            }

            // Data
            const max = Math.max(...data.map(Math.abs));
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < data.length; i++) {
                const x = (i / (data.length - 1)) * w;
                const y = h / 2 - (data[i] / (max || 1)) * (h * 0.45);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function drawSpectrum(canvas, data, color) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            // Grid with dB labels
            ctx.strokeStyle = 'rgba(0,170,255,0.1)';
            ctx.fillStyle = '#666';
            ctx.font = '10px Courier New';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = h * i / 4;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
                ctx.fillText(`${-i * 20} dB`, 5, y + 12);
            }

            // Spectrum (first half only - positive frequencies)
            const halfN = data.length / 2;
            const maxMag = Math.max(...data.slice(0, halfN));

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < halfN; i++) {
                const x = (i / halfN) * w;
                const db = 20 * Math.log10(data[i] / maxMag + 1e-10);
                const y = Math.max(0, Math.min(h, -db / 80 * h));
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function update() {
            const window = getWindow(currentWindow, N);

            // Generate test signal (sine wave not perfectly aligned with FFT bin)
            const freq = 10.5; // Deliberately non-integer for leakage demo
            const signal = new Array(N);
            for (let i = 0; i < N; i++) {
                signal[i] = Math.sin(2 * Math.PI * freq * i / N);
            }

            // Apply window
            const windowedSignal = signal.map((s, i) => s * window[i]);

            // Compute FFTs
            const windowSpectrum = fft(window).map(magnitude);
            const signalSpectrum = fft(windowedSignal).map(magnitude);

            // Draw all panels
            drawCurve(windowCanvas, window, '#00aaff', 'Window');
            drawCurve(signalCanvas, windowedSignal, '#00ffaa', 'Windowed Signal');
            drawSpectrum(spectrumCanvas, windowSpectrum, '#00aaff');
            drawSpectrum(resultCanvas, signalSpectrum, '#00ffaa');

            // Update properties
            const props = windowProperties[currentWindow];
            document.getElementById('mainLobe').textContent = props.mainLobe;
            document.getElementById('sideLobe').textContent = props.sideLobe;
            document.getElementById('falloff').textContent = props.falloff;
            document.getElementById('gain').textContent = props.gain;
        }

        function setWindow(type) {
            currentWindow = type;
            document.querySelectorAll('.window-selector button').forEach(b => b.classList.remove('active'));
            document.getElementById('btn' + type.charAt(0).toUpperCase() + type.slice(1)).classList.add('active');
            update();
        }

        function init() {
            [windowCanvas, signalCanvas, spectrumCanvas, resultCanvas].forEach(resizeCanvas);
            update();
        }

        window.addEventListener('resize', init);
        init();
    </script>
</body>
</html>
