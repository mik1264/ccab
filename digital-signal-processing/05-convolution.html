<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convolution Operation - Filter Application</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #00aaff;
            min-height: 100vh;
            padding: 20px;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00aaff;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(0,170,255,0.1);
            border: 1px solid #00aaff;
            border-radius: 5px;
            z-index: 100;
        }
        .back-link:hover { background: rgba(0,170,255,0.2); }
        .container {
            max-width: 1100px;
            margin: 60px auto 0;
        }
        h1 { font-size: 2rem; margin-bottom: 10px; text-align: center; }
        .subtitle { color: #888; margin-bottom: 30px; text-align: center; }
        .viz-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        .panel {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 15px;
            border: 1px solid #00aaff;
        }
        .panel h3 { color: #00ccff; margin-bottom: 10px; text-align: center; font-size: 0.95rem; }
        canvas {
            width: 100%;
            height: 150px;
            background: rgba(0,20,40,0.5);
            border-radius: 8px;
        }
        .animation-panel {
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid #00aaff;
            margin-bottom: 20px;
        }
        .animation-panel h3 { color: #00ccff; margin-bottom: 15px; text-align: center; }
        #animCanvas {
            height: 200px;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 25px;
            font-family: inherit;
            background: rgba(0,170,255,0.1);
            border: 1px solid #00aaff;
            color: #00aaff;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover { background: rgba(0,170,255,0.3); }
        button.active { background: rgba(0,170,255,0.4); }
        select {
            padding: 10px 20px;
            font-family: inherit;
            background: rgba(0,170,255,0.1);
            border: 1px solid #00aaff;
            color: #00aaff;
            border-radius: 5px;
        }
        .formula {
            text-align: center;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            margin: 20px 0;
            font-size: 1.1rem;
        }
        .info {
            background: rgba(0,170,255,0.05);
            padding: 20px;
            border-radius: 10px;
        }
        .info h3 { color: #00ccff; margin-bottom: 10px; }
        .info p { color: #aaa; line-height: 1.6; margin-bottom: 10px; }
        @media (max-width: 768px) {
            .viz-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div class="container">
        <h1>Convolution Operation</h1>
        <p class="subtitle">The fundamental operation behind filtering</p>

        <div class="viz-grid">
            <div class="panel">
                <h3>Input Signal x[n]</h3>
                <canvas id="inputCanvas"></canvas>
            </div>
            <div class="panel">
                <h3>Impulse Response h[n]</h3>
                <canvas id="kernelCanvas"></canvas>
            </div>
            <div class="panel">
                <h3>Output y[n] = x * h</h3>
                <canvas id="outputCanvas"></canvas>
            </div>
        </div>

        <div class="animation-panel">
            <h3>Convolution Animation - Flip, Shift, Multiply, Sum</h3>
            <canvas id="animCanvas"></canvas>
            <div class="controls">
                <select id="signalType">
                    <option value="pulse">Pulse Signal</option>
                    <option value="step">Step Signal</option>
                    <option value="ramp">Ramp Signal</option>
                    <option value="sine">Sine Wave</option>
                </select>
                <select id="kernelType">
                    <option value="box">Box Filter (Moving Avg)</option>
                    <option value="gaussian">Gaussian Blur</option>
                    <option value="diff">Differentiator</option>
                    <option value="echo">Echo Effect</option>
                </select>
                <button onclick="reset()">Reset</button>
                <button onclick="togglePlay()" id="playBtn">Play</button>
                <button onclick="stepForward()">Step</button>
            </div>
        </div>

        <div class="formula">
            y[n] = Σ x[k] · h[n - k] = x[n] * h[n]
        </div>

        <div class="info">
            <h3>Understanding Convolution</h3>
            <p>Convolution combines two signals to produce a third. In signal processing, it applies a filter (impulse response) to an input signal.</p>
            <p><strong>The Steps:</strong></p>
            <p>1. <strong>Flip</strong> the kernel (impulse response) horizontally</p>
            <p>2. <strong>Shift</strong> it across the input signal</p>
            <p>3. <strong>Multiply</strong> overlapping samples point-by-point</p>
            <p>4. <strong>Sum</strong> the products to get one output sample</p>
            <p><strong>Applications:</strong> Smoothing, sharpening, edge detection, reverb, echo, blur effects</p>
        </div>
    </div>

    <script>
        const inputCanvas = document.getElementById('inputCanvas');
        const kernelCanvas = document.getElementById('kernelCanvas');
        const outputCanvas = document.getElementById('outputCanvas');
        const animCanvas = document.getElementById('animCanvas');

        const N = 64;
        const kernelSize = 9;
        let input = [];
        let kernel = [];
        let output = [];
        let position = 0;
        let isPlaying = false;

        function generateSignal(type) {
            const sig = new Array(N).fill(0);
            switch(type) {
                case 'pulse':
                    for (let i = 20; i < 30; i++) sig[i] = 1;
                    break;
                case 'step':
                    for (let i = 20; i < N; i++) sig[i] = 1;
                    break;
                case 'ramp':
                    for (let i = 15; i < 45; i++) sig[i] = (i - 15) / 30;
                    break;
                case 'sine':
                    for (let i = 0; i < N; i++) sig[i] = 0.5 + 0.5 * Math.sin(2 * Math.PI * i / 16);
                    break;
            }
            return sig;
        }

        function generateKernel(type) {
            const k = new Array(kernelSize).fill(0);
            const center = Math.floor(kernelSize / 2);
            switch(type) {
                case 'box':
                    for (let i = 0; i < kernelSize; i++) k[i] = 1 / kernelSize;
                    break;
                case 'gaussian':
                    const sigma = 1.5;
                    let sum = 0;
                    for (let i = 0; i < kernelSize; i++) {
                        k[i] = Math.exp(-0.5 * Math.pow((i - center) / sigma, 2));
                        sum += k[i];
                    }
                    for (let i = 0; i < kernelSize; i++) k[i] /= sum;
                    break;
                case 'diff':
                    k[center - 1] = -0.5;
                    k[center + 1] = 0.5;
                    break;
                case 'echo':
                    k[0] = 1;
                    k[4] = 0.5;
                    k[8] = 0.25;
                    break;
            }
            return k;
        }

        function convolve(signal, kernel) {
            const result = new Array(signal.length).fill(0);
            const halfK = Math.floor(kernel.length / 2);

            for (let i = 0; i < signal.length; i++) {
                for (let j = 0; j < kernel.length; j++) {
                    const idx = i - halfK + j;
                    if (idx >= 0 && idx < signal.length) {
                        result[i] += signal[idx] * kernel[kernel.length - 1 - j];
                    }
                }
            }
            return result;
        }

        function resizeCanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.getContext('2d').scale(dpr, dpr);
        }

        function drawSignal(canvas, data, color, highlight = -1) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            // Grid
            ctx.strokeStyle = 'rgba(0,170,255,0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, h / 2);
            ctx.lineTo(w, h / 2);
            ctx.stroke();

            const max = Math.max(Math.abs(Math.max(...data)), Math.abs(Math.min(...data)), 0.1);
            const barWidth = w / data.length;

            data.forEach((val, i) => {
                const x = i * barWidth;
                const barHeight = (val / max) * (h * 0.45);

                ctx.fillStyle = i === highlight ? '#ff6688' : color;
                if (barHeight >= 0) {
                    ctx.fillRect(x, h / 2 - barHeight, barWidth - 1, barHeight);
                } else {
                    ctx.fillRect(x, h / 2, barWidth - 1, -barHeight);
                }
            });
        }

        function drawAnimation() {
            const ctx = animCanvas.getContext('2d');
            const w = animCanvas.width / (window.devicePixelRatio || 1);
            const h = animCanvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            const halfK = Math.floor(kernel.length / 2);
            const barWidth = w / (N + kernel.length);

            // Draw input signal
            const maxIn = Math.max(...input.map(Math.abs), 0.1);
            input.forEach((val, i) => {
                const x = (i + halfK) * barWidth;
                const barHeight = (val / maxIn) * (h * 0.35);
                ctx.fillStyle = 'rgba(0,170,255,0.5)';
                ctx.fillRect(x, h / 2 - barHeight, barWidth - 1, barHeight);
            });

            // Draw flipped and shifted kernel
            const flippedKernel = [...kernel].reverse();
            const maxK = Math.max(...kernel.map(Math.abs), 0.1);
            flippedKernel.forEach((val, i) => {
                const x = (position + i) * barWidth;
                const barHeight = (val / maxK) * (h * 0.35);
                ctx.fillStyle = '#ff6688';
                ctx.fillRect(x, h / 2, barWidth - 1, barHeight);
            });

            // Calculate current output value
            let currentSum = 0;
            for (let j = 0; j < kernel.length; j++) {
                const idx = position - halfK + j;
                if (idx >= 0 && idx < N) {
                    currentSum += input[idx] * kernel[kernel.length - 1 - j];
                }
            }

            // Update output
            if (position >= 0 && position < N) {
                output[position] = currentSum;
            }

            // Draw output so far
            const maxOut = Math.max(...output.map(Math.abs), 0.1);
            for (let i = 0; i <= position && i < N; i++) {
                const x = (i + halfK) * barWidth;
                const barHeight = (output[i] / maxOut) * (h * 0.25);
                ctx.fillStyle = '#00ffaa';
                ctx.fillRect(x, h - 20 - Math.abs(barHeight), barWidth - 1, Math.abs(barHeight));
            }

            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.fillText('Input x[n]', 10, 20);
            ctx.fillText('Kernel h[-k] shifted', 10, h / 2 + 15);
            ctx.fillText('Output y[n]', 10, h - 5);

            // Current sum
            ctx.fillStyle = '#00ffff';
            ctx.font = '14px Courier New';
            ctx.fillText(`Position: ${position}  Sum: ${currentSum.toFixed(3)}`, w - 200, 25);
        }

        function stepForward() {
            position++;
            if (position >= N + kernel.length) position = N + kernel.length - 1;
            drawAnimation();
            drawSignal(outputCanvas, output, '#00ffaa');
        }

        function togglePlay() {
            isPlaying = !isPlaying;
            document.getElementById('playBtn').textContent = isPlaying ? 'Pause' : 'Play';
            if (isPlaying) animate();
        }

        function animate() {
            if (!isPlaying) return;
            stepForward();
            if (position < N + kernel.length - 1) {
                setTimeout(animate, 50);
            } else {
                isPlaying = false;
                document.getElementById('playBtn').textContent = 'Play';
            }
        }

        function reset() {
            position = -kernel.length;
            output = new Array(N).fill(0);
            isPlaying = false;
            document.getElementById('playBtn').textContent = 'Play';
            drawAll();
        }

        function drawAll() {
            drawSignal(inputCanvas, input, '#00aaff');
            drawSignal(kernelCanvas, kernel, '#ff6688');
            drawSignal(outputCanvas, output, '#00ffaa');
            drawAnimation();
        }

        function init() {
            [inputCanvas, kernelCanvas, outputCanvas, animCanvas].forEach(resizeCanvas);
            input = generateSignal(document.getElementById('signalType').value);
            kernel = generateKernel(document.getElementById('kernelType').value);
            output = convolve(input, kernel);
            position = N + kernel.length - 1;
            drawAll();
        }

        document.getElementById('signalType').addEventListener('change', () => {
            input = generateSignal(document.getElementById('signalType').value);
            reset();
        });

        document.getElementById('kernelType').addEventListener('change', () => {
            kernel = generateKernel(document.getElementById('kernelType').value);
            reset();
        });

        window.addEventListener('resize', init);
        init();
    </script>
</body>
</html>
