<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectrogram Display - Time-Frequency Representation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #00aaff; min-height: 100vh; padding: 20px;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px; color: #00aaff;
            text-decoration: none; padding: 10px 20px;
            background: rgba(0,170,255,0.1); border: 1px solid #00aaff;
            border-radius: 5px; z-index: 100;
        }
        .container { max-width: 1100px; margin: 60px auto 0; }
        h1 { font-size: 2rem; margin-bottom: 10px; text-align: center; }
        .subtitle { color: #888; margin-bottom: 30px; text-align: center; }
        .main-panel {
            background: rgba(0,0,0,0.5); padding: 20px;
            border-radius: 15px; border: 1px solid #00aaff; margin-bottom: 20px;
        }
        .main-panel h3 { color: #00ccff; margin-bottom: 15px; text-align: center; }
        #waveformCanvas { height: 100px; margin-bottom: 10px; }
        #spectrogramCanvas { height: 300px; }
        canvas { width: 100%; background: rgba(0,20,40,0.5); border-radius: 10px; }
        .controls {
            display: grid; grid-template-columns: repeat(4, 1fr);
            gap: 15px; margin-top: 20px;
        }
        .control-group label { display: block; color: #888; margin-bottom: 5px; font-size: 0.85rem; }
        select, input[type="range"] {
            width: 100%; padding: 8px; font-family: inherit;
            background: rgba(0,170,255,0.1); border: 1px solid #00aaff;
            color: #00aaff; border-radius: 5px;
        }
        input[type="range"] { padding: 0; height: 8px; }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px;
            background: #00aaff; border-radius: 50%; cursor: pointer;
        }
        .value { color: #00ffff; font-size: 0.8rem; margin-top: 3px; }
        .colorbar {
            display: flex; align-items: center; gap: 10px;
            justify-content: center; margin-top: 15px;
        }
        .colorbar-gradient {
            width: 200px; height: 20px; border-radius: 5px;
            background: linear-gradient(to right, #000033, #0066ff, #00ffff, #ffff00, #ff0000);
        }
        .info { background: rgba(0,170,255,0.05); padding: 20px; border-radius: 10px; }
        .info h3 { color: #00ccff; margin-bottom: 10px; }
        .info p { color: #aaa; line-height: 1.6; margin-bottom: 10px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <div class="container">
        <h1>Spectrogram Display</h1>
        <p class="subtitle">See how frequency content changes over time</p>

        <div class="main-panel">
            <h3>Waveform</h3>
            <canvas id="waveformCanvas"></canvas>
            <h3 style="margin-top:15px;">Spectrogram (Time-Frequency)</h3>
            <canvas id="spectrogramCanvas"></canvas>
            <div class="colorbar">
                <span style="color:#888;">-60 dB</span>
                <div class="colorbar-gradient"></div>
                <span style="color:#888;">0 dB</span>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>Signal Type</label>
                    <select id="signal">
                        <option value="chirp">Chirp (Sweep)</option>
                        <option value="tones">Two Tones</option>
                        <option value="speech">Speech-like</option>
                        <option value="fm">FM Signal</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Window Size</label>
                    <select id="windowSize">
                        <option value="64">64 samples</option>
                        <option value="128" selected>128 samples</option>
                        <option value="256">256 samples</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Overlap</label>
                    <input type="range" id="overlap" min="0" max="0.9" value="0.75" step="0.05">
                    <div class="value" id="overlapVal">75%</div>
                </div>
                <div class="control-group">
                    <label>Window Type</label>
                    <select id="windowType">
                        <option value="hann" selected>Hann</option>
                        <option value="hamming">Hamming</option>
                        <option value="rectangular">Rectangular</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="info">
            <h3>Understanding Spectrograms</h3>
            <p><strong>X-axis:</strong> Time - the horizontal position shows when a frequency occurs</p>
            <p><strong>Y-axis:</strong> Frequency - the vertical position shows which frequencies are present</p>
            <p><strong>Color:</strong> Intensity - brighter colors indicate stronger energy at that time-frequency point</p>
            <p><strong>Trade-off:</strong> Larger window = better frequency resolution but poorer time resolution. Smaller window = opposite. This is Heisenberg's uncertainty principle in action!</p>
        </div>
    </div>

    <script>
        const waveformCanvas = document.getElementById('waveformCanvas');
        const spectrogramCanvas = document.getElementById('spectrogramCanvas');

        const N = 2048;
        const sampleRate = 1000;

        function resizeCanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.getContext('2d').scale(dpr, dpr);
        }

        function generateSignal(type) {
            const sig = [];
            for (let i = 0; i < N; i++) {
                const t = i / sampleRate;
                switch (type) {
                    case 'chirp':
                        sig.push(Math.sin(2 * Math.PI * (50 + 200 * t) * t));
                        break;
                    case 'tones':
                        sig.push(t < 1 ?
                            Math.sin(2 * Math.PI * 100 * t) :
                            Math.sin(2 * Math.PI * 200 * t));
                        break;
                    case 'speech':
                        const f1 = 80 + 50 * Math.sin(2 * Math.PI * 2 * t);
                        const f2 = 200 + 100 * Math.sin(2 * Math.PI * 3 * t);
                        sig.push(0.5 * Math.sin(2 * Math.PI * f1 * t) +
                                0.3 * Math.sin(2 * Math.PI * f2 * t) +
                                0.2 * (Math.random() - 0.5));
                        break;
                    case 'fm':
                        sig.push(Math.sin(2 * Math.PI * (150 + 50 * Math.sin(2 * Math.PI * 5 * t)) * t));
                        break;
                }
            }
            return sig;
        }

        function getWindow(type, size) {
            const w = [];
            for (let n = 0; n < size; n++) {
                switch (type) {
                    case 'hann':
                        w.push(0.5 * (1 - Math.cos(2 * Math.PI * n / (size - 1))));
                        break;
                    case 'hamming':
                        w.push(0.54 - 0.46 * Math.cos(2 * Math.PI * n / (size - 1)));
                        break;
                    case 'rectangular':
                        w.push(1);
                        break;
                }
            }
            return w;
        }

        function fft(data) {
            const n = data.length;
            if (n <= 1) return data.map(x => ({ re: x, im: 0 }));

            const even = fft(data.filter((_, i) => i % 2 === 0));
            const odd = fft(data.filter((_, i) => i % 2 === 1));

            const result = [];
            for (let k = 0; k < n / 2; k++) {
                const angle = -2 * Math.PI * k / n;
                const t = {
                    re: Math.cos(angle) * odd[k].re - Math.sin(angle) * odd[k].im,
                    im: Math.cos(angle) * odd[k].im + Math.sin(angle) * odd[k].re
                };
                result[k] = { re: even[k].re + t.re, im: even[k].im + t.im };
                result[k + n / 2] = { re: even[k].re - t.re, im: even[k].im - t.im };
            }
            return result;
        }

        function computeSpectrogram(signal, windowSize, overlap, windowType) {
            const hopSize = Math.floor(windowSize * (1 - overlap));
            const window = getWindow(windowType, windowSize);
            const spectrogram = [];

            for (let start = 0; start + windowSize <= signal.length; start += hopSize) {
                const segment = [];
                for (let i = 0; i < windowSize; i++) {
                    segment.push(signal[start + i] * window[i]);
                }

                // Pad to power of 2
                while (segment.length < windowSize) segment.push(0);

                const spectrum = fft(segment);
                const magnitudes = spectrum.slice(0, windowSize / 2).map(c =>
                    Math.sqrt(c.re * c.re + c.im * c.im)
                );
                spectrogram.push(magnitudes);
            }

            return spectrogram;
        }

        function valueToColor(val, min, max) {
            const normalized = (val - min) / (max - min);
            const hue = (1 - normalized) * 240; // Blue to red
            return `hsl(${hue}, 100%, ${20 + normalized * 50}%)`;
        }

        function drawWaveform(signal) {
            const ctx = waveformCanvas.getContext('2d');
            const w = waveformCanvas.width / (window.devicePixelRatio || 1);
            const h = waveformCanvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            ctx.strokeStyle = '#00aaff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i < signal.length; i++) {
                const x = (i / signal.length) * w;
                const y = h / 2 - signal[i] * (h * 0.45);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function drawSpectrogram(spectrogram) {
            const ctx = spectrogramCanvas.getContext('2d');
            const w = spectrogramCanvas.width / (window.devicePixelRatio || 1);
            const h = spectrogramCanvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            if (spectrogram.length === 0) return;

            // Convert to dB
            const dbSpec = spectrogram.map(col =>
                col.map(val => 20 * Math.log10(val + 1e-10))
            );

            const allValues = dbSpec.flat();
            const maxDb = Math.max(...allValues);
            const minDb = maxDb - 60;

            const binWidth = w / spectrogram.length;
            const binHeight = h / spectrogram[0].length;

            for (let t = 0; t < spectrogram.length; t++) {
                for (let f = 0; f < spectrogram[t].length; f++) {
                    const db = Math.max(minDb, dbSpec[t][f]);
                    ctx.fillStyle = valueToColor(db, minDb, maxDb);
                    ctx.fillRect(
                        t * binWidth,
                        h - (f + 1) * binHeight,
                        binWidth + 1,
                        binHeight + 1
                    );
                }
            }

            // Frequency axis labels
            ctx.fillStyle = '#888';
            ctx.font = '10px Courier New';
            ctx.fillText('0 Hz', 5, h - 5);
            ctx.fillText(`${sampleRate / 2} Hz`, 5, 15);
        }

        function update() {
            const signalType = document.getElementById('signal').value;
            const windowSize = parseInt(document.getElementById('windowSize').value);
            const overlap = parseFloat(document.getElementById('overlap').value);
            const windowType = document.getElementById('windowType').value;

            document.getElementById('overlapVal').textContent = Math.round(overlap * 100) + '%';

            const signal = generateSignal(signalType);
            const spectrogram = computeSpectrogram(signal, windowSize, overlap, windowType);

            drawWaveform(signal);
            drawSpectrogram(spectrogram);
        }

        function init() {
            resizeCanvas(waveformCanvas);
            resizeCanvas(spectrogramCanvas);
            update();
        }

        ['signal', 'windowSize', 'overlap', 'windowType'].forEach(id => {
            document.getElementById(id).addEventListener('input', update);
            document.getElementById(id).addEventListener('change', update);
        });

        window.addEventListener('resize', init);
        init();
    </script>
</body>
</html>
