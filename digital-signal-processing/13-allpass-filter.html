<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>All-Pass Filter - Phase Modification</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #00aaff; min-height: 100vh; padding: 20px;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px; color: #00aaff;
            text-decoration: none; padding: 10px 20px;
            background: rgba(0,170,255,0.1); border: 1px solid #00aaff;
            border-radius: 5px; z-index: 100;
        }
        .container { max-width: 1100px; margin: 60px auto 0; }
        h1 { font-size: 2rem; margin-bottom: 10px; text-align: center; }
        .subtitle { color: #888; margin-bottom: 30px; text-align: center; }
        .viz-grid {
            display: grid; grid-template-columns: 1fr 1fr;
            gap: 20px; margin-bottom: 30px;
        }
        .panel {
            background: rgba(0,0,0,0.5); padding: 20px;
            border-radius: 15px; border: 1px solid #00aaff;
        }
        .panel h3 { color: #00ccff; margin-bottom: 15px; text-align: center; }
        canvas { width: 100%; height: 200px; background: rgba(0,20,40,0.5); border-radius: 10px; }
        .controls {
            background: rgba(0,170,255,0.05); padding: 20px;
            border-radius: 15px; margin-bottom: 30px;
        }
        .control-row {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 30px;
        }
        .control-group label { display: block; color: #888; margin-bottom: 8px; }
        input[type="range"] {
            width: 100%; height: 8px; background: rgba(0,170,255,0.2); border-radius: 4px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px;
            background: #00aaff; border-radius: 50%; cursor: pointer;
        }
        .value { color: #00ffff; font-size: 0.95rem; margin-top: 5px; }
        .info { background: rgba(0,170,255,0.05); padding: 20px; border-radius: 10px; }
        .info h3 { color: #00ccff; margin-bottom: 10px; }
        .info p { color: #aaa; line-height: 1.6; margin-bottom: 10px; }
        .formula {
            background: rgba(0,0,0,0.3); padding: 15px;
            border-radius: 5px; text-align: center;
            font-size: 1.1rem; margin: 15px 0;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div class="container">
        <h1>All-Pass Filter</h1>
        <p class="subtitle">Unity magnitude at all frequencies - only phase changes</p>

        <div class="controls">
            <div class="control-row">
                <div class="control-group">
                    <label>Pole Radius (r)</label>
                    <input type="range" id="radius" min="0.1" max="0.95" value="0.8" step="0.05">
                    <div class="value" id="radiusVal">r = 0.80</div>
                </div>
                <div class="control-group">
                    <label>Pole Angle (θ)</label>
                    <input type="range" id="angle" min="0" max="3.14" value="1.57" step="0.1">
                    <div class="value" id="angleVal">θ = 1.57 rad (π/2)</div>
                </div>
            </div>
        </div>

        <div class="viz-grid">
            <div class="panel">
                <h3>Magnitude Response |H(e^jω)|</h3>
                <canvas id="magCanvas"></canvas>
            </div>
            <div class="panel">
                <h3>Phase Response ∠H(e^jω)</h3>
                <canvas id="phaseCanvas"></canvas>
            </div>
            <div class="panel">
                <h3>Group Delay τ(ω)</h3>
                <canvas id="delayCanvas"></canvas>
            </div>
            <div class="panel">
                <h3>Pole-Zero Plot</h3>
                <canvas id="pzCanvas"></canvas>
            </div>
        </div>

        <div class="formula">
            H(z) = (z⁻¹ - r·e^(jθ)) / (1 - r·e^(-jθ)·z⁻¹) × (z⁻¹ - r·e^(-jθ)) / (1 - r·e^(jθ)·z⁻¹)
        </div>

        <div class="info">
            <h3>All-Pass Filter Properties</h3>
            <p><strong>Unity Magnitude:</strong> The magnitude response is exactly 1 at all frequencies. The filter only changes the phase of the signal.</p>
            <p><strong>Mirror Poles and Zeros:</strong> For each pole at z = r·e^(jθ), there's a zero at z = (1/r)·e^(jθ). This creates the unity magnitude property.</p>
            <p><strong>Group Delay:</strong> The rate of phase change varies with frequency. Higher pole radius = more concentrated delay near the pole frequency.</p>
            <p><strong>Applications:</strong> Phase equalization, audio effects (phaser), group delay compensation, building blocks for other filters.</p>
        </div>
    </div>

    <script>
        const magCanvas = document.getElementById('magCanvas');
        const phaseCanvas = document.getElementById('phaseCanvas');
        const delayCanvas = document.getElementById('delayCanvas');
        const pzCanvas = document.getElementById('pzCanvas');

        function resizeCanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.getContext('2d').scale(dpr, dpr);
        }

        function allpassResponse(omega, r, theta) {
            // H(z) for second-order allpass with conjugate poles
            const cosTheta = Math.cos(theta);
            const cosOmega = Math.cos(omega);
            const sinOmega = Math.sin(omega);

            // Numerator: z^(-2) - 2r*cos(theta)*z^(-1) + r^2
            const numRe = Math.cos(-2 * omega) - 2 * r * cosTheta * Math.cos(-omega) + r * r;
            const numIm = Math.sin(-2 * omega) - 2 * r * cosTheta * Math.sin(-omega);

            // Denominator: 1 - 2r*cos(theta)*z^(-1) + r^2*z^(-2)
            const denRe = 1 - 2 * r * cosTheta * cosOmega + r * r * Math.cos(-2 * omega);
            const denIm = 2 * r * cosTheta * sinOmega + r * r * Math.sin(-2 * omega);

            const numMag = Math.sqrt(numRe * numRe + numIm * numIm);
            const denMag = Math.sqrt(denRe * denRe + denIm * denIm);
            const mag = numMag / denMag;

            const numPhase = Math.atan2(numIm, numRe);
            const denPhase = Math.atan2(denIm, denRe);
            const phase = numPhase - denPhase;

            return { mag, phase };
        }

        function drawMagnitude() {
            const ctx = magCanvas.getContext('2d');
            const w = magCanvas.width / (window.devicePixelRatio || 1);
            const h = magCanvas.height / (window.devicePixelRatio || 1);

            const r = parseFloat(document.getElementById('radius').value);
            const theta = parseFloat(document.getElementById('angle').value);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            // Grid
            ctx.strokeStyle = 'rgba(0,170,255,0.1)';
            for (let i = 0; i <= 4; i++) {
                ctx.beginPath();
                ctx.moveTo(0, h * i / 4);
                ctx.lineTo(w, h * i / 4);
                ctx.stroke();
            }

            // Response
            ctx.strokeStyle = '#00ffaa';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = 0; x < w; x++) {
                const omega = (x / w) * Math.PI;
                const { mag } = allpassResponse(omega, r, theta);
                const y = h - mag * h * 0.9;
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.fillText('1.0', 5, h * 0.1 + 10);
            ctx.fillText('0', 5, h - 5);
            ctx.fillText('Unity magnitude at all frequencies', w / 2 - 100, 20);
        }

        function drawPhase() {
            const ctx = phaseCanvas.getContext('2d');
            const w = phaseCanvas.width / (window.devicePixelRatio || 1);
            const h = phaseCanvas.height / (window.devicePixelRatio || 1);

            const r = parseFloat(document.getElementById('radius').value);
            const theta = parseFloat(document.getElementById('angle').value);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            ctx.strokeStyle = 'rgba(0,170,255,0.2)';
            ctx.beginPath();
            ctx.moveTo(0, h / 2);
            ctx.lineTo(w, h / 2);
            ctx.stroke();

            // Unwrap phase
            let prevPhase = 0;
            let offset = 0;

            ctx.strokeStyle = '#ff6688';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = 0; x < w; x++) {
                const omega = (x / w) * Math.PI;
                let { phase } = allpassResponse(omega, r, theta);

                // Simple unwrapping
                while (phase - prevPhase > Math.PI) phase -= 2 * Math.PI;
                while (phase - prevPhase < -Math.PI) phase += 2 * Math.PI;
                prevPhase = phase;

                const y = h / 2 - (phase / (2 * Math.PI)) * h * 0.8;
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.fillText('+π', 5, 15);
            ctx.fillText('-π', 5, h - 5);

            // Mark pole frequency
            const poleX = (theta / Math.PI) * w;
            ctx.strokeStyle = 'rgba(255,170,0,0.5)';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(poleX, 0);
            ctx.lineTo(poleX, h);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawGroupDelay() {
            const ctx = delayCanvas.getContext('2d');
            const w = delayCanvas.width / (window.devicePixelRatio || 1);
            const h = delayCanvas.height / (window.devicePixelRatio || 1);

            const r = parseFloat(document.getElementById('radius').value);
            const theta = parseFloat(document.getElementById('angle').value);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            // Compute group delay numerically
            const delays = [];
            const dw = 0.01;
            for (let x = 0; x < w; x++) {
                const omega = (x / w) * Math.PI;
                const { phase: phase1 } = allpassResponse(omega, r, theta);
                const { phase: phase2 } = allpassResponse(omega + dw, r, theta);
                let delay = -(phase2 - phase1) / dw;
                delays.push(delay);
            }

            const maxDelay = Math.max(...delays);

            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = 0; x < w; x++) {
                const y = h - (delays[x] / maxDelay) * h * 0.85;
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Mark pole frequency
            const poleX = (theta / Math.PI) * w;
            ctx.strokeStyle = 'rgba(255,170,0,0.5)';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(poleX, 0);
            ctx.lineTo(poleX, h);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#888';
            ctx.font = '11px Courier New';
            ctx.fillText('Group Delay (samples)', 10, 20);
            ctx.fillText(`Peak at θ = ${theta.toFixed(2)}`, poleX + 5, 35);
        }

        function drawPoleZero() {
            const ctx = pzCanvas.getContext('2d');
            const w = pzCanvas.width / (window.devicePixelRatio || 1);
            const h = pzCanvas.height / (window.devicePixelRatio || 1);

            const r = parseFloat(document.getElementById('radius').value);
            const theta = parseFloat(document.getElementById('angle').value);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            const cx = w / 2, cy = h / 2;
            const scale = Math.min(w, h) * 0.35;

            // Unit circle
            ctx.strokeStyle = '#00aaff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(cx, cy, scale, 0, Math.PI * 2);
            ctx.stroke();

            // Axes
            ctx.strokeStyle = 'rgba(0,170,255,0.3)';
            ctx.beginPath();
            ctx.moveTo(0, cy);
            ctx.lineTo(w, cy);
            ctx.moveTo(cx, 0);
            ctx.lineTo(cx, h);
            ctx.stroke();

            // Poles (inside unit circle)
            [[r, theta], [r, -theta]].forEach(([radius, angle]) => {
                const x = cx + radius * Math.cos(angle) * scale;
                const y = cy - radius * Math.sin(angle) * scale;
                ctx.strokeStyle = '#ff6688';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x - 7, y - 7);
                ctx.lineTo(x + 7, y + 7);
                ctx.moveTo(x + 7, y - 7);
                ctx.lineTo(x - 7, y + 7);
                ctx.stroke();
            });

            // Zeros (outside unit circle, mirrored)
            [[1/r, theta], [1/r, -theta]].forEach(([radius, angle]) => {
                const drawRadius = Math.min(radius, 1.3) * scale;
                const x = cx + Math.cos(angle) * drawRadius;
                const y = cy - Math.sin(angle) * drawRadius;
                ctx.strokeStyle = '#00ffaa';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.stroke();
            });

            ctx.fillStyle = '#888';
            ctx.font = '10px Courier New';
            ctx.fillText('Zeros at 1/r (outside)', 10, h - 10);
        }

        function update() {
            const r = document.getElementById('radius').value;
            const theta = document.getElementById('angle').value;

            document.getElementById('radiusVal').textContent = `r = ${parseFloat(r).toFixed(2)}`;
            document.getElementById('angleVal').textContent =
                `θ = ${parseFloat(theta).toFixed(2)} rad`;

            drawMagnitude();
            drawPhase();
            drawGroupDelay();
            drawPoleZero();
        }

        function init() {
            [magCanvas, phaseCanvas, delayCanvas, pzCanvas].forEach(resizeCanvas);
            update();
        }

        ['radius', 'angle'].forEach(id => {
            document.getElementById(id).addEventListener('input', update);
        });

        window.addEventListener('resize', init);
        init();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
