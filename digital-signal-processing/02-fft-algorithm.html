<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FFT Algorithm Animation - Butterfly Operations</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #00aaff;
            min-height: 100vh;
            padding: 20px;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00aaff;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(0,170,255,0.1);
            border: 1px solid #00aaff;
            border-radius: 5px;
            z-index: 100;
        }
        .back-link:hover { background: rgba(0,170,255,0.2); }
        .container {
            max-width: 1200px;
            margin: 60px auto 0;
        }
        h1 { font-size: 2rem; margin-bottom: 10px; text-align: center; }
        .subtitle { color: #888; margin-bottom: 30px; text-align: center; }
        .main-viz {
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid #00aaff;
            margin-bottom: 30px;
        }
        canvas {
            width: 100%;
            height: 500px;
            background: rgba(0,20,40,0.5);
            border-radius: 10px;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            backdrop-filter: blur(10px);
        }
        button {
            padding: 12px 30px;
            font-family: inherit;
            font-size: 1rem;
            background: rgba(0,170,255,0.1);
            border: 1px solid #00aaff;
            color: #00aaff;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover { background: rgba(0,170,255,0.3); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .stage-info {
            text-align: center;
            margin-top: 15px;
            padding: 15px;
            background: rgba(0,170,255,0.1);
            border-radius: 10px;
        }
        .stage-info h4 { color: #00ffff; margin-bottom: 5px; }
        .complexity {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        .complexity-box {
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        .complexity-box h4 { color: #00ccff; margin-bottom: 10px; }
        .complexity-value { font-size: 2rem; color: #00ffff; }
        .complexity-label { color: #888; font-size: 0.9rem; }
        .info {
            background: rgba(0,170,255,0.05);
            padding: 20px;
            border-radius: 10px;
        }
        .info h3 { color: #00ccff; margin-bottom: 10px; }
        .info p { color: #aaa; line-height: 1.6; margin-bottom: 10px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div class="container">
        <h1>FFT Algorithm Animation</h1>
        <p class="subtitle">Watch the Cooley-Tukey butterfly operations in action</p>

        <div class="complexity">
            <div class="complexity-box">
                <h4>DFT Complexity</h4>
                <div class="complexity-value">O(N²)</div>
                <div class="complexity-label">N = 8: 64 operations</div>
            </div>
            <div class="complexity-box">
                <h4>FFT Complexity</h4>
                <div class="complexity-value">O(N log N)</div>
                <div class="complexity-label">N = 8: 24 operations</div>
            </div>
        </div>

        <div class="main-viz">
            <canvas id="fftCanvas"></canvas>
            <div class="controls">
                <button onclick="reset()">Reset</button>
                <button onclick="step()" id="stepBtn">Step Forward</button>
                <button onclick="runAnimation()" id="runBtn">Run Animation</button>
            </div>
            <div class="stage-info">
                <h4 id="stageTitle">Stage 0: Input (Bit-Reversed Order)</h4>
                <p id="stageDesc">Input values are reordered using bit-reversal permutation</p>
            </div>
        </div>

        <div class="info">
            <h3>The Fast Fourier Transform</h3>
            <p>The FFT reduces the complexity of computing the Discrete Fourier Transform from O(N²) to O(N log N) by exploiting symmetries in the calculation.</p>
            <p><strong>Butterfly Operation:</strong> The core of the FFT. Two values are combined using a twiddle factor (W): output₁ = input₁ + W·input₂, output₂ = input₁ - W·input₂</p>
            <p><strong>Stages:</strong> For N points, there are log₂(N) stages. Each stage performs N/2 butterfly operations.</p>
            <p><strong>Bit-Reversal:</strong> Input indices are reordered by reversing their binary representation before processing.</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('fftCanvas');
        const ctx = canvas.getContext('2d');
        const N = 8;
        const stages = Math.log2(N);

        let currentStage = 0;
        let currentButterfly = 0;
        let isAnimating = false;
        let animationId = null;

        // Sample input values
        let values = [1, 0, 1, 0, 0, 1, 0, 1];
        let displayValues = [...values];

        // Bit reversal permutation
        function bitReverse(n, bits) {
            let reversed = 0;
            for (let i = 0; i < bits; i++) {
                reversed = (reversed << 1) | (n & 1);
                n >>= 1;
            }
            return reversed;
        }

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            draw();
        }

        function draw() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            const stageWidth = w / (stages + 2);
            const nodeSpacing = h / (N + 1);

            // Draw stage labels
            ctx.fillStyle = '#666';
            ctx.font = '14px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('Input', stageWidth, 30);
            for (let s = 0; s < stages; s++) {
                ctx.fillText(`Stage ${s + 1}`, stageWidth * (s + 2), 30);
            }
            ctx.fillText('Output', stageWidth * (stages + 1), 30);

            // Draw nodes for each stage
            for (let stage = 0; stage <= stages; stage++) {
                const x = stageWidth * (stage + 1);

                for (let i = 0; i < N; i++) {
                    const y = nodeSpacing * (i + 1);

                    // Node circle
                    ctx.beginPath();
                    ctx.arc(x, y, 20, 0, Math.PI * 2);

                    if (stage <= currentStage) {
                        ctx.fillStyle = 'rgba(0,170,255,0.3)';
                        ctx.fill();
                        ctx.strokeStyle = '#00aaff';
                    } else {
                        ctx.fillStyle = 'rgba(100,100,100,0.2)';
                        ctx.fill();
                        ctx.strokeStyle = '#444';
                    }
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Value text
                    if (stage === 0) {
                        const idx = bitReverse(i, stages);
                        ctx.fillStyle = stage <= currentStage ? '#fff' : '#666';
                        ctx.font = '12px Courier New';
                        ctx.fillText(values[idx].toFixed(1), x, y + 4);
                    } else if (stage <= currentStage) {
                        ctx.fillStyle = '#fff';
                        ctx.font = '11px Courier New';
                        ctx.fillText(displayValues[i].toFixed(1), x, y + 4);
                    }
                }
            }

            // Draw butterfly connections
            for (let stage = 0; stage < stages; stage++) {
                const xStart = stageWidth * (stage + 1);
                const xEnd = stageWidth * (stage + 2);
                const butterflySize = Math.pow(2, stage + 1);
                const halfSize = butterflySize / 2;

                for (let group = 0; group < N / butterflySize; group++) {
                    for (let k = 0; k < halfSize; k++) {
                        const i1 = group * butterflySize + k;
                        const i2 = i1 + halfSize;

                        const y1Start = nodeSpacing * (i1 + 1);
                        const y2Start = nodeSpacing * (i2 + 1);
                        const y1End = nodeSpacing * (i1 + 1);
                        const y2End = nodeSpacing * (i2 + 1);

                        const isActive = stage < currentStage ||
                            (stage === currentStage && (group * halfSize + k) <= currentButterfly);

                        ctx.strokeStyle = isActive ? '#00aaff' : 'rgba(100,100,100,0.3)';
                        ctx.lineWidth = isActive ? 2 : 1;

                        // Draw butterfly pattern
                        ctx.beginPath();
                        ctx.moveTo(xStart + 20, y1Start);
                        ctx.lineTo(xEnd - 20, y1End);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(xStart + 20, y2Start);
                        ctx.lineTo(xEnd - 20, y1End);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(xStart + 20, y1Start);
                        ctx.lineTo(xEnd - 20, y2End);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(xStart + 20, y2Start);
                        ctx.lineTo(xEnd - 20, y2End);
                        ctx.stroke();

                        // Twiddle factor label
                        if (isActive) {
                            const angle = -2 * Math.PI * k / butterflySize;
                            const midX = (xStart + xEnd) / 2;
                            const midY = (y1Start + y2Start) / 2;
                            ctx.fillStyle = '#00ffff';
                            ctx.font = '10px Courier New';
                            ctx.fillText(`W${k}`, midX, midY);
                        }
                    }
                }
            }
        }

        function step() {
            if (currentStage >= stages) return;

            const butterflySize = Math.pow(2, currentStage + 1);
            const halfSize = butterflySize / 2;
            const numButterflies = N / 2;

            currentButterfly++;

            if (currentButterfly >= halfSize * (N / butterflySize)) {
                // Complete the stage computation
                const newValues = [...displayValues];
                for (let group = 0; group < N / butterflySize; group++) {
                    for (let k = 0; k < halfSize; k++) {
                        const i1 = group * butterflySize + k;
                        const i2 = i1 + halfSize;
                        const angle = -2 * Math.PI * k / butterflySize;
                        const wr = Math.cos(angle);
                        const wi = Math.sin(angle);

                        const temp = displayValues[i1];
                        const twiddle = displayValues[i2] * wr;
                        newValues[i1] = temp + twiddle;
                        newValues[i2] = temp - twiddle;
                    }
                }
                displayValues = newValues;
                currentStage++;
                currentButterfly = 0;
            }

            updateStageInfo();
            draw();

            if (currentStage >= stages) {
                document.getElementById('stepBtn').disabled = true;
                document.getElementById('runBtn').disabled = true;
            }
        }

        function runAnimation() {
            if (isAnimating) {
                isAnimating = false;
                document.getElementById('runBtn').textContent = 'Run Animation';
                return;
            }

            isAnimating = true;
            document.getElementById('runBtn').textContent = 'Pause';

            function animate() {
                if (!isAnimating || currentStage >= stages) {
                    isAnimating = false;
                    document.getElementById('runBtn').textContent = 'Run Animation';
                    return;
                }
                step();
                animationId = setTimeout(animate, 300);
            }
            animate();
        }

        function reset() {
            currentStage = 0;
            currentButterfly = 0;
            isAnimating = false;
            displayValues = [...values];
            document.getElementById('stepBtn').disabled = false;
            document.getElementById('runBtn').disabled = false;
            document.getElementById('runBtn').textContent = 'Run Animation';
            updateStageInfo();
            draw();
        }

        function updateStageInfo() {
            const title = document.getElementById('stageTitle');
            const desc = document.getElementById('stageDesc');

            if (currentStage === 0 && currentButterfly === 0) {
                title.textContent = 'Stage 0: Input (Bit-Reversed Order)';
                desc.textContent = 'Input values are reordered using bit-reversal permutation';
            } else if (currentStage < stages) {
                title.textContent = `Stage ${currentStage + 1}: Butterfly ${currentButterfly} of ${N/2}`;
                desc.textContent = `Combining pairs with distance ${Math.pow(2, currentStage)} using twiddle factors`;
            } else {
                title.textContent = 'Complete: Output (Frequency Domain)';
                desc.textContent = 'FFT computation finished - values represent frequency components';
            }
        }

        // Expose functions for enhance.js keyboard shortcuts
        window.reset = resizeCanvas;

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
