<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IIR Filter Poles & Zeros - Stability Analysis</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #00aaff;
            min-height: 100vh;
            padding: 20px;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00aaff;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(0,170,255,0.1);
            border: 1px solid #00aaff;
            border-radius: 5px;
            z-index: 100;
        }
        .back-link:hover { background: rgba(0,170,255,0.2); }
        .container {
            max-width: 1200px;
            margin: 60px auto 0;
        }
        h1 { font-size: 2rem; margin-bottom: 10px; text-align: center; }
        .subtitle { color: #888; margin-bottom: 30px; text-align: center; }
        .main-grid {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        .pz-panel {
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid #00aaff;
        }
        .pz-panel h3 { color: #00ccff; margin-bottom: 15px; text-align: center; }
        #pzCanvas {
            width: 100%;
            height: 360px;
            background: rgba(0,20,40,0.5);
            border-radius: 10px;
            cursor: crosshair;
        }
        .response-panel {
            display: grid;
            grid-template-rows: 1fr 1fr;
            gap: 20px;
        }
        .panel {
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid #00aaff;
        }
        .panel h3 { color: #00ccff; margin-bottom: 15px; text-align: center; }
        canvas {
            width: 100%;
            height: 150px;
            background: rgba(0,20,40,0.5);
            border-radius: 10px;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 20px;
            font-family: inherit;
            background: rgba(0,170,255,0.1);
            border: 1px solid #00aaff;
            color: #00aaff;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover { background: rgba(0,170,255,0.3); }
        button.active { background: rgba(0,170,255,0.4); }
        .stability-indicator {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-size: 1.2rem;
        }
        .stable { background: rgba(0,255,136,0.2); color: #00ff88; border: 1px solid #00ff88; }
        .unstable { background: rgba(255,68,68,0.2); color: #ff4444; border: 1px solid #ff4444; }
        .info {
            background: rgba(0,170,255,0.05);
            padding: 20px;
            border-radius: 10px;
        }
        .info h3 { color: #00ccff; margin-bottom: 10px; }
        .info p { color: #aaa; line-height: 1.6; margin-bottom: 10px; }
        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 10px;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; }
        @media (max-width: 900px) {
            .main-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <div class="container">
        <h1>IIR Filter Poles & Zeros</h1>
        <p class="subtitle">Click to place poles (×) and zeros (○) on the z-plane</p>

        <div class="main-grid">
            <div class="pz-panel">
                <h3>Pole-Zero Plot (z-plane)</h3>
                <canvas id="pzCanvas"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <span style="color:#ff6688; font-size:1.5rem;">×</span>
                        <span>Poles</span>
                    </div>
                    <div class="legend-item">
                        <span style="color:#00ffaa; font-size:1.5rem;">○</span>
                        <span>Zeros</span>
                    </div>
                </div>
                <div class="controls">
                    <button onclick="setMode('pole')" id="btnPole" class="active">Add Pole</button>
                    <button onclick="setMode('zero')" id="btnZero">Add Zero</button>
                    <button onclick="clearAll()">Clear All</button>
                    <button onclick="loadPreset('lowpass')">LP Preset</button>
                    <button onclick="loadPreset('notch')">Notch</button>
                </div>
                <div class="stability-indicator stable" id="stability">
                    ✓ STABLE - All poles inside unit circle
                </div>
            </div>

            <div class="response-panel">
                <div class="panel">
                    <h3>Magnitude Response |H(e^jω)|</h3>
                    <canvas id="magCanvas"></canvas>
                </div>
                <div class="panel">
                    <h3>Phase Response ∠H(e^jω)</h3>
                    <canvas id="phaseCanvas"></canvas>
                </div>
            </div>
        </div>

        <div class="info">
            <h3>Understanding IIR Filters</h3>
            <p><strong>Infinite Impulse Response:</strong> IIR filters have feedback, so their impulse response theoretically lasts forever (though it decays for stable filters).</p>
            <p><strong>Poles (×):</strong> Locations where the transfer function goes to infinity. Create peaks in the frequency response. Must be inside the unit circle for stability.</p>
            <p><strong>Zeros (○):</strong> Locations where the transfer function goes to zero. Create notches in the frequency response. Can be anywhere.</p>
            <p><strong>Stability Rule:</strong> A digital IIR filter is stable if and only if all poles lie strictly inside the unit circle |z| < 1.</p>
        </div>
    </div>

    <script>
        const pzCanvas = document.getElementById('pzCanvas');
        const magCanvas = document.getElementById('magCanvas');
        const phaseCanvas = document.getElementById('phaseCanvas');
        const pzCtx = pzCanvas.getContext('2d');

        let poles = [];
        let zeros = [];
        let mode = 'pole';

        function resizeCanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.getContext('2d').scale(dpr, dpr);
        }

        function canvasToComplex(x, y, canvas) {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            const scale = Math.min(w, h) / 2.4;
            return {
                re: (x - w / 2) / scale,
                im: -(y - h / 2) / scale
            };
        }

        function complexToCanvas(re, im, canvas) {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            const scale = Math.min(w, h) / 2.4;
            return {
                x: w / 2 + re * scale,
                y: h / 2 - im * scale
            };
        }

        function drawPZPlot() {
            const w = pzCanvas.width / (window.devicePixelRatio || 1);
            const h = pzCanvas.height / (window.devicePixelRatio || 1);

            pzCtx.fillStyle = 'rgba(0,20,40,0.5)';
            pzCtx.fillRect(0, 0, w, h);

            const scale = Math.min(w, h) / 2.4;
            const cx = w / 2, cy = h / 2;

            // Grid
            pzCtx.strokeStyle = 'rgba(0,170,255,0.1)';
            pzCtx.lineWidth = 1;
            pzCtx.beginPath();
            pzCtx.moveTo(0, cy);
            pzCtx.lineTo(w, cy);
            pzCtx.moveTo(cx, 0);
            pzCtx.lineTo(cx, h);
            pzCtx.stroke();

            // Unit circle
            pzCtx.strokeStyle = '#00aaff';
            pzCtx.lineWidth = 2;
            pzCtx.beginPath();
            pzCtx.arc(cx, cy, scale, 0, Math.PI * 2);
            pzCtx.stroke();

            // Labels
            pzCtx.fillStyle = '#888';
            pzCtx.font = '12px Courier New';
            pzCtx.fillText('Re', w - 25, cy - 5);
            pzCtx.fillText('Im', cx + 5, 15);
            pzCtx.fillText('1', cx + scale - 5, cy + 15);
            pzCtx.fillText('-1', cx - scale - 15, cy + 15);

            // Draw zeros
            zeros.forEach(z => {
                const pos = complexToCanvas(z.re, z.im, pzCanvas);
                pzCtx.strokeStyle = '#00ffaa';
                pzCtx.lineWidth = 3;
                pzCtx.beginPath();
                pzCtx.arc(pos.x, pos.y, 10, 0, Math.PI * 2);
                pzCtx.stroke();
            });

            // Draw poles
            poles.forEach(p => {
                const pos = complexToCanvas(p.re, p.im, pzCanvas);
                pzCtx.strokeStyle = '#ff6688';
                pzCtx.lineWidth = 3;
                pzCtx.beginPath();
                pzCtx.moveTo(pos.x - 8, pos.y - 8);
                pzCtx.lineTo(pos.x + 8, pos.y + 8);
                pzCtx.moveTo(pos.x + 8, pos.y - 8);
                pzCtx.lineTo(pos.x - 8, pos.y + 8);
                pzCtx.stroke();
            });
        }

        function computeResponse() {
            const numPoints = 256;
            const mag = new Array(numPoints);
            const phase = new Array(numPoints);

            for (let k = 0; k < numPoints; k++) {
                const omega = Math.PI * k / numPoints;
                const ejw = { re: Math.cos(omega), im: Math.sin(omega) };

                // H(z) = product of (z - zeros) / product of (z - poles)
                let numRe = 1, numIm = 0;
                let denRe = 1, denIm = 0;

                zeros.forEach(z => {
                    const diffRe = ejw.re - z.re;
                    const diffIm = ejw.im - z.im;
                    const newRe = numRe * diffRe - numIm * diffIm;
                    const newIm = numRe * diffIm + numIm * diffRe;
                    numRe = newRe;
                    numIm = newIm;
                });

                poles.forEach(p => {
                    const diffRe = ejw.re - p.re;
                    const diffIm = ejw.im - p.im;
                    const newRe = denRe * diffRe - denIm * diffIm;
                    const newIm = denRe * diffIm + denIm * diffRe;
                    denRe = newRe;
                    denIm = newIm;
                });

                // Complex division
                const denMag = denRe * denRe + denIm * denIm;
                const hRe = (numRe * denRe + numIm * denIm) / (denMag + 1e-10);
                const hIm = (numIm * denRe - numRe * denIm) / (denMag + 1e-10);

                mag[k] = Math.sqrt(hRe * hRe + hIm * hIm);
                phase[k] = Math.atan2(hIm, hRe);
            }

            return { mag, phase };
        }

        function drawMagnitude(mag) {
            const ctx = magCanvas.getContext('2d');
            const w = magCanvas.width / (window.devicePixelRatio || 1);
            const h = magCanvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            const maxMag = Math.max(...mag, 0.01);
            const dbMax = 20;
            const dbMin = -60;

            // Grid
            ctx.strokeStyle = 'rgba(0,170,255,0.1)';
            ctx.fillStyle = '#666';
            ctx.font = '10px Courier New';
            for (let db = 0; db >= dbMin; db -= 20) {
                const y = ((dbMax - db) / (dbMax - dbMin)) * h;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
                ctx.fillText(`${db}dB`, 5, y - 3);
            }

            ctx.strokeStyle = '#00ffaa';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < mag.length; i++) {
                const x = (i / mag.length) * w;
                let db = 20 * Math.log10(mag[i] + 1e-10);
                db = Math.max(dbMin, Math.min(dbMax, db));
                const y = ((dbMax - db) / (dbMax - dbMin)) * h;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function drawPhase(phase) {
            const ctx = phaseCanvas.getContext('2d');
            const w = phaseCanvas.width / (window.devicePixelRatio || 1);
            const h = phaseCanvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0,20,40,0.5)';
            ctx.fillRect(0, 0, w, h);

            ctx.strokeStyle = 'rgba(0,170,255,0.1)';
            ctx.beginPath();
            ctx.moveTo(0, h / 2);
            ctx.lineTo(w, h / 2);
            ctx.stroke();

            ctx.strokeStyle = '#ff6688';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < phase.length; i++) {
                const x = (i / phase.length) * w;
                const y = h / 2 - (phase[i] / Math.PI) * (h * 0.45);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            ctx.fillStyle = '#888';
            ctx.font = '10px Courier New';
            ctx.fillText('+π', 5, 15);
            ctx.fillText('-π', 5, h - 5);
        }

        function checkStability() {
            const isStable = poles.every(p => Math.sqrt(p.re * p.re + p.im * p.im) < 1);
            const el = document.getElementById('stability');
            if (isStable) {
                el.className = 'stability-indicator stable';
                el.textContent = '✓ STABLE - All poles inside unit circle';
            } else {
                el.className = 'stability-indicator unstable';
                el.textContent = '✗ UNSTABLE - Pole outside unit circle!';
            }
        }

        function update() {
            drawPZPlot();
            const { mag, phase } = computeResponse();
            drawMagnitude(mag);
            drawPhase(phase);
            checkStability();
        }

        function setMode(m) {
            mode = m;
            document.getElementById('btnPole').classList.toggle('active', m === 'pole');
            document.getElementById('btnZero').classList.toggle('active', m === 'zero');
        }

        function clearAll() {
            poles = [];
            zeros = [];
            update();
        }

        function loadPreset(type) {
            clearAll();
            if (type === 'lowpass') {
                poles = [
                    { re: 0.5, im: 0.5 },
                    { re: 0.5, im: -0.5 }
                ];
                zeros = [
                    { re: -1, im: 0 }
                ];
            } else if (type === 'notch') {
                const omega = Math.PI / 4;
                zeros = [
                    { re: Math.cos(omega), im: Math.sin(omega) },
                    { re: Math.cos(omega), im: -Math.sin(omega) }
                ];
                poles = [
                    { re: 0.9 * Math.cos(omega), im: 0.9 * Math.sin(omega) },
                    { re: 0.9 * Math.cos(omega), im: -0.9 * Math.sin(omega) }
                ];
            }
            update();
        }

        pzCanvas.addEventListener('click', (e) => {
            const rect = pzCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const complex = canvasToComplex(x, y, pzCanvas);

            if (mode === 'pole') {
                poles.push(complex);
            } else {
                zeros.push(complex);
            }
            update();
        });

        function init() {
            [pzCanvas, magCanvas, phaseCanvas].forEach(resizeCanvas);
            loadPreset('lowpass');
        }

        window.addEventListener('resize', init);
        init();
    </script>
</body>
</html>
