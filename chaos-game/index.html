<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaos Game Fractals - CCAB</title>
    <link rel="stylesheet" href="../assets/css/navigation.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Spectral:ital,wght@0,400;0,600;1,400&family=Space+Mono:wght@400;700&display=swap');

        :root {
            /* CCAB Color Scheme */
            --bg-primary: #0a0e1a;
            --bg-secondary: #111827;
            --text-primary: #e0e0ff;
            --text-secondary: #a0a0c0;
            --text-accent: #fbbf24;
            --theme-color: #667eea;

            /* Spacing */
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            /* Typography */
            --font-display: 'Orbitron', sans-serif;
            --font-heading: 'Spectral', serif;
            --font-mono: 'Space Mono', monospace;
            --font-body: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

            /* Layout */
            --header-height: 64px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: linear-gradient(135deg, var(--bg-primary) 0%, #0f172a 50%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            padding: 20px;
            padding-top: calc(var(--header-height) + 20px);
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            font-family: var(--font-display);
            text-align: center;
            margin-bottom: 10px;
            font-size: clamp(2rem, 5vw, 3rem);
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 50%, var(--theme-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 30px;
            font-size: 1.1em;
            font-family: var(--font-heading);
            font-style: italic;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            padding: 12px 24px;
            background: rgba(224, 224, 255, 0.1);
            border: 2px solid rgba(224, 224, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
            color: var(--text-primary);
            font-family: var(--font-mono);
        }

        .tab:hover {
            background: rgba(224, 224, 255, 0.2);
            transform: translateY(-2px);
        }

        .tab.active {
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border-color: var(--theme-color);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .view {
            display: none;
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .view.active {
            display: block;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.9em;
            color: var(--text-secondary);
            font-family: var(--font-mono);
        }

        input[type="range"] {
            width: 150px;
            accent-color: var(--theme-color);
        }

        input[type="number"] {
            width: 80px;
            padding: 8px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 1em;
        }

        select {
            padding: 8px 12px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 1em;
            cursor: pointer;
            font-family: var(--font-mono);
        }

        select option {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            font-family: var(--font-mono);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .canvas-wrapper {
            position: relative;
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        canvas {
            display: block;
            background: #000;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 100%;
        }

        .stats-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: var(--theme-color);
            font-family: var(--font-mono);
        }

        .stat-label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid var(--theme-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .info-box h3 {
            margin-bottom: 10px;
            color: var(--theme-color);
            font-family: var(--font-display);
        }

        .info-box ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        .info-box code {
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: var(--font-mono);
            color: var(--text-accent);
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 15px 0;
        }

        .preset-btn {
            padding: 8px 16px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
            font-family: var(--font-mono);
        }

        .preset-btn:hover {
            background: rgba(224, 224, 255, 0.2);
            transform: translateY(-2px);
        }

        .preset-btn.featured {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            border-color: #ff6b6b;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--theme-color);
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.8);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }

            .tabs {
                font-size: 0.9em;
            }

            .tab {
                padding: 8px 16px;
            }

            input[type="range"] {
                width: 120px;
            }

            canvas {
                max-width: 100%;
                height: auto !important;
            }
        }
    
        /* Organic Nature Back Link */
        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10000;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #BC6C25;
            text-decoration: none;
            font-family: 'Nunito', -apple-system, BlinkMacSystemFont, sans-serif;
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: rgba(254, 250, 224, 0.95);
            border-radius: 20px;
            border: 2px solid rgba(138, 154, 91, 0.3);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(96, 108, 56, 0.15);
        }
        .organic-back-link:hover {
            background: rgba(254, 250, 224, 1);
            transform: translateX(-5px);
            border-color: #DDA15E;
            box-shadow: 0 6px 20px rgba(96, 108, 56, 0.25);
        }

    </style>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>

    <a href="../index.html" class="organic-back-link">← Back to Gallery</a>

    <!-- Navigation Header -->
    <nav class="ccab-nav">
        <div class="nav-container">
            <a href="../index.html" class="nav-home">
                <span class="nav-logo">CCAB</span>
                <span class="nav-tagline">Claude Code and Algorithmic Beauty</span>
            </a>
            <div class="nav-breadcrumb">
                <a href="../index.html">Gallery</a>
                <span class="separator">/</span>
                <span class="current">Chaos Game Fractals</span>
            </div>
        </div>
    </nav>

    <div class="container">
        <h1>Chaos Game Fractals</h1>
        <p class="subtitle">Order from Randomness: The Beauty of Probabilistic Fractals</p>

        <div class="tabs">
            <div class="tab active" data-view="sierpinski">Sierpinski</div>
            <div class="tab" data-view="polygon">Custom Polygon</div>
            <div class="tab" data-view="restricted">Restricted</div>
            <div class="tab" data-view="ifs">IFS</div>
        </div>

        <!-- Sierpinski Triangle View -->
        <div class="view active" id="sierpinski">
            <div class="info-box">
                <h3>The Sierpinski Triangle</h3>
                <p>The classic chaos game: start at a random point, pick a random vertex from 3 corners, jump halfway there, plot the point, and repeat. Despite pure randomness in vertex selection, a perfect fractal triangle emerges!</p>
                <ul>
                    <li><strong>Algorithm:</strong> 3 vertices, jump ratio = 0.5</li>
                    <li><strong>Magic:</strong> No restrictions needed - the pattern just appears</li>
                    <li><strong>Fractal Dimension:</strong> log(3)/log(2) = 1.585</li>
                    <li><strong>Self-Similar:</strong> Each triangle contains 3 smaller copies of itself</li>
                </ul>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Points: <span id="sierpPoints">100000</span></label>
                    <input type="range" id="sierpPointsSlider" min="1000" max="1000000" value="100000" step="1000">
                </div>
                <div class="control-group">
                    <label>Jump Ratio: <span id="sierpRatio">0.5</span></label>
                    <input type="range" id="sierpRatioSlider" min="0.1" max="0.9" value="0.5" step="0.01">
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="sierpAnimate">
                    <label for="sierpAnimate">Animate</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="sierpColor" checked>
                    <label for="sierpColor">Color by Vertex</label>
                </div>
                <button onclick="renderSierpinski()">Render</button>
                <button class="secondary" onclick="clearSierpinski()">Clear</button>
            </div>

            <div class="canvas-wrapper">
                <canvas id="sierpCanvas" width="800" height="800"></canvas>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="sierpPointsRendered">0</div>
                        <div class="stat-label">Points Rendered</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">3</div>
                        <div class="stat-label">Vertices</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="sierpRatioStat">0.50</div>
                        <div class="stat-label">Jump Ratio</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">1.585</div>
                        <div class="stat-label">Fractal Dim</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Custom Polygon View -->
        <div class="view" id="polygon">
            <div class="info-box">
                <h3>Custom Polygon Chaos Game</h3>
                <p>Experiment with different numbers of vertices and jump ratios. Not all combinations create fractals - some create filled shapes, others create surprising patterns!</p>
                <ul>
                    <li><strong>Square (4):</strong> With r=0.5, creates a solid square (boring!)</li>
                    <li><strong>Pentagon (5):</strong> r=0.618 (golden ratio) creates beautiful patterns</li>
                    <li><strong>Hexagon (6):</strong> r=0.5 creates nested hexagons</li>
                    <li><strong>Higher N:</strong> Approach circular symmetry</li>
                </ul>
            </div>

            <div class="preset-buttons">
                <button class="preset-btn featured" onclick="setPolygonPreset(3, 0.5)">Triangle (3, 0.5)</button>
                <button class="preset-btn" onclick="setPolygonPreset(4, 0.5)">Square (4, 0.5)</button>
                <button class="preset-btn" onclick="setPolygonPreset(5, 0.618)">Pentagon (5, φ)</button>
                <button class="preset-btn" onclick="setPolygonPreset(6, 0.5)">Hexagon (6, 0.5)</button>
                <button class="preset-btn" onclick="setPolygonPreset(8, 0.5)">Octagon (8, 0.5)</button>
                <button class="preset-btn" onclick="setPolygonPreset(12, 0.5)">Dodecagon (12, 0.5)</button>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Vertices: <span id="polyVertices">4</span></label>
                    <input type="range" id="polyVerticesSlider" min="3" max="12" value="4" step="1">
                </div>
                <div class="control-group">
                    <label>Jump Ratio: <span id="polyRatio">0.5</span></label>
                    <input type="range" id="polyRatioSlider" min="0.1" max="0.9" value="0.5" step="0.01">
                </div>
                <div class="control-group">
                    <label>Points: <span id="polyPoints">100000</span></label>
                    <input type="range" id="polyPointsSlider" min="1000" max="1000000" value="100000" step="1000">
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="polyAnimate">
                    <label for="polyAnimate">Animate</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="polyColor" checked>
                    <label for="polyColor">Color by Vertex</label>
                </div>
                <button onclick="renderPolygon()">Render</button>
                <button class="secondary" onclick="clearPolygon()">Clear</button>
            </div>

            <div class="canvas-wrapper">
                <canvas id="polyCanvas" width="800" height="800"></canvas>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="polyPointsRendered">0</div>
                        <div class="stat-label">Points Rendered</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="polyVerticesStat">4</div>
                        <div class="stat-label">Vertices</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="polyRatioStat">0.50</div>
                        <div class="stat-label">Jump Ratio</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="polyDimension">-</div>
                        <div class="stat-label">Pattern Type</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Restricted Rules View -->
        <div class="view" id="restricted">
            <div class="info-box">
                <h3>Restricted Chaos Game</h3>
                <p>Add rules like "can't pick the same vertex twice" or "can't pick adjacent vertices" to create wildly different patterns from the same polygon!</p>
                <ul>
                    <li><strong>Square + No Repeat:</strong> Creates a Sierpinski carpet-like pattern</li>
                    <li><strong>Pentagon + No Adjacent:</strong> Beautiful 5-fold symmetry</li>
                    <li><strong>Hexagon + Two Back:</strong> Cannot pick vertex two positions back</li>
                    <li><strong>Custom Rules:</strong> The possibilities are endless</li>
                </ul>
            </div>

            <div class="preset-buttons">
                <button class="preset-btn featured" onclick="setRestrictedPreset(4, 0.5, 'noRepeat')">Square + No Repeat</button>
                <button class="preset-btn featured" onclick="setRestrictedPreset(5, 0.5, 'noAdjacent')">Pentagon + No Adjacent</button>
                <button class="preset-btn" onclick="setRestrictedPreset(6, 0.5, 'twoBack')">Hexagon + Two Back</button>
                <button class="preset-btn" onclick="setRestrictedPreset(4, 0.5, 'oneOrTwo')">Square + 1 or 2 Away</button>
                <button class="preset-btn" onclick="setRestrictedPreset(5, 0.618, 'noRepeat')">Pentagon + No Repeat</button>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Vertices: <span id="restVertices">4</span></label>
                    <input type="range" id="restVerticesSlider" min="3" max="12" value="4" step="1">
                </div>
                <div class="control-group">
                    <label>Jump Ratio: <span id="restRatio">0.5</span></label>
                    <input type="range" id="restRatioSlider" min="0.1" max="0.9" value="0.5" step="0.01">
                </div>
                <div class="control-group">
                    <label>Rule:</label>
                    <select id="restRule">
                        <option value="none">No Restriction</option>
                        <option value="noRepeat" selected>No Repeat</option>
                        <option value="noAdjacent">No Adjacent</option>
                        <option value="twoBack">No Two Back</option>
                        <option value="oneOrTwo">1 or 2 Vertices Away</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Points: <span id="restPoints">100000</span></label>
                    <input type="range" id="restPointsSlider" min="1000" max="1000000" value="100000" step="1000">
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="restAnimate">
                    <label for="restAnimate">Animate</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="restColor" checked>
                    <label for="restColor">Color by Vertex</label>
                </div>
                <button onclick="renderRestricted()">Render</button>
                <button class="secondary" onclick="clearRestricted()">Clear</button>
            </div>

            <div class="canvas-wrapper">
                <canvas id="restCanvas" width="800" height="800"></canvas>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="restPointsRendered">0</div>
                        <div class="stat-label">Points Rendered</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="restVerticesStat">4</div>
                        <div class="stat-label">Vertices</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="restRatioStat">0.50</div>
                        <div class="stat-label">Jump Ratio</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="restRuleStat">No Repeat</div>
                        <div class="stat-label">Restriction</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- IFS (Iterated Function System) View -->
        <div class="view" id="ifs">
            <div class="info-box">
                <h3>Iterated Function Systems</h3>
                <p>Instead of random vertices, apply one of several affine transformations chosen by probability. This creates famous fractals like the Barnsley Fern!</p>
                <ul>
                    <li><strong>Barnsley Fern:</strong> 4 transformations create a realistic fern</li>
                    <li><strong>Tree:</strong> Branching structure from simple rules</li>
                    <li><strong>Spiral:</strong> Logarithmic spiral from rotation + scaling</li>
                    <li><strong>Dragon Curve:</strong> Space-filling fractal dragon</li>
                </ul>
            </div>

            <div class="preset-buttons">
                <button class="preset-btn featured" onclick="setIFSPreset('fern')">Barnsley Fern</button>
                <button class="preset-btn featured" onclick="setIFSPreset('tree')">Fractal Tree</button>
                <button class="preset-btn" onclick="setIFSPreset('spiral')">Spiral</button>
                <button class="preset-btn" onclick="setIFSPreset('dragon')">Dragon Curve</button>
                <button class="preset-btn" onclick="setIFSPreset('maple')">Maple Leaf</button>
                <button class="preset-btn" onclick="setIFSPreset('levy')">Levy C Curve</button>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Points: <span id="ifsPoints">100000</span></label>
                    <input type="range" id="ifsPointsSlider" min="1000" max="500000" value="100000" step="1000">
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="ifsAnimate">
                    <label for="ifsAnimate">Animate</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="ifsColor" checked>
                    <label for="ifsColor">Color by Transform</label>
                </div>
                <button onclick="renderIFS()">Render</button>
                <button class="secondary" onclick="clearIFS()">Clear</button>
            </div>

            <div class="canvas-wrapper">
                <canvas id="ifsCanvas" width="800" height="800"></canvas>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="ifsPointsRendered">0</div>
                        <div class="stat-label">Points Rendered</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="ifsTransforms">4</div>
                        <div class="stat-label">Transforms</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="ifsName">Barnsley Fern</div>
                        <div class="stat-label">Fractal Type</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="ifsComplexity">High</div>
                        <div class="stat-label">Complexity</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== SIERPINSKI TRIANGLE ====================
        const sierpCanvas = document.getElementById('sierpCanvas');
        const sierpCtx = sierpCanvas.getContext('2d');

        let sierpState = {
            points: 100000,
            ratio: 0.5,
            animate: false,
            colorByVertex: true,
            animationId: null,
            pointsRendered: 0
        };

        const sierpVertices = [
            { x: 400, y: 50 },    // Top
            { x: 100, y: 750 },   // Bottom left
            { x: 700, y: 750 }    // Bottom right
        ];

        const vertexColors = [
            '#ff6b6b', // Red
            '#4ecdc4', // Cyan
            '#ffd93d', // Yellow
            '#a8e6cf', // Green
            '#ff6fb5', // Pink
            '#95e1d3', // Teal
            '#f38181', // Rose
            '#aa96da', // Purple
            '#fcbad3', // Light pink
            '#ffffd2', // Light yellow
            '#a8d8ea', // Light blue
            '#ffccf9'  // Lavender
        ];

        function clearSierpinski() {
            sierpCtx.fillStyle = '#000';
            sierpCtx.fillRect(0, 0, sierpCanvas.width, sierpCanvas.height);
            sierpState.pointsRendered = 0;
            updateSierpinskiStats();
            if (sierpState.animationId) {
                cancelAnimationFrame(sierpState.animationId);
                sierpState.animationId = null;
            }
        }

        function renderSierpinski() {
            clearSierpinski();

            let x = Math.random() * sierpCanvas.width;
            let y = Math.random() * sierpCanvas.height;

            if (sierpState.animate) {
                animateSierpinski(x, y, 0);
            } else {
                // Fast render
                for (let i = 0; i < sierpState.points; i++) {
                    const vertex = sierpVertices[Math.floor(Math.random() * 3)];
                    x = x + (vertex.x - x) * sierpState.ratio;
                    y = y + (vertex.y - y) * sierpState.ratio;

                    if (i > 100) { // Skip first 100 points
                        if (sierpState.colorByVertex) {
                            const vIndex = sierpVertices.findIndex(v => v === vertex);
                            sierpCtx.fillStyle = vertexColors[vIndex];
                        } else {
                            sierpCtx.fillStyle = '#ffffff';
                        }
                        sierpCtx.fillRect(x, y, 1, 1);
                    }
                }
                sierpState.pointsRendered = sierpState.points;
                updateSierpinskiStats();
            }
        }

        function animateSierpinski(x, y, count) {
            const batchSize = 500;

            for (let i = 0; i < batchSize && count < sierpState.points; i++, count++) {
                const vertexIndex = Math.floor(Math.random() * 3);
                const vertex = sierpVertices[vertexIndex];
                x = x + (vertex.x - x) * sierpState.ratio;
                y = y + (vertex.y - y) * sierpState.ratio;

                if (count > 100) {
                    if (sierpState.colorByVertex) {
                        sierpCtx.fillStyle = vertexColors[vertexIndex];
                    } else {
                        sierpCtx.fillStyle = '#ffffff';
                    }
                    sierpCtx.fillRect(x, y, 1, 1);
                    sierpState.pointsRendered = count;
                }
            }

            updateSierpinskiStats();

            if (count < sierpState.points && sierpState.animate) {
                sierpState.animationId = requestAnimationFrame(() => animateSierpinski(x, y, count));
            }
        }

        function updateSierpinskiStats() {
            document.getElementById('sierpPointsRendered').textContent = sierpState.pointsRendered.toLocaleString();
            document.getElementById('sierpRatioStat').textContent = sierpState.ratio.toFixed(2);
        }

        // Event listeners
        document.getElementById('sierpPointsSlider').addEventListener('input', (e) => {
            sierpState.points = parseInt(e.target.value);
            document.getElementById('sierpPoints').textContent = sierpState.points.toLocaleString();
        });

        document.getElementById('sierpRatioSlider').addEventListener('input', (e) => {
            sierpState.ratio = parseFloat(e.target.value);
            document.getElementById('sierpRatio').textContent = sierpState.ratio;
        });

        document.getElementById('sierpAnimate').addEventListener('change', (e) => {
            sierpState.animate = e.target.checked;
        });

        document.getElementById('sierpColor').addEventListener('change', (e) => {
            sierpState.colorByVertex = e.target.checked;
        });

        // ==================== CUSTOM POLYGON ====================
        const polyCanvas = document.getElementById('polyCanvas');
        const polyCtx = polyCanvas.getContext('2d');

        let polyState = {
            vertices: 4,
            ratio: 0.5,
            points: 100000,
            animate: false,
            colorByVertex: true,
            animationId: null,
            pointsRendered: 0
        };

        function getPolygonVertices(n) {
            const vertices = [];
            const centerX = polyCanvas.width / 2;
            const centerY = polyCanvas.height / 2;
            const radius = Math.min(centerX, centerY) - 50;

            for (let i = 0; i < n; i++) {
                const angle = (i * 2 * Math.PI / n) - Math.PI / 2;
                vertices.push({
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                });
            }
            return vertices;
        }

        function clearPolygon() {
            polyCtx.fillStyle = '#000';
            polyCtx.fillRect(0, 0, polyCanvas.width, polyCanvas.height);
            polyState.pointsRendered = 0;
            updatePolygonStats();
            if (polyState.animationId) {
                cancelAnimationFrame(polyState.animationId);
                polyState.animationId = null;
            }
        }

        function renderPolygon() {
            clearPolygon();

            const vertices = getPolygonVertices(polyState.vertices);

            // Draw vertices
            polyCtx.strokeStyle = '#ffffff';
            polyCtx.lineWidth = 1;
            polyCtx.beginPath();
            polyCtx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < vertices.length; i++) {
                polyCtx.lineTo(vertices[i].x, vertices[i].y);
            }
            polyCtx.closePath();
            polyCtx.stroke();

            vertices.forEach((v, i) => {
                polyCtx.fillStyle = vertexColors[i % vertexColors.length];
                polyCtx.beginPath();
                polyCtx.arc(v.x, v.y, 5, 0, Math.PI * 2);
                polyCtx.fill();
            });

            let x = polyCanvas.width / 2;
            let y = polyCanvas.height / 2;

            if (polyState.animate) {
                animatePolygon(x, y, 0, vertices);
            } else {
                for (let i = 0; i < polyState.points; i++) {
                    const vertexIndex = Math.floor(Math.random() * vertices.length);
                    const vertex = vertices[vertexIndex];
                    x = x + (vertex.x - x) * polyState.ratio;
                    y = y + (vertex.y - y) * polyState.ratio;

                    if (i > 100) {
                        if (polyState.colorByVertex) {
                            polyCtx.fillStyle = vertexColors[vertexIndex];
                        } else {
                            polyCtx.fillStyle = '#ffffff';
                        }
                        polyCtx.fillRect(x, y, 1, 1);
                    }
                }
                polyState.pointsRendered = polyState.points;
                updatePolygonStats();
            }
        }

        function animatePolygon(x, y, count, vertices) {
            const batchSize = 500;

            for (let i = 0; i < batchSize && count < polyState.points; i++, count++) {
                const vertexIndex = Math.floor(Math.random() * vertices.length);
                const vertex = vertices[vertexIndex];
                x = x + (vertex.x - x) * polyState.ratio;
                y = y + (vertex.y - y) * polyState.ratio;

                if (count > 100) {
                    if (polyState.colorByVertex) {
                        polyCtx.fillStyle = vertexColors[vertexIndex];
                    } else {
                        polyCtx.fillStyle = '#ffffff';
                    }
                    polyCtx.fillRect(x, y, 1, 1);
                    polyState.pointsRendered = count;
                }
            }

            updatePolygonStats();

            if (count < polyState.points && polyState.animate) {
                polyState.animationId = requestAnimationFrame(() => animatePolygon(x, y, count, vertices));
            }
        }

        function setPolygonPreset(vertices, ratio) {
            polyState.vertices = vertices;
            polyState.ratio = ratio;
            document.getElementById('polyVerticesSlider').value = vertices;
            document.getElementById('polyRatioSlider').value = ratio;
            document.getElementById('polyVertices').textContent = vertices;
            document.getElementById('polyRatio').textContent = ratio.toFixed(3);
            renderPolygon();
        }

        function updatePolygonStats() {
            document.getElementById('polyPointsRendered').textContent = polyState.pointsRendered.toLocaleString();
            document.getElementById('polyVerticesStat').textContent = polyState.vertices;
            document.getElementById('polyRatioStat').textContent = polyState.ratio.toFixed(2);

            // Determine pattern type
            let patternType = '-';
            if (polyState.vertices === 3 && Math.abs(polyState.ratio - 0.5) < 0.01) {
                patternType = 'Sierpinski';
            } else if (polyState.vertices === 4 && Math.abs(polyState.ratio - 0.5) < 0.01) {
                patternType = 'Filled';
            } else if (polyState.vertices === 5 && Math.abs(polyState.ratio - 0.618) < 0.01) {
                patternType = 'Golden';
            } else {
                patternType = 'Custom';
            }
            document.getElementById('polyDimension').textContent = patternType;
        }

        // Event listeners
        document.getElementById('polyVerticesSlider').addEventListener('input', (e) => {
            polyState.vertices = parseInt(e.target.value);
            document.getElementById('polyVertices').textContent = polyState.vertices;
        });

        document.getElementById('polyRatioSlider').addEventListener('input', (e) => {
            polyState.ratio = parseFloat(e.target.value);
            document.getElementById('polyRatio').textContent = polyState.ratio.toFixed(3);
        });

        document.getElementById('polyPointsSlider').addEventListener('input', (e) => {
            polyState.points = parseInt(e.target.value);
            document.getElementById('polyPoints').textContent = polyState.points.toLocaleString();
        });

        document.getElementById('polyAnimate').addEventListener('change', (e) => {
            polyState.animate = e.target.checked;
        });

        document.getElementById('polyColor').addEventListener('change', (e) => {
            polyState.colorByVertex = e.target.checked;
        });

        // ==================== RESTRICTED CHAOS GAME ====================
        const restCanvas = document.getElementById('restCanvas');
        const restCtx = restCanvas.getContext('2d');

        let restState = {
            vertices: 4,
            ratio: 0.5,
            points: 100000,
            rule: 'noRepeat',
            animate: false,
            colorByVertex: true,
            animationId: null,
            pointsRendered: 0
        };

        function clearRestricted() {
            restCtx.fillStyle = '#000';
            restCtx.fillRect(0, 0, restCanvas.width, restCanvas.height);
            restState.pointsRendered = 0;
            updateRestrictedStats();
            if (restState.animationId) {
                cancelAnimationFrame(restState.animationId);
                restState.animationId = null;
            }
        }

        function isAllowedVertex(lastVertex, newVertex, n, rule) {
            if (rule === 'none') return true;
            if (rule === 'noRepeat') return newVertex !== lastVertex;
            if (rule === 'noAdjacent') {
                const diff = Math.abs(newVertex - lastVertex);
                return diff !== 1 && diff !== n - 1;
            }
            if (rule === 'twoBack') {
                const diff = Math.abs(newVertex - lastVertex);
                return diff !== 2 && diff !== n - 2;
            }
            if (rule === 'oneOrTwo') {
                const diff = Math.abs(newVertex - lastVertex);
                return diff === 1 || diff === 2 || diff === n - 1 || diff === n - 2;
            }
            return true;
        }

        function renderRestricted() {
            clearRestricted();

            const vertices = getPolygonVertices(restState.vertices);

            // Draw vertices
            restCtx.strokeStyle = '#ffffff';
            restCtx.lineWidth = 1;
            restCtx.beginPath();
            restCtx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < vertices.length; i++) {
                restCtx.lineTo(vertices[i].x, vertices[i].y);
            }
            restCtx.closePath();
            restCtx.stroke();

            vertices.forEach((v, i) => {
                restCtx.fillStyle = vertexColors[i % vertexColors.length];
                restCtx.beginPath();
                restCtx.arc(v.x, v.y, 5, 0, Math.PI * 2);
                restCtx.fill();
            });

            let x = restCanvas.width / 2;
            let y = restCanvas.height / 2;
            let lastVertex = -1;

            if (restState.animate) {
                animateRestricted(x, y, 0, vertices, lastVertex);
            } else {
                for (let i = 0; i < restState.points; i++) {
                    let vertexIndex;
                    let attempts = 0;
                    do {
                        vertexIndex = Math.floor(Math.random() * vertices.length);
                        attempts++;
                    } while (!isAllowedVertex(lastVertex, vertexIndex, vertices.length, restState.rule) && attempts < 100);

                    const vertex = vertices[vertexIndex];
                    x = x + (vertex.x - x) * restState.ratio;
                    y = y + (vertex.y - y) * restState.ratio;
                    lastVertex = vertexIndex;

                    if (i > 100) {
                        if (restState.colorByVertex) {
                            restCtx.fillStyle = vertexColors[vertexIndex];
                        } else {
                            restCtx.fillStyle = '#ffffff';
                        }
                        restCtx.fillRect(x, y, 1, 1);
                    }
                }
                restState.pointsRendered = restState.points;
                updateRestrictedStats();
            }
        }

        function animateRestricted(x, y, count, vertices, lastVertex) {
            const batchSize = 500;

            for (let i = 0; i < batchSize && count < restState.points; i++, count++) {
                let vertexIndex;
                let attempts = 0;
                do {
                    vertexIndex = Math.floor(Math.random() * vertices.length);
                    attempts++;
                } while (!isAllowedVertex(lastVertex, vertexIndex, vertices.length, restState.rule) && attempts < 100);

                const vertex = vertices[vertexIndex];
                x = x + (vertex.x - x) * restState.ratio;
                y = y + (vertex.y - y) * restState.ratio;
                lastVertex = vertexIndex;

                if (count > 100) {
                    if (restState.colorByVertex) {
                        restCtx.fillStyle = vertexColors[vertexIndex];
                    } else {
                        restCtx.fillStyle = '#ffffff';
                    }
                    restCtx.fillRect(x, y, 1, 1);
                    restState.pointsRendered = count;
                }
            }

            updateRestrictedStats();

            if (count < restState.points && restState.animate) {
                restState.animationId = requestAnimationFrame(() => animateRestricted(x, y, count, vertices, lastVertex));
            }
        }

        function setRestrictedPreset(vertices, ratio, rule) {
            restState.vertices = vertices;
            restState.ratio = ratio;
            restState.rule = rule;
            document.getElementById('restVerticesSlider').value = vertices;
            document.getElementById('restRatioSlider').value = ratio;
            document.getElementById('restRule').value = rule;
            document.getElementById('restVertices').textContent = vertices;
            document.getElementById('restRatio').textContent = ratio.toFixed(3);
            renderRestricted();
        }

        function updateRestrictedStats() {
            document.getElementById('restPointsRendered').textContent = restState.pointsRendered.toLocaleString();
            document.getElementById('restVerticesStat').textContent = restState.vertices;
            document.getElementById('restRatioStat').textContent = restState.ratio.toFixed(2);

            const ruleNames = {
                'none': 'None',
                'noRepeat': 'No Repeat',
                'noAdjacent': 'No Adjacent',
                'twoBack': 'No Two Back',
                'oneOrTwo': '1 or 2 Away'
            };
            document.getElementById('restRuleStat').textContent = ruleNames[restState.rule] || restState.rule;
        }

        // Event listeners
        document.getElementById('restVerticesSlider').addEventListener('input', (e) => {
            restState.vertices = parseInt(e.target.value);
            document.getElementById('restVertices').textContent = restState.vertices;
        });

        document.getElementById('restRatioSlider').addEventListener('input', (e) => {
            restState.ratio = parseFloat(e.target.value);
            document.getElementById('restRatio').textContent = restState.ratio.toFixed(3);
        });

        document.getElementById('restPointsSlider').addEventListener('input', (e) => {
            restState.points = parseInt(e.target.value);
            document.getElementById('restPoints').textContent = restState.points.toLocaleString();
        });

        document.getElementById('restRule').addEventListener('change', (e) => {
            restState.rule = e.target.value;
        });

        document.getElementById('restAnimate').addEventListener('change', (e) => {
            restState.animate = e.target.checked;
        });

        document.getElementById('restColor').addEventListener('change', (e) => {
            restState.colorByVertex = e.target.checked;
        });

        // ==================== IFS (ITERATED FUNCTION SYSTEMS) ====================
        const ifsCanvas = document.getElementById('ifsCanvas');
        const ifsCtx = ifsCanvas.getContext('2d');

        let ifsState = {
            points: 100000,
            animate: false,
            colorByTransform: true,
            animationId: null,
            pointsRendered: 0,
            currentPreset: 'fern'
        };

        const ifsPresets = {
            fern: {
                name: 'Barnsley Fern',
                transforms: [
                    { a: 0, b: 0, c: 0, d: 0.16, e: 0, f: 0, p: 0.01, color: '#228B22' },
                    { a: 0.85, b: 0.04, c: -0.04, d: 0.85, e: 0, f: 1.6, p: 0.85, color: '#32CD32' },
                    { a: 0.2, b: -0.26, c: 0.23, d: 0.22, e: 0, f: 1.6, p: 0.07, color: '#90EE90' },
                    { a: -0.15, b: 0.28, c: 0.26, d: 0.24, e: 0, f: 0.44, p: 0.07, color: '#00FF00' }
                ],
                scale: 60,
                offsetX: 400,
                offsetY: 50
            },
            tree: {
                name: 'Fractal Tree',
                transforms: [
                    { a: 0, b: 0, c: 0, d: 0.5, e: 0, f: 0, p: 0.05, color: '#8B4513' },
                    { a: 0.42, b: -0.42, c: 0.42, d: 0.42, e: 0, f: 0.2, p: 0.4, color: '#228B22' },
                    { a: 0.42, b: 0.42, c: -0.42, d: 0.42, e: 0, f: 0.2, p: 0.4, color: '#32CD32' },
                    { a: 0.1, b: 0, c: 0, d: 0.1, e: 0, f: 0.2, p: 0.15, color: '#90EE90' }
                ],
                scale: 300,
                offsetX: 400,
                offsetY: 700
            },
            spiral: {
                name: 'Spiral',
                transforms: [
                    { a: 0.787879, b: -0.424242, c: 0.242424, d: 0.859848, e: 1.758647, f: 1.408065, p: 0.9, color: '#FF69B4' },
                    { a: -0.121212, b: 0.257576, c: 0.151515, d: 0.053030, e: -6.721654, f: 1.377236, p: 0.1, color: '#FFB6C1' }
                ],
                scale: 60,
                offsetX: 400,
                offsetY: 400
            },
            dragon: {
                name: 'Dragon Curve',
                transforms: [
                    { a: 0.5, b: -0.5, c: 0.5, d: 0.5, e: 0, f: 0, p: 0.5, color: '#FF4500' },
                    { a: -0.5, b: -0.5, c: 0.5, d: -0.5, e: 1, f: 0, p: 0.5, color: '#FF6347' }
                ],
                scale: 300,
                offsetX: 300,
                offsetY: 400
            },
            maple: {
                name: 'Maple Leaf',
                transforms: [
                    { a: 0.14, b: 0.01, c: 0, d: 0.51, e: -0.08, f: -1.31, p: 0.25, color: '#DC143C' },
                    { a: 0.43, b: 0.52, c: -0.45, d: 0.5, e: 1.49, f: -0.75, p: 0.25, color: '#FF0000' },
                    { a: 0.45, b: -0.49, c: 0.47, d: 0.47, e: -1.62, f: -0.74, p: 0.25, color: '#FF6347' },
                    { a: 0.49, b: 0, c: 0, d: 0.51, e: 0.02, f: 1.62, p: 0.25, color: '#FF4500' }
                ],
                scale: 150,
                offsetX: 400,
                offsetY: 600
            },
            levy: {
                name: 'Levy C Curve',
                transforms: [
                    { a: 0.5, b: -0.5, c: 0.5, d: 0.5, e: 0, f: 0, p: 0.5, color: '#9370DB' },
                    { a: 0.5, b: 0.5, c: -0.5, d: 0.5, e: 0.5, f: 0.5, p: 0.5, color: '#BA55D3' }
                ],
                scale: 400,
                offsetX: 200,
                offsetY: 400
            }
        };

        function clearIFS() {
            ifsCtx.fillStyle = '#000';
            ifsCtx.fillRect(0, 0, ifsCanvas.width, ifsCanvas.height);
            ifsState.pointsRendered = 0;
            updateIFSStats();
            if (ifsState.animationId) {
                cancelAnimationFrame(ifsState.animationId);
                ifsState.animationId = null;
            }
        }

        function renderIFS() {
            clearIFS();

            const preset = ifsPresets[ifsState.currentPreset];
            let x = 0, y = 0;

            if (ifsState.animate) {
                animateIFS(x, y, 0, preset);
            } else {
                for (let i = 0; i < ifsState.points; i++) {
                    const rand = Math.random();
                    let cumProb = 0;
                    let transform = null;

                    for (const t of preset.transforms) {
                        cumProb += t.p;
                        if (rand < cumProb) {
                            transform = t;
                            break;
                        }
                    }

                    if (transform) {
                        const newX = transform.a * x + transform.b * y + transform.e;
                        const newY = transform.c * x + transform.d * y + transform.f;
                        x = newX;
                        y = newY;

                        if (i > 100) {
                            const screenX = preset.offsetX + x * preset.scale;
                            const screenY = preset.offsetY - y * preset.scale;

                            if (ifsState.colorByTransform) {
                                ifsCtx.fillStyle = transform.color;
                            } else {
                                ifsCtx.fillStyle = '#ffffff';
                            }
                            ifsCtx.fillRect(screenX, screenY, 1, 1);
                        }
                    }
                }
                ifsState.pointsRendered = ifsState.points;
                updateIFSStats();
            }
        }

        function animateIFS(x, y, count, preset) {
            const batchSize = 500;

            for (let i = 0; i < batchSize && count < ifsState.points; i++, count++) {
                const rand = Math.random();
                let cumProb = 0;
                let transform = null;

                for (const t of preset.transforms) {
                    cumProb += t.p;
                    if (rand < cumProb) {
                        transform = t;
                        break;
                    }
                }

                if (transform) {
                    const newX = transform.a * x + transform.b * y + transform.e;
                    const newY = transform.c * x + transform.d * y + transform.f;
                    x = newX;
                    y = newY;

                    if (count > 100) {
                        const screenX = preset.offsetX + x * preset.scale;
                        const screenY = preset.offsetY - y * preset.scale;

                        if (ifsState.colorByTransform) {
                            ifsCtx.fillStyle = transform.color;
                        } else {
                            ifsCtx.fillStyle = '#ffffff';
                        }
                        ifsCtx.fillRect(screenX, screenY, 1, 1);
                        ifsState.pointsRendered = count;
                    }
                }
            }

            updateIFSStats();

            if (count < ifsState.points && ifsState.animate) {
                ifsState.animationId = requestAnimationFrame(() => animateIFS(x, y, count, preset));
            }
        }

        function setIFSPreset(presetName) {
            ifsState.currentPreset = presetName;
            renderIFS();
        }

        function updateIFSStats() {
            const preset = ifsPresets[ifsState.currentPreset];
            document.getElementById('ifsPointsRendered').textContent = ifsState.pointsRendered.toLocaleString();
            document.getElementById('ifsTransforms').textContent = preset.transforms.length;
            document.getElementById('ifsName').textContent = preset.name;

            const complexity = ifsState.points > 50000 ? 'High' : ifsState.points > 10000 ? 'Medium' : 'Low';
            document.getElementById('ifsComplexity').textContent = complexity;
        }

        // Event listeners
        document.getElementById('ifsPointsSlider').addEventListener('input', (e) => {
            ifsState.points = parseInt(e.target.value);
            document.getElementById('ifsPoints').textContent = ifsState.points.toLocaleString();
        });

        document.getElementById('ifsAnimate').addEventListener('change', (e) => {
            ifsState.animate = e.target.checked;
        });

        document.getElementById('ifsColor').addEventListener('change', (e) => {
            ifsState.colorByTransform = e.target.checked;
        });

        // ==================== TAB SYSTEM ====================
        function setupTabs() {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    // Stop all animations
                    if (sierpState.animationId) cancelAnimationFrame(sierpState.animationId);
                    if (polyState.animationId) cancelAnimationFrame(polyState.animationId);
                    if (restState.animationId) cancelAnimationFrame(restState.animationId);
                    if (ifsState.animationId) cancelAnimationFrame(ifsState.animationId);

                    // Switch tabs
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.view).classList.add('active');
                });
            });
        }

        // ==================== INITIALIZATION ====================
        window.addEventListener('load', () => {
            setupTabs();
            clearSierpinski();
            clearPolygon();
            clearRestricted();
            clearIFS();

            // Render initial Sierpinski
            renderSierpinski();
        });
    </script>
    <script src="../assets/js/navigation.js"></script>
</body>
</html>
