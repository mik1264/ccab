<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heat Equation / Diffusion</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0808;
            overflow: hidden;
        }

        #canvas {
            display: block;
            cursor: crosshair;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(10, 8, 8, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 100, 50, 0.3);
            z-index: 100;
            min-width: 260px;
            color: #e0e0e0;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        h1 {
            font-size: 1.3em;
            margin-bottom: 5px;
            color: #ff6432;
        }

        .subtitle {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 15px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85em;
            color: #aaa;
        }

        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            background: rgba(40, 30, 30, 0.8);
            border: 1px solid rgba(255, 100, 50, 0.3);
            border-radius: 6px;
            color: #fff;
            font-size: 0.85em;
        }

        input[type="range"] {
            -webkit-appearance: none;
            height: 8px;
            padding: 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #ff6432;
            border-radius: 50%;
            cursor: pointer;
        }

        .btn-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 10px;
            background: linear-gradient(135deg, #c03020, #ff6432);
            border: none;
            border-radius: 6px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 100, 50, 0.4);
        }

        .equation {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(10, 8, 8, 0.95);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 100, 50, 0.3);
            color: #e0e0e0;
            font-family: 'Segoe UI', sans-serif;
            text-align: center;
        }

        .equation h3 {
            color: #ff6432;
            margin-bottom: 10px;
        }

        .formula {
            font-family: 'Georgia', serif;
            font-size: 1.2em;
            color: #fff;
            margin: 10px 0;
        }

        .equation p {
            font-size: 0.8em;
            color: #888;
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 8, 8, 0.95);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 100, 50, 0.3);
            font-size: 0.85em;
            color: #aaa;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
            gap: 15px;
        }

        .info-value {
            color: #ff6432;
            font-family: 'Consolas', monospace;
        }

        .back-link {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #ff6432;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(10, 8, 8, 0.95);
            border-radius: 8px;
            border: 1px solid rgba(255, 100, 50, 0.3);
            font-family: 'Segoe UI', sans-serif;
            transition: all 0.3s;
        }

        .back-link:hover {
            background: rgba(255, 100, 50, 0.1);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>üî• Heat Equation</h1>
        <p class="subtitle">Thermal Diffusion</p>

        <div class="control-group">
            <label>Diffusivity (Œ±): <span id="alphaValue">0.25</span></label>
            <input type="range" id="alpha" min="0.05" max="0.5" step="0.01" value="0.25">
        </div>

        <div class="control-group">
            <label>Brush Size: <span id="brushValue">20</span></label>
            <input type="range" id="brush" min="5" max="60" value="20">
        </div>

        <div class="control-group">
            <label>Heat/Cold Mode</label>
            <select id="mode">
                <option value="heat">Heat (Red)</option>
                <option value="cold">Cold (Blue)</option>
                <option value="both">Both Sources</option>
            </select>
        </div>

        <div class="control-group">
            <label>Boundary</label>
            <select id="boundary">
                <option value="insulated">Insulated (‚àáT=0)</option>
                <option value="fixed">Fixed (T=0)</option>
                <option value="periodic">Periodic</option>
            </select>
        </div>

        <div class="btn-row">
            <button onclick="reset()">Clear</button>
            <button onclick="addHotSpots()">Hot Spots</button>
        </div>
        <div class="btn-row">
            <button onclick="addGradient()">Gradient</button>
            <button onclick="addPattern()">Pattern</button>
        </div>
    </div>

    <div class="equation">
        <h3>Heat Equation</h3>
        <div class="formula">‚àÇT/‚àÇt = Œ± ‚àá¬≤T</div>
        <p>Œ± = thermal diffusivity</p>
        <p style="margin-top: 10px; color: #ff6432;">Click/drag to add heat</p>
    </div>

    <div class="info">
        <div class="info-row">
            <span>Max Temp:</span>
            <span class="info-value" id="maxTemp">0.00</span>
        </div>
        <div class="info-row">
            <span>Min Temp:</span>
            <span class="info-value" id="minTemp">0.00</span>
        </div>
        <div class="info-row">
            <span>Total Energy:</span>
            <span class="info-value" id="energy">0.00</span>
        </div>
    </div>

    <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let gridW, gridH;
        const scale = 2;

        let T, Tnew;
        let sources;

        let alpha = 0.25;
        let brushSize = 20;
        let mode = 'heat';
        let boundary = 'insulated';

        let isDrawing = false;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = canvas.width;
            height = canvas.height;
            gridW = Math.floor(width / scale);
            gridH = Math.floor(height / scale);

            initArrays();
        }

        function initArrays() {
            T = new Float32Array(gridW * gridH);
            Tnew = new Float32Array(gridW * gridH);
            sources = new Float32Array(gridW * gridH);
        }

        function reset() {
            T.fill(0);
            Tnew.fill(0);
            sources.fill(0);
        }

        function idx(x, y) {
            return y * gridW + x;
        }

        function addHeat(px, py, temperature, radius) {
            const gx = Math.floor(px / scale);
            const gy = Math.floor(py / scale);
            const r = Math.floor(radius / scale);

            for (let dy = -r; dy <= r; dy++) {
                for (let dx = -r; dx <= r; dx++) {
                    const x = gx + dx;
                    const y = gy + dy;

                    if (x < 0 || x >= gridW || y < 0 || y >= gridH) continue;

                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= r) {
                        const factor = 1 - dist / r;
                        const i = idx(x, y);
                        T[i] += temperature * factor * factor;
                        T[i] = Math.max(-1, Math.min(1, T[i]));
                    }
                }
            }
        }

        function addHotSpots() {
            reset();
            const count = 5;
            for (let i = 0; i < count; i++) {
                const x = 100 + Math.random() * (width - 200);
                const y = 100 + Math.random() * (height - 200);
                addHeat(x, y, 1, 50);
            }
        }

        function addGradient() {
            reset();
            for (let y = 0; y < gridH; y++) {
                for (let x = 0; x < gridW; x++) {
                    T[idx(x, y)] = x / gridW;
                }
            }
        }

        function addPattern() {
            reset();
            for (let y = 0; y < gridH; y++) {
                for (let x = 0; x < gridW; x++) {
                    const fx = x / gridW * 4;
                    const fy = y / gridH * 4;
                    T[idx(x, y)] = Math.sin(fx * Math.PI) * Math.sin(fy * Math.PI);
                }
            }
        }

        function update() {
            const dt = 1;

            // Heat equation: dT/dt = alpha * laplacian(T)
            // Using explicit finite difference method

            for (let y = 1; y < gridH - 1; y++) {
                for (let x = 1; x < gridW - 1; x++) {
                    const i = idx(x, y);

                    // 5-point Laplacian stencil
                    const laplacian = T[idx(x + 1, y)] + T[idx(x - 1, y)] +
                                     T[idx(x, y + 1)] + T[idx(x, y - 1)] -
                                     4 * T[i];

                    Tnew[i] = T[i] + alpha * laplacian * dt;

                    // Add constant heat sources
                    Tnew[i] += sources[i];

                    // Clamp temperature
                    Tnew[i] = Math.max(-1, Math.min(1, Tnew[i]));
                }
            }

            // Boundary conditions
            if (boundary === 'insulated') {
                // Neumann: dT/dn = 0 (copy from interior)
                for (let x = 0; x < gridW; x++) {
                    Tnew[idx(x, 0)] = Tnew[idx(x, 1)];
                    Tnew[idx(x, gridH - 1)] = Tnew[idx(x, gridH - 2)];
                }
                for (let y = 0; y < gridH; y++) {
                    Tnew[idx(0, y)] = Tnew[idx(1, y)];
                    Tnew[idx(gridW - 1, y)] = Tnew[idx(gridW - 2, y)];
                }
            } else if (boundary === 'fixed') {
                // Dirichlet: T = 0 at boundaries
                for (let x = 0; x < gridW; x++) {
                    Tnew[idx(x, 0)] = 0;
                    Tnew[idx(x, gridH - 1)] = 0;
                }
                for (let y = 0; y < gridH; y++) {
                    Tnew[idx(0, y)] = 0;
                    Tnew[idx(gridW - 1, y)] = 0;
                }
            } else {
                // Periodic
                for (let x = 0; x < gridW; x++) {
                    Tnew[idx(x, 0)] = Tnew[idx(x, gridH - 2)];
                    Tnew[idx(x, gridH - 1)] = Tnew[idx(x, 1)];
                }
                for (let y = 0; y < gridH; y++) {
                    Tnew[idx(0, y)] = Tnew[idx(gridW - 2, y)];
                    Tnew[idx(gridW - 1, y)] = Tnew[idx(1, y)];
                }
            }

            // Swap buffers
            [T, Tnew] = [Tnew, T];

            // Update stats
            let maxT = -Infinity, minT = Infinity, totalE = 0;
            for (let i = 0; i < T.length; i++) {
                maxT = Math.max(maxT, T[i]);
                minT = Math.min(minT, T[i]);
                totalE += Math.abs(T[i]);
            }
            document.getElementById('maxTemp').textContent = maxT.toFixed(3);
            document.getElementById('minTemp').textContent = minT.toFixed(3);
            document.getElementById('energy').textContent = totalE.toFixed(1);
        }

        function getColor(temp) {
            // Temperature range: -1 (cold/blue) to 1 (hot/red)
            if (temp >= 0) {
                // Hot: black -> red -> orange -> yellow -> white
                if (temp < 0.25) {
                    const t = temp / 0.25;
                    return [Math.floor(t * 180), 0, 0];
                } else if (temp < 0.5) {
                    const t = (temp - 0.25) / 0.25;
                    return [180 + Math.floor(t * 75), Math.floor(t * 80), 0];
                } else if (temp < 0.75) {
                    const t = (temp - 0.5) / 0.25;
                    return [255, 80 + Math.floor(t * 120), Math.floor(t * 50)];
                } else {
                    const t = (temp - 0.75) / 0.25;
                    return [255, 200 + Math.floor(t * 55), 50 + Math.floor(t * 205)];
                }
            } else {
                // Cold: black -> blue -> cyan
                const t = -temp;
                if (t < 0.5) {
                    const s = t / 0.5;
                    return [0, Math.floor(s * 100), Math.floor(s * 200)];
                } else {
                    const s = (t - 0.5) / 0.5;
                    return [Math.floor(s * 100), 100 + Math.floor(s * 155), 200 + Math.floor(s * 55)];
                }
            }
        }

        function draw() {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            for (let py = 0; py < height; py++) {
                const gy = Math.floor(py / scale);
                for (let px = 0; px < width; px++) {
                    const gx = Math.floor(px / scale);
                    const i = idx(gx, gy);
                    const pi = (py * width + px) * 4;

                    const [r, g, b] = getColor(T[i]);
                    data[pi] = r;
                    data[pi + 1] = g;
                    data[pi + 2] = b;
                    data[pi + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Input handlers
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const temp = (mode === 'cold') ? -0.5 : 0.5;
            addHeat(e.clientX, e.clientY, temp, brushSize);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                let temp;
                if (mode === 'heat') temp = 0.3;
                else if (mode === 'cold') temp = -0.3;
                else temp = e.shiftKey ? -0.3 : 0.3;

                addHeat(e.clientX, e.clientY, temp, brushSize);
            }
        });

        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseleave', () => isDrawing = false);

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDrawing = true;
            const touch = e.touches[0];
            const temp = (mode === 'cold') ? -0.5 : 0.5;
            addHeat(touch.clientX, touch.clientY, temp, brushSize);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDrawing) {
                const touch = e.touches[0];
                const temp = (mode === 'cold') ? -0.3 : 0.3;
                addHeat(touch.clientX, touch.clientY, temp, brushSize);
            }
        });

        canvas.addEventListener('touchend', () => isDrawing = false);

        // UI handlers
        document.getElementById('alpha').addEventListener('input', (e) => {
            alpha = parseFloat(e.target.value);
            document.getElementById('alphaValue').textContent = alpha.toFixed(2);
        });

        document.getElementById('brush').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushValue').textContent = brushSize;
        });

        document.getElementById('mode').addEventListener('change', (e) => {
            mode = e.target.value;
        });

        document.getElementById('boundary').addEventListener('change', (e) => {
            boundary = e.target.value;
        });

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        // Initialize
        window.addEventListener('resize', resize);
        resize();
        addHotSpots();
        animate();
    </script>
</body>
</html>
