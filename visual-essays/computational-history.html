<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Complete History of Computational Visualizations and Simulations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            line-height: 1.8;
            color: #2c3e50;
            background: linear-gradient(to bottom, #f8f9fa 0%, #e9ecef 100%);
        }

        .hero {
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
            padding: 2rem;
            position: relative;
            overflow: hidden;
        }

        .hero h1 {
            font-size: 3.5rem;
            font-weight: 300;
            margin-bottom: 1rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            max-width: 1200px;
        }

        .hero .subtitle {
            font-size: 1.3rem;
            font-weight: 300;
            opacity: 0.95;
            max-width: 900px;
            font-style: italic;
        }

        #heroCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.15;
            z-index: 0;
        }

        .hero h1, .hero .subtitle {
            position: relative;
            z-index: 1;
        }

        .timeline {
            max-width: 1200px;
            margin: 4rem auto;
            padding: 2rem;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }

        .timeline h2 {
            text-align: center;
            font-size: 2.5rem;
            color: #667eea;
            margin-bottom: 2rem;
        }

        #timelineCanvas {
            width: 100%;
            height: 300px;
            cursor: crosshair;
        }

        .section {
            max-width: 1200px;
            margin: 4rem auto;
            padding: 3rem;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }

        .section h2 {
            font-size: 2.5rem;
            color: #667eea;
            margin-bottom: 1.5rem;
            border-bottom: 3px solid #764ba2;
            padding-bottom: 0.5rem;
        }

        .section h3 {
            font-size: 1.8rem;
            color: #495057;
            margin-top: 2rem;
            margin-bottom: 1rem;
        }

        .section p {
            margin-bottom: 1.2rem;
            font-size: 1.1rem;
            text-align: justify;
        }

        .demo-container {
            margin: 2rem 0;
            padding: 1.5rem;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #667eea;
        }

        .demo-container h4 {
            color: #667eea;
            margin-bottom: 1rem;
            font-size: 1.3rem;
        }

        .demo-canvas {
            width: 100%;
            border-radius: 8px;
            background: #000;
            cursor: pointer;
            display: block;
            margin: 1rem 0;
        }

        .demo-controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .demo-controls button {
            padding: 0.6rem 1.5rem;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.3s;
        }

        .demo-controls button:hover {
            background: #764ba2;
        }

        .demo-controls label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.95rem;
        }

        .demo-controls input[type="range"] {
            width: 150px;
        }

        .highlight-box {
            background: #e7f3ff;
            border-left: 5px solid #2196F3;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 5px;
        }

        .highlight-box strong {
            color: #2196F3;
        }

        .citation {
            font-style: italic;
            color: #6c757d;
            font-size: 0.95rem;
        }

        .grid-2col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 2rem 0;
        }

        @media (max-width: 768px) {
            .hero h1 {
                font-size: 2rem;
            }
            .hero .subtitle {
                font-size: 1rem;
            }
            .section {
                padding: 1.5rem;
            }
            .grid-2col {
                grid-template-columns: 1fr;
            }
        }

        .scroll-indicator {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            animation: bounce 2s infinite;
            z-index: 1;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateX(-50%) translateY(0);
            }
            40% {
                transform: translateX(-50%) translateY(-20px);
            }
            60% {
                transform: translateX(-50%) translateY(-10px);
            }
        }

        .conclusion {
            max-width: 1200px;
            margin: 4rem auto;
            padding: 3rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            text-align: center;
        }

        .conclusion h2 {
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
        }

        .conclusion p {
            font-size: 1.2rem;
            line-height: 1.8;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <!-- Hero Section with Background Animation -->
    <div class="hero">
        <canvas id="heroCanvas"></canvas>
        <h1>The Complete History of Computational Visualizations and Simulations</h1>
        <p class="subtitle">From Turing's morphogenesis to modern web-based interactive science</p>
        <div class="scroll-indicator">
            <svg width="30" height="50" viewBox="0 0 30 50">
                <rect x="5" y="5" width="20" height="35" rx="10" fill="none" stroke="white" stroke-width="2"/>
                <circle cx="15" cy="15" r="3" fill="white" opacity="0.8">
                    <animate attributeName="cy" from="15" to="30" dur="1.5s" repeatCount="indefinite"/>
                    <animate attributeName="opacity" from="0.8" to="0" dur="1.5s" repeatCount="indefinite"/>
                </circle>
            </svg>
        </div>
    </div>

    <!-- Interactive Timeline -->
    <div class="timeline">
        <h2>Timeline of Innovation</h2>
        <canvas id="timelineCanvas"></canvas>
        <p style="text-align: center; color: #6c757d; margin-top: 1rem; font-style: italic;">
            Hover over events to explore key milestones from 1950 to 2025
        </p>
    </div>

    <!-- Introduction -->
    <div class="section">
        <h2>The Evolution of Computational Science</h2>
        <p>The evolution of computational science from simple automata to complex systems modeling represents one of the most profound intellectual achievements of the 20th century. Beginning with Alan Turing's 1952 morphogenesis paper and John von Neumann's self-replicating automata, computational visualizations transformed from theoretical curiosities into essential tools spanning biology, physics, sociology, and computer graphics.</p>

        <p>These simulations became canonical educational examples because they demonstrated <strong>emergence</strong>—how simple local rules generate complex global behavior—while remaining accessible enough for students to implement and explore. From Conway's Game of Life running on 1970 minicomputers to today's browser-based WebGL simulations, this democratization of computational tools enabled millions to experience firsthand the mathematical principles underlying natural phenomena.</p>
    </div>

    <!-- Section 1: Game of Life -->
    <div class="section">
        <h2>Conway's Game of Life: The Birth of Popular Cellular Automata</h2>

        <p>The breakthrough to mainstream visibility came with John Horton Conway's Game of Life in 1970, popularized by Martin Gardner's October 1970 <em>Scientific American</em> column "Mathematical Games." Conway designed his cellular automaton at Cambridge University using graph paper and Go boards, establishing three elegant rules:</p>

        <div class="highlight-box">
            <strong>The Rules of Life:</strong><br>
            • Survival: Cells with 2-3 neighbors survive<br>
            • Birth: Cells with exactly 3 neighbors are born<br>
            • Death: All others die
        </div>

        <p>Bill Gosper's MIT team discovered the glider gun in November 1970, winning Conway's $50 prize by proving unlimited growth possible and establishing Life's Turing completeness. The timing proved perfect—inexpensive minicomputers allowed overnight simulations, and Life's extreme simplicity producing rich emergent behavior made it an instant educational classic.</p>

        <div class="demo-container">
            <h4>Interactive Demo: Conway's Game of Life</h4>
            <canvas id="lifeCanvas" class="demo-canvas" width="800" height="600"></canvas>
            <div class="demo-controls">
                <button id="lifeStart">Start</button>
                <button id="lifePause">Pause</button>
                <button id="lifeReset">Reset</button>
                <button id="lifeGlider">Add Glider</button>
                <button id="lifeGun">Add Glider Gun</button>
                <label>
                    Speed: <input type="range" id="lifeSpeed" min="1" max="60" value="10">
                </label>
            </div>
            <p class="citation">Click cells to toggle them alive/dead. Watch emergent patterns form from simple rules.</p>
        </div>
    </div>

    <!-- Section 2: Wolfram Cellular Automata -->
    <div class="section">
        <h2>Wolfram's Elementary Cellular Automata</h2>

        <p>The theoretical underpinnings of cellular automata achieved rigorous formulation through Stephen Wolfram's systematic investigation beginning in 1981. His June 1983 paper "Statistical Mechanics of Cellular Automata" introduced the influential four-class classification system for elementary cellular automata.</p>

        <p>Wolfram identified <strong>Rule 110</strong> as Turing complete, with Matthew Cook proving this rigorously in 2004. Among 88 unique elementary CA, Rule 110 stands as one of the simplest known Turing-complete systems. <strong>Rule 30</strong> generates seemingly random patterns from simple initial states, leading Wolfram to use it as Mathematica's pseudorandom number generator.</p>

        <div class="demo-container">
            <h4>Interactive Demo: Elementary Cellular Automata</h4>
            <canvas id="caCanvas" class="demo-canvas" width="800" height="600"></canvas>
            <div class="demo-controls">
                <label>
                    Rule: <input type="number" id="caRule" min="0" max="255" value="30" style="width: 80px;">
                </label>
                <button id="caGenerate">Generate</button>
                <button id="caRule30">Rule 30</button>
                <button id="caRule110">Rule 110</button>
                <button id="caRule90">Rule 90</button>
            </div>
            <p class="citation">Each rule produces dramatically different patterns from identical starting conditions.</p>
        </div>
    </div>

    <!-- Section 3: Boids and Emergent Behavior -->
    <div class="section">
        <h2>Boids: Emergence of Collective Behavior</h2>

        <p>Craig Reynolds revolutionized computer animation with boids in 1987, presenting "Flocks, Herds, and Schools: A Distributed Behavioral Model" at SIGGRAPH. His three steering behaviors produced realistic flocking from local rules alone:</p>

        <div class="highlight-box">
            <strong>The Three Rules of Boids:</strong><br>
            • <strong>Separation:</strong> Avoid crowding neighbors<br>
            • <strong>Alignment:</strong> Match neighbors' heading<br>
            • <strong>Cohesion:</strong> Move toward neighbors' center of mass
        </div>

        <p>First demonstrated in the 1987 short "Stanley and Stella in: Breaking the Ice," boids made their feature film debut in Tim Burton's "Batman Returns" (1992) for bat swarms and penguin armies. Reynolds received an Academy Award for technical achievement in 1998.</p>

        <div class="demo-container">
            <h4>Interactive Demo: Flocking Boids</h4>
            <canvas id="boidsCanvas" class="demo-canvas" width="800" height="600"></canvas>
            <div class="demo-controls">
                <button id="boidsReset">Reset</button>
                <label>
                    Separation: <input type="range" id="boidsSeparation" min="0" max="3" step="0.1" value="1.5">
                </label>
                <label>
                    Alignment: <input type="range" id="boidsAlignment" min="0" max="3" step="0.1" value="1">
                </label>
                <label>
                    Cohesion: <input type="range" id="boidsCohesion" min="0" max="3" step="0.1" value="1">
                </label>
            </div>
            <p class="citation">Adjust the three forces to see how local rules create global patterns. Click to attract boids.</p>
        </div>
    </div>

    <!-- Section 4: Chaos Theory and Lorenz Attractor -->
    <div class="section">
        <h2>Chaos Theory: Deterministic Unpredictability</h2>

        <p>Edward Lorenz's 1963 paper "Deterministic Nonperiodic Flow" introduced the Lorenz attractor. The MIT meteorologist discovered sensitive dependence on initial conditions in winter 1961 when rounding .506127 to .506 produced drastically different weather simulations on his Royal McBee computer.</p>

        <p>His three differential equations with standard parameters σ=10, ρ=28, β=8/3 create a butterfly-shaped attractor in 3D phase space exhibiting sensitivity, fractal dimension ~2.06, and never-repeating trajectories. His 1972 talk popularized the "butterfly effect."</p>

        <div class="demo-container">
            <h4>Interactive Demo: Lorenz Attractor</h4>
            <canvas id="lorenzCanvas" class="demo-canvas" width="800" height="600"></canvas>
            <div class="demo-controls">
                <button id="lorenzReset">Reset</button>
                <button id="lorenzPause">Pause</button>
                <label>
                    σ (sigma): <input type="range" id="lorenzSigma" min="5" max="15" step="0.1" value="10">
                    <span id="sigmaValue">10.0</span>
                </label>
                <label>
                    ρ (rho): <input type="range" id="lorenzRho" min="20" max="35" step="0.1" value="28">
                    <span id="rhoValue">28.0</span>
                </label>
            </div>
            <p class="citation">Drag to rotate. Watch the chaotic butterfly emerge from deterministic equations.</p>
        </div>
    </div>

    <!-- Section 5: Mandelbrot Set -->
    <div class="section">
        <h2>Fractals: Infinite Complexity from Simple Rules</h2>

        <p>Benoit Mandelbrot first visualized the Mandelbrot set on March 1, 1980 at IBM's Thomas J. Watson Research Center using computer graphics. Though Robert Brooks and Peter Matelski defined the set in 1978, Mandelbrot's December 1980 paper and his 1982 masterwork "The Fractal Geometry of Nature" made fractals accessible worldwide.</p>

        <p>The Mandelbrot set M = {c ∈ ℂ : sequence z₀=0, z_{n+1}=z_n² + c remains bounded} exhibits uncountable complexity with fractal dimension ~2 and infinitely many self-similar miniature copies. <em>Scientific American</em>'s August 1985 cover article introduced the algorithm to home computer users, triggering widespread public engagement.</p>

        <div class="demo-container">
            <h4>Interactive Demo: Mandelbrot Set Explorer</h4>
            <canvas id="mandelbrotCanvas" class="demo-canvas" width="800" height="600"></canvas>
            <div class="demo-controls">
                <button id="mandelbrotReset">Reset View</button>
                <button id="mandelbrotRender">Render</button>
                <label>
                    Max Iterations: <input type="range" id="mandelbrotIterations" min="50" max="500" value="100">
                    <span id="iterValue">100</span>
                </label>
            </div>
            <p class="citation">Click to zoom in. Discover infinite detail at every scale.</p>
        </div>
    </div>

    <!-- Section 6: Reaction-Diffusion -->
    <div class="section">
        <h2>Reaction-Diffusion: Turing's Pattern Formation</h2>

        <p>Alan Turing's 1952 paper "The Chemical Basis of Morphogenesis" proposed that two diffusing chemicals (morphogens) with different diffusion rates could spontaneously generate patterns from uniform states. This remained largely theoretical until computing power advanced sufficiently in the 1960s-1970s.</p>

        <p>P. Gray and S.K. Scott developed their reaction-diffusion model in papers from 1983-1985. The Gray-Scott equations describe autocatalytic reaction U + 2V → 3V with feed rate F and kill rate k parameters. Different F-k combinations produce vastly different behaviors, from stable structures to dynamic chaos.</p>

        <div class="demo-container">
            <h4>Interactive Demo: Reaction-Diffusion Patterns</h4>
            <canvas id="reactionCanvas" class="demo-canvas" width="800" height="600"></canvas>
            <div class="demo-controls">
                <button id="reactionStart">Start</button>
                <button id="reactionPause">Pause</button>
                <button id="reactionReset">Reset</button>
                <button id="reactionSpots">Spots</button>
                <button id="reactionStripes">Stripes</button>
                <button id="reactionWaves">Waves</button>
            </div>
            <p class="citation">Watch organic patterns emerge from chemical equations. Click to add perturbations.</p>
        </div>
    </div>

    <!-- Section 7: L-Systems -->
    <div class="section">
        <h2>L-Systems: Algorithmic Plant Growth</h2>

        <p>Aristid Lindenmayer's 1968 papers in <em>Journal of Theoretical Biology</em> introduced L-systems for modeling filamentous organisms. The Hungarian theoretical biologist at Utrecht University developed parallel rewriting systems where productions apply simultaneously rather than sequentially.</p>

        <p>Przemyslaw Prusinkiewicz transformed L-systems into practical computer graphics tools in the 1980s at University of Calgary. His development of turtle interpretation methods using LOGO-style graphics enabled realistic plant visualization. The 1990 book "The Algorithmic Beauty of Plants" became the field's seminal reference.</p>

        <div class="demo-container">
            <h4>Interactive Demo: L-System Plant Growth</h4>
            <canvas id="lsystemCanvas" class="demo-canvas" width="800" height="600"></canvas>
            <div class="demo-controls">
                <button id="lsystemTree">Tree</button>
                <button id="lsystemFern">Fern</button>
                <button id="lsystemBush">Bush</button>
                <button id="lsystemGrow">Grow</button>
                <label>
                    Generations: <input type="range" id="lsystemGen" min="1" max="7" value="4">
                    <span id="genValue">4</span>
                </label>
            </div>
            <p class="citation">Watch plants grow through recursive rule application.</p>
        </div>
    </div>

    <!-- Section 8: Network Theory -->
    <div class="section">
        <h2>Network Theory: From Small Worlds to Scale-Free Networks</h2>

        <p>Duncan Watts and Steven Strogatz's June 1998 <em>Nature</em> paper "Collective dynamics of 'small-world' networks" resolved the dichotomy between regular and random networks. Their model starts with a ring lattice, then randomly rewires edges with probability p, creating networks with short path lengths and high clustering—explaining the "six degrees of separation" phenomenon mathematically.</p>

        <p>Albert-László Barabási and Réka Albert's October 1999 <em>Science</em> paper "Emergence of scaling in random networks" established scale-free networks through growth and preferential attachment. Their model continuously adds vertices connecting preferentially to well-connected nodes, producing power-law degree distributions with no characteristic scale.</p>

        <div class="demo-container">
            <h4>Interactive Demo: Network Evolution</h4>
            <canvas id="networkCanvas" class="demo-canvas" width="800" height="600"></canvas>
            <div class="demo-controls">
                <button id="networkRegular">Regular</button>
                <button id="networkSmallWorld">Small World</button>
                <button id="networkScaleFree">Scale-Free</button>
                <button id="networkGrow">Grow Network</button>
                <button id="networkReset">Reset</button>
            </div>
            <p class="citation">Observe different network topologies and their emergent properties.</p>
        </div>
    </div>

    <!-- Section 9: Visualization Technologies -->
    <div class="section">
        <h2>The Democratization of Visualization</h2>

        <p>Ivan Sutherland's Sketchpad (1963 MIT PhD thesis) pioneered interactive computer graphics. Silicon Graphics released OpenGL in 1992 as a cross-platform standard. Ricardo Cabello (Mr.doob) released Three.js in April 2010, making WebGL accessible to non-graphics programmers.</p>

        <p>WebGL 1.0 specification released March 2011 enabled GPU-accelerated graphics directly in browsers without plugins. Mike Bostock announced D3.js in 2011 at Stanford, revolutionizing data visualization with its "Data-Driven Documents" philosophy. Processing (2001) and p5.js (2014) brought creative coding to millions.</p>

        <div class="highlight-box">
            <strong>Key Technological Milestones:</strong><br>
            • 1963: Sketchpad - First interactive graphics<br>
            • 1992: OpenGL - Cross-platform 3D standard<br>
            • 2001: Processing - Creative coding for artists<br>
            • 2010: Three.js - 3D graphics for the web<br>
            • 2011: WebGL - GPU in the browser<br>
            • 2011: D3.js - Data-driven documents<br>
            • 2017: WebAssembly - Near-native performance
        </div>

        <p>This 10,000× cost reduction and accessibility transformation—from 1970s minicomputers requiring million-dollar equipment to modern browsers accessible worldwide—fundamentally changed computational science education from elite specialization to universal access.</p>
    </div>

    <!-- Section 10: Why These Became Canonical -->
    <div class="section">
        <h2>Why These Visualizations Became Canonical Examples</h2>

        <p>These computational visualizations achieved canonical status through converging factors transcending individual technical merit:</p>

        <h3>Pedagogical Accessibility</h3>
        <p>Game of Life's three rules producing complex behavior, Schelling's segregation demonstrating emergence with coins on paper, and boids' three steering laws creating realistic flocks provided intuitive entry points requiring minimal mathematical sophistication. Students could implement these in single programming sessions while exploring enough depth for advanced research.</p>

        <h3>Visual Appeal and Emergence</h3>
        <p>Mandelbrot set's infinite detail, Lorenz attractor's butterfly wings, reaction-diffusion's organic patterns, and double pendulum's chaotic paths provided aesthetic hooks capturing imagination beyond technical audiences. The gap between simple rules and complex outcomes—<strong>emergence</strong>—became directly observable rather than abstract theorem.</p>

        <h3>Interdisciplinary Relevance</h3>
        <p>Turing patterns explain zebrafish stripes and seashell patterns, evolutionary algorithms optimize NASA antennas and financial portfolios, network models apply equally to neural connectivity and epidemic spread, L-systems generate both plant morphology and game levels. This versatility made single implementations teach transferable principles spanning biology, physics, economics, and computer science.</p>

        <h3>Open-Source Culture</h3>
        <p>Processing, NetLogo, D3.js, Three.js, and most frameworks discussed provide free access with extensive documentation, examples, and active communities. This eliminated financial barriers while collective knowledge accelerated learning. The 600+ NetLogo models, thousands of Processing sketches, and abundant D3 examples created scaffolding enabling progressive mastery.</p>

        <h3>Historical Timing</h3>
        <p>Conway's Life appeared precisely when 1970 minicomputers enabled overnight simulations. NetLogo's 1999 release coincided with classroom computing becoming standard. WebGL's 2011 specification arrived as JavaScript performance enabled sophisticated browser applications. Each breakthrough lowered entry barriers at the exact moment technology could support mass adoption.</p>
    </div>

    <!-- Conclusion -->
    <div class="conclusion">
        <h2>The Continuing Evolution</h2>
        <p>From von Neumann's 1940s self-replicating automata through today's GPU-accelerated web visualizations, computational science evolved by making complex phenomena experientially accessible—transforming abstract mathematics into interactive exploration tools enabling millions to discover how simple rules generate the complex beauty underlying natural and artificial systems.</p>

        <p>A 2025 student with browser access can implement Conway's Life, visualize Lorenz attractors, simulate disease spread on scale-free networks, evolve L-system plants, and animate boids flocking—all activities requiring million-dollar equipment and specialized expertise mere decades ago.</p>

        <p>These canonical examples persist because they successfully balance simplicity and depth, provide visual feedback, demonstrate emergence, span disciplines, and offer scaffolding from beginner exercises to research frontiers. Educational tools became research instruments, and research advances continue feeding back into refined educational implementations—a virtuous cycle where accessibility enhances understanding, which enables innovation, which produces more powerful yet accessible tools for the next generation of computational scientists.</p>
    </div>

    <script>
        // =================================================================
        // HERO CANVAS - Game of Life Background
        // =================================================================
        const heroCanvas = document.getElementById('heroCanvas');
        const heroCtx = heroCanvas.getContext('2d');

        function resizeHeroCanvas() {
            heroCanvas.width = window.innerWidth;
            heroCanvas.height = window.innerHeight;
        }
        resizeHeroCanvas();
        window.addEventListener('resize', resizeHeroCanvas);

        const heroCellSize = 20;
        const heroRows = Math.ceil(heroCanvas.height / heroCellSize);
        const heroCols = Math.ceil(heroCanvas.width / heroCellSize);
        let heroGrid = createRandomGrid(heroRows, heroCols, 0.15);

        function createRandomGrid(rows, cols, density) {
            return Array.from({length: rows}, () =>
                Array.from({length: cols}, () => Math.random() < density ? 1 : 0)
            );
        }

        function updateHeroLife() {
            const newGrid = heroGrid.map(row => [...row]);
            for (let i = 0; i < heroRows; i++) {
                for (let j = 0; j < heroCols; j++) {
                    const neighbors = countNeighbors(heroGrid, i, j, heroRows, heroCols);
                    if (heroGrid[i][j] === 1) {
                        newGrid[i][j] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
                    } else {
                        newGrid[i][j] = neighbors === 3 ? 1 : 0;
                    }
                }
            }
            heroGrid = newGrid;
        }

        function drawHeroLife() {
            heroCtx.fillStyle = '#667eea';
            heroCtx.fillRect(0, 0, heroCanvas.width, heroCanvas.height);
            heroCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < heroRows; i++) {
                for (let j = 0; j < heroCols; j++) {
                    if (heroGrid[i][j] === 1) {
                        heroCtx.fillRect(j * heroCellSize, i * heroCellSize, heroCellSize - 1, heroCellSize - 1);
                    }
                }
            }
        }

        function animateHero() {
            updateHeroLife();
            drawHeroLife();
            setTimeout(() => requestAnimationFrame(animateHero), 200);
        }
        animateHero();

        // =================================================================
        // TIMELINE CANVAS
        // =================================================================
        const timelineCanvas = document.getElementById('timelineCanvas');
        const timelineCtx = timelineCanvas.getContext('2d');
        timelineCanvas.width = timelineCanvas.offsetWidth;

        const events = [
            {year: 1952, label: "Turing's Morphogenesis", color: '#e74c3c'},
            {year: 1963, label: "Lorenz Attractor", color: '#3498db'},
            {year: 1970, label: "Conway's Game of Life", color: '#2ecc71'},
            {year: 1980, label: "Mandelbrot Set", color: '#9b59b6'},
            {year: 1987, label: "Reynolds' Boids", color: '#f39c12'},
            {year: 1990, label: "L-Systems Book", color: '#1abc9c'},
            {year: 1998, label: "Small-World Networks", color: '#e67e22'},
            {year: 1999, label: "Scale-Free Networks", color: '#c0392b'},
            {year: 2001, label: "Processing", color: '#16a085'},
            {year: 2010, label: "Three.js", color: '#8e44ad'},
            {year: 2011, label: "WebGL & D3.js", color: '#27ae60'},
            {year: 2017, label: "WebAssembly", color: '#2980b9'}
        ];

        function drawTimeline() {
            const padding = 40;
            const width = timelineCanvas.width - 2 * padding;
            const height = timelineCanvas.height;
            const minYear = 1950;
            const maxYear = 2025;

            // Draw timeline axis
            timelineCtx.strokeStyle = '#667eea';
            timelineCtx.lineWidth = 3;
            timelineCtx.beginPath();
            timelineCtx.moveTo(padding, height / 2);
            timelineCtx.lineTo(timelineCanvas.width - padding, height / 2);
            timelineCtx.stroke();

            // Draw events
            events.forEach(event => {
                const x = padding + ((event.year - minYear) / (maxYear - minYear)) * width;
                const y = height / 2;

                // Event marker
                timelineCtx.fillStyle = event.color;
                timelineCtx.beginPath();
                timelineCtx.arc(x, y, 8, 0, Math.PI * 2);
                timelineCtx.fill();

                // Event label
                timelineCtx.save();
                timelineCtx.translate(x, y);
                timelineCtx.rotate(-Math.PI / 4);
                timelineCtx.fillStyle = '#2c3e50';
                timelineCtx.font = '12px Georgia';
                timelineCtx.fillText(event.label, 10, -10);
                timelineCtx.fillText(event.year, 10, 5);
                timelineCtx.restore();
            });
        }
        drawTimeline();

        timelineCanvas.addEventListener('mousemove', (e) => {
            const rect = timelineCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const padding = 40;
            const width = timelineCanvas.width - 2 * padding;
            const minYear = 1950;
            const maxYear = 2025;

            events.forEach(event => {
                const eventX = padding + ((event.year - minYear) / (maxYear - minYear)) * width;
                const eventY = timelineCanvas.height / 2;
                const dist = Math.sqrt((x - eventX) ** 2 + (y - eventY) ** 2);

                if (dist < 15) {
                    timelineCanvas.style.cursor = 'pointer';
                    drawTimeline();
                    timelineCtx.fillStyle = 'rgba(102, 126, 234, 0.1)';
                    timelineCtx.fillRect(eventX - 50, eventY - 100, 100, 80);
                    timelineCtx.fillStyle = event.color;
                    timelineCtx.font = 'bold 14px Georgia';
                    timelineCtx.fillText(event.year, eventX - 20, eventY - 70);
                    timelineCtx.font = '12px Georgia';
                    timelineCtx.fillStyle = '#2c3e50';
                    const words = event.label.split(' ');
                    words.forEach((word, i) => {
                        timelineCtx.fillText(word, eventX - 40, eventY - 50 + i * 15);
                    });
                }
            });
        });

        // =================================================================
        // GAME OF LIFE
        // =================================================================
        const lifeCanvas = document.getElementById('lifeCanvas');
        const lifeCtx = lifeCanvas.getContext('2d');
        const lifeCellSize = 8;
        const lifeRows = Math.floor(lifeCanvas.height / lifeCellSize);
        const lifeCols = Math.floor(lifeCanvas.width / lifeCellSize);
        let lifeGrid = createRandomGrid(lifeRows, lifeCols, 0.3);
        let lifeRunning = false;
        let lifeSpeed = 10;

        function countNeighbors(grid, row, col, rows, cols) {
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    const newRow = (row + i + rows) % rows;
                    const newCol = (col + j + cols) % cols;
                    count += grid[newRow][newCol];
                }
            }
            return count;
        }

        function drawLife() {
            lifeCtx.fillStyle = '#000';
            lifeCtx.fillRect(0, 0, lifeCanvas.width, lifeCanvas.height);
            lifeCtx.fillStyle = '#00ff00';
            for (let i = 0; i < lifeRows; i++) {
                for (let j = 0; j < lifeCols; j++) {
                    if (lifeGrid[i][j] === 1) {
                        lifeCtx.fillRect(j * lifeCellSize, i * lifeCellSize, lifeCellSize - 1, lifeCellSize - 1);
                    }
                }
            }
        }

        function updateLife() {
            const newGrid = lifeGrid.map(row => [...row]);
            for (let i = 0; i < lifeRows; i++) {
                for (let j = 0; j < lifeCols; j++) {
                    const neighbors = countNeighbors(lifeGrid, i, j, lifeRows, lifeCols);
                    if (lifeGrid[i][j] === 1) {
                        newGrid[i][j] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
                    } else {
                        newGrid[i][j] = neighbors === 3 ? 1 : 0;
                    }
                }
            }
            lifeGrid = newGrid;
            drawLife();
        }

        function lifeLoop() {
            if (lifeRunning) {
                updateLife();
                setTimeout(() => requestAnimationFrame(lifeLoop), 1000 / lifeSpeed);
            }
        }

        lifeCanvas.addEventListener('click', (e) => {
            const rect = lifeCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const col = Math.floor(x / lifeCellSize);
            const row = Math.floor(y / lifeCellSize);
            lifeGrid[row][col] = 1 - lifeGrid[row][col];
            drawLife();
        });

        document.getElementById('lifeStart').addEventListener('click', () => {
            lifeRunning = true;
            lifeLoop();
        });
        document.getElementById('lifePause').addEventListener('click', () => lifeRunning = false);
        document.getElementById('lifeReset').addEventListener('click', () => {
            lifeGrid = createRandomGrid(lifeRows, lifeCols, 0.3);
            drawLife();
        });
        document.getElementById('lifeSpeed').addEventListener('input', (e) => {
            lifeSpeed = parseInt(e.target.value);
        });

        // Add glider
        document.getElementById('lifeGlider').addEventListener('click', () => {
            const row = Math.floor(lifeRows / 2);
            const col = Math.floor(lifeCols / 2);
            lifeGrid[row][col+1] = 1;
            lifeGrid[row+1][col+2] = 1;
            lifeGrid[row+2][col] = 1;
            lifeGrid[row+2][col+1] = 1;
            lifeGrid[row+2][col+2] = 1;
            drawLife();
        });

        // Add glider gun (simplified)
        document.getElementById('lifeGun').addEventListener('click', () => {
            const row = 10;
            const col = 10;
            // Left square
            [[0,0],[0,1],[1,0],[1,1]].forEach(([r,c]) => lifeGrid[row+r][col+c] = 1);
            // Generator
            [[0,10],[1,10],[2,10],[0,11],[1,11],[2,11]].forEach(([r,c]) => lifeGrid[row+r][col+c] = 1);
            drawLife();
        });

        drawLife();

        // =================================================================
        // CELLULAR AUTOMATA
        // =================================================================
        const caCanvas = document.getElementById('caCanvas');
        const caCtx = caCanvas.getContext('2d');
        const caCellSize = 2;
        const caWidth = Math.floor(caCanvas.width / caCellSize);
        const caHeight = Math.floor(caCanvas.height / caCellSize);

        function drawCA(rule) {
            let cells = new Array(caWidth).fill(0);
            cells[Math.floor(caWidth / 2)] = 1;

            caCtx.fillStyle = '#000';
            caCtx.fillRect(0, 0, caCanvas.width, caCanvas.height);

            for (let y = 0; y < caHeight; y++) {
                for (let x = 0; x < caWidth; x++) {
                    if (cells[x] === 1) {
                        caCtx.fillStyle = '#00ffff';
                        caCtx.fillRect(x * caCellSize, y * caCellSize, caCellSize, caCellSize);
                    }
                }

                const newCells = new Array(caWidth).fill(0);
                for (let x = 0; x < caWidth; x++) {
                    const left = cells[(x - 1 + caWidth) % caWidth];
                    const center = cells[x];
                    const right = cells[(x + 1) % caWidth];
                    const config = (left << 2) | (center << 1) | right;
                    newCells[x] = (rule >> config) & 1;
                }
                cells = newCells;
            }
        }

        document.getElementById('caGenerate').addEventListener('click', () => {
            const rule = parseInt(document.getElementById('caRule').value);
            drawCA(rule);
        });
        document.getElementById('caRule30').addEventListener('click', () => {
            document.getElementById('caRule').value = 30;
            drawCA(30);
        });
        document.getElementById('caRule110').addEventListener('click', () => {
            document.getElementById('caRule').value = 110;
            drawCA(110);
        });
        document.getElementById('caRule90').addEventListener('click', () => {
            document.getElementById('caRule').value = 90;
            drawCA(90);
        });

        drawCA(30);

        // =================================================================
        // BOIDS
        // =================================================================
        const boidsCanvas = document.getElementById('boidsCanvas');
        const boidsCtx = boidsCanvas.getContext('2d');

        class Boid {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.ax = 0;
                this.ay = 0;
            }

            update() {
                this.vx += this.ax;
                this.vy += this.ay;
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const maxSpeed = 4;
                if (speed > maxSpeed) {
                    this.vx = (this.vx / speed) * maxSpeed;
                    this.vy = (this.vy / speed) * maxSpeed;
                }
                this.x += this.vx;
                this.y += this.vy;

                if (this.x < 0) this.x = boidsCanvas.width;
                if (this.x > boidsCanvas.width) this.x = 0;
                if (this.y < 0) this.y = boidsCanvas.height;
                if (this.y > boidsCanvas.height) this.y = 0;

                this.ax = 0;
                this.ay = 0;
            }

            draw() {
                const angle = Math.atan2(this.vy, this.vx);
                boidsCtx.save();
                boidsCtx.translate(this.x, this.y);
                boidsCtx.rotate(angle);
                boidsCtx.fillStyle = '#00ffff';
                boidsCtx.beginPath();
                boidsCtx.moveTo(8, 0);
                boidsCtx.lineTo(-8, 4);
                boidsCtx.lineTo(-8, -4);
                boidsCtx.closePath();
                boidsCtx.fill();
                boidsCtx.restore();
            }
        }

        let boids = [];
        for (let i = 0; i < 50; i++) {
            boids.push(new Boid(Math.random() * boidsCanvas.width, Math.random() * boidsCanvas.height));
        }

        let separationForce = 1.5;
        let alignmentForce = 1;
        let cohesionForce = 1;
        let mouseX = -1000;
        let mouseY = -1000;

        function updateBoids() {
            boids.forEach(boid => {
                let separationX = 0, separationY = 0;
                let alignmentX = 0, alignmentY = 0;
                let cohesionX = 0, cohesionY = 0;
                let neighbors = 0;

                boids.forEach(other => {
                    if (boid === other) return;
                    const dx = other.x - boid.x;
                    const dy = other.y - boid.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 50) {
                        separationX -= dx / dist;
                        separationY -= dy / dist;
                    }

                    if (dist < 100) {
                        alignmentX += other.vx;
                        alignmentY += other.vy;
                        cohesionX += other.x;
                        cohesionY += other.y;
                        neighbors++;
                    }
                });

                if (neighbors > 0) {
                    alignmentX /= neighbors;
                    alignmentY /= neighbors;
                    cohesionX = cohesionX / neighbors - boid.x;
                    cohesionY = cohesionY / neighbors - boid.y;
                }

                // Mouse attraction
                const mdx = mouseX - boid.x;
                const mdy = mouseY - boid.y;
                const mdist = Math.sqrt(mdx * mdx + mdy * mdy);
                if (mdist < 200 && mdist > 0) {
                    boid.ax += (mdx / mdist) * 0.5;
                    boid.ay += (mdy / mdist) * 0.5;
                }

                boid.ax += separationX * separationForce * 0.05;
                boid.ay += separationY * separationForce * 0.05;
                boid.ax += alignmentX * alignmentForce * 0.05;
                boid.ay += alignmentY * alignmentForce * 0.05;
                boid.ax += cohesionX * cohesionForce * 0.01;
                boid.ay += cohesionY * cohesionForce * 0.01;

                boid.update();
            });
        }

        function drawBoids() {
            boidsCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            boidsCtx.fillRect(0, 0, boidsCanvas.width, boidsCanvas.height);
            boids.forEach(boid => boid.draw());
        }

        function animateBoids() {
            updateBoids();
            drawBoids();
            requestAnimationFrame(animateBoids);
        }

        boidsCanvas.addEventListener('mousemove', (e) => {
            const rect = boidsCanvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        boidsCanvas.addEventListener('mouseleave', () => {
            mouseX = -1000;
            mouseY = -1000;
        });

        document.getElementById('boidsReset').addEventListener('click', () => {
            boids = [];
            for (let i = 0; i < 50; i++) {
                boids.push(new Boid(Math.random() * boidsCanvas.width, Math.random() * boidsCanvas.height));
            }
        });

        document.getElementById('boidsSeparation').addEventListener('input', (e) => {
            separationForce = parseFloat(e.target.value);
        });
        document.getElementById('boidsAlignment').addEventListener('input', (e) => {
            alignmentForce = parseFloat(e.target.value);
        });
        document.getElementById('boidsCohesion').addEventListener('input', (e) => {
            cohesionForce = parseFloat(e.target.value);
        });

        boidsCtx.fillStyle = '#000';
        boidsCtx.fillRect(0, 0, boidsCanvas.width, boidsCanvas.height);
        animateBoids();

        // =================================================================
        // LORENZ ATTRACTOR
        // =================================================================
        const lorenzCanvas = document.getElementById('lorenzCanvas');
        const lorenzCtx = lorenzCanvas.getContext('2d');

        let lorenzSigma = 10;
        let lorenzRho = 28;
        const lorenzBeta = 8/3;
        let lorenzX = 0.1;
        let lorenzY = 0;
        let lorenzZ = 0;
        let lorenzPoints = [];
        let lorenzPaused = false;
        let lorenzRotation = 0;

        function updateLorenz() {
            const dt = 0.01;
            const dx = lorenzSigma * (lorenzY - lorenzX);
            const dy = lorenzX * (lorenzRho - lorenzZ) - lorenzY;
            const dz = lorenzX * lorenzY - lorenzBeta * lorenzZ;

            lorenzX += dx * dt;
            lorenzY += dy * dt;
            lorenzZ += dz * dt;

            lorenzPoints.push({x: lorenzX, y: lorenzY, z: lorenzZ});
            if (lorenzPoints.length > 3000) lorenzPoints.shift();
        }

        function drawLorenz() {
            lorenzCtx.fillStyle = 'rgba(0, 0, 0, 0.02)';
            lorenzCtx.fillRect(0, 0, lorenzCanvas.width, lorenzCanvas.height);

            const scale = 8;
            const centerX = lorenzCanvas.width / 2;
            const centerY = lorenzCanvas.height / 2;

            lorenzCtx.strokeStyle = '#00ffff';
            lorenzCtx.lineWidth = 1;
            lorenzCtx.beginPath();

            lorenzPoints.forEach((point, i) => {
                // 3D rotation
                const x = point.x;
                const y = point.y * Math.cos(lorenzRotation) - point.z * Math.sin(lorenzRotation);
                const z = point.y * Math.sin(lorenzRotation) + point.z * Math.cos(lorenzRotation);

                const screenX = centerX + x * scale;
                const screenY = centerY - y * scale;

                if (i === 0) {
                    lorenzCtx.moveTo(screenX, screenY);
                } else {
                    lorenzCtx.lineTo(screenX, screenY);
                }
            });
            lorenzCtx.stroke();
        }

        function animateLorenz() {
            if (!lorenzPaused) {
                for (let i = 0; i < 5; i++) updateLorenz();
                drawLorenz();
            }
            requestAnimationFrame(animateLorenz);
        }

        lorenzCanvas.addEventListener('mousedown', (e) => {
            let startX = e.clientX;
            const mousemove = (e) => {
                lorenzRotation += (e.clientX - startX) * 0.01;
                startX = e.clientX;
            };
            const mouseup = () => {
                document.removeEventListener('mousemove', mousemove);
                document.removeEventListener('mouseup', mouseup);
            };
            document.addEventListener('mousemove', mousemove);
            document.addEventListener('mouseup', mouseup);
        });

        document.getElementById('lorenzReset').addEventListener('click', () => {
            lorenzX = 0.1;
            lorenzY = 0;
            lorenzZ = 0;
            lorenzPoints = [];
            lorenzCtx.fillStyle = '#000';
            lorenzCtx.fillRect(0, 0, lorenzCanvas.width, lorenzCanvas.height);
        });

        document.getElementById('lorenzPause').addEventListener('click', (e) => {
            lorenzPaused = !lorenzPaused;
            e.target.textContent = lorenzPaused ? 'Resume' : 'Pause';
        });

        document.getElementById('lorenzSigma').addEventListener('input', (e) => {
            lorenzSigma = parseFloat(e.target.value);
            document.getElementById('sigmaValue').textContent = lorenzSigma.toFixed(1);
        });

        document.getElementById('lorenzRho').addEventListener('input', (e) => {
            lorenzRho = parseFloat(e.target.value);
            document.getElementById('rhoValue').textContent = lorenzRho.toFixed(1);
        });

        lorenzCtx.fillStyle = '#000';
        lorenzCtx.fillRect(0, 0, lorenzCanvas.width, lorenzCanvas.height);
        animateLorenz();

        // =================================================================
        // MANDELBROT SET
        // =================================================================
        const mandelbrotCanvas = document.getElementById('mandelbrotCanvas');
        const mandelbrotCtx = mandelbrotCanvas.getContext('2d');

        let mandelbrotZoom = 1;
        let mandelbrotCenterX = -0.5;
        let mandelbrotCenterY = 0;
        let mandelbrotMaxIter = 100;

        function mandelbrot(x, y, maxIter) {
            let real = x;
            let imag = y;
            for (let i = 0; i < maxIter; i++) {
                const real2 = real * real - imag * imag + x;
                const imag2 = 2 * real * imag + y;
                real = real2;
                imag = imag2;
                if (real * real + imag * imag > 4) {
                    return i;
                }
            }
            return maxIter;
        }

        function renderMandelbrot() {
            const imageData = mandelbrotCtx.createImageData(mandelbrotCanvas.width, mandelbrotCanvas.height);
            const width = mandelbrotCanvas.width;
            const height = mandelbrotCanvas.height;

            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const x = mandelbrotCenterX + (px - width / 2) / (width / 4 * mandelbrotZoom);
                    const y = mandelbrotCenterY + (py - height / 2) / (height / 4 * mandelbrotZoom);

                    const iter = mandelbrot(x, y, mandelbrotMaxIter);
                    const idx = (py * width + px) * 4;

                    if (iter === mandelbrotMaxIter) {
                        imageData.data[idx] = 0;
                        imageData.data[idx + 1] = 0;
                        imageData.data[idx + 2] = 0;
                    } else {
                        const hue = (iter / mandelbrotMaxIter) * 360;
                        const rgb = hslToRgb(hue, 100, 50);
                        imageData.data[idx] = rgb[0];
                        imageData.data[idx + 1] = rgb[1];
                        imageData.data[idx + 2] = rgb[2];
                    }
                    imageData.data[idx + 3] = 255;
                }
            }
            mandelbrotCtx.putImageData(imageData, 0, 0);
        }

        function hslToRgb(h, s, l) {
            h /= 360;
            s /= 100;
            l /= 100;
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        mandelbrotCanvas.addEventListener('click', (e) => {
            const rect = mandelbrotCanvas.getBoundingClientRect();
            const px = e.clientX - rect.left;
            const py = e.clientY - rect.top;
            mandelbrotCenterX += (px - mandelbrotCanvas.width / 2) / (mandelbrotCanvas.width / 4 * mandelbrotZoom);
            mandelbrotCenterY += (py - mandelbrotCanvas.height / 2) / (mandelbrotCanvas.height / 4 * mandelbrotZoom);
            mandelbrotZoom *= 2;
            renderMandelbrot();
        });

        document.getElementById('mandelbrotReset').addEventListener('click', () => {
            mandelbrotZoom = 1;
            mandelbrotCenterX = -0.5;
            mandelbrotCenterY = 0;
            renderMandelbrot();
        });

        document.getElementById('mandelbrotRender').addEventListener('click', () => {
            renderMandelbrot();
        });

        document.getElementById('mandelbrotIterations').addEventListener('input', (e) => {
            mandelbrotMaxIter = parseInt(e.target.value);
            document.getElementById('iterValue').textContent = mandelbrotMaxIter;
        });

        renderMandelbrot();

        // =================================================================
        // REACTION-DIFFUSION
        // =================================================================
        const reactionCanvas = document.getElementById('reactionCanvas');
        const reactionCtx = reactionCanvas.getContext('2d');

        const rdWidth = 200;
        const rdHeight = 150;
        const rdScale = reactionCanvas.width / rdWidth;

        let gridA = Array(rdWidth * rdHeight).fill(1);
        let gridB = Array(rdWidth * rdHeight).fill(0);
        let rdRunning = false;
        let rdF = 0.055;
        let rdK = 0.062;

        // Initialize with perturbation
        for (let i = 90; i < 110; i++) {
            for (let j = 70; j < 80; j++) {
                gridB[i + j * rdWidth] = 1;
            }
        }

        function laplacian(grid, x, y) {
            let sum = 0;
            sum += grid[x + y * rdWidth] * -1;
            sum += grid[(x-1+rdWidth)%rdWidth + y * rdWidth] * 0.2;
            sum += grid[(x+1)%rdWidth + y * rdWidth] * 0.2;
            sum += grid[x + ((y-1+rdHeight)%rdHeight) * rdWidth] * 0.2;
            sum += grid[x + ((y+1)%rdHeight) * rdWidth] * 0.2;
            sum += grid[(x-1+rdWidth)%rdWidth + ((y-1+rdHeight)%rdHeight) * rdWidth] * 0.05;
            sum += grid[(x+1)%rdWidth + ((y-1+rdHeight)%rdHeight) * rdWidth] * 0.05;
            sum += grid[(x-1+rdWidth)%rdWidth + ((y+1)%rdHeight) * rdWidth] * 0.05;
            sum += grid[(x+1)%rdWidth + ((y+1)%rdHeight) * rdWidth] * 0.05;
            return sum;
        }

        function updateReactionDiffusion() {
            const newA = [...gridA];
            const newB = [...gridB];
            const dA = 1.0;
            const dB = 0.5;

            for (let x = 1; x < rdWidth - 1; x++) {
                for (let y = 1; y < rdHeight - 1; y++) {
                    const i = x + y * rdWidth;
                    const a = gridA[i];
                    const b = gridB[i];

                    const laplaceA = laplacian(gridA, x, y);
                    const laplaceB = laplacian(gridB, x, y);

                    const reaction = a * b * b;
                    newA[i] = a + (dA * laplaceA - reaction + rdF * (1 - a));
                    newB[i] = b + (dB * laplaceB + reaction - (rdK + rdF) * b);

                    newA[i] = Math.max(0, Math.min(1, newA[i]));
                    newB[i] = Math.max(0, Math.min(1, newB[i]));
                }
            }

            gridA = newA;
            gridB = newB;
        }

        function drawReactionDiffusion() {
            const imageData = reactionCtx.createImageData(rdWidth, rdHeight);
            for (let i = 0; i < rdWidth * rdHeight; i++) {
                const value = Math.floor((gridA[i] - gridB[i]) * 255);
                imageData.data[i * 4] = value;
                imageData.data[i * 4 + 1] = value;
                imageData.data[i * 4 + 2] = value;
                imageData.data[i * 4 + 3] = 255;
            }
            createImageBitmap(imageData).then(bitmap => {
                reactionCtx.drawImage(bitmap, 0, 0, rdWidth, rdHeight, 0, 0, reactionCanvas.width, reactionCanvas.height);
            });
        }

        function animateReactionDiffusion() {
            if (rdRunning) {
                for (let i = 0; i < 10; i++) updateReactionDiffusion();
                drawReactionDiffusion();
            }
            requestAnimationFrame(animateReactionDiffusion);
        }

        reactionCanvas.addEventListener('click', (e) => {
            const rect = reactionCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / rdScale);
            const y = Math.floor((e.clientY - rect.top) / rdScale);
            for (let i = -5; i < 5; i++) {
                for (let j = -5; j < 5; j++) {
                    const idx = (x + i) + (y + j) * rdWidth;
                    if (idx >= 0 && idx < rdWidth * rdHeight) {
                        gridB[idx] = 1;
                    }
                }
            }
        });

        document.getElementById('reactionStart').addEventListener('click', () => rdRunning = true);
        document.getElementById('reactionPause').addEventListener('click', () => rdRunning = false);
        document.getElementById('reactionReset').addEventListener('click', () => {
            gridA = Array(rdWidth * rdHeight).fill(1);
            gridB = Array(rdWidth * rdHeight).fill(0);
            for (let i = 90; i < 110; i++) {
                for (let j = 70; j < 80; j++) {
                    gridB[i + j * rdWidth] = 1;
                }
            }
            drawReactionDiffusion();
        });

        document.getElementById('reactionSpots').addEventListener('click', () => {
            rdF = 0.055;
            rdK = 0.062;
        });
        document.getElementById('reactionStripes').addEventListener('click', () => {
            rdF = 0.035;
            rdK = 0.065;
        });
        document.getElementById('reactionWaves').addEventListener('click', () => {
            rdF = 0.014;
            rdK = 0.054;
        });

        animateReactionDiffusion();

        // =================================================================
        // L-SYSTEMS
        // =================================================================
        const lsystemCanvas = document.getElementById('lsystemCanvas');
        const lsystemCtx = lsystemCanvas.getContext('2d');

        let currentSystem = {
            axiom: 'F',
            rules: {'F': 'FF+[+F-F-F]-[-F+F+F]'},
            angle: 22.5,
            length: 5,
            generations: 4
        };

        const systems = {
            tree: {
                axiom: 'F',
                rules: {'F': 'FF+[+F-F-F]-[-F+F+F]'},
                angle: 22.5,
                length: 3,
                generations: 4
            },
            fern: {
                axiom: 'X',
                rules: {'X': 'F+[[X]-X]-F[-FX]+X', 'F': 'FF'},
                angle: 25,
                length: 3,
                generations: 5
            },
            bush: {
                axiom: 'F',
                rules: {'F': 'F[+F]F[-F]F'},
                angle: 25,
                length: 4,
                generations: 4
            }
        };

        function generateLSystem(axiom, rules, generations) {
            let result = axiom;
            for (let i = 0; i < generations; i++) {
                let next = '';
                for (let char of result) {
                    next += rules[char] || char;
                }
                result = next;
            }
            return result;
        }

        function drawLSystem() {
            lsystemCtx.fillStyle = '#000';
            lsystemCtx.fillRect(0, 0, lsystemCanvas.width, lsystemCanvas.height);

            const instructions = generateLSystem(
                currentSystem.axiom,
                currentSystem.rules,
                currentSystem.generations
            );

            lsystemCtx.strokeStyle = '#00ff00';
            lsystemCtx.lineWidth = 1;

            let x = lsystemCanvas.width / 2;
            let y = lsystemCanvas.height - 50;
            let angle = -90;
            const stack = [];

            lsystemCtx.beginPath();
            lsystemCtx.moveTo(x, y);

            for (let char of instructions) {
                if (char === 'F') {
                    const newX = x + Math.cos(angle * Math.PI / 180) * currentSystem.length;
                    const newY = y + Math.sin(angle * Math.PI / 180) * currentSystem.length;
                    lsystemCtx.lineTo(newX, newY);
                    x = newX;
                    y = newY;
                } else if (char === '+') {
                    angle += currentSystem.angle;
                } else if (char === '-') {
                    angle -= currentSystem.angle;
                } else if (char === '[') {
                    stack.push({x, y, angle});
                } else if (char === ']') {
                    lsystemCtx.stroke();
                    const state = stack.pop();
                    x = state.x;
                    y = state.y;
                    angle = state.angle;
                    lsystemCtx.beginPath();
                    lsystemCtx.moveTo(x, y);
                }
            }
            lsystemCtx.stroke();
        }

        document.getElementById('lsystemTree').addEventListener('click', () => {
            currentSystem = {...systems.tree};
            document.getElementById('lsystemGen').value = currentSystem.generations;
            document.getElementById('genValue').textContent = currentSystem.generations;
            drawLSystem();
        });

        document.getElementById('lsystemFern').addEventListener('click', () => {
            currentSystem = {...systems.fern};
            document.getElementById('lsystemGen').value = currentSystem.generations;
            document.getElementById('genValue').textContent = currentSystem.generations;
            drawLSystem();
        });

        document.getElementById('lsystemBush').addEventListener('click', () => {
            currentSystem = {...systems.bush};
            document.getElementById('lsystemGen').value = currentSystem.generations;
            document.getElementById('genValue').textContent = currentSystem.generations;
            drawLSystem();
        });

        document.getElementById('lsystemGrow').addEventListener('click', () => {
            if (currentSystem.generations < 7) {
                currentSystem.generations++;
                document.getElementById('lsystemGen').value = currentSystem.generations;
                document.getElementById('genValue').textContent = currentSystem.generations;
                drawLSystem();
            }
        });

        document.getElementById('lsystemGen').addEventListener('input', (e) => {
            currentSystem.generations = parseInt(e.target.value);
            document.getElementById('genValue').textContent = currentSystem.generations;
            drawLSystem();
        });

        drawLSystem();

        // =================================================================
        // NETWORK VISUALIZATION
        // =================================================================
        const networkCanvas = document.getElementById('networkCanvas');
        const networkCtx = networkCanvas.getContext('2d');

        class Node {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.id = id;
                this.degree = 0;
            }

            draw(size) {
                networkCtx.fillStyle = '#00ffff';
                networkCtx.beginPath();
                networkCtx.arc(this.x, this.y, size, 0, Math.PI * 2);
                networkCtx.fill();
            }
        }

        let nodes = [];
        let edges = [];

        function createRegularNetwork(n) {
            nodes = [];
            edges = [];
            const radius = Math.min(networkCanvas.width, networkCanvas.height) / 2 - 50;
            const cx = networkCanvas.width / 2;
            const cy = networkCanvas.height / 2;

            for (let i = 0; i < n; i++) {
                const angle = (i / n) * 2 * Math.PI;
                nodes.push(new Node(
                    cx + radius * Math.cos(angle),
                    cy + radius * Math.sin(angle),
                    i
                ));
            }

            for (let i = 0; i < n; i++) {
                edges.push([i, (i + 1) % n]);
                edges.push([i, (i + 2) % n]);
            }

            updateDegrees();
        }

        function createSmallWorldNetwork(n, p) {
            createRegularNetwork(n);
            const newEdges = [];

            edges.forEach(([a, b]) => {
                if (Math.random() < p) {
                    let newTarget = Math.floor(Math.random() * n);
                    while (newTarget === a || newTarget === b) {
                        newTarget = Math.floor(Math.random() * n);
                    }
                    newEdges.push([a, newTarget]);
                } else {
                    newEdges.push([a, b]);
                }
            });

            edges = newEdges;
            updateDegrees();
        }

        function createScaleFreeNetwork(n) {
            nodes = [];
            edges = [];
            const cx = networkCanvas.width / 2;
            const cy = networkCanvas.height / 2;

            // Start with triangle
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * 2 * Math.PI;
                nodes.push(new Node(
                    cx + 100 * Math.cos(angle),
                    cy + 100 * Math.sin(angle),
                    i
                ));
            }
            edges.push([0, 1], [1, 2], [2, 0]);

            // Preferential attachment
            for (let i = 3; i < n; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const radius = 50 + Math.random() * (Math.min(networkCanvas.width, networkCanvas.height) / 2 - 100);
                nodes.push(new Node(
                    cx + radius * Math.cos(angle),
                    cy + radius * Math.sin(angle),
                    i
                ));

                const degrees = nodes.map((node, idx) => {
                    if (idx >= i) return 0;
                    return edges.filter(([a, b]) => a === idx || b === idx).length;
                });
                const totalDegree = degrees.reduce((a, b) => a + b, 0);

                // Add 2 edges using preferential attachment
                const targets = new Set();
                while (targets.size < Math.min(2, i)) {
                    let r = Math.random() * totalDegree;
                    for (let j = 0; j < i; j++) {
                        r -= degrees[j];
                        if (r <= 0) {
                            targets.add(j);
                            break;
                        }
                    }
                }
                targets.forEach(target => edges.push([i, target]));
            }

            updateDegrees();
        }

        function updateDegrees() {
            nodes.forEach(node => node.degree = 0);
            edges.forEach(([a, b]) => {
                nodes[a].degree++;
                nodes[b].degree++;
            });
        }

        function applyForces() {
            const repulsion = 1000;
            const attraction = 0.01;
            const damping = 0.9;

            // Repulsion
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = repulsion / (dist * dist);
                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;
                    nodes[i].vx -= fx;
                    nodes[i].vy -= fy;
                    nodes[j].vx += fx;
                    nodes[j].vy += fy;
                }
            }

            // Attraction along edges
            edges.forEach(([a, b]) => {
                const dx = nodes[b].x - nodes[a].x;
                const dy = nodes[b].y - nodes[a].y;
                const fx = dx * attraction;
                const fy = dy * attraction;
                nodes[a].vx += fx;
                nodes[a].vy += fy;
                nodes[b].vx -= fx;
                nodes[b].vy -= fy;
            });

            // Update positions
            nodes.forEach(node => {
                node.x += node.vx;
                node.y += node.vy;
                node.vx *= damping;
                node.vy *= damping;

                // Keep in bounds
                node.x = Math.max(20, Math.min(networkCanvas.width - 20, node.x));
                node.y = Math.max(20, Math.min(networkCanvas.height - 20, node.y));
            });
        }

        function drawNetwork() {
            networkCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            networkCtx.fillRect(0, 0, networkCanvas.width, networkCanvas.height);

            // Draw edges
            networkCtx.strokeStyle = 'rgba(100, 100, 255, 0.3)';
            networkCtx.lineWidth = 1;
            edges.forEach(([a, b]) => {
                networkCtx.beginPath();
                networkCtx.moveTo(nodes[a].x, nodes[a].y);
                networkCtx.lineTo(nodes[b].x, nodes[b].y);
                networkCtx.stroke();
            });

            // Draw nodes
            nodes.forEach(node => {
                const size = 3 + Math.sqrt(node.degree) * 2;
                node.draw(size);
            });
        }

        function animateNetwork() {
            applyForces();
            drawNetwork();
            requestAnimationFrame(animateNetwork);
        }

        document.getElementById('networkRegular').addEventListener('click', () => {
            createRegularNetwork(20);
            networkCtx.fillStyle = '#000';
            networkCtx.fillRect(0, 0, networkCanvas.width, networkCanvas.height);
        });

        document.getElementById('networkSmallWorld').addEventListener('click', () => {
            createSmallWorldNetwork(20, 0.1);
            networkCtx.fillStyle = '#000';
            networkCtx.fillRect(0, 0, networkCanvas.width, networkCanvas.height);
        });

        document.getElementById('networkScaleFree').addEventListener('click', () => {
            createScaleFreeNetwork(30);
            networkCtx.fillStyle = '#000';
            networkCtx.fillRect(0, 0, networkCanvas.width, networkCanvas.height);
        });

        document.getElementById('networkGrow').addEventListener('click', () => {
            if (nodes.length > 0 && nodes.length < 50) {
                const n = nodes.length;
                const cx = networkCanvas.width / 2;
                const cy = networkCanvas.height / 2;
                const angle = Math.random() * 2 * Math.PI;
                const radius = 50 + Math.random() * (Math.min(networkCanvas.width, networkCanvas.height) / 2 - 100);
                nodes.push(new Node(
                    cx + radius * Math.cos(angle),
                    cy + radius * Math.sin(angle),
                    n
                ));

                // Connect to random existing node
                const target = Math.floor(Math.random() * n);
                edges.push([n, target]);
                updateDegrees();
            }
        });

        document.getElementById('networkReset').addEventListener('click', () => {
            nodes = [];
            edges = [];
            networkCtx.fillStyle = '#000';
            networkCtx.fillRect(0, 0, networkCanvas.width, networkCanvas.height);
        });

        createRegularNetwork(20);
        networkCtx.fillStyle = '#000';
        networkCtx.fillRect(0, 0, networkCanvas.width, networkCanvas.height);
        animateNetwork();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>