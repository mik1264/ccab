<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Complete History of Computational Visualizations - WebGL Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            line-height: 1.8;
            color: #2c3e50;
            background: linear-gradient(to bottom, #0a0a1a 0%, #1a1a2e 100%);
        }

        .hero {
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }

        .hero-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .hero-content {
            position: relative;
            z-index: 1;
            text-align: center;
            padding: 2rem;
        }

        .hero h1 {
            font-size: 3.5rem;
            font-weight: 300;
            margin-bottom: 1rem;
            text-shadow: 0 0 30px rgba(100, 200, 255, 0.5);
            max-width: 1200px;
            color: white;
            background: linear-gradient(135deg, #64ffda 0%, #a78bfa 50%, #f472b6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero .subtitle {
            font-size: 1.3rem;
            font-weight: 300;
            color: rgba(255,255,255,0.9);
            max-width: 900px;
            font-style: italic;
        }

        .scroll-indicator {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            animation: bounce 2s infinite;
            z-index: 1;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateX(-50%) translateY(0); }
            40% { transform: translateX(-50%) translateY(-20px); }
            60% { transform: translateX(-50%) translateY(-10px); }
        }

        .timeline {
            max-width: 1200px;
            margin: 4rem auto;
            padding: 2rem;
            background: rgba(20, 20, 40, 0.9);
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5), 0 0 60px rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.2);
        }

        .timeline h2 {
            text-align: center;
            font-size: 2.5rem;
            background: linear-gradient(135deg, #64ffda 0%, #a78bfa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 2rem;
        }

        .timeline-canvas {
            width: 100%;
            height: 300px;
            cursor: crosshair;
            border-radius: 10px;
        }

        .section {
            max-width: 1200px;
            margin: 4rem auto;
            padding: 3rem;
            background: rgba(20, 20, 40, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5), 0 0 60px rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.2);
        }

        .section h2 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, #64ffda 0%, #a78bfa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid rgba(100, 200, 255, 0.3);
            padding-bottom: 0.5rem;
        }

        .section h3 {
            font-size: 1.8rem;
            color: #a78bfa;
            margin-top: 2rem;
            margin-bottom: 1rem;
        }

        .section p {
            margin-bottom: 1.2rem;
            font-size: 1.1rem;
            text-align: justify;
            color: rgba(255,255,255,0.85);
        }

        .demo-container {
            margin: 2rem 0;
            padding: 1.5rem;
            background: rgba(10, 10, 30, 0.8);
            border-radius: 10px;
            border-left: 5px solid #64ffda;
        }

        .demo-container h4 {
            color: #64ffda;
            margin-bottom: 1rem;
            font-size: 1.3rem;
        }

        .demo-canvas {
            width: 100%;
            height: 500px;
            border-radius: 8px;
            background: #000;
            cursor: pointer;
            display: block;
            margin: 1rem 0;
        }

        .demo-controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .demo-controls button {
            padding: 0.6rem 1.5rem;
            background: linear-gradient(135deg, #64ffda 0%, #a78bfa 100%);
            color: #0a0a1a;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s;
        }

        .demo-controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(100, 200, 255, 0.4);
        }

        .demo-controls label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.95rem;
            color: rgba(255,255,255,0.8);
        }

        .demo-controls input[type="range"] {
            width: 120px;
            accent-color: #64ffda;
        }

        .demo-controls input[type="number"] {
            width: 70px;
            padding: 0.3rem;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            color: white;
        }

        .highlight-box {
            background: rgba(100, 200, 255, 0.1);
            border-left: 5px solid #64ffda;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 5px;
            color: rgba(255,255,255,0.9);
        }

        .highlight-box strong {
            color: #64ffda;
        }

        .citation {
            font-style: italic;
            color: rgba(255,255,255,0.6);
            font-size: 0.95rem;
        }

        .conclusion {
            max-width: 1200px;
            margin: 4rem auto;
            padding: 3rem;
            background: linear-gradient(135deg, rgba(100, 255, 218, 0.1) 0%, rgba(167, 139, 250, 0.1) 100%);
            border: 1px solid rgba(100, 200, 255, 0.3);
            color: white;
            border-radius: 15px;
            text-align: center;
        }

        .conclusion h2 {
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #64ffda 0%, #a78bfa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .conclusion p {
            font-size: 1.2rem;
            line-height: 1.8;
            margin-bottom: 1rem;
            color: rgba(255,255,255,0.85);
        }

        @media (max-width: 768px) {
            .hero h1 { font-size: 2rem; }
            .hero .subtitle { font-size: 1rem; }
            .section { padding: 1.5rem; }
            .demo-canvas { height: 300px; }
        }

        .webgl-badge {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #64ffda 0%, #a78bfa 100%);
            color: #0a0a1a;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(100, 200, 255, 0.4);
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #64ffda;
            text-decoration: none;
            z-index: 1000;
            font-size: 1rem;
            transition: all 0.3s;
        }

        .back-link:hover {
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">← Back to Gallery</a>
    <div class="webgl-badge">WebGL Enhanced</div>

    <!-- Hero Section with GPU Game of Life -->
    <div class="hero">
        <canvas id="heroCanvas" class="hero-canvas"></canvas>
        <div class="hero-content">
            <h1>The Complete History of Computational Visualizations and Simulations</h1>
            <p class="subtitle">From Turing's morphogenesis to modern GPU-accelerated web-based interactive science</p>
        </div>
        <div class="scroll-indicator">
            <svg width="30" height="50" viewBox="0 0 30 50">
                <rect x="5" y="5" width="20" height="35" rx="10" fill="none" stroke="rgba(100, 255, 218, 0.8)" stroke-width="2"/>
                <circle cx="15" cy="15" r="3" fill="#64ffda" opacity="0.8">
                    <animate attributeName="cy" from="15" to="30" dur="1.5s" repeatCount="indefinite"/>
                    <animate attributeName="opacity" from="0.8" to="0" dur="1.5s" repeatCount="indefinite"/>
                </circle>
            </svg>
        </div>
    </div>

    <!-- Interactive Timeline -->
    <div class="timeline">
        <h2>Timeline of Innovation</h2>
        <canvas id="timelineCanvas" class="timeline-canvas"></canvas>
        <p style="text-align: center; color: rgba(255,255,255,0.6); margin-top: 1rem; font-style: italic;">
            Hover over events to explore key milestones from 1950 to 2025
        </p>
    </div>

    <!-- Introduction -->
    <div class="section">
        <h2>The Evolution of Computational Science</h2>
        <p>The evolution of computational science from simple automata to complex systems modeling represents one of the most profound intellectual achievements of the 20th century. Beginning with Alan Turing's 1952 morphogenesis paper and John von Neumann's self-replicating automata, computational visualizations transformed from theoretical curiosities into essential tools spanning biology, physics, sociology, and computer graphics.</p>
        <p>These simulations became canonical educational examples because they demonstrated <strong style="color: #64ffda;">emergence</strong>—how simple local rules generate complex global behavior—while remaining accessible enough for students to implement and explore.</p>
    </div>

    <!-- Section 1: Game of Life -->
    <div class="section">
        <h2>Conway's Game of Life: The Birth of Popular Cellular Automata</h2>
        <p>The breakthrough to mainstream visibility came with John Horton Conway's Game of Life in 1970, popularized by Martin Gardner's October 1970 <em>Scientific American</em> column.</p>
        <div class="highlight-box">
            <strong>The Rules of Life:</strong><br>
            • Survival: Cells with 2-3 neighbors survive<br>
            • Birth: Cells with exactly 3 neighbors are born<br>
            • Death: All others die
        </div>
        <div class="demo-container">
            <h4>Interactive Demo: GPU-Accelerated Game of Life</h4>
            <canvas id="lifeCanvas" class="demo-canvas"></canvas>
            <div class="demo-controls">
                <button id="lifeStart">Start</button>
                <button id="lifePause">Pause</button>
                <button id="lifeReset">Reset</button>
                <button id="lifeGlider">Add Glider</button>
                <label>Speed: <input type="range" id="lifeSpeed" min="1" max="60" value="30"></label>
            </div>
            <p class="citation">GPU-accelerated simulation. Click to toggle cells.</p>
        </div>
    </div>

    <!-- Section 2: Wolfram Cellular Automata -->
    <div class="section">
        <h2>Wolfram's Elementary Cellular Automata</h2>
        <p>Stephen Wolfram's systematic investigation beginning in 1981 formulated the theoretical underpinnings of cellular automata. <strong style="color: #64ffda;">Rule 110</strong> is Turing complete. <strong style="color: #a78bfa;">Rule 30</strong> generates seemingly random patterns.</p>
        <div class="demo-container">
            <h4>Interactive Demo: Elementary Cellular Automata</h4>
            <canvas id="caCanvas" class="demo-canvas"></canvas>
            <div class="demo-controls">
                <label>Rule: <input type="number" id="caRule" min="0" max="255" value="30"></label>
                <button id="caGenerate">Generate</button>
                <button id="caRule30">Rule 30</button>
                <button id="caRule110">Rule 110</button>
                <button id="caRule90">Rule 90</button>
            </div>
            <p class="citation">WebGL-rendered cellular automata with gradient coloring.</p>
        </div>
    </div>

    <!-- Section 3: Boids -->
    <div class="section">
        <h2>Boids: Emergence of Collective Behavior</h2>
        <p>Craig Reynolds revolutionized computer animation with boids in 1987. His three steering behaviors produced realistic flocking from local rules alone:</p>
        <div class="highlight-box">
            <strong>The Three Rules of Boids:</strong><br>
            • <strong>Separation:</strong> Avoid crowding neighbors<br>
            • <strong>Alignment:</strong> Match neighbors' heading<br>
            • <strong>Cohesion:</strong> Move toward neighbors' center of mass
        </div>
        <div class="demo-container">
            <h4>Interactive Demo: 3D Flocking Boids</h4>
            <canvas id="boidsCanvas" class="demo-canvas"></canvas>
            <div class="demo-controls">
                <button id="boidsReset">Reset</button>
                <label>Separation: <input type="range" id="boidsSeparation" min="0" max="3" step="0.1" value="1.5"></label>
                <label>Alignment: <input type="range" id="boidsAlignment" min="0" max="3" step="0.1" value="1"></label>
                <label>Cohesion: <input type="range" id="boidsCohesion" min="0" max="3" step="0.1" value="1"></label>
            </div>
            <p class="citation">Three.js 3D boids. Drag to orbit, scroll to zoom.</p>
        </div>
    </div>

    <!-- Section 4: Lorenz Attractor -->
    <div class="section">
        <h2>Chaos Theory: Deterministic Unpredictability</h2>
        <p>Edward Lorenz's 1963 paper "Deterministic Nonperiodic Flow" introduced the Lorenz attractor. His three differential equations with parameters σ=10, ρ=28, β=8/3 create a butterfly-shaped attractor in 3D phase space.</p>
        <div class="demo-container">
            <h4>Interactive Demo: 3D Lorenz Attractor</h4>
            <canvas id="lorenzCanvas" class="demo-canvas"></canvas>
            <div class="demo-controls">
                <button id="lorenzReset">Reset</button>
                <button id="lorenzPause">Pause</button>
                <label>σ: <input type="range" id="lorenzSigma" min="5" max="15" step="0.1" value="10"> <span id="sigmaValue">10.0</span></label>
                <label>ρ: <input type="range" id="lorenzRho" min="20" max="35" step="0.1" value="28"> <span id="rhoValue">28.0</span></label>
            </div>
            <p class="citation">Three.js with glow effects. Drag to orbit the butterfly.</p>
        </div>
    </div>

    <!-- Section 5: Mandelbrot -->
    <div class="section">
        <h2>Fractals: Infinite Complexity from Simple Rules</h2>
        <p>Benoit Mandelbrot first visualized the Mandelbrot set on March 1, 1980 at IBM. The set exhibits uncountable complexity with fractal dimension ~2 and infinitely many self-similar miniature copies.</p>
        <div class="demo-container">
            <h4>Interactive Demo: GPU Mandelbrot Set Explorer</h4>
            <canvas id="mandelbrotCanvas" class="demo-canvas"></canvas>
            <div class="demo-controls">
                <button id="mandelbrotReset">Reset View</button>
                <label>Iterations: <input type="range" id="mandelbrotIterations" min="100" max="1000" value="300"> <span id="iterValue">300</span></label>
            </div>
            <p class="citation">WebGL2 fragment shader with smooth coloring. Click to zoom in.</p>
        </div>
    </div>

    <!-- Section 6: Reaction-Diffusion -->
    <div class="section">
        <h2>Reaction-Diffusion: Turing's Pattern Formation</h2>
        <p>Alan Turing's 1952 paper proposed that two diffusing chemicals with different diffusion rates could spontaneously generate patterns. The Gray-Scott model produces vastly different behaviors based on feed and kill rates.</p>
        <div class="demo-container">
            <h4>Interactive Demo: GPU Reaction-Diffusion</h4>
            <canvas id="reactionCanvas" class="demo-canvas"></canvas>
            <div class="demo-controls">
                <button id="reactionStart">Start</button>
                <button id="reactionPause">Pause</button>
                <button id="reactionReset">Reset</button>
                <button id="reactionMitosis">Mitosis</button>
                <button id="reactionCoral">Coral</button>
                <button id="reactionWaves">Waves</button>
            </div>
            <p class="citation">GPU-accelerated Gray-Scott model. Click to add seeds.</p>
        </div>
    </div>

    <!-- Section 7: L-Systems -->
    <div class="section">
        <h2>L-Systems: Algorithmic Plant Growth</h2>
        <p>Aristid Lindenmayer's 1968 papers introduced L-systems for modeling organisms. Przemyslaw Prusinkiewicz's 1990 book "The Algorithmic Beauty of Plants" became the field's seminal reference.</p>
        <div class="demo-container">
            <h4>Interactive Demo: 3D L-System Trees</h4>
            <canvas id="lsystemCanvas" class="demo-canvas"></canvas>
            <div class="demo-controls">
                <button id="lsystemTree">Tree</button>
                <button id="lsystemFern">Fern</button>
                <button id="lsystemBush">Bush</button>
                <label>Generations: <input type="range" id="lsystemGen" min="1" max="6" value="4"> <span id="genValue">4</span></label>
            </div>
            <p class="citation">Three.js 3D trees with cylinder branches. Drag to orbit.</p>
        </div>
    </div>

    <!-- Section 8: Networks -->
    <div class="section">
        <h2>Network Theory: From Small Worlds to Scale-Free Networks</h2>
        <p>Watts & Strogatz (1998) introduced small-world networks. Barabási & Albert (1999) established scale-free networks through preferential attachment.</p>
        <div class="demo-container">
            <h4>Interactive Demo: 3D Network Visualization</h4>
            <canvas id="networkCanvas" class="demo-canvas"></canvas>
            <div class="demo-controls">
                <button id="networkRegular">Regular</button>
                <button id="networkSmallWorld">Small World</button>
                <button id="networkScaleFree">Scale-Free</button>
                <button id="networkReset">Reset</button>
            </div>
            <p class="citation">Force-directed 3D network. Drag to rotate.</p>
        </div>
    </div>

    <!-- Conclusion -->
    <div class="conclusion">
        <h2>The Continuing Evolution</h2>
        <p>From von Neumann's 1940s self-replicating automata through today's GPU-accelerated WebGL visualizations, computational science evolved by making complex phenomena experientially accessible.</p>
        <p>A 2025 student with browser access can implement GPU-accelerated simulations that required million-dollar equipment mere decades ago.</p>
    </div>

    <!-- Load Three.js via ES modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // =================================================================
    // UTILITY FUNCTIONS
    // =================================================================
    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader compile error:', gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function createProgram(gl, vertexSource, fragmentSource) {
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
        if (!vertexShader || !fragmentShader) return null;
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
            return null;
        }
        return program;
    }

    // =================================================================
    // HERO: GPU GAME OF LIFE
    // =================================================================
    (function() {
        const canvas = document.getElementById('heroCanvas');
        const gl = canvas.getContext('webgl2');
        if (!gl) { console.warn('WebGL2 not supported for hero'); return; }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resize();
        window.addEventListener('resize', resize);

        const width = 256, height = 256;

        const vsSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_texCoord;
            void main() {
                v_texCoord = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0, 1);
            }`;

        const updateFs = `#version 300 es
            precision highp float;
            uniform sampler2D u_state;
            uniform vec2 u_resolution;
            out vec4 outColor;
            void main() {
                vec2 texel = 1.0 / u_resolution;
                vec2 uv = gl_FragCoord.xy / u_resolution;
                float sum = 0.0;
                for(int y = -1; y <= 1; y++) {
                    for(int x = -1; x <= 1; x++) {
                        if(x == 0 && y == 0) continue;
                        vec2 offset = vec2(float(x), float(y)) * texel;
                        sum += texture(u_state, fract(uv + offset)).r;
                    }
                }
                float current = texture(u_state, uv).r;
                float next = (current > 0.5) ? ((sum >= 2.0 && sum <= 3.0) ? 1.0 : 0.0)
                                             : ((sum >= 2.5 && sum <= 3.5) ? 1.0 : 0.0);
                outColor = vec4(next, next, next, 1.0);
            }`;

        const renderFs = `#version 300 es
            precision highp float;
            uniform sampler2D u_state;
            uniform float u_time;
            in vec2 v_texCoord;
            out vec4 outColor;
            void main() {
                float cell = texture(u_state, v_texCoord).r;
                vec3 color1 = vec3(0.4, 1.0, 0.85);
                vec3 color2 = vec3(0.65, 0.55, 0.98);
                vec3 color = mix(color1, color2, v_texCoord.x + sin(u_time * 0.5) * 0.2);
                float glow = cell * 0.8 + 0.2 * cell * sin(u_time + v_texCoord.x * 10.0);
                outColor = vec4(color * glow * 0.6, 1.0);
            }`;

        const updateProgram = createProgram(gl, vsSource, updateFs);
        const renderProgram = createProgram(gl, vsSource, renderFs);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

        function createTexture() {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            return tex;
        }

        const textures = [createTexture(), createTexture()];
        const framebuffers = textures.map(tex => {
            const fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
            return fb;
        });

        function initState() {
            const data = new Uint8Array(width * height * 4);
            for (let i = 0; i < width * height; i++) {
                const v = Math.random() < 0.25 ? 255 : 0;
                data[i*4] = v; data[i*4+1] = v; data[i*4+2] = v; data[i*4+3] = 255;
            }
            gl.bindTexture(gl.TEXTURE_2D, textures[0]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            gl.bindTexture(gl.TEXTURE_2D, textures[1]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
        initState();

        let frame = 0;
        function animate(time) {
            // Update step
            gl.useProgram(updateProgram);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[(frame + 1) % 2]);
            gl.viewport(0, 0, width, height);
            gl.bindTexture(gl.TEXTURE_2D, textures[frame % 2]);
            gl.uniform1i(gl.getUniformLocation(updateProgram, 'u_state'), 0);
            gl.uniform2f(gl.getUniformLocation(updateProgram, 'u_resolution'), width, height);
            const posLoc = gl.getAttribLocation(updateProgram, 'a_position');
            gl.enableVertexAttribArray(posLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // Render step
            gl.useProgram(renderProgram);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.bindTexture(gl.TEXTURE_2D, textures[(frame + 1) % 2]);
            gl.uniform1i(gl.getUniformLocation(renderProgram, 'u_state'), 0);
            gl.uniform1f(gl.getUniformLocation(renderProgram, 'u_time'), time * 0.001);
            const posLoc2 = gl.getAttribLocation(renderProgram, 'a_position');
            gl.enableVertexAttribArray(posLoc2);
            gl.vertexAttribPointer(posLoc2, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            frame++;
            setTimeout(() => requestAnimationFrame(animate), 50);
        }
        animate(0);
    })();

    // =================================================================
    // TIMELINE (Canvas 2D)
    // =================================================================
    (function() {
        const canvas = document.getElementById('timelineCanvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);

        const events = [
            {year: 1952, label: "Turing's Morphogenesis", color: '#f472b6'},
            {year: 1963, label: "Lorenz Attractor", color: '#60a5fa'},
            {year: 1970, label: "Game of Life", color: '#34d399'},
            {year: 1980, label: "Mandelbrot Set", color: '#a78bfa'},
            {year: 1987, label: "Boids", color: '#fbbf24'},
            {year: 1990, label: "L-Systems", color: '#22d3d8'},
            {year: 1998, label: "Small-World", color: '#fb923c'},
            {year: 2011, label: "WebGL", color: '#64ffda'},
        ];

        let hoveredEvent = null;

        function drawTimeline() {
            const w = rect.width;
            const h = rect.height;
            const padding = 60;
            const minYear = 1950, maxYear = 2025;

            ctx.clearRect(0, 0, w, h);

            // Glowing line
            const gradient = ctx.createLinearGradient(padding, 0, w - padding, 0);
            gradient.addColorStop(0, '#64ffda');
            gradient.addColorStop(0.5, '#a78bfa');
            gradient.addColorStop(1, '#f472b6');

            ctx.strokeStyle = gradient;
            ctx.lineWidth = 4;
            ctx.shadowColor = '#64ffda';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(padding, h / 2);
            ctx.lineTo(w - padding, h / 2);
            ctx.stroke();
            ctx.shadowBlur = 0;

            events.forEach((event, i) => {
                const x = padding + ((event.year - minYear) / (maxYear - minYear)) * (w - 2 * padding);
                const y = h / 2;
                const isHovered = hoveredEvent === i;
                const radius = isHovered ? 14 : 10;

                // Glow
                ctx.beginPath();
                ctx.arc(x, y, radius + 8, 0, Math.PI * 2);
                ctx.fillStyle = event.color + '30';
                ctx.fill();

                // Marker
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = event.color;
                ctx.fill();

                // Label
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(-Math.PI / 4);
                ctx.fillStyle = 'rgba(255,255,255,0.95)';
                ctx.font = isHovered ? 'bold 14px Georgia' : '12px Georgia';
                ctx.fillText(event.label, 18, -6);
                ctx.fillStyle = event.color;
                ctx.font = '11px Georgia';
                ctx.fillText(event.year.toString(), 18, 10);
                ctx.restore();
            });
        }

        canvas.addEventListener('mousemove', (e) => {
            const canvasRect = canvas.getBoundingClientRect();
            const x = e.clientX - canvasRect.left;
            const padding = 60;
            const w = rect.width;
            const minYear = 1950, maxYear = 2025;

            hoveredEvent = null;
            events.forEach((event, i) => {
                const eventX = padding + ((event.year - minYear) / (maxYear - minYear)) * (w - 2 * padding);
                if (Math.abs(x - eventX) < 20) hoveredEvent = i;
            });
            drawTimeline();
        });

        drawTimeline();
    })();

    // =================================================================
    // GAME OF LIFE - GPU
    // =================================================================
    (function() {
        const canvas = document.getElementById('lifeCanvas');
        const gl = canvas.getContext('webgl2');
        if (!gl) { console.error('WebGL2 not available'); return; }

        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;

        const width = 400, height = 250;

        const vsSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_texCoord;
            void main() {
                v_texCoord = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0, 1);
            }`;

        const updateFs = `#version 300 es
            precision highp float;
            uniform sampler2D u_state;
            uniform vec2 u_resolution;
            out vec4 outColor;
            void main() {
                vec2 texel = 1.0 / u_resolution;
                vec2 uv = gl_FragCoord.xy / u_resolution;
                float sum = 0.0;
                for(int y = -1; y <= 1; y++) {
                    for(int x = -1; x <= 1; x++) {
                        if(x == 0 && y == 0) continue;
                        sum += texture(u_state, fract(uv + vec2(float(x), float(y)) * texel)).r;
                    }
                }
                float current = texture(u_state, uv).r;
                float next = (current > 0.5) ? ((sum >= 2.0 && sum <= 3.0) ? 1.0 : 0.0)
                                             : ((sum >= 2.5 && sum <= 3.5) ? 1.0 : 0.0);
                outColor = vec4(next, next, next, 1.0);
            }`;

        const renderFs = `#version 300 es
            precision highp float;
            uniform sampler2D u_state;
            in vec2 v_texCoord;
            out vec4 outColor;
            void main() {
                float cell = texture(u_state, v_texCoord).r;
                vec3 alive = vec3(0.4, 1.0, 0.85);
                vec3 dead = vec3(0.02, 0.02, 0.05);
                outColor = vec4(mix(dead, alive, cell), 1.0);
            }`;

        const updateProgram = createProgram(gl, vsSource, updateFs);
        const renderProgram = createProgram(gl, vsSource, renderFs);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

        function createTexture() {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            return tex;
        }

        const textures = [createTexture(), createTexture()];
        const framebuffers = textures.map(tex => {
            const fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
            return fb;
        });

        let stateData = new Uint8Array(width * height * 4);

        function initState() {
            for (let i = 0; i < width * height; i++) {
                const v = Math.random() < 0.3 ? 255 : 0;
                stateData[i*4] = v; stateData[i*4+1] = v; stateData[i*4+2] = v; stateData[i*4+3] = 255;
            }
            gl.bindTexture(gl.TEXTURE_2D, textures[0]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, stateData);
            gl.bindTexture(gl.TEXTURE_2D, textures[1]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, stateData);
        }
        initState();

        let frame = 0, running = false, speed = 30;

        function step() {
            gl.useProgram(updateProgram);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[(frame + 1) % 2]);
            gl.viewport(0, 0, width, height);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures[frame % 2]);
            gl.uniform1i(gl.getUniformLocation(updateProgram, 'u_state'), 0);
            gl.uniform2f(gl.getUniformLocation(updateProgram, 'u_resolution'), width, height);
            const posLoc = gl.getAttribLocation(updateProgram, 'a_position');
            gl.enableVertexAttribArray(posLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            frame++;
        }

        function render() {
            gl.useProgram(renderProgram);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures[frame % 2]);
            gl.uniform1i(gl.getUniformLocation(renderProgram, 'u_state'), 0);
            const posLoc = gl.getAttribLocation(renderProgram, 'a_position');
            gl.enableVertexAttribArray(posLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        function animate() {
            if (running) {
                step();
                render();
                setTimeout(() => requestAnimationFrame(animate), 1000 / speed);
            }
        }

        render();

        function setCell(cx, cy, value) {
            if (cx < 0 || cx >= width || cy < 0 || cy >= height) return;
            const idx = (cx + cy * width) * 4;
            stateData[idx] = value ? 255 : 0;
            stateData[idx+1] = value ? 255 : 0;
            stateData[idx+2] = value ? 255 : 0;
            gl.bindTexture(gl.TEXTURE_2D, textures[frame % 2]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, stateData);
        }

        canvas.addEventListener('click', (e) => {
            const canvasRect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - canvasRect.left) / canvasRect.width * width);
            const y = Math.floor((1 - (e.clientY - canvasRect.top) / canvasRect.height) * height);
            const idx = (x + y * width) * 4;
            const current = stateData[idx] > 127;
            setCell(x, y, !current);
            render();
        });

        document.getElementById('lifeStart').onclick = () => { running = true; animate(); };
        document.getElementById('lifePause').onclick = () => { running = false; };
        document.getElementById('lifeReset').onclick = () => { running = false; initState(); frame = 0; render(); };
        document.getElementById('lifeSpeed').oninput = (e) => { speed = parseInt(e.target.value); };

        document.getElementById('lifeGlider').onclick = () => {
            const cx = Math.floor(width / 2), cy = Math.floor(height / 2);
            [[0,2],[1,0],[1,2],[2,1],[2,2]].forEach(([dx,dy]) => setCell(cx+dx, cy+dy, true));
            render();
        };
    })();

    // =================================================================
    // CELLULAR AUTOMATA
    // =================================================================
    (function() {
        const canvas = document.getElementById('caCanvas');
        const ctx = canvas.getContext('2d');
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;

        const width = Math.floor(rect.width);
        const height = Math.floor(rect.height);

        function generateCA(rule) {
            const imageData = ctx.createImageData(width, height);
            let cells = new Array(width).fill(0);
            cells[Math.floor(width / 2)] = 1;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (x + y * width) * 4;
                    if (cells[x]) {
                        const hue = y / height;
                        imageData.data[idx] = Math.floor((100 + 155 * hue));
                        imageData.data[idx+1] = Math.floor((255 - 100 * hue));
                        imageData.data[idx+2] = Math.floor((218 + 37 * hue));
                        imageData.data[idx+3] = 255;
                    } else {
                        imageData.data[idx] = 5;
                        imageData.data[idx+1] = 5;
                        imageData.data[idx+2] = 16;
                        imageData.data[idx+3] = 255;
                    }
                }
                const newCells = new Array(width).fill(0);
                for (let x = 0; x < width; x++) {
                    const left = cells[(x - 1 + width) % width];
                    const center = cells[x];
                    const right = cells[(x + 1) % width];
                    const config = (left << 2) | (center << 1) | right;
                    newCells[x] = (rule >> config) & 1;
                }
                cells = newCells;
            }
            ctx.putImageData(imageData, 0, 0);
        }

        generateCA(30);

        document.getElementById('caGenerate').onclick = () => generateCA(parseInt(document.getElementById('caRule').value));
        document.getElementById('caRule30').onclick = () => { document.getElementById('caRule').value = 30; generateCA(30); };
        document.getElementById('caRule110').onclick = () => { document.getElementById('caRule').value = 110; generateCA(110); };
        document.getElementById('caRule90').onclick = () => { document.getElementById('caRule').value = 90; generateCA(90); };
    })();

    // =================================================================
    // BOIDS - Three.js 3D
    // =================================================================
    (function() {
        const canvas = document.getElementById('boidsCanvas');
        const rect = canvas.getBoundingClientRect();

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);

        const camera = new THREE.PerspectiveCamera(75, rect.width / rect.height, 0.1, 1000);
        camera.position.z = 150;

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(rect.width, rect.height);

        const controls = new OrbitControls(camera, canvas);
        controls.enableDamping = true;

        const boidGeometry = new THREE.ConeGeometry(1, 3, 6);
        boidGeometry.rotateX(Math.PI / 2);

        const NUM_BOIDS = 150;
        const boids = [];
        const boidMeshes = [];

        class Boid3D {
            constructor() {
                this.position = new THREE.Vector3(
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200
                );
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                this.acceleration = new THREE.Vector3();
            }

            update(separation, alignment, cohesion) {
                const sep = new THREE.Vector3();
                const ali = new THREE.Vector3();
                const coh = new THREE.Vector3();
                let neighbors = 0;

                boids.forEach(other => {
                    if (other === this) return;
                    const d = this.position.distanceTo(other.position);
                    if (d < 20) {
                        sep.add(this.position.clone().sub(other.position).divideScalar(Math.max(d, 0.1)));
                    }
                    if (d < 40) {
                        ali.add(other.velocity);
                        coh.add(other.position);
                        neighbors++;
                    }
                });

                if (neighbors > 0) {
                    ali.divideScalar(neighbors);
                    coh.divideScalar(neighbors).sub(this.position);
                }

                this.acceleration.add(sep.multiplyScalar(separation * 0.05));
                this.acceleration.add(ali.multiplyScalar(alignment * 0.02));
                this.acceleration.add(coh.multiplyScalar(cohesion * 0.01));

                const bound = 100;
                ['x', 'y', 'z'].forEach(axis => {
                    if (this.position[axis] > bound) this.acceleration[axis] -= 0.5;
                    if (this.position[axis] < -bound) this.acceleration[axis] += 0.5;
                });

                this.velocity.add(this.acceleration);
                this.velocity.clampLength(0, 3);
                this.position.add(this.velocity);
                this.acceleration.set(0, 0, 0);
            }
        }

        for (let i = 0; i < NUM_BOIDS; i++) {
            const boid = new Boid3D();
            boids.push(boid);
            const material = new THREE.MeshBasicMaterial();
            material.color.setHSL((i / NUM_BOIDS) * 0.3 + 0.45, 0.8, 0.6);
            const mesh = new THREE.Mesh(boidGeometry, material);
            scene.add(mesh);
            boidMeshes.push(mesh);
        }

        let sepForce = 1.5, aliForce = 1, cohForce = 1;

        function animate() {
            requestAnimationFrame(animate);
            boids.forEach((boid, i) => {
                boid.update(sepForce, aliForce, cohForce);
                boidMeshes[i].position.copy(boid.position);
                if (boid.velocity.length() > 0.1) {
                    boidMeshes[i].lookAt(boid.position.clone().add(boid.velocity));
                }
            });
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        document.getElementById('boidsReset').onclick = () => {
            boids.forEach(boid => {
                boid.position.set((Math.random()-0.5)*200, (Math.random()-0.5)*200, (Math.random()-0.5)*200);
                boid.velocity.set((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2);
            });
        };
        document.getElementById('boidsSeparation').oninput = (e) => sepForce = parseFloat(e.target.value);
        document.getElementById('boidsAlignment').oninput = (e) => aliForce = parseFloat(e.target.value);
        document.getElementById('boidsCohesion').oninput = (e) => cohForce = parseFloat(e.target.value);
    })();

    // =================================================================
    // LORENZ ATTRACTOR - Three.js
    // =================================================================
    (function() {
        const canvas = document.getElementById('lorenzCanvas');
        const rect = canvas.getBoundingClientRect();

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000008);

        const camera = new THREE.PerspectiveCamera(60, rect.width / rect.height, 0.1, 1000);
        camera.position.set(0, 0, 80);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(rect.width, rect.height);

        const controls = new OrbitControls(camera, canvas);
        controls.enableDamping = true;

        let sigma = 10, rho = 28, beta = 8/3;
        let x = 0.1, y = 0, z = 0;
        const MAX_POINTS = 8000;

        const positions = new Float32Array(MAX_POINTS * 3);
        const colors = new Float32Array(MAX_POINTS * 3);

        const lineGeometry = new THREE.BufferGeometry();
        lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        lineGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const lineMaterial = new THREE.LineBasicMaterial({ vertexColors: true });
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);

        // Add glow sphere at current position
        const glowGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({ color: 0x64ffda });
        const glowSphere = new THREE.Mesh(glowGeometry, glowMaterial);
        scene.add(glowSphere);

        let pointCount = 0;
        let paused = false;

        function updateLorenz() {
            const dt = 0.005;
            for (let i = 0; i < 5; i++) {
                const dx = sigma * (y - x);
                const dy = x * (rho - z) - y;
                const dz = x * y - beta * z;
                x += dx * dt;
                y += dy * dt;
                z += dz * dt;

                if (pointCount < MAX_POINTS) {
                    const idx = pointCount * 3;
                    positions[idx] = x;
                    positions[idx + 1] = y;
                    positions[idx + 2] = z - 25;

                    const hue = (pointCount / MAX_POINTS) * 0.5 + 0.4;
                    const color = new THREE.Color().setHSL(hue, 0.9, 0.6);
                    colors[idx] = color.r;
                    colors[idx + 1] = color.g;
                    colors[idx + 2] = color.b;

                    pointCount++;
                    lineGeometry.setDrawRange(0, pointCount);
                    lineGeometry.attributes.position.needsUpdate = true;
                    lineGeometry.attributes.color.needsUpdate = true;
                }
            }
            glowSphere.position.set(x, y, z - 25);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!paused) updateLorenz();
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        document.getElementById('lorenzReset').onclick = () => {
            x = 0.1; y = 0; z = 0;
            pointCount = 0;
            lineGeometry.setDrawRange(0, 0);
        };

        document.getElementById('lorenzPause').onclick = (e) => {
            paused = !paused;
            e.target.textContent = paused ? 'Resume' : 'Pause';
        };

        document.getElementById('lorenzSigma').oninput = (e) => {
            sigma = parseFloat(e.target.value);
            document.getElementById('sigmaValue').textContent = sigma.toFixed(1);
        };

        document.getElementById('lorenzRho').oninput = (e) => {
            rho = parseFloat(e.target.value);
            document.getElementById('rhoValue').textContent = rho.toFixed(1);
        };
    })();

    // =================================================================
    // MANDELBROT - WebGL2 GPU
    // =================================================================
    (function() {
        const canvas = document.getElementById('mandelbrotCanvas');
        const gl = canvas.getContext('webgl2');
        if (!gl) { console.error('WebGL2 not available for Mandelbrot'); return; }

        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;

        const vsSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_coord;
            uniform vec2 u_center;
            uniform float u_zoom;
            uniform vec2 u_resolution;
            void main() {
                float aspect = u_resolution.x / u_resolution.y;
                v_coord = u_center + (a_position * vec2(aspect, 1.0)) / u_zoom;
                gl_Position = vec4(a_position, 0, 1);
            }`;

        const fsSource = `#version 300 es
            precision highp float;
            in vec2 v_coord;
            out vec4 outColor;
            uniform int u_maxIter;

            vec3 palette(float t) {
                vec3 a = vec3(0.5, 0.5, 0.5);
                vec3 b = vec3(0.5, 0.5, 0.5);
                vec3 c = vec3(1.0, 1.0, 1.0);
                vec3 d = vec3(0.0, 0.33, 0.67);
                return a + b * cos(6.28318 * (c * t + d));
            }

            void main() {
                vec2 c = v_coord;
                vec2 z = vec2(0.0);
                float iter = 0.0;

                for (int i = 0; i < 1000; i++) {
                    if (i >= u_maxIter) break;
                    if (dot(z, z) > 4.0) break;
                    z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
                    iter += 1.0;
                }

                if (iter >= float(u_maxIter)) {
                    outColor = vec4(0.0, 0.0, 0.02, 1.0);
                } else {
                    float smooth_iter = iter + 1.0 - log(log(length(z))) / log(2.0);
                    vec3 color = palette(smooth_iter * 0.025);
                    outColor = vec4(color, 1.0);
                }
            }`;

        const program = createProgram(gl, vsSource, fsSource);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

        let centerX = -0.5, centerY = 0, zoom = 1, maxIter = 300;

        function render() {
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.useProgram(program);

            const posLoc = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(posLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            gl.uniform2f(gl.getUniformLocation(program, 'u_center'), centerX, centerY);
            gl.uniform1f(gl.getUniformLocation(program, 'u_zoom'), zoom);
            gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), canvas.width, canvas.height);
            gl.uniform1i(gl.getUniformLocation(program, 'u_maxIter'), maxIter);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
        render();

        canvas.addEventListener('click', (e) => {
            const canvasRect = canvas.getBoundingClientRect();
            const x = (e.clientX - canvasRect.left) / canvasRect.width * 2 - 1;
            const y = -((e.clientY - canvasRect.top) / canvasRect.height * 2 - 1);
            const aspect = canvas.width / canvas.height;
            centerX += x * aspect / zoom;
            centerY += y / zoom;
            zoom *= 2;
            render();
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            zoom *= e.deltaY > 0 ? 0.8 : 1.25;
            render();
        });

        document.getElementById('mandelbrotReset').onclick = () => {
            centerX = -0.5; centerY = 0; zoom = 1;
            render();
        };

        document.getElementById('mandelbrotIterations').oninput = (e) => {
            maxIter = parseInt(e.target.value);
            document.getElementById('iterValue').textContent = maxIter;
            render();
        };
    })();

    // =================================================================
    // REACTION-DIFFUSION - CPU with Canvas
    // =================================================================
    (function() {
        const canvas = document.getElementById('reactionCanvas');
        const ctx = canvas.getContext('2d');

        // Set actual pixel size
        canvas.width = 300;
        canvas.height = 200;

        const width = 300, height = 200;

        // Two chemical grids: A and B
        let gridA = new Float32Array(width * height);
        let gridB = new Float32Array(width * height);
        let nextA = new Float32Array(width * height);
        let nextB = new Float32Array(width * height);

        let feed = 0.055, kill = 0.062;
        const dA = 1.0, dB = 0.5;

        function initGrid() {
            for (let i = 0; i < width * height; i++) {
                gridA[i] = 1;
                gridB[i] = 0;
            }
            // Add multiple seeds
            const seeds = [
                [width/2, height/2],
                [width/3, height/3],
                [width*2/3, height*2/3],
                [width/4, height*3/4],
                [width*3/4, height/4]
            ];
            seeds.forEach(([cx, cy]) => {
                for (let dy = -8; dy <= 8; dy++) {
                    for (let dx = -8; dx <= 8; dx++) {
                        if (dx*dx + dy*dy <= 64) {
                            const x = Math.floor(cx) + dx;
                            const y = Math.floor(cy) + dy;
                            if (x >= 0 && x < width && y >= 0 && y < height) {
                                gridB[x + y * width] = 1;
                            }
                        }
                    }
                }
            });
        }
        initGrid();

        function step() {
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const i = x + y * width;
                    const a = gridA[i];
                    const b = gridB[i];

                    // Laplacian with 9-point stencil
                    const lapA = gridA[i-1] * 0.2 + gridA[i+1] * 0.2 +
                                 gridA[i-width] * 0.2 + gridA[i+width] * 0.2 +
                                 gridA[i-width-1] * 0.05 + gridA[i-width+1] * 0.05 +
                                 gridA[i+width-1] * 0.05 + gridA[i+width+1] * 0.05 - a;

                    const lapB = gridB[i-1] * 0.2 + gridB[i+1] * 0.2 +
                                 gridB[i-width] * 0.2 + gridB[i+width] * 0.2 +
                                 gridB[i-width-1] * 0.05 + gridB[i-width+1] * 0.05 +
                                 gridB[i+width-1] * 0.05 + gridB[i+width+1] * 0.05 - b;

                    const reaction = a * b * b;
                    nextA[i] = a + dA * lapA - reaction + feed * (1 - a);
                    nextB[i] = b + dB * lapB + reaction - (kill + feed) * b;

                    // Clamp
                    if (nextA[i] < 0) nextA[i] = 0;
                    if (nextA[i] > 1) nextA[i] = 1;
                    if (nextB[i] < 0) nextB[i] = 0;
                    if (nextB[i] > 1) nextB[i] = 1;
                }
            }
            // Swap buffers
            let tmp = gridA; gridA = nextA; nextA = tmp;
            tmp = gridB; gridB = nextB; nextB = tmp;
        }

        function render() {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            for (let i = 0; i < width * height; i++) {
                const a = gridA[i];
                const b = gridB[i];

                // Simple color: dark where B is high, cyan where A dominates
                const val = a - b;
                let r, g, bl;

                if (b > 0.1) {
                    // B chemical present - show as purple/pink
                    r = Math.floor(100 + b * 155);
                    g = Math.floor(50 + b * 50);
                    bl = Math.floor(150 + b * 100);
                } else {
                    // A chemical dominates - show as cyan/teal
                    r = Math.floor(10 + a * 90);
                    g = Math.floor(50 + a * 200);
                    bl = Math.floor(80 + a * 135);
                }

                data[i * 4] = r;
                data[i * 4 + 1] = g;
                data[i * 4 + 2] = bl;
                data[i * 4 + 3] = 255;
            }

            ctx.putImageData(imageData, 0, 0);
        }

        let running = false;

        function animate() {
            if (running) {
                for (let i = 0; i < 8; i++) step();
                render();
            }
            requestAnimationFrame(animate);
        }
        render();
        animate();

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = width / rect.width;
            const scaleY = height / rect.height;
            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);

            for (let dy = -8; dy <= 8; dy++) {
                for (let dx = -8; dx <= 8; dx++) {
                    if (dx*dx + dy*dy <= 64) {
                        const px = x + dx, py = y + dy;
                        if (px >= 0 && px < width && py >= 0 && py < height) {
                            gridB[px + py * width] = 1;
                        }
                    }
                }
            }
            render();
        });

        document.getElementById('reactionStart').onclick = () => { running = true; };
        document.getElementById('reactionPause').onclick = () => { running = false; };
        document.getElementById('reactionReset').onclick = () => { running = false; initGrid(); render(); };
        document.getElementById('reactionMitosis').onclick = () => { feed = 0.0367; kill = 0.0649; initGrid(); };
        document.getElementById('reactionCoral').onclick = () => { feed = 0.0545; kill = 0.062; initGrid(); };
        document.getElementById('reactionWaves').onclick = () => { feed = 0.014; kill = 0.054; initGrid(); };
    })();

    // =================================================================
    // L-SYSTEMS - Three.js 3D
    // =================================================================
    (function() {
        const canvas = document.getElementById('lsystemCanvas');
        const rect = canvas.getBoundingClientRect();

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);

        const camera = new THREE.PerspectiveCamera(60, rect.width / rect.height, 0.1, 1000);
        camera.position.set(0, 60, 120);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(rect.width, rect.height);

        const controls = new OrbitControls(camera, canvas);
        controls.enableDamping = true;
        controls.target.set(0, 40, 0);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        scene.add(dirLight);

        const systems = {
            tree: { axiom: 'F', rules: {'F': 'FF+[+F-F-F]-[-F+F+F]'}, angle: 22.5, length: 4, generations: 4 },
            fern: { axiom: 'X', rules: {'X': 'F+[[X]-X]-F[-FX]+X', 'F': 'FF'}, angle: 25, length: 3, generations: 5 },
            bush: { axiom: 'F', rules: {'F': 'F[+F]F[-F]F'}, angle: 25, length: 5, generations: 4 }
        };

        let currentSystem = {...systems.tree};
        let treeGroup = new THREE.Group();
        scene.add(treeGroup);

        function generate(axiom, rules, generations) {
            let result = axiom;
            for (let i = 0; i < generations; i++) {
                let next = '';
                for (const char of result) next += rules[char] || char;
                result = next;
            }
            return result;
        }

        function buildTree() {
            while (treeGroup.children.length) {
                const child = treeGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                treeGroup.remove(child);
            }

            const instructions = generate(currentSystem.axiom, currentSystem.rules, currentSystem.generations);
            const branchMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const leafMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });

            let position = new THREE.Vector3(0, 0, 0);
            let direction = new THREE.Vector3(0, 1, 0);
            const stack = [];
            let depth = 0;

            for (const char of instructions) {
                if (char === 'F') {
                    const len = currentSystem.length * Math.pow(0.75, depth);
                    const radius = Math.max(0.15, 0.8 - depth * 0.12);

                    const geometry = new THREE.CylinderGeometry(radius * 0.7, radius, len, 6);
                    geometry.translate(0, len / 2, 0);

                    const material = depth > 2 ? leafMaterial : branchMaterial;
                    const mesh = new THREE.Mesh(geometry, material);

                    mesh.position.copy(position);
                    const up = new THREE.Vector3(0, 1, 0);
                    const quat = new THREE.Quaternion().setFromUnitVectors(up, direction.clone().normalize());
                    mesh.quaternion.copy(quat);
                    treeGroup.add(mesh);

                    position.add(direction.clone().normalize().multiplyScalar(len));
                } else if (char === '+') {
                    const axis = new THREE.Vector3(1, 0, 0).applyQuaternion(
                        new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.clone().normalize())
                    );
                    direction.applyAxisAngle(axis, currentSystem.angle * Math.PI / 180);
                } else if (char === '-') {
                    const axis = new THREE.Vector3(1, 0, 0).applyQuaternion(
                        new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.clone().normalize())
                    );
                    direction.applyAxisAngle(axis, -currentSystem.angle * Math.PI / 180);
                } else if (char === '[') {
                    stack.push({ pos: position.clone(), dir: direction.clone(), depth });
                    depth++;
                } else if (char === ']') {
                    const state = stack.pop();
                    position = state.pos;
                    direction = state.dir;
                    depth = state.depth;
                }
            }
        }

        buildTree();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        document.getElementById('lsystemTree').onclick = () => {
            currentSystem = {...systems.tree};
            document.getElementById('lsystemGen').value = 4;
            document.getElementById('genValue').textContent = '4';
            buildTree();
        };
        document.getElementById('lsystemFern').onclick = () => {
            currentSystem = {...systems.fern};
            document.getElementById('lsystemGen').value = 5;
            document.getElementById('genValue').textContent = '5';
            buildTree();
        };
        document.getElementById('lsystemBush').onclick = () => {
            currentSystem = {...systems.bush};
            document.getElementById('lsystemGen').value = 4;
            document.getElementById('genValue').textContent = '4';
            buildTree();
        };
        document.getElementById('lsystemGen').oninput = (e) => {
            currentSystem.generations = parseInt(e.target.value);
            document.getElementById('genValue').textContent = e.target.value;
            buildTree();
        };
    })();

    // =================================================================
    // NETWORK - Three.js 3D
    // =================================================================
    (function() {
        const canvas = document.getElementById('networkCanvas');
        const rect = canvas.getBoundingClientRect();

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);

        const camera = new THREE.PerspectiveCamera(60, rect.width / rect.height, 0.1, 1000);
        camera.position.z = 200;

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(rect.width, rect.height);

        const controls = new OrbitControls(camera, canvas);
        controls.enableDamping = true;

        class Node3D {
            constructor(id) {
                this.id = id;
                this.position = new THREE.Vector3(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100
                );
                this.velocity = new THREE.Vector3();
                this.degree = 0;
            }
        }

        let nodes = [], edges = [];
        let nodeGroup = new THREE.Group();
        let edgeGroup = new THREE.Group();
        scene.add(nodeGroup);
        scene.add(edgeGroup);

        function updateDegrees() {
            nodes.forEach(n => n.degree = 0);
            edges.forEach(([a, b]) => { nodes[a].degree++; nodes[b].degree++; });
        }

        function createRegular(n) {
            nodes = [];
            edges = [];
            for (let i = 0; i < n; i++) {
                const angle = (i / n) * Math.PI * 2;
                const node = new Node3D(i);
                node.position.set(Math.cos(angle) * 50, Math.sin(angle) * 50, 0);
                nodes.push(node);
            }
            for (let i = 0; i < n; i++) {
                edges.push([i, (i + 1) % n]);
                edges.push([i, (i + 2) % n]);
            }
            updateDegrees();
            buildMeshes();
        }

        function createSmallWorld(n, p) {
            createRegular(n);
            edges = edges.map(([a, b]) => {
                if (Math.random() < p) {
                    let target = Math.floor(Math.random() * n);
                    while (target === a) target = Math.floor(Math.random() * n);
                    return [a, target];
                }
                return [a, b];
            });
            updateDegrees();
            buildMeshes();
        }

        function createScaleFree(n) {
            nodes = [];
            edges = [];
            for (let i = 0; i < 3; i++) {
                const node = new Node3D(i);
                node.position.set((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50);
                nodes.push(node);
            }
            edges.push([0,1], [1,2], [2,0]);

            for (let i = 3; i < n; i++) {
                const node = new Node3D(i);
                node.position.set((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
                nodes.push(node);

                const degrees = nodes.slice(0, i).map((_, idx) =>
                    edges.filter(([a,b]) => a === idx || b === idx).length
                );
                const total = degrees.reduce((a,b) => a+b, 0) || 1;

                const targets = new Set();
                let attempts = 0;
                while (targets.size < 2 && attempts < 100) {
                    let r = Math.random() * total;
                    for (let j = 0; j < i; j++) {
                        r -= degrees[j];
                        if (r <= 0) { targets.add(j); break; }
                    }
                    attempts++;
                }
                targets.forEach(t => edges.push([i, t]));
            }
            updateDegrees();
            buildMeshes();
        }

        function buildMeshes() {
            while (nodeGroup.children.length) {
                const child = nodeGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                nodeGroup.remove(child);
            }
            while (edgeGroup.children.length) {
                const child = edgeGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                edgeGroup.remove(child);
            }

            nodes.forEach(node => {
                const geo = new THREE.SphereGeometry(2 + Math.sqrt(node.degree) * 0.8, 12, 12);
                const mat = new THREE.MeshBasicMaterial();
                mat.color.setHSL((node.id / nodes.length) * 0.4 + 0.45, 0.8, 0.6);
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(node.position);
                mesh.userData.node = node;
                nodeGroup.add(mesh);
            });

            const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x4466ff, transparent: true, opacity: 0.4 });
            edges.forEach(([a, b]) => {
                const geo = new THREE.BufferGeometry().setFromPoints([nodes[a].position, nodes[b].position]);
                const line = new THREE.Line(geo, edgeMaterial);
                line.userData.edge = [a, b];
                edgeGroup.add(line);
            });
        }

        function applyForces() {
            const repulsion = 2000, attraction = 0.01, damping = 0.85;

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const diff = nodes[j].position.clone().sub(nodes[i].position);
                    const dist = diff.length() || 1;
                    const force = repulsion / (dist * dist);
                    const f = diff.normalize().multiplyScalar(force);
                    nodes[i].velocity.sub(f);
                    nodes[j].velocity.add(f);
                }
            }

            edges.forEach(([a, b]) => {
                const diff = nodes[b].position.clone().sub(nodes[a].position);
                const f = diff.multiplyScalar(attraction);
                nodes[a].velocity.add(f);
                nodes[b].velocity.sub(f);
            });

            nodes.forEach(node => {
                node.velocity.multiplyScalar(damping);
                node.position.add(node.velocity);
            });

            nodeGroup.children.forEach(mesh => {
                mesh.position.copy(mesh.userData.node.position);
            });

            edgeGroup.children.forEach(line => {
                const [a, b] = line.userData.edge;
                line.geometry.setFromPoints([nodes[a].position, nodes[b].position]);
            });
        }

        createRegular(20);

        function animate() {
            requestAnimationFrame(animate);
            applyForces();
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        document.getElementById('networkRegular').onclick = () => createRegular(20);
        document.getElementById('networkSmallWorld').onclick = () => createSmallWorld(20, 0.15);
        document.getElementById('networkScaleFree').onclick = () => createScaleFree(25);
        document.getElementById('networkReset').onclick = () => {
            nodes = [];
            edges = [];
            buildMeshes();
        };
    })();

    </script>
</body>
</html>
