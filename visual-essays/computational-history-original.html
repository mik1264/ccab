<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Complete History of Computational Visualizations and Simulations | CCAB</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r149/three.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #667eea;
            --secondary-color: #764ba2;
            --accent-color: #f093fb;
            --text-color: #2d3748;
            --light-bg: #f7fafc;
            --card-bg: #ffffff;
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 15px 40px rgba(0, 0, 0, 0.15);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--light-bg);
            overflow-x: hidden;
        }

        /* Hero Section */
        .hero {
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            text-align: center;
            padding: 2rem;
        }

        .hero-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .hero-content {
            position: relative;
            z-index: 2;
            color: white;
            max-width: 1200px;
        }

        .hero h1 {
            font-size: 4rem;
            font-weight: 800;
            margin-bottom: 1.5rem;
            line-height: 1.2;
            text-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .hero .subtitle {
            font-size: 1.5rem;
            opacity: 0.95;
            margin-bottom: 2rem;
            font-weight: 300;
        }

        .hero .meta {
            font-size: 1.1rem;
            opacity: 0.85;
            margin-bottom: 3rem;
        }

        .scroll-indicator {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateX(-50%) translateY(0); }
            40% { transform: translateX(-50%) translateY(-10px); }
            60% { transform: translateX(-50%) translateY(-5px); }
        }

        /* Navigation */
        .nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow);
            z-index: 1000;
            padding: 1rem 2rem;
            display: none;
            align-items: center;
            justify-content: space-between;
        }

        .nav.visible {
            display: flex;
        }

        .nav-title {
            font-weight: 700;
            color: var(--primary-color);
            font-size: 1.2rem;
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            list-style: none;
        }

        .nav-links a {
            color: var(--text-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s;
        }

        .nav-links a:hover {
            color: var(--primary-color);
        }

        /* Main Content */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 4rem 2rem;
        }

        .section {
            margin-bottom: 6rem;
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.8s, transform 0.8s;
        }

        .section.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .section-title {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: var(--primary-color);
            position: relative;
            padding-bottom: 1rem;
        }

        .section-title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100px;
            height: 4px;
            background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
            border-radius: 2px;
        }

        .section-subtitle {
            font-size: 1.8rem;
            font-weight: 600;
            margin: 2rem 0 1rem;
            color: var(--secondary-color);
        }

        .text-content {
            font-size: 1.1rem;
            line-height: 1.9;
            margin-bottom: 1.5rem;
            color: #4a5568;
        }

        .text-content strong {
            color: var(--text-color);
            font-weight: 600;
        }

        /* Visualization Cards */
        .viz-card {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 2rem;
            margin: 3rem 0;
            box-shadow: var(--shadow);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .viz-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-hover);
        }

        .viz-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--primary-color);
        }

        .viz-description {
            margin-bottom: 1.5rem;
            color: #718096;
        }

        canvas {
            display: block;
            max-width: 100%;
            border-radius: 8px;
            background: #000;
        }

        /* Timeline */
        .timeline {
            position: relative;
            padding: 2rem 0;
        }

        .timeline-item {
            display: flex;
            gap: 2rem;
            margin-bottom: 3rem;
            position: relative;
        }

        .timeline-date {
            flex: 0 0 150px;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
            text-align: right;
        }

        .timeline-content {
            flex: 1;
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: 10px;
            box-shadow: var(--shadow);
            border-left: 4px solid var(--primary-color);
        }

        .timeline-content h3 {
            font-size: 1.3rem;
            margin-bottom: 0.5rem;
            color: var(--secondary-color);
        }

        /* Grid Layout */
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }

        .grid-item {
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: 10px;
            box-shadow: var(--shadow);
            transition: transform 0.3s;
        }

        .grid-item:hover {
            transform: translateY(-5px);
        }

        .grid-item h3 {
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }

        /* Interactive Controls */
        .controls {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #718096, #4a5568);
        }

        /* Stats Display */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .stat-card {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 2rem;
            border-radius: 10px;
            text-align: center;
        }

        .stat-number {
            font-size: 3rem;
            font-weight: 700;
            display: block;
            margin-bottom: 0.5rem;
        }

        .stat-label {
            font-size: 1rem;
            opacity: 0.9;
        }

        /* Quote Block */
        .quote {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-left: 4px solid var(--primary-color);
            padding: 2rem;
            margin: 2rem 0;
            border-radius: 8px;
            font-style: italic;
            font-size: 1.2rem;
        }

        .quote-author {
            margin-top: 1rem;
            font-style: normal;
            font-weight: 600;
            color: var(--primary-color);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .hero h1 {
                font-size: 2.5rem;
            }

            .hero .subtitle {
                font-size: 1.2rem;
            }

            .section-title {
                font-size: 2rem;
            }

            .timeline-item {
                flex-direction: column;
                gap: 0.5rem;
            }

            .timeline-date {
                text-align: left;
            }

            .nav-links {
                display: none;
            }
        }

        /* Loading Animation */
        .loading {
            text-align: center;
            padding: 2rem;
            color: var(--primary-color);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(102, 126, 234, 0.3);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <!-- Hero Section -->
    <div class="hero">
        <canvas id="hero-canvas" class="hero-background"></canvas>
        <div class="hero-content">
            <h1>The Complete History of<br>Computational Visualizations<br>and Simulations</h1>
            <p class="subtitle">From Simple Automata to Complex Systems Modeling</p>
            <p class="meta">An Interactive Visual Essay | 1940s - Present</p>
        </div>
        <div class="scroll-indicator">
            <svg width="30" height="50" viewBox="0 0 30 50" fill="none">
                <rect x="1" y="1" width="28" height="48" rx="14" stroke="white" stroke-width="2"/>
                <circle cx="15" cy="15" r="4" fill="white"/>
            </svg>
        </div>
    </div>

    <!-- Navigation -->
    <nav class="nav" id="nav">
        <div class="nav-title">Computational History</div>
        <ul class="nav-links">
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#timeline">Timeline</a></li>
            <li><a href="#automata">Automata</a></li>
            <li><a href="#agents">Agents</a></li>
            <li><a href="#chaos">Chaos</a></li>
            <li><a href="#fractals">Fractals</a></li>
            <li><a href="#modern">Modern Era</a></li>
        </ul>
    </nav>

    <!-- Main Content -->
    <div class="container">
        <!-- Introduction -->
        <section class="section" id="introduction">
            <h2 class="section-title">Introduction</h2>
            <p class="text-content">
                The evolution of computational science from simple automata to complex systems modeling represents one of the most profound intellectual achievements of the 20th century. Beginning with Alan Turing's 1952 morphogenesis paper and John von Neumann's self-replicating automata, computational visualizations transformed from theoretical curiosities into essential tools spanning biology, physics, sociology, and computer graphics.
            </p>
            <p class="text-content">
                These simulations became canonical educational examples because they demonstrated <strong>emergence</strong>—how simple local rules generate complex global behavior—while remaining accessible enough for students to implement and explore. From Conway's Game of Life running on 1970 minicomputers to today's browser-based WebGL simulations, this democratization of computational tools enabled millions to experience firsthand the mathematical principles underlying natural phenomena.
            </p>

            <div class="stats-grid">
                <div class="stat-card">
                    <span class="stat-number">80+</span>
                    <span class="stat-label">Years of Innovation</span>
                </div>
                <div class="stat-card">
                    <span class="stat-number">20+</span>
                    <span class="stat-label">Canonical Algorithms</span>
                </div>
                <div class="stat-card">
                    <span class="stat-number">∞</span>
                    <span class="stat-label">Emergent Patterns</span>
                </div>
                <div class="stat-card">
                    <span class="stat-number">10^6+</span>
                    <span class="stat-label">Cost Reduction</span>
                </div>
            </div>
        </section>

        <!-- Timeline -->
        <section class="section" id="timeline">
            <h2 class="section-title">Historical Timeline</h2>
            <div class="timeline">
                <div class="timeline-item">
                    <div class="timeline-date">1940s</div>
                    <div class="timeline-content">
                        <h3>Theoretical Foundations</h3>
                        <p>John von Neumann and Stanisław Ulam pioneer cellular automata at Los Alamos. Von Neumann develops theory of self-reproducing automata.</p>
                    </div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">1952</div>
                    <div class="timeline-content">
                        <h3>Turing's Morphogenesis</h3>
                        <p>Alan Turing publishes "The Chemical Basis of Morphogenesis," introducing reaction-diffusion systems that spontaneously generate patterns from uniform states.</p>
                    </div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">1970</div>
                    <div class="timeline-content">
                        <h3>Conway's Game of Life</h3>
                        <p>John Conway creates the Game of Life. Martin Gardner's Scientific American column brings it to mainstream. Bill Gosper discovers the glider gun, proving Turing completeness.</p>
                    </div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">1971</div>
                    <div class="timeline-content">
                        <h3>Schelling Segregation Model</h3>
                        <p>Thomas Schelling demonstrates how mild individual preferences (30-50% tolerance) produce extreme macro-level segregation. Work contributes to his 2005 Nobel Prize.</p>
                    </div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">1983</div>
                    <div class="timeline-content">
                        <h3>Wolfram's Classification</h3>
                        <p>Stephen Wolfram introduces four-class classification for elementary cellular automata. Identifies Rule 110 as Turing complete, Rule 30 for pseudorandom generation.</p>
                    </div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">1987</div>
                    <div class="timeline-content">
                        <h3>Boids & Artificial Life</h3>
                        <p>Craig Reynolds presents boids at SIGGRAPH. Christopher Langton organizes first Artificial Life workshop, founding the field.</p>
                    </div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">1999</div>
                    <div class="timeline-content">
                        <h3>NetLogo & Scale-Free Networks</h3>
                        <p>Uri Wilensky releases NetLogo, democratizing agent-based modeling. Barabási and Albert publish scale-free network paper in Science.</p>
                    </div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">2011</div>
                    <div class="timeline-content">
                        <h3>WebGL Revolution</h3>
                        <p>WebGL 1.0 enables GPU-accelerated graphics in browsers. D3.js brings data-driven visualizations to the web. Computational science becomes universally accessible.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Conway's Game of Life -->
        <section class="section" id="automata">
            <h2 class="section-title">Cellular Automata: Life and Beyond</h2>
            <p class="text-content">
                John Horton Conway's <strong>Game of Life</strong>, created in 1970, became the most famous cellular automaton in history. Working at Cambridge University using graph paper and Go boards, Conway established three elegant rules: cells with 2-3 neighbors survive, cells with exactly 3 neighbors are born, all others die.
            </p>

            <div class="viz-card">
                <h3 class="viz-title">Conway's Game of Life (1970)</h3>
                <p class="viz-description">
                    Click to place cells, or use the Random button to generate a random configuration. Watch as simple rules create complex emergent patterns including oscillators, spaceships, and gliders.
                </p>
                <canvas id="game-of-life" width="800" height="600"></canvas>
                <div class="controls">
                    <button class="btn" id="gol-play">Play</button>
                    <button class="btn" id="gol-pause">Pause</button>
                    <button class="btn" id="gol-step">Step</button>
                    <button class="btn btn-secondary" id="gol-clear">Clear</button>
                    <button class="btn btn-secondary" id="gol-random">Random</button>
                    <button class="btn btn-secondary" id="gol-glider">Glider Gun</button>
                </div>
            </div>

            <h3 class="section-subtitle">Wolfram's Elementary Cellular Automata</h3>
            <p class="text-content">
                Stephen Wolfram's systematic investigation beginning in 1981 achieved rigorous formulation of cellular automata theory. His <strong>Rule 110</strong> stands as one of the simplest known Turing-complete systems, while <strong>Rule 30</strong> generates seemingly random patterns from simple initial states.
            </p>

            <div class="viz-card">
                <h3 class="viz-title">Wolfram Elementary Cellular Automata</h3>
                <p class="viz-description">
                    Explore different Wolfram rules. Rule 30 shows chaotic behavior, Rule 110 is Turing complete, Rule 90 creates Sierpiński triangles.
                </p>
                <canvas id="wolfram-ca" width="800" height="600"></canvas>
                <div class="controls">
                    <button class="btn" id="rule-30">Rule 30</button>
                    <button class="btn" id="rule-110">Rule 110</button>
                    <button class="btn" id="rule-90">Rule 90</button>
                    <button class="btn btn-secondary" id="wolfram-reset">Reset</button>
                </div>
            </div>
        </section>

        <!-- Agent-Based Modeling -->
        <section class="section" id="agents">
            <h2 class="section-title">Agent-Based Modeling: From Coins to Complexity</h2>
            <p class="text-content">
                While cellular automata explored mathematical abstraction, agent-based modeling emerged from social science. Thomas Schelling's segregation model demonstrated how mild individual preferences produce extreme macro-level segregation, while Craig Reynolds' boids revolutionized computer animation with emergent flocking behavior.
            </p>

            <div class="viz-card">
                <h3 class="viz-title">Boids: Flocking Simulation (Reynolds, 1987)</h3>
                <p class="viz-description">
                    Three simple rules create realistic flocking: <strong>separation</strong> (avoid crowding), <strong>alignment</strong> (match neighbors' heading), and <strong>cohesion</strong> (move toward neighbors' center). First used in Batman Returns (1992).
                </p>
                <canvas id="boids-canvas" width="800" height="600"></canvas>
                <div class="controls">
                    <button class="btn" id="boids-more">Add Boids</button>
                    <button class="btn btn-secondary" id="boids-reset">Reset</button>
                </div>
            </div>

            <div class="quote">
                "The emergence of realistic collective behavior from local rules alone—this is the profound insight of agent-based modeling. No central coordinator, no global plan, just simple interactions creating complex patterns."
                <div class="quote-author">— Craig Reynolds, 1987</div>
            </div>
        </section>

        <!-- Chemical Reactions & Patterns -->
        <section class="section" id="patterns">
            <h2 class="section-title">Chemical Reactions Generate Biological Patterns</h2>
            <p class="text-content">
                Boris Belousov's 1951 discovery of oscillating chemical reactions was initially rejected as "theoretically impossible." Anatoly Zhabotinsky refined it in 1964, creating the BZ reaction. The <strong>Gray-Scott model</strong> of reaction-diffusion reveals self-replicating spots, coral patterns, mazes, and traveling waves.
            </p>

            <div class="viz-card">
                <h3 class="viz-title">Gray-Scott Reaction-Diffusion (1983-1985)</h3>
                <p class="viz-description">
                    Watch as two diffusing chemicals with different diffusion rates spontaneously generate patterns. The autocatalytic reaction U + 2V → 3V creates diverse behaviors based on feed rate (F) and kill rate (k) parameters.
                </p>
                <canvas id="reaction-diffusion" width="800" height="600"></canvas>
                <div class="controls">
                    <button class="btn" id="rd-spots">Spots</button>
                    <button class="btn" id="rd-coral">Coral</button>
                    <button class="btn" id="rd-maze">Maze</button>
                    <button class="btn btn-secondary" id="rd-reset">Reset</button>
                </div>
            </div>

            <h3 class="section-subtitle">Biological Validation: Zebrafish Stripes</h3>
            <p class="text-content">
                Theoretical predictions met experimental validation through zebrafish stripe pattern research starting in 2006. Shigeru Kondo's laboratory demonstrated that three pigment cell types interact through short-range repulsion and long-range attraction, confirming Turing-like pattern formation at cellular level.
            </p>
        </section>

        <!-- Chaos Theory -->
        <section class="section" id="chaos">
            <h2 class="section-title">Chaos Theory Reveals Fundamental Limits</h2>
            <p class="text-content">
                Edward Lorenz's 1963 discovery of the <strong>butterfly effect</strong> revolutionized our understanding of prediction. When rounding .506127 to .506 produced drastically different weather simulations, Lorenz realized that determinism doesn't imply predictability.
            </p>

            <div class="viz-card">
                <h3 class="viz-title">Lorenz Attractor (1963)</h3>
                <p class="viz-description">
                    The butterfly-shaped strange attractor emerges from three differential equations with parameters σ=10, ρ=28, β=8/3. Trajectories never repeat, exhibiting fractal dimension ~2.06 and extreme sensitivity to initial conditions.
                </p>
                <canvas id="lorenz-canvas" width="800" height="600"></canvas>
                <div class="controls">
                    <button class="btn" id="lorenz-rotate">Toggle Rotation</button>
                    <button class="btn btn-secondary" id="lorenz-reset">Reset</button>
                </div>
            </div>

            <div class="quote">
                "Predictability: Does the Flap of a Butterfly's Wings in Brazil Set Off a Tornado in Texas?"
                <div class="quote-author">— Edward Lorenz, 1972 Talk Title</div>
            </div>

            <h3 class="section-subtitle">The Double Pendulum</h3>
            <p class="text-content">
                The double pendulum demonstrates chaotic unpredictability for large displacements. Two pendulums differing by one-millionth of a radian diverge dramatically within seconds, with Lyapunov exponent λ = 7.5 ± 1.5 s⁻¹ quantifying exponential divergence.
            </p>
        </section>

        <!-- Fractals -->
        <section class="section" id="fractals">
            <h2 class="section-title">Fractals Bridge Mathematics and Nature</h2>
            <p class="text-content">
                Benoit Mandelbrot first visualized the <strong>Mandelbrot set</strong> on March 1, 1980 at IBM's Thomas J. Watson Research Center. His 1982 masterwork "The Fractal Geometry of Nature" showed "rough" mathematics could be rigorous, challenging 300+ years of smooth Euclidean geometry.
            </p>

            <div class="viz-card">
                <h3 class="viz-title">Mandelbrot Set Explorer</h3>
                <p class="viz-description">
                    Infinite complexity from the simple equation z → z² + c. Click to zoom in and discover self-similar miniature copies at every scale. Each point in the Mandelbrot set corresponds to a different Julia set.
                </p>
                <canvas id="mandelbrot-canvas" width="800" height="600"></canvas>
                <div class="controls">
                    <button class="btn" id="mandel-zoom-in">Zoom In</button>
                    <button class="btn" id="mandel-zoom-out">Zoom Out</button>
                    <button class="btn btn-secondary" id="mandel-reset">Reset</button>
                </div>
            </div>

            <h3 class="section-subtitle">L-Systems: Algorithmic Botany</h3>
            <p class="text-content">
                Aristid Lindenmayer's 1968 L-systems model filamentous organisms through parallel rewriting. Przemyslaw Prusinkiewicz transformed these into practical graphics tools, culminating in the 1990 masterwork "The Algorithmic Beauty of Plants."
            </p>

            <div class="viz-card">
                <h3 class="viz-title">L-System Tree Growth</h3>
                <p class="viz-description">
                    Watch algorithmic plant growth using parallel string rewriting. Each iteration applies production rules simultaneously, modeling biological realism where multiple cell divisions occur at once.
                </p>
                <canvas id="lsystem-canvas" width="800" height="600"></canvas>
                <div class="controls">
                    <button class="btn" id="lsys-grow">Grow</button>
                    <button class="btn" id="lsys-iteration">Next Iteration</button>
                    <button class="btn btn-secondary" id="lsys-reset">Reset</button>
                </div>
            </div>
        </section>

        <!-- Networks -->
        <section class="section" id="networks">
            <h2 class="section-title">Networks Reveal Universal Organizational Principles</h2>
            <p class="text-content">
                Duncan Watts and Steven Strogatz's 1998 Nature paper resolved the dichotomy between regular and random networks, explaining "six degrees of separation." Albert-László Barabási and Réka Albert's 1999 Science paper established scale-free networks through preferential attachment.
            </p>

            <div class="viz-card">
                <h3 class="viz-title">Small-World & Scale-Free Networks</h3>
                <p class="viz-description">
                    Explore different network topologies: small-world networks exhibit short path lengths with high clustering, while scale-free networks create natural "hubs" through preferential attachment (rich get richer).
                </p>
                <svg id="network-svg" width="800" height="600"></svg>
                <div class="controls">
                    <button class="btn" id="net-small-world">Small-World</button>
                    <button class="btn" id="net-scale-free">Scale-Free</button>
                    <button class="btn" id="net-random">Random</button>
                    <button class="btn btn-secondary" id="net-reset">Reset</button>
                </div>
            </div>

            <div class="grid">
                <div class="grid-item">
                    <h3>Small-World Networks</h3>
                    <p>Short average path lengths + high clustering. Found in C. elegans neural networks (282 neurons), Western US power grid (4,941 nodes).</p>
                </div>
                <div class="grid-item">
                    <h3>Scale-Free Networks</h3>
                    <p>Power-law degree distribution P(k) ~ k^(-3). No characteristic scale. Natural emergence of hubs drives network resilience and vulnerability.</p>
                </div>
                <div class="grid-item">
                    <h3>Applications</h3>
                    <p>Epidemic modeling (SIR on networks), social media analysis, protein interactions, World Wide Web structure, citation networks.</p>
                </div>
            </div>
        </section>

        <!-- Modern Visualization Technologies -->
        <section class="section" id="modern">
            <h2 class="section-title">Modern Visualization Technologies</h2>
            <p class="text-content">
                The democratization of computational science accelerated dramatically from the 1960s onward. Ivan Sutherland's 1963 Sketchpad pioneered interactive computer graphics. OpenGL (1992) standardized 3D rendering. WebGL (2011) brought GPU-accelerated graphics to browsers, enabling the visualizations you're experiencing on this page.
            </p>

            <h3 class="section-subtitle">From Million-Dollar Computers to Web Browsers</h3>
            <div class="stats-grid">
                <div class="stat-card">
                    <span class="stat-number">1963</span>
                    <span class="stat-label">Sketchpad on TX-2</span>
                </div>
                <div class="stat-card">
                    <span class="stat-number">1970</span>
                    <span class="stat-label">Life on Minicomputers</span>
                </div>
                <div class="stat-card">
                    <span class="stat-number">2011</span>
                    <span class="stat-label">WebGL Browser Graphics</span>
                </div>
                <div class="stat-card">
                    <span class="stat-number">2025</span>
                    <span class="stat-label">Universal Access</span>
                </div>
            </div>

            <div class="grid">
                <div class="grid-item">
                    <h3>Three.js (2010)</h3>
                    <p>Ricardo Cabello's library abstracts WebGL complexity, enabling browser-based 3D without plugins. Used by Google, NYT, Airbnb, MTV.</p>
                </div>
                <div class="grid-item">
                    <h3>D3.js (2011)</h3>
                    <p>Mike Bostock's "Data-Driven Documents" binds data to DOM elements. Won IEEE VIS 2021 Test of Time Award for transformative impact.</p>
                </div>
                <div class="grid-item">
                    <h3>WebAssembly (2017)</h3>
                    <p>Binary instruction format achieving 91-120% native speed. Enables high-performance scientific simulations in browsers.</p>
                </div>
                <div class="grid-item">
                    <h3>WebGPU (2023)</h3>
                    <p>Modern GPU API exposing compute shaders for parallel processing. Next generation of browser-based computational science.</p>
                </div>
            </div>
        </section>

        <!-- Convergence & Conclusion -->
        <section class="section" id="conclusion">
            <h2 class="section-title">Convergence: Why These Became Canonical</h2>
            <p class="text-content">
                These computational visualizations achieved canonical status through converging factors transcending individual technical merit:
            </p>

            <div class="grid">
                <div class="grid-item">
                    <h3>Pedagogical Accessibility</h3>
                    <p>Game of Life's three rules, Schelling's coins, boids' steering laws—minimal math, maximum insight. Students implement in single sessions while exploring research-level depth.</p>
                </div>
                <div class="grid-item">
                    <h3>Visual Appeal & Emergence</h3>
                    <p>Mandelbrot's infinite detail, Lorenz's butterfly, reaction-diffusion organics. The gap between simple rules and complex outcomes becomes directly observable.</p>
                </div>
                <div class="grid-item">
                    <h3>Historical Timing</h3>
                    <p>Each breakthrough aligned technology with conceptual needs: Life with 1970 minicomputers, NetLogo with classroom computing, WebGL with JavaScript performance.</p>
                </div>
                <div class="grid-item">
                    <h3>Interdisciplinary Relevance</h3>
                    <p>Single implementations teach transferable principles: Turing patterns explain stripes, evolutionary algorithms optimize antennas, networks model epidemics and neurons.</p>
                </div>
                <div class="grid-item">
                    <h3>Open-Source Culture</h3>
                    <p>Processing, NetLogo, D3.js, Three.js—free access, extensive documentation, active communities. Eliminates barriers, accelerates collective learning.</p>
                </div>
                <div class="grid-item">
                    <h3>10,000× Democratization</h3>
                    <p>From million-dollar 1970s minicomputers to free browser access in 2025. Universal availability transformed computational science from elite to accessible.</p>
                </div>
            </div>

            <div class="quote">
                "A 2025 student with browser access can implement Conway's Life, visualize Lorenz attractors, simulate disease spread on networks, evolve L-system plants, and animate boids—all activities requiring million-dollar equipment mere decades ago."
                <div class="quote-author">— The Computational Revolution</div>
            </div>

            <h3 class="section-subtitle">Continuing Importance</h3>
            <p class="text-content">
                These canonical examples persist because they successfully balance simplicity and depth, provide visual feedback, demonstrate emergence, span disciplines, and offer scaffolding from beginner exercises to research frontiers.
            </p>
            <p class="text-content">
                Modern research employs these same principles: <strong>COVID-19 modeling</strong> uses SEIR on networks, <strong>climate science</strong> applies computational fluid dynamics, <strong>neuroscience</strong> analyzes brain networks, <strong>synthetic biology</strong> engineers L-system-like gene circuits, and <strong>AI training</strong> uses evolutionary algorithms.
            </p>
            <p class="text-content">
                Educational tools became research instruments, and research advances continue feeding back into refined educational implementations—a virtuous cycle where accessibility enhances understanding, which enables innovation, which produces more powerful yet accessible tools for the next generation of computational scientists.
            </p>

            <div style="text-align: center; margin: 4rem 0; padding: 3rem; background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1)); border-radius: 15px;">
                <h3 style="color: var(--primary-color); margin-bottom: 1rem; font-size: 2rem;">Explore More</h3>
                <p style="margin-bottom: 2rem; font-size: 1.1rem;">Continue your journey through computational beauty</p>
                <a href="../index.html" class="btn" style="display: inline-block; text-decoration: none; padding: 1rem 2rem;">Return to CCAB Gallery</a>
            </div>
        </section>
    </div>

    <script>
        // Navigation scroll behavior
        window.addEventListener('scroll', () => {
            const nav = document.getElementById('nav');
            if (window.scrollY > window.innerHeight - 100) {
                nav.classList.add('visible');
            } else {
                nav.classList.remove('visible');
            }
        });

        // Intersection Observer for section animations
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('visible');
                }
            });
        }, { threshold: 0.1 });

        document.querySelectorAll('.section').forEach(section => {
            observer.observe(section);
        });

        // Hero Background - Particle System
        const heroCanvas = document.getElementById('hero-canvas');
        const heroCtx = heroCanvas.getContext('2d');
        heroCanvas.width = window.innerWidth;
        heroCanvas.height = window.innerHeight;

        const particles = [];
        const particleCount = 100;

        class Particle {
            constructor() {
                this.x = Math.random() * heroCanvas.width;
                this.y = Math.random() * heroCanvas.height;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.radius = Math.random() * 2 + 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.x < 0 || this.x > heroCanvas.width) this.vx *= -1;
                if (this.y < 0 || this.y > heroCanvas.height) this.vy *= -1;
            }

            draw() {
                heroCtx.beginPath();
                heroCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                heroCtx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                heroCtx.fill();
            }
        }

        for (let i = 0; i < particleCount; i++) {
            particles.push(new Particle());
        }

        function animateHero() {
            heroCtx.clearRect(0, 0, heroCanvas.width, heroCanvas.height);

            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });

            // Draw connections
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 100) {
                        heroCtx.beginPath();
                        heroCtx.strokeStyle = `rgba(255, 255, 255, ${0.2 * (1 - distance / 100)})`;
                        heroCtx.lineWidth = 1;
                        heroCtx.moveTo(particles[i].x, particles[i].y);
                        heroCtx.lineTo(particles[j].x, particles[j].y);
                        heroCtx.stroke();
                    }
                }
            }

            requestAnimationFrame(animateHero);
        }
        animateHero();

        window.addEventListener('resize', () => {
            heroCanvas.width = window.innerWidth;
            heroCanvas.height = window.innerHeight;
        });

        // Conway's Game of Life
        const golCanvas = document.getElementById('game-of-life');
        const golCtx = golCanvas.getContext('2d');
        const cellSize = 8;
        const cols = Math.floor(golCanvas.width / cellSize);
        const rows = Math.floor(golCanvas.height / cellSize);
        let golGrid = Array(rows).fill().map(() => Array(cols).fill(0));
        let golRunning = false;

        function drawGOL() {
            golCtx.fillStyle = '#000';
            golCtx.fillRect(0, 0, golCanvas.width, golCanvas.height);

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (golGrid[i][j]) {
                        golCtx.fillStyle = '#00ff88';
                        golCtx.fillRect(j * cellSize, i * cellSize, cellSize - 1, cellSize - 1);
                    }
                }
            }
        }

        function updateGOL() {
            const newGrid = golGrid.map(arr => [...arr]);

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    let neighbors = 0;
                    for (let di = -1; di <= 1; di++) {
                        for (let dj = -1; dj <= 1; dj++) {
                            if (di === 0 && dj === 0) continue;
                            const ni = (i + di + rows) % rows;
                            const nj = (j + dj + cols) % cols;
                            neighbors += golGrid[ni][nj];
                        }
                    }

                    if (golGrid[i][j] === 1) {
                        newGrid[i][j] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
                    } else {
                        newGrid[i][j] = (neighbors === 3) ? 1 : 0;
                    }
                }
            }

            golGrid = newGrid;
            drawGOL();
        }

        function golLoop() {
            if (golRunning) {
                updateGOL();
                setTimeout(golLoop, 100);
            }
        }

        golCanvas.addEventListener('click', (e) => {
            const rect = golCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);
            golGrid[row][col] = 1 - golGrid[row][col];
            drawGOL();
        });

        document.getElementById('gol-play').addEventListener('click', () => {
            golRunning = true;
            golLoop();
        });

        document.getElementById('gol-pause').addEventListener('click', () => {
            golRunning = false;
        });

        document.getElementById('gol-step').addEventListener('click', updateGOL);

        document.getElementById('gol-clear').addEventListener('click', () => {
            golGrid = Array(rows).fill().map(() => Array(cols).fill(0));
            drawGOL();
        });

        document.getElementById('gol-random').addEventListener('click', () => {
            golGrid = Array(rows).fill().map(() =>
                Array(cols).fill().map(() => Math.random() > 0.7 ? 1 : 0)
            );
            drawGOL();
        });

        document.getElementById('gol-glider').addEventListener('click', () => {
            golGrid = Array(rows).fill().map(() => Array(cols).fill(0));
            // Gosper Glider Gun pattern
            const gun = [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                [1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ];
            const startRow = 10;
            const startCol = 10;
            for (let i = 0; i < gun.length; i++) {
                for (let j = 0; j < gun[i].length; j++) {
                    if (startRow + i < rows && startCol + j < cols) {
                        golGrid[startRow + i][startCol + j] = gun[i][j];
                    }
                }
            }
            drawGOL();
        });

        drawGOL();

        // Wolfram CA
        const wolframCanvas = document.getElementById('wolfram-ca');
        const wolframCtx = wolframCanvas.getContext('2d');
        const wCellSize = 2;
        const wCols = Math.floor(wolframCanvas.width / wCellSize);
        let currentRule = 30;
        let wRow = 0;
        let wCells = Array(wCols).fill(0);
        wCells[Math.floor(wCols / 2)] = 1;

        function getRuleBit(rule, left, center, right) {
            const index = (left << 2) | (center << 1) | right;
            return (rule >> index) & 1;
        }

        function drawWolframRow() {
            for (let i = 0; i < wCols; i++) {
                wolframCtx.fillStyle = wCells[i] ? '#fff' : '#000';
                wolframCtx.fillRect(i * wCellSize, wRow * wCellSize, wCellSize, wCellSize);
            }
        }

        function updateWolfram() {
            drawWolframRow();

            const newCells = Array(wCols).fill(0);
            for (let i = 0; i < wCols; i++) {
                const left = wCells[(i - 1 + wCols) % wCols];
                const center = wCells[i];
                const right = wCells[(i + 1) % wCols];
                newCells[i] = getRuleBit(currentRule, left, center, right);
            }

            wCells = newCells;
            wRow++;

            if (wRow < wolframCanvas.height / wCellSize) {
                requestAnimationFrame(updateWolfram);
            }
        }

        function resetWolfram(rule) {
            currentRule = rule;
            wolframCtx.fillStyle = '#000';
            wolframCtx.fillRect(0, 0, wolframCanvas.width, wolframCanvas.height);
            wCells = Array(wCols).fill(0);
            wCells[Math.floor(wCols / 2)] = 1;
            wRow = 0;
            updateWolfram();
        }

        document.getElementById('rule-30').addEventListener('click', () => resetWolfram(30));
        document.getElementById('rule-110').addEventListener('click', () => resetWolfram(110));
        document.getElementById('rule-90').addEventListener('click', () => resetWolfram(90));
        document.getElementById('wolfram-reset').addEventListener('click', () => resetWolfram(currentRule));

        resetWolfram(30);

        // Boids
        const boidsCanvas = document.getElementById('boids-canvas');
        const boidsCtx = boidsCanvas.getContext('2d');
        const boids = [];

        class Boid {
            constructor() {
                this.x = Math.random() * boidsCanvas.width;
                this.y = Math.random() * boidsCanvas.height;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.maxSpeed = 2;
                this.maxForce = 0.05;
            }

            update() {
                const separation = this.separate();
                const alignment = this.align();
                const cohesion = this.cohesion();

                this.vx += separation.x + alignment.x + cohesion.x;
                this.vy += separation.y + alignment.y + cohesion.y;

                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > this.maxSpeed) {
                    this.vx = (this.vx / speed) * this.maxSpeed;
                    this.vy = (this.vy / speed) * this.maxSpeed;
                }

                this.x += this.vx;
                this.y += this.vy;

                if (this.x < 0) this.x = boidsCanvas.width;
                if (this.x > boidsCanvas.width) this.x = 0;
                if (this.y < 0) this.y = boidsCanvas.height;
                if (this.y > boidsCanvas.height) this.y = 0;
            }

            separate() {
                const desiredSeparation = 25;
                let steer = { x: 0, y: 0 };
                let count = 0;

                boids.forEach(other => {
                    const d = Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
                    if (d > 0 && d < desiredSeparation) {
                        const diff = {
                            x: (this.x - other.x) / d,
                            y: (this.y - other.y) / d
                        };
                        steer.x += diff.x;
                        steer.y += diff.y;
                        count++;
                    }
                });

                if (count > 0) {
                    steer.x /= count;
                    steer.y /= count;
                }

                return { x: steer.x * 1.5, y: steer.y * 1.5 };
            }

            align() {
                const neighborDist = 50;
                let sum = { x: 0, y: 0 };
                let count = 0;

                boids.forEach(other => {
                    const d = Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
                    if (d > 0 && d < neighborDist) {
                        sum.x += other.vx;
                        sum.y += other.vy;
                        count++;
                    }
                });

                if (count > 0) {
                    sum.x /= count;
                    sum.y /= count;
                    return { x: sum.x * 0.05, y: sum.y * 0.05 };
                }

                return { x: 0, y: 0 };
            }

            cohesion() {
                const neighborDist = 50;
                let sum = { x: 0, y: 0 };
                let count = 0;

                boids.forEach(other => {
                    const d = Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
                    if (d > 0 && d < neighborDist) {
                        sum.x += other.x;
                        sum.y += other.y;
                        count++;
                    }
                });

                if (count > 0) {
                    sum.x /= count;
                    sum.y /= count;
                    return {
                        x: (sum.x - this.x) * 0.01,
                        y: (sum.y - this.y) * 0.01
                    };
                }

                return { x: 0, y: 0 };
            }

            draw() {
                const angle = Math.atan2(this.vy, this.vx);
                boidsCtx.save();
                boidsCtx.translate(this.x, this.y);
                boidsCtx.rotate(angle);
                boidsCtx.fillStyle = '#00ff88';
                boidsCtx.beginPath();
                boidsCtx.moveTo(6, 0);
                boidsCtx.lineTo(-6, 4);
                boidsCtx.lineTo(-6, -4);
                boidsCtx.closePath();
                boidsCtx.fill();
                boidsCtx.restore();
            }
        }

        for (let i = 0; i < 50; i++) {
            boids.push(new Boid());
        }

        function animateBoids() {
            boidsCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            boidsCtx.fillRect(0, 0, boidsCanvas.width, boidsCanvas.height);

            boids.forEach(boid => {
                boid.update();
                boid.draw();
            });

            requestAnimationFrame(animateBoids);
        }

        document.getElementById('boids-more').addEventListener('click', () => {
            for (let i = 0; i < 10; i++) {
                boids.push(new Boid());
            }
        });

        document.getElementById('boids-reset').addEventListener('click', () => {
            boids.length = 0;
            for (let i = 0; i < 50; i++) {
                boids.push(new Boid());
            }
        });

        animateBoids();

        // Reaction-Diffusion (simplified visualization)
        const rdCanvas = document.getElementById('reaction-diffusion');
        const rdCtx = rdCanvas.getContext('2d');
        const rdWidth = 200;
        const rdHeight = 150;
        let rdGrid = Array(rdHeight).fill().map(() => Array(rdWidth).fill().map(() => ({ u: 1, v: 0 })));
        let rdF = 0.055;
        let rdK = 0.062;
        let rdRunning = true;

        // Seed with random noise
        for (let i = rdHeight / 2 - 10; i < rdHeight / 2 + 10; i++) {
            for (let j = rdWidth / 2 - 10; j < rdWidth / 2 + 10; j++) {
                rdGrid[i][j].v = 1;
            }
        }

        function updateRD() {
            const newGrid = rdGrid.map(row => row.map(cell => ({ ...cell })));

            for (let i = 1; i < rdHeight - 1; i++) {
                for (let j = 1; j < rdWidth - 1; j++) {
                    const u = rdGrid[i][j].u;
                    const v = rdGrid[i][j].v;

                    const laplacianU =
                        rdGrid[i-1][j].u + rdGrid[i+1][j].u +
                        rdGrid[i][j-1].u + rdGrid[i][j+1].u - 4 * u;
                    const laplacianV =
                        rdGrid[i-1][j].v + rdGrid[i+1][j].v +
                        rdGrid[i][j-1].v + rdGrid[i][j+1].v - 4 * v;

                    const Du = 1.0;
                    const Dv = 0.5;
                    const uvv = u * v * v;

                    newGrid[i][j].u = u + (Du * laplacianU - uvv + rdF * (1 - u));
                    newGrid[i][j].v = v + (Dv * laplacianV + uvv - (rdF + rdK) * v);

                    newGrid[i][j].u = Math.max(0, Math.min(1, newGrid[i][j].u));
                    newGrid[i][j].v = Math.max(0, Math.min(1, newGrid[i][j].v));
                }
            }

            rdGrid = newGrid;
        }

        function drawRD() {
            const imageData = rdCtx.createImageData(rdCanvas.width, rdCanvas.height);
            const pixelWidth = rdCanvas.width / rdWidth;
            const pixelHeight = rdCanvas.height / rdHeight;

            for (let i = 0; i < rdHeight; i++) {
                for (let j = 0; j < rdWidth; j++) {
                    const u = rdGrid[i][j].u;
                    const v = rdGrid[i][j].v;
                    const value = Math.floor((u - v) * 255);

                    for (let py = 0; py < pixelHeight; py++) {
                        for (let px = 0; px < pixelWidth; px++) {
                            const x = Math.floor(j * pixelWidth + px);
                            const y = Math.floor(i * pixelHeight + py);
                            const index = (y * rdCanvas.width + x) * 4;

                            imageData.data[index] = value;
                            imageData.data[index + 1] = value / 2;
                            imageData.data[index + 2] = 255 - value;
                            imageData.data[index + 3] = 255;
                        }
                    }
                }
            }

            rdCtx.putImageData(imageData, 0, 0);
        }

        function animateRD() {
            if (rdRunning) {
                for (let i = 0; i < 10; i++) updateRD();
                drawRD();
                requestAnimationFrame(animateRD);
            }
        }

        function resetRD(f, k) {
            rdF = f;
            rdK = k;
            rdGrid = Array(rdHeight).fill().map(() => Array(rdWidth).fill().map(() => ({ u: 1, v: 0 })));
            for (let i = rdHeight / 2 - 10; i < rdHeight / 2 + 10; i++) {
                for (let j = rdWidth / 2 - 10; j < rdWidth / 2 + 10; j++) {
                    if (i >= 0 && i < rdHeight && j >= 0 && j < rdWidth) {
                        rdGrid[i][j].v = 1;
                    }
                }
            }
            rdRunning = true;
            animateRD();
        }

        document.getElementById('rd-spots').addEventListener('click', () => resetRD(0.055, 0.062));
        document.getElementById('rd-coral').addEventListener('click', () => resetRD(0.062, 0.061));
        document.getElementById('rd-maze').addEventListener('click', () => resetRD(0.029, 0.057));
        document.getElementById('rd-reset').addEventListener('click', () => resetRD(rdF, rdK));

        animateRD();

        // Lorenz Attractor
        const lorenzCanvas = document.getElementById('lorenz-canvas');
        if (typeof THREE === 'undefined') {
            console.warn('THREE.js not loaded, skipping Lorenz attractor');
        } else {
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, lorenzCanvas.width / lorenzCanvas.height, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: lorenzCanvas, antialias: true });
        renderer.setSize(lorenzCanvas.width, lorenzCanvas.height);

        const lorenzPoints = [];
        const lorenzGeometry = new THREE.BufferGeometry();
        let x = 0.1, y = 0, z = 0;
        const sigma = 10, rho = 28, beta = 8/3;
        const dt = 0.01;

        for (let i = 0; i < 5000; i++) {
            const dx = sigma * (y - x) * dt;
            const dy = (x * (rho - z) - y) * dt;
            const dz = (x * y - beta * z) * dt;

            x += dx;
            y += dy;
            z += dz;

            lorenzPoints.push(x * 2, y * 2, z * 2);
        }

        lorenzGeometry.setAttribute('position', new THREE.Float32BufferAttribute(lorenzPoints, 3));

        const lorenzMaterial = new THREE.LineBasicMaterial({
            color: 0x00ff88,
            linewidth: 1
        });

        const lorenzLine = new THREE.Line(lorenzGeometry, lorenzMaterial);
        scene.add(lorenzLine);

        camera.position.z = 100;
        camera.position.y = 20;

        let lorenzRotate = true;

        function animateLorenz() {
            if (lorenzRotate) {
                lorenzLine.rotation.y += 0.005;
                lorenzLine.rotation.x += 0.002;
            }
            renderer.render(scene, camera);
            requestAnimationFrame(animateLorenz);
        }

        document.getElementById('lorenz-rotate').addEventListener('click', () => {
            lorenzRotate = !lorenzRotate;
        });

        document.getElementById('lorenz-reset').addEventListener('click', () => {
            lorenzLine.rotation.x = 0;
            lorenzLine.rotation.y = 0;
            lorenzLine.rotation.z = 0;
        });

        animateLorenz();
        } // end THREE.js check

        // Mandelbrot Set
        const mandelCanvas = document.getElementById('mandelbrot-canvas');
        const mandelCtx = mandelCanvas.getContext('2d');
        let mandelCenterX = -0.5;
        let mandelCenterY = 0;
        let mandelZoom = 1;

        function drawMandelbrot() {
            const imageData = mandelCtx.createImageData(mandelCanvas.width, mandelCanvas.height);
            const maxIter = 100;

            for (let px = 0; px < mandelCanvas.width; px++) {
                for (let py = 0; py < mandelCanvas.height; py++) {
                    const x0 = (px / mandelCanvas.width - 0.5) * 4 / mandelZoom + mandelCenterX;
                    const y0 = (py / mandelCanvas.height - 0.5) * 3 / mandelZoom + mandelCenterY;

                    let x = 0, y = 0;
                    let iter = 0;

                    while (x * x + y * y <= 4 && iter < maxIter) {
                        const xtemp = x * x - y * y + x0;
                        y = 2 * x * y + y0;
                        x = xtemp;
                        iter++;
                    }

                    const index = (py * mandelCanvas.width + px) * 4;

                    if (iter === maxIter) {
                        imageData.data[index] = 0;
                        imageData.data[index + 1] = 0;
                        imageData.data[index + 2] = 0;
                    } else {
                        const hue = (iter / maxIter) * 360;
                        const rgb = hslToRgb(hue / 360, 1, 0.5);
                        imageData.data[index] = rgb[0];
                        imageData.data[index + 1] = rgb[1];
                        imageData.data[index + 2] = rgb[2];
                    }
                    imageData.data[index + 3] = 255;
                }
            }

            mandelCtx.putImageData(imageData, 0, 0);
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        document.getElementById('mandel-zoom-in').addEventListener('click', () => {
            mandelZoom *= 2;
            drawMandelbrot();
        });

        document.getElementById('mandel-zoom-out').addEventListener('click', () => {
            mandelZoom /= 2;
            drawMandelbrot();
        });

        document.getElementById('mandel-reset').addEventListener('click', () => {
            mandelCenterX = -0.5;
            mandelCenterY = 0;
            mandelZoom = 1;
            drawMandelbrot();
        });

        mandelCanvas.addEventListener('click', (e) => {
            const rect = mandelCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            mandelCenterX = (x / mandelCanvas.width - 0.5) * 4 / mandelZoom + mandelCenterX;
            mandelCenterY = (y / mandelCanvas.height - 0.5) * 3 / mandelZoom + mandelCenterY;
            mandelZoom *= 2;
            drawMandelbrot();
        });

        drawMandelbrot();

        // L-System
        const lsysCanvas = document.getElementById('lsystem-canvas');
        const lsysCtx = lsysCanvas.getContext('2d');
        let lsysString = 'X';
        let lsysIteration = 0;
        const lsysRules = { 'X': 'F+[[X]-X]-F[-FX]+X', 'F': 'FF' };
        const lsysAngle = 25;

        function applyLSystemRules() {
            let newString = '';
            for (let char of lsysString) {
                newString += lsysRules[char] || char;
            }
            lsysString = newString;
            lsysIteration++;
        }

        function drawLSystem() {
            lsysCtx.fillStyle = '#000';
            lsysCtx.fillRect(0, 0, lsysCanvas.width, lsysCanvas.height);

            lsysCtx.strokeStyle = '#00ff88';
            lsysCtx.lineWidth = 1;

            const startX = lsysCanvas.width / 2;
            const startY = lsysCanvas.height - 50;
            const length = Math.max(1, 100 / Math.pow(2, lsysIteration));

            let x = startX;
            let y = startY;
            let angle = -90;
            const stack = [];

            lsysCtx.beginPath();
            lsysCtx.moveTo(x, y);

            for (let char of lsysString) {
                if (char === 'F') {
                    const newX = x + length * Math.cos(angle * Math.PI / 180);
                    const newY = y + length * Math.sin(angle * Math.PI / 180);
                    lsysCtx.lineTo(newX, newY);
                    x = newX;
                    y = newY;
                } else if (char === '+') {
                    angle += lsysAngle;
                } else if (char === '-') {
                    angle -= lsysAngle;
                } else if (char === '[') {
                    stack.push({ x, y, angle });
                } else if (char === ']') {
                    const state = stack.pop();
                    x = state.x;
                    y = state.y;
                    angle = state.angle;
                    lsysCtx.moveTo(x, y);
                }
            }

            lsysCtx.stroke();
        }

        document.getElementById('lsys-grow').addEventListener('click', () => {
            const interval = setInterval(() => {
                if (lsysIteration < 6) {
                    applyLSystemRules();
                    drawLSystem();
                } else {
                    clearInterval(interval);
                }
            }, 1000);
        });

        document.getElementById('lsys-iteration').addEventListener('click', () => {
            if (lsysIteration < 7) {
                applyLSystemRules();
                drawLSystem();
            }
        });

        document.getElementById('lsys-reset').addEventListener('click', () => {
            lsysString = 'X';
            lsysIteration = 0;
            drawLSystem();
        });

        drawLSystem();

        // Network Visualization with D3
        const networkSvg = d3.select('#network-svg');
        const width = 800;
        const height = 600;

        let networkSimulation = null;

        function generateSmallWorldNetwork() {
            const nodes = [];
            const links = [];
            const n = 50;
            const k = 4;
            const p = 0.1;

            for (let i = 0; i < n; i++) {
                nodes.push({ id: i });
            }

            // Ring lattice
            for (let i = 0; i < n; i++) {
                for (let j = 1; j <= k / 2; j++) {
                    if (Math.random() > p) {
                        links.push({ source: i, target: (i + j) % n });
                    } else {
                        // Rewire
                        const target = Math.floor(Math.random() * n);
                        if (target !== i) {
                            links.push({ source: i, target });
                        }
                    }
                }
            }

            return { nodes, links };
        }

        function generateScaleFreeNetwork() {
            const nodes = [];
            const links = [];
            const n = 50;
            const m = 2;

            for (let i = 0; i < m + 1; i++) {
                nodes.push({ id: i });
            }

            for (let i = 0; i < m; i++) {
                for (let j = i + 1; j < m + 1; j++) {
                    links.push({ source: i, target: j });
                }
            }

            for (let i = m + 1; i < n; i++) {
                nodes.push({ id: i });

                const targets = new Set();
                while (targets.size < m) {
                    const degrees = nodes.map((_, idx) =>
                        links.filter(l => l.source === idx || l.target === idx).length
                    );
                    const totalDegree = degrees.reduce((a, b) => a + b, 0);

                    let rand = Math.random() * totalDegree;
                    for (let j = 0; j < i; j++) {
                        rand -= degrees[j];
                        if (rand <= 0) {
                            targets.add(j);
                            break;
                        }
                    }
                }

                targets.forEach(target => {
                    links.push({ source: i, target });
                });
            }

            return { nodes, links };
        }

        function generateRandomNetwork() {
            const nodes = [];
            const links = [];
            const n = 50;
            const p = 0.1;

            for (let i = 0; i < n; i++) {
                nodes.push({ id: i });
            }

            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    if (Math.random() < p) {
                        links.push({ source: i, target: j });
                    }
                }
            }

            return { nodes, links };
        }

        function drawNetwork(data) {
            networkSvg.selectAll('*').remove();

            if (networkSimulation) {
                networkSimulation.stop();
            }

            networkSimulation = d3.forceSimulation(data.nodes)
                .force('link', d3.forceLink(data.links).id(d => d.id).distance(50))
                .force('charge', d3.forceManyBody().strength(-100))
                .force('center', d3.forceCenter(width / 2, height / 2));

            const link = networkSvg.append('g')
                .selectAll('line')
                .data(data.links)
                .join('line')
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', 1);

            const node = networkSvg.append('g')
                .selectAll('circle')
                .data(data.nodes)
                .join('circle')
                .attr('r', 5)
                .attr('fill', '#667eea')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            node.append('title')
                .text(d => `Node ${d.id}`);

            networkSimulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
            });

            function dragstarted(event) {
                if (!event.active) networkSimulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            function dragended(event) {
                if (!event.active) networkSimulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }
        }

        document.getElementById('net-small-world').addEventListener('click', () => {
            drawNetwork(generateSmallWorldNetwork());
        });

        document.getElementById('net-scale-free').addEventListener('click', () => {
            drawNetwork(generateScaleFreeNetwork());
        });

        document.getElementById('net-random').addEventListener('click', () => {
            drawNetwork(generateRandomNetwork());
        });

        document.getElementById('net-reset').addEventListener('click', () => {
            drawNetwork(generateSmallWorldNetwork());
        });

        // Initialize with small-world network
        drawNetwork(generateSmallWorldNetwork());
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>