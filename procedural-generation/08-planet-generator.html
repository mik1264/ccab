<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planet Generator - Procedural Generation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #020208;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas { display: block; width: 100vw; height: 100vh; }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            min-width: 280px;
        }
        h1 { font-size: 1.3em; margin-bottom: 5px; color: #42a5f5; }
        .subtitle { font-size: 0.85em; color: #888; margin-bottom: 15px; }
        .slider-group { margin-bottom: 12px; }
        .slider-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.85em;
            color: #aaa;
        }
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #42a5f5;
            border-radius: 50%;
            cursor: pointer;
        }
        .planet-types {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        .type-btn {
            padding: 6px 10px;
            background: #222;
            border: 1px solid #444;
            border-radius: 6px;
            color: #aaa;
            font-size: 0.75em;
            cursor: pointer;
        }
        .type-btn:hover, .type-btn.active {
            background: #333;
            border-color: #42a5f5;
            color: #fff;
        }
        .button-row { display: flex; gap: 10px; margin-top: 15px; }
        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: #42a5f5;
            color: #000;
            cursor: pointer;
            font-weight: 600;
        }
        button:hover { background: #1e88e5; }
        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
            font-size: 0.85em;
            color: #888;
        }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #42a5f5;
            text-decoration: none;
            z-index: 100;
        }
        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 350px;
            font-size: 0.85em;
            color: #aaa;
            line-height: 1.5;
        }
        .info h3 { color: #42a5f5; margin-bottom: 8px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>Planet Generator</h1>
        <p class="subtitle">Procedural Worlds</p>

        <div class="slider-group">
            <label>Ocean Level <span id="oceanVal">50%</span></label>
            <input type="range" id="ocean" min="0" max="80" step="5" value="50">
        </div>

        <div class="slider-group">
            <label>Roughness <span id="roughVal">0.6</span></label>
            <input type="range" id="roughness" min="0.3" max="0.9" step="0.05" value="0.6">
        </div>

        <div class="slider-group">
            <label>Ice Caps <span id="iceVal">20%</span></label>
            <input type="range" id="ice" min="0" max="50" step="5" value="20">
        </div>

        <div class="slider-group">
            <label>Cloud Cover <span id="cloudVal">30%</span></label>
            <input type="range" id="clouds" min="0" max="80" step="5" value="30">
        </div>

        <div class="planet-types">
            <span class="type-btn active" data-type="earthlike">Earth-like</span>
            <span class="type-btn" data-type="desert">Desert</span>
            <span class="type-btn" data-type="ocean">Ocean</span>
            <span class="type-btn" data-type="ice">Ice</span>
            <span class="type-btn" data-type="volcanic">Volcanic</span>
        </div>

        <div class="button-row">
            <button id="generateBtn">New Planet</button>
            <button id="atmosphereBtn">Atmosphere</button>
        </div>

        <div class="stats">
            <div>Type: <span id="planetType">Earth-like</span></div>
            <div>FPS: <span id="fps">0</span></div>
        </div>
    </div>

    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="info">
        <h3>Planet Generation</h3>
        <p>A spherical planet rendered with 3D noise for terrain and biomes.
        Different planet types have unique color palettes and features.
        The planet rotates slowly, and clouds can be toggled on/off.</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let oceanLevel = 50;
        let roughness = 0.6;
        let iceCaps = 20;
        let cloudCover = 30;
        let planetType = 'earthlike';
        let showAtmosphere = true;
        let time = 0;
        let seed = Math.random() * 10000;

        // Noise
        const p = new Uint8Array(512);

        function initNoise(s) {
            const perm = new Uint8Array(256);
            for (let i = 0; i < 256; i++) perm[i] = i;

            for (let i = 255; i > 0; i--) {
                s = (s * 16807) % 2147483647;
                const j = s % (i + 1);
                [perm[i], perm[j]] = [perm[j], perm[i]];
            }

            for (let i = 0; i < 512; i++) p[i] = perm[i & 255];
        }

        function noise3D(x, y, z) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            const Z = Math.floor(z) & 255;

            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);

            const u = x * x * x * (x * (x * 6 - 15) + 10);
            const v = y * y * y * (y * (y * 6 - 15) + 10);
            const w = z * z * z * (z * (z * 6 - 15) + 10);

            const A = p[X] + Y;
            const AA = p[A] + Z;
            const AB = p[A + 1] + Z;
            const B = p[X + 1] + Y;
            const BA = p[B] + Z;
            const BB = p[B + 1] + Z;

            function grad(h, x, y, z) {
                h = h & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
            }

            const lerp = (a, b, t) => a + t * (b - a);

            return lerp(
                lerp(
                    lerp(grad(p[AA], x, y, z), grad(p[BA], x - 1, y, z), u),
                    lerp(grad(p[AB], x, y - 1, z), grad(p[BB], x - 1, y - 1, z), u),
                    v
                ),
                lerp(
                    lerp(grad(p[AA + 1], x, y, z - 1), grad(p[BA + 1], x - 1, y, z - 1), u),
                    lerp(grad(p[AB + 1], x, y - 1, z - 1), grad(p[BB + 1], x - 1, y - 1, z - 1), u),
                    v
                ),
                w
            );
        }

        function fbm3D(x, y, z, octaves) {
            let value = 0;
            let amplitude = 1;
            let frequency = 1;
            let maxValue = 0;

            for (let i = 0; i < octaves; i++) {
                value += amplitude * noise3D(x * frequency, y * frequency, z * frequency);
                maxValue += amplitude;
                amplitude *= roughness;
                frequency *= 2;
            }

            return (value / maxValue + 1) / 2;
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = canvas.width;
            height = canvas.height;
        }

        function getPlanetColors() {
            switch (planetType) {
                case 'earthlike':
                    return {
                        ocean: [20, 80, 150],
                        beach: [210, 190, 140],
                        lowland: [80, 140, 60],
                        highland: [60, 100, 40],
                        mountain: [120, 100, 80],
                        snow: [240, 245, 255],
                        atmosphere: [100, 150, 255, 0.3]
                    };
                case 'desert':
                    return {
                        ocean: [160, 120, 80],
                        beach: [200, 160, 100],
                        lowland: [180, 140, 90],
                        highland: [160, 120, 70],
                        mountain: [140, 100, 60],
                        snow: [220, 200, 180],
                        atmosphere: [255, 200, 150, 0.2]
                    };
                case 'ocean':
                    return {
                        ocean: [20, 60, 120],
                        beach: [40, 100, 160],
                        lowland: [50, 120, 180],
                        highland: [60, 140, 200],
                        mountain: [80, 160, 220],
                        snow: [200, 230, 255],
                        atmosphere: [100, 180, 255, 0.4]
                    };
                case 'ice':
                    return {
                        ocean: [100, 140, 180],
                        beach: [180, 200, 220],
                        lowland: [200, 220, 240],
                        highland: [220, 235, 250],
                        mountain: [240, 248, 255],
                        snow: [255, 255, 255],
                        atmosphere: [180, 220, 255, 0.35]
                    };
                case 'volcanic':
                    return {
                        ocean: [200, 60, 20],
                        beach: [80, 40, 30],
                        lowland: [60, 50, 45],
                        highland: [50, 45, 40],
                        mountain: [40, 35, 30],
                        snow: [255, 150, 50],
                        atmosphere: [255, 100, 50, 0.25]
                    };
                default:
                    return getPlanetColors();
            }
        }

        function draw() {
            // Space background with stars
            ctx.fillStyle = '#020208';
            ctx.fillRect(0, 0, width, height);

            // Draw stars
            const starSeed = Math.floor(seed);
            let s = starSeed;
            for (let i = 0; i < 200; i++) {
                s = (s * 16807) % 2147483647;
                const x = (s % width);
                s = (s * 16807) % 2147483647;
                const y = (s % height);
                s = (s * 16807) % 2147483647;
                const brightness = 0.3 + (s % 100) / 100 * 0.7;

                ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                ctx.beginPath();
                ctx.arc(x, y, 0.5 + (s % 3) / 3, 0, Math.PI * 2);
                ctx.fill();
            }

            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.35;
            const colors = getPlanetColors();

            // Create planet image
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            const rotationY = time * 0.1;

            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const dx = px - centerX;
                    const dy = py - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > radius + 20) continue;

                    const idx = (py * width + px) * 4;

                    if (dist <= radius) {
                        // On planet surface
                        // Convert 2D to 3D sphere coordinates
                        const z = Math.sqrt(radius * radius - dx * dx - dy * dy);
                        const nx = dx / radius;
                        const ny = -dy / radius;
                        const nz = z / radius;

                        // Rotate around Y axis
                        const cosR = Math.cos(rotationY);
                        const sinR = Math.sin(rotationY);
                        const rx = nx * cosR + nz * sinR;
                        const rz = -nx * sinR + nz * cosR;

                        // Spherical coordinates for noise
                        const lat = Math.asin(ny);
                        const lon = Math.atan2(rx, rz);

                        // Get terrain height from noise
                        const scale = 3;
                        const noiseVal = fbm3D(
                            Math.cos(lon) * Math.cos(lat) * scale,
                            Math.sin(lat) * scale,
                            Math.sin(lon) * Math.cos(lat) * scale,
                            6
                        );

                        // Determine biome
                        const latAbs = Math.abs(ny);
                        const normalizedOcean = oceanLevel / 100;
                        const normalizedIce = iceCaps / 100;

                        let r, g, b;

                        // Ice caps
                        if (latAbs > 1 - normalizedIce) {
                            [r, g, b] = colors.snow;
                        }
                        // Ocean
                        else if (noiseVal < normalizedOcean) {
                            const depth = noiseVal / normalizedOcean;
                            r = colors.ocean[0] * (0.7 + depth * 0.3);
                            g = colors.ocean[1] * (0.7 + depth * 0.3);
                            b = colors.ocean[2] * (0.7 + depth * 0.3);
                        }
                        // Beach
                        else if (noiseVal < normalizedOcean + 0.05) {
                            [r, g, b] = colors.beach;
                        }
                        // Lowlands
                        else if (noiseVal < 0.6) {
                            const t = (noiseVal - normalizedOcean - 0.05) / (0.6 - normalizedOcean - 0.05);
                            r = colors.lowland[0] * (1 - t) + colors.highland[0] * t;
                            g = colors.lowland[1] * (1 - t) + colors.highland[1] * t;
                            b = colors.lowland[2] * (1 - t) + colors.highland[2] * t;
                        }
                        // Mountains
                        else if (noiseVal < 0.85) {
                            [r, g, b] = colors.mountain;
                        }
                        // Snow peaks
                        else {
                            [r, g, b] = colors.snow;
                        }

                        // Simple lighting
                        const lightDir = { x: 0.5, y: -0.3, z: 0.8 };
                        const len = Math.sqrt(lightDir.x ** 2 + lightDir.y ** 2 + lightDir.z ** 2);
                        lightDir.x /= len; lightDir.y /= len; lightDir.z /= len;

                        const diffuse = Math.max(0.2, nx * lightDir.x + ny * lightDir.y + nz * lightDir.z);
                        r *= diffuse;
                        g *= diffuse;
                        b *= diffuse;

                        data[idx] = Math.min(255, r);
                        data[idx + 1] = Math.min(255, g);
                        data[idx + 2] = Math.min(255, b);
                        data[idx + 3] = 255;

                        // Clouds
                        if (cloudCover > 0) {
                            const cloudNoise = fbm3D(
                                Math.cos(lon) * Math.cos(lat) * 2 + time * 0.02,
                                Math.sin(lat) * 2,
                                Math.sin(lon) * Math.cos(lat) * 2 + time * 0.01,
                                4
                            );

                            if (cloudNoise > 1 - cloudCover / 100) {
                                const cloudAlpha = (cloudNoise - (1 - cloudCover / 100)) * 3;
                                const ca = Math.min(0.9, cloudAlpha) * diffuse;
                                data[idx] = data[idx] * (1 - ca) + 255 * ca;
                                data[idx + 1] = data[idx + 1] * (1 - ca) + 255 * ca;
                                data[idx + 2] = data[idx + 2] * (1 - ca) + 255 * ca;
                            }
                        }
                    }
                    // Atmosphere glow
                    else if (showAtmosphere && dist < radius + 20) {
                        const glowDist = (dist - radius) / 20;
                        const alpha = (1 - glowDist) * colors.atmosphere[3];
                        data[idx] = colors.atmosphere[0];
                        data[idx + 1] = colors.atmosphere[1];
                        data[idx + 2] = colors.atmosphere[2];
                        data[idx + 3] = alpha * 255;
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // UI
        document.getElementById('ocean').addEventListener('input', (e) => {
            oceanLevel = parseInt(e.target.value);
            document.getElementById('oceanVal').textContent = oceanLevel + '%';
        });

        document.getElementById('roughness').addEventListener('input', (e) => {
            roughness = parseFloat(e.target.value);
            document.getElementById('roughVal').textContent = roughness.toFixed(2);
        });

        document.getElementById('ice').addEventListener('input', (e) => {
            iceCaps = parseInt(e.target.value);
            document.getElementById('iceVal').textContent = iceCaps + '%';
        });

        document.getElementById('clouds').addEventListener('input', (e) => {
            cloudCover = parseInt(e.target.value);
            document.getElementById('cloudVal').textContent = cloudCover + '%';
        });

        document.querySelectorAll('.type-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.type-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                planetType = btn.dataset.type;
                document.getElementById('planetType').textContent = btn.textContent;
            });
        });

        document.getElementById('generateBtn').addEventListener('click', () => {
            seed = Math.random() * 10000;
            initNoise(seed);
        });

        document.getElementById('atmosphereBtn').addEventListener('click', function() {
            showAtmosphere = !showAtmosphere;
            this.textContent = showAtmosphere ? 'No Atmosphere' : 'Atmosphere';
        });

        window.addEventListener('resize', resize);

        let lastTime = performance.now();
        let frameCount = 0;
        let fpsTime = 0;

        function animate() {
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            frameCount++;
            fpsTime += dt;
            if (fpsTime >= 1) {
                document.getElementById('fps').textContent = Math.round(frameCount / fpsTime);
                frameCount = 0;
                fpsTime = 0;
            }

            time += dt;
            draw();

            requestAnimationFrame(animate);
        }

        initNoise(seed);
        resize();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
