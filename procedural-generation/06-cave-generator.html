<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cave Generator - Procedural Generation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas { display: block; width: 100vw; height: 100vh; }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            min-width: 280px;
        }
        h1 { font-size: 1.3em; margin-bottom: 5px; color: #795548; }
        .subtitle { font-size: 0.85em; color: #888; margin-bottom: 15px; }
        .slider-group { margin-bottom: 12px; }
        .slider-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.85em;
            color: #aaa;
        }
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #795548;
            border-radius: 50%;
            cursor: pointer;
        }
        .button-row { display: flex; gap: 10px; margin-top: 15px; }
        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: #795548;
            color: #fff;
            cursor: pointer;
            font-weight: 600;
        }
        button:hover { background: #6d4c41; }
        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
            font-size: 0.85em;
            color: #888;
        }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #795548;
            text-decoration: none;
            z-index: 100;
        }
        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 350px;
            font-size: 0.85em;
            color: #aaa;
            line-height: 1.5;
        }
        .info h3 { color: #795548; margin-bottom: 8px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>Cave Generator</h1>
        <p class="subtitle">Cellular Automata Caves</p>

        <div class="slider-group">
            <label>Initial Fill <span id="fillVal">45%</span></label>
            <input type="range" id="fill" min="30" max="60" step="1" value="45">
        </div>

        <div class="slider-group">
            <label>Birth Threshold <span id="birthVal">5</span></label>
            <input type="range" id="birth" min="3" max="7" step="1" value="5">
        </div>

        <div class="slider-group">
            <label>Death Threshold <span id="deathVal">4</span></label>
            <input type="range" id="death" min="2" max="6" step="1" value="4">
        </div>

        <div class="slider-group">
            <label>Iterations <span id="iterVal">5</span></label>
            <input type="range" id="iterations" min="1" max="15" step="1" value="5">
        </div>

        <div class="button-row">
            <button id="generateBtn">Generate</button>
            <button id="stepBtn">Step</button>
        </div>

        <div class="button-row">
            <button id="floodBtn">Flood Fill</button>
            <button id="connectBtn">Connect</button>
        </div>

        <div class="stats">
            <div>Step: <span id="stepCount">0</span></div>
            <div>Open Space: <span id="openSpace">0%</span></div>
            <div>Regions: <span id="regions">0</span></div>
        </div>
    </div>

    <a href="index.html" class="back-link">← Back to Gallery</a>

    <div class="info">
        <h3>Cave Generation</h3>
        <p>Uses cellular automata rules similar to Conway's Game of Life.
        A cell becomes wall if it has ≥ birth neighbors, and stays wall if
        it has ≥ death neighbors. Multiple iterations smooth the caves.
        Flood fill shows disconnected regions, and connect links them.</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height, gridWidth, gridHeight;
        const CELL_SIZE = 6;

        let grid;
        let regionGrid;
        let regionCount = 0;

        let fillPercent = 45;
        let birthThreshold = 5;
        let deathThreshold = 4;
        let iterations = 5;
        let currentStep = 0;

        const regionColors = [];
        for (let i = 0; i < 50; i++) {
            const hue = (i * 37) % 360;
            regionColors.push(`hsl(${hue}, 60%, 40%)`);
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = canvas.width;
            height = canvas.height;
            gridWidth = Math.floor(width / CELL_SIZE);
            gridHeight = Math.floor(height / CELL_SIZE);
            generate();
        }

        function idx(x, y) {
            return y * gridWidth + x;
        }

        function generate() {
            grid = new Uint8Array(gridWidth * gridHeight);
            regionGrid = new Int32Array(gridWidth * gridHeight);
            regionGrid.fill(-1);
            regionCount = 0;
            currentStep = 0;

            // Random fill
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (x === 0 || x === gridWidth - 1 || y === 0 || y === gridHeight - 1) {
                        grid[idx(x, y)] = 1; // Border walls
                    } else {
                        grid[idx(x, y)] = Math.random() * 100 < fillPercent ? 1 : 0;
                    }
                }
            }

            // Apply iterations
            for (let i = 0; i < iterations; i++) {
                step();
            }

            updateStats();
            draw();
        }

        function step() {
            const newGrid = new Uint8Array(grid.length);

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    // Border always wall
                    if (x === 0 || x === gridWidth - 1 || y === 0 || y === gridHeight - 1) {
                        newGrid[idx(x, y)] = 1;
                        continue;
                    }

                    // Count neighbors
                    let walls = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx < 0 || nx >= gridWidth || ny < 0 || ny >= gridHeight) {
                                walls++;
                            } else if (grid[idx(nx, ny)] === 1) {
                                walls++;
                            }
                        }
                    }

                    // Apply rules
                    if (grid[idx(x, y)] === 1) {
                        // Wall stays wall if enough neighbors
                        newGrid[idx(x, y)] = walls >= deathThreshold ? 1 : 0;
                    } else {
                        // Empty becomes wall if enough neighbors
                        newGrid[idx(x, y)] = walls >= birthThreshold ? 1 : 0;
                    }
                }
            }

            grid = newGrid;
            currentStep++;
            regionGrid.fill(-1);
            regionCount = 0;
        }

        function floodFill() {
            regionGrid.fill(-1);
            regionCount = 0;

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (grid[idx(x, y)] === 0 && regionGrid[idx(x, y)] === -1) {
                        // Flood fill this region
                        const stack = [[x, y]];
                        const region = regionCount++;

                        while (stack.length > 0) {
                            const [cx, cy] = stack.pop();
                            if (cx < 0 || cx >= gridWidth || cy < 0 || cy >= gridHeight) continue;
                            if (grid[idx(cx, cy)] !== 0) continue;
                            if (regionGrid[idx(cx, cy)] !== -1) continue;

                            regionGrid[idx(cx, cy)] = region;

                            stack.push([cx - 1, cy], [cx + 1, cy], [cx, cy - 1], [cx, cy + 1]);
                        }
                    }
                }
            }

            updateStats();
            draw();
        }

        function connectRegions() {
            if (regionCount < 2) {
                floodFill();
            }
            if (regionCount < 2) return;

            // Find region centers
            const regionCenters = [];
            const regionSizes = [];
            for (let i = 0; i < regionCount; i++) {
                regionCenters.push({ x: 0, y: 0, count: 0 });
                regionSizes.push(0);
            }

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const region = regionGrid[idx(x, y)];
                    if (region >= 0) {
                        regionCenters[region].x += x;
                        regionCenters[region].y += y;
                        regionCenters[region].count++;
                        regionSizes[region]++;
                    }
                }
            }

            for (let i = 0; i < regionCount; i++) {
                if (regionCenters[i].count > 0) {
                    regionCenters[i].x = Math.floor(regionCenters[i].x / regionCenters[i].count);
                    regionCenters[i].y = Math.floor(regionCenters[i].y / regionCenters[i].count);
                }
            }

            // Find largest region
            let largest = 0;
            for (let i = 1; i < regionCount; i++) {
                if (regionSizes[i] > regionSizes[largest]) {
                    largest = i;
                }
            }

            // Connect all regions to the largest
            for (let i = 0; i < regionCount; i++) {
                if (i === largest) continue;

                // Find closest points between regions
                let bestDist = Infinity;
                let bestPoint1 = null;
                let bestPoint2 = null;

                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        if (regionGrid[idx(x, y)] !== i) continue;

                        for (let y2 = 0; y2 < gridHeight; y2++) {
                            for (let x2 = 0; x2 < gridWidth; x2++) {
                                if (regionGrid[idx(x2, y2)] !== largest) continue;

                                const dist = (x - x2) ** 2 + (y - y2) ** 2;
                                if (dist < bestDist) {
                                    bestDist = dist;
                                    bestPoint1 = { x, y };
                                    bestPoint2 = { x: x2, y: y2 };
                                }
                            }
                        }
                    }
                }

                // Carve tunnel
                if (bestPoint1 && bestPoint2) {
                    let x = bestPoint1.x;
                    let y = bestPoint1.y;

                    while (x !== bestPoint2.x || y !== bestPoint2.y) {
                        // Carve a small circle
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx > 0 && nx < gridWidth - 1 && ny > 0 && ny < gridHeight - 1) {
                                    grid[idx(nx, ny)] = 0;
                                }
                            }
                        }

                        // Move toward target
                        if (x < bestPoint2.x) x++;
                        else if (x > bestPoint2.x) x--;

                        if (y < bestPoint2.y) y++;
                        else if (y > bestPoint2.y) y--;
                    }
                }
            }

            floodFill();
        }

        function updateStats() {
            let openCount = 0;
            for (let i = 0; i < grid.length; i++) {
                if (grid[i] === 0) openCount++;
            }

            document.getElementById('stepCount').textContent = currentStep;
            document.getElementById('openSpace').textContent =
                Math.round(openCount / grid.length * 100) + '%';
            document.getElementById('regions').textContent = regionCount || '?';
        }

        function draw() {
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, width, height);

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const i = idx(x, y);

                    if (grid[i] === 0) {
                        // Floor - color by region if available
                        if (regionGrid[i] >= 0) {
                            ctx.fillStyle = regionColors[regionGrid[i] % regionColors.length];
                        } else {
                            ctx.fillStyle = '#5d4037';
                        }
                    } else {
                        // Wall with depth effect
                        const hasFloorNeighbor =
                            (x > 0 && grid[idx(x - 1, y)] === 0) ||
                            (x < gridWidth - 1 && grid[idx(x + 1, y)] === 0) ||
                            (y > 0 && grid[idx(x, y - 1)] === 0) ||
                            (y < gridHeight - 1 && grid[idx(x, y + 1)] === 0);

                        ctx.fillStyle = hasFloorNeighbor ? '#3e2723' : '#1a1a1a';
                    }

                    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE - 1, CELL_SIZE - 1);
                }
            }
        }

        // UI
        document.getElementById('fill').addEventListener('input', (e) => {
            fillPercent = parseInt(e.target.value);
            document.getElementById('fillVal').textContent = fillPercent + '%';
        });

        document.getElementById('birth').addEventListener('input', (e) => {
            birthThreshold = parseInt(e.target.value);
            document.getElementById('birthVal').textContent = birthThreshold;
        });

        document.getElementById('death').addEventListener('input', (e) => {
            deathThreshold = parseInt(e.target.value);
            document.getElementById('deathVal').textContent = deathThreshold;
        });

        document.getElementById('iterations').addEventListener('input', (e) => {
            iterations = parseInt(e.target.value);
            document.getElementById('iterVal').textContent = iterations;
        });

        document.getElementById('generateBtn').addEventListener('click', generate);

        document.getElementById('stepBtn').addEventListener('click', () => {
            step();
            updateStats();
            draw();
        });

        document.getElementById('floodBtn').addEventListener('click', floodFill);
        document.getElementById('connectBtn').addEventListener('click', connectRegions);

        window.addEventListener('resize', resize);
        resize();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
