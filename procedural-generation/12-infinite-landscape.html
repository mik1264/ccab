<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Landscape - Procedural Generation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a1a;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas { display: block; width: 100vw; height: 100vh; }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            min-width: 280px;
        }
        h1 { font-size: 1.3em; margin-bottom: 5px; color: #81c784; }
        .subtitle { font-size: 0.85em; color: #888; margin-bottom: 15px; }
        .slider-group { margin-bottom: 12px; }
        .slider-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.85em;
            color: #aaa;
        }
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #81c784;
            border-radius: 50%;
            cursor: pointer;
        }
        .button-row { display: flex; gap: 10px; margin-top: 15px; }
        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: #81c784;
            color: #000;
            cursor: pointer;
            font-weight: 600;
        }
        button:hover { background: #66bb6a; }
        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
            font-size: 0.85em;
            color: #888;
        }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #81c784;
            text-decoration: none;
            z-index: 100;
        }
        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 350px;
            font-size: 0.85em;
            color: #aaa;
            line-height: 1.5;
        }
        .info h3 { color: #81c784; margin-bottom: 8px; }
        .instructions {
            margin-top: 10px;
            padding: 10px;
            background: rgba(129, 199, 132, 0.1);
            border-radius: 6px;
            font-size: 0.8em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>Infinite Landscape</h1>
        <p class="subtitle">Chunked Streaming Terrain</p>

        <div class="slider-group">
            <label>Speed <span id="speedVal">1.0</span></label>
            <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1">
        </div>

        <div class="slider-group">
            <label>Height Scale <span id="heightVal">150</span></label>
            <input type="range" id="height" min="50" max="300" step="10" value="150">
        </div>

        <div class="slider-group">
            <label>Detail <span id="detailVal">6</span></label>
            <input type="range" id="detail" min="2" max="8" step="1" value="6">
        </div>

        <div class="slider-group">
            <label>View Distance <span id="viewVal">12</span></label>
            <input type="range" id="view" min="6" max="20" step="1" value="12">
        </div>

        <div class="button-row">
            <button id="toggleBtn">Pause</button>
            <button id="resetBtn">Reset</button>
        </div>

        <div class="instructions">
            Arrow Keys / WASD: Move camera<br>
            Q/E: Rotate view
        </div>

        <div class="stats">
            <div>Position: <span id="posX">0</span>, <span id="posZ">0</span></div>
            <div>Chunks: <span id="chunks">0</span></div>
            <div>FPS: <span id="fps">0</span></div>
        </div>
    </div>

    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="info">
        <h3>Infinite Streaming</h3>
        <p>Endless procedural terrain using chunk-based generation.
        New chunks are generated as you move, creating an infinite
        world from a single noise seed. Old chunks are recycled.</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        const CHUNK_SIZE = 16;
        const CELL_SIZE = 8;

        let cameraX = 0, cameraZ = 0;
        let cameraAngle = 0;
        let speed = 1;
        let heightScale = 150;
        let octaves = 6;
        let viewDistance = 12;
        let running = true;

        const chunks = new Map();
        const keys = {};

        // Noise
        const p = new Uint8Array(512);
        const seed = Math.random() * 10000;

        function initNoise() {
            const perm = new Uint8Array(256);
            for (let i = 0; i < 256; i++) perm[i] = i;

            let s = seed;
            for (let i = 255; i > 0; i--) {
                s = (s * 16807) % 2147483647;
                const j = s % (i + 1);
                [perm[i], perm[j]] = [perm[j], perm[i]];
            }

            for (let i = 0; i < 512; i++) p[i] = perm[i & 255];
        }

        function noise(x, y) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            x -= Math.floor(x);
            y -= Math.floor(y);

            const u = x * x * x * (x * (x * 6 - 15) + 10);
            const v = y * y * y * (y * (y * 6 - 15) + 10);

            const A = p[X] + Y;
            const B = p[X + 1] + Y;

            function grad(h, x, y) {
                h = h & 3;
                return ((h & 1) ? -x : x) + ((h & 2) ? -y : y);
            }

            const lerp = (a, b, t) => a + t * (b - a);

            return lerp(
                lerp(grad(p[A], x, y), grad(p[B], x - 1, y), u),
                lerp(grad(p[A + 1], x, y - 1), grad(p[B + 1], x - 1, y - 1), u),
                v
            );
        }

        function fbm(x, y) {
            let value = 0;
            let amplitude = 1;
            let frequency = 1;
            let maxValue = 0;

            for (let i = 0; i < octaves; i++) {
                value += amplitude * noise(x * frequency, y * frequency);
                maxValue += amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }

            return (value / maxValue + 1) / 2;
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = canvas.width;
            height = canvas.height;
        }

        function getChunkKey(cx, cz) {
            return `${cx},${cz}`;
        }

        function generateChunk(cx, cz) {
            const heightmap = new Float32Array(CHUNK_SIZE * CHUNK_SIZE);

            for (let z = 0; z < CHUNK_SIZE; z++) {
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    const worldX = (cx * CHUNK_SIZE + x) * 0.02;
                    const worldZ = (cz * CHUNK_SIZE + z) * 0.02;
                    heightmap[z * CHUNK_SIZE + x] = fbm(worldX, worldZ);
                }
            }

            return { cx, cz, heightmap };
        }

        function getOrCreateChunk(cx, cz) {
            const key = getChunkKey(cx, cz);
            if (!chunks.has(key)) {
                chunks.set(key, generateChunk(cx, cz));
            }
            return chunks.get(key);
        }

        function getHeight(worldX, worldZ) {
            const cx = Math.floor(worldX / CHUNK_SIZE);
            const cz = Math.floor(worldZ / CHUNK_SIZE);
            const chunk = getOrCreateChunk(cx, cz);

            const lx = ((worldX % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
            const lz = ((worldZ % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

            const x0 = Math.floor(lx);
            const z0 = Math.floor(lz);
            const x1 = (x0 + 1) % CHUNK_SIZE;
            const z1 = (z0 + 1) % CHUNK_SIZE;

            const fx = lx - x0;
            const fz = lz - z0;

            // Handle edge cases with neighboring chunks
            let h00, h10, h01, h11;

            if (x1 === 0 || z1 === 0) {
                // Need to sample from neighbor chunks
                h00 = chunk.heightmap[z0 * CHUNK_SIZE + x0];
                h10 = x1 === 0 ? getOrCreateChunk(cx + 1, cz).heightmap[z0 * CHUNK_SIZE] : chunk.heightmap[z0 * CHUNK_SIZE + x1];
                h01 = z1 === 0 ? getOrCreateChunk(cx, cz + 1).heightmap[x0] : chunk.heightmap[z1 * CHUNK_SIZE + x0];
                h11 = (x1 === 0 && z1 === 0) ? getOrCreateChunk(cx + 1, cz + 1).heightmap[0] :
                      (x1 === 0 ? getOrCreateChunk(cx + 1, cz).heightmap[z1 * CHUNK_SIZE] :
                       (z1 === 0 ? getOrCreateChunk(cx, cz + 1).heightmap[x1] : chunk.heightmap[z1 * CHUNK_SIZE + x1]));
            } else {
                h00 = chunk.heightmap[z0 * CHUNK_SIZE + x0];
                h10 = chunk.heightmap[z0 * CHUNK_SIZE + x1];
                h01 = chunk.heightmap[z1 * CHUNK_SIZE + x0];
                h11 = chunk.heightmap[z1 * CHUNK_SIZE + x1];
            }

            // Bilinear interpolation
            const h0 = h00 + fx * (h10 - h00);
            const h1 = h01 + fx * (h11 - h01);
            return h0 + fz * (h1 - h0);
        }

        function getTerrainColor(h, worldX, worldZ) {
            // Biome based on height
            if (h < 0.35) {
                // Water
                const depth = h / 0.35;
                return { r: 30 + depth * 40, g: 60 + depth * 60, b: 130 + depth * 50 };
            } else if (h < 0.4) {
                // Sand
                return { r: 210, g: 190, b: 140 };
            } else if (h < 0.6) {
                // Grass with variation
                const t = (h - 0.4) / 0.2;
                const variation = noise(worldX * 0.5, worldZ * 0.5) * 0.2;
                return {
                    r: 60 + t * 20 + variation * 30,
                    g: 120 + t * 20 - variation * 20,
                    b: 40 + t * 10
                };
            } else if (h < 0.75) {
                // Rock
                const t = (h - 0.6) / 0.15;
                const gray = 80 + t * 40;
                return { r: gray, g: gray - 5, b: gray - 10 };
            } else {
                // Snow
                const t = (h - 0.75) / 0.25;
                const white = 200 + t * 55;
                return { r: white, g: white, b: white + 5 };
            }
        }

        function project(x, y, z) {
            // Rotate around camera
            const dx = x - cameraX;
            const dz = z - cameraZ;

            const cos = Math.cos(cameraAngle);
            const sin = Math.sin(cameraAngle);

            const rx = dx * cos - dz * sin;
            const rz = dx * sin + dz * cos;

            // Perspective projection
            const fov = 400;
            const dist = rz + viewDistance * CHUNK_SIZE * 0.5;

            if (dist < 1) return null;

            const scale = fov / dist;

            return {
                x: width / 2 + rx * scale,
                y: height * 0.6 - y * scale,
                z: dist,
                scale
            };
        }

        function cleanupChunks() {
            const camCX = Math.floor(cameraX / CHUNK_SIZE);
            const camCZ = Math.floor(cameraZ / CHUNK_SIZE);

            for (const [key, chunk] of chunks) {
                const dx = Math.abs(chunk.cx - camCX);
                const dz = Math.abs(chunk.cz - camCZ);
                if (dx > viewDistance + 2 || dz > viewDistance + 2) {
                    chunks.delete(key);
                }
            }
        }

        function draw() {
            // Sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, height);
            skyGradient.addColorStop(0, '#1a237e');
            skyGradient.addColorStop(0.4, '#3949ab');
            skyGradient.addColorStop(0.7, '#64b5f6');
            skyGradient.addColorStop(1, '#81d4fa');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, width, height);

            // Sun
            ctx.fillStyle = '#fff9c4';
            ctx.beginPath();
            ctx.arc(width * 0.8, height * 0.15, 40, 0, Math.PI * 2);
            ctx.fill();

            // Collect visible terrain cells
            const cells = [];
            const camCX = Math.floor(cameraX / CHUNK_SIZE);
            const camCZ = Math.floor(cameraZ / CHUNK_SIZE);

            for (let cz = camCZ - viewDistance; cz <= camCZ + viewDistance; cz++) {
                for (let cx = camCX - viewDistance; cx <= camCX + viewDistance; cx++) {
                    getOrCreateChunk(cx, cz);

                    for (let z = 0; z < CHUNK_SIZE; z++) {
                        for (let x = 0; x < CHUNK_SIZE; x++) {
                            const worldX = cx * CHUNK_SIZE + x;
                            const worldZ = cz * CHUNK_SIZE + z;

                            const h = getHeight(worldX, worldZ);
                            const y = (h - 0.5) * heightScale;

                            const p1 = project(worldX, y, worldZ);
                            const p2 = project(worldX + 1, getHeight(worldX + 1, worldZ) * heightScale - heightScale / 2, worldZ);
                            const p3 = project(worldX + 1, getHeight(worldX + 1, worldZ + 1) * heightScale - heightScale / 2, worldZ + 1);
                            const p4 = project(worldX, getHeight(worldX, worldZ + 1) * heightScale - heightScale / 2, worldZ + 1);

                            if (p1 && p2 && p3 && p4 && p1.z > 0) {
                                const avgZ = (p1.z + p2.z + p3.z + p4.z) / 4;
                                cells.push({
                                    points: [p1, p2, p3, p4],
                                    z: avgZ,
                                    h,
                                    worldX,
                                    worldZ
                                });
                            }
                        }
                    }
                }
            }

            // Sort by depth
            cells.sort((a, b) => b.z - a.z);

            // Draw terrain
            for (const cell of cells) {
                const color = getTerrainColor(cell.h, cell.worldX, cell.worldZ);

                // Distance fog
                const fogFactor = Math.min(1, cell.z / (viewDistance * CHUNK_SIZE * 0.8));
                color.r = color.r * (1 - fogFactor) + 100 * fogFactor;
                color.g = color.g * (1 - fogFactor) + 149 * fogFactor;
                color.b = color.b * (1 - fogFactor) + 237 * fogFactor;

                ctx.beginPath();
                ctx.moveTo(cell.points[0].x, cell.points[0].y);
                for (let i = 1; i < 4; i++) {
                    ctx.lineTo(cell.points[i].x, cell.points[i].y);
                }
                ctx.closePath();

                ctx.fillStyle = `rgb(${Math.floor(color.r)}, ${Math.floor(color.g)}, ${Math.floor(color.b)})`;
                ctx.fill();
            }

            document.getElementById('posX').textContent = Math.floor(cameraX);
            document.getElementById('posZ').textContent = Math.floor(cameraZ);
            document.getElementById('chunks').textContent = chunks.size;
        }

        function update(dt) {
            if (!running) return;

            const moveSpeed = speed * 20 * dt;
            const rotSpeed = 1.5 * dt;

            let dx = 0, dz = 0;

            if (keys['ArrowUp'] || keys['KeyW']) dz = 1;
            if (keys['ArrowDown'] || keys['KeyS']) dz = -1;
            if (keys['ArrowLeft'] || keys['KeyA']) dx = -1;
            if (keys['ArrowRight'] || keys['KeyD']) dx = 1;
            if (keys['KeyQ']) cameraAngle -= rotSpeed;
            if (keys['KeyE']) cameraAngle += rotSpeed;

            // Move in camera direction
            const cos = Math.cos(cameraAngle);
            const sin = Math.sin(cameraAngle);

            cameraX += (dx * cos + dz * sin) * moveSpeed;
            cameraZ += (-dx * sin + dz * cos) * moveSpeed;

            // Auto forward movement
            if (!keys['ArrowUp'] && !keys['KeyW'] && !keys['ArrowDown'] && !keys['KeyS']) {
                cameraZ += cos * speed * 5 * dt;
                cameraX += sin * speed * 5 * dt;
            }

            // Cleanup old chunks occasionally
            if (Math.random() < 0.01) {
                cleanupChunks();
            }
        }

        // UI
        document.getElementById('speed').addEventListener('input', (e) => {
            speed = parseFloat(e.target.value);
            document.getElementById('speedVal').textContent = speed.toFixed(1);
        });

        document.getElementById('height').addEventListener('input', (e) => {
            heightScale = parseInt(e.target.value);
            document.getElementById('heightVal').textContent = heightScale;
        });

        document.getElementById('detail').addEventListener('input', (e) => {
            octaves = parseInt(e.target.value);
            document.getElementById('detailVal').textContent = octaves;
            chunks.clear();
        });

        document.getElementById('view').addEventListener('input', (e) => {
            viewDistance = parseInt(e.target.value);
            document.getElementById('viewVal').textContent = viewDistance;
        });

        document.getElementById('toggleBtn').addEventListener('click', function() {
            running = !running;
            this.textContent = running ? 'Pause' : 'Resume';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            cameraX = 0;
            cameraZ = 0;
            cameraAngle = 0;
            chunks.clear();
        });

        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        window.addEventListener('resize', resize);

        let lastTime = performance.now();
        let frameCount = 0;
        let fpsTime = 0;

        function animate() {
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            frameCount++;
            fpsTime += dt;
            if (fpsTime >= 1) {
                document.getElementById('fps').textContent = Math.round(frameCount / fpsTime);
                frameCount = 0;
                fpsTime = 0;
            }

            update(dt);
            draw();

            requestAnimationFrame(animate);
        }

        initNoise();
        resize();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
