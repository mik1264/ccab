<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Generator - Procedural Generation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas { display: block; width: 100vw; height: 100vh; }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            min-width: 280px;
        }
        h1 { font-size: 1.3em; margin-bottom: 5px; color: #ff9800; }
        .subtitle { font-size: 0.85em; color: #888; margin-bottom: 15px; }
        .slider-group { margin-bottom: 12px; }
        .slider-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.85em;
            color: #aaa;
        }
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #ff9800;
            border-radius: 50%;
            cursor: pointer;
        }
        .button-row { display: flex; gap: 10px; margin-top: 15px; }
        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: #ff9800;
            color: #000;
            cursor: pointer;
            font-weight: 600;
        }
        button:hover { background: #f57c00; }
        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
            font-size: 0.85em;
            color: #888;
        }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #ff9800;
            text-decoration: none;
            z-index: 100;
        }
        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 350px;
            font-size: 0.85em;
            color: #aaa;
            line-height: 1.5;
        }
        .info h3 { color: #ff9800; margin-bottom: 8px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>City Generator</h1>
        <p class="subtitle">Procedural Urban Layout</p>

        <div class="slider-group">
            <label>Grid Size <span id="sizeVal">20</span></label>
            <input type="range" id="size" min="10" max="40" step="2" value="20">
        </div>

        <div class="slider-group">
            <label>Block Size <span id="blockVal">3</span></label>
            <input type="range" id="block" min="2" max="6" step="1" value="3">
        </div>

        <div class="slider-group">
            <label>Building Density <span id="densityVal">70%</span></label>
            <input type="range" id="density" min="30" max="100" step="5" value="70">
        </div>

        <div class="slider-group">
            <label>Max Height <span id="heightVal">8</span></label>
            <input type="range" id="maxHeight" min="3" max="15" step="1" value="8">
        </div>

        <div class="slider-group">
            <label>View Angle <span id="angleVal">30°</span></label>
            <input type="range" id="angle" min="15" max="60" step="5" value="30">
        </div>

        <div class="button-row">
            <button id="generateBtn">Generate</button>
            <button id="nightBtn">Night Mode</button>
        </div>

        <div class="stats">
            <div>Buildings: <span id="buildings">0</span></div>
            <div>Blocks: <span id="blocks">0</span></div>
            <div>FPS: <span id="fps">0</span></div>
        </div>
    </div>

    <a href="index.html" class="back-link">← Back to Gallery</a>

    <div class="info">
        <h3>City Generation</h3>
        <p>An isometric city view with procedural building placement.
        Buildings are placed in city blocks separated by streets.
        Height varies based on distance from city center and noise.</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let gridSize = 20;
        let blockSize = 3;
        let buildingDensity = 70;
        let maxHeight = 8;
        let viewAngle = 30;
        let nightMode = false;
        let time = 0;

        let buildings = [];
        let seed = Math.random() * 10000;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = canvas.width;
            height = canvas.height;
            generate();
        }

        function seededRandom() {
            seed = (seed * 16807) % 2147483647;
            return (seed - 1) / 2147483646;
        }

        function generate() {
            buildings = [];
            seed = Math.random() * 10000;

            const cellSize = Math.min(width, height) / (gridSize + 4);
            const centerX = gridSize / 2;
            const centerY = gridSize / 2;

            let blockCount = 0;

            for (let bx = 0; bx < gridSize; bx += blockSize + 1) {
                for (let by = 0; by < gridSize; by += blockSize + 1) {
                    blockCount++;

                    // Generate buildings in this block
                    for (let x = bx; x < bx + blockSize && x < gridSize; x++) {
                        for (let y = by; y < by + blockSize && y < gridSize; y++) {
                            if (seededRandom() * 100 > buildingDensity) continue;

                            // Distance from center affects height
                            const dx = (x + 0.5 - centerX) / centerX;
                            const dy = (y + 0.5 - centerY) / centerY;
                            const distFromCenter = Math.sqrt(dx * dx + dy * dy);

                            // Downtown is taller
                            const heightMultiplier = 1 - distFromCenter * 0.6;
                            const buildingHeight = Math.ceil(1 + seededRandom() * maxHeight * heightMultiplier);

                            // Random width/depth variations
                            const widthVar = 0.7 + seededRandom() * 0.3;
                            const depthVar = 0.7 + seededRandom() * 0.3;

                            // Building color
                            const colorIndex = Math.floor(seededRandom() * 5);

                            buildings.push({
                                x, y,
                                w: widthVar,
                                d: depthVar,
                                h: buildingHeight,
                                colorIndex,
                                windows: seededRandom() > 0.3
                            });
                        }
                    }
                }
            }

            // Sort by depth for proper rendering
            buildings.sort((a, b) => (a.x + a.y) - (b.x + b.y));

            document.getElementById('buildings').textContent = buildings.length;
            document.getElementById('blocks').textContent = blockCount;
        }

        function getBuildingColor(colorIndex, face) {
            const colors = nightMode ? [
                [[30, 35, 45], [25, 30, 40], [20, 25, 35]],
                [[35, 40, 50], [30, 35, 45], [25, 30, 40]],
                [[40, 45, 55], [35, 40, 50], [30, 35, 45]],
                [[35, 38, 48], [30, 33, 43], [25, 28, 38]],
                [[45, 50, 60], [40, 45, 55], [35, 40, 50]]
            ] : [
                [[180, 180, 190], [140, 140, 150], [100, 100, 110]],
                [[200, 190, 180], [160, 150, 140], [120, 110, 100]],
                [[170, 185, 195], [130, 145, 155], [90, 105, 115]],
                [[190, 195, 185], [150, 155, 145], [110, 115, 105]],
                [[185, 180, 190], [145, 140, 150], [105, 100, 110]]
            ];

            const c = colors[colorIndex % colors.length][face];
            return `rgb(${c[0]}, ${c[1]}, ${c[2]})`;
        }

        function toIso(x, y, z) {
            const angle = viewAngle * Math.PI / 180;
            const cellSize = Math.min(width, height) / (gridSize + 8);

            const isoX = (x - y) * cellSize * Math.cos(angle);
            const isoY = (x + y) * cellSize * Math.sin(angle) - z * cellSize * 0.8;

            return {
                x: width / 2 + isoX,
                y: height / 2 + isoY + 100
            };
        }

        function draw() {
            // Background
            if (nightMode) {
                ctx.fillStyle = '#0a0a15';
                ctx.fillRect(0, 0, width, height);

                // Stars
                ctx.fillStyle = '#ffffff';
                for (let i = 0; i < 100; i++) {
                    const sx = (i * 137 + 50) % width;
                    const sy = (i * 73 + 30) % (height / 2);
                    ctx.beginPath();
                    ctx.arc(sx, sy, 0.5 + (i % 3) / 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else {
                ctx.fillStyle = '#87ceeb';
                ctx.fillRect(0, 0, width, height);

                // Sun
                ctx.beginPath();
                ctx.arc(width - 150, 100, 50, 0, Math.PI * 2);
                ctx.fillStyle = '#fff5d0';
                ctx.fill();
            }

            // Ground
            const groundColor = nightMode ? '#1a1a25' : '#4a5a40';
            const p1 = toIso(-2, -2, 0);
            const p2 = toIso(gridSize + 2, -2, 0);
            const p3 = toIso(gridSize + 2, gridSize + 2, 0);
            const p4 = toIso(-2, gridSize + 2, 0);

            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.lineTo(p4.x, p4.y);
            ctx.closePath();
            ctx.fillStyle = groundColor;
            ctx.fill();

            // Streets
            ctx.strokeStyle = nightMode ? '#2a2a35' : '#555555';
            ctx.lineWidth = 3;

            for (let i = 0; i <= gridSize; i += blockSize + 1) {
                // Horizontal streets
                const h1 = toIso(0, i, 0);
                const h2 = toIso(gridSize, i, 0);
                ctx.beginPath();
                ctx.moveTo(h1.x, h1.y);
                ctx.lineTo(h2.x, h2.y);
                ctx.stroke();

                // Vertical streets
                const v1 = toIso(i, 0, 0);
                const v2 = toIso(i, gridSize, 0);
                ctx.beginPath();
                ctx.moveTo(v1.x, v1.y);
                ctx.lineTo(v2.x, v2.y);
                ctx.stroke();
            }

            // Draw buildings
            for (const b of buildings) {
                const { x, y, w, h, d, colorIndex, windows } = b;

                // Building corners at ground
                const bl = toIso(x + (1 - w) / 2, y + (1 - d) / 2, 0);
                const br = toIso(x + (1 + w) / 2, y + (1 - d) / 2, 0);
                const fl = toIso(x + (1 - w) / 2, y + (1 + d) / 2, 0);
                const fr = toIso(x + (1 + w) / 2, y + (1 + d) / 2, 0);

                // Building corners at top
                const blT = toIso(x + (1 - w) / 2, y + (1 - d) / 2, h);
                const brT = toIso(x + (1 + w) / 2, y + (1 - d) / 2, h);
                const flT = toIso(x + (1 - w) / 2, y + (1 + d) / 2, h);
                const frT = toIso(x + (1 + w) / 2, y + (1 + d) / 2, h);

                // Left face
                ctx.beginPath();
                ctx.moveTo(fl.x, fl.y);
                ctx.lineTo(flT.x, flT.y);
                ctx.lineTo(blT.x, blT.y);
                ctx.lineTo(bl.x, bl.y);
                ctx.closePath();
                ctx.fillStyle = getBuildingColor(colorIndex, 1);
                ctx.fill();

                // Right face
                ctx.beginPath();
                ctx.moveTo(fr.x, fr.y);
                ctx.lineTo(frT.x, frT.y);
                ctx.lineTo(flT.x, flT.y);
                ctx.lineTo(fl.x, fl.y);
                ctx.closePath();
                ctx.fillStyle = getBuildingColor(colorIndex, 2);
                ctx.fill();

                // Top face
                ctx.beginPath();
                ctx.moveTo(blT.x, blT.y);
                ctx.lineTo(brT.x, brT.y);
                ctx.lineTo(frT.x, frT.y);
                ctx.lineTo(flT.x, flT.y);
                ctx.closePath();
                ctx.fillStyle = getBuildingColor(colorIndex, 0);
                ctx.fill();

                // Windows (in night mode, some are lit)
                if (windows && nightMode) {
                    const windowRows = Math.floor(h * 2);
                    for (let wy = 0; wy < windowRows; wy++) {
                        for (let wx = 0; wx < 2; wx++) {
                            if (seededRandom() > 0.6) {
                                const wh = (wy + 0.3) / (windowRows + 0.5) * h;
                                const ww = 0.2 + wx * 0.4;

                                const wp1 = toIso(x + ww, y + 0.95, wh);
                                const wp2 = toIso(x + ww + 0.15, y + 0.95, wh);
                                const wp3 = toIso(x + ww + 0.15, y + 0.95, wh + 0.3);
                                const wp4 = toIso(x + ww, y + 0.95, wh + 0.3);

                                ctx.beginPath();
                                ctx.moveTo(wp1.x, wp1.y);
                                ctx.lineTo(wp2.x, wp2.y);
                                ctx.lineTo(wp3.x, wp3.y);
                                ctx.lineTo(wp4.x, wp4.y);
                                ctx.closePath();
                                ctx.fillStyle = `rgba(255, 220, 150, ${0.6 + seededRandom() * 0.4})`;
                                ctx.fill();
                            }
                        }
                    }
                }
            }
        }

        // UI
        document.getElementById('size').addEventListener('input', (e) => {
            gridSize = parseInt(e.target.value);
            document.getElementById('sizeVal').textContent = gridSize;
            generate();
        });

        document.getElementById('block').addEventListener('input', (e) => {
            blockSize = parseInt(e.target.value);
            document.getElementById('blockVal').textContent = blockSize;
            generate();
        });

        document.getElementById('density').addEventListener('input', (e) => {
            buildingDensity = parseInt(e.target.value);
            document.getElementById('densityVal').textContent = buildingDensity + '%';
            generate();
        });

        document.getElementById('maxHeight').addEventListener('input', (e) => {
            maxHeight = parseInt(e.target.value);
            document.getElementById('heightVal').textContent = maxHeight;
            generate();
        });

        document.getElementById('angle').addEventListener('input', (e) => {
            viewAngle = parseInt(e.target.value);
            document.getElementById('angleVal').textContent = viewAngle + '°';
        });

        document.getElementById('generateBtn').addEventListener('click', generate);

        document.getElementById('nightBtn').addEventListener('click', function() {
            nightMode = !nightMode;
            this.textContent = nightMode ? 'Day Mode' : 'Night Mode';
        });

        window.addEventListener('resize', resize);

        let lastTime = performance.now();
        let frameCount = 0;
        let fpsTime = 0;

        function animate() {
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            frameCount++;
            fpsTime += dt;
            if (fpsTime >= 1) {
                document.getElementById('fps').textContent = Math.round(frameCount / fpsTime);
                frameCount = 0;
                fpsTime = 0;
            }

            time += dt;
            draw();

            requestAnimationFrame(animate);
        }

        resize();
        animate();
    </script>
</body>
</html>
