<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Terrain Generator - Procedural Generation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas { display: block; width: 100vw; height: 100vh; }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            min-width: 280px;
        }
        h1 { font-size: 1.3em; margin-bottom: 5px; color: #66bb6a; }
        .subtitle { font-size: 0.85em; color: #888; margin-bottom: 15px; }
        .slider-group { margin-bottom: 12px; }
        .slider-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.85em;
            color: #aaa;
        }
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #66bb6a;
            border-radius: 50%;
            cursor: pointer;
        }
        .button-row { display: flex; gap: 10px; margin-top: 15px; }
        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: #66bb6a;
            color: #000;
            cursor: pointer;
            font-weight: 600;
        }
        button:hover { background: #4caf50; }
        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
            font-size: 0.85em;
            color: #888;
        }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #66bb6a;
            text-decoration: none;
            z-index: 100;
        }
        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 350px;
            font-size: 0.85em;
            color: #aaa;
            line-height: 1.5;
        }
        .info h3 { color: #66bb6a; margin-bottom: 8px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>3D Terrain</h1>
        <p class="subtitle">Noise-Based Heightmap</p>

        <div class="slider-group">
            <label>Height Scale <span id="heightVal">150</span></label>
            <input type="range" id="height" min="50" max="300" step="10" value="150">
        </div>

        <div class="slider-group">
            <label>Detail (Octaves) <span id="octavesVal">6</span></label>
            <input type="range" id="octaves" min="1" max="8" step="1" value="6">
        </div>

        <div class="slider-group">
            <label>Roughness <span id="roughnessVal">0.5</span></label>
            <input type="range" id="roughness" min="0.3" max="0.8" step="0.05" value="0.5">
        </div>

        <div class="slider-group">
            <label>Water Level <span id="waterVal">0.35</span></label>
            <input type="range" id="water" min="0" max="0.6" step="0.05" value="0.35">
        </div>

        <div class="slider-group">
            <label>Rotation Speed <span id="rotVal">0.5</span></label>
            <input type="range" id="rotation" min="0" max="2" step="0.1" value="0.5">
        </div>

        <div class="button-row">
            <button id="generateBtn">New Terrain</button>
            <button id="wireframeBtn">Wireframe</button>
        </div>

        <div class="stats">
            <div>Vertices: <span id="vertices">0</span></div>
            <div>FPS: <span id="fps">0</span></div>
        </div>
    </div>

    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="info">
        <h3>Procedural Terrain</h3>
        <p>A 3D terrain mesh generated from layered Perlin noise (FBM).
        Heights are colored by biome: water, sand, grass, rock, and snow.
        The mesh is rendered with simple perspective projection.</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let heightScale = 150;
        let octaves = 6;
        let roughness = 0.5;
        let waterLevel = 0.35;
        let rotationSpeed = 0.5;
        let wireframe = false;
        let time = 0;
        let seed = Math.random() * 10000;

        const GRID_SIZE = 80;
        let heightmap = [];
        let vertices = [];

        // Noise
        const p = new Uint8Array(512);

        function initNoise(s) {
            const perm = new Uint8Array(256);
            for (let i = 0; i < 256; i++) perm[i] = i;

            for (let i = 255; i > 0; i--) {
                s = (s * 16807) % 2147483647;
                const j = s % (i + 1);
                [perm[i], perm[j]] = [perm[j], perm[i]];
            }

            for (let i = 0; i < 512; i++) p[i] = perm[i & 255];
        }

        function noise(x, y) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            x -= Math.floor(x);
            y -= Math.floor(y);

            const u = x * x * x * (x * (x * 6 - 15) + 10);
            const v = y * y * y * (y * (y * 6 - 15) + 10);

            const A = p[X] + Y;
            const B = p[X + 1] + Y;

            function grad(h, x, y) {
                h = h & 3;
                return ((h & 1) ? -x : x) + ((h & 2) ? -y : y);
            }

            const lerp = (a, b, t) => a + t * (b - a);

            return lerp(
                lerp(grad(p[A], x, y), grad(p[B], x - 1, y), u),
                lerp(grad(p[A + 1], x, y - 1), grad(p[B + 1], x - 1, y - 1), u),
                v
            );
        }

        function fbm(x, y) {
            let value = 0;
            let amplitude = 1;
            let frequency = 1;
            let maxValue = 0;

            for (let i = 0; i < octaves; i++) {
                value += amplitude * noise(x * frequency, y * frequency);
                maxValue += amplitude;
                amplitude *= roughness;
                frequency *= 2;
            }

            return (value / maxValue + 1) / 2;
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = canvas.width;
            height = canvas.height;
        }

        function generateTerrain() {
            heightmap = [];
            vertices = [];

            for (let y = 0; y <= GRID_SIZE; y++) {
                heightmap[y] = [];
                for (let x = 0; x <= GRID_SIZE; x++) {
                    const nx = x / GRID_SIZE * 4;
                    const ny = y / GRID_SIZE * 4;
                    heightmap[y][x] = fbm(nx, ny);
                }
            }

            // Create vertex list
            const size = 300;
            for (let y = 0; y <= GRID_SIZE; y++) {
                for (let x = 0; x <= GRID_SIZE; x++) {
                    const h = heightmap[y][x];
                    vertices.push({
                        x: (x / GRID_SIZE - 0.5) * size,
                        y: (h - 0.5) * heightScale,
                        z: (y / GRID_SIZE - 0.5) * size,
                        h: h
                    });
                }
            }

            document.getElementById('vertices').textContent = vertices.length;
        }

        function getTerrainColor(h) {
            if (h < waterLevel) {
                // Water
                const depth = h / waterLevel;
                return `rgb(${30 + depth * 20}, ${80 + depth * 50}, ${150 + depth * 50})`;
            } else if (h < waterLevel + 0.05) {
                // Sand
                return '#d4b896';
            } else if (h < 0.5) {
                // Grass
                const t = (h - waterLevel - 0.05) / (0.5 - waterLevel - 0.05);
                return `rgb(${60 - t * 20}, ${140 - t * 20}, ${60 - t * 20})`;
            } else if (h < 0.75) {
                // Rock
                const t = (h - 0.5) / 0.25;
                const gray = 80 + t * 40;
                return `rgb(${gray}, ${gray - 10}, ${gray - 20})`;
            } else {
                // Snow
                const t = (h - 0.75) / 0.25;
                const white = 200 + t * 55;
                return `rgb(${white}, ${white}, ${white + 5})`;
            }
        }

        function project(x, y, z, rotY) {
            // Rotate around Y axis
            const cosR = Math.cos(rotY);
            const sinR = Math.sin(rotY);
            const rx = x * cosR - z * sinR;
            const rz = x * sinR + z * cosR;

            // Simple perspective projection
            const fov = 400;
            const distance = 500;
            const scale = fov / (rz + distance);

            return {
                x: width / 2 + rx * scale,
                y: height / 2 - y * scale + 100,
                z: rz
            };
        }

        function draw() {
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, width, height);

            const rotY = time * rotationSpeed;

            // Draw terrain as quads, back to front
            const quads = [];

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const i00 = y * (GRID_SIZE + 1) + x;
                    const i10 = i00 + 1;
                    const i01 = i00 + GRID_SIZE + 1;
                    const i11 = i01 + 1;

                    const v00 = vertices[i00];
                    const v10 = vertices[i10];
                    const v01 = vertices[i01];
                    const v11 = vertices[i11];

                    const p00 = project(v00.x, v00.y, v00.z, rotY);
                    const p10 = project(v10.x, v10.y, v10.z, rotY);
                    const p01 = project(v01.x, v01.y, v01.z, rotY);
                    const p11 = project(v11.x, v11.y, v11.z, rotY);

                    const avgZ = (p00.z + p10.z + p01.z + p11.z) / 4;
                    const avgH = (v00.h + v10.h + v01.h + v11.h) / 4;

                    quads.push({
                        points: [p00, p10, p11, p01],
                        z: avgZ,
                        h: avgH
                    });
                }
            }

            // Sort by Z (painter's algorithm)
            quads.sort((a, b) => b.z - a.z);

            // Draw quads
            for (const quad of quads) {
                ctx.beginPath();
                ctx.moveTo(quad.points[0].x, quad.points[0].y);
                for (let i = 1; i < 4; i++) {
                    ctx.lineTo(quad.points[i].x, quad.points[i].y);
                }
                ctx.closePath();

                if (wireframe) {
                    ctx.strokeStyle = getTerrainColor(quad.h);
                    ctx.lineWidth = 1;
                    ctx.stroke();
                } else {
                    // Simple shading
                    ctx.fillStyle = getTerrainColor(quad.h);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }

            // Draw water plane
            if (!wireframe && waterLevel > 0) {
                const waterY = (waterLevel - 0.5) * heightScale;
                const corners = [
                    project(-150, waterY, -150, rotY),
                    project(150, waterY, -150, rotY),
                    project(150, waterY, 150, rotY),
                    project(-150, waterY, 150, rotY)
                ];

                ctx.beginPath();
                ctx.moveTo(corners[0].x, corners[0].y);
                for (let i = 1; i < 4; i++) {
                    ctx.lineTo(corners[i].x, corners[i].y);
                }
                ctx.closePath();
                ctx.fillStyle = 'rgba(50, 120, 180, 0.6)';
                ctx.fill();
            }
        }

        // UI
        document.getElementById('height').addEventListener('input', (e) => {
            heightScale = parseInt(e.target.value);
            document.getElementById('heightVal').textContent = heightScale;
            generateTerrain();
        });

        document.getElementById('octaves').addEventListener('input', (e) => {
            octaves = parseInt(e.target.value);
            document.getElementById('octavesVal').textContent = octaves;
            generateTerrain();
        });

        document.getElementById('roughness').addEventListener('input', (e) => {
            roughness = parseFloat(e.target.value);
            document.getElementById('roughnessVal').textContent = roughness.toFixed(2);
            generateTerrain();
        });

        document.getElementById('water').addEventListener('input', (e) => {
            waterLevel = parseFloat(e.target.value);
            document.getElementById('waterVal').textContent = waterLevel.toFixed(2);
        });

        document.getElementById('rotation').addEventListener('input', (e) => {
            rotationSpeed = parseFloat(e.target.value);
            document.getElementById('rotVal').textContent = rotationSpeed.toFixed(1);
        });

        document.getElementById('generateBtn').addEventListener('click', () => {
            seed = Math.random() * 10000;
            initNoise(seed);
            generateTerrain();
        });

        document.getElementById('wireframeBtn').addEventListener('click', function() {
            wireframe = !wireframe;
            this.textContent = wireframe ? 'Solid' : 'Wireframe';
        });

        window.addEventListener('resize', resize);

        let lastTime = performance.now();
        let frameCount = 0;
        let fpsTime = 0;

        function animate() {
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            frameCount++;
            fpsTime += dt;
            if (fpsTime >= 1) {
                document.getElementById('fps').textContent = Math.round(frameCount / fpsTime);
                frameCount = 0;
                fpsTime = 0;
            }

            time += dt;
            draw();

            requestAnimationFrame(animate);
        }

        initNoise(seed);
        resize();
        generateTerrain();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
