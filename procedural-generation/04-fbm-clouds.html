<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBM Clouds - Procedural Generation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas { display: block; width: 100vw; height: 100vh; }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            min-width: 280px;
        }
        h1 { font-size: 1.3em; margin-bottom: 5px; color: #64b5f6; }
        .subtitle { font-size: 0.85em; color: #888; margin-bottom: 15px; }
        .slider-group { margin-bottom: 12px; }
        .slider-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.85em;
            color: #aaa;
        }
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #64b5f6;
            border-radius: 50%;
            cursor: pointer;
        }
        .presets {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        .preset-btn {
            padding: 6px 10px;
            background: #222;
            border: 1px solid #444;
            border-radius: 6px;
            color: #aaa;
            font-size: 0.75em;
            cursor: pointer;
        }
        .preset-btn:hover, .preset-btn.active {
            background: #333;
            border-color: #64b5f6;
            color: #fff;
        }
        .button-row { display: flex; gap: 10px; margin-top: 15px; }
        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: #64b5f6;
            color: #000;
            cursor: pointer;
            font-weight: 600;
        }
        button:hover { background: #42a5f5; }
        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
            font-size: 0.85em;
            color: #888;
        }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #64b5f6;
            text-decoration: none;
            z-index: 100;
        }
        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 350px;
            font-size: 0.85em;
            color: #aaa;
            line-height: 1.5;
        }
        .info h3 { color: #64b5f6; margin-bottom: 8px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>FBM Clouds</h1>
        <p class="subtitle">Fractal Brownian Motion</p>

        <div class="slider-group">
            <label>Scale <span id="scaleVal">100</span></label>
            <input type="range" id="scale" min="30" max="300" step="10" value="100">
        </div>

        <div class="slider-group">
            <label>Octaves <span id="octavesVal">6</span></label>
            <input type="range" id="octaves" min="1" max="10" step="1" value="6">
        </div>

        <div class="slider-group">
            <label>Gain <span id="gainVal">0.5</span></label>
            <input type="range" id="gain" min="0.2" max="0.8" step="0.05" value="0.5">
        </div>

        <div class="slider-group">
            <label>Lacunarity <span id="lacVal">2.0</span></label>
            <input type="range" id="lacunarity" min="1.5" max="3" step="0.1" value="2.0">
        </div>

        <div class="slider-group">
            <label>Wind Speed <span id="windVal">1.0</span></label>
            <input type="range" id="wind" min="0" max="3" step="0.1" value="1.0">
        </div>

        <div class="presets">
            <span class="preset-btn active" data-preset="cumulus">Cumulus</span>
            <span class="preset-btn" data-preset="stratus">Stratus</span>
            <span class="preset-btn" data-preset="cirrus">Cirrus</span>
            <span class="preset-btn" data-preset="storm">Storm</span>
            <span class="preset-btn" data-preset="sunset">Sunset</span>
        </div>

        <div class="button-row">
            <button id="regenerateBtn">New Seed</button>
        </div>

        <div class="stats">
            <div>Coverage: <span id="coverage">0%</span></div>
            <div>FPS: <span id="fps">0</span></div>
        </div>
    </div>

    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="info">
        <h3>Fractal Brownian Motion</h3>
        <p>FBM layers multiple octaves of noise at different frequencies and amplitudes
        to create complex, natural-looking patterns. Each octave adds finer detail.
        The "gain" controls amplitude decay, "lacunarity" controls frequency increase.</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let scale = 100;
        let octaves = 6;
        let gain = 0.5;
        let lacunarity = 2.0;
        let windSpeed = 1.0;
        let preset = 'cumulus';
        let time = 0;
        let seed = Math.random() * 10000;

        // Simplex-like noise
        const p = new Uint8Array(512);

        function initNoise(s) {
            const perm = new Uint8Array(256);
            for (let i = 0; i < 256; i++) perm[i] = i;

            for (let i = 255; i > 0; i--) {
                s = (s * 16807) % 2147483647;
                const j = s % (i + 1);
                [perm[i], perm[j]] = [perm[j], perm[i]];
            }

            for (let i = 0; i < 512; i++) p[i] = perm[i & 255];
        }

        function noise(x, y) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            x -= Math.floor(x);
            y -= Math.floor(y);

            const u = x * x * x * (x * (x * 6 - 15) + 10);
            const v = y * y * y * (y * (y * 6 - 15) + 10);

            const A = p[X] + Y;
            const B = p[X + 1] + Y;

            function grad(h, x, y) {
                h = h & 3;
                const u = h < 2 ? x : y;
                const v = h < 2 ? y : x;
                return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
            }

            const lerp = (a, b, t) => a + t * (b - a);

            return lerp(
                lerp(grad(p[A], x, y), grad(p[B], x - 1, y), u),
                lerp(grad(p[A + 1], x, y - 1), grad(p[B + 1], x - 1, y - 1), u),
                v
            );
        }

        function fbm(x, y, oct, g, lac) {
            let value = 0;
            let amplitude = 1;
            let frequency = 1;
            let maxValue = 0;

            for (let i = 0; i < oct; i++) {
                value += amplitude * noise(x * frequency, y * frequency);
                maxValue += amplitude;
                amplitude *= g;
                frequency *= lac;
            }

            return value / maxValue;
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = canvas.width;
            height = canvas.height;
        }

        function getPresetColors() {
            switch (preset) {
                case 'cumulus':
                    return {
                        sky: [135, 206, 250],
                        cloud: [255, 255, 255],
                        shadow: [180, 180, 200],
                        threshold: 0.3
                    };
                case 'stratus':
                    return {
                        sky: [100, 140, 180],
                        cloud: [220, 220, 230],
                        shadow: [150, 150, 170],
                        threshold: 0.2
                    };
                case 'cirrus':
                    return {
                        sky: [100, 180, 255],
                        cloud: [255, 255, 255],
                        shadow: [200, 220, 255],
                        threshold: 0.5
                    };
                case 'storm':
                    return {
                        sky: [40, 50, 70],
                        cloud: [100, 100, 120],
                        shadow: [30, 30, 50],
                        threshold: 0.15
                    };
                case 'sunset':
                    return {
                        sky: [255, 150, 100],
                        cloud: [255, 200, 150],
                        shadow: [200, 100, 80],
                        threshold: 0.3
                    };
                default:
                    return {
                        sky: [135, 206, 250],
                        cloud: [255, 255, 255],
                        shadow: [180, 180, 200],
                        threshold: 0.3
                    };
            }
        }

        function draw() {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            const colors = getPresetColors();
            let cloudPixels = 0;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // Base cloud noise
                    const nx = (x + time * 50 * windSpeed) / scale;
                    const ny = y / scale;

                    let cloudValue = fbm(nx, ny, octaves, gain, lacunarity);

                    // Add secondary movement layer
                    const nx2 = (x + time * 30 * windSpeed) / (scale * 2);
                    const ny2 = (y + time * 10) / (scale * 2);
                    cloudValue += fbm(nx2, ny2, 3, 0.5, 2.0) * 0.3;

                    // Normalize
                    cloudValue = (cloudValue + 1) / 2;

                    // Apply threshold for cloud density
                    const cloudDensity = Math.max(0, (cloudValue - colors.threshold) / (1 - colors.threshold));

                    if (cloudDensity > 0) cloudPixels++;

                    // Calculate lighting (simple gradient from top-left)
                    const lightValue = 1 - cloudDensity * 0.3;

                    let r, g, b;

                    if (cloudDensity > 0) {
                        // Cloud coloring with shadows
                        const shadowAmount = 1 - lightValue;
                        r = Math.floor(colors.cloud[0] * lightValue + colors.shadow[0] * shadowAmount);
                        g = Math.floor(colors.cloud[1] * lightValue + colors.shadow[1] * shadowAmount);
                        b = Math.floor(colors.cloud[2] * lightValue + colors.shadow[2] * shadowAmount);

                        // Blend with sky based on density
                        const alpha = Math.min(1, cloudDensity * 2);
                        r = Math.floor(r * alpha + colors.sky[0] * (1 - alpha));
                        g = Math.floor(g * alpha + colors.sky[1] * (1 - alpha));
                        b = Math.floor(b * alpha + colors.sky[2] * (1 - alpha));
                    } else {
                        // Sky gradient
                        const skyGradient = y / height;
                        r = Math.floor(colors.sky[0] * (1 - skyGradient * 0.3));
                        g = Math.floor(colors.sky[1] * (1 - skyGradient * 0.2));
                        b = Math.floor(colors.sky[2] * (1 - skyGradient * 0.1));
                    }

                    const idx = (y * width + x) * 4;
                    data[idx] = Math.min(255, Math.max(0, r));
                    data[idx + 1] = Math.min(255, Math.max(0, g));
                    data[idx + 2] = Math.min(255, Math.max(0, b));
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);

            document.getElementById('coverage').textContent =
                Math.round(cloudPixels / (width * height) * 100) + '%';
        }

        const presets = {
            cumulus: { scale: 100, octaves: 6, gain: 0.5, lacunarity: 2.0 },
            stratus: { scale: 200, octaves: 4, gain: 0.6, lacunarity: 1.8 },
            cirrus: { scale: 150, octaves: 8, gain: 0.4, lacunarity: 2.2 },
            storm: { scale: 80, octaves: 7, gain: 0.55, lacunarity: 2.0 },
            sunset: { scale: 120, octaves: 5, gain: 0.5, lacunarity: 2.0 }
        };

        // UI
        document.getElementById('scale').addEventListener('input', (e) => {
            scale = parseInt(e.target.value);
            document.getElementById('scaleVal').textContent = scale;
        });

        document.getElementById('octaves').addEventListener('input', (e) => {
            octaves = parseInt(e.target.value);
            document.getElementById('octavesVal').textContent = octaves;
        });

        document.getElementById('gain').addEventListener('input', (e) => {
            gain = parseFloat(e.target.value);
            document.getElementById('gainVal').textContent = gain.toFixed(2);
        });

        document.getElementById('lacunarity').addEventListener('input', (e) => {
            lacunarity = parseFloat(e.target.value);
            document.getElementById('lacVal').textContent = lacunarity.toFixed(1);
        });

        document.getElementById('wind').addEventListener('input', (e) => {
            windSpeed = parseFloat(e.target.value);
            document.getElementById('windVal').textContent = windSpeed.toFixed(1);
        });

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                preset = btn.dataset.preset;

                const p = presets[preset];
                scale = p.scale;
                octaves = p.octaves;
                gain = p.gain;
                lacunarity = p.lacunarity;

                document.getElementById('scale').value = scale;
                document.getElementById('octaves').value = octaves;
                document.getElementById('gain').value = gain;
                document.getElementById('lacunarity').value = lacunarity;

                document.getElementById('scaleVal').textContent = scale;
                document.getElementById('octavesVal').textContent = octaves;
                document.getElementById('gainVal').textContent = gain.toFixed(2);
                document.getElementById('lacVal').textContent = lacunarity.toFixed(1);
            });
        });

        document.getElementById('regenerateBtn').addEventListener('click', () => {
            seed = Math.random() * 10000;
            initNoise(seed);
        });

        window.addEventListener('resize', resize);

        let lastTime = performance.now();
        let frameCount = 0;
        let fpsTime = 0;

        function animate() {
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            frameCount++;
            fpsTime += dt;
            if (fpsTime >= 1) {
                document.getElementById('fps').textContent = Math.round(frameCount / fpsTime);
                frameCount = 0;
                fpsTime = 0;
            }

            time += dt;
            draw();

            requestAnimationFrame(animate);
        }

        initNoise(seed);
        resize();
        animate();
    </script>
</body>
</html>
