<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree Generator - Procedural Generation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(to bottom, #87ceeb 0%, #e0f0ff 100%);
            color: #333;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas { display: block; width: 100vw; height: 100vh; }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.9);
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            min-width: 280px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        h1 { font-size: 1.3em; margin-bottom: 5px; color: #4a7c23; }
        .subtitle { font-size: 0.85em; color: #888; margin-bottom: 15px; }
        .slider-group { margin-bottom: 12px; }
        .slider-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.85em;
            color: #666;
        }
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #ddd;
            border-radius: 3px;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #4a7c23;
            border-radius: 50%;
            cursor: pointer;
        }
        .tree-types {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        .type-btn {
            padding: 6px 10px;
            background: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 6px;
            color: #666;
            font-size: 0.75em;
            cursor: pointer;
        }
        .type-btn:hover, .type-btn.active {
            background: #e8f5e9;
            border-color: #4a7c23;
            color: #4a7c23;
        }
        .button-row { display: flex; gap: 10px; margin-top: 15px; }
        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: #4a7c23;
            color: #fff;
            cursor: pointer;
            font-weight: 600;
        }
        button:hover { background: #3d6a1d; }
        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
            font-size: 0.85em;
            color: #888;
        }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #4a7c23;
            text-decoration: none;
            z-index: 100;
        }
        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: 8px;
            max-width: 350px;
            font-size: 0.85em;
            color: #666;
            line-height: 1.5;
        }
        .info h3 { color: #4a7c23; margin-bottom: 8px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>Tree Generator</h1>
        <p class="subtitle">Space Colonization Algorithm</p>

        <div class="slider-group">
            <label>Branches <span id="branchesVal">200</span></label>
            <input type="range" id="branches" min="50" max="500" step="25" value="200">
        </div>

        <div class="slider-group">
            <label>Branch Angle <span id="angleVal">25°</span></label>
            <input type="range" id="angle" min="10" max="45" step="5" value="25">
        </div>

        <div class="slider-group">
            <label>Trunk Height <span id="trunkVal">0.3</span></label>
            <input type="range" id="trunk" min="0.1" max="0.5" step="0.05" value="0.3">
        </div>

        <div class="slider-group">
            <label>Leaf Density <span id="leafVal">150</span></label>
            <input type="range" id="leaves" min="50" max="400" step="25" value="150">
        </div>

        <div class="tree-types">
            <span class="type-btn active" data-type="oak">Oak</span>
            <span class="type-btn" data-type="pine">Pine</span>
            <span class="type-btn" data-type="willow">Willow</span>
            <span class="type-btn" data-type="cherry">Cherry</span>
        </div>

        <div class="button-row">
            <button id="generateBtn">New Tree</button>
            <button id="animateBtn">Animate</button>
        </div>

        <div class="stats">
            <div>Segments: <span id="segments">0</span></div>
            <div>Leaves: <span id="leafCount">0</span></div>
        </div>
    </div>

    <a href="index.html" class="back-link">← Back to Gallery</a>

    <div class="info">
        <h3>Tree Generation</h3>
        <p>Uses recursive branching with randomized angles and lengths.
        Each branch splits into smaller branches, creating natural-looking
        tree structures. Different tree types have unique characteristics.</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let maxBranches = 200;
        let branchAngle = 25;
        let trunkHeight = 0.3;
        let leafDensity = 150;
        let treeType = 'oak';
        let animating = false;
        let animProgress = 0;

        let branches = [];
        let leaves = [];
        let seed = Math.random() * 10000;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = canvas.width;
            height = canvas.height;
            generate();
        }

        function seededRandom() {
            seed = (seed * 16807) % 2147483647;
            return (seed - 1) / 2147483646;
        }

        function getTreeParams() {
            switch (treeType) {
                case 'oak':
                    return {
                        branchDecay: 0.7,
                        angleVariation: 15,
                        branchChance: 0.85,
                        leafColor: '#4a8c23',
                        leafSize: [8, 15],
                        leafShape: 'circle'
                    };
                case 'pine':
                    return {
                        branchDecay: 0.65,
                        angleVariation: 8,
                        branchChance: 0.75,
                        leafColor: '#2d5a1e',
                        leafSize: [5, 10],
                        leafShape: 'needle'
                    };
                case 'willow':
                    return {
                        branchDecay: 0.8,
                        angleVariation: 25,
                        branchChance: 0.9,
                        leafColor: '#6b9b37',
                        leafSize: [4, 8],
                        leafShape: 'drop'
                    };
                case 'cherry':
                    return {
                        branchDecay: 0.72,
                        angleVariation: 20,
                        branchChance: 0.8,
                        leafColor: '#ffb7c5',
                        leafSize: [6, 12],
                        leafShape: 'petal'
                    };
                default:
                    return getTreeParams();
            }
        }

        function generateBranch(x, y, angle, length, depth, maxDepth) {
            if (depth > maxDepth || length < 3 || branches.length > maxBranches) return;

            const params = getTreeParams();

            const endX = x + Math.sin(angle) * length;
            const endY = y - Math.cos(angle) * length;

            branches.push({
                x1: x, y1: y,
                x2: endX, y2: endY,
                depth,
                width: Math.max(1, (maxDepth - depth) * 2)
            });

            // Add leaves at branch ends
            if (depth > maxDepth * 0.5) {
                const leafCount = Math.floor(1 + seededRandom() * 3);
                for (let i = 0; i < leafCount; i++) {
                    const leafAngle = seededRandom() * Math.PI * 2;
                    const leafDist = seededRandom() * 15;
                    leaves.push({
                        x: endX + Math.cos(leafAngle) * leafDist,
                        y: endY + Math.sin(leafAngle) * leafDist,
                        size: params.leafSize[0] + seededRandom() * (params.leafSize[1] - params.leafSize[0]),
                        rotation: seededRandom() * Math.PI * 2
                    });
                }
            }

            // Generate child branches
            const newLength = length * params.branchDecay * (0.8 + seededRandom() * 0.4);

            if (seededRandom() < params.branchChance) {
                const leftAngle = angle - (branchAngle + seededRandom() * params.angleVariation) * Math.PI / 180;
                generateBranch(endX, endY, leftAngle, newLength, depth + 1, maxDepth);
            }

            if (seededRandom() < params.branchChance) {
                const rightAngle = angle + (branchAngle + seededRandom() * params.angleVariation) * Math.PI / 180;
                generateBranch(endX, endY, rightAngle, newLength, depth + 1, maxDepth);
            }

            // Sometimes add a middle branch
            if (seededRandom() < 0.3) {
                const midAngle = angle + (seededRandom() - 0.5) * 0.3;
                generateBranch(endX, endY, midAngle, newLength * 0.8, depth + 1, maxDepth);
            }
        }

        function generate() {
            branches = [];
            leaves = [];
            seed = Math.random() * 10000;

            const startX = width / 2;
            const startY = height - 50;
            const initialLength = height * trunkHeight;

            // Calculate max depth based on branch count
            const maxDepth = Math.floor(Math.log2(maxBranches / 2)) + 1;

            generateBranch(startX, startY, 0, initialLength, 0, maxDepth);

            // Limit leaves based on density
            if (leaves.length > leafDensity) {
                leaves = leaves.slice(0, leafDensity);
            }

            document.getElementById('segments').textContent = branches.length;
            document.getElementById('leafCount').textContent = leaves.length;

            if (!animating) animProgress = 1;
        }

        function drawLeaf(x, y, size, rotation) {
            const params = getTreeParams();

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);

            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            gradient.addColorStop(0, params.leafColor);
            gradient.addColorStop(1, shadeColor(params.leafColor, -20));

            ctx.fillStyle = gradient;

            switch (params.leafShape) {
                case 'circle':
                    ctx.beginPath();
                    ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'needle':
                    ctx.beginPath();
                    ctx.ellipse(0, 0, size / 6, size, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'drop':
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.quadraticCurveTo(size / 2, 0, 0, size);
                    ctx.quadraticCurveTo(-size / 2, 0, 0, -size);
                    ctx.fill();
                    break;

                case 'petal':
                    ctx.beginPath();
                    ctx.ellipse(0, 0, size / 2, size / 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Center
                    ctx.fillStyle = '#ffeb3b';
                    ctx.beginPath();
                    ctx.arc(0, 0, size / 6, 0, Math.PI * 2);
                    ctx.fill();
                    break;
            }

            ctx.restore();
        }

        function shadeColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const r = Math.min(255, Math.max(0, (num >> 16) + percent));
            const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + percent));
            const b = Math.min(255, Math.max(0, (num & 0x0000FF) + percent));
            return '#' + (0x1000000 + r * 0x10000 + g * 0x100 + b).toString(16).slice(1);
        }

        function draw() {
            // Sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, height);
            skyGradient.addColorStop(0, '#87ceeb');
            skyGradient.addColorStop(1, '#e0f7fa');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, width, height);

            // Ground
            ctx.fillStyle = '#5d7a3a';
            ctx.fillRect(0, height - 50, width, 50);

            // Grass texture
            ctx.strokeStyle = '#4a6830';
            for (let i = 0; i < width; i += 8) {
                const grassHeight = 10 + seededRandom() * 20;
                ctx.beginPath();
                ctx.moveTo(i, height - 50);
                ctx.lineTo(i + seededRandom() * 5, height - 50 - grassHeight);
                ctx.stroke();
            }

            // Draw branches up to animation progress
            const branchesToDraw = Math.floor(branches.length * animProgress);

            for (let i = 0; i < branchesToDraw; i++) {
                const b = branches[i];

                // Bark gradient
                const barkGradient = ctx.createLinearGradient(b.x1, b.y1, b.x2, b.y2);
                barkGradient.addColorStop(0, '#5d4037');
                barkGradient.addColorStop(0.5, '#795548');
                barkGradient.addColorStop(1, '#4e342e');

                ctx.strokeStyle = barkGradient;
                ctx.lineWidth = b.width;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(b.x1, b.y1);
                ctx.lineTo(b.x2, b.y2);
                ctx.stroke();
            }

            // Draw leaves
            const leavesToDraw = Math.floor(leaves.length * Math.max(0, animProgress * 1.5 - 0.5));

            for (let i = 0; i < leavesToDraw; i++) {
                const l = leaves[i];
                drawLeaf(l.x, l.y, l.size, l.rotation);
            }
        }

        // UI
        document.getElementById('branches').addEventListener('input', (e) => {
            maxBranches = parseInt(e.target.value);
            document.getElementById('branchesVal').textContent = maxBranches;
            generate();
        });

        document.getElementById('angle').addEventListener('input', (e) => {
            branchAngle = parseInt(e.target.value);
            document.getElementById('angleVal').textContent = branchAngle + '°';
            generate();
        });

        document.getElementById('trunk').addEventListener('input', (e) => {
            trunkHeight = parseFloat(e.target.value);
            document.getElementById('trunkVal').textContent = trunkHeight.toFixed(2);
            generate();
        });

        document.getElementById('leaves').addEventListener('input', (e) => {
            leafDensity = parseInt(e.target.value);
            document.getElementById('leafVal').textContent = leafDensity;
            generate();
        });

        document.querySelectorAll('.type-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.type-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                treeType = btn.dataset.type;
                generate();
            });
        });

        document.getElementById('generateBtn').addEventListener('click', generate);

        document.getElementById('animateBtn').addEventListener('click', function() {
            animating = !animating;
            this.textContent = animating ? 'Stop' : 'Animate';
            if (animating) {
                animProgress = 0;
            }
        });

        window.addEventListener('resize', resize);

        function animate() {
            if (animating && animProgress < 1) {
                animProgress += 0.01;
            }

            draw();
            requestAnimationFrame(animate);
        }

        resize();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
