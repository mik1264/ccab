<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Generator - Procedural Generation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas { display: block; width: 100vw; height: 100vh; }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            min-width: 280px;
        }
        h1 { font-size: 1.3em; margin-bottom: 5px; color: #8bc34a; }
        .subtitle { font-size: 0.85em; color: #888; margin-bottom: 15px; }
        .slider-group { margin-bottom: 12px; }
        .slider-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.85em;
            color: #aaa;
        }
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #8bc34a;
            border-radius: 50%;
            cursor: pointer;
        }
        .methods {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        .method-btn {
            padding: 6px 10px;
            background: #222;
            border: 1px solid #444;
            border-radius: 6px;
            color: #aaa;
            font-size: 0.75em;
            cursor: pointer;
        }
        .method-btn:hover, .method-btn.active {
            background: #333;
            border-color: #8bc34a;
            color: #fff;
        }
        .button-row { display: flex; gap: 10px; margin-top: 15px; }
        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: #8bc34a;
            color: #000;
            cursor: pointer;
            font-weight: 600;
        }
        button:hover { background: #7cb342; }
        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
            font-size: 0.85em;
            color: #888;
        }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #8bc34a;
            text-decoration: none;
            z-index: 100;
        }
        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 350px;
            font-size: 0.85em;
            color: #aaa;
            line-height: 1.5;
        }
        .info h3 { color: #8bc34a; margin-bottom: 8px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>Dungeon Generator</h1>
        <p class="subtitle">Procedural Level Design</p>

        <div class="slider-group">
            <label>Room Count <span id="roomsVal">12</span></label>
            <input type="range" id="rooms" min="5" max="30" step="1" value="12">
        </div>

        <div class="slider-group">
            <label>Min Room Size <span id="minSizeVal">4</span></label>
            <input type="range" id="minSize" min="3" max="8" step="1" value="4">
        </div>

        <div class="slider-group">
            <label>Max Room Size <span id="maxSizeVal">10</span></label>
            <input type="range" id="maxSize" min="6" max="20" step="1" value="10">
        </div>

        <div class="slider-group">
            <label>Corridor Width <span id="corridorVal">2</span></label>
            <input type="range" id="corridor" min="1" max="4" step="1" value="2">
        </div>

        <div class="methods">
            <span class="method-btn active" data-method="bsp">BSP Tree</span>
            <span class="method-btn" data-method="rooms">Random Rooms</span>
            <span class="method-btn" data-method="cellular">Cellular</span>
            <span class="method-btn" data-method="drunkard">Drunkard Walk</span>
        </div>

        <div class="button-row">
            <button id="generateBtn">Generate</button>
            <button id="animateBtn">Animate</button>
        </div>

        <div class="stats">
            <div>Rooms: <span id="roomCount">0</span></div>
            <div>Corridors: <span id="corridorCount">0</span></div>
            <div>Open Space: <span id="openSpace">0%</span></div>
        </div>
    </div>

    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="info">
        <h3>Dungeon Generation</h3>
        <p>Common algorithms for procedural dungeons:
        <strong>BSP</strong> divides space into rooms, <strong>Random Rooms</strong>
        places non-overlapping rectangles, <strong>Cellular Automata</strong> creates
        cave-like spaces, and <strong>Drunkard Walk</strong> carves random tunnels.</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height, gridWidth, gridHeight;
        const CELL_SIZE = 8;

        let grid;
        let rooms = [];
        let corridors = [];

        let roomCount = 12;
        let minRoomSize = 4;
        let maxRoomSize = 10;
        let corridorWidth = 2;
        let method = 'bsp';
        let animating = false;
        let animationStep = 0;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = canvas.width;
            height = canvas.height;
            gridWidth = Math.floor(width / CELL_SIZE);
            gridHeight = Math.floor(height / CELL_SIZE);
            generate();
        }

        function initGrid() {
            grid = new Uint8Array(gridWidth * gridHeight);
            grid.fill(1); // All walls
            rooms = [];
            corridors = [];
        }

        function idx(x, y) {
            return y * gridWidth + x;
        }

        function carveRoom(room) {
            for (let y = room.y; y < room.y + room.h; y++) {
                for (let x = room.x; x < room.x + room.w; x++) {
                    if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) {
                        grid[idx(x, y)] = 0;
                    }
                }
            }
        }

        function carveCorridor(x1, y1, x2, y2) {
            const hw = Math.floor(corridorWidth / 2);

            // Horizontal first, then vertical
            for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
                for (let dy = -hw; dy <= hw; dy++) {
                    const y = y1 + dy;
                    if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) {
                        grid[idx(x, y)] = 0;
                    }
                }
            }

            for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
                for (let dx = -hw; dx <= hw; dx++) {
                    const x = x2 + dx;
                    if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) {
                        grid[idx(x, y)] = 0;
                    }
                }
            }

            corridors.push({ x1, y1, x2, y2 });
        }

        function generateBSP() {
            initGrid();

            class BSPNode {
                constructor(x, y, w, h) {
                    this.x = x; this.y = y;
                    this.w = w; this.h = h;
                    this.left = null;
                    this.right = null;
                    this.room = null;
                }

                split() {
                    if (this.left || this.right) return false;

                    const minSize = maxRoomSize + 2;
                    if (this.w < minSize * 2 && this.h < minSize * 2) return false;

                    const splitH = Math.random() > 0.5;
                    const canSplitH = this.w >= minSize * 2;
                    const canSplitV = this.h >= minSize * 2;

                    if (splitH && canSplitH) {
                        const split = Math.floor(minSize + Math.random() * (this.w - minSize * 2));
                        this.left = new BSPNode(this.x, this.y, split, this.h);
                        this.right = new BSPNode(this.x + split, this.y, this.w - split, this.h);
                    } else if (canSplitV) {
                        const split = Math.floor(minSize + Math.random() * (this.h - minSize * 2));
                        this.left = new BSPNode(this.x, this.y, this.w, split);
                        this.right = new BSPNode(this.x, this.y + split, this.w, this.h - split);
                    } else if (canSplitH) {
                        const split = Math.floor(minSize + Math.random() * (this.w - minSize * 2));
                        this.left = new BSPNode(this.x, this.y, split, this.h);
                        this.right = new BSPNode(this.x + split, this.y, this.w - split, this.h);
                    } else {
                        return false;
                    }

                    return true;
                }

                createRoom() {
                    if (this.left || this.right) {
                        if (this.left) this.left.createRoom();
                        if (this.right) this.right.createRoom();
                    } else {
                        const roomW = minRoomSize + Math.floor(Math.random() * (Math.min(maxRoomSize, this.w - 2) - minRoomSize));
                        const roomH = minRoomSize + Math.floor(Math.random() * (Math.min(maxRoomSize, this.h - 2) - minRoomSize));
                        const roomX = this.x + 1 + Math.floor(Math.random() * (this.w - roomW - 2));
                        const roomY = this.y + 1 + Math.floor(Math.random() * (this.h - roomH - 2));

                        this.room = { x: roomX, y: roomY, w: roomW, h: roomH };
                        rooms.push(this.room);
                        carveRoom(this.room);
                    }
                }

                getRoom() {
                    if (this.room) return this.room;
                    const leftRoom = this.left ? this.left.getRoom() : null;
                    const rightRoom = this.right ? this.right.getRoom() : null;
                    if (leftRoom && rightRoom) {
                        return Math.random() > 0.5 ? leftRoom : rightRoom;
                    }
                    return leftRoom || rightRoom;
                }

                connectRooms() {
                    if (this.left && this.right) {
                        const room1 = this.left.getRoom();
                        const room2 = this.right.getRoom();
                        if (room1 && room2) {
                            const x1 = room1.x + Math.floor(room1.w / 2);
                            const y1 = room1.y + Math.floor(room1.h / 2);
                            const x2 = room2.x + Math.floor(room2.w / 2);
                            const y2 = room2.y + Math.floor(room2.h / 2);
                            carveCorridor(x1, y1, x2, y2);
                        }
                        this.left.connectRooms();
                        this.right.connectRooms();
                    }
                }
            }

            const root = new BSPNode(1, 1, gridWidth - 2, gridHeight - 2);

            // Split recursively
            const nodes = [root];
            for (let i = 0; i < 10; i++) {
                const toSplit = [...nodes];
                for (const node of toSplit) {
                    if (node.split()) {
                        nodes.push(node.left, node.right);
                    }
                }
            }

            root.createRoom();
            root.connectRooms();
        }

        function generateRandomRooms() {
            initGrid();

            const attempts = roomCount * 20;

            for (let i = 0; i < attempts && rooms.length < roomCount; i++) {
                const w = minRoomSize + Math.floor(Math.random() * (maxRoomSize - minRoomSize));
                const h = minRoomSize + Math.floor(Math.random() * (maxRoomSize - minRoomSize));
                const x = 2 + Math.floor(Math.random() * (gridWidth - w - 4));
                const y = 2 + Math.floor(Math.random() * (gridHeight - h - 4));

                // Check overlap
                let overlap = false;
                for (const room of rooms) {
                    if (x < room.x + room.w + 2 && x + w + 2 > room.x &&
                        y < room.y + room.h + 2 && y + h + 2 > room.y) {
                        overlap = true;
                        break;
                    }
                }

                if (!overlap) {
                    const room = { x, y, w, h };
                    rooms.push(room);
                    carveRoom(room);
                }
            }

            // Connect rooms
            for (let i = 1; i < rooms.length; i++) {
                const r1 = rooms[i - 1];
                const r2 = rooms[i];
                carveCorridor(
                    r1.x + Math.floor(r1.w / 2),
                    r1.y + Math.floor(r1.h / 2),
                    r2.x + Math.floor(r2.w / 2),
                    r2.y + Math.floor(r2.h / 2)
                );
            }
        }

        function generateCellular() {
            initGrid();

            // Random fill
            for (let i = 0; i < grid.length; i++) {
                grid[i] = Math.random() < 0.45 ? 0 : 1;
            }

            // Clear border
            for (let x = 0; x < gridWidth; x++) {
                grid[idx(x, 0)] = 1;
                grid[idx(x, gridHeight - 1)] = 1;
            }
            for (let y = 0; y < gridHeight; y++) {
                grid[idx(0, y)] = 1;
                grid[idx(gridWidth - 1, y)] = 1;
            }

            // Cellular automata iterations
            for (let iter = 0; iter < 5; iter++) {
                const newGrid = new Uint8Array(grid.length);

                for (let y = 1; y < gridHeight - 1; y++) {
                    for (let x = 1; x < gridWidth - 1; x++) {
                        let walls = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (grid[idx(x + dx, y + dy)]) walls++;
                            }
                        }
                        newGrid[idx(x, y)] = walls >= 5 ? 1 : 0;
                    }
                }

                grid = newGrid;
            }
        }

        function generateDrunkard() {
            initGrid();

            const targetFloor = Math.floor(gridWidth * gridHeight * 0.4);
            let floorCount = 0;

            let x = Math.floor(gridWidth / 2);
            let y = Math.floor(gridHeight / 2);

            while (floorCount < targetFloor) {
                if (grid[idx(x, y)] === 1) {
                    grid[idx(x, y)] = 0;
                    floorCount++;
                }

                const dir = Math.floor(Math.random() * 4);
                switch (dir) {
                    case 0: if (x > 1) x--; break;
                    case 1: if (x < gridWidth - 2) x++; break;
                    case 2: if (y > 1) y--; break;
                    case 3: if (y < gridHeight - 2) y++; break;
                }
            }
        }

        function generate() {
            switch (method) {
                case 'bsp': generateBSP(); break;
                case 'rooms': generateRandomRooms(); break;
                case 'cellular': generateCellular(); break;
                case 'drunkard': generateDrunkard(); break;
            }
            updateStats();
            draw();
        }

        function updateStats() {
            let openCount = 0;
            for (let i = 0; i < grid.length; i++) {
                if (grid[i] === 0) openCount++;
            }
            document.getElementById('roomCount').textContent = rooms.length;
            document.getElementById('corridorCount').textContent = corridors.length;
            document.getElementById('openSpace').textContent =
                Math.round(openCount / grid.length * 100) + '%';
        }

        function draw() {
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, width, height);

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const cell = grid[idx(x, y)];

                    if (cell === 0) {
                        // Floor
                        ctx.fillStyle = '#2d2d3a';
                    } else {
                        // Wall
                        ctx.fillStyle = '#1a1a24';
                    }

                    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE - 1, CELL_SIZE - 1);
                }
            }

            // Highlight rooms
            ctx.strokeStyle = '#8bc34a33';
            ctx.lineWidth = 2;
            for (const room of rooms) {
                ctx.strokeRect(
                    room.x * CELL_SIZE,
                    room.y * CELL_SIZE,
                    room.w * CELL_SIZE,
                    room.h * CELL_SIZE
                );
            }
        }

        // UI
        document.getElementById('rooms').addEventListener('input', (e) => {
            roomCount = parseInt(e.target.value);
            document.getElementById('roomsVal').textContent = roomCount;
        });

        document.getElementById('minSize').addEventListener('input', (e) => {
            minRoomSize = parseInt(e.target.value);
            document.getElementById('minSizeVal').textContent = minRoomSize;
        });

        document.getElementById('maxSize').addEventListener('input', (e) => {
            maxRoomSize = parseInt(e.target.value);
            document.getElementById('maxSizeVal').textContent = maxRoomSize;
        });

        document.getElementById('corridor').addEventListener('input', (e) => {
            corridorWidth = parseInt(e.target.value);
            document.getElementById('corridorVal').textContent = corridorWidth;
        });

        document.querySelectorAll('.method-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.method-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                method = btn.dataset.method;
                generate();
            });
        });

        document.getElementById('generateBtn').addEventListener('click', generate);

        document.getElementById('animateBtn').addEventListener('click', function() {
            animating = !animating;
            this.textContent = animating ? 'Stop' : 'Animate';
            if (animating) animateGeneration();
        });

        let lastGenTime = 0;
        function animateGeneration() {
            if (!animating) return;

            const now = performance.now();
            if (now - lastGenTime > 1000) {
                generate();
                lastGenTime = now;
            }

            requestAnimationFrame(animateGeneration);
        }

        window.addEventListener('resize', resize);
        resize();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
