<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FEM Stress Analysis - CCAB</title>
    <style>
        body { margin: 0; background: #eee; overflow: hidden; font-family: monospace; }
        canvas { display: block; }
        .controls { position: absolute; top: 20px; right: 20px; background: rgba(255,255,255,0.9); backdrop-filter: blur(10px); padding: 10px; border-radius: 4px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
    </style>
</head>
<body>
    <div class="controls">
        <button onclick="addLoad()">Add Load</button>
        <button onclick="reset()">Reset</button>
    </div>
    <canvas id="canvas"></canvas>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        // Simple Truss
        const nodes = [
            {x: 100, y: 300, fixed: true},
            {x: 300, y: 300, fixed: true},
            {x: 200, y: 150, fixed: false, load: {x:0, y:0}},
            {x: 150, y: 225, fixed: false, load: {x:0, y:0}},
            {x: 250, y: 225, fixed: false, load: {x:0, y:0}}
        ];

        const elements = [
            {n1: 0, n2: 1}, {n1: 0, n2: 3}, {n1: 1, n2: 4},
            {n1: 3, n2: 2}, {n1: 4, n2: 2}, {n1: 3, n2: 4},
            {n1: 0, n2: 4}, {n1: 1, n2: 3} // Cross bracing
        ];

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            draw();
        }
        window.addEventListener('resize', resize);

        function solve() {
            // Pseudo-FEM: Just calculate simple force distribution for visualization
            // Assume top node (2) has load.
            elements.forEach(e => {
                const n1 = nodes[e.n1];
                const n2 = nodes[e.n2];
                const dy = n2.y - n1.y;
                
                // Visualization logic: Vertical members carry load
                e.stress = 0;
                if(nodes[2].load.y > 0) {
                    // Load applied
                    const dist = Math.abs(n1.x - 200) + Math.abs(n2.x - 200);
                    if(dist < 100) e.stress = 1; // High stress near load
                    else e.stress = 0.2;
                }
            });
        }

        function draw() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, width, height);
            
            ctx.save();
            ctx.translate(width/2 - 200, 100);

            // Draw Elements
            elements.forEach(e => {
                const n1 = nodes[e.n1];
                const n2 = nodes[e.n2];
                
                ctx.beginPath();
                ctx.moveTo(n1.x, n1.y);
                ctx.lineTo(n2.x, n2.y);
                
                // Color by stress
                const stress = e.stress || 0;
                const r = Math.min(255, stress * 255);
                const b = Math.min(255, (1-stress) * 255);
                
                ctx.strokeStyle = `rgb(${r}, 0, ${b})`;
                ctx.lineWidth = 4 + stress * 4;
                ctx.stroke();
            });

            // Draw Nodes
            nodes.forEach((n, i) => {
                ctx.beginPath();
                ctx.arc(n.x, n.y, 8, 0, Math.PI*2);
                ctx.fillStyle = n.fixed ? '#333' : '#fff';
                ctx.fill();
                ctx.stroke();
                
                // Load Arrow
                if(n.load && n.load.y > 0) {
                    ctx.beginPath();
                    ctx.moveTo(n.x, n.y);
                    ctx.lineTo(n.x, n.y + 50);
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    // Arrowhead
                    ctx.beginPath();
                    ctx.moveTo(n.x, n.y + 50);
                    ctx.lineTo(n.x - 5, n.y + 40);
                    ctx.lineTo(n.x + 5, n.y + 40);
                    ctx.fillStyle = 'red';
                    ctx.fill();
                }
            });

            ctx.restore();
        }

        function addLoad() {
            nodes[2].load.y = 50;
            solve();
            draw();
        }

        function reset() {
            nodes[2].load.y = 0;
            elements.forEach(e => e.stress = 0);
            draw();
        }

        // Expose for enhance.js keyboard shortcuts
        window.reset = reset;
        window.init = function() { reset(); resize(); };

        resize();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
