<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slime Mold Simulation - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #e0e0e0;
        }
        h1 {
            font-size: 2em;
            margin-bottom: 10px;
            color: #FFD700;
            text-align: center;
        }
        .container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        canvas {
            display: block;
            background: #000000;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 10px 20px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: #FFD700;
            color: #1a1a2e;
            font-weight: bold;
            transition: background 0.3s;
        }
        button:hover {
            background: #FFA500;
        }
        button.secondary {
            background: #2196F3;
            color: white;
        }
        button.secondary:hover {
            background: #0b7dda;
        }
        .info {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .metric {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #FFD700;
        }
        .metric-label {
            font-size: 0.9em;
            color: #aaa;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            flex: 1;
            max-width: 200px;
        }
        .slider-label {
            min-width: 120px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link" style="position:fixed;top:15px;left:15px;color:#fff;text-decoration:none;opacity:0.8;z-index:1000;">← Back</a>
    <h1>Physarum Polycephalum Slime Mold</h1>

    <div class="container">
        <canvas id="canvas" width="800" height="600"></canvas>

        <div class="controls">
            <button id="pauseBtn">Pause</button>
            <button id="resetBtn" class="secondary">Reset</button>
            <div class="slider-container">
                <span class="slider-label">Sensor Angle:</span>
                <input type="range" id="sensorAngleSlider" min="10" max="90" value="45">
                <span id="sensorAngleValue">45°</span>
            </div>
        </div>

        <div class="info">
            <strong>Physarum Polycephalum Simulation</strong><br>
            A single-celled organism that exhibits intelligent behavior through simple rules. Agents sense
            their environment, deposit chemical trails, and follow gradients. The emergent network efficiently
            connects food sources, mimicking behavior used to solve optimization problems like shortest path networks.
        </div>

        <div class="metrics">
            <div class="metric">
                <div class="metric-value" id="agentCount">0</div>
                <div class="metric-label">Active Agents</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="trailDensity">0%</div>
                <div class="metric-label">Trail Coverage</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="networkEfficiency">0%</div>
                <div class="metric-label">Network Efficiency</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="avgTrailStrength">0</div>
                <div class="metric-label">Avg Trail Strength</div>
            </div>
        </div>
    </div>

    <script src="../assets/js/demo-utils.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const fps = new FPSCounter({ position: 'top-right' });
        const errorMgr = new ErrorManager();
        setupGlobalErrorHandler((msg, details) => errorMgr.show(msg, details));
        fps.start();

        let isPaused = false;
        let sensorAngle = Math.PI / 4;

        // Trail map
        const trailCanvas = document.createElement('canvas');
        trailCanvas.width = canvas.width;
        trailCanvas.height = canvas.height;
        const trailCtx = trailCanvas.getContext('2d');

        // Food sources (attractants)
        const foodSources = [
            { x: 100, y: 100, radius: 20 },
            { x: 700, y: 100, radius: 20 },
            { x: 400, y: 300, radius: 20 },
            { x: 150, y: 500, radius: 20 },
            { x: 650, y: 500, radius: 20 }
        ];

        class Agent {
            constructor(x, y) {
                this.x = x || canvas.width / 2;
                this.y = y || canvas.height / 2;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 2;
                this.sensorDist = 15;
                this.sensorAngle = sensorAngle;
                this.turnSpeed = 0.3;
            }

            sense() {
                const sensors = [
                    { angle: this.angle, value: 0 }, // Forward
                    { angle: this.angle + this.sensorAngle, value: 0 }, // Left
                    { angle: this.angle - this.sensorAngle, value: 0 }  // Right
                ];

                for (const sensor of sensors) {
                    const sx = this.x + Math.cos(sensor.angle) * this.sensorDist;
                    const sy = this.y + Math.sin(sensor.angle) * this.sensorDist;

                    if (sx >= 0 && sx < canvas.width && sy >= 0 && sy < canvas.height) {
                        const imageData = trailCtx.getImageData(sx, sy, 1, 1);
                        // Sum RGB values as trail strength
                        sensor.value = imageData.data[0] + imageData.data[1] + imageData.data[2];
                    }
                }

                return sensors;
            }

            update() {
                const sensors = this.sense();

                // Determine turning direction based on sensor values
                const forward = sensors[0].value;
                const left = sensors[1].value;
                const right = sensors[2].value;

                if (forward > left && forward > right) {
                    // Continue forward
                } else if (forward < left && forward < right) {
                    // Random turn
                    this.angle += (Math.random() - 0.5) * this.turnSpeed;
                } else if (left > right) {
                    this.angle += this.turnSpeed;
                } else if (right > left) {
                    this.angle -= this.turnSpeed;
                } else {
                    this.angle += (Math.random() - 0.5) * this.turnSpeed;
                }

                // Move
                let newX = this.x + Math.cos(this.angle) * this.speed;
                let newY = this.y + Math.sin(this.angle) * this.speed;

                // Bounce off boundaries
                if (newX < 0 || newX >= canvas.width) {
                    this.angle = Math.PI - this.angle;
                    newX = Math.max(0, Math.min(canvas.width - 1, newX));
                }
                if (newY < 0 || newY >= canvas.height) {
                    this.angle = -this.angle;
                    newY = Math.max(0, Math.min(canvas.height - 1, newY));
                }

                this.x = newX;
                this.y = newY;

                // Deposit trail
                this.depositTrail();
            }

            depositTrail() {
                trailCtx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                trailCtx.beginPath();
                trailCtx.arc(this.x, this.y, 1.5, 0, Math.PI * 2);
                trailCtx.fill();
            }

            draw() {
                ctx.fillStyle = '#FFFF00';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 1, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        const agents = [];
        function initAgents() {
            agents.length = 0;
            // Spawn agents around food sources
            for (const food of foodSources) {
                for (let i = 0; i < 200; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * food.radius;
                    agents.push(new Agent(
                        food.x + Math.cos(angle) * dist,
                        food.y + Math.sin(angle) * dist
                    ));
                }
            }
        }

        function diffuseAndDecay() {
            const imageData = trailCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(trailCanvas, 0, 0);
            const tempData = tempCtx.getImageData(0, 0, canvas.width, canvas.height).data;

            for (let y = 1; y < canvas.height - 1; y++) {
                for (let x = 1; x < canvas.width - 1; x++) {
                    const idx = (y * canvas.width + x) * 4;

                    // Simple blur (3x3 average)
                    let sum = [0, 0, 0];
                    let count = 0;

                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nidx = ((y + dy) * canvas.width + (x + dx)) * 4;
                            sum[0] += tempData[nidx];
                            sum[1] += tempData[nidx + 1];
                            sum[2] += tempData[nidx + 2];
                            count++;
                        }
                    }

                    // Decay
                    data[idx] = sum[0] / count * 0.96;
                    data[idx + 1] = sum[1] / count * 0.96;
                    data[idx + 2] = sum[2] / count * 0.96;
                    data[idx + 3] = 255;
                }
            }

            trailCtx.putImageData(imageData, 0, 0);
        }

        function drawFoodSources() {
            for (const food of foodSources) {
                // Glow effect
                const gradient = ctx.createRadialGradient(food.x, food.y, 0, food.x, food.y, food.radius);
                gradient.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(food.x, food.y, food.radius, 0, Math.PI * 2);
                ctx.fill();

                // Core
                ctx.fillStyle = '#FF6600';
                ctx.beginPath();
                ctx.arc(food.x, food.y, 8, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function calculateMetrics() {
            // Calculate trail coverage
            const imageData = trailCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            let trailPixels = 0;
            let totalStrength = 0;

            for (let i = 0; i < data.length; i += 4) {
                const strength = data[i] + data[i + 1] + data[i + 2];
                if (strength > 10) {
                    trailPixels++;
                    totalStrength += strength;
                }
            }

            const coverage = ((trailPixels / (canvas.width * canvas.height)) * 100).toFixed(1);
            const avgStrength = trailPixels > 0 ? (totalStrength / trailPixels / 3).toFixed(1) : 0;

            document.getElementById('agentCount').textContent = agents.length;
            document.getElementById('trailDensity').textContent = coverage + '%';
            document.getElementById('avgTrailStrength').textContent = avgStrength;

            // Simple efficiency metric based on trail connectivity
            const efficiency = Math.min(100, parseFloat(coverage) * 1.5).toFixed(0);
            document.getElementById('networkEfficiency').textContent = efficiency + '%';
        }

        function animate() {
            fps.update();
            if (!isPaused) {
                // Clear main canvas
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Diffuse and decay trails
                diffuseAndDecay();

                // Draw trails
                ctx.drawImage(trailCanvas, 0, 0);

                // Update and draw agents
                agents.forEach(agent => {
                    agent.update();
                    agent.draw();
                });

                // Draw food sources
                drawFoodSources();

                // Update metrics every 30 frames
                if (Math.random() < 0.03) {
                    calculateMetrics();
                }
            }

            requestAnimationFrame(animate);
        }

        function reset() {
            trailCtx.fillStyle = '#000000';
            trailCtx.fillRect(0, 0, canvas.width, canvas.height);
            initAgents();
        }

        document.getElementById('pauseBtn').addEventListener('click', function() {
            isPaused = !isPaused;
            this.textContent = isPaused ? 'Resume' : 'Pause';
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        document.getElementById('sensorAngleSlider').addEventListener('input', function() {
            const degrees = parseInt(this.value);
            sensorAngle = (degrees * Math.PI) / 180;
            agents.forEach(agent => agent.sensorAngle = sensorAngle);
            document.getElementById('sensorAngleValue').textContent = degrees + '°';
        });

        initAgents();
        animate();
    </script>
</body>
</html>