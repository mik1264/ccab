<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fitness Landscape Explorer - Evolutionary Dynamics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: #e0e0e0;
        }
        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            color: #00d9ff;
            text-decoration: none;
            font-size: 14px;
            z-index: 100;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 300px;
            height: 100vh;
        }
        .main-view {
            display: flex;
            flex-direction: column;
            padding: 20px;
        }
        header {
            text-align: center;
            padding-bottom: 15px;
        }
        h1 {
            font-size: 1.6rem;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { color: #8899a6; font-size: 0.9rem; }
        .canvas-wrapper {
            flex: 1;
            display: flex;
            gap: 15px;
        }
        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .canvas-container h3 {
            color: #00d9ff;
            font-size: 0.9rem;
            margin-bottom: 8px;
            text-align: center;
        }
        canvas {
            flex: 1;
            background: #0a0a15;
            border: 1px solid #2a3a4a;
            border-radius: 8px;
        }
        .sidebar {
            background: rgba(10, 10, 21, 0.9);
            border-left: 1px solid #2a3a4a;
            padding: 20px;
            overflow-y: auto;
        }
        .control-section {
            margin-bottom: 20px;
        }
        .control-section h3 {
            color: #00d9ff;
            font-size: 0.9rem;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #2a3a4a;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            color: #8899a6;
            font-size: 0.85rem;
            margin-bottom: 6px;
        }
        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            background: #1a1a2e;
            border: 1px solid #2a3a4a;
            border-radius: 5px;
            color: #fff;
            font-size: 0.85rem;
        }
        input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            padding: 0;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #00d9ff;
            border-radius: 50%;
            cursor: pointer;
        }
        .slider-value {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 0.75rem;
            color: #5a6a7a;
        }
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            border: none;
            border-radius: 5px;
            color: #000;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }
        button:hover { transform: scale(1.02); }
        button.secondary {
            background: #2a3a4a;
            color: #fff;
        }
        .stats-panel {
            background: rgba(0, 217, 255, 0.05);
            border: 1px solid rgba(0, 217, 255, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            font-size: 0.85rem;
        }
        .stat-label { color: #8899a6; }
        .stat-value { color: #00ff88; font-family: monospace; }
        .legend {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
        }
        .legend-title {
            color: #00d9ff;
            font-size: 0.85rem;
            margin-bottom: 8px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
            font-size: 0.8rem;
        }
        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }
        .info-text {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,100,150,0.1);
            border-radius: 5px;
            font-size: 0.8rem;
            line-height: 1.5;
            color: #8899a6;
        }
        @media (max-width: 1000px) {
            .container { grid-template-columns: 1fr; }
            .canvas-wrapper { flex-direction: column; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>

    <div class="container">
        <div class="main-view">
            <header>
                <h1>Fitness Landscape Explorer</h1>
                <p class="subtitle">Visualizing Evolutionary Dynamics on Adaptive Landscapes</p>
            </header>
            <div class="canvas-wrapper">
                <div class="canvas-container">
                    <h3>3D Landscape View</h3>
                    <canvas id="landscape3d"></canvas>
                </div>
                <div class="canvas-container">
                    <h3>Population Distribution</h3>
                    <canvas id="population"></canvas>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div class="control-section">
                <h3>Landscape Type</h3>
                <div class="control-group">
                    <select id="landscapeType">
                        <option value="rugged">Rugged (NK Model)</option>
                        <option value="smooth">Smooth Gaussian</option>
                        <option value="holey">Holey (Sparse Peaks)</option>
                        <option value="multimodal">Multi-Modal</option>
                        <option value="shifting">Shifting Peaks</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Ruggedness (K)</label>
                    <input type="range" id="ruggedness" min="0" max="10" value="3">
                    <div class="slider-value">
                        <span>Smooth</span>
                        <span id="ruggedVal">3</span>
                        <span>Rugged</span>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <h3>Population Settings</h3>
                <div class="control-group">
                    <label>Population Size</label>
                    <input type="range" id="popSize" min="10" max="200" value="50">
                    <div class="slider-value">
                        <span>10</span>
                        <span id="popSizeVal">50</span>
                        <span>200</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Mutation Rate</label>
                    <input type="range" id="mutationRate" min="1" max="50" value="10">
                    <div class="slider-value">
                        <span>0.01</span>
                        <span id="mutRateVal">0.10</span>
                        <span>0.50</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Selection Pressure</label>
                    <input type="range" id="selection" min="1" max="10" value="5">
                    <div class="slider-value">
                        <span>Weak</span>
                        <span id="selVal">5</span>
                        <span>Strong</span>
                    </div>
                </div>
            </div>

            <button id="resetBtn">New Landscape</button>
            <button id="startBtn">Start Evolution</button>
            <button id="stepBtn" class="secondary">Single Generation</button>

            <div class="stats-panel">
                <div class="stat-row">
                    <span class="stat-label">Generation:</span>
                    <span class="stat-value" id="genStat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Max Fitness:</span>
                    <span class="stat-value" id="maxFitStat">0.00</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Avg Fitness:</span>
                    <span class="stat-value" id="avgFitStat">0.00</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Diversity:</span>
                    <span class="stat-value" id="divStat">0.00</span>
                </div>
            </div>

            <div class="legend">
                <div class="legend-title">Fitness Scale</div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(90deg, #0000ff, #00ffff, #00ff00, #ffff00, #ff0000)"></div>
                    <span>Low → High</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #fff; border-radius: 50%;"></div>
                    <span>Population individuals</span>
                </div>
            </div>

            <div class="info-text">
                <strong>Fitness landscapes</strong> visualize how genotypes map to fitness.
                Populations evolve by climbing peaks. Rugged landscapes have many local optima
                that can trap populations. Selection pressure determines how quickly populations
                climb, while mutation enables exploration of new regions.
            </div>
        </div>
    </div>

    <script>
        const canvas3d = document.getElementById('landscape3d');
        const ctx3d = canvas3d.getContext('2d');
        const canvasPop = document.getElementById('population');
        const ctxPop = canvasPop.getContext('2d');

        // Resize
        function resize() {
            canvas3d.width = canvas3d.offsetWidth;
            canvas3d.height = canvas3d.offsetHeight;
            canvasPop.width = canvasPop.offsetWidth;
            canvasPop.height = canvasPop.offsetHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Parameters
        const GRID_SIZE = 50;
        let landscape = [];
        let population = [];
        let generation = 0;
        let running = false;
        let rotationAngle = 0;

        let ruggedness = 3;
        let popSize = 50;
        let mutationRate = 0.1;
        let selectionPressure = 5;
        let landscapeType = 'rugged';

        // Generate landscape
        function generateLandscape() {
            landscape = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));

            switch (landscapeType) {
                case 'smooth':
                    generateSmoothLandscape();
                    break;
                case 'holey':
                    generateHoleyLandscape();
                    break;
                case 'multimodal':
                    generateMultimodalLandscape();
                    break;
                case 'shifting':
                    generateShiftingLandscape();
                    break;
                default:
                    generateRuggedLandscape();
            }

            // Normalize to [0, 1]
            let min = Infinity, max = -Infinity;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    min = Math.min(min, landscape[y][x]);
                    max = Math.max(max, landscape[y][x]);
                }
            }
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    landscape[y][x] = (landscape[y][x] - min) / (max - min || 1);
                }
            }
        }

        function generateRuggedLandscape() {
            // NK-like rugged landscape
            const numPeaks = 3 + ruggedness * 2;
            const peaks = [];
            for (let i = 0; i < numPeaks; i++) {
                peaks.push({
                    x: Math.random() * GRID_SIZE,
                    y: Math.random() * GRID_SIZE,
                    height: 0.5 + Math.random() * 0.5,
                    width: 3 + Math.random() * (10 - ruggedness)
                });
            }

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    let value = 0;
                    peaks.forEach(peak => {
                        const dx = x - peak.x;
                        const dy = y - peak.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        value += peak.height * Math.exp(-dist*dist / (2 * peak.width * peak.width));
                    });

                    // Add noise based on ruggedness
                    value += (Math.random() - 0.5) * ruggedness * 0.05;
                    landscape[y][x] = value;
                }
            }
        }

        function generateSmoothLandscape() {
            const cx = GRID_SIZE / 2;
            const cy = GRID_SIZE / 2;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const dx = x - cx;
                    const dy = y - cy;
                    landscape[y][x] = Math.exp(-(dx*dx + dy*dy) / (GRID_SIZE * 10));
                }
            }
        }

        function generateHoleyLandscape() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    landscape[y][x] = 0.1;
                }
            }
            // Add sparse high peaks
            for (let i = 0; i < 5; i++) {
                const px = Math.floor(Math.random() * GRID_SIZE);
                const py = Math.floor(Math.random() * GRID_SIZE);
                const radius = 2 + Math.random() * 3;
                for (let dy = -5; dy <= 5; dy++) {
                    for (let dx = -5; dx <= 5; dx++) {
                        const x = px + dx;
                        const y = py + dy;
                        if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                            const d = Math.sqrt(dx*dx + dy*dy);
                            if (d < radius) {
                                landscape[y][x] = Math.max(landscape[y][x], 1 - d/radius);
                            }
                        }
                    }
                }
            }
        }

        function generateMultimodalLandscape() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const fx = x / GRID_SIZE * Math.PI * 4;
                    const fy = y / GRID_SIZE * Math.PI * 4;
                    landscape[y][x] = Math.sin(fx) * Math.sin(fy) + 0.5 * Math.sin(fx*2) * Math.sin(fy*2);
                }
            }
        }

        function generateShiftingLandscape() {
            generateRuggedLandscape();
        }

        // Initialize population
        function initPopulation() {
            population = [];
            for (let i = 0; i < popSize; i++) {
                population.push({
                    x: Math.random() * GRID_SIZE,
                    y: Math.random() * GRID_SIZE
                });
            }
            generation = 0;
        }

        // Get fitness at position
        function getFitness(x, y) {
            const ix = Math.floor(Math.max(0, Math.min(GRID_SIZE - 1, x)));
            const iy = Math.floor(Math.max(0, Math.min(GRID_SIZE - 1, y)));
            return landscape[iy][ix];
        }

        // Evolve one generation
        function evolve() {
            // Calculate fitness for all individuals
            const fitnesses = population.map(ind => getFitness(ind.x, ind.y));

            // Selection (tournament)
            const newPop = [];
            for (let i = 0; i < popSize; i++) {
                let best = Math.floor(Math.random() * popSize);
                for (let j = 0; j < selectionPressure; j++) {
                    const competitor = Math.floor(Math.random() * popSize);
                    if (fitnesses[competitor] > fitnesses[best]) {
                        best = competitor;
                    }
                }
                newPop.push({...population[best]});
            }

            // Mutation
            newPop.forEach(ind => {
                if (Math.random() < mutationRate) {
                    ind.x += (Math.random() - 0.5) * 5;
                    ind.y += (Math.random() - 0.5) * 5;
                    ind.x = Math.max(0, Math.min(GRID_SIZE - 1, ind.x));
                    ind.y = Math.max(0, Math.min(GRID_SIZE - 1, ind.y));
                }
            });

            population = newPop;
            generation++;

            // Shifting landscape
            if (landscapeType === 'shifting' && generation % 50 === 0) {
                generateLandscape();
            }

            updateStats();
        }

        // Update statistics
        function updateStats() {
            const fitnesses = population.map(ind => getFitness(ind.x, ind.y));
            const maxFit = Math.max(...fitnesses);
            const avgFit = fitnesses.reduce((a, b) => a + b, 0) / fitnesses.length;

            // Diversity: average distance from centroid
            const cx = population.reduce((a, b) => a + b.x, 0) / popSize;
            const cy = population.reduce((a, b) => a + b.y, 0) / popSize;
            const diversity = population.reduce((a, b) => {
                const dx = b.x - cx;
                const dy = b.y - cy;
                return a + Math.sqrt(dx*dx + dy*dy);
            }, 0) / popSize / GRID_SIZE;

            document.getElementById('genStat').textContent = generation;
            document.getElementById('maxFitStat').textContent = maxFit.toFixed(3);
            document.getElementById('avgFitStat').textContent = avgFit.toFixed(3);
            document.getElementById('divStat').textContent = diversity.toFixed(3);
        }

        // Color from fitness
        function fitnessColor(f) {
            const colors = [
                [0, 0, 128],      // dark blue
                [0, 128, 255],    // light blue
                [0, 255, 128],    // cyan-green
                [128, 255, 0],    // yellow-green
                [255, 255, 0],    // yellow
                [255, 128, 0],    // orange
                [255, 0, 0]       // red
            ];
            const idx = Math.min(f * (colors.length - 1), colors.length - 2);
            const i = Math.floor(idx);
            const t = idx - i;
            const r = Math.round(colors[i][0] * (1-t) + colors[i+1][0] * t);
            const g = Math.round(colors[i][1] * (1-t) + colors[i+1][1] * t);
            const b = Math.round(colors[i][2] * (1-t) + colors[i+1][2] * t);
            return `rgb(${r},${g},${b})`;
        }

        // Render 3D landscape
        function render3D() {
            const w = canvas3d.width;
            const h = canvas3d.height;

            ctx3d.fillStyle = '#0a0a15';
            ctx3d.fillRect(0, 0, w, h);

            rotationAngle += 0.005;
            const cos = Math.cos(rotationAngle);
            const sin = Math.sin(rotationAngle);
            const tilt = 0.6;

            const scale = Math.min(w, h) * 0.012;
            const offsetX = w / 2;
            const offsetY = h * 0.6;

            // Draw landscape as lines
            for (let y = 0; y < GRID_SIZE; y += 2) {
                ctx3d.beginPath();
                for (let x = 0; x < GRID_SIZE; x++) {
                    const fx = (x - GRID_SIZE/2) * scale;
                    const fy = (y - GRID_SIZE/2) * scale;
                    const fz = landscape[y][x] * scale * 15;

                    const rx = fx * cos - fy * sin;
                    const ry = (fx * sin + fy * cos) * tilt - fz;

                    const px = offsetX + rx;
                    const py = offsetY + ry;

                    if (x === 0) ctx3d.moveTo(px, py);
                    else ctx3d.lineTo(px, py);
                }
                ctx3d.strokeStyle = `rgba(0, 217, 255, 0.3)`;
                ctx3d.lineWidth = 1;
                ctx3d.stroke();
            }

            for (let x = 0; x < GRID_SIZE; x += 2) {
                ctx3d.beginPath();
                for (let y = 0; y < GRID_SIZE; y++) {
                    const fx = (x - GRID_SIZE/2) * scale;
                    const fy = (y - GRID_SIZE/2) * scale;
                    const fz = landscape[y][x] * scale * 15;

                    const rx = fx * cos - fy * sin;
                    const ry = (fx * sin + fy * cos) * tilt - fz;

                    const px = offsetX + rx;
                    const py = offsetY + ry;

                    if (y === 0) ctx3d.moveTo(px, py);
                    else ctx3d.lineTo(px, py);
                }
                ctx3d.strokeStyle = `rgba(0, 255, 136, 0.3)`;
                ctx3d.stroke();
            }

            // Draw population on 3D
            population.forEach(ind => {
                const fx = (ind.x - GRID_SIZE/2) * scale;
                const fy = (ind.y - GRID_SIZE/2) * scale;
                const fz = getFitness(ind.x, ind.y) * scale * 15;

                const rx = fx * cos - fy * sin;
                const ry = (fx * sin + fy * cos) * tilt - fz;

                const px = offsetX + rx;
                const py = offsetY + ry;

                ctx3d.fillStyle = '#fff';
                ctx3d.beginPath();
                ctx3d.arc(px, py, 3, 0, Math.PI * 2);
                ctx3d.fill();
            });
        }

        // Render 2D population view
        function render2D() {
            const w = canvasPop.width;
            const h = canvasPop.height;
            const cellW = w / GRID_SIZE;
            const cellH = h / GRID_SIZE;

            // Draw landscape heatmap
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    ctxPop.fillStyle = fitnessColor(landscape[y][x]);
                    ctxPop.fillRect(x * cellW, y * cellH, cellW + 1, cellH + 1);
                }
            }

            // Draw population
            population.forEach(ind => {
                const px = ind.x * cellW;
                const py = ind.y * cellH;

                ctxPop.fillStyle = '#fff';
                ctxPop.beginPath();
                ctxPop.arc(px, py, 4, 0, Math.PI * 2);
                ctxPop.fill();

                ctxPop.strokeStyle = '#000';
                ctxPop.lineWidth = 1;
                ctxPop.stroke();
            });
        }

        // Animation
        function animate() {
            if (running) {
                evolve();
            }
            render3D();
            render2D();
            requestAnimationFrame(animate);
        }

        // Event handlers
        document.getElementById('landscapeType').addEventListener('change', (e) => {
            landscapeType = e.target.value;
        });

        document.getElementById('ruggedness').addEventListener('input', (e) => {
            ruggedness = parseInt(e.target.value);
            document.getElementById('ruggedVal').textContent = ruggedness;
        });

        document.getElementById('popSize').addEventListener('input', (e) => {
            popSize = parseInt(e.target.value);
            document.getElementById('popSizeVal').textContent = popSize;
        });

        document.getElementById('mutationRate').addEventListener('input', (e) => {
            mutationRate = e.target.value / 100;
            document.getElementById('mutRateVal').textContent = mutationRate.toFixed(2);
        });

        document.getElementById('selection').addEventListener('input', (e) => {
            selectionPressure = parseInt(e.target.value);
            document.getElementById('selVal').textContent = selectionPressure;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            document.getElementById('startBtn').textContent = 'Start Evolution';
            generateLandscape();
            initPopulation();
            updateStats();
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start Evolution';
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            if (!running) {
                evolve();
            }
        });

        // Initialize
        generateLandscape();
        initPopulation();
        updateStats();
        animate();
    </script>
</body>
</html>
