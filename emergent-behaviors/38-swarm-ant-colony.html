<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ant Colony Optimization - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #e0e0e0;
        }
        h1 {
            font-size: 2em;
            margin-bottom: 10px;
            color: #4CAF50;
            text-align: center;
        }
        .container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        canvas {
            display: block;
            background: #0a0a0a;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 10px 20px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            transition: background 0.3s;
        }
        button:hover {
            background: #45a049;
        }
        button.secondary {
            background: #2196F3;
        }
        button.secondary:hover {
            background: #0b7dda;
        }
        .info {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .metric {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #4CAF50;
        }
        .metric-label {
            font-size: 0.9em;
            color: #aaa;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            flex: 1;
            max-width: 200px;
        }
        .slider-label {
            min-width: 100px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link" style="position:fixed;top:15px;left:15px;color:#fff;text-decoration:none;opacity:0.8;z-index:1000;">‚Üê Back</a>
    <h1>Ant Colony Optimization</h1>

    <div class="container">
        <canvas id="canvas" width="800" height="600"></canvas>

        <div class="controls">
            <button id="pauseBtn">Pause</button>
            <button id="resetBtn" class="secondary">Reset</button>
            <div class="slider-container">
                <span class="slider-label">Speed:</span>
                <input type="range" id="speedSlider" min="1" max="10" value="5">
                <span id="speedValue">5x</span>
            </div>
        </div>

        <div class="info">
            <strong>Ant Colony Optimization</strong><br>
            Ants find the shortest path between nest and food using pheromone trails. Each ant deposits pheromones
            that evaporate over time. Shorter paths accumulate stronger pheromone concentrations, creating an
            emergent optimization algorithm. Watch as the colony converges on the optimal path through collective behavior.
        </div>

        <div class="metrics">
            <div class="metric">
                <div class="metric-value" id="antCount">0</div>
                <div class="metric-label">Active Ants</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="foodCollected">0</div>
                <div class="metric-label">Food Collected</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="pheromoneLevel">0</div>
                <div class="metric-label">Avg Pheromone</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="pathEfficiency">0%</div>
                <div class="metric-label">Path Efficiency</div>
            </div>
        </div>
    </div>

    <script src="../assets/js/demo-utils.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const fps = new FPSCounter({ position: 'top-right' });
        const errorMgr = new ErrorManager();
        setupGlobalErrorHandler((msg, details) => errorMgr.show(msg, details));
        fps.start();

        let isPaused = false;
        let speed = 5;
        let foodCollected = 0;

        // Grid for pheromone trails
        const gridSize = 5;
        const gridWidth = Math.ceil(canvas.width / gridSize);
        const gridHeight = Math.ceil(canvas.height / gridSize);
        const pheromoneGrid = Array(gridHeight).fill().map(() => Array(gridWidth).fill(0));

        // Nest and food positions
        const nest = { x: 100, y: 300, radius: 30 };
        const foodSources = [
            { x: 700, y: 150, radius: 25, amount: 100 },
            { x: 650, y: 450, radius: 25, amount: 100 }
        ];

        // Obstacles
        const obstacles = [
            { x: 300, y: 200, width: 20, height: 200 },
            { x: 500, y: 200, width: 20, height: 200 }
        ];

        class Ant {
            constructor() {
                this.x = nest.x;
                this.y = nest.y;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 2;
                this.hasFood = false;
                this.path = [];
                this.pathIndex = 0;
            }

            update() {
                if (this.hasFood) {
                    // Return to nest following reverse path with some randomness
                    const dx = nest.x - this.x;
                    const dy = nest.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < nest.radius) {
                        // Reached nest, deposit food
                        this.hasFood = false;
                        foodCollected++;
                        // Deposit pheromones along path
                        this.depositPheromones();
                        this.path = [];
                        this.angle = Math.random() * Math.PI * 2;
                    } else {
                        // Move towards nest
                        this.angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.3;
                        this.move();
                    }
                } else {
                    // Search for food, following pheromones
                    let foundFood = false;

                    // Check if reached food
                    for (const food of foodSources) {
                        if (food.amount > 0) {
                            const dx = food.x - this.x;
                            const dy = food.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < food.radius) {
                                this.hasFood = true;
                                food.amount--;
                                foundFood = true;
                                break;
                            }
                        }
                    }

                    if (!foundFood) {
                        // Follow pheromone gradient with some exploration
                        if (Math.random() < 0.7) {
                            const bestAngle = this.findBestDirection();
                            if (bestAngle !== null) {
                                this.angle = bestAngle + (Math.random() - 0.5) * 0.5;
                            } else {
                                this.angle += (Math.random() - 0.5) * 0.4;
                            }
                        } else {
                            this.angle += (Math.random() - 0.5) * 0.4;
                        }

                        this.move();
                    }
                }
            }

            findBestDirection() {
                const sensorDist = 20;
                const sensorAngle = Math.PI / 4;

                const sensors = [
                    { angle: this.angle, strength: 0 },
                    { angle: this.angle + sensorAngle, strength: 0 },
                    { angle: this.angle - sensorAngle, strength: 0 }
                ];

                for (const sensor of sensors) {
                    const sx = this.x + Math.cos(sensor.angle) * sensorDist;
                    const sy = this.y + Math.sin(sensor.angle) * sensorDist;
                    sensor.strength = this.getPheromoneAt(sx, sy);
                }

                let maxStrength = Math.max(...sensors.map(s => s.strength));
                if (maxStrength > 0) {
                    const best = sensors.find(s => s.strength === maxStrength);
                    return best.angle;
                }

                return null;
            }

            getPheromoneAt(x, y) {
                const gx = Math.floor(x / gridSize);
                const gy = Math.floor(y / gridSize);
                if (gx >= 0 && gx < gridWidth && gy >= 0 && gy < gridHeight) {
                    return pheromoneGrid[gy][gx];
                }
                return 0;
            }

            move() {
                const newX = this.x + Math.cos(this.angle) * this.speed;
                const newY = this.y + Math.sin(this.angle) * this.speed;

                // Check boundaries
                if (newX < 10 || newX > canvas.width - 10) {
                    this.angle = Math.PI - this.angle;
                    return;
                }
                if (newY < 10 || newY > canvas.height - 10) {
                    this.angle = -this.angle;
                    return;
                }

                // Check obstacles
                for (const obs of obstacles) {
                    if (newX > obs.x && newX < obs.x + obs.width &&
                        newY > obs.y && newY < obs.y + obs.height) {
                        this.angle += Math.PI / 2 + (Math.random() - 0.5);
                        return;
                    }
                }

                this.x = newX;
                this.y = newY;

                if (!this.hasFood) {
                    this.path.push({ x: this.x, y: this.y });
                }
            }

            depositPheromones() {
                for (const point of this.path) {
                    const gx = Math.floor(point.x / gridSize);
                    const gy = Math.floor(point.y / gridSize);
                    if (gx >= 0 && gx < gridWidth && gy >= 0 && gy < gridHeight) {
                        pheromoneGrid[gy][gx] = Math.min(255, pheromoneGrid[gy][gx] + 50);
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Draw ant
                ctx.fillStyle = this.hasFood ? '#FFD700' : '#FF4444';
                ctx.beginPath();
                ctx.ellipse(0, 0, 3, 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.beginPath();
                ctx.arc(3, 0, 1.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        const ants = [];
        for (let i = 0; i < 50; i++) {
            ants.push(new Ant());
        }

        function evaporatePheromones() {
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    pheromoneGrid[y][x] *= 0.995; // Slow evaporation
                }
            }
        }

        function drawPheromones() {
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const strength = pheromoneGrid[y][x];
                    if (strength > 1) {
                        const alpha = Math.min(strength / 100, 1);
                        ctx.fillStyle = `rgba(100, 200, 255, ${alpha * 0.5})`;
                        ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
                    }
                }
            }
        }

        function drawNest() {
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(nest.x, nest.y, nest.radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('NEST', nest.x, nest.y);
        }

        function drawFood() {
            for (const food of foodSources) {
                if (food.amount > 0) {
                    const radius = food.radius * (food.amount / 100);
                    ctx.fillStyle = '#4CAF50';
                    ctx.beginPath();
                    ctx.arc(food.x, food.y, Math.max(radius, 5), 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(food.amount, food.x, food.y);
                }
            }
        }

        function drawObstacles() {
            ctx.fillStyle = '#333333';
            for (const obs of obstacles) {
                ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
            }
        }

        function updateMetrics() {
            document.getElementById('antCount').textContent = ants.length;
            document.getElementById('foodCollected').textContent = foodCollected;

            let avgPheromone = 0;
            let count = 0;
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    avgPheromone += pheromoneGrid[y][x];
                    count++;
                }
            }
            avgPheromone = (avgPheromone / count).toFixed(1);
            document.getElementById('pheromoneLevel').textContent = avgPheromone;

            const maxPossible = foodSources.reduce((sum, f) => sum + 100, 0);
            const efficiency = ((foodCollected / maxPossible) * 100).toFixed(1);
            document.getElementById('pathEfficiency').textContent = efficiency + '%';
        }

        function animate() {
            fps.update();
            if (!isPaused) {
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                drawPheromones();
                drawObstacles();
                drawNest();
                drawFood();

                for (let i = 0; i < speed; i++) {
                    evaporatePheromones();
                    ants.forEach(ant => ant.update());
                }

                ants.forEach(ant => ant.draw());
                updateMetrics();
            }

            requestAnimationFrame(animate);
        }

        function reset() {
            foodCollected = 0;
            ants.length = 0;
            for (let i = 0; i < 50; i++) {
                ants.push(new Ant());
            }
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    pheromoneGrid[y][x] = 0;
                }
            }
            foodSources[0].amount = 100;
            foodSources[1].amount = 100;
        }

        document.getElementById('pauseBtn').addEventListener('click', function() {
            isPaused = !isPaused;
            this.textContent = isPaused ? 'Resume' : 'Pause';
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        document.getElementById('speedSlider').addEventListener('input', function() {
            speed = parseInt(this.value);
            document.getElementById('speedValue').textContent = speed + 'x';
        });

        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>