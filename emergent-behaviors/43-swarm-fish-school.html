<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fish Schooling - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #e0e0e0;
        }
        h1 {
            font-size: 2em;
            margin-bottom: 10px;
            color: #00BCD4;
            text-align: center;
        }
        .container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        canvas {
            display: block;
            background: linear-gradient(180deg, #001a33 0%, #002244 50%, #003355 100%);
            border-radius: 8px;
            margin-bottom: 15px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 10px 20px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: #00BCD4;
            color: white;
            transition: background 0.3s;
        }
        button:hover {
            background: #0097A7;
        }
        button.secondary {
            background: #FF9800;
        }
        button.secondary:hover {
            background: #F57C00;
        }
        .info {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .metric {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #00BCD4;
        }
        .metric-label {
            font-size: 0.9em;
            color: #aaa;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            flex: 1;
            max-width: 150px;
        }
        .slider-label {
            min-width: 90px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link" style="position:fixed;top:15px;left:15px;color:#fff;text-decoration:none;opacity:0.8;z-index:1000;">‚Üê Back</a>
    <h1>Fish Schooling Behavior</h1>

    <div class="container">
        <canvas id="canvas" width="800" height="600"></canvas>

        <div class="controls">
            <button id="pauseBtn">Pause</button>
            <button id="resetBtn" class="secondary">Reset</button>
            <button id="predatorBtn" class="secondary">Add Predator</button>
            <div class="slider-container">
                <span class="slider-label">Cohesion:</span>
                <input type="range" id="cohesionSlider" min="0" max="100" value="50">
            </div>
            <div class="slider-container">
                <span class="slider-label">Separation:</span>
                <input type="range" id="separationSlider" min="0" max="100" value="80">
            </div>
        </div>

        <div class="info">
            <strong>Fish Schooling with Attraction and Repulsion Zones</strong><br>
            Fish maintain cohesive schools through three zones: repulsion (avoid collisions), attraction (stay together),
            and alignment (match neighbor velocities). This emergent behavior provides protection from predators and
            improves foraging efficiency without requiring centralized coordination.
        </div>

        <div class="metrics">
            <div class="metric">
                <div class="metric-value" id="fishCount">0</div>
                <div class="metric-label">Fish</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="cohesion">0%</div>
                <div class="metric-label">School Cohesion</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="avgSpeed">0</div>
                <div class="metric-label">Avg Speed</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="alignment">0%</div>
                <div class="metric-label">Alignment</div>
            </div>
        </div>
    </div>

    <script src="../assets/js/demo-utils.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const fps = new FPSCounter({ position: 'top-right' });
        const errorMgr = new ErrorManager();
        setupGlobalErrorHandler((msg, details) => errorMgr.show(msg, details));
        fps.start();

        let isPaused = false;

        // Behavioral parameters
        let cohesionStrength = 0.5;
        let separationStrength = 0.8;
        const alignmentStrength = 0.3;

        // Zones
        const repulsionRadius = 25;
        const attractionRadius = 100;
        const alignmentRadius = 50;

        class Fish {
            constructor(x, y) {
                this.x = x || Math.random() * canvas.width;
                this.y = y || Math.random() * canvas.height;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.maxSpeed = 3;
                this.maxForce = 0.1;
                this.size = 6;
                this.hue = 180 + Math.random() * 40;
            }

            update(fish, predators) {
                // Initialize forces
                let separationForce = { x: 0, y: 0 };
                let alignmentForce = { x: 0, y: 0 };
                let cohesionForce = { x: 0, y: 0 };

                let separationCount = 0;
                let alignmentCount = 0;
                let cohesionCount = 0;

                // Calculate forces from neighbors
                for (const other of fish) {
                    if (other === this) continue;

                    const dx = this.x - other.x;
                    const dy = this.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < repulsionRadius && dist > 0) {
                        // Separation: steer away from close neighbors
                        separationForce.x += dx / dist;
                        separationForce.y += dy / dist;
                        separationCount++;
                    }

                    if (dist < alignmentRadius && dist > 0) {
                        // Alignment: match velocity of neighbors
                        alignmentForce.x += other.vx;
                        alignmentForce.y += other.vy;
                        alignmentCount++;
                    }

                    if (dist < attractionRadius && dist > 0) {
                        // Cohesion: steer toward center of neighbors
                        cohesionForce.x += other.x;
                        cohesionForce.y += other.y;
                        cohesionCount++;
                    }
                }

                // Average forces
                if (separationCount > 0) {
                    separationForce.x /= separationCount;
                    separationForce.y /= separationCount;
                    this.applyForce(separationForce.x * separationStrength, separationForce.y * separationStrength);
                }

                if (alignmentCount > 0) {
                    alignmentForce.x /= alignmentCount;
                    alignmentForce.y /= alignmentCount;
                    // Desired velocity
                    const dx = alignmentForce.x - this.vx;
                    const dy = alignmentForce.y - this.vy;
                    this.applyForce(dx * alignmentStrength, dy * alignmentStrength);
                }

                if (cohesionCount > 0) {
                    cohesionForce.x /= cohesionCount;
                    cohesionForce.y /= cohesionCount;
                    // Steer toward center
                    const dx = cohesionForce.x - this.x;
                    const dy = cohesionForce.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        this.applyForce((dx / dist) * cohesionStrength * 0.1, (dy / dist) * cohesionStrength * 0.1);
                    }
                }

                // Avoid predators
                for (const predator of predators) {
                    const dx = this.x - predator.x;
                    const dy = this.y - predator.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 150 && dist > 0) {
                        const panicForce = 200 / dist;
                        this.applyForce((dx / dist) * panicForce * 0.01, (dy / dist) * panicForce * 0.01);
                    }
                }

                // Limit speed
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > this.maxSpeed) {
                    this.vx = (this.vx / speed) * this.maxSpeed;
                    this.vy = (this.vy / speed) * this.maxSpeed;
                }

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Wrap around edges
                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
            }

            applyForce(fx, fy) {
                // Limit force
                const forceMag = Math.sqrt(fx * fx + fy * fy);
                if (forceMag > this.maxForce) {
                    fx = (fx / forceMag) * this.maxForce;
                    fy = (fy / forceMag) * this.maxForce;
                }

                this.vx += fx;
                this.vy += fy;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                const angle = Math.atan2(this.vy, this.vx);
                ctx.rotate(angle);

                // Draw fish body
                ctx.fillStyle = `hsl(${this.hue}, 80%, 60%)`;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size, this.size * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Draw tail
                ctx.fillStyle = `hsl(${this.hue}, 70%, 50%)`;
                ctx.beginPath();
                ctx.moveTo(-this.size, 0);
                ctx.lineTo(-this.size * 1.5, -this.size * 0.5);
                ctx.lineTo(-this.size * 1.5, this.size * 0.5);
                ctx.closePath();
                ctx.fill();

                // Draw eye
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(this.size * 0.4, 0, 1.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class Predator {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.maxSpeed = 2.5;
                this.size = 12;
            }

            update(fish) {
                // Chase nearest fish
                let nearestDist = Infinity;
                let nearestFish = null;

                for (const f of fish) {
                    const dx = f.x - this.x;
                    const dy = f.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestFish = f;
                    }
                }

                if (nearestFish && nearestDist < 200) {
                    const dx = nearestFish.x - this.x;
                    const dy = nearestFish.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    this.vx += (dx / dist) * 0.05;
                    this.vy += (dy / dist) * 0.05;
                }

                // Limit speed
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > this.maxSpeed) {
                    this.vx = (this.vx / speed) * this.maxSpeed;
                    this.vy = (this.vy / speed) * this.maxSpeed;
                }

                this.x += this.vx;
                this.y += this.vy;

                // Wrap around
                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                const angle = Math.atan2(this.vy, this.vx);
                ctx.rotate(angle);

                // Draw predator body (shark-like)
                ctx.fillStyle = '#FF5722';
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size, this.size * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Draw fin
                ctx.fillStyle = '#E64A19';
                ctx.beginPath();
                ctx.moveTo(0, -this.size * 0.5);
                ctx.lineTo(this.size * 0.3, -this.size * 1.2);
                ctx.lineTo(this.size * 0.6, -this.size * 0.5);
                ctx.fill();

                // Draw tail
                ctx.fillStyle = '#E64A19';
                ctx.beginPath();
                ctx.moveTo(-this.size, 0);
                ctx.lineTo(-this.size * 1.8, -this.size * 0.7);
                ctx.lineTo(-this.size * 1.8, this.size * 0.7);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }
        }

        const fish = [];
        const predators = [];

        function initFish() {
            fish.length = 0;
            predators.length = 0;

            for (let i = 0; i < 60; i++) {
                fish.push(new Fish());
            }
        }

        function calculateMetrics() {
            if (fish.length === 0) return;

            // Cohesion - average distance from center
            let centerX = 0, centerY = 0;
            for (const f of fish) {
                centerX += f.x;
                centerY += f.y;
            }
            centerX /= fish.length;
            centerY /= fish.length;

            let avgDist = 0;
            for (const f of fish) {
                const dx = f.x - centerX;
                const dy = f.y - centerY;
                avgDist += Math.sqrt(dx * dx + dy * dy);
            }
            avgDist /= fish.length;

            const cohesion = Math.max(0, 100 - (avgDist / 2));
            document.getElementById('cohesion').textContent = cohesion.toFixed(0) + '%';

            // Average speed
            let avgSpeed = 0;
            for (const f of fish) {
                avgSpeed += Math.sqrt(f.vx * f.vx + f.vy * f.vy);
            }
            avgSpeed /= fish.length;
            document.getElementById('avgSpeed').textContent = avgSpeed.toFixed(2);

            // Alignment - how similar are velocities
            let avgVx = 0, avgVy = 0;
            for (const f of fish) {
                avgVx += f.vx;
                avgVy += f.vy;
            }
            avgVx /= fish.length;
            avgVy /= fish.length;

            let alignment = 0;
            for (const f of fish) {
                const dot = f.vx * avgVx + f.vy * avgVy;
                const mag1 = Math.sqrt(f.vx * f.vx + f.vy * f.vy);
                const mag2 = Math.sqrt(avgVx * avgVx + avgVy * avgVy);
                if (mag1 > 0 && mag2 > 0) {
                    alignment += dot / (mag1 * mag2);
                }
            }
            alignment = ((alignment / fish.length) * 100);
            document.getElementById('alignment').textContent = alignment.toFixed(0) + '%';

            document.getElementById('fishCount').textContent = fish.length;
        }

        function animate() {
            fps.update();
            if (!isPaused) {
                // Semi-transparent fill for trail effect
                ctx.fillStyle = 'rgba(0, 26, 51, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Update
                predators.forEach(p => p.update(fish));
                fish.forEach(f => f.update(fish, predators));

                // Draw
                fish.forEach(f => f.draw());
                predators.forEach(p => p.draw());

                calculateMetrics();
            }

            requestAnimationFrame(animate);
        }

        document.getElementById('pauseBtn').addEventListener('click', function() {
            isPaused = !isPaused;
            this.textContent = isPaused ? 'Resume' : 'Pause';
        });

        document.getElementById('resetBtn').addEventListener('click', initFish);

        document.getElementById('predatorBtn').addEventListener('click', () => {
            predators.push(new Predator(
                Math.random() * canvas.width,
                Math.random() * canvas.height
            ));
        });

        document.getElementById('cohesionSlider').addEventListener('input', function() {
            cohesionStrength = parseInt(this.value) / 100;
        });

        document.getElementById('separationSlider').addEventListener('input', function() {
            separationStrength = parseInt(this.value) / 100;
        });

        initFish();
        animate();
    </script>
</body>
</html>