<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emergence Principles - From Simple Rules to Complex Patterns</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #1a0a2e 0%, #16213e 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: #fff;
        }
        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            color: #ff6b9d;
            text-decoration: none;
            font-size: 14px;
            z-index: 100;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            padding: 20px 0;
        }
        h1 {
            font-size: 2rem;
            background: linear-gradient(90deg, #ff6b9d, #c44dff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { color: #888; margin-top: 5px; }
        .demos-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .demo-card {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .demo-card h3 {
            color: #ff6b9d;
            margin-bottom: 10px;
            font-size: 1rem;
        }
        .demo-card canvas {
            width: 100%;
            border-radius: 8px;
            background: #000;
        }
        .demo-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .demo-controls button {
            padding: 8px 15px;
            background: rgba(255,107,157,0.2);
            border: 1px solid #ff6b9d;
            color: #ff6b9d;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85rem;
        }
        .demo-controls button:hover {
            background: rgba(255,107,157,0.4);
        }
        .demo-info {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255,107,157,0.1);
            border-radius: 5px;
            font-size: 0.85rem;
            line-height: 1.4;
        }
        .principle {
            color: #c44dff;
            font-weight: bold;
        }
        .stats-bar {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.8rem;
            color: #888;
        }
        .summary-section {
            margin-top: 30px;
            padding: 20px;
            background: rgba(196,77,255,0.1);
            border-radius: 12px;
            border: 1px solid rgba(196,77,255,0.3);
        }
        .summary-section h2 {
            color: #c44dff;
            margin-bottom: 15px;
        }
        .principles-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
        }
        .principle-item {
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }
        .principle-item h4 {
            color: #ff6b9d;
            margin-bottom: 8px;
        }
        .principle-item p {
            font-size: 0.85rem;
            color: #aaa;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>

    <div class="container">
        <header>
            <h1>Emergence Principles</h1>
            <p class="subtitle">How Simple Local Rules Create Complex Global Patterns</p>
        </header>

        <div class="demos-grid">
            <!-- Demo 1: Termite Wood Chips -->
            <div class="demo-card">
                <h3>1. Termite Wood Chip Clustering</h3>
                <canvas id="termiteCanvas" width="300" height="300"></canvas>
                <div class="demo-controls">
                    <button onclick="resetTermites()">Reset</button>
                    <button onclick="toggleTermites()">Pause</button>
                </div>
                <div class="demo-info">
                    <span class="principle">Principle: Stigmergy</span><br>
                    Termites follow two rules: pick up chip if alone, drop if near others.
                    No global coordination - piles emerge from local interactions.
                </div>
                <div class="stats-bar">
                    <span>Termites: 50</span>
                    <span>Chips: <span id="termiteChips">200</span></span>
                    <span>Piles: <span id="termitePiles">0</span></span>
                </div>
            </div>

            <!-- Demo 2: Schelling Segregation -->
            <div class="demo-card">
                <h3>2. Schelling Segregation</h3>
                <canvas id="schellingCanvas" width="300" height="300"></canvas>
                <div class="demo-controls">
                    <button onclick="resetSchelling()">Reset</button>
                    <button onclick="toggleSchelling()">Pause</button>
                </div>
                <div class="demo-info">
                    <span class="principle">Principle: Micro→Macro Amplification</span><br>
                    Agents move if <30% neighbors are similar. Mild preferences create strong segregation.
                </div>
                <div class="stats-bar">
                    <span>Threshold: 30%</span>
                    <span>Segregation: <span id="schellingIndex">0</span>%</span>
                </div>
            </div>

            <!-- Demo 3: Traffic Jam -->
            <div class="demo-card">
                <h3>3. Phantom Traffic Jams</h3>
                <canvas id="trafficCanvas" width="300" height="300"></canvas>
                <div class="demo-controls">
                    <button onclick="resetTraffic()">Reset</button>
                    <button onclick="toggleTraffic()">Pause</button>
                    <button onclick="brakeCar()">Brake!</button>
                </div>
                <div class="demo-info">
                    <span class="principle">Principle: Backward Wave Propagation</span><br>
                    One car brakes → wave travels backward through traffic.
                    Jam persists even after cause is gone.
                </div>
                <div class="stats-bar">
                    <span>Cars: 40</span>
                    <span>Avg Speed: <span id="trafficSpeed">0</span></span>
                </div>
            </div>

            <!-- Demo 4: Vicsek Flocking -->
            <div class="demo-card">
                <h3>4. Vicsek Model - Order from Noise</h3>
                <canvas id="vicsekCanvas" width="300" height="300"></canvas>
                <div class="demo-controls">
                    <button onclick="resetVicsek()">Reset</button>
                    <button onclick="toggleVicsek()">Pause</button>
                </div>
                <div class="demo-info">
                    <span class="principle">Principle: Phase Transition</span><br>
                    Particles align with neighbors + noise. Below critical noise: ordered motion.
                    Above: disorder. Sharp transition between phases.
                </div>
                <div class="stats-bar">
                    <span>Particles: 200</span>
                    <span>Order: <span id="vicsekOrder">0</span>%</span>
                </div>
            </div>

            <!-- Demo 5: Majority Rule -->
            <div class="demo-card">
                <h3>5. Majority Rule Consensus</h3>
                <canvas id="majorityCanvas" width="300" height="300"></canvas>
                <div class="demo-controls">
                    <button onclick="resetMajority()">Reset</button>
                    <button onclick="toggleMajority()">Pause</button>
                </div>
                <div class="demo-info">
                    <span class="principle">Principle: Local Majority → Global Consensus</span><br>
                    Each cell adopts majority state of neighbors.
                    Random start → domains form → one color wins.
                </div>
                <div class="stats-bar">
                    <span>Red: <span id="majorityRed">50</span>%</span>
                    <span>Blue: <span id="majorityBlue">50</span>%</span>
                </div>
            </div>

            <!-- Demo 6: Wealth Distribution -->
            <div class="demo-card">
                <h3>6. Wealth Inequality Emergence</h3>
                <canvas id="wealthCanvas" width="300" height="300"></canvas>
                <div class="demo-controls">
                    <button onclick="resetWealth()">Reset</button>
                    <button onclick="toggleWealth()">Pause</button>
                </div>
                <div class="demo-info">
                    <span class="principle">Principle: Matthew Effect</span><br>
                    Random fair trades between equal agents → extreme inequality emerges.
                    "The rich get richer" from pure chance.
                </div>
                <div class="stats-bar">
                    <span>Agents: 100</span>
                    <span>Gini: <span id="wealthGini">0</span></span>
                </div>
            </div>
        </div>

        <div class="summary-section">
            <h2>Key Principles of Emergence</h2>
            <div class="principles-list">
                <div class="principle-item">
                    <h4>1. No Central Control</h4>
                    <p>Complex patterns arise without any leader, planner, or global knowledge. Each agent follows only local rules.</p>
                </div>
                <div class="principle-item">
                    <h4>2. Simple Rules, Complex Results</h4>
                    <p>A few simple rules can generate infinite complexity. The whole is greater than the sum of parts.</p>
                </div>
                <div class="principle-item">
                    <h4>3. Positive Feedback Loops</h4>
                    <p>Small fluctuations get amplified. Random advantages compound. Initial conditions matter.</p>
                </div>
                <div class="principle-item">
                    <h4>4. Phase Transitions</h4>
                    <p>Systems can flip suddenly between qualitatively different states at critical thresholds.</p>
                </div>
                <div class="principle-item">
                    <h4>5. Stigmergy</h4>
                    <p>Agents communicate indirectly through the environment. Traces and marks coordinate behavior.</p>
                </div>
                <div class="principle-item">
                    <h4>6. Robustness</h4>
                    <p>Emergent systems are fault-tolerant. Remove some agents and the pattern persists or reforms.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============ TERMITE SIMULATION ============
        const termiteCanvas = document.getElementById('termiteCanvas');
        const termiteCtx = termiteCanvas.getContext('2d');
        let termitePaused = false;

        const TERMITE_GRID = 60;
        const TERMITE_CELL = termiteCanvas.width / TERMITE_GRID;
        let termiteGrid = [];
        let termites = [];

        function initTermites() {
            termiteGrid = Array(TERMITE_GRID).fill().map(() => Array(TERMITE_GRID).fill(0));
            termites = [];

            // Scatter wood chips
            for (let i = 0; i < 200; i++) {
                const x = Math.floor(Math.random() * TERMITE_GRID);
                const y = Math.floor(Math.random() * TERMITE_GRID);
                termiteGrid[y][x] = 1;
            }

            // Create termites
            for (let i = 0; i < 50; i++) {
                termites.push({
                    x: Math.floor(Math.random() * TERMITE_GRID),
                    y: Math.floor(Math.random() * TERMITE_GRID),
                    carrying: false,
                    dir: Math.floor(Math.random() * 4)
                });
            }
        }

        function updateTermites() {
            const dx = [0, 1, 0, -1];
            const dy = [-1, 0, 1, 0];

            termites.forEach(t => {
                // Random turn
                if (Math.random() < 0.3) {
                    t.dir = (t.dir + (Math.random() < 0.5 ? 1 : 3)) % 4;
                }

                // Move
                t.x = (t.x + dx[t.dir] + TERMITE_GRID) % TERMITE_GRID;
                t.y = (t.y + dy[t.dir] + TERMITE_GRID) % TERMITE_GRID;

                // Count nearby chips
                let nearby = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const nx = (t.x + dx + TERMITE_GRID) % TERMITE_GRID;
                        const ny = (t.y + dy + TERMITE_GRID) % TERMITE_GRID;
                        if (termiteGrid[ny][nx] === 1) nearby++;
                    }
                }

                if (!t.carrying && termiteGrid[t.y][t.x] === 1 && nearby < 3) {
                    // Pick up chip if isolated
                    termiteGrid[t.y][t.x] = 0;
                    t.carrying = true;
                } else if (t.carrying && termiteGrid[t.y][t.x] === 0 && nearby > 2) {
                    // Drop chip near others
                    termiteGrid[t.y][t.x] = 1;
                    t.carrying = false;
                }
            });
        }

        function countTermitePiles() {
            let piles = 0;
            const visited = Array(TERMITE_GRID).fill().map(() => Array(TERMITE_GRID).fill(false));

            function flood(x, y) {
                if (x < 0 || x >= TERMITE_GRID || y < 0 || y >= TERMITE_GRID) return 0;
                if (visited[y][x] || termiteGrid[y][x] === 0) return 0;
                visited[y][x] = true;
                return 1 + flood(x+1,y) + flood(x-1,y) + flood(x,y+1) + flood(x,y-1);
            }

            for (let y = 0; y < TERMITE_GRID; y++) {
                for (let x = 0; x < TERMITE_GRID; x++) {
                    if (termiteGrid[y][x] === 1 && !visited[y][x]) {
                        const size = flood(x, y);
                        if (size > 5) piles++;
                    }
                }
            }
            return piles;
        }

        function renderTermites() {
            termiteCtx.fillStyle = '#1a0a2e';
            termiteCtx.fillRect(0, 0, termiteCanvas.width, termiteCanvas.height);

            // Draw chips
            termiteCtx.fillStyle = '#8B4513';
            for (let y = 0; y < TERMITE_GRID; y++) {
                for (let x = 0; x < TERMITE_GRID; x++) {
                    if (termiteGrid[y][x] === 1) {
                        termiteCtx.fillRect(x * TERMITE_CELL, y * TERMITE_CELL, TERMITE_CELL - 1, TERMITE_CELL - 1);
                    }
                }
            }

            // Draw termites
            termites.forEach(t => {
                termiteCtx.fillStyle = t.carrying ? '#ff6b9d' : '#ffffff';
                termiteCtx.beginPath();
                termiteCtx.arc(t.x * TERMITE_CELL + TERMITE_CELL/2, t.y * TERMITE_CELL + TERMITE_CELL/2, TERMITE_CELL/2, 0, Math.PI * 2);
                termiteCtx.fill();
            });

            document.getElementById('termitePiles').textContent = countTermitePiles();
        }

        function resetTermites() { initTermites(); }
        function toggleTermites() { termitePaused = !termitePaused; }

        // ============ SCHELLING SEGREGATION ============
        const schellingCanvas = document.getElementById('schellingCanvas');
        const schellingCtx = schellingCanvas.getContext('2d');
        let schellingPaused = false;

        const SCHELLING_GRID = 50;
        const SCHELLING_CELL = schellingCanvas.width / SCHELLING_GRID;
        let schellingGrid = [];

        function initSchelling() {
            schellingGrid = Array(SCHELLING_GRID).fill().map(() =>
                Array(SCHELLING_GRID).fill().map(() => {
                    const r = Math.random();
                    if (r < 0.45) return 1; // Red
                    if (r < 0.9) return 2;  // Blue
                    return 0; // Empty
                })
            );
        }

        function updateSchelling() {
            const unhappy = [];

            // Find unhappy agents
            for (let y = 0; y < SCHELLING_GRID; y++) {
                for (let x = 0; x < SCHELLING_GRID; x++) {
                    if (schellingGrid[y][x] === 0) continue;

                    let same = 0, diff = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = x + dx, ny = y + dy;
                            if (nx < 0 || nx >= SCHELLING_GRID || ny < 0 || ny >= SCHELLING_GRID) continue;
                            if (schellingGrid[ny][nx] === schellingGrid[y][x]) same++;
                            else if (schellingGrid[ny][nx] !== 0) diff++;
                        }
                    }

                    if (same + diff > 0 && same / (same + diff) < 0.3) {
                        unhappy.push({x, y});
                    }
                }
            }

            // Move some unhappy agents
            const empties = [];
            for (let y = 0; y < SCHELLING_GRID; y++) {
                for (let x = 0; x < SCHELLING_GRID; x++) {
                    if (schellingGrid[y][x] === 0) empties.push({x, y});
                }
            }

            for (let i = 0; i < Math.min(10, unhappy.length); i++) {
                if (empties.length === 0) break;
                const agent = unhappy[Math.floor(Math.random() * unhappy.length)];
                const emptyIdx = Math.floor(Math.random() * empties.length);
                const empty = empties[emptyIdx];

                schellingGrid[empty.y][empty.x] = schellingGrid[agent.y][agent.x];
                schellingGrid[agent.y][agent.x] = 0;
                empties.splice(emptyIdx, 1);
                empties.push(agent);
            }
        }

        function calculateSegregation() {
            let totalSame = 0, totalNeighbors = 0;

            for (let y = 0; y < SCHELLING_GRID; y++) {
                for (let x = 0; x < SCHELLING_GRID; x++) {
                    if (schellingGrid[y][x] === 0) continue;

                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = x + dx, ny = y + dy;
                            if (nx < 0 || nx >= SCHELLING_GRID || ny < 0 || ny >= SCHELLING_GRID) continue;
                            if (schellingGrid[ny][nx] !== 0) {
                                totalNeighbors++;
                                if (schellingGrid[ny][nx] === schellingGrid[y][x]) totalSame++;
                            }
                        }
                    }
                }
            }

            return totalNeighbors > 0 ? Math.round(totalSame / totalNeighbors * 100) : 50;
        }

        function renderSchelling() {
            schellingCtx.fillStyle = '#1a0a2e';
            schellingCtx.fillRect(0, 0, schellingCanvas.width, schellingCanvas.height);

            for (let y = 0; y < SCHELLING_GRID; y++) {
                for (let x = 0; x < SCHELLING_GRID; x++) {
                    if (schellingGrid[y][x] === 1) {
                        schellingCtx.fillStyle = '#ff4444';
                    } else if (schellingGrid[y][x] === 2) {
                        schellingCtx.fillStyle = '#4444ff';
                    } else {
                        continue;
                    }
                    schellingCtx.fillRect(x * SCHELLING_CELL, y * SCHELLING_CELL, SCHELLING_CELL - 1, SCHELLING_CELL - 1);
                }
            }

            document.getElementById('schellingIndex').textContent = calculateSegregation();
        }

        function resetSchelling() { initSchelling(); }
        function toggleSchelling() { schellingPaused = !schellingPaused; }

        // ============ TRAFFIC SIMULATION ============
        const trafficCanvas = document.getElementById('trafficCanvas');
        const trafficCtx = trafficCanvas.getContext('2d');
        let trafficPaused = false;

        const TRACK_RADIUS = 120;
        const NUM_CARS = 40;
        let cars = [];

        function initTraffic() {
            cars = [];
            for (let i = 0; i < NUM_CARS; i++) {
                cars.push({
                    angle: (i / NUM_CARS) * Math.PI * 2,
                    speed: 0.02,
                    maxSpeed: 0.025
                });
            }
        }

        function updateTraffic() {
            cars.forEach((car, i) => {
                const nextCar = cars[(i + 1) % NUM_CARS];
                let gap = nextCar.angle - car.angle;
                if (gap < 0) gap += Math.PI * 2;

                const safeGap = 0.15;
                if (gap < safeGap) {
                    car.speed = Math.max(0, car.speed - 0.002);
                } else {
                    car.speed = Math.min(car.maxSpeed, car.speed + 0.001);
                }

                car.angle += car.speed;
                if (car.angle > Math.PI * 2) car.angle -= Math.PI * 2;
            });
        }

        function brakeCar() {
            if (cars.length > 0) {
                cars[0].speed = 0;
            }
        }

        function renderTraffic() {
            const cx = trafficCanvas.width / 2;
            const cy = trafficCanvas.height / 2;

            trafficCtx.fillStyle = '#1a0a2e';
            trafficCtx.fillRect(0, 0, trafficCanvas.width, trafficCanvas.height);

            // Draw track
            trafficCtx.strokeStyle = '#333';
            trafficCtx.lineWidth = 25;
            trafficCtx.beginPath();
            trafficCtx.arc(cx, cy, TRACK_RADIUS, 0, Math.PI * 2);
            trafficCtx.stroke();

            // Draw cars
            let totalSpeed = 0;
            cars.forEach(car => {
                const x = cx + Math.cos(car.angle) * TRACK_RADIUS;
                const y = cy + Math.sin(car.angle) * TRACK_RADIUS;

                const hue = (car.speed / car.maxSpeed) * 120;
                trafficCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                trafficCtx.beginPath();
                trafficCtx.arc(x, y, 6, 0, Math.PI * 2);
                trafficCtx.fill();

                totalSpeed += car.speed;
            });

            document.getElementById('trafficSpeed').textContent = (totalSpeed / cars.length * 1000).toFixed(1);
        }

        function resetTraffic() { initTraffic(); }
        function toggleTraffic() { trafficPaused = !trafficPaused; }

        // ============ VICSEK MODEL ============
        const vicsekCanvas = document.getElementById('vicsekCanvas');
        const vicsekCtx = vicsekCanvas.getContext('2d');
        let vicsekPaused = false;

        const NUM_PARTICLES = 200;
        const VICSEK_RADIUS = 20;
        const NOISE = 0.3;
        let particles = [];

        function initVicsek() {
            particles = [];
            for (let i = 0; i < NUM_PARTICLES; i++) {
                particles.push({
                    x: Math.random() * vicsekCanvas.width,
                    y: Math.random() * vicsekCanvas.height,
                    angle: Math.random() * Math.PI * 2,
                    speed: 2
                });
            }
        }

        function updateVicsek() {
            const newAngles = [];

            particles.forEach((p, i) => {
                let sumSin = 0, sumCos = 0, count = 0;

                particles.forEach((other, j) => {
                    const dx = other.x - p.x;
                    const dy = other.y - p.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist < VICSEK_RADIUS) {
                        sumSin += Math.sin(other.angle);
                        sumCos += Math.cos(other.angle);
                        count++;
                    }
                });

                const avgAngle = Math.atan2(sumSin, sumCos);
                newAngles[i] = avgAngle + (Math.random() - 0.5) * NOISE * Math.PI * 2;
            });

            particles.forEach((p, i) => {
                p.angle = newAngles[i];
                p.x += Math.cos(p.angle) * p.speed;
                p.y += Math.sin(p.angle) * p.speed;

                // Wrap
                if (p.x < 0) p.x += vicsekCanvas.width;
                if (p.x > vicsekCanvas.width) p.x -= vicsekCanvas.width;
                if (p.y < 0) p.y += vicsekCanvas.height;
                if (p.y > vicsekCanvas.height) p.y -= vicsekCanvas.height;
            });
        }

        function calculateOrder() {
            let sumSin = 0, sumCos = 0;
            particles.forEach(p => {
                sumSin += Math.sin(p.angle);
                sumCos += Math.cos(p.angle);
            });
            const order = Math.sqrt(sumSin*sumSin + sumCos*sumCos) / particles.length;
            return Math.round(order * 100);
        }

        function renderVicsek() {
            vicsekCtx.fillStyle = 'rgba(26, 10, 46, 0.3)';
            vicsekCtx.fillRect(0, 0, vicsekCanvas.width, vicsekCanvas.height);

            particles.forEach(p => {
                const hue = (p.angle / (Math.PI * 2)) * 360;
                vicsekCtx.fillStyle = `hsl(${hue}, 80%, 60%)`;
                vicsekCtx.beginPath();
                vicsekCtx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                vicsekCtx.fill();
            });

            document.getElementById('vicsekOrder').textContent = calculateOrder();
        }

        function resetVicsek() { initVicsek(); }
        function toggleVicsek() { vicsekPaused = !vicsekPaused; }

        // ============ MAJORITY RULE ============
        const majorityCanvas = document.getElementById('majorityCanvas');
        const majorityCtx = majorityCanvas.getContext('2d');
        let majorityPaused = false;

        const MAJORITY_GRID = 100;
        const MAJORITY_CELL = majorityCanvas.width / MAJORITY_GRID;
        let majorityGrid = [];

        function initMajority() {
            majorityGrid = Array(MAJORITY_GRID).fill().map(() =>
                Array(MAJORITY_GRID).fill().map(() => Math.random() < 0.5 ? 0 : 1)
            );
        }

        function updateMajority() {
            const newGrid = majorityGrid.map(row => [...row]);

            for (let y = 0; y < MAJORITY_GRID; y++) {
                for (let x = 0; x < MAJORITY_GRID; x++) {
                    let count0 = 0, count1 = 0;

                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nx = (x + dx + MAJORITY_GRID) % MAJORITY_GRID;
                            const ny = (y + dy + MAJORITY_GRID) % MAJORITY_GRID;
                            if (majorityGrid[ny][nx] === 0) count0++;
                            else count1++;
                        }
                    }

                    newGrid[y][x] = count1 > count0 ? 1 : (count0 > count1 ? 0 : majorityGrid[y][x]);
                }
            }

            majorityGrid = newGrid;
        }

        function renderMajority() {
            let red = 0, blue = 0;

            for (let y = 0; y < MAJORITY_GRID; y++) {
                for (let x = 0; x < MAJORITY_GRID; x++) {
                    majorityCtx.fillStyle = majorityGrid[y][x] === 0 ? '#ff4444' : '#4444ff';
                    majorityCtx.fillRect(x * MAJORITY_CELL, y * MAJORITY_CELL, MAJORITY_CELL, MAJORITY_CELL);
                    if (majorityGrid[y][x] === 0) red++;
                    else blue++;
                }
            }

            const total = MAJORITY_GRID * MAJORITY_GRID;
            document.getElementById('majorityRed').textContent = Math.round(red / total * 100);
            document.getElementById('majorityBlue').textContent = Math.round(blue / total * 100);
        }

        function resetMajority() { initMajority(); }
        function toggleMajority() { majorityPaused = !majorityPaused; }

        // ============ WEALTH DISTRIBUTION ============
        const wealthCanvas = document.getElementById('wealthCanvas');
        const wealthCtx = wealthCanvas.getContext('2d');
        let wealthPaused = false;

        const NUM_AGENTS = 100;
        let agents = [];

        function initWealth() {
            agents = Array(NUM_AGENTS).fill(100); // Equal starting wealth
        }

        function updateWealth() {
            for (let i = 0; i < 50; i++) {
                const a = Math.floor(Math.random() * NUM_AGENTS);
                const b = Math.floor(Math.random() * NUM_AGENTS);
                if (a === b) continue;

                const transfer = Math.min(agents[a], agents[b], 1);
                if (Math.random() < 0.5) {
                    agents[a] += transfer;
                    agents[b] -= transfer;
                } else {
                    agents[a] -= transfer;
                    agents[b] += transfer;
                }
            }
        }

        function calculateGini() {
            const sorted = [...agents].sort((a, b) => a - b);
            const n = sorted.length;
            let sumNumerator = 0;

            for (let i = 0; i < n; i++) {
                sumNumerator += (2 * (i + 1) - n - 1) * sorted[i];
            }

            const mean = sorted.reduce((a, b) => a + b, 0) / n;
            const gini = sumNumerator / (n * n * mean);
            return gini.toFixed(3);
        }

        function renderWealth() {
            wealthCtx.fillStyle = '#1a0a2e';
            wealthCtx.fillRect(0, 0, wealthCanvas.width, wealthCanvas.height);

            const sorted = [...agents].sort((a, b) => b - a);
            const maxWealth = Math.max(...sorted);
            const barWidth = wealthCanvas.width / NUM_AGENTS;

            sorted.forEach((wealth, i) => {
                const height = (wealth / maxWealth) * (wealthCanvas.height - 20);
                const hue = 120 - (wealth / maxWealth) * 120;
                wealthCtx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                wealthCtx.fillRect(i * barWidth, wealthCanvas.height - height, barWidth - 1, height);
            });

            document.getElementById('wealthGini').textContent = calculateGini();
        }

        function resetWealth() { initWealth(); }
        function toggleWealth() { wealthPaused = !wealthPaused; }

        // ============ MAIN LOOP ============
        function init() {
            initTermites();
            initSchelling();
            initTraffic();
            initVicsek();
            initMajority();
            initWealth();
        }

        function animate() {
            if (!termitePaused) { updateTermites(); }
            renderTermites();

            if (!schellingPaused) { updateSchelling(); }
            renderSchelling();

            if (!trafficPaused) { updateTraffic(); }
            renderTraffic();

            if (!vicsekPaused) { updateVicsek(); }
            renderVicsek();

            if (!majorityPaused) { updateMajority(); }
            renderMajority();

            if (!wealthPaused) { updateWealth(); }
            renderWealth();

            requestAnimationFrame(animate);
        }

        init();
        animate();
    </script>
</body>
</html>
