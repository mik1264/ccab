<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Swarm Optimization - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #e0e0e0;
        }
        h1 {
            font-size: 2em;
            margin-bottom: 10px;
            color: #00BCD4;
            text-align: center;
        }
        .container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        canvas {
            display: block;
            background: #0a0a0a;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 10px 20px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: #00BCD4;
            color: white;
            transition: background 0.3s;
        }
        button:hover {
            background: #0097A7;
        }
        button.secondary {
            background: #FF5722;
        }
        button.secondary:hover {
            background: #E64A19;
        }
        .info {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .metric {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #00BCD4;
        }
        .metric-label {
            font-size: 0.9em;
            color: #aaa;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            flex: 1;
            max-width: 200px;
        }
        .slider-label {
            min-width: 120px;
            font-size: 14px;
        }
        select {
            padding: 10px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            background: #333;
            color: white;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link" style="position:fixed;top:15px;left:15px;color:#fff;text-decoration:none;opacity:0.8;z-index:1000;">‚Üê Back</a>
    <h1>Particle Swarm Optimization</h1>

    <div class="container">
        <canvas id="canvas" width="800" height="600"></canvas>

        <div class="controls">
            <button id="pauseBtn">Pause</button>
            <button id="resetBtn" class="secondary">Reset</button>
            <select id="functionSelect">
                <option value="rastrigin">Rastrigin Function</option>
                <option value="ackley">Ackley Function</option>
                <option value="sphere">Sphere Function</option>
                <option value="rosenbrock">Rosenbrock Valley</option>
            </select>
            <div class="slider-container">
                <span class="slider-label">Inertia:</span>
                <input type="range" id="inertiaSlider" min="0" max="100" value="70">
                <span id="inertiaValue">0.7</span>
            </div>
        </div>

        <div class="info">
            <strong>Particle Swarm Optimization (PSO)</strong><br>
            An optimization algorithm inspired by bird flocking and fish schooling. Each particle explores the
            search space, remembering its best position and being influenced by the swarm's global best. This
            collective behavior emerges into an efficient optimization strategy for finding function minima.
        </div>

        <div class="metrics">
            <div class="metric">
                <div class="metric-value" id="particleCount">0</div>
                <div class="metric-label">Particles</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="globalBest">0</div>
                <div class="metric-label">Global Best</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="iterations">0</div>
                <div class="metric-label">Iterations</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="convergence">0%</div>
                <div class="metric-label">Convergence</div>
            </div>
        </div>
    </div>

    <script src="../assets/js/demo-utils.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const fps = new FPSCounter({ position: 'top-right' });
        const errorMgr = new ErrorManager();
        setupGlobalErrorHandler((msg, details) => errorMgr.show(msg, details));
        fps.start();

        let isPaused = false;
        let iterations = 0;

        // PSO parameters
        let inertia = 0.7;
        const cognitive = 1.5;
        const social = 1.5;

        // Search space
        const bounds = { min: -5, max: 5 };

        let currentFunction = 'rastrigin';

        // Fitness functions
        const functions = {
            rastrigin: (x, y) => {
                const A = 10;
                return 2 * A + (x * x - A * Math.cos(2 * Math.PI * x)) +
                       (y * y - A * Math.cos(2 * Math.PI * y));
            },
            ackley: (x, y) => {
                const a = 20;
                const b = 0.2;
                const c = 2 * Math.PI;
                return -a * Math.exp(-b * Math.sqrt(0.5 * (x * x + y * y))) -
                       Math.exp(0.5 * (Math.cos(c * x) + Math.cos(c * y))) + a + Math.E;
            },
            sphere: (x, y) => {
                return x * x + y * y;
            },
            rosenbrock: (x, y) => {
                const a = 1;
                const b = 100;
                return (a - x) * (a - x) + b * (y - x * x) * (y - x * x);
            }
        };

        function getFitness(x, y) {
            return functions[currentFunction](x, y);
        }

        // Convert world coordinates to canvas coordinates
        function worldToCanvas(wx, wy) {
            const x = ((wx - bounds.min) / (bounds.max - bounds.min)) * canvas.width;
            const y = ((wy - bounds.min) / (bounds.max - bounds.min)) * canvas.height;
            return { x, y };
        }

        function canvasToWorld(cx, cy) {
            const x = (cx / canvas.width) * (bounds.max - bounds.min) + bounds.min;
            const y = (cy / canvas.height) * (bounds.max - bounds.min) + bounds.min;
            return { x, y };
        }

        class Particle {
            constructor() {
                // Random position in search space
                this.x = Math.random() * (bounds.max - bounds.min) + bounds.min;
                this.y = Math.random() * (bounds.max - bounds.min) + bounds.min;

                // Random velocity
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;

                // Personal best
                this.bestX = this.x;
                this.bestY = this.y;
                this.bestFitness = getFitness(this.x, this.y);

                this.fitness = this.bestFitness;
            }

            update(globalBestX, globalBestY) {
                // Update velocity
                const r1 = Math.random();
                const r2 = Math.random();

                this.vx = inertia * this.vx +
                         cognitive * r1 * (this.bestX - this.x) +
                         social * r2 * (globalBestX - this.x);

                this.vy = inertia * this.vy +
                         cognitive * r1 * (this.bestY - this.y) +
                         social * r2 * (globalBestY - this.y);

                // Limit velocity
                const maxVel = 0.5;
                this.vx = Math.max(-maxVel, Math.min(maxVel, this.vx));
                this.vy = Math.max(-maxVel, Math.min(maxVel, this.vy));

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Clamp to bounds
                this.x = Math.max(bounds.min, Math.min(bounds.max, this.x));
                this.y = Math.max(bounds.min, Math.min(bounds.max, this.y));

                // Evaluate fitness
                this.fitness = getFitness(this.x, this.y);

                // Update personal best
                if (this.fitness < this.bestFitness) {
                    this.bestFitness = this.fitness;
                    this.bestX = this.x;
                    this.bestY = this.y;
                }
            }

            draw() {
                const pos = worldToCanvas(this.x, this.y);

                // Draw velocity vector
                ctx.strokeStyle = 'rgba(0, 188, 212, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x + this.vx * 50, pos.y + this.vy * 50);
                ctx.stroke();

                // Draw particle
                const intensity = 1 - Math.min(this.fitness / 50, 1);
                ctx.fillStyle = `rgba(0, 188, 212, ${0.5 + intensity * 0.5})`;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 4, 0, Math.PI * 2);
                ctx.fill();

                // Draw personal best
                const bestPos = worldToCanvas(this.bestX, this.bestY);
                ctx.fillStyle = 'rgba(255, 152, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(bestPos.x, bestPos.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        const particles = [];
        let globalBestX = 0;
        let globalBestY = 0;
        let globalBestFitness = Infinity;

        function initParticles() {
            particles.length = 0;
            globalBestFitness = Infinity;
            iterations = 0;

            for (let i = 0; i < 50; i++) {
                const particle = new Particle();
                particles.push(particle);

                if (particle.fitness < globalBestFitness) {
                    globalBestFitness = particle.fitness;
                    globalBestX = particle.x;
                    globalBestY = particle.y;
                }
            }
        }

        function drawFitnessLandscape() {
            const resolution = 20;
            const imageData = ctx.createImageData(canvas.width, canvas.height);

            for (let py = 0; py < canvas.height; py += resolution) {
                for (let px = 0; px < canvas.width; px += resolution) {
                    const world = canvasToWorld(px, py);
                    const fitness = getFitness(world.x, world.y);

                    // Normalize fitness for visualization
                    const normalized = Math.min(fitness / 50, 1);
                    const color = Math.floor((1 - normalized) * 150);

                    // Fill block
                    for (let dy = 0; dy < resolution && py + dy < canvas.height; dy++) {
                        for (let dx = 0; dx < resolution && px + dx < canvas.width; dx++) {
                            const idx = ((py + dy) * canvas.width + (px + dx)) * 4;
                            imageData.data[idx] = color * 0.3;
                            imageData.data[idx + 1] = color * 0.5;
                            imageData.data[idx + 2] = color;
                            imageData.data[idx + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function updateMetrics() {
            document.getElementById('particleCount').textContent = particles.length;
            document.getElementById('globalBest').textContent = globalBestFitness.toFixed(4);
            document.getElementById('iterations').textContent = iterations;

            // Calculate convergence (how close particles are to global best)
            let avgDistance = 0;
            particles.forEach(p => {
                const dx = p.x - globalBestX;
                const dy = p.y - globalBestY;
                avgDistance += Math.sqrt(dx * dx + dy * dy);
            });
            avgDistance /= particles.length;

            const maxDistance = Math.sqrt(2 * (bounds.max - bounds.min) * (bounds.max - bounds.min));
            const convergence = ((1 - avgDistance / maxDistance) * 100).toFixed(1);
            document.getElementById('convergence').textContent = convergence + '%';
        }

        function animate() {
            fps.update();
            if (!isPaused) {
                // Draw fitness landscape
                drawFitnessLandscape();

                // Update particles
                particles.forEach(particle => {
                    particle.update(globalBestX, globalBestY);

                    // Update global best
                    if (particle.fitness < globalBestFitness) {
                        globalBestFitness = particle.fitness;
                        globalBestX = particle.x;
                        globalBestY = particle.y;
                    }
                });

                // Draw particles
                particles.forEach(particle => particle.draw());

                // Draw global best
                const bestPos = worldToCanvas(globalBestX, globalBestY);
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.beginPath();
                ctx.arc(bestPos.x, bestPos.y, 8, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(bestPos.x, bestPos.y, 15, 0, Math.PI * 2);
                ctx.stroke();

                iterations++;
                updateMetrics();
            }

            requestAnimationFrame(animate);
        }

        document.getElementById('pauseBtn').addEventListener('click', function() {
            isPaused = !isPaused;
            this.textContent = isPaused ? 'Resume' : 'Pause';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            initParticles();
        });

        document.getElementById('inertiaSlider').addEventListener('input', function() {
            inertia = parseInt(this.value) / 100;
            document.getElementById('inertiaValue').textContent = inertia.toFixed(2);
        });

        document.getElementById('functionSelect').addEventListener('change', function() {
            currentFunction = this.value;
            initParticles();
        });

        initParticles();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>