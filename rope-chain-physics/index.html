<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rope & Chain Physics - Verlet Integration - CCAB</title>
    <meta name="description" content="Interactive rope and chain physics simulation using Verlet integration and constraint relaxation. Drag, swing, and watch realistic physics in action.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.6);
            color: #ff9800;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 152, 0, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(255, 152, 0, 0.2);
            transform: translateX(-4px);
        }

        #info {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            border-radius: 12px;
            color: #ff9800;
            font-size: 13px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 152, 0, 0.2);
            z-index: 1000;
            max-width: 280px;
        }

        #info h3 {
            margin-bottom: 10px;
            color: #fff;
        }

        #info .stat {
            margin: 5px 0;
        }

        #info .stat-label {
            color: #aaa;
            font-size: 11px;
        }

        #info .stat-value {
            color: #ff9800;
            font-weight: bold;
        }

        #info p {
            font-size: 11px;
            opacity: 0.8;
            line-height: 1.5;
            margin-top: 10px;
            color: #ddd;
        }

        #presets {
            position: fixed;
            top: 220px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }

        button {
            background: rgba(255, 152, 0, 0.15);
            border: 1px solid rgba(255, 152, 0, 0.4);
            color: #ff9800;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(255, 152, 0, 0.3);
        }

        button.active {
            background: rgba(255, 152, 0, 0.4);
            border-color: #ff9800;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 16px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 152, 0, 0.2);
        }

        .control-group label {
            color: #ff9800;
            font-size: 11px;
            display: block;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 100px;
            accent-color: #ff9800;
        }

        .control-group span {
            color: #fff;
            font-size: 10px;
            margin-left: 6px;
        }

        #fps-display {
            position: fixed;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 6px;
            color: #ff9800;
            font-size: 12px;
            z-index: 1000;
        }

        .instructions {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            color: #aaa;
            font-size: 12px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 152, 0, 0.2);
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>

    <canvas id="canvas"></canvas>

    <div id="info">
        <h3>Rope & Chain Physics</h3>
        <div class="stat">
            <span class="stat-label">Points</span>
            <span class="stat-value" id="points">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Ropes</span>
            <span class="stat-value" id="ropes">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Constraints</span>
            <span class="stat-value" id="constraints">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Iterations</span>
            <span class="stat-value" id="iterations">15</span>
        </div>
        <p>Verlet integration with constraint relaxation. Based on Thomas Jakobsen's "Advanced Character Physics" from GDC 2001.</p>
    </div>

    <div id="presets">
        <button class="active" data-preset="single">Single Rope</button>
        <button data-preset="chain">Heavy Chain</button>
        <button data-preset="web">Spider Web</button>
        <button data-preset="bridge">Rope Bridge</button>
        <button data-preset="curtain">Curtain</button>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>Gravity: <span id="grav-val">0.5</span></label>
            <input type="range" id="gravity" min="0" max="2" step="0.1" value="0.5">
        </div>
        <div class="control-group">
            <label>Damping: <span id="damp-val">0.99</span></label>
            <input type="range" id="damping" min="0.9" max="1" step="0.01" value="0.99">
        </div>
        <div class="control-group">
            <label>Iterations: <span id="iter-val">15</span></label>
            <input type="range" id="iters" min="1" max="50" step="1" value="15">
        </div>
        <div class="control-group">
            <label>Stiffness: <span id="stiff-val">1.0</span></label>
            <input type="range" id="stiffness" min="0.1" max="1" step="0.1" value="1">
        </div>
    </div>

    <div class="instructions">Click and drag to interact with the rope. Double-click to create a new anchor point.</div>

    <div id="fps-display">FPS: <span id="fps">0</span></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // DOM elements
        const pointsDisplay = document.getElementById('points');
        const ropesDisplay = document.getElementById('ropes');
        const constraintsDisplay = document.getElementById('constraints');
        const iterationsDisplay = document.getElementById('iterations');
        const fpsDisplay = document.getElementById('fps');

        // Configuration
        let config = {
            gravity: 0.5,
            damping: 0.99,
            iterations: 15,
            stiffness: 1.0,
            preset: 'single'
        };

        // Physics objects
        let points = [];
        let constraints = [];
        let ropeCount = 0;

        // Mouse state
        let mouseX = 0;
        let mouseY = 0;
        let isDragging = false;
        let dragPoint = null;

        // Point class using Verlet integration
        class Point {
            constructor(x, y, pinned = false, mass = 1) {
                this.x = x;
                this.y = y;
                this.prevX = x;
                this.prevY = y;
                this.pinned = pinned;
                this.mass = mass;
                this.radius = 4 + mass * 2;
            }

            update() {
                if (this.pinned) return;

                // Verlet integration: x_new = 2x - x_old + a*dt^2
                const vx = (this.x - this.prevX) * config.damping;
                const vy = (this.y - this.prevY) * config.damping;

                this.prevX = this.x;
                this.prevY = this.y;

                this.x += vx;
                this.y += vy + config.gravity;

                // Boundary collision
                if (this.x < this.radius) {
                    this.x = this.radius;
                    this.prevX = this.x + vx * 0.5;
                }
                if (this.x > canvas.width - this.radius) {
                    this.x = canvas.width - this.radius;
                    this.prevX = this.x + vx * 0.5;
                }
                if (this.y < this.radius) {
                    this.y = this.radius;
                    this.prevY = this.y + vy * 0.5;
                }
                if (this.y > canvas.height - this.radius) {
                    this.y = canvas.height - this.radius;
                    this.prevY = this.y + vy * 0.5;
                }
            }
        }

        // Constraint class (distance constraint)
        class Constraint {
            constructor(p1, p2, length = null, stiffness = 1) {
                this.p1 = p1;
                this.p2 = p2;
                this.length = length || Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
                this.stiffness = stiffness;
            }

            solve() {
                const dx = this.p2.x - this.p1.x;
                const dy = this.p2.y - this.p1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist === 0) return;

                const diff = (dist - this.length) / dist;
                const stiff = this.stiffness * config.stiffness;

                // Mass-weighted constraint correction
                const totalMass = this.p1.mass + this.p2.mass;
                const w1 = this.p1.pinned ? 0 : this.p2.mass / totalMass;
                const w2 = this.p2.pinned ? 0 : this.p1.mass / totalMass;

                if (!this.p1.pinned) {
                    this.p1.x += dx * diff * stiff * w1;
                    this.p1.y += dy * diff * stiff * w1;
                }
                if (!this.p2.pinned) {
                    this.p2.x -= dx * diff * stiff * w2;
                    this.p2.y -= dy * diff * stiff * w2;
                }
            }
        }

        // Create a rope
        function createRope(startX, startY, segments, segmentLength, pinStart = true, pinEnd = false, mass = 1) {
            const ropePoints = [];
            const ropeConstraints = [];

            for (let i = 0; i < segments; i++) {
                const pinned = (i === 0 && pinStart) || (i === segments - 1 && pinEnd);
                const point = new Point(
                    startX + i * segmentLength,
                    startY,
                    pinned,
                    mass
                );
                points.push(point);
                ropePoints.push(point);
            }

            for (let i = 0; i < ropePoints.length - 1; i++) {
                const constraint = new Constraint(ropePoints[i], ropePoints[i + 1], segmentLength);
                constraints.push(constraint);
                ropeConstraints.push(constraint);
            }

            ropeCount++;
            return { points: ropePoints, constraints: ropeConstraints };
        }

        // Create a hanging rope
        function createHangingRope(x, y, segments, segmentLength, mass = 1) {
            const ropePoints = [];
            const ropeConstraints = [];

            for (let i = 0; i < segments; i++) {
                const point = new Point(
                    x,
                    y + i * segmentLength,
                    i === 0,
                    mass
                );
                points.push(point);
                ropePoints.push(point);
            }

            for (let i = 0; i < ropePoints.length - 1; i++) {
                const constraint = new Constraint(ropePoints[i], ropePoints[i + 1], segmentLength);
                constraints.push(constraint);
                ropeConstraints.push(constraint);
            }

            ropeCount++;
            return { points: ropePoints, constraints: ropeConstraints };
        }

        // Initialize presets
        function initPreset(preset) {
            points = [];
            constraints = [];
            ropeCount = 0;

            const centerX = canvas.width / 2;
            const centerY = canvas.height * 0.15;

            switch (preset) {
                case 'single':
                    createHangingRope(centerX, centerY, 30, 15, 1);
                    break;

                case 'chain':
                    // Heavy chain with larger masses
                    const chainPoints = [];
                    for (let i = 0; i < 20; i++) {
                        const point = new Point(
                            centerX,
                            centerY + i * 20,
                            i === 0,
                            2 + i * 0.2 // Increasing mass
                        );
                        points.push(point);
                        chainPoints.push(point);
                    }
                    for (let i = 0; i < chainPoints.length - 1; i++) {
                        constraints.push(new Constraint(chainPoints[i], chainPoints[i + 1], 20));
                    }
                    ropeCount = 1;
                    break;

                case 'web':
                    // Spider web pattern
                    const webCenterX = centerX;
                    const webCenterY = canvas.height * 0.4;
                    const rings = 6;
                    const spokes = 12;
                    const ringSpacing = 40;

                    // Center point
                    const center = new Point(webCenterX, webCenterY, true, 0.5);
                    points.push(center);

                    // Create rings
                    const ringPoints = [[]];
                    for (let r = 1; r <= rings; r++) {
                        ringPoints[r] = [];
                        for (let s = 0; s < spokes; s++) {
                            const angle = (s / spokes) * Math.PI * 2;
                            const x = webCenterX + Math.cos(angle) * r * ringSpacing;
                            const y = webCenterY + Math.sin(angle) * r * ringSpacing;
                            const pinned = r === rings && (s === 0 || s === spokes / 4 || s === spokes / 2 || s === (3 * spokes) / 4);
                            const point = new Point(x, y, pinned, 0.3);
                            points.push(point);
                            ringPoints[r].push(point);
                        }
                    }

                    // Spokes from center
                    for (let s = 0; s < spokes; s++) {
                        constraints.push(new Constraint(center, ringPoints[1][s], ringSpacing, 0.8));
                    }

                    // Radial constraints (spokes)
                    for (let r = 1; r < rings; r++) {
                        for (let s = 0; s < spokes; s++) {
                            constraints.push(new Constraint(ringPoints[r][s], ringPoints[r + 1][s], ringSpacing, 0.8));
                        }
                    }

                    // Circular constraints (rings)
                    for (let r = 1; r <= rings; r++) {
                        for (let s = 0; s < spokes; s++) {
                            const nextS = (s + 1) % spokes;
                            const len = Math.sqrt(
                                (ringPoints[r][s].x - ringPoints[r][nextS].x) ** 2 +
                                (ringPoints[r][s].y - ringPoints[r][nextS].y) ** 2
                            );
                            constraints.push(new Constraint(ringPoints[r][s], ringPoints[r][nextS], len, 0.5));
                        }
                    }
                    ropeCount = 1;
                    break;

                case 'bridge':
                    // Rope bridge between two points
                    const bridgeY = canvas.height * 0.3;
                    const bridgeLeft = canvas.width * 0.2;
                    const bridgeRight = canvas.width * 0.8;
                    const segments = 25;
                    const segLen = (bridgeRight - bridgeLeft) / segments;

                    const bridgePoints = [];
                    for (let i = 0; i <= segments; i++) {
                        const pinned = i === 0 || i === segments;
                        const point = new Point(
                            bridgeLeft + i * segLen,
                            bridgeY,
                            pinned,
                            1
                        );
                        points.push(point);
                        bridgePoints.push(point);
                    }

                    for (let i = 0; i < bridgePoints.length - 1; i++) {
                        constraints.push(new Constraint(bridgePoints[i], bridgePoints[i + 1], segLen));
                    }

                    // Add hanging supports
                    const topY = canvas.height * 0.1;
                    const leftTop = new Point(bridgeLeft, topY, true, 1);
                    const rightTop = new Point(bridgeRight, topY, true, 1);
                    points.push(leftTop, rightTop);

                    // Support ropes
                    for (let i = 0; i <= segments; i += 3) {
                        const supportLen = Math.sqrt((bridgePoints[i].x - leftTop.x) ** 2 + (bridgeY - topY) ** 2);
                        if (i < segments / 2) {
                            constraints.push(new Constraint(leftTop, bridgePoints[i], supportLen * 0.95, 0.5));
                        } else {
                            constraints.push(new Constraint(rightTop, bridgePoints[i], supportLen * 0.95, 0.5));
                        }
                    }
                    ropeCount = 1;
                    break;

                case 'curtain':
                    // Multiple parallel ropes
                    const curtainTop = canvas.height * 0.1;
                    const curtainWidth = canvas.width * 0.6;
                    const curtainLeft = (canvas.width - curtainWidth) / 2;
                    const numRopes = 12;
                    const ropeSpacing = curtainWidth / (numRopes - 1);
                    const curtainSegments = 20;
                    const curtainSegLen = 18;

                    const allCurtainPoints = [];

                    for (let r = 0; r < numRopes; r++) {
                        const ropePoints = [];
                        for (let i = 0; i < curtainSegments; i++) {
                            const point = new Point(
                                curtainLeft + r * ropeSpacing,
                                curtainTop + i * curtainSegLen,
                                i === 0,
                                0.8
                            );
                            points.push(point);
                            ropePoints.push(point);
                        }

                        // Vertical constraints
                        for (let i = 0; i < ropePoints.length - 1; i++) {
                            constraints.push(new Constraint(ropePoints[i], ropePoints[i + 1], curtainSegLen));
                        }

                        allCurtainPoints.push(ropePoints);
                    }

                    // Horizontal constraints between ropes (creating cloth-like structure)
                    for (let i = 0; i < curtainSegments; i++) {
                        for (let r = 0; r < numRopes - 1; r++) {
                            constraints.push(new Constraint(
                                allCurtainPoints[r][i],
                                allCurtainPoints[r + 1][i],
                                ropeSpacing,
                                0.3
                            ));
                        }
                    }

                    ropeCount = numRopes;
                    break;
            }
        }

        // Physics update
        function update() {
            // Update points (Verlet integration)
            for (const point of points) {
                point.update();
            }

            // Solve constraints (relaxation iterations)
            for (let i = 0; i < config.iterations; i++) {
                for (const constraint of constraints) {
                    constraint.solve();
                }
            }

            // Mouse dragging
            if (isDragging && dragPoint && !dragPoint.pinned) {
                dragPoint.x = mouseX;
                dragPoint.y = mouseY;
            }
        }

        // Get color based on tension
        function getTensionColor(constraint) {
            const dx = constraint.p2.x - constraint.p1.x;
            const dy = constraint.p2.y - constraint.p1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const tension = Math.abs(dist - constraint.length) / constraint.length;

            const r = Math.min(255, 255 * tension * 5);
            const g = Math.max(0, 200 - tension * 300);
            const b = 100;

            return `rgb(${r}, ${g}, ${b})`;
        }

        // Draw function
        function draw() {
            ctx.fillStyle = 'rgba(10, 10, 26, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw constraints (ropes)
            for (const constraint of constraints) {
                ctx.beginPath();
                ctx.moveTo(constraint.p1.x, constraint.p1.y);
                ctx.lineTo(constraint.p2.x, constraint.p2.y);

                // Tension-based coloring
                ctx.strokeStyle = getTensionColor(constraint);
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            // Draw points
            for (const point of points) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2);

                if (point.pinned) {
                    ctx.fillStyle = '#ff5722';
                    ctx.strokeStyle = '#ff9800';
                    ctx.lineWidth = 2;
                    ctx.fill();
                    ctx.stroke();

                    // Pin indicator
                    ctx.beginPath();
                    ctx.moveTo(point.x, point.y - point.radius - 5);
                    ctx.lineTo(point.x - 3, point.y - point.radius - 12);
                    ctx.lineTo(point.x + 3, point.y - point.radius - 12);
                    ctx.closePath();
                    ctx.fillStyle = '#ff5722';
                    ctx.fill();
                } else if (point === dragPoint) {
                    ctx.fillStyle = '#4caf50';
                } else {
                    ctx.fillStyle = '#ff9800';
                }
                ctx.fill();
            }

            // Update stats
            pointsDisplay.textContent = points.length;
            ropesDisplay.textContent = ropeCount;
            constraintsDisplay.textContent = constraints.length;
            iterationsDisplay.textContent = config.iterations;
        }

        // Find closest point to mouse
        function findClosestPoint(x, y, maxDist = 30) {
            let closest = null;
            let closestDist = maxDist;

            for (const point of points) {
                const dist = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);
                if (dist < closestDist) {
                    closest = point;
                    closestDist = dist;
                }
            }

            return closest;
        }

        // Animation loop
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;

        function animate(currentTime) {
            requestAnimationFrame(animate);

            // FPS calculation
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                fpsDisplay.textContent = fps;
            }

            update();
            draw();
        }

        // Event listeners
        canvas.addEventListener('mousedown', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            dragPoint = findClosestPoint(mouseX, mouseY);
            if (dragPoint) {
                isDragging = true;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            dragPoint = null;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            dragPoint = null;
        });

        canvas.addEventListener('dblclick', (e) => {
            // Create new pinned point and connect to nearest
            const x = e.clientX;
            const y = e.clientY;
            const nearest = findClosestPoint(x, y, 100);

            if (nearest) {
                const newPoint = new Point(x, y, true, 1);
                points.push(newPoint);

                const dist = Math.sqrt((x - nearest.x) ** 2 + (y - nearest.y) ** 2);
                constraints.push(new Constraint(newPoint, nearest, dist));
            }
        });

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            mouseX = touch.clientX;
            mouseY = touch.clientY;
            dragPoint = findClosestPoint(mouseX, mouseY);
            if (dragPoint) {
                isDragging = true;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            mouseX = touch.clientX;
            mouseY = touch.clientY;
        });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
            dragPoint = null;
        });

        // Control listeners
        document.getElementById('gravity').addEventListener('input', (e) => {
            config.gravity = parseFloat(e.target.value);
            document.getElementById('grav-val').textContent = config.gravity.toFixed(1);
        });

        document.getElementById('damping').addEventListener('input', (e) => {
            config.damping = parseFloat(e.target.value);
            document.getElementById('damp-val').textContent = config.damping.toFixed(2);
        });

        document.getElementById('iters').addEventListener('input', (e) => {
            config.iterations = parseInt(e.target.value);
            document.getElementById('iter-val').textContent = config.iterations;
        });

        document.getElementById('stiffness').addEventListener('input', (e) => {
            config.stiffness = parseFloat(e.target.value);
            document.getElementById('stiff-val').textContent = config.stiffness.toFixed(1);
        });

        // Preset buttons
        document.querySelectorAll('#presets button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('#presets button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                config.preset = btn.dataset.preset;
                initPreset(config.preset);
            });
        });

        // Expose for enhance.js keyboard shortcuts
        window.reset = function() { initPreset(config.preset); };

        // Initialize
        initPreset('single');
        requestAnimationFrame(animate);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
