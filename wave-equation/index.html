<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wave Equation Solver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a14;
            overflow: hidden;
        }

        #canvas {
            display: block;
            cursor: crosshair;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 20, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            z-index: 100;
            min-width: 260px;
            color: #e0e0e0;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        h1 {
            font-size: 1.3em;
            margin-bottom: 5px;
            color: #6496ff;
        }

        .subtitle {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 15px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85em;
            color: #aaa;
        }

        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            background: rgba(30, 40, 70, 0.8);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 6px;
            color: #fff;
            font-size: 0.85em;
        }

        input[type="range"] {
            -webkit-appearance: none;
            height: 8px;
            padding: 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #6496ff;
            border-radius: 50%;
            cursor: pointer;
        }

        .btn-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 10px;
            background: linear-gradient(135deg, #3060c0, #6496ff);
            border: none;
            border-radius: 6px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(100, 150, 255, 0.4);
        }

        .equation {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(10, 10, 20, 0.95);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            color: #e0e0e0;
            font-family: 'Segoe UI', sans-serif;
            text-align: center;
        }

        .equation h3 {
            color: #6496ff;
            margin-bottom: 10px;
        }

        .formula {
            font-family: 'Georgia', serif;
            font-size: 1.2em;
            color: #fff;
            margin: 10px 0;
        }

        .equation p {
            font-size: 0.8em;
            color: #888;
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 10, 20, 0.95);
            backdrop-filter: blur(10px);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.8em;
            color: #888;
            border: 1px solid rgba(100, 150, 255, 0.3);
        }

        .back-link {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #6496ff;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(10, 10, 20, 0.95);
            border-radius: 8px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            font-family: 'Segoe UI', sans-serif;
            transition: all 0.3s;
        }

        .back-link:hover {
            background: rgba(100, 150, 255, 0.1);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>üåä Wave Equation</h1>
        <p class="subtitle">2D Wave Simulation</p>

        <div class="control-group">
            <label>Wave Speed: <span id="speedValue">0.5</span></label>
            <input type="range" id="speed" min="0.1" max="1" step="0.05" value="0.5">
        </div>

        <div class="control-group">
            <label>Damping: <span id="dampValue">0.999</span></label>
            <input type="range" id="damping" min="0.99" max="1" step="0.001" value="0.999">
        </div>

        <div class="control-group">
            <label>Brush Size: <span id="brushValue">15</span></label>
            <input type="range" id="brush" min="5" max="50" value="15">
        </div>

        <div class="control-group">
            <label>Color Mode</label>
            <select id="colorMode">
                <option value="height">Height Map</option>
                <option value="velocity">Velocity</option>
                <option value="gradient">Gradient</option>
                <option value="thermal">Thermal</option>
            </select>
        </div>

        <div class="control-group">
            <label>Boundary</label>
            <select id="boundary">
                <option value="reflect">Reflective</option>
                <option value="absorb">Absorbing</option>
                <option value="wrap">Wrap Around</option>
            </select>
        </div>

        <div class="btn-row">
            <button onclick="reset()">Clear</button>
            <button onclick="addSource()">Add Source</button>
        </div>
        <div class="btn-row">
            <button onclick="addSlit()">Double Slit</button>
            <button onclick="addBarrier()">Barrier</button>
        </div>
    </div>

    <div class="equation">
        <h3>Wave Equation</h3>
        <div class="formula">‚àÇ¬≤u/‚àÇt¬≤ = c¬≤ ‚àá¬≤u</div>
        <p>Click/drag to create waves</p>
    </div>

    <div class="info">
        Click and drag to disturb the surface ‚Ä¢ Shift+click for negative waves
    </div>

    <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let gridW, gridH;
        const scale = 2; // Lower resolution for performance

        // Wave state: current, previous, and velocity
        let u, uPrev, v;
        let barriers;

        let c = 0.5; // Wave speed
        let damping = 0.999;
        let brushSize = 15;
        let colorMode = 'height';
        let boundary = 'reflect';

        let isDrawing = false;
        let oscillators = [];

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = canvas.width;
            height = canvas.height;
            gridW = Math.floor(width / scale);
            gridH = Math.floor(height / scale);

            initArrays();
        }

        function initArrays() {
            u = new Float32Array(gridW * gridH);
            uPrev = new Float32Array(gridW * gridH);
            v = new Float32Array(gridW * gridH);
            barriers = new Uint8Array(gridW * gridH);
        }

        function reset() {
            u.fill(0);
            uPrev.fill(0);
            v.fill(0);
            barriers.fill(0);
            oscillators = [];
        }

        function idx(x, y) {
            return y * gridW + x;
        }

        function addDisturbance(px, py, amplitude, radius) {
            const gx = Math.floor(px / scale);
            const gy = Math.floor(py / scale);
            const r = Math.floor(radius / scale);

            for (let dy = -r; dy <= r; dy++) {
                for (let dx = -r; dx <= r; dx++) {
                    const x = gx + dx;
                    const y = gy + dy;

                    if (x < 0 || x >= gridW || y < 0 || y >= gridH) continue;

                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= r) {
                        const factor = Math.cos((dist / r) * Math.PI * 0.5);
                        const i = idx(x, y);
                        if (!barriers[i]) {
                            u[i] += amplitude * factor * factor;
                        }
                    }
                }
            }
        }

        function addSource() {
            const x = width / 2;
            const y = height / 2;
            oscillators.push({
                x: Math.floor(x / scale),
                y: Math.floor(y / scale),
                frequency: 0.1,
                phase: 0
            });
        }

        function addSlit() {
            reset();
            const wallX = Math.floor(gridW * 0.3);
            const slitY1 = Math.floor(gridH * 0.35);
            const slitY2 = Math.floor(gridH * 0.65);
            const slitWidth = 10;

            for (let y = 0; y < gridH; y++) {
                for (let x = wallX - 2; x <= wallX + 2; x++) {
                    const inSlit1 = y >= slitY1 - slitWidth && y <= slitY1 + slitWidth;
                    const inSlit2 = y >= slitY2 - slitWidth && y <= slitY2 + slitWidth;

                    if (!inSlit1 && !inSlit2) {
                        barriers[idx(x, y)] = 1;
                    }
                }
            }

            // Add oscillator on left side
            oscillators.push({
                x: 20,
                y: Math.floor(gridH / 2),
                frequency: 0.08,
                phase: 0
            });
        }

        function addBarrier() {
            const cx = Math.floor(gridW / 2);
            const cy = Math.floor(gridH / 2);
            const r = 30;

            for (let dy = -r; dy <= r; dy++) {
                for (let dx = -r; dx <= r; dx++) {
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist >= r - 3 && dist <= r) {
                        const x = cx + dx;
                        const y = cy + dy;
                        if (x >= 0 && x < gridW && y >= 0 && y < gridH) {
                            barriers[idx(x, y)] = 1;
                        }
                    }
                }
            }
        }

        function update() {
            const c2 = c * c;

            // Update oscillators
            for (const osc of oscillators) {
                osc.phase += osc.frequency;
                const i = idx(osc.x, osc.y);
                u[i] = Math.sin(osc.phase) * 2;
            }

            // Wave equation: u_tt = c^2 * (u_xx + u_yy)
            // Using finite differences: u_new = 2*u - u_old + c^2*dt^2*laplacian
            // With dt = 1, this simplifies

            for (let y = 1; y < gridH - 1; y++) {
                for (let x = 1; x < gridW - 1; x++) {
                    const i = idx(x, y);

                    if (barriers[i]) continue;

                    // Laplacian (5-point stencil)
                    let laplacian = 0;

                    // Get neighbors (with boundary handling)
                    const left = barriers[idx(x - 1, y)] ? u[i] : u[idx(x - 1, y)];
                    const right = barriers[idx(x + 1, y)] ? u[i] : u[idx(x + 1, y)];
                    const up = barriers[idx(x, y - 1)] ? u[i] : u[idx(x, y - 1)];
                    const down = barriers[idx(x, y + 1)] ? u[i] : u[idx(x, y + 1)];

                    laplacian = left + right + up + down - 4 * u[i];

                    // Update velocity
                    v[i] += c2 * laplacian;
                    v[i] *= damping;
                }
            }

            // Update positions
            for (let i = 0; i < u.length; i++) {
                if (!barriers[i]) {
                    uPrev[i] = u[i];
                    u[i] += v[i];
                    u[i] *= damping;
                }
            }

            // Boundary conditions
            if (boundary === 'reflect') {
                for (let x = 0; x < gridW; x++) {
                    u[idx(x, 0)] = u[idx(x, 1)];
                    u[idx(x, gridH - 1)] = u[idx(x, gridH - 2)];
                }
                for (let y = 0; y < gridH; y++) {
                    u[idx(0, y)] = u[idx(1, y)];
                    u[idx(gridW - 1, y)] = u[idx(gridW - 2, y)];
                }
            } else if (boundary === 'absorb') {
                for (let x = 0; x < gridW; x++) {
                    u[idx(x, 0)] *= 0.9;
                    u[idx(x, gridH - 1)] *= 0.9;
                }
                for (let y = 0; y < gridH; y++) {
                    u[idx(0, y)] *= 0.9;
                    u[idx(gridW - 1, y)] *= 0.9;
                }
            }
            // wrap: periodic boundaries handled in laplacian
        }

        function getColor(value, vel) {
            value = Math.max(-1, Math.min(1, value));

            switch (colorMode) {
                case 'height':
                    if (value >= 0) {
                        const t = value;
                        return [
                            Math.floor(30 + t * 70),
                            Math.floor(60 + t * 140),
                            Math.floor(150 + t * 105)
                        ];
                    } else {
                        const t = -value;
                        return [
                            Math.floor(20 + t * 30),
                            Math.floor(30 + t * 30),
                            Math.floor(80 + t * 70)
                        ];
                    }

                case 'velocity':
                    vel = Math.max(-1, Math.min(1, vel * 10));
                    if (vel >= 0) {
                        return [Math.floor(255 * vel), 50, 50];
                    } else {
                        return [50, 50, Math.floor(-255 * vel)];
                    }

                case 'gradient':
                    const h = (value + 1) * 180;
                    return hslToRgb(h, 80, 50);

                case 'thermal':
                    const t = (value + 1) / 2;
                    if (t < 0.5) {
                        return [
                            Math.floor(t * 2 * 255),
                            0,
                            Math.floor((1 - t * 2) * 100)
                        ];
                    } else {
                        return [
                            255,
                            Math.floor((t - 0.5) * 2 * 255),
                            0
                        ];
                    }
            }
        }

        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;
            let r, g, b;

            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }

            return [
                Math.floor((r + m) * 255),
                Math.floor((g + m) * 255),
                Math.floor((b + m) * 255)
            ];
        }

        function draw() {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            for (let py = 0; py < height; py++) {
                const gy = Math.floor(py / scale);
                for (let px = 0; px < width; px++) {
                    const gx = Math.floor(px / scale);
                    const i = idx(gx, gy);
                    const pi = (py * width + px) * 4;

                    if (barriers[i]) {
                        data[pi] = 60;
                        data[pi + 1] = 60;
                        data[pi + 2] = 80;
                    } else {
                        const [r, g, b] = getColor(u[i], v[i]);
                        data[pi] = r;
                        data[pi + 1] = g;
                        data[pi + 2] = b;
                    }
                    data[pi + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw oscillator markers
            ctx.fillStyle = '#ffcc00';
            for (const osc of oscillators) {
                ctx.beginPath();
                ctx.arc(osc.x * scale, osc.y * scale, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Input handlers
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const amplitude = e.shiftKey ? -3 : 3;
            addDisturbance(e.clientX, e.clientY, amplitude, brushSize);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                const amplitude = e.shiftKey ? -2 : 2;
                addDisturbance(e.clientX, e.clientY, amplitude, brushSize);
            }
        });

        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseleave', () => isDrawing = false);

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDrawing = true;
            const touch = e.touches[0];
            addDisturbance(touch.clientX, touch.clientY, 3, brushSize);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDrawing) {
                const touch = e.touches[0];
                addDisturbance(touch.clientX, touch.clientY, 2, brushSize);
            }
        });

        canvas.addEventListener('touchend', () => isDrawing = false);

        // UI handlers
        document.getElementById('speed').addEventListener('input', (e) => {
            c = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = c.toFixed(2);
        });

        document.getElementById('damping').addEventListener('input', (e) => {
            damping = parseFloat(e.target.value);
            document.getElementById('dampValue').textContent = damping.toFixed(3);
        });

        document.getElementById('brush').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushValue').textContent = brushSize;
        });

        document.getElementById('colorMode').addEventListener('change', (e) => {
            colorMode = e.target.value;
        });

        document.getElementById('boundary').addEventListener('change', (e) => {
            boundary = e.target.value;
        });

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        // Expose for enhance.js keyboard shortcuts
        window.reset = function() { initArrays(); resize(); };

        // Initialize
        window.addEventListener('resize', resize);
        resize();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
