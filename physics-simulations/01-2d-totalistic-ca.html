<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>2D Totalistic Cellular Automaton</title>
    <style>
        * { margin: 0; padding: 0; }
        body { background: #1a1a2e; color: #e0e0e0; font-family: sans-serif; overflow: hidden; }
        #canvas { display: block; }
        .info { position: fixed; top: 20px; left: 20px; background: rgba(26, 26, 46, 0.95); padding: 20px; border-radius: 10px; max-width: 300px; }
        h1 { font-size: 1.3em; color: #64ffda; margin-bottom: 10px; }
        p { font-size: 0.85em; color: #c0c0c0; line-height: 1.6; }
        .controls { position: fixed; top: 20px; right: 20px; background: rgba(26, 26, 46, 0.95); padding: 20px; border-radius: 10px; }
        button { width: 100%; padding: 10px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer; margin: 5px 0; }
        button:hover { background: #764ba2; }
    </style>
</head>
<body>
    <div class="info">
        <h1>2D Totalistic CA</h1>
        <p>Cellular automaton where next state depends on sum of neighbor values. Creates complex emergent patterns.</p>
        <p><strong>Click</strong> to add live cells.</p>
    </div>
    <div class="controls">
        <button id="resetBtn">Reset</button>
        <button id="pauseBtn">Pause</button>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
        const cellSize = 4, cols = Math.floor(window.innerWidth / cellSize), rows = Math.floor(window.innerHeight / cellSize);
        canvas.width = cols * cellSize; canvas.height = rows * cellSize;

        let grid = new Uint8Array(cols * rows), paused = false;

        function init() {
            grid.fill(0);
            for (let i = 0; i < cols * rows * 0.3; i++) {
                grid[Math.floor(Math.random() * grid.length)] = Math.floor(Math.random() * 4);
            }
        }

        function step() {
            const newGrid = new Uint8Array(cols * rows);
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const idx = y * cols + x;
                    let sum = 0, count = 0;

                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = (x + dx + cols) % cols;
                            const ny = (y + dy + rows) % rows;
                            sum += grid[ny * cols + nx];
                            count++;
                        }
                    }

                    const current = grid[idx];
                    // Totalistic rule
                    if (current === 0) {
                        newGrid[idx] = (sum === 3 || sum === 6 || sum === 9) ? 1 : 0;
                    } else {
                        newGrid[idx] = (sum >= 4 && sum <= 12) ? Math.min(3, current + 1) : Math.max(0, current - 1);
                    }
                }
            }
            grid = newGrid;
        }

        function render() {
            const colors = ['#000000', '#64ffda', '#4ecdc4', '#ffe66d', '#ff6b6b'];
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const state = grid[y * cols + x];
                    ctx.fillStyle = colors[state % colors.length];
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }

        function animate() {
            if (!paused) {
                step();
                render();
            }
            requestAnimationFrame(animate);
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / cellSize);
            const y = Math.floor((e.clientY - rect.top) / cellSize);
            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    const nx = (x + dx + cols) % cols;
                    const ny = (y + dy + rows) % rows;
                    grid[ny * cols + nx] = Math.floor(Math.random() * 3) + 1;
                }
            }
        });

        document.getElementById('resetBtn').addEventListener('click', init);
        document.getElementById('pauseBtn').addEventListener('click', (e) => {
            paused = !paused; e.target.textContent = paused ? 'Resume' : 'Pause';
        });

        init(); animate();
    </script>
</body>
</html>
