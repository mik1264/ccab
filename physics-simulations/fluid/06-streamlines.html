<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamline Visualization - Fluid Dynamics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas { display: block; width: 100vw; height: 100vh; }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            min-width: 280px;
        }
        h1 { font-size: 1.3em; margin-bottom: 5px; color: #4fc3f7; }
        .subtitle { font-size: 0.85em; color: #888; margin-bottom: 15px; }
        .slider-group { margin-bottom: 12px; }
        .slider-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.85em;
            color: #aaa;
        }
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #4fc3f7;
            border-radius: 50%;
            cursor: pointer;
        }
        .flow-types {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 15px;
        }
        .flow-type {
            padding: 6px 12px;
            background: #222;
            border: 1px solid #444;
            border-radius: 6px;
            color: #aaa;
            font-size: 0.8em;
            cursor: pointer;
        }
        .flow-type:hover, .flow-type.active {
            background: #333;
            border-color: #4fc3f7;
            color: #fff;
        }
        .button-row { display: flex; gap: 10px; margin-top: 15px; }
        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: #4fc3f7;
            color: #000;
            cursor: pointer;
            font-weight: 600;
        }
        button:hover { background: #29b6f6; }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #4fc3f7;
            text-decoration: none;
            z-index: 100;
        }
        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 350px;
            font-size: 0.85em;
            color: #aaa;
            line-height: 1.5;
        }
        .info h3 { color: #4fc3f7; margin-bottom: 8px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>Streamline Visualization</h1>
        <p class="subtitle">Flow Field Visualization</p>

        <div class="slider-group">
            <label>Line Density <span id="densityVal">30</span></label>
            <input type="range" id="density" min="10" max="60" step="5" value="30">
        </div>

        <div class="slider-group">
            <label>Line Length <span id="lengthVal">150</span></label>
            <input type="range" id="length" min="50" max="300" step="10" value="150">
        </div>

        <div class="slider-group">
            <label>Flow Speed <span id="speedVal">1.0</span></label>
            <input type="range" id="speed" min="0.2" max="3" step="0.1" value="1.0">
        </div>

        <div class="slider-group">
            <label>Vortex Strength <span id="vortexVal">0.5</span></label>
            <input type="range" id="vortex" min="0" max="2" step="0.1" value="0.5">
        </div>

        <div class="flow-types">
            <span class="flow-type active" data-type="doublet">Doublet</span>
            <span class="flow-type" data-type="vortex">Vortex</span>
            <span class="flow-type" data-type="source">Source</span>
            <span class="flow-type" data-type="uniform">Uniform</span>
            <span class="flow-type" data-type="corner">Corner</span>
        </div>

        <div class="button-row">
            <button id="regenerateBtn">Regenerate</button>
            <button id="animateBtn">Animate</button>
        </div>
    </div>

    <a href="../index.html" class="back-link">‚Üê Back</a>

    <div class="info">
        <h3>Streamlines</h3>
        <p>Streamlines are curves tangent to the velocity field at every point.
        They show the instantaneous direction of fluid flow. In steady flow,
        they coincide with pathlines (particle trajectories).</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let density = 30;
        let lineLength = 150;
        let flowSpeed = 1.0;
        let vortexStrength = 0.5;
        let flowType = 'doublet';
        let animate = false;
        let time = 0;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = canvas.width;
            height = canvas.height;
            generateStreamlines();
        }

        // Velocity field functions
        function getVelocity(x, y) {
            const cx = width / 2;
            const cy = height / 2;

            // Normalized coordinates
            const px = (x - cx) / 200;
            const py = (y - cy) / 200;
            const r2 = px * px + py * py + 0.01;
            const r = Math.sqrt(r2);

            let vx = 0, vy = 0;

            switch (flowType) {
                case 'doublet':
                    // Doublet flow (source + sink)
                    vx = flowSpeed * (py * py - px * px) / (r2 * r2);
                    vy = flowSpeed * (-2 * px * py) / (r2 * r2);
                    break;

                case 'vortex':
                    // Vortex flow
                    vx = flowSpeed * vortexStrength * (-py / r2);
                    vy = flowSpeed * vortexStrength * (px / r2);
                    break;

                case 'source':
                    // Source/Sink flow
                    vx = flowSpeed * px / r2;
                    vy = flowSpeed * py / r2;
                    break;

                case 'uniform':
                    // Uniform flow with oscillation
                    vx = flowSpeed * (1 + 0.3 * Math.sin(py * 2 + time * 2));
                    vy = flowSpeed * 0.2 * Math.sin(px * 2 + time);
                    break;

                case 'corner':
                    // Corner flow
                    vx = flowSpeed * px;
                    vy = flowSpeed * (-py);
                    break;
            }

            // Add some general circulation
            vx -= vortexStrength * 0.2 * py / (r + 0.5);
            vy += vortexStrength * 0.2 * px / (r + 0.5);

            return { vx, vy };
        }

        let streamlines = [];

        function generateStreamlines() {
            streamlines = [];

            const spacing = Math.max(width, height) / density;

            for (let y = spacing / 2; y < height; y += spacing) {
                for (let x = spacing / 2; x < width; x += spacing) {
                    const line = traceStreamline(x, y);
                    if (line.length > 5) {
                        streamlines.push(line);
                    }
                }
            }
        }

        function traceStreamline(startX, startY) {
            const points = [];
            let x = startX;
            let y = startY;
            const dt = 2;

            // Trace forward
            for (let i = 0; i < lineLength; i++) {
                points.push({ x, y });

                const vel = getVelocity(x, y);
                const speed = Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy);
                if (speed < 0.001) break;

                x += vel.vx * dt / speed * 2;
                y += vel.vy * dt / speed * 2;

                if (x < 0 || x > width || y < 0 || y > height) break;
            }

            return points;
        }

        function draw() {
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, width, height);

            // Draw streamlines
            for (const line of streamlines) {
                if (line.length < 2) continue;

                ctx.beginPath();
                ctx.moveTo(line[0].x, line[0].y);

                for (let i = 1; i < line.length; i++) {
                    ctx.lineTo(line[i].x, line[i].y);
                }

                // Color based on velocity magnitude at start
                const vel = getVelocity(line[0].x, line[0].y);
                const speed = Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy);
                const hue = 180 + speed * 60;
                const alpha = Math.min(1, speed * 2);

                ctx.strokeStyle = `hsla(${hue}, 80%, 60%, ${0.3 + alpha * 0.5})`;
                ctx.lineWidth = 1 + speed * 0.5;
                ctx.stroke();

                // Draw arrowhead at end
                if (line.length > 2) {
                    const end = line[line.length - 1];
                    const prev = line[line.length - 3];
                    const angle = Math.atan2(end.y - prev.y, end.x - prev.x);

                    ctx.save();
                    ctx.translate(end.x, end.y);
                    ctx.rotate(angle);

                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-6, -3);
                    ctx.lineTo(-6, 3);
                    ctx.closePath();
                    ctx.fillStyle = `hsla(${hue}, 80%, 60%, ${0.5 + alpha * 0.5})`;
                    ctx.fill();

                    ctx.restore();
                }
            }

            // Draw center marker
            ctx.beginPath();
            ctx.arc(width / 2, height / 2, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
        }

        function animateFrame() {
            if (animate) {
                time += 0.02;
                generateStreamlines();
                draw();
                requestAnimationFrame(animateFrame);
            }
        }

        // UI
        document.getElementById('density').addEventListener('input', (e) => {
            density = parseInt(e.target.value);
            document.getElementById('densityVal').textContent = density;
            generateStreamlines();
            draw();
        });

        document.getElementById('length').addEventListener('input', (e) => {
            lineLength = parseInt(e.target.value);
            document.getElementById('lengthVal').textContent = lineLength;
            generateStreamlines();
            draw();
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            flowSpeed = parseFloat(e.target.value);
            document.getElementById('speedVal').textContent = flowSpeed.toFixed(1);
            generateStreamlines();
            draw();
        });

        document.getElementById('vortex').addEventListener('input', (e) => {
            vortexStrength = parseFloat(e.target.value);
            document.getElementById('vortexVal').textContent = vortexStrength.toFixed(1);
            generateStreamlines();
            draw();
        });

        document.querySelectorAll('.flow-type').forEach(el => {
            el.addEventListener('click', () => {
                document.querySelectorAll('.flow-type').forEach(t => t.classList.remove('active'));
                el.classList.add('active');
                flowType = el.dataset.type;
                generateStreamlines();
                draw();
            });
        });

        document.getElementById('regenerateBtn').addEventListener('click', () => {
            generateStreamlines();
            draw();
        });

        document.getElementById('animateBtn').addEventListener('click', function() {
            animate = !animate;
            this.textContent = animate ? 'Stop' : 'Animate';
            if (animate) animateFrame();
        });

        window.addEventListener('resize', resize);

        resize();
        draw();
    </script>
</body>
</html>
