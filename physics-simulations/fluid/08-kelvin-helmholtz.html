<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kelvin-Helmholtz Instability</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas { display: block; width: 100vw; height: 100vh; }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            min-width: 280px;
        }
        h1 { font-size: 1.3em; margin-bottom: 5px; color: #26a69a; }
        .subtitle { font-size: 0.85em; color: #888; margin-bottom: 15px; }
        .slider-group { margin-bottom: 12px; }
        .slider-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.85em;
            color: #aaa;
        }
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #26a69a;
            border-radius: 50%;
            cursor: pointer;
        }
        .button-row { display: flex; gap: 10px; margin-top: 15px; }
        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: #26a69a;
            color: #fff;
            cursor: pointer;
            font-weight: 600;
        }
        button:hover { background: #00897b; }
        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
            font-size: 0.85em;
            color: #888;
        }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #26a69a;
            text-decoration: none;
            z-index: 100;
        }
        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 400px;
            font-size: 0.85em;
            color: #aaa;
            line-height: 1.5;
        }
        .info h3 { color: #26a69a; margin-bottom: 8px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>Kelvin-Helmholtz Instability</h1>
        <p class="subtitle">Shear Flow Instability</p>

        <div class="slider-group">
            <label>Velocity Difference <span id="velVal">2.0</span></label>
            <input type="range" id="velocity" min="0.5" max="4" step="0.1" value="2.0">
        </div>

        <div class="slider-group">
            <label>Density Ratio <span id="densityVal">0.5</span></label>
            <input type="range" id="densityRatio" min="0.2" max="0.9" step="0.05" value="0.5">
        </div>

        <div class="slider-group">
            <label>Perturbation <span id="perturbVal">0.05</span></label>
            <input type="range" id="perturb" min="0.01" max="0.2" step="0.01" value="0.05">
        </div>

        <div class="slider-group">
            <label>Viscosity <span id="viscVal">0.01</span></label>
            <input type="range" id="viscosity" min="0.001" max="0.05" step="0.001" value="0.01">
        </div>

        <div class="button-row">
            <button id="resetBtn">Reset</button>
            <button id="pauseBtn">Pause</button>
        </div>

        <div class="stats">
            <div>Grid: <span id="gridSize">0×0</span></div>
            <div>Time: <span id="simTime">0.00</span>s</div>
            <div>FPS: <span id="fps">0</span></div>
        </div>
    </div>

    <a href="../index.html" class="back-link">← Back</a>

    <div class="info">
        <h3>Kelvin-Helmholtz Instability</h3>
        <p>When two fluids with different velocities flow past each other, small
        perturbations grow into characteristic rolling vortices. This instability
        is visible in clouds, ocean waves, and planetary atmospheres (like Jupiter's bands).</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height, gridWidth, gridHeight;
        const CELL_SIZE = 3;

        let rho, u, v;
        let rhoNext, uNext, vNext;

        let velocityDiff = 2.0;
        let densityRatio = 0.5;
        let perturbation = 0.05;
        let viscosity = 0.01;
        let paused = false;
        let simTime = 0;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = canvas.width;
            height = canvas.height;
            gridWidth = Math.floor(width / CELL_SIZE);
            gridHeight = Math.floor(height / CELL_SIZE);
            document.getElementById('gridSize').textContent = `${gridWidth}×${gridHeight}`;
            init();
        }

        function init() {
            const size = gridWidth * gridHeight;
            rho = new Float32Array(size);
            u = new Float32Array(size);
            v = new Float32Array(size);
            rhoNext = new Float32Array(size);
            uNext = new Float32Array(size);
            vNext = new Float32Array(size);

            simTime = 0;

            // Initialize shear layer with sinusoidal perturbation
            const midY = gridHeight / 2;
            const wavelength = gridWidth / 4;

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const i = y * gridWidth + x;

                    // Smooth transition with perturbation
                    const yOffset = perturbation * gridHeight * Math.sin(2 * Math.PI * x / wavelength);
                    const transitionWidth = 0.1 * gridHeight;
                    const relY = (y - midY - yOffset) / transitionWidth;
                    const blend = 0.5 * (1 + Math.tanh(relY));

                    // Density: light fluid on top, heavy on bottom
                    rho[i] = densityRatio + (1 - densityRatio) * blend;

                    // Velocity: opposite directions on each side
                    u[i] = velocityDiff * (0.5 - blend);
                    v[i] = perturbation * velocityDiff * Math.cos(2 * Math.PI * x / wavelength) *
                           Math.exp(-relY * relY);
                }
            }
        }

        function idx(x, y) {
            x = (x + gridWidth) % gridWidth;
            y = Math.max(0, Math.min(gridHeight - 1, y));
            return y * gridWidth + x;
        }

        function step(dt) {
            // Semi-Lagrangian advection + viscosity
            for (let y = 1; y < gridHeight - 1; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const i = idx(x, y);

                    // Backtrace
                    const srcX = x - u[i] * dt * 10;
                    const srcY = y - v[i] * dt * 10;

                    // Bilinear interpolation
                    const x0 = Math.floor(srcX);
                    const y0 = Math.floor(srcY);
                    const fx = srcX - x0;
                    const fy = srcY - y0;

                    const i00 = idx(x0, y0);
                    const i10 = idx(x0 + 1, y0);
                    const i01 = idx(x0, y0 + 1);
                    const i11 = idx(x0 + 1, y0 + 1);

                    // Advect density
                    rhoNext[i] = (1 - fx) * (1 - fy) * rho[i00] +
                                 fx * (1 - fy) * rho[i10] +
                                 (1 - fx) * fy * rho[i01] +
                                 fx * fy * rho[i11];

                    // Advect velocity
                    uNext[i] = (1 - fx) * (1 - fy) * u[i00] +
                               fx * (1 - fy) * u[i10] +
                               (1 - fx) * fy * u[i01] +
                               fx * fy * u[i11];

                    vNext[i] = (1 - fx) * (1 - fy) * v[i00] +
                               fx * (1 - fy) * v[i10] +
                               (1 - fx) * fy * v[i01] +
                               fx * fy * v[i11];

                    // Add viscosity (diffusion)
                    const lapU = u[idx(x-1, y)] + u[idx(x+1, y)] + u[idx(x, y-1)] + u[idx(x, y+1)] - 4 * u[i];
                    const lapV = v[idx(x-1, y)] + v[idx(x+1, y)] + v[idx(x, y-1)] + v[idx(x, y+1)] - 4 * v[i];

                    uNext[i] += viscosity * lapU;
                    vNext[i] += viscosity * lapV;
                }
            }

            // Boundary conditions
            for (let x = 0; x < gridWidth; x++) {
                // Top boundary
                rhoNext[idx(x, 0)] = densityRatio;
                uNext[idx(x, 0)] = velocityDiff / 2;
                vNext[idx(x, 0)] = 0;

                // Bottom boundary
                rhoNext[idx(x, gridHeight - 1)] = 1;
                uNext[idx(x, gridHeight - 1)] = -velocityDiff / 2;
                vNext[idx(x, gridHeight - 1)] = 0;
            }

            [rho, rhoNext] = [rhoNext, rho];
            [u, uNext] = [uNext, u];
            [v, vNext] = [vNext, v];

            simTime += dt;
        }

        function draw() {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const i = idx(x, y);
                    const density = rho[i];
                    const speed = Math.sqrt(u[i] * u[i] + v[i] * v[i]);

                    // Color by density and vorticity
                    const vorticity = (v[idx(x+1, y)] - v[idx(x-1, y)]) -
                                     (u[idx(x, y+1)] - u[idx(x, y-1)]);

                    // Blue for light/fast fluid, orange for heavy/slow
                    let r, g, b;
                    if (density < 0.75) {
                        // Light fluid - cyan/blue tones
                        const t = density / 0.75;
                        r = Math.floor(38 + 50 * Math.abs(vorticity));
                        g = Math.floor(166 - 80 * t + 30 * speed);
                        b = Math.floor(154 + 100 * (1 - t));
                    } else {
                        // Heavy fluid - orange/red tones
                        const t = (density - 0.75) / 0.25;
                        r = Math.floor(255 - 100 * (1 - t) + 30 * Math.abs(vorticity));
                        g = Math.floor(152 - 100 * t);
                        b = Math.floor(0 + 50 * speed);
                    }

                    // Add vorticity highlighting
                    if (Math.abs(vorticity) > 0.1) {
                        const highlight = Math.min(1, Math.abs(vorticity) * 2);
                        if (vorticity > 0) {
                            g = Math.min(255, g + highlight * 50);
                        } else {
                            r = Math.min(255, r + highlight * 50);
                        }
                    }

                    for (let py = 0; py < CELL_SIZE; py++) {
                        for (let px = 0; px < CELL_SIZE; px++) {
                            const screenX = x * CELL_SIZE + px;
                            const screenY = y * CELL_SIZE + py;
                            if (screenX < width && screenY < height) {
                                const pixelIdx = (screenY * width + screenX) * 4;
                                data[pixelIdx] = Math.min(255, Math.max(0, r));
                                data[pixelIdx + 1] = Math.min(255, Math.max(0, g));
                                data[pixelIdx + 2] = Math.min(255, Math.max(0, b));
                                data[pixelIdx + 3] = 255;
                            }
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // UI
        document.getElementById('velocity').addEventListener('input', (e) => {
            velocityDiff = parseFloat(e.target.value);
            document.getElementById('velVal').textContent = velocityDiff.toFixed(1);
        });

        document.getElementById('densityRatio').addEventListener('input', (e) => {
            densityRatio = parseFloat(e.target.value);
            document.getElementById('densityVal').textContent = densityRatio.toFixed(2);
        });

        document.getElementById('perturb').addEventListener('input', (e) => {
            perturbation = parseFloat(e.target.value);
            document.getElementById('perturbVal').textContent = perturbation.toFixed(2);
        });

        document.getElementById('viscosity').addEventListener('input', (e) => {
            viscosity = parseFloat(e.target.value);
            document.getElementById('viscVal').textContent = viscosity.toFixed(3);
        });

        document.getElementById('resetBtn').addEventListener('click', init);

        document.getElementById('pauseBtn').addEventListener('click', function() {
            paused = !paused;
            this.textContent = paused ? 'Resume' : 'Pause';
        });

        window.addEventListener('resize', resize);

        let lastTime = performance.now();
        let frameCount = 0;
        let fpsTime = 0;

        function animate() {
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            frameCount++;
            fpsTime += dt;
            if (fpsTime >= 1) {
                document.getElementById('fps').textContent = Math.round(frameCount / fpsTime);
                frameCount = 0;
                fpsTime = 0;
            }

            if (!paused) {
                for (let i = 0; i < 3; i++) {
                    step(0.016);
                }
                document.getElementById('simTime').textContent = simTime.toFixed(2);
            }
            draw();

            requestAnimationFrame(animate);
        }

        resize();
        animate();
    </script>
</body>
</html>
