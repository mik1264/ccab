<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hele-Shaw Flow - Viscous Fingering</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas { display: block; width: 100vw; height: 100vh; }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            min-width: 280px;
        }
        h1 { font-size: 1.3em; margin-bottom: 5px; color: #ffc107; }
        .subtitle { font-size: 0.85em; color: #888; margin-bottom: 15px; }
        .slider-group { margin-bottom: 12px; }
        .slider-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.85em;
            color: #aaa;
        }
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #ffc107;
            border-radius: 50%;
            cursor: pointer;
        }
        .button-row { display: flex; gap: 10px; margin-top: 15px; }
        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: #ffc107;
            color: #000;
            cursor: pointer;
            font-weight: 600;
        }
        button:hover { background: #ffb300; }
        .modes {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }
        .mode-btn {
            flex: 1;
            padding: 8px;
            background: #222;
            border: 1px solid #444;
            border-radius: 6px;
            color: #aaa;
            cursor: pointer;
            font-size: 0.8em;
            text-align: center;
        }
        .mode-btn:hover, .mode-btn.active {
            background: #333;
            border-color: #ffc107;
            color: #fff;
        }
        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
            font-size: 0.85em;
            color: #888;
        }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #ffc107;
            text-decoration: none;
            z-index: 100;
        }
        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 400px;
            font-size: 0.85em;
            color: #aaa;
            line-height: 1.5;
        }
        .info h3 { color: #ffc107; margin-bottom: 8px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>Hele-Shaw Flow</h1>
        <p class="subtitle">Viscous Fingering Instability</p>

        <div class="slider-group">
            <label>Injection Rate <span id="rateVal">1.0</span></label>
            <input type="range" id="rate" min="0.2" max="3" step="0.1" value="1.0">
        </div>

        <div class="slider-group">
            <label>Viscosity Ratio <span id="viscVal">10</span></label>
            <input type="range" id="viscosity" min="2" max="50" step="1" value="10">
        </div>

        <div class="slider-group">
            <label>Surface Tension <span id="tensionVal">0.5</span></label>
            <input type="range" id="tension" min="0" max="2" step="0.1" value="0.5">
        </div>

        <div class="slider-group">
            <label>Noise Level <span id="noiseVal">0.02</span></label>
            <input type="range" id="noise" min="0" max="0.1" step="0.005" value="0.02">
        </div>

        <div class="modes">
            <span class="mode-btn active" data-mode="radial">Radial</span>
            <span class="mode-btn" data-mode="linear">Linear</span>
            <span class="mode-btn" data-mode="corner">Corner</span>
        </div>

        <div class="button-row">
            <button id="resetBtn">Reset</button>
            <button id="pauseBtn">Pause</button>
        </div>

        <div class="stats">
            <div>Coverage: <span id="coverage">0%</span></div>
            <div>Fingers: <span id="fingers">0</span></div>
            <div>FPS: <span id="fps">0</span></div>
        </div>
    </div>

    <a href="../index.html" class="back-link">← Back</a>

    <div class="info">
        <h3>Hele-Shaw Flow</h3>
        <p>When a less viscous fluid displaces a more viscous one in a thin gap
        (Hele-Shaw cell), the interface becomes unstable and develops "fingers."
        This Saffman-Taylor instability appears in oil recovery, CO₂ sequestration,
        and even bacterial colony growth.</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height, gridWidth, gridHeight;
        const CELL_SIZE = 2;

        let phi; // Phase field: 0 = defending fluid, 1 = invading fluid
        let phiNext;
        let pressure;

        let injectionRate = 1.0;
        let viscosityRatio = 10;
        let surfaceTension = 0.5;
        let noiseLevel = 0.02;
        let injectionMode = 'radial';
        let paused = false;

        let centerX, centerY;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = canvas.width;
            height = canvas.height;
            gridWidth = Math.floor(width / CELL_SIZE);
            gridHeight = Math.floor(height / CELL_SIZE);
            centerX = gridWidth / 2;
            centerY = gridHeight / 2;
            init();
        }

        function init() {
            const size = gridWidth * gridHeight;
            phi = new Float32Array(size);
            phiNext = new Float32Array(size);
            pressure = new Float32Array(size);

            // Initialize based on injection mode
            const initRadius = 30;

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const i = y * gridWidth + x;

                    let dist;
                    switch (injectionMode) {
                        case 'radial':
                            dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                            phi[i] = dist < initRadius ? 1 : 0;
                            break;

                        case 'linear':
                            phi[i] = x < 30 ? 1 : 0;
                            break;

                        case 'corner':
                            dist = Math.sqrt(x * x + y * y);
                            phi[i] = dist < initRadius * 2 ? 1 : 0;
                            break;
                    }

                    // Add small perturbation
                    if (phi[i] < 0.5 && phi[i] > 0) {
                        phi[i] += (Math.random() - 0.5) * noiseLevel;
                    }
                }
            }
        }

        function idx(x, y) {
            x = Math.max(0, Math.min(gridWidth - 1, x));
            y = Math.max(0, Math.min(gridHeight - 1, y));
            return y * gridWidth + x;
        }

        function getMobility(p) {
            // Mobility depends on viscosity ratio
            // High mobility in low-viscosity (invading) fluid
            // Low mobility in high-viscosity (defending) fluid
            return 1 / (1 + (viscosityRatio - 1) * (1 - p));
        }

        function step(dt) {
            // Solve for pressure (simplified Laplace)
            for (let iter = 0; iter < 10; iter++) {
                for (let y = 1; y < gridHeight - 1; y++) {
                    for (let x = 1; x < gridWidth - 1; x++) {
                        const i = idx(x, y);

                        const mob = getMobility(phi[i]);
                        const mobL = getMobility(phi[idx(x-1, y)]);
                        const mobR = getMobility(phi[idx(x+1, y)]);
                        const mobU = getMobility(phi[idx(x, y-1)]);
                        const mobD = getMobility(phi[idx(x, y+1)]);

                        pressure[i] = (
                            mobL * pressure[idx(x-1, y)] +
                            mobR * pressure[idx(x+1, y)] +
                            mobU * pressure[idx(x, y-1)] +
                            mobD * pressure[idx(x, y+1)]
                        ) / (mobL + mobR + mobU + mobD + 0.001);
                    }
                }

                // Injection boundary condition
                switch (injectionMode) {
                    case 'radial':
                        for (let y = 0; y < gridHeight; y++) {
                            for (let x = 0; x < gridWidth; x++) {
                                const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                                if (dist < 10) {
                                    pressure[idx(x, y)] = injectionRate * 10;
                                }
                            }
                        }
                        break;

                    case 'linear':
                        for (let y = 0; y < gridHeight; y++) {
                            pressure[idx(0, y)] = injectionRate * 10;
                            pressure[idx(gridWidth - 1, y)] = 0;
                        }
                        break;

                    case 'corner':
                        for (let y = 0; y < 20; y++) {
                            for (let x = 0; x < 20; x++) {
                                pressure[idx(x, y)] = injectionRate * 10;
                            }
                        }
                        break;
                }
            }

            // Update phase field
            for (let y = 1; y < gridHeight - 1; y++) {
                for (let x = 1; x < gridWidth - 1; x++) {
                    const i = idx(x, y);

                    // Pressure gradient
                    const gradPx = (pressure[idx(x+1, y)] - pressure[idx(x-1, y)]) * 0.5;
                    const gradPy = (pressure[idx(x, y+1)] - pressure[idx(x, y-1)]) * 0.5;

                    // Phase gradient
                    const gradPhiX = (phi[idx(x+1, y)] - phi[idx(x-1, y)]) * 0.5;
                    const gradPhiY = (phi[idx(x, y+1)] - phi[idx(x, y-1)]) * 0.5;

                    // Curvature (Laplacian of phi)
                    const lapPhi = phi[idx(x-1, y)] + phi[idx(x+1, y)] +
                                   phi[idx(x, y-1)] + phi[idx(x, y+1)] - 4 * phi[i];

                    // Mobility
                    const mob = getMobility(phi[i]);

                    // Advection by pressure gradient
                    let dphi = -mob * (gradPx * gradPhiX + gradPy * gradPhiY) * dt * 0.5;

                    // Surface tension (diffusion)
                    dphi += surfaceTension * lapPhi * dt * 0.1;

                    // Add noise at interface
                    const isInterface = phi[i] > 0.1 && phi[i] < 0.9;
                    if (isInterface) {
                        dphi += (Math.random() - 0.5) * noiseLevel * dt * 10;
                    }

                    phiNext[i] = Math.max(0, Math.min(1, phi[i] + dphi));
                }
            }

            // Injection source
            switch (injectionMode) {
                case 'radial':
                    for (let y = 0; y < gridHeight; y++) {
                        for (let x = 0; x < gridWidth; x++) {
                            const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                            if (dist < 15) {
                                phiNext[idx(x, y)] = 1;
                            }
                        }
                    }
                    break;

                case 'linear':
                    for (let y = 0; y < gridHeight; y++) {
                        phiNext[idx(0, y)] = 1;
                        phiNext[idx(1, y)] = 1;
                    }
                    break;

                case 'corner':
                    for (let y = 0; y < 25; y++) {
                        for (let x = 0; x < 25; x++) {
                            phiNext[idx(x, y)] = 1;
                        }
                    }
                    break;
            }

            [phi, phiNext] = [phiNext, phi];
        }

        function calculateStats() {
            let invaded = 0;
            let interfaceLength = 0;

            for (let y = 1; y < gridHeight - 1; y++) {
                for (let x = 1; x < gridWidth - 1; x++) {
                    const i = idx(x, y);
                    if (phi[i] > 0.5) invaded++;

                    // Count interface cells
                    if (phi[i] > 0.2 && phi[i] < 0.8) {
                        interfaceLength++;
                    }
                }
            }

            const coverage = (invaded / (gridWidth * gridHeight) * 100).toFixed(1);
            // Rough finger count from interface complexity
            const expectedCircumference = 2 * Math.PI * Math.sqrt(invaded / Math.PI);
            const fingers = Math.max(0, Math.floor((interfaceLength - expectedCircumference) / 50));

            return { coverage, fingers };
        }

        function draw() {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const i = idx(x, y);
                    const p = phi[i];

                    // Golden invading fluid, dark blue defending fluid
                    let r, g, b;

                    if (p > 0.5) {
                        // Invading fluid (golden)
                        const t = (p - 0.5) * 2;
                        r = Math.floor(255 * (0.6 + 0.4 * t));
                        g = Math.floor(193 * (0.6 + 0.4 * t));
                        b = Math.floor(7 * (0.3 + 0.7 * t));
                    } else {
                        // Defending fluid (dark blue)
                        const t = p * 2;
                        r = Math.floor(10 + 50 * t);
                        g = Math.floor(20 + 60 * t);
                        b = Math.floor(60 + 100 * t);
                    }

                    // Highlight interface
                    if (p > 0.3 && p < 0.7) {
                        r = Math.min(255, r + 30);
                        g = Math.min(255, g + 30);
                        b = Math.min(255, b + 30);
                    }

                    for (let py = 0; py < CELL_SIZE; py++) {
                        for (let px = 0; px < CELL_SIZE; px++) {
                            const screenX = x * CELL_SIZE + px;
                            const screenY = y * CELL_SIZE + py;
                            if (screenX < width && screenY < height) {
                                const pixelIdx = (screenY * width + screenX) * 4;
                                data[pixelIdx] = r;
                                data[pixelIdx + 1] = g;
                                data[pixelIdx + 2] = b;
                                data[pixelIdx + 3] = 255;
                            }
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // UI
        document.getElementById('rate').addEventListener('input', (e) => {
            injectionRate = parseFloat(e.target.value);
            document.getElementById('rateVal').textContent = injectionRate.toFixed(1);
        });

        document.getElementById('viscosity').addEventListener('input', (e) => {
            viscosityRatio = parseInt(e.target.value);
            document.getElementById('viscVal').textContent = viscosityRatio;
        });

        document.getElementById('tension').addEventListener('input', (e) => {
            surfaceTension = parseFloat(e.target.value);
            document.getElementById('tensionVal').textContent = surfaceTension.toFixed(1);
        });

        document.getElementById('noise').addEventListener('input', (e) => {
            noiseLevel = parseFloat(e.target.value);
            document.getElementById('noiseVal').textContent = noiseLevel.toFixed(3);
        });

        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                injectionMode = btn.dataset.mode;
                init();
            });
        });

        document.getElementById('resetBtn').addEventListener('click', init);

        document.getElementById('pauseBtn').addEventListener('click', function() {
            paused = !paused;
            this.textContent = paused ? 'Resume' : 'Pause';
        });

        window.addEventListener('resize', resize);

        let lastTime = performance.now();
        let frameCount = 0;
        let fpsTime = 0;

        function animate() {
            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            frameCount++;
            fpsTime += dt;
            if (fpsTime >= 1) {
                document.getElementById('fps').textContent = Math.round(frameCount / fpsTime);
                const stats = calculateStats();
                document.getElementById('coverage').textContent = stats.coverage + '%';
                document.getElementById('fingers').textContent = stats.fingers;
                frameCount = 0;
                fpsTime = 0;
            }

            if (!paused) {
                for (let i = 0; i < 5; i++) {
                    step(0.1);
                }
            }
            draw();

            requestAnimationFrame(animate);
        }

        resize();
        animate();
    </script>
    <script src="../../assets/js/enhance.js" defer></script>
</body>
</html>
