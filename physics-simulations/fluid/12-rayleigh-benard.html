<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rayleigh-Bénard Convection</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas { display: block; width: 100vw; height: 100vh; }
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            min-width: 300px;
        }
        h1 { font-size: 1.3em; margin-bottom: 5px; color: #ff6b35; }
        .subtitle { font-size: 0.85em; color: #888; margin-bottom: 15px; }
        .slider-group { margin-bottom: 12px; }
        .slider-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.85em;
            color: #aaa;
        }
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #ff6b35;
            border-radius: 50%;
            cursor: pointer;
        }
        .button-row { display: flex; gap: 10px; margin-top: 15px; }
        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: #ff6b35;
            color: #fff;
            cursor: pointer;
            font-weight: 600;
        }
        button:hover { background: #e55a28; }
        button.active { background: #2ecc71; }
        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
            font-size: 0.85em;
            color: #888;
        }
        .stats .highlight { color: #ff6b35; font-weight: 600; }
        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #ff6b35;
            text-decoration: none;
            z-index: 100;
        }
        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 400px;
            font-size: 0.85em;
            color: #aaa;
            line-height: 1.5;
        }
        .info h3 { color: #ff6b35; margin-bottom: 8px; }
        .mode-buttons { display: flex; gap: 8px; margin-bottom: 12px; }
        .mode-btn {
            flex: 1;
            padding: 8px;
            font-size: 0.8em;
            background: #333;
        }
        .mode-btn.active { background: #ff6b35; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>Rayleigh-Bénard Convection</h1>
        <p class="subtitle">Thermal Convection Cells</p>

        <div class="mode-buttons">
            <button class="mode-btn active" data-mode="temperature">Temperature</button>
            <button class="mode-btn" data-mode="velocity">Velocity</button>
            <button class="mode-btn" data-mode="vorticity">Vorticity</button>
        </div>

        <div class="slider-group">
            <label>Rayleigh Number (Ra) <span id="raVal">2000</span></label>
            <input type="range" id="rayleigh" min="500" max="10000" step="100" value="2000">
        </div>

        <div class="slider-group">
            <label>Prandtl Number (Pr) <span id="prVal">7.0</span></label>
            <input type="range" id="prandtl" min="0.5" max="20" step="0.5" value="7.0">
        </div>

        <div class="slider-group">
            <label>Temperature Diff (ΔT) <span id="dtVal">10</span>°C</label>
            <input type="range" id="deltaT" min="1" max="50" step="1" value="10">
        </div>

        <div class="slider-group">
            <label>Aspect Ratio <span id="arVal">3.0</span></label>
            <input type="range" id="aspectRatio" min="1" max="6" step="0.5" value="3.0">
        </div>

        <div class="button-row">
            <button id="resetBtn">Reset</button>
            <button id="pauseBtn">Pause</button>
            <button id="perturbBtn">Perturb</button>
        </div>

        <div class="stats">
            <div>Grid: <span id="gridSize">0×0</span></div>
            <div>Ra/Ra_c: <span id="raRatio" class="highlight">1.0</span> (Ra_c ≈ 1708)</div>
            <div>Nusselt Number: <span id="nusselt" class="highlight">1.00</span></div>
            <div>Max Velocity: <span id="maxVel">0.00</span></div>
            <div>FPS: <span id="fps">0</span></div>
        </div>
    </div>

    <a href="../index.html" class="back-link">← Back</a>

    <div class="info">
        <h3>Rayleigh-Bénard Convection</h3>
        <p>When a fluid layer is heated from below, thermal expansion creates buoyancy.
        Above the critical Rayleigh number (Ra_c ≈ 1708), convection cells form with
        alternating up and down flows. This creates the characteristic "roll" pattern
        seen in atmospheric clouds and the sun's surface.</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        const CELL_SIZE = 4;
        let gridWidth, gridHeight;

        // Fields
        let T, Tnext;      // Temperature
        let u, v;          // Velocity
        let uNext, vNext;
        let psi;           // Stream function
        let omega;         // Vorticity

        // Parameters
        let Ra = 2000;     // Rayleigh number
        let Pr = 7.0;      // Prandtl number (water ≈ 7)
        let deltaT = 10;   // Temperature difference
        let aspectRatio = 3.0;
        let paused = false;
        let viewMode = 'temperature';

        // Physical constants (normalized)
        const g = 1.0;      // Gravity
        const alpha = 1.0;  // Thermal expansion coefficient
        const Ra_c = 1707.762; // Critical Rayleigh number

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = canvas.width;
            height = canvas.height;

            // Set grid based on aspect ratio
            const cellHeight = Math.floor(height * 0.6 / CELL_SIZE);
            gridHeight = cellHeight;
            gridWidth = Math.floor(gridHeight * aspectRatio);

            document.getElementById('gridSize').textContent = `${gridWidth}×${gridHeight}`;
            init();
        }

        function init() {
            const size = gridWidth * gridHeight;
            T = new Float32Array(size);
            Tnext = new Float32Array(size);
            u = new Float32Array(size);
            v = new Float32Array(size);
            uNext = new Float32Array(size);
            vNext = new Float32Array(size);
            psi = new Float32Array(size);
            omega = new Float32Array(size);

            // Initialize temperature: linear profile from bottom (hot) to top (cold)
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const i = y * gridWidth + x;
                    // T = 1 at bottom, T = 0 at top (normalized)
                    T[i] = 1.0 - y / (gridHeight - 1);

                    // Add small random perturbation
                    T[i] += (Math.random() - 0.5) * 0.01;

                    u[i] = 0;
                    v[i] = 0;
                }
            }
        }

        function idx(x, y) {
            // Periodic in x, clamped in y
            x = (x + gridWidth) % gridWidth;
            y = Math.max(0, Math.min(gridHeight - 1, y));
            return y * gridWidth + x;
        }

        function addPerturbation() {
            // Add sinusoidal perturbation to trigger convection cells
            const numRolls = Math.round(aspectRatio);
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const i = y * gridWidth + x;
                    const perturbation = 0.05 * Math.sin(numRolls * Math.PI * x / gridWidth)
                                              * Math.sin(Math.PI * y / gridHeight);
                    T[i] += perturbation;
                }
            }
        }

        function step(dt) {
            const dx = 1.0 / gridWidth;
            const dy = 1.0 / gridHeight;
            const dx2 = dx * dx;
            const dy2 = dy * dy;

            // Thermal diffusivity (normalized)
            const kappa = 1.0;
            // Kinematic viscosity
            const nu = Pr;

            // Effective Rayleigh number scaling
            const buoyancyCoeff = Ra * Pr * dy2 * dy2;

            // Step 1: Update temperature (advection-diffusion)
            for (let y = 1; y < gridHeight - 1; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const i = idx(x, y);

                    // Laplacian of temperature
                    const lapT = (T[idx(x-1, y)] + T[idx(x+1, y)] - 2*T[i]) / dx2 +
                                 (T[idx(x, y-1)] + T[idx(x, y+1)] - 2*T[i]) / dy2;

                    // Advection terms (upwind)
                    const dTdx = u[i] > 0 ? (T[i] - T[idx(x-1, y)]) / dx : (T[idx(x+1, y)] - T[i]) / dx;
                    const dTdy = v[i] > 0 ? (T[i] - T[idx(x, y-1)]) / dy : (T[idx(x, y+1)] - T[i]) / dy;

                    // Update temperature
                    Tnext[i] = T[i] + dt * (kappa * lapT - u[i] * dTdx - v[i] * dTdy);
                }
            }

            // Temperature boundary conditions
            for (let x = 0; x < gridWidth; x++) {
                Tnext[idx(x, 0)] = 1.0;              // Hot bottom
                Tnext[idx(x, gridHeight - 1)] = 0.0; // Cold top
            }

            // Step 2: Calculate vorticity and update velocity
            for (let y = 1; y < gridHeight - 1; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const i = idx(x, y);

                    // Vorticity: omega = dv/dx - du/dy
                    omega[i] = (v[idx(x+1, y)] - v[idx(x-1, y)]) / (2*dx) -
                               (u[idx(x, y+1)] - u[idx(x, y-1)]) / (2*dy);

                    // Laplacian of velocity components
                    const lapU = (u[idx(x-1, y)] + u[idx(x+1, y)] - 2*u[i]) / dx2 +
                                 (u[idx(x, y-1)] + u[idx(x, y+1)] - 2*u[i]) / dy2;
                    const lapV = (v[idx(x-1, y)] + v[idx(x+1, y)] - 2*v[i]) / dx2 +
                                 (v[idx(x, y-1)] + v[idx(x, y+1)] - 2*v[i]) / dy2;

                    // Advection of velocity
                    const dudx = u[i] > 0 ? (u[i] - u[idx(x-1, y)]) / dx : (u[idx(x+1, y)] - u[i]) / dx;
                    const dudy = v[i] > 0 ? (u[i] - u[idx(x, y-1)]) / dy : (u[idx(x, y+1)] - u[i]) / dy;
                    const dvdx = u[i] > 0 ? (v[i] - v[idx(x-1, y)]) / dx : (v[idx(x+1, y)] - v[i]) / dx;
                    const dvdy = v[i] > 0 ? (v[i] - v[idx(x, y-1)]) / dy : (v[idx(x, y+1)] - v[i]) / dy;

                    // Horizontal temperature gradient for buoyancy
                    const dTdx_center = (T[idx(x+1, y)] - T[idx(x-1, y)]) / (2*dx);

                    // Buoyancy force (proportional to temperature)
                    const buoyancy = buoyancyCoeff * (T[i] - 0.5);

                    // Update velocities
                    uNext[i] = u[i] + dt * (nu * lapU - u[i]*dudx - v[i]*dudy);
                    vNext[i] = v[i] + dt * (nu * lapV - u[i]*dvdx - v[i]*dvdy + buoyancy);
                }
            }

            // Velocity boundary conditions (no-slip)
            for (let x = 0; x < gridWidth; x++) {
                uNext[idx(x, 0)] = 0;
                vNext[idx(x, 0)] = 0;
                uNext[idx(x, gridHeight - 1)] = 0;
                vNext[idx(x, gridHeight - 1)] = 0;
            }

            // Swap buffers
            [T, Tnext] = [Tnext, T];
            [u, uNext] = [uNext, u];
            [v, vNext] = [vNext, v];

            // Project to enforce incompressibility (simple pressure correction)
            projectVelocity(dt, dx, dy);
        }

        function projectVelocity(dt, dx, dy) {
            // Simple pressure projection to enforce div(v) = 0
            const relaxation = 0.8;
            const iterations = 10;

            for (let iter = 0; iter < iterations; iter++) {
                for (let y = 1; y < gridHeight - 1; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        const i = idx(x, y);

                        // Divergence
                        const div = (u[idx(x+1, y)] - u[idx(x-1, y)]) / (2*dx) +
                                    (v[idx(x, y+1)] - v[idx(x, y-1)]) / (2*dy);

                        // Correct velocities
                        const correction = relaxation * div * 0.25;
                        u[idx(x-1, y)] -= correction;
                        u[idx(x+1, y)] += correction;
                        v[idx(x, y-1)] -= correction;
                        v[idx(x, y+1)] += correction;
                    }
                }
            }
        }

        function calculateNusselt() {
            // Nusselt number: ratio of convective to conductive heat transfer
            // Nu = 1 + <v*T> / (kappa * dT/dz)
            let convectiveFlux = 0;
            let count = 0;

            for (let y = 1; y < gridHeight - 1; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const i = idx(x, y);
                    convectiveFlux += v[i] * (T[i] - 0.5);
                    count++;
                }
            }

            convectiveFlux /= count;

            // Normalize by conductive flux
            const conductiveFlux = 1.0 / gridHeight;
            const Nu = 1 + Math.abs(convectiveFlux) / conductiveFlux * 10;

            return Math.max(1, Nu).toFixed(2);
        }

        function getMaxVelocity() {
            let maxV = 0;
            for (let i = 0; i < u.length; i++) {
                const speed = Math.sqrt(u[i]*u[i] + v[i]*v[i]);
                if (speed > maxV) maxV = speed;
            }
            return maxV.toFixed(4);
        }

        function draw() {
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, width, height);

            const offsetX = (width - gridWidth * CELL_SIZE) / 2;
            const offsetY = (height - gridHeight * CELL_SIZE) / 2;

            const imageData = ctx.createImageData(gridWidth * CELL_SIZE, gridHeight * CELL_SIZE);
            const data = imageData.data;

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const i = idx(x, y);
                    let r, g, b;

                    if (viewMode === 'temperature') {
                        // Temperature: blue (cold) to red (hot)
                        const temp = Math.max(0, Math.min(1, T[i]));
                        if (temp < 0.5) {
                            r = Math.floor(temp * 2 * 255);
                            g = Math.floor(temp * 2 * 100);
                            b = Math.floor(255 - temp * 2 * 155);
                        } else {
                            r = 255;
                            g = Math.floor((1 - (temp - 0.5) * 2) * 100);
                            b = Math.floor((1 - (temp - 0.5) * 2) * 100);
                        }
                    } else if (viewMode === 'velocity') {
                        // Velocity magnitude
                        const speed = Math.sqrt(u[i]*u[i] + v[i]*v[i]);
                        const normalized = Math.min(1, speed * 50);
                        r = Math.floor(255 * normalized);
                        g = Math.floor(107 * normalized);
                        b = Math.floor(53 * normalized);
                    } else {
                        // Vorticity: green for positive, purple for negative
                        const vort = omega[i];
                        const magnitude = Math.min(1, Math.abs(vort) * 100);
                        if (vort > 0) {
                            r = Math.floor(50 * magnitude);
                            g = Math.floor(255 * magnitude);
                            b = Math.floor(100 * magnitude);
                        } else {
                            r = Math.floor(200 * magnitude);
                            g = Math.floor(50 * magnitude);
                            b = Math.floor(255 * magnitude);
                        }
                    }

                    // Fill cell
                    for (let py = 0; py < CELL_SIZE; py++) {
                        for (let px = 0; px < CELL_SIZE; px++) {
                            const pixelX = x * CELL_SIZE + px;
                            const pixelY = y * CELL_SIZE + py;
                            const pixelIdx = (pixelY * gridWidth * CELL_SIZE + pixelX) * 4;
                            data[pixelIdx] = r;
                            data[pixelIdx + 1] = g;
                            data[pixelIdx + 2] = b;
                            data[pixelIdx + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, offsetX, offsetY);

            // Draw boundary indicators
            ctx.fillStyle = '#ff6b35';
            ctx.font = '12px sans-serif';
            ctx.fillText('HOT (T=1)', offsetX, offsetY + gridHeight * CELL_SIZE + 15);
            ctx.fillStyle = '#4da6ff';
            ctx.fillText('COLD (T=0)', offsetX, offsetY - 5);

            // Draw velocity vectors (sparse)
            if (viewMode === 'temperature') {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                const step = 8;
                for (let y = step/2; y < gridHeight; y += step) {
                    for (let x = step/2; x < gridWidth; x += step) {
                        const i = idx(x, y);
                        const vx = u[i] * 200;
                        const vy = v[i] * 200;
                        const cx = offsetX + x * CELL_SIZE + CELL_SIZE/2;
                        const cy = offsetY + y * CELL_SIZE + CELL_SIZE/2;

                        if (Math.abs(vx) > 0.5 || Math.abs(vy) > 0.5) {
                            ctx.beginPath();
                            ctx.moveTo(cx, cy);
                            ctx.lineTo(cx + vx, cy + vy);
                            ctx.stroke();
                        }
                    }
                }
            }
        }

        // UI event handlers
        document.getElementById('rayleigh').addEventListener('input', (e) => {
            Ra = parseFloat(e.target.value);
            document.getElementById('raVal').textContent = Ra;
            document.getElementById('raRatio').textContent = (Ra / Ra_c).toFixed(2);
        });

        document.getElementById('prandtl').addEventListener('input', (e) => {
            Pr = parseFloat(e.target.value);
            document.getElementById('prVal').textContent = Pr.toFixed(1);
        });

        document.getElementById('deltaT').addEventListener('input', (e) => {
            deltaT = parseFloat(e.target.value);
            document.getElementById('dtVal').textContent = deltaT;
        });

        document.getElementById('aspectRatio').addEventListener('input', (e) => {
            aspectRatio = parseFloat(e.target.value);
            document.getElementById('arVal').textContent = aspectRatio.toFixed(1);
            resize();
        });

        document.getElementById('resetBtn').addEventListener('click', init);

        document.getElementById('pauseBtn').addEventListener('click', function() {
            paused = !paused;
            this.textContent = paused ? 'Resume' : 'Pause';
        });

        document.getElementById('perturbBtn').addEventListener('click', addPerturbation);

        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                viewMode = this.dataset.mode;
            });
        });

        window.addEventListener('resize', resize);

        let lastTime = performance.now();
        let frameCount = 0;
        let fpsTime = 0;

        function animate() {
            const now = performance.now();
            const dt = Math.min((now - lastTime) / 1000, 0.033);
            lastTime = now;

            frameCount++;
            fpsTime += dt;
            if (fpsTime >= 1) {
                document.getElementById('fps').textContent = Math.round(frameCount / fpsTime);
                document.getElementById('nusselt').textContent = calculateNusselt();
                document.getElementById('maxVel').textContent = getMaxVelocity();
                document.getElementById('raRatio').textContent = (Ra / Ra_c).toFixed(2);
                frameCount = 0;
                fpsTime = 0;
            }

            if (!paused) {
                const substeps = 3;
                const subDt = 0.002;
                for (let i = 0; i < substeps; i++) {
                    step(subDt);
                }
            }
            draw();

            requestAnimationFrame(animate);
        }

        resize();
        animate();
    </script>
    <script src="../../assets/js/enhance.js" defer></script>
</body>
</html>
