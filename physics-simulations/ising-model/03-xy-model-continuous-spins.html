<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XY Model - Continuous Spins</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 5px;
        }
        input { width: 200px; }
    </style>
</head>
<body>
    <div class="controls">
        <h3>XY Model (Continuous Spins)</h3>
        <label>Temperature: <span id="temp">0.5</span></label><br>
        <input type="range" id="temperature" min="0.1" max="2" step="0.01" value="0.5"><br>
        <div style="margin-top:10px; font-size:12px">
            <div>Vorticity: <span id="vorticity">0</span></div>
            <div>Shows Kosterlitz-Thouless transition</div>
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 80;
        const cellSize = 8;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;

        let spins = [];
        let temperature = 0.5;

        function initSpins() {
            spins = [];
            for (let i = 0; i < gridSize; i++) {
                spins[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    spins[i][j] = Math.random() * 2 * Math.PI;
                }
            }
        }

        function getEnergy(i, j) {
            const theta = spins[i][j];
            const neighbors = [
                spins[(i+1)%gridSize][j],
                spins[(i-1+gridSize)%gridSize][j],
                spins[i][(j+1)%gridSize],
                spins[i][(j-1+gridSize)%gridSize]
            ];
            let energy = 0;
            for (const n of neighbors) {
                energy -= Math.cos(theta - n);
            }
            return energy;
        }

        function mcStep() {
            for (let n = 0; n < gridSize * gridSize / 2; n++) {
                const i = Math.floor(Math.random() * gridSize);
                const j = Math.floor(Math.random() * gridSize);

                const oldEnergy = getEnergy(i, j);
                const oldTheta = spins[i][j];
                spins[i][j] = Math.random() * 2 * Math.PI;
                const newEnergy = getEnergy(i, j);
                const dE = newEnergy - oldEnergy;

                if (dE > 0 && Math.random() > Math.exp(-dE / temperature)) {
                    spins[i][j] = oldTheta;
                }
            }
        }

        function countVortices() {
            let vortexCount = 0;
            for (let i = 0; i < gridSize-1; i++) {
                for (let j = 0; j < gridSize-1; j++) {
                    const angles = [
                        spins[i][j],
                        spins[i+1][j],
                        spins[i+1][j+1],
                        spins[i][j+1]
                    ];

                    let sum = 0;
                    for (let k = 0; k < 4; k++) {
                        let diff = angles[(k+1)%4] - angles[k];
                        while (diff > Math.PI) diff -= 2*Math.PI;
                        while (diff < -Math.PI) diff += 2*Math.PI;
                        sum += diff;
                    }

                    if (Math.abs(sum) > Math.PI) {
                        vortexCount++;
                    }
                }
            }
            return vortexCount;
        }

        function render() {
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const theta = spins[i][j];
                    const hue = (theta / (2 * Math.PI)) * 360;
                    ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                    ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);

                    // Draw arrow
                    const cx = i * cellSize + cellSize/2;
                    const cy = j * cellSize + cellSize/2;
                    const len = cellSize * 0.4;
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + len * Math.cos(theta), cy + len * Math.sin(theta));
                    ctx.stroke();
                }
            }

            document.getElementById('vorticity').textContent = countVortices();
        }

        function animate() {
            mcStep();
            render();
            requestAnimationFrame(animate);
        }

        document.getElementById('temperature').addEventListener('input', (e) => {
            temperature = parseFloat(e.target.value);
            document.getElementById('temp').textContent = temperature.toFixed(2);
        });

        initSpins();
        animate();
    </script>
</body>
</html>
