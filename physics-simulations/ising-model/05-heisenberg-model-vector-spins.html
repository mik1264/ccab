<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heisenberg Model - Vector Spins</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        .controls {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.8); color: white;
            padding: 15px; border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <h3>Heisenberg Model (3D Spins)</h3>
        <label>Temperature: <span id="temp">1.0</span></label><br>
        <input type="range" id="temperature" min="0.1" max="3" step="0.01" value="1.0"><br>
        <div style="margin-top:10px; font-size:12px">
            Vector spins on 2D lattice
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 40;
        const cellSize = 15;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;

        let spins = [];
        let temperature = 1.0;

        function initSpins() {
            spins = [];
            for (let i = 0; i < gridSize; i++) {
                spins[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    const theta = Math.random() * Math.PI;
                    const phi = Math.random() * 2 * Math.PI;
                    spins[i][j] = {
                        x: Math.sin(theta) * Math.cos(phi),
                        y: Math.sin(theta) * Math.sin(phi),
                        z: Math.cos(theta)
                    };
                }
            }
        }

        function dot(a, b) {
            return a.x * b.x + a.y * b.y + a.z * b.z;
        }

        function getEnergy(i, j) {
            const spin = spins[i][j];
            const neighbors = [
                spins[(i+1)%gridSize][j],
                spins[(i-1+gridSize)%gridSize][j],
                spins[i][(j+1)%gridSize],
                spins[i][(j-1+gridSize)%gridSize]
            ];
            let energy = 0;
            neighbors.forEach(n => energy -= dot(spin, n));
            return energy;
        }

        function mcStep() {
            for (let n = 0; n < gridSize * gridSize / 4; n++) {
                const i = Math.floor(Math.random() * gridSize);
                const j = Math.floor(Math.random() * gridSize);

                const oldE = getEnergy(i, j);
                const oldSpin = {...spins[i][j]};

                const theta = Math.random() * Math.PI;
                const phi = Math.random() * 2 * Math.PI;
                spins[i][j] = {
                    x: Math.sin(theta) * Math.cos(phi),
                    y: Math.sin(theta) * Math.sin(phi),
                    z: Math.cos(theta)
                };

                const newE = getEnergy(i, j);
                const dE = newE - oldE;

                if (dE > 0 && Math.random() > Math.exp(-dE / temperature)) {
                    spins[i][j] = oldSpin;
                }
            }
        }

        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const spin = spins[i][j];
                    const cx = i * cellSize + cellSize/2;
                    const cy = j * cellSize + cellSize/2;

                    // Color based on z-component
                    const hue = (spin.z + 1) * 180;
                    ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                    ctx.fillRect(i * cellSize, j * cellSize, cellSize-1, cellSize-1);

                    // Draw projection
                    const len = cellSize * 0.4;
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + len * spin.x, cy + len * spin.y);
                    ctx.stroke();
                }
            }
        }

        function animate() {
            mcStep();
            render();
            requestAnimationFrame(animate);
        }

        document.getElementById('temperature').oninput = e => {
            temperature = parseFloat(e.target.value);
            document.getElementById('temp').textContent = temperature.toFixed(2);
        };

        initSpins();
        animate();
    </script>
</body>
</html>
