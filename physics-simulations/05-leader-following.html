<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leader Following Boids</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas { display: block; background: radial-gradient(circle at 50% 50%, #1a1a2e, #000); }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
        }
        .leader { color: #ffd700; }
        .follower { color: #4fc3f7; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="info">
        <h3 style="margin: 0 0 10px 0;">Leader-Follower Dynamics</h3>
        <div><span class="leader">● Leader</span> follows mouse</div>
        <div><span class="follower">● Followers</span> follow leader</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let mouse = { x: canvas.width / 2, y: canvas.height / 2 };

        canvas.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        class Boid {
            constructor(x, y, isLeader = false) {
                this.position = { x, y };
                this.velocity = { x: Math.random() - 0.5, y: Math.random() - 0.5 };
                this.acceleration = { x: 0, y: 0 };
                this.isLeader = isLeader;
                this.maxSpeed = isLeader ? 5 : 4;
                this.maxForce = isLeader ? 0.3 : 0.15;
                this.perception = 70;
                this.trail = [];
            }

            followMouse() {
                if (!this.isLeader) return;

                const desired = {
                    x: mouse.x - this.position.x,
                    y: mouse.y - this.position.y
                };
                const distance = Math.sqrt(desired.x ** 2 + desired.y ** 2);

                if (distance > 10) {
                    const steer = this.setMag(desired, this.maxSpeed);
                    steer.x -= this.velocity.x;
                    steer.y -= this.velocity.y;
                    const limited = this.limit(steer, this.maxForce);
                    this.acceleration.x += limited.x * 2;
                    this.acceleration.y += limited.y * 2;
                }
            }

            followLeader(leader) {
                if (this.isLeader) return;

                const desired = {
                    x: leader.position.x - this.position.x,
                    y: leader.position.y - this.position.y
                };
                const distance = Math.sqrt(desired.x ** 2 + desired.y ** 2);

                if (distance > 50) {
                    const steer = this.setMag(desired, this.maxSpeed);
                    steer.x -= this.velocity.x;
                    steer.y -= this.velocity.y;
                    const limited = this.limit(steer, this.maxForce);
                    this.acceleration.x += limited.x * 1.5;
                    this.acceleration.y += limited.y * 1.5;
                }
            }

            flock(boids) {
                if (this.isLeader) return;

                let alignment = { x: 0, y: 0 };
                let cohesion = { x: 0, y: 0 };
                let separation = { x: 0, y: 0 };
                let total = 0;

                for (let other of boids) {
                    const d = this.distance(other);

                    if (other !== this && !other.isLeader && d < this.perception) {
                        alignment.x += other.velocity.x;
                        alignment.y += other.velocity.y;
                        cohesion.x += other.position.x;
                        cohesion.y += other.position.y;

                        if (d < this.perception / 2) {
                            let diff = {
                                x: this.position.x - other.position.x,
                                y: this.position.y - other.position.y
                            };
                            if (d > 0) {
                                diff.x /= d;
                                diff.y /= d;
                            }
                            separation.x += diff.x;
                            separation.y += diff.y;
                        }

                        total++;
                    }
                }

                if (total > 0) {
                    alignment.x /= total;
                    alignment.y /= total;
                    alignment = this.setMag(alignment, this.maxSpeed);
                    alignment.x -= this.velocity.x;
                    alignment.y -= this.velocity.y;
                    alignment = this.limit(alignment, this.maxForce);

                    cohesion.x /= total;
                    cohesion.y /= total;
                    cohesion.x -= this.position.x;
                    cohesion.y -= this.position.y;
                    cohesion = this.setMag(cohesion, this.maxSpeed);
                    cohesion.x -= this.velocity.x;
                    cohesion.y -= this.velocity.y;
                    cohesion = this.limit(cohesion, this.maxForce);

                    separation = this.setMag(separation, this.maxSpeed);
                    separation.x -= this.velocity.x;
                    separation.y -= this.velocity.y;
                    separation = this.limit(separation, this.maxForce);

                    this.acceleration.x += alignment.x + cohesion.x * 0.5 + separation.x * 1.2;
                    this.acceleration.y += alignment.y + cohesion.y * 0.5 + separation.y * 1.2;
                }
            }

            update() {
                this.velocity.x += this.acceleration.x;
                this.velocity.y += this.acceleration.y;

                const speed = Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2);
                if (speed > this.maxSpeed) {
                    this.velocity.x = (this.velocity.x / speed) * this.maxSpeed;
                    this.velocity.y = (this.velocity.y / speed) * this.maxSpeed;
                }

                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;

                this.trail.push({ ...this.position });
                if (this.trail.length > 20) this.trail.shift();

                this.acceleration.x = 0;
                this.acceleration.y = 0;
            }

            draw() {
                const angle = Math.atan2(this.velocity.y, this.velocity.x);
                const color = this.isLeader ? '#ffd700' : '#4fc3f7';

                // Draw trail
                ctx.strokeStyle = color;
                ctx.lineWidth = this.isLeader ? 2 : 1;
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                for (let i = 0; i < this.trail.length; i++) {
                    if (i === 0) {
                        ctx.moveTo(this.trail[i].x, this.trail[i].y);
                    } else {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                }
                ctx.stroke();
                ctx.globalAlpha = 1;

                // Draw boid
                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(angle);

                const size = this.isLeader ? 10 : 6;
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(size, 0);
                ctx.lineTo(-size, size / 2);
                ctx.lineTo(-size, -size / 2);
                ctx.closePath();
                ctx.fill();

                ctx.shadowBlur = this.isLeader ? 20 : 10;
                ctx.shadowColor = color;
                ctx.fill();

                ctx.restore();
            }

            distance(other) {
                return Math.sqrt(
                    (this.position.x - other.position.x) ** 2 +
                    (this.position.y - other.position.y) ** 2
                );
            }

            setMag(vec, mag) {
                const m = Math.sqrt(vec.x ** 2 + vec.y ** 2);
                if (m > 0) return { x: (vec.x / m) * mag, y: (vec.y / m) * mag };
                return vec;
            }

            limit(vec, max) {
                const m = Math.sqrt(vec.x ** 2 + vec.y ** 2);
                if (m > max) return { x: (vec.x / m) * max, y: (vec.y / m) * max };
                return vec;
            }
        }

        const boids = [];
        const leader = new Boid(canvas.width / 2, canvas.height / 2, true);
        boids.push(leader);

        for (let i = 0; i < 80; i++) {
            boids.push(new Boid(Math.random() * canvas.width, Math.random() * canvas.height));
        }

        function animate() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let boid of boids) {
                if (boid.isLeader) {
                    boid.followMouse();
                } else {
                    boid.followLeader(leader);
                    boid.flock(boids);
                }
                boid.update();
                boid.draw();
            }

            requestAnimationFrame(animate);
        }

        animate();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>
