<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hodgepodge Machine - Chemical Clock</title>
    <style>
        * { margin: 0; padding: 0; }
        body { background: #000; color: #e0e0e0; font-family: sans-serif; overflow: hidden; }
        #canvas { display: block; }
        .info { position: fixed; top: 20px; left: 20px; background: rgba(26, 26, 46, 0.95); padding: 20px; border-radius: 10px; max-width: 300px; }
        h1 { font-size: 1.3em; color: #64ffda; margin-bottom: 10px; }
        p { font-size: 0.85em; color: #c0c0c0; line-height: 1.6; }
    </style>
</head>
<body>
    <div class="info">
        <h1>Hodgepodge Machine</h1>
        <p>Continuous-valued CA modeling chemical oscillations. Creates spiral waves similar to BZ reaction.</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
        const cellSize = 3, cols = Math.floor(window.innerWidth / cellSize), rows = Math.floor(window.innerHeight / cellSize);
        canvas.width = cols * cellSize; canvas.height = rows * cellSize;

        let grid = new Float32Array(cols * rows);
        const k1 = 2, k2 = 3, g = 50;

        for (let i = 0; i < grid.length; i++) {
            grid[i] = Math.floor(Math.random() * (g + 1));
        }

        // Add some initial excitation centers
        for (let i = 0; i < 5; i++) {
            const x = Math.floor(Math.random() * cols);
            const y = Math.floor(Math.random() * rows);
            for (let dy = -5; dy <= 5; dy++) {
                for (let dx = -5; dx <= 5; dx++) {
                    const nx = (x + dx + cols) % cols;
                    const ny = (y + dy + rows) % rows;
                    grid[ny * cols + nx] = g;
                }
            }
        }

        function step() {
            const newGrid = new Float32Array(cols * rows);
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const idx = y * cols + x;
                    const current = grid[idx];

                    let sum = 0, sickCount = 0, healthyCount = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = (x + dx + cols) % cols;
                            const ny = (y + dy + rows) % rows;
                            const val = grid[ny * cols + nx];
                            sum += val;
                            if (val > 0 && val < g) sickCount++;
                            if (val === 0) healthyCount++;
                        }
                    }

                    const avg = sum / 8;

                    if (current === 0) {
                        newGrid[idx] = Math.floor(sickCount / k1) + Math.floor(healthyCount / k2);
                    } else if (current < g) {
                        newGrid[idx] = Math.min(g, Math.floor(avg) + g);
                    } else {
                        newGrid[idx] = 0;
                    }

                    newGrid[idx] = Math.min(g, Math.max(0, newGrid[idx]));
                }
            }
            grid = newGrid;
        }

        function render() {
            const imageData = ctx.createImageData(canvas.width, canvas.height), d = imageData.data;
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const val = grid[y * cols + x] / g;

                    for (let dy = 0; dy < cellSize; dy++) {
                        for (let dx = 0; dx < cellSize; dx++) {
                            const px = x * cellSize + dx, py = y * cellSize + dy;
                            const pidx = (py * canvas.width + px) * 4;

                            const r = Math.floor(val * 255);
                            const g = Math.floor(Math.sin(val * Math.PI) * 200);
                            const b = Math.floor((1 - val) * 255);

                            d[pidx] = r; d[pidx + 1] = g; d[pidx + 2] = b; d[pidx + 3] = 255;
                        }
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function animate() {
            step(); render();
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>
