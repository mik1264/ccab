<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Barnes-Hut Tree Optimization</title>
    <style>
        * { margin: 0; padding: 0; }
        body { background: #000; color: #e0e0e0; font-family: sans-serif; overflow: hidden; }
        #canvas { display: block; }
        .info { position: fixed; top: 20px; left: 20px; background: rgba(26, 26, 46, 0.95); padding: 20px; border-radius: 10px; max-width: 320px; }
        h1 { font-size: 1.3em; color: #64ffda; margin-bottom: 10px; }
        p { font-size: 0.85em; color: #c0c0c0; line-height: 1.6; }
    </style>
</head>
<body>
    <div class="info">
        <h1>Barnes-Hut Algorithm</h1>
        <p>Efficient O(n log n) N-body simulation using quad-tree spatial subdivision. Can simulate thousands of particles in real-time.</p>
        <p>Particles: <span id="count">500</span></p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        const G = 10, dt = 0.1, theta = 0.5;

        class QuadTree {
            constructor(x, y, w, h) {
                this.x = x; this.y = y; this.w = w; this.h = h;
                this.mass = 0; this.cx = 0; this.cy = 0;
                this.children = null; this.body = null;
            }

            insert(b) {
                if (this.mass === 0) {
                    this.mass = b.m; this.cx = b.x; this.cy = b.y; this.body = b;
                } else {
                    if (!this.children) this.subdivide();
                    this.children[this.quadrant(b.x, b.y)].insert(b);
                    this.cx = (this.cx * this.mass + b.x * b.m) / (this.mass + b.m);
                    this.cy = (this.cy * this.mass + b.y * b.m) / (this.mass + b.m);
                    this.mass += b.m;
                }
            }

            subdivide() {
                const hw = this.w / 2, hh = this.h / 2;
                this.children = [
                    new QuadTree(this.x, this.y, hw, hh),
                    new QuadTree(this.x + hw, this.y, hw, hh),
                    new QuadTree(this.x, this.y + hh, hw, hh),
                    new QuadTree(this.x + hw, this.y + hh, hw, hh)
                ];
                if (this.body) {
                    this.children[this.quadrant(this.body.x, this.body.y)].insert(this.body);
                    this.body = null;
                }
            }

            quadrant(x, y) {
                return (x >= this.x + this.w / 2 ? 1 : 0) + (y >= this.y + this.h / 2 ? 2 : 0);
            }

            computeForce(b) {
                if (this.mass === 0) return { fx: 0, fy: 0 };
                const dx = this.cx - b.x, dy = this.cy - b.y;
                const r2 = dx * dx + dy * dy;
                if (r2 < 1) return { fx: 0, fy: 0 };
                const r = Math.sqrt(r2);

                if (this.body || this.w / r < theta) {
                    const f = G * this.mass / r2 / r;
                    return { fx: f * dx, fy: f * dy };
                }

                let fx = 0, fy = 0;
                if (this.children) {
                    this.children.forEach(c => {
                        const force = c.computeForce(b);
                        fx += force.fx; fy += force.fy;
                    });
                }
                return { fx, fy };
            }
        }

        const bodies = [];
        for (let i = 0; i < 500; i++) {
            const angle = Math.random() * Math.PI * 2, r = Math.sqrt(Math.random()) * 300;
            bodies.push({
                x: canvas.width / 2 + r * Math.cos(angle),
                y: canvas.height / 2 + r * Math.sin(angle),
                vx: -Math.sin(angle) * Math.sqrt(G * 1000 / r) * 0.5,
                vy: Math.cos(angle) * Math.sqrt(G * 1000 / r) * 0.5,
                m: 1
            });
        }
        bodies.push({ x: canvas.width / 2, y: canvas.height / 2, vx: 0, vy: 0, m: 1000 });

        function step() {
            const tree = new QuadTree(0, 0, canvas.width, canvas.height);
            bodies.forEach(b => tree.insert(b));

            bodies.forEach(b => {
                const { fx, fy } = tree.computeForce(b);
                b.vx += fx / b.m * dt; b.vy += fy / b.m * dt;
                b.x += b.vx * dt; b.y += b.vy * dt;
            });
        }

        function render() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#64ffda';
            bodies.forEach(b => {
                ctx.fillRect(b.x, b.y, b.m > 10 ? 4 : 2, b.m > 10 ? 4 : 2);
            });
        }

        function animate() {
            step(); render();
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>
