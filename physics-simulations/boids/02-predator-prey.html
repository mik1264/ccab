<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Predator-Prey Boids</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
            background: radial-gradient(circle, #1a1a2e 0%, #0a0a0a 100%);
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
        }
        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
        }
        .prey { color: #4fc3f7; }
        .predator { color: #ff5252; }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link" style="position:fixed;top:15px;left:15px;color:#fff;text-decoration:none;opacity:0.8;">← Back</a>
    <canvas id="canvas"></canvas>

    <div class="info">
        <h3 style="margin: 0 0 10px 0;">Predator-Prey Dynamics</h3>
        <div>Prey: <span class="prey" id="preyCount">80</span></div>
        <div>Predators: <span class="predator" id="predCount">10</span></div>
    </div>

    <div class="legend">
        <span class="prey">● Prey (flee from predators)</span><br>
        <span class="predator">● Predators (hunt prey)</span>
    </div>

    <script src="../../assets/js/demo-utils.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const fps = new FPSCounter({ position: 'top-right' });
        const errorMgr = new ErrorManager();
        setupGlobalErrorHandler((msg, details) => errorMgr.show(msg, details));
        fps.start();

        class Boid {
            constructor(x, y, isPredator = false) {
                this.position = { x, y };
                this.velocity = {
                    x: (Math.random() - 0.5) * 2,
                    y: (Math.random() - 0.5) * 2
                };
                this.acceleration = { x: 0, y: 0 };
                this.isPredator = isPredator;
                this.size = isPredator ? 8 : 5;
                this.maxSpeed = isPredator ? 5 : 4;
                this.maxForce = 0.15;
                this.perception = isPredator ? 100 : 60;
                this.energy = isPredator ? 100 : 50;
            }

            edges() {
                if (this.position.x > canvas.width) this.position.x = 0;
                if (this.position.x < 0) this.position.x = canvas.width;
                if (this.position.y > canvas.height) this.position.y = 0;
                if (this.position.y < 0) this.position.y = canvas.height;
            }

            flock(boids) {
                let alignment = { x: 0, y: 0 };
                let cohesion = { x: 0, y: 0 };
                let separation = { x: 0, y: 0 };
                let total = 0;

                for (let other of boids) {
                    let d = this.distance(other);

                    if (other !== this && other.isPredator === this.isPredator && d < this.perception) {
                        // Alignment
                        alignment.x += other.velocity.x;
                        alignment.y += other.velocity.y;

                        // Cohesion
                        cohesion.x += other.position.x;
                        cohesion.y += other.position.y;

                        // Separation
                        if (d < this.perception / 2) {
                            let diff = {
                                x: this.position.x - other.position.x,
                                y: this.position.y - other.position.y
                            };
                            if (d > 0) {
                                diff.x /= d;
                                diff.y /= d;
                            }
                            separation.x += diff.x;
                            separation.y += diff.y;
                        }

                        total++;
                    }
                }

                if (total > 0) {
                    alignment.x /= total;
                    alignment.y /= total;
                    alignment = this.setMag(alignment, this.maxSpeed);
                    alignment.x -= this.velocity.x;
                    alignment.y -= this.velocity.y;
                    alignment = this.limit(alignment, this.maxForce);

                    cohesion.x /= total;
                    cohesion.y /= total;
                    cohesion.x -= this.position.x;
                    cohesion.y -= this.position.y;
                    cohesion = this.setMag(cohesion, this.maxSpeed);
                    cohesion.x -= this.velocity.x;
                    cohesion.y -= this.velocity.y;
                    cohesion = this.limit(cohesion, this.maxForce);

                    separation = this.setMag(separation, this.maxSpeed);
                    separation.x -= this.velocity.x;
                    separation.y -= this.velocity.y;
                    separation = this.limit(separation, this.maxForce);
                }

                this.acceleration.x += alignment.x + cohesion.x * 0.5 + separation.x * 1.5;
                this.acceleration.y += alignment.y + cohesion.y * 0.5 + separation.y * 1.5;
            }

            hunt(prey) {
                if (!this.isPredator) return;

                let closest = null;
                let closestDist = Infinity;

                for (let p of prey) {
                    if (!p.isPredator) {
                        let d = this.distance(p);
                        if (d < closestDist && d < 150) {
                            closest = p;
                            closestDist = d;
                        }
                    }
                }

                if (closest) {
                    let desired = {
                        x: closest.position.x - this.position.x,
                        y: closest.position.y - this.position.y
                    };
                    desired = this.setMag(desired, this.maxSpeed * 1.5);
                    let steer = {
                        x: desired.x - this.velocity.x,
                        y: desired.y - this.velocity.y
                    };
                    steer = this.limit(steer, this.maxForce * 2);

                    this.acceleration.x += steer.x * 2;
                    this.acceleration.y += steer.y * 2;

                    // Catch prey
                    if (closestDist < 10) {
                        const idx = prey.indexOf(closest);
                        if (idx > -1) {
                            prey.splice(idx, 1);
                            this.energy += 30;
                        }
                    }
                }
            }

            flee(predators) {
                if (this.isPredator) return;

                for (let pred of predators) {
                    if (pred.isPredator) {
                        let d = this.distance(pred);
                        if (d < 120) {
                            let desired = {
                                x: this.position.x - pred.position.x,
                                y: this.position.y - pred.position.y
                            };
                            desired = this.setMag(desired, this.maxSpeed * 1.5);
                            let steer = {
                                x: desired.x - this.velocity.x,
                                y: desired.y - this.velocity.y
                            };
                            steer = this.limit(steer, this.maxForce * 2);

                            this.acceleration.x += steer.x * 3;
                            this.acceleration.y += steer.y * 3;
                        }
                    }
                }
            }

            update() {
                this.velocity.x += this.acceleration.x;
                this.velocity.y += this.acceleration.y;

                let speed = Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2);
                if (speed > this.maxSpeed) {
                    this.velocity.x = (this.velocity.x / speed) * this.maxSpeed;
                    this.velocity.y = (this.velocity.y / speed) * this.maxSpeed;
                }

                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;

                this.acceleration.x = 0;
                this.acceleration.y = 0;

                this.energy -= 0.05;
            }

            draw() {
                const angle = Math.atan2(this.velocity.y, this.velocity.x);
                const color = this.isPredator ? '#ff5252' : '#4fc3f7';

                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(angle);

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(this.size, 0);
                ctx.lineTo(-this.size, this.size / 2);
                ctx.lineTo(-this.size, -this.size / 2);
                ctx.closePath();
                ctx.fill();

                ctx.shadowBlur = 10;
                ctx.shadowColor = color;
                ctx.fill();

                ctx.restore();
            }

            distance(other) {
                return Math.sqrt(
                    (this.position.x - other.position.x) ** 2 +
                    (this.position.y - other.position.y) ** 2
                );
            }

            setMag(vec, mag) {
                let m = Math.sqrt(vec.x ** 2 + vec.y ** 2);
                if (m > 0) {
                    return { x: (vec.x / m) * mag, y: (vec.y / m) * mag };
                }
                return vec;
            }

            limit(vec, max) {
                let m = Math.sqrt(vec.x ** 2 + vec.y ** 2);
                if (m > max) {
                    return { x: (vec.x / m) * max, y: (vec.y / m) * max };
                }
                return vec;
            }
        }

        // Create boids
        const boids = [];

        // Prey
        for (let i = 0; i < 80; i++) {
            boids.push(new Boid(
                Math.random() * canvas.width,
                Math.random() * canvas.height,
                false
            ));
        }

        // Predators
        for (let i = 0; i < 10; i++) {
            boids.push(new Boid(
                Math.random() * canvas.width,
                Math.random() * canvas.height,
                true
            ));
        }

        function animate() {
            fps.update();
            ctx.fillStyle = 'rgba(10, 10, 10, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Separate prey and predators
            const prey = boids.filter(b => !b.isPredator);
            const predators = boids.filter(b => b.isPredator);

            for (let boid of boids) {
                boid.edges();
                boid.flock(boids);

                if (boid.isPredator) {
                    boid.hunt(boids);
                } else {
                    boid.flee(boids);
                }

                boid.update();
                boid.draw();
            }

            // Remove low energy boids
            for (let i = boids.length - 1; i >= 0; i--) {
                if (boids[i].energy <= 0) {
                    boids.splice(i, 1);
                }
            }

            // Repopulate
            if (prey.length < 30 && Math.random() < 0.02) {
                boids.push(new Boid(Math.random() * canvas.width, Math.random() * canvas.height, false));
            }

            if (predators.length < 5 && Math.random() < 0.01) {
                boids.push(new Boid(Math.random() * canvas.width, Math.random() * canvas.height, true));
            }

            // Update counts
            document.getElementById('preyCount').textContent = prey.length;
            document.getElementById('predCount').textContent = predators.length;

            requestAnimationFrame(animate);
        }

        animate();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>
