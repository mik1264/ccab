<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Double Slit Interference</title>
    <style>
        * { margin: 0; padding: 0; }
        body { background: #000; color: #e0e0e0; font-family: sans-serif; overflow: hidden; }
        #canvas { display: block; }
        .info { position: fixed; top: 20px; left: 20px; background: rgba(26, 26, 46, 0.95); padding: 20px; border-radius: 10px; max-width: 300px; }
        h1 { font-size: 1.3em; color: #64ffda; margin-bottom: 10px; }
        p { font-size: 0.85em; color: #c0c0c0; line-height: 1.6; }
    </style>
</head>
<body>
    <div class="info">
        <h1>Double Slit Experiment</h1>
        <p>Classic quantum interference. Wave function passes through two slits, creating characteristic interference pattern on screen.</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
        const NX = 200, NY = 100; canvas.width = NX * 3; canvas.height = NY * 3;

        let psi_r = new Float32Array(NX * NY), psi_i = new Float32Array(NX * NY);
        const barrier = new Uint8Array(NX * NY);

        // Create barrier with two slits
        const slitX = NX / 3;
        for (let y = 0; y < NY; y++) {
            barrier[y * NX + Math.floor(slitX)] = (y < NY / 2 - 8 || y > NY / 2 - 2) && (y < NY / 2 + 2 || y > NY / 2 + 8) ? 1 : 0;
        }

        // Initialize wave source
        for (let y = 0; y < NY; y++) {
            const amp = Math.exp(-((y - NY / 2) ** 2) / 200);
            psi_r[y * NX + 10] = amp;
        }

        function step() {
            const new_r = new Float32Array(NX * NY), new_i = new Float32Array(NX * NY);
            const dt = 0.1, hbar = 1, m = 1;

            for (let y = 1; y < NY - 1; y++) {
                for (let x = 1; x < NX - 1; x++) {
                    const idx = y * NX + x;
                    if (barrier[idx]) {
                        new_r[idx] = 0; new_i[idx] = 0;
                        continue;
                    }

                    const lap_r = psi_r[idx - 1] + psi_r[idx + 1] + psi_r[idx - NX] + psi_r[idx + NX] - 4 * psi_r[idx];
                    const lap_i = psi_i[idx - 1] + psi_i[idx + 1] + psi_i[idx - NX] + psi_i[idx + NX] - 4 * psi_i[idx];

                    new_r[idx] = psi_r[idx] + (dt / hbar) * (hbar ** 2 / (2 * m)) * lap_i;
                    new_i[idx] = psi_i[idx] - (dt / hbar) * (hbar ** 2 / (2 * m)) * lap_r;
                }
            }

            // Source
            for (let y = 20; y < NY - 20; y++) {
                const amp = 0.5 * Math.sin((Date.now() / 50) % (Math.PI * 2));
                new_r[y * NX + 10] = amp * Math.exp(-((y - NY / 2) ** 2) / 200);
            }

            psi_r = new_r; psi_i = new_i;
        }

        function render() {
            const img = ctx.createImageData(canvas.width, canvas.height), d = img.data;
            for (let py = 0; py < canvas.height; py++) {
                for (let px = 0; px < canvas.width; px++) {
                    const x = Math.floor(px / 3), y = Math.floor(py / 3);
                    const idx = y * NX + x;
                    const pidx = (py * canvas.width + px) * 4;

                    if (barrier[idx]) {
                        d[pidx] = 150; d[pidx + 1] = 150; d[pidx + 2] = 150;
                    } else {
                        const prob = psi_r[idx] ** 2 + psi_i[idx] ** 2;
                        const v = Math.min(255, prob * 10000);
                        d[pidx] = v * 0.5; d[pidx + 1] = v; d[pidx + 2] = v * 1.5;
                    }
                    d[pidx + 3] = 255;
                }
            }
            ctx.putImageData(img, 0, 0);
        }

        function animate() {
            for (let i = 0; i < 5; i++) step();
            render();
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>
