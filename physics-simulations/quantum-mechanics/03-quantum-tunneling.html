<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Quantum Tunneling Through Barrier</title>
    <style>
        * { margin: 0; padding: 0; }
        body { background: #000; color: #e0e0e0; font-family: sans-serif; overflow: hidden; }
        #canvas { display: block; }
        .info { position: fixed; top: 20px; left: 20px; background: rgba(26, 26, 46, 0.95); padding: 20px; border-radius: 10px; max-width: 300px; }
        h1 { font-size: 1.3em; color: #64ffda; margin-bottom: 10px; }
        p { font-size: 0.85em; color: #c0c0c0; line-height: 1.6; }
    </style>
</head>
<body>
    <div class="info">
        <h1>Quantum Tunneling</h1>
        <p>Wave packet encounters potential barrier. Classically forbidden, but quantum mechanically, part of the wave tunnels through!</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
        const N = 200; canvas.width = N * 3; canvas.height = 150;

        let psi_r = new Float32Array(N), psi_i = new Float32Array(N);
        const V = new Float32Array(N);

        // Potential barrier
        for (let x = N / 2 - 10; x < N / 2 + 10; x++) V[Math.floor(x)] = 3;

        // Gaussian wave packet
        const x0 = N / 4, sigma = 10, k0 = 1;
        for (let x = 0; x < N; x++) {
            const amp = Math.exp(-((x - x0) ** 2) / (2 * sigma ** 2));
            psi_r[x] = amp * Math.cos(k0 * (x - x0));
            psi_i[x] = amp * Math.sin(k0 * (x - x0));
        }

        function step() {
            const new_r = new Float32Array(N), new_i = new Float32Array(N);
            const dt = 0.1, hbar = 1, m = 1;

            for (let x = 1; x < N - 1; x++) {
                const lap_r = psi_r[x - 1] + psi_r[x + 1] - 2 * psi_r[x];
                const lap_i = psi_i[x - 1] + psi_i[x + 1] - 2 * psi_i[x];

                const H_r = -(hbar ** 2 / (2 * m)) * lap_r + V[x] * psi_r[x];
                const H_i = -(hbar ** 2 / (2 * m)) * lap_i + V[x] * psi_i[x];

                new_r[x] = psi_r[x] + (dt / hbar) * H_i;
                new_i[x] = psi_i[x] - (dt / hbar) * H_r;
            }

            psi_r = new_r; psi_i = new_i;
        }

        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Potential
            ctx.fillStyle = '#3a3a4a';
            for (let x = 0; x < N; x++) {
                if (V[x] > 0) {
                    ctx.fillRect(x * 3, canvas.height / 2 - 40, 3, 80);
                }
            }

            // Wave function
            ctx.strokeStyle = '#64ffda';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = 0; x < N; x++) {
                const prob = psi_r[x] ** 2 + psi_i[x] ** 2;
                const y = canvas.height / 2 - prob * 2000;
                x === 0 ? ctx.moveTo(x * 3, y) : ctx.lineTo(x * 3, y);
            }
            ctx.stroke();

            ctx.strokeStyle = '#ff6b6b80';
            ctx.beginPath();
            for (let x = 0; x < N; x++) {
                const y = canvas.height / 2 - psi_r[x] * 100;
                x === 0 ? ctx.moveTo(x * 3, y) : ctx.lineTo(x * 3, y);
            }
            ctx.stroke();
        }

        function animate() {
            for (let i = 0; i < 3; i++) step();
            render();
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>
