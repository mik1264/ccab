<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>2D Schrödinger Wave Evolution</title>
    <style>
        * { margin: 0; padding: 0; }
        body { background: #000; color: #e0e0e0; font-family: sans-serif; overflow: hidden; }
        #canvas { display: block; }
        .info { position: fixed; top: 20px; left: 20px; background: rgba(26, 26, 46, 0.95); padding: 20px; border-radius: 10px; max-width: 300px; }
        h1 { font-size: 1.3em; color: #64ffda; margin-bottom: 10px; }
        p { font-size: 0.85em; color: #c0c0c0; line-height: 1.6; }
    </style>
</head>
<body>
    <div class="info">
        <h1>Schrödinger Wave Function</h1>
        <p>2D time-dependent Schrödinger equation. Wave packet evolves and disperses over time. <strong>Click</strong> to add wave disturbances.</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
        const N = 128; canvas.width = N * 4; canvas.height = N * 4;

        const hbar = 1, m = 1, dt = 0.05;
        let psi_r = new Float32Array(N * N), psi_i = new Float32Array(N * N);
        let V = new Float32Array(N * N);

        // Initialize Gaussian wave packet
        const cx = N / 2, cy = N / 2, sigma = 10, kx = 0.5, ky = 0.3;
        for (let y = 0; y < N; y++) {
            for (let x = 0; x < N; x++) {
                const idx = y * N + x;
                const r2 = (x - cx) ** 2 + (y - cy) ** 2;
                const amp = Math.exp(-r2 / (2 * sigma ** 2));
                psi_r[idx] = amp * Math.cos(kx * (x - cx) + ky * (y - cy));
                psi_i[idx] = amp * Math.sin(kx * (x - cx) + ky * (y - cy));
            }
        }

        function laplacian(arr, x, y) {
            const idx = y * N + x;
            if (x === 0 || x === N - 1 || y === 0 || y === N - 1) return 0;
            return arr[idx - 1] + arr[idx + 1] + arr[idx - N] + arr[idx + N] - 4 * arr[idx];
        }

        function step() {
            const new_psi_r = new Float32Array(N * N), new_psi_i = new Float32Array(N * N);

            for (let y = 1; y < N - 1; y++) {
                for (let x = 1; x < N - 1; x++) {
                    const idx = y * N + x;
                    const lap_r = laplacian(psi_r, x, y);
                    const lap_i = laplacian(psi_i, x, y);

                    const H_psi_r = -(hbar ** 2 / (2 * m)) * lap_r + V[idx] * psi_r[idx];
                    const H_psi_i = -(hbar ** 2 / (2 * m)) * lap_i + V[idx] * psi_i[idx];

                    new_psi_r[idx] = psi_r[idx] + (dt / hbar) * H_psi_i;
                    new_psi_i[idx] = psi_i[idx] - (dt / hbar) * H_psi_r;
                }
            }

            psi_r = new_psi_r; psi_i = new_psi_i;
        }

        function render() {
            const img = ctx.createImageData(canvas.width, canvas.height), d = img.data;
            for (let py = 0; py < canvas.height; py++) {
                for (let px = 0; px < canvas.width; px++) {
                    const x = Math.floor(px / 4), y = Math.floor(py / 4);
                    const idx = y * N + x;
                    const prob = psi_r[idx] ** 2 + psi_i[idx] ** 2;
                    const v = Math.min(255, prob * 5000);
                    const pidx = (py * canvas.width + px) * 4;
                    d[pidx] = v * 0.5; d[pidx + 1] = v; d[pidx + 2] = v * 1.5; d[pidx + 3] = 255;
                }
            }
            ctx.putImageData(img, 0, 0);
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const px = Math.floor((e.clientX - rect.left) / 4);
            const py = Math.floor((e.clientY - rect.top) / 4);
            for (let dy = -5; dy <= 5; dy++) {
                for (let dx = -5; dx <= 5; dx++) {
                    const x = px + dx, y = py + dy;
                    if (x >= 0 && x < N && y >= 0 && y < N) {
                        const idx = y * N + x;
                        psi_r[idx] += 0.5; psi_i[idx] += 0.5;
                    }
                }
            }
        });

        function animate() {
            for (let i = 0; i < 2; i++) step();
            render();
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>
