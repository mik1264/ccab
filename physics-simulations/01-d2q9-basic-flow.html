<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D2Q9 Lattice Boltzmann - Basic Flow</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #e0e0e0; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        #canvas { display: block; background: #000; }
        .controls { position: fixed; top: 20px; right: 20px; background: rgba(26, 26, 46, 0.95); padding: 20px; border-radius: 10px; min-width: 250px; }
        .info { position: fixed; top: 20px; left: 20px; background: rgba(26, 26, 46, 0.95); padding: 20px; border-radius: 10px; max-width: 320px; }
        h1 { font-size: 1.3em; margin-bottom: 10px; color: #64ffda; }
        h2 { font-size: 1em; margin-bottom: 15px; color: #64ffda; }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-size: 0.9em; color: #b0b0b0; }
        input[type="range"] { width: 100%; }
        .value { font-size: 0.85em; color: #64ffda; }
        button { width: 100%; padding: 10px; margin: 10px 0; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer; }
        button:hover { background: #764ba2; }
        .info p { font-size: 0.85em; line-height: 1.6; margin-bottom: 10px; color: #c0c0c0; }
    </style>
</head>
<body>
    <div class="info">
        <h1>D2Q9 Lattice Boltzmann</h1>
        <p>Computational fluid dynamics using the Lattice Boltzmann Method with 9 velocity directions (D2Q9 model).</p>
        <p><strong>Click and drag</strong> to create flow disturbances.</p>
    </div>
    <div class="controls">
        <h2>Flow Parameters</h2>
        <div class="control-group">
            <label>Viscosity: <span class="value" id="viscValue">0.1</span></label>
            <input type="range" id="viscSlider" min="0.01" max="0.3" step="0.01" value="0.1">
        </div>
        <div class="control-group">
            <label>Flow Speed: <span class="value" id="speedValue">0.1</span></label>
            <input type="range" id="speedSlider" min="0" max="0.3" step="0.01" value="0.1">
        </div>
        <button id="resetBtn">Reset</button>
        <button id="pauseBtn">Pause</button>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const NX = 200, NY = 100;
        canvas.width = NX * 4; canvas.height = NY * 4;

        let viscosity = 0.1, flowSpeed = 0.1, paused = false;
        const tau = 3 * viscosity + 0.5;
        const omega = 1 / tau;

        // D2Q9 lattice velocities
        const ex = [0, 1, 0, -1, 0, 1, -1, -1, 1];
        const ey = [0, 0, 1, 0, -1, 1, 1, -1, -1];
        const w = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];

        let f = new Array(9).fill(0).map(() => new Float32Array(NX * NY));
        let feq = new Array(9).fill(0).map(() => new Float32Array(NX * NY));
        let ux = new Float32Array(NX * NY), uy = new Float32Array(NX * NY);
        let rho = new Float32Array(NX * NY);
        let mouseDown = false;

        function init() {
            for (let i = 0; i < NX * NY; i++) {
                rho[i] = 1; ux[i] = flowSpeed; uy[i] = 0;
                for (let k = 0; k < 9; k++) {
                    f[k][i] = w[k];
                }
            }
        }

        function equilibrium(k, r, u, v) {
            const cu = ex[k] * u + ey[k] * v;
            const usq = u * u + v * v;
            return w[k] * r * (1 + 3 * cu + 4.5 * cu * cu - 1.5 * usq);
        }

        function step() {
            // Collision
            for (let y = 0; y < NY; y++) {
                for (let x = 0; x < NX; x++) {
                    const idx = y * NX + x;
                    for (let k = 0; k < 9; k++) {
                        feq[k][idx] = equilibrium(k, rho[idx], ux[idx], uy[idx]);
                        f[k][idx] += omega * (feq[k][idx] - f[k][idx]);
                    }
                }
            }

            // Streaming
            const fnew = new Array(9).fill(0).map(() => new Float32Array(NX * NY));
            for (let y = 0; y < NY; y++) {
                for (let x = 0; x < NX; x++) {
                    const idx = y * NX + x;
                    for (let k = 0; k < 9; k++) {
                        const nx = (x + ex[k] + NX) % NX;
                        const ny = (y + ey[k] + NY) % NY;
                        fnew[k][ny * NX + nx] = f[k][idx];
                    }
                }
            }
            f = fnew;

            // Compute macroscopic
            for (let i = 0; i < NX * NY; i++) {
                rho[i] = 0; ux[i] = 0; uy[i] = 0;
                for (let k = 0; k < 9; k++) {
                    rho[i] += f[k][i];
                    ux[i] += ex[k] * f[k][i];
                    uy[i] += ey[k] * f[k][i];
                }
                ux[i] /= rho[i]; uy[i] /= rho[i];
            }
        }

        function render() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let py = 0; py < canvas.height; py++) {
                for (let px = 0; px < canvas.width; px++) {
                    const x = Math.floor(px / 4), y = Math.floor(py / 4);
                    const idx = y * NX + x;
                    const speed = Math.sqrt(ux[idx] * ux[idx] + uy[idx] * uy[idx]);
                    const v = Math.min(1, speed * 20);

                    const pidx = (py * canvas.width + px) * 4;
                    data[pidx] = Math.floor(v * 100);
                    data[pidx + 1] = Math.floor(v * 200);
                    data[pidx + 2] = Math.floor(v * 255);
                    data[pidx + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function animate() {
            if (!paused) {
                for (let i = 0; i < 3; i++) step();
                render();
            }
            requestAnimationFrame(animate);
        }

        canvas.addEventListener('mousedown', () => { mouseDown = true; });
        canvas.addEventListener('mouseup', () => { mouseDown = false; });
        canvas.addEventListener('mousemove', (e) => {
            if (mouseDown) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / 4);
                const y = Math.floor((e.clientY - rect.top) / 4);
                if (x >= 0 && x < NX && y >= 0 && y < NY) {
                    const idx = y * NX + x;
                    uy[idx] = (Math.random() - 0.5) * 0.3;
                }
            }
        });

        document.getElementById('viscSlider').addEventListener('input', (e) => {
            viscosity = parseFloat(e.target.value);
            document.getElementById('viscValue').textContent = viscosity.toFixed(2);
        });
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            flowSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = flowSpeed.toFixed(2);
            init();
        });
        document.getElementById('resetBtn').addEventListener('click', init);
        document.getElementById('pauseBtn').addEventListener('click', (e) => {
            paused = !paused; e.target.textContent = paused ? 'Resume' : 'Pause';
        });

        init(); animate();
    </script>
</body>
</html>
