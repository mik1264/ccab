<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Von Karman Vortex Street</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #1a1a2e; color: #e0e0e0; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        #canvas { display: block; }
        .info { position: fixed; top: 20px; left: 20px; background: rgba(26, 26, 46, 0.95); padding: 20px; border-radius: 10px; max-width: 300px; }
        h1 { font-size: 1.3em; margin-bottom: 10px; color: #64ffda; }
        p { font-size: 0.85em; line-height: 1.6; color: #c0c0c0; }
    </style>
</head>
<body>
    <div class="info">
        <h1>Vortex Shedding</h1>
        <p>Von Karman vortex street forms behind cylindrical obstacles. Alternating vortices create beautiful periodic flow patterns.</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const NX = 300, NY = 100;
        canvas.width = NX * 3; canvas.height = NY * 3;

        const ex = [0, 1, 0, -1, 0, 1, -1, -1, 1];
        const ey = [0, 0, 1, 0, -1, 1, 1, -1, -1];
        const w = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
        const omega = 1.7;

        let f = Array(9).fill(0).map(() => new Float32Array(NX * NY));
        let ux = new Float32Array(NX * NY), uy = new Float32Array(NX * NY);
        let rho = new Float32Array(NX * NY);
        let obstacle = new Uint8Array(NX * NY);

        // Place cylinder
        const cx = NX / 4, cy = NY / 2, radius = 10;
        for (let y = 0; y < NY; y++) {
            for (let x = 0; x < NX; x++) {
                const dist = Math.hypot(x - cx, y - cy);
                if (dist < radius) obstacle[y * NX + x] = 1;
                rho[y * NX + x] = 1;
                ux[y * NX + x] = 0.1;
                uy[y * NX + x] = 0;
                for (let k = 0; k < 9; k++) {
                    const cu = ex[k] * 0.1;
                    f[k][y * NX + x] = w[k] * (1 + 3 * cu + 4.5 * cu * cu - 1.5 * 0.01);
                }
            }
        }

        function step() {
            // Collision
            for (let i = 0; i < NX * NY; i++) {
                if (obstacle[i]) continue;
                const usq = ux[i] * ux[i] + uy[i] * uy[i];
                for (let k = 0; k < 9; k++) {
                    const cu = ex[k] * ux[i] + ey[k] * uy[i];
                    const feq = w[k] * rho[i] * (1 + 3 * cu + 4.5 * cu * cu - 1.5 * usq);
                    f[k][i] += omega * (feq - f[k][i]);
                }
            }

            // Streaming + bounce-back
            const fnew = Array(9).fill(0).map(() => new Float32Array(NX * NY));
            for (let y = 0; y < NY; y++) {
                for (let x = 0; x < NX; x++) {
                    const idx = y * NX + x;
                    for (let k = 0; k < 9; k++) {
                        let nx = x + ex[k], ny = y + ey[k];
                        if (nx < 0) nx = NX - 1; if (nx >= NX) nx = 0;
                        if (ny < 0) ny = NY - 1; if (ny >= NY) ny = 0;
                        const nidx = ny * NX + nx;
                        if (obstacle[nidx]) {
                            const opp = [0, 3, 4, 1, 2, 7, 8, 5, 6][k];
                            fnew[opp][idx] = f[k][idx];
                        } else {
                            fnew[k][nidx] = f[k][idx];
                        }
                    }
                }
            }
            f = fnew;

            // Macroscopic
            for (let i = 0; i < NX * NY; i++) {
                if (obstacle[i]) continue;
                rho[i] = 0; ux[i] = 0; uy[i] = 0;
                for (let k = 0; k < 9; k++) {
                    rho[i] += f[k][i];
                    ux[i] += ex[k] * f[k][i];
                    uy[i] += ey[k] * f[k][i];
                }
                ux[i] /= rho[i]; uy[i] /= rho[i];
            }

            // Inflow
            for (let y = 0; y < NY; y++) {
                ux[y * NX] = 0.1; uy[y * NX] = 0;
            }
        }

        function render() {
            const img = ctx.createImageData(canvas.width, canvas.height);
            const d = img.data;
            for (let py = 0; py < canvas.height; py++) {
                for (let px = 0; px < canvas.width; px++) {
                    const x = Math.floor(px / 3), y = Math.floor(py / 3);
                    const idx = y * NX + x;
                    const curl = (x > 0 && x < NX-1 && y > 0 && y < NY-1) ?
                        (uy[idx + 1] - uy[idx - 1] - ux[idx + NX] + ux[idx - NX]) : 0;
                    const v = Math.abs(curl) * 100;
                    const pidx = (py * canvas.width + px) * 4;
                    d[pidx] = obstacle[idx] * 100;
                    d[pidx + 1] = Math.min(255, v * 2);
                    d[pidx + 2] = Math.min(255, v);
                    d[pidx + 3] = 255;
                }
            }
            ctx.putImageData(img, 0, 0);
        }

        function animate() {
            for (let i = 0; i < 2; i++) step();
            render();
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>
