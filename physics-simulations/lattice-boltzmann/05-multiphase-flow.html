<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Multi-Phase Flow Simulation</title>
    <style>
        * { margin: 0; padding: 0; }
        body { background: #1a1a2e; color: #e0e0e0; font-family: sans-serif; overflow: hidden; }
        #canvas { display: block; }
        .info { position: fixed; top: 20px; left: 20px; background: rgba(26, 26, 46, 0.95); padding: 20px; border-radius: 10px; max-width: 300px; }
        h1 { font-size: 1.3em; color: #64ffda; margin-bottom: 10px; }
        p { font-size: 0.85em; color: #c0c0c0; line-height: 1.6; }
    </style>
</head>
<body>
    <div class="info">
        <h1>Multi-Phase Flow</h1>
        <p>Simulates two immiscible fluids (oil and water). Surface tension creates droplet formation and phase separation dynamics.</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const NX = 200, NY = 100, canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
        canvas.width = NX * 3; canvas.height = NY * 3;

        let phi = new Float32Array(NX * NY), phiNew = new Float32Array(NX * NY);
        let ux = new Float32Array(NX * NY), uy = new Float32Array(NX * NY);

        for (let y = 0; y < NY; y++) {
            for (let x = 0; x < NX; x++) {
                const idx = y * NX + x;
                if (y < NY / 2) {
                    phi[idx] = -1 + Math.random() * 0.1;
                } else {
                    phi[idx] = 1 + Math.random() * 0.1;
                }
                ux[idx] = (Math.random() - 0.5) * 0.01;
                uy[idx] = (Math.random() - 0.5) * 0.01;
            }
        }

        // Add droplets
        for (let i = 0; i < 5; i++) {
            const cx = Math.random() * NX, cy = Math.random() * NY, r = 10 + Math.random() * 10;
            for (let y = 0; y < NY; y++) {
                for (let x = 0; x < NX; x++) {
                    if (Math.hypot(x - cx, y - cy) < r) {
                        phi[y * NX + x] = y < NY / 2 ? 1 : -1;
                    }
                }
            }
        }

        function laplacian(arr, x, y) {
            const idx = y * NX + x;
            const l = y * NX + ((x - 1 + NX) % NX);
            const r = y * NX + ((x + 1) % NX);
            const u = ((y - 1 + NY) % NY) * NX + x;
            const d = ((y + 1) % NY) * NX + x;
            return arr[l] + arr[r] + arr[u] + arr[d] - 4 * arr[idx];
        }

        function step() {
            // Cahn-Hilliard equation
            const M = 0.1, kappa = 0.1, dt = 0.5;
            const mu = new Float32Array(NX * NY);

            for (let y = 1; y < NY - 1; y++) {
                for (let x = 1; x < NX - 1; x++) {
                    const idx = y * NX + x;
                    const p = phi[idx];
                    mu[idx] = p * p * p - p - kappa * laplacian(phi, x, y);
                }
            }

            for (let y = 1; y < NY - 1; y++) {
                for (let x = 1; x < NX - 1; x++) {
                    const idx = y * NX + x;
                    phiNew[idx] = phi[idx] + dt * M * laplacian(mu, x, y);
                    phiNew[idx] = Math.max(-1, Math.min(1, phiNew[idx]));
                }
            }

            [phi, phiNew] = [phiNew, phi];

            // Simple advection
            for (let y = 0; y < NY; y++) {
                for (let x = 0; x < NX; x++) {
                    const idx = y * NX + x;
                    ux[idx] += (Math.random() - 0.5) * 0.001;
                    uy[idx] += (Math.random() - 0.5) * 0.001 - 0.001;
                    ux[idx] *= 0.99; uy[idx] *= 0.99;
                }
            }
        }

        function render() {
            const img = ctx.createImageData(canvas.width, canvas.height), d = img.data;
            for (let py = 0; py < canvas.height; py++) {
                for (let px = 0; px < canvas.width; px++) {
                    const idx = Math.floor(py / 3) * NX + Math.floor(px / 3);
                    const v = (phi[idx] + 1) / 2;
                    const pidx = (py * canvas.width + px) * 4;
                    d[pidx] = v * 100 + (1 - v) * 200;
                    d[pidx + 1] = v * 150 + (1 - v) * 100;
                    d[pidx + 2] = v * 255 + (1 - v) * 50;
                    d[pidx + 3] = 255;
                }
            }
            ctx.putImageData(img, 0, 0);
        }

        function animate() {
            for (let i = 0; i < 3; i++) step();
            render();
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>
