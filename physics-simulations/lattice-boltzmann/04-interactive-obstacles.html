<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Obstacles in Flow</title>
    <style>
        * { margin: 0; padding: 0; }
        body { background: #1a1a2e; color: #e0e0e0; font-family: sans-serif; overflow: hidden; }
        #canvas { display: block; cursor: crosshair; }
        .info { position: fixed; top: 20px; left: 20px; background: rgba(26, 26, 46, 0.95); padding: 20px; border-radius: 10px; max-width: 300px; }
        h1 { font-size: 1.3em; color: #64ffda; margin-bottom: 10px; }
        p { font-size: 0.85em; color: #c0c0c0; line-height: 1.6; }
    </style>
</head>
<body>
    <div class="info">
        <h1>Interactive Obstacles</h1>
        <p><strong>Click and drag</strong> to draw obstacles in the flow. Watch the fluid dynamics adapt in real-time.</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const NX = 250, NY = 100, canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
        canvas.width = NX * 3; canvas.height = NY * 3;

        const ex = [0, 1, 0, -1, 0, 1, -1, -1, 1], ey = [0, 0, 1, 0, -1, 1, 1, -1, -1];
        const w = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36], omega = 1.7;

        let f = Array(9).fill(0).map(() => new Float32Array(NX * NY));
        let ux = new Float32Array(NX * NY), uy = new Float32Array(NX * NY), rho = new Float32Array(NX * NY);
        let obstacle = new Uint8Array(NX * NY);

        for (let i = 0; i < NX * NY; i++) {
            rho[i] = 1; ux[i] = 0.1; uy[i] = 0;
            for (let k = 0; k < 9; k++) {
                const cu = ex[k] * 0.1;
                f[k][i] = w[k] * (1 + 3 * cu + 4.5 * cu * cu - 0.015);
            }
        }

        let mouseDown = false;
        canvas.addEventListener('mousedown', () => { mouseDown = true; });
        canvas.addEventListener('mouseup', () => { mouseDown = false; });
        canvas.addEventListener('mousemove', (e) => {
            if (mouseDown) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / 3);
                const y = Math.floor((e.clientY - rect.top) / 3);
                for (let dy = -3; dy <= 3; dy++) {
                    for (let dx = -3; dx <= 3; dx++) {
                        const nx = x + dx, ny = y + dy;
                        if (nx >= 0 && nx < NX && ny >= 0 && ny < NY) {
                            obstacle[ny * NX + nx] = 1;
                        }
                    }
                }
            }
        });

        function step() {
            for (let i = 0; i < NX * NY; i++) {
                if (obstacle[i]) continue;
                const usq = ux[i] ** 2 + uy[i] ** 2;
                for (let k = 0; k < 9; k++) {
                    const cu = ex[k] * ux[i] + ey[k] * uy[i];
                    f[k][i] += omega * (w[k] * rho[i] * (1 + 3 * cu + 4.5 * cu * cu - 1.5 * usq) - f[k][i]);
                }
            }

            const fnew = Array(9).fill(0).map(() => new Float32Array(NX * NY));
            for (let y = 0; y < NY; y++) {
                for (let x = 0; x < NX; x++) {
                    const idx = y * NX + x;
                    for (let k = 0; k < 9; k++) {
                        let nx = x + ex[k], ny = y + ey[k];
                        if (nx < 0 || nx >= NX || ny < 0 || ny >= NY) continue;
                        const nidx = ny * NX + nx;
                        if (obstacle[nidx]) {
                            fnew[[0, 3, 4, 1, 2, 7, 8, 5, 6][k]][idx] = f[k][idx];
                        } else {
                            fnew[k][nidx] = f[k][idx];
                        }
                    }
                }
            }
            f = fnew;

            for (let i = 0; i < NX * NY; i++) {
                if (obstacle[i]) continue;
                rho[i] = 0; ux[i] = 0; uy[i] = 0;
                for (let k = 0; k < 9; k++) {
                    rho[i] += f[k][i]; ux[i] += ex[k] * f[k][i]; uy[i] += ey[k] * f[k][i];
                }
                ux[i] /= rho[i]; uy[i] /= rho[i];
            }

            for (let y = 0; y < NY; y++) {
                ux[y * NX] = 0.1; uy[y * NX] = 0;
            }
        }

        function render() {
            const img = ctx.createImageData(canvas.width, canvas.height), d = img.data;
            for (let py = 0; py < canvas.height; py++) {
                for (let px = 0; px < canvas.width; px++) {
                    const idx = Math.floor(py / 3) * NX + Math.floor(px / 3), pidx = (py * canvas.width + px) * 4;
                    if (obstacle[idx]) {
                        d[pidx] = 150; d[pidx + 1] = 150; d[pidx + 2] = 150;
                    } else {
                        const s = Math.sqrt(ux[idx] ** 2 + uy[idx] ** 2) * 800;
                        d[pidx] = s * 0.5; d[pidx + 1] = s; d[pidx + 2] = s * 1.5;
                    }
                    d[pidx + 3] = 255;
                }
            }
            ctx.putImageData(img, 0, 0);
        }

        function animate() {
            for (let i = 0; i < 2; i++) step();
            render();
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>
