<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Hole Gravitational Lensing - CCAB</title>
    <meta name="description" content="Visualize gravitational lensing around a Schwarzschild black hole. Watch light bend around the event horizon, revealing the photon sphere and Einstein ring.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.6);
            color: #ff7b00;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 123, 0, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(255, 123, 0, 0.2);
            transform: translateX(-4px);
        }

        #info {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            border-radius: 12px;
            color: #ff7b00;
            font-size: 13px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 123, 0, 0.2);
            z-index: 1000;
            max-width: 280px;
        }

        #info h3 {
            margin-bottom: 10px;
            color: #fff;
        }

        #info p {
            font-size: 11px;
            opacity: 0.8;
            line-height: 1.5;
            margin-top: 10px;
            color: #ddd;
        }

        #info .physics {
            font-size: 10px;
            color: #aaa;
            margin-top: 8px;
        }

        #presets {
            position: fixed;
            top: 220px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }

        button {
            background: rgba(255, 123, 0, 0.15);
            border: 1px solid rgba(255, 123, 0, 0.4);
            color: #ff7b00;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(255, 123, 0, 0.3);
        }

        button.active {
            background: rgba(255, 123, 0, 0.4);
            border-color: #ff7b00;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 16px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 123, 0, 0.2);
        }

        .control-group label {
            color: #ff7b00;
            font-size: 11px;
            display: block;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 100px;
            accent-color: #ff7b00;
        }

        .control-group span {
            color: #fff;
            font-size: 10px;
            margin-left: 6px;
        }

        #fps-display {
            position: fixed;
            bottom: 80px;
            right: 15px;
            background: rgba(0, 0, 0, 0.6);
            color: #ff7b00;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff7b00;
            font-size: 18px;
            z-index: 2000;
        }

        #error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-size: 16px;
            z-index: 2000;
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 12px;
            display: none;
        }

        #instructions {
            position: fixed;
            bottom: 80px;
            left: 15px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            color: #ddd;
            font-size: 11px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">← Back to Gallery</a>

    <div id="info">
        <h3>Black Hole Lensing</h3>
        <div>Background: <span id="bg-name">Star Field</span></div>
        <p>Gravitational lensing around a Schwarzschild black hole. Light bends near massive objects, creating an Einstein ring and revealing objects behind the black hole.</p>
        <div class="physics">
            Event Horizon: r = 2GM/c²<br>
            Photon Sphere: r = 1.5 × Rs
        </div>
    </div>

    <div id="presets">
        <button class="active" data-preset="stars">Star Field</button>
        <button data-preset="grid">Grid Pattern</button>
        <button data-preset="galaxy">Galaxy</button>
        <button data-preset="accretion">Accretion Disk</button>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>Black Hole Size: <span id="size-val">1.0</span></label>
            <input type="range" id="bh-size" min="0.3" max="2" value="1" step="0.1">
        </div>
        <div class="control-group">
            <label>Lensing Strength: <span id="lens-val">1.0</span></label>
            <input type="range" id="lens-strength" min="0.5" max="2" value="1" step="0.1">
        </div>
        <div class="control-group">
            <label>Distance: <span id="dist-val">3.0</span></label>
            <input type="range" id="distance" min="2" max="6" value="3" step="0.1">
        </div>
    </div>

    <div id="fps-display">FPS: <span id="fps">0</span></div>

    <div id="instructions">
        Move mouse to shift view angle
    </div>

    <div id="loading">Initializing black hole...</div>
    <div id="error"></div>

    <canvas id="canvas"></canvas>

    <script>
        // Black Hole Gravitational Lensing
        // Based on Schwarzschild metric ray tracing

        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');
        const loadingEl = document.getElementById('loading');
        const errorEl = document.getElementById('error');

        if (!gl) {
            loadingEl.style.display = 'none';
            errorEl.style.display = 'block';
            errorEl.textContent = 'WebGL2 is not supported';
            throw new Error('WebGL2 not supported');
        }

        // Parameters
        let params = {
            bhSize: 1.0,
            lensStrength: 1.0,
            distance: 3.0,
            time: 0,
            mouseX: 0,
            mouseY: 0
        };

        let currentPreset = 'stars';

        // Resize
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resize();
        window.addEventListener('resize', resize);

        // Vertex shader
        const vertexShader = `#version 300 es
            in vec2 position;
            out vec2 vUv;
            void main() {
                vUv = position * 0.5 + 0.5;
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        // Fragment shader - gravitational lensing
        const fragmentShader = `#version 300 es
            precision highp float;

            uniform vec2 uResolution;
            uniform float uBHSize;
            uniform float uLensStrength;
            uniform float uDistance;
            uniform float uTime;
            uniform vec2 uMouse;
            uniform int uPreset;

            in vec2 vUv;
            out vec4 fragColor;

            #define PI 3.14159265359
            #define SCHWARZSCHILD_RADIUS 1.0
            #define PHOTON_SPHERE 1.5

            // Pseudo-random function
            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                return mix(
                    mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                    mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x),
                    f.y
                );
            }

            // Star field background
            vec3 starField(vec2 uv) {
                vec3 col = vec3(0.0);

                // Multiple star layers
                for (float i = 0.0; i < 3.0; i++) {
                    vec2 p = uv * (100.0 + i * 50.0);
                    float star = hash(floor(p));
                    if (star > 0.98) {
                        float brightness = pow(star - 0.98, 2.0) * 50.0;
                        brightness *= smoothstep(0.5, 0.0, length(fract(p) - 0.5));
                        vec3 starColor = vec3(1.0);
                        if (hash(floor(p) + 0.5) > 0.5) {
                            starColor = vec3(1.0, 0.9, 0.7);  // Warm star
                        } else {
                            starColor = vec3(0.7, 0.8, 1.0);  // Cool star
                        }
                        col += starColor * brightness;
                    }
                }

                // Subtle nebula
                float neb = noise(uv * 3.0 + uTime * 0.01) * 0.3;
                col += vec3(0.1, 0.05, 0.15) * neb;

                return col;
            }

            // Grid background
            vec3 gridPattern(vec2 uv) {
                vec2 grid = abs(fract(uv * 10.0) - 0.5);
                float line = min(grid.x, grid.y);
                float gridLine = smoothstep(0.02, 0.03, line);
                vec3 col = mix(vec3(0.0, 0.4, 0.8), vec3(0.0, 0.05, 0.1), gridLine);
                return col;
            }

            // Galaxy background
            vec3 galaxyBg(vec2 uv) {
                vec2 center = uv - vec2(0.3, 0.2);
                float r = length(center);
                float angle = atan(center.y, center.x);

                // Spiral arms
                float spiral = sin(angle * 2.0 - r * 10.0 + uTime * 0.1);
                spiral = smoothstep(0.0, 1.0, spiral);

                float glow = exp(-r * 3.0);
                vec3 col = vec3(0.8, 0.6, 0.4) * glow * 0.5;
                col += vec3(0.3, 0.2, 0.5) * spiral * exp(-r * 2.0) * 0.3;

                // Add stars
                col += starField(uv) * 0.5;

                return col;
            }

            // Accretion disk
            vec3 accretionDisk(vec2 uv, float bhRadius) {
                vec3 col = vec3(0.0);

                // Disk parameters
                float innerRadius = bhRadius * 3.0;
                float outerRadius = bhRadius * 8.0;
                float r = length(uv);

                if (r > innerRadius && r < outerRadius) {
                    // Disk brightness falloff
                    float diskBrightness = 1.0 - (r - innerRadius) / (outerRadius - innerRadius);
                    diskBrightness = pow(diskBrightness, 0.5);

                    // Rotation effect
                    float angle = atan(uv.y, uv.x);
                    float rotation = angle + uTime * 0.5 / r;  // Keplerian-ish
                    float spiral = sin(rotation * 8.0 + r * 10.0) * 0.5 + 0.5;

                    // Hot inner edge
                    float heat = exp(-(r - innerRadius) * 2.0);

                    // Color gradient: hot (white/blue) -> cold (red/orange)
                    vec3 hotColor = vec3(1.0, 0.9, 0.8);
                    vec3 warmColor = vec3(1.0, 0.5, 0.1);
                    vec3 coolColor = vec3(0.8, 0.2, 0.0);

                    vec3 diskColor = mix(coolColor, warmColor, diskBrightness);
                    diskColor = mix(diskColor, hotColor, heat);

                    // Add turbulence
                    float turb = noise(uv * 20.0 + uTime * 0.3) * 0.3 + 0.7;

                    col = diskColor * diskBrightness * spiral * turb;
                }

                // Add background stars
                col += starField(uv) * 0.3 * smoothstep(innerRadius, outerRadius, r);

                return col;
            }

            // Get background color based on preset
            vec3 getBackground(vec2 uv, float bhRadius) {
                if (uPreset == 0) return starField(uv);
                if (uPreset == 1) return gridPattern(uv);
                if (uPreset == 2) return galaxyBg(uv);
                if (uPreset == 3) return accretionDisk(uv, bhRadius);
                return starField(uv);
            }

            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * uResolution) / min(uResolution.x, uResolution.y);

                // Apply mouse offset for view angle
                uv += uMouse * 0.3;

                // Black hole parameters
                float bhRadius = uBHSize * SCHWARZSCHILD_RADIUS * 0.15;
                float photonSphere = bhRadius * PHOTON_SPHERE;

                // Distance from black hole center
                float r = length(uv);

                // Gravitational lensing calculation
                // Light bending angle depends on impact parameter
                vec2 dir = normalize(uv);
                float bendAngle = 0.0;

                if (r > bhRadius) {
                    // Deflection angle approximation: alpha ≈ 4GM/(c²b) = 2Rs/b
                    // For visualization, we use a simplified model
                    float impactParam = r;
                    bendAngle = (2.0 * bhRadius * uLensStrength) / impactParam;

                    // Stronger bending near photon sphere
                    if (r < photonSphere * 2.0) {
                        float factor = 1.0 + 2.0 * exp(-(r - photonSphere) / bhRadius);
                        bendAngle *= factor;
                    }
                }

                // Apply lensing distortion
                vec2 lensedUv = uv;
                if (r > bhRadius * 1.01) {
                    // Radial distortion - light bends toward black hole
                    float distortionStrength = bendAngle / (r + 0.01);
                    lensedUv = uv + dir * distortionStrength * uDistance;

                    // Einstein ring effect - light wrapping around
                    if (r < photonSphere * 1.5) {
                        float ringFactor = smoothstep(bhRadius, photonSphere * 1.5, r);
                        lensedUv = mix(
                            uv * (1.0 + bendAngle * 2.0),
                            lensedUv,
                            ringFactor
                        );
                    }
                }

                // Get background with lensed coordinates
                vec3 col = getBackground(lensedUv, bhRadius);

                // Event horizon - complete darkness
                if (r < bhRadius) {
                    col = vec3(0.0);
                }

                // Photon sphere glow
                float photonGlow = exp(-abs(r - photonSphere) * 10.0 / bhRadius) * 0.3;
                col += vec3(1.0, 0.6, 0.2) * photonGlow;

                // Edge darkening near event horizon
                if (r < bhRadius * 1.5 && r > bhRadius) {
                    float darken = smoothstep(bhRadius, bhRadius * 1.5, r);
                    col *= darken;
                }

                // Vignette
                float vignette = 1.0 - length(vUv - 0.5) * 0.5;
                col *= vignette;

                fragColor = vec4(col, 1.0);
            }
        `;

        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        // Create program
        const vert = compileShader(vertexShader, gl.VERTEX_SHADER);
        const frag = compileShader(fragmentShader, gl.FRAGMENT_SHADER);
        const program = gl.createProgram();
        gl.attachShader(program, vert);
        gl.attachShader(program, frag);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program error:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // Geometry
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1
        ]), gl.STATIC_DRAW);

        const posLoc = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        // Uniforms
        const uniforms = {
            resolution: gl.getUniformLocation(program, 'uResolution'),
            bhSize: gl.getUniformLocation(program, 'uBHSize'),
            lensStrength: gl.getUniformLocation(program, 'uLensStrength'),
            distance: gl.getUniformLocation(program, 'uDistance'),
            time: gl.getUniformLocation(program, 'uTime'),
            mouse: gl.getUniformLocation(program, 'uMouse'),
            preset: gl.getUniformLocation(program, 'uPreset')
        };

        // Preset mapping
        const presetMap = { stars: 0, grid: 1, galaxy: 2, accretion: 3 };

        // FPS counter
        let frameCount = 0;
        let lastFpsTime = performance.now();

        function updateFPS() {
            frameCount++;
            const now = performance.now();
            if (now - lastFpsTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFpsTime = now;
            }
        }

        // Render
        function render() {
            params.time += 0.016;

            gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
            gl.uniform1f(uniforms.bhSize, params.bhSize);
            gl.uniform1f(uniforms.lensStrength, params.lensStrength);
            gl.uniform1f(uniforms.distance, params.distance);
            gl.uniform1f(uniforms.time, params.time);
            gl.uniform2f(uniforms.mouse, params.mouseX, params.mouseY);
            gl.uniform1i(uniforms.preset, presetMap[currentPreset]);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            updateFPS();
            requestAnimationFrame(render);
        }

        // Event listeners
        document.querySelectorAll('#presets button').forEach(btn => {
            btn.addEventListener('click', () => {
                currentPreset = btn.dataset.preset;
                document.getElementById('bg-name').textContent = btn.textContent;
                document.querySelectorAll('#presets button').forEach(b =>
                    b.classList.toggle('active', b === btn)
                );
            });
        });

        document.getElementById('bh-size').addEventListener('input', e => {
            params.bhSize = parseFloat(e.target.value);
            document.getElementById('size-val').textContent = params.bhSize.toFixed(1);
        });

        document.getElementById('lens-strength').addEventListener('input', e => {
            params.lensStrength = parseFloat(e.target.value);
            document.getElementById('lens-val').textContent = params.lensStrength.toFixed(1);
        });

        document.getElementById('distance').addEventListener('input', e => {
            params.distance = parseFloat(e.target.value);
            document.getElementById('dist-val').textContent = params.distance.toFixed(1);
        });

        // Mouse interaction
        canvas.addEventListener('mousemove', e => {
            params.mouseX = (e.clientX / canvas.width - 0.5) * 2;
            params.mouseY = -(e.clientY / canvas.height - 0.5) * 2;
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const touch = e.touches[0];
            params.mouseX = (touch.clientX / canvas.width - 0.5) * 2;
            params.mouseY = -(touch.clientY / canvas.height - 0.5) * 2;
        });

        // Expose for enhance.js keyboard shortcuts
        window.reset = function() { render(); };
        window.init = window.reset;

        // Start
        loadingEl.style.display = 'none';
        render();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
