<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nash Equilibrium Visualizer</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; }
#title { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); color: #fbbf24; font-size: 20px; font-weight: 700; z-index: 999; text-shadow: 0 0 20px rgba(251,191,36,0.5); font-family: sans-serif; }
#controls { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; z-index: 999; background: rgba(0,0,0,0.75); padding: 12px 16px; border-radius: 10px; flex-wrap: wrap; justify-content: center; align-items: center; }
#controls button { background: rgba(251,191,36,0.15); color: #fbbf24; border: 1px solid rgba(251,191,36,0.4); padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 11px; transition: all 0.2s; }
#controls button:hover { background: rgba(251,191,36,0.3); }
#controls button.active { background: rgba(251,191,36,0.5); border-color: #fbbf24; }
#controls label { color: #ccc; font-size: 11px; display: flex; flex-direction: column; align-items: center; gap: 2px; }
#controls input[type=range] { width: 80px; accent-color: #fbbf24; }
#controls span { color: #fbbf24; font-size: 10px; }
#info { position: fixed; top: 50px; right: 15px; color: #ccc; font-size: 12px; z-index: 999; background: rgba(0,0,0,0.7); padding: 12px; border-radius: 8px; line-height: 1.8; max-width: 230px; }
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">‚Üê Back to Gallery</a>
<div id="title">Nash Equilibrium Visualizer</div>
<div id="info">
    <div style="color:#fbbf24;font-weight:bold;" id="gameName">Prisoner's Dilemma</div>
    <div id="gameDesc" style="font-size:10px;color:#888;margin:4px 0;"></div>
    <div>Nash Equilibria: <span style="color:#4ade80;" id="nashEq">--</span></div>
    <div style="margin-top:8px;font-size:10px;font-weight:bold;color:#60a5fa;">Population Evolution</div>
    <div>Cooperators: <span style="color:#4ade80;" id="coopPct">50%</span></div>
    <div>Defectors: <span style="color:#ef4444;" id="defPct">50%</span></div>
    <div>Generation: <span style="color:#fbbf24;" id="genCount">0</span></div>
</div>
<canvas id="canvas"></canvas>
<div id="controls">
    <button id="btnPD" class="active">Prisoner's Dilemma</button>
    <button id="btnChicken">Chicken</button>
    <button id="btnBOS">Battle of Sexes</button>
    <button id="btnSH">Stag Hunt</button>
    <button id="btnCustom">Custom</button>
    <label>Pop Size <input type="range" id="popSize" min="20" max="200" step="10" value="100"><span id="popVal">100</span></label>
    <label>Speed <input type="range" id="speed" min="1" max="20" step="1" value="5"><span id="speedVal">5</span></label>
    <button id="btnResetEvo">Reset Evolution</button>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

const popSlider = document.getElementById('popSize');
const speedSlider = document.getElementById('speed');
popSlider.oninput = () => { document.getElementById('popVal').textContent = popSlider.value; resetEvolution(); };
speedSlider.oninput = () => document.getElementById('speedVal').textContent = speedSlider.value;

// Game definitions: [row player payoff, col player payoff]
const games = {
    pd: {
        name: "Prisoner's Dilemma",
        desc: "Both players benefit from cooperation, but defection is individually rational. The Nash Equilibrium (Defect, Defect) is Pareto-inferior to (Cooperate, Cooperate).",
        rows: ['Cooperate', 'Defect'],
        cols: ['Cooperate', 'Defect'],
        payoffs: [
            [[-1, -1], [-3, 0]],
            [[0, -3], [-2, -2]]
        ],
        nash: [[1, 1]]
    },
    chicken: {
        name: "Chicken (Hawk-Dove)",
        desc: "Two drivers heading toward each other. Swerving is 'chicken'. Two Nash Equilibria exist where one swerves and the other doesn't.",
        rows: ['Swerve', 'Straight'],
        cols: ['Swerve', 'Straight'],
        payoffs: [
            [[0, 0], [-1, 1]],
            [[1, -1], [-5, -5]]
        ],
        nash: [[0, 1], [1, 0]]
    },
    bos: {
        name: "Battle of the Sexes",
        desc: "Two players want to coordinate but prefer different outcomes. Two pure-strategy Nash Equilibria exist.",
        rows: ['Opera', 'Football'],
        cols: ['Opera', 'Football'],
        payoffs: [
            [[3, 2], [0, 0]],
            [[0, 0], [2, 3]]
        ],
        nash: [[0, 0], [1, 1]]
    },
    sh: {
        name: "Stag Hunt",
        desc: "Cooperation yields the best outcome, but it's risky. Hunting hare is safe but worse. Two Nash Equilibria: both cooperate or both defect.",
        rows: ['Stag', 'Hare'],
        cols: ['Stag', 'Hare'],
        payoffs: [
            [[4, 4], [0, 3]],
            [[3, 0], [2, 2]]
        ],
        nash: [[0, 0], [1, 1]]
    },
    custom: {
        name: "Custom Game",
        desc: "Edit payoffs by concept. Uses random payoffs.",
        rows: ['Strategy A', 'Strategy B'],
        cols: ['Strategy A', 'Strategy B'],
        payoffs: [
            [[3, 3], [0, 5]],
            [[5, 0], [1, 1]]
        ],
        nash: []
    }
};

let currentGame = 'pd';
let game = games.pd;

// Evolution state
let population = [];
let coopHistory = [];
let generation = 0;
const maxHistoryLen = 300;

function setGame(key) {
    currentGame = key;
    game = games[key];

    if (key === 'custom') {
        // Random payoffs
        for (let r = 0; r < 2; r++) {
            for (let c = 0; c < 2; c++) {
                game.payoffs[r][c] = [
                    Math.floor(Math.random() * 10) - 2,
                    Math.floor(Math.random() * 10) - 2
                ];
            }
        }
        game.nash = findNashEquilibria();
    }

    document.getElementById('gameName').textContent = game.name;
    document.getElementById('gameDesc').textContent = game.desc;

    document.querySelectorAll('#controls button').forEach(b => b.classList.remove('active'));
    const btnMap = { pd: 'btnPD', chicken: 'btnChicken', bos: 'btnBOS', sh: 'btnSH', custom: 'btnCustom' };
    document.getElementById(btnMap[key]).classList.add('active');

    resetEvolution();
}

function findNashEquilibria() {
    const ne = [];
    for (let r = 0; r < 2; r++) {
        for (let c = 0; c < 2; c++) {
            const otherR = 1 - r;
            const otherC = 1 - c;
            // Row player: given col=c, is r the best response?
            const rowBR = game.payoffs[r][c][0] >= game.payoffs[otherR][c][0];
            // Col player: given row=r, is c the best response?
            const colBR = game.payoffs[r][c][1] >= game.payoffs[r][otherC][1];
            if (rowBR && colBR) ne.push([r, c]);
        }
    }
    return ne;
}

function resetEvolution() {
    const n = parseInt(popSlider.value);
    population = [];
    for (let i = 0; i < n; i++) {
        population.push({
            strategy: Math.random() < 0.5 ? 0 : 1, // 0 = row strategy 0, 1 = row strategy 1
            fitness: 0,
            x: 0, y: 0
        });
    }
    coopHistory = [];
    generation = 0;
}

function evolveStep() {
    const n = population.length;

    // Calculate fitness through random pairings
    population.forEach(p => p.fitness = 0);
    for (let i = 0; i < n; i++) {
        const j = Math.floor(Math.random() * n);
        if (i === j) continue;
        const si = population[i].strategy;
        const sj = population[j].strategy;
        population[i].fitness += game.payoffs[si][sj][0];
        population[j].fitness += game.payoffs[si][sj][1];
    }

    // Replicator dynamics - select next generation proportional to fitness
    const minFit = Math.min(...population.map(p => p.fitness));
    const adjusted = population.map(p => p.fitness - minFit + 1);
    const totalFit = adjusted.reduce((a, b) => a + b, 0);

    const newPop = [];
    for (let i = 0; i < n; i++) {
        // Tournament selection
        const a = Math.floor(Math.random() * n);
        const b = Math.floor(Math.random() * n);
        const winner = adjusted[a] >= adjusted[b] ? a : b;

        let strategy = population[winner].strategy;
        // Mutation
        if (Math.random() < 0.02) strategy = 1 - strategy;

        newPop.push({ strategy, fitness: 0, x: 0, y: 0 });
    }

    population = newPop;
    generation++;

    // Record history
    const coopCount = population.filter(p => p.strategy === 0).length;
    coopHistory.push(coopCount / n);
    if (coopHistory.length > maxHistoryLen) coopHistory.shift();
}

document.getElementById('btnPD').onclick = () => setGame('pd');
document.getElementById('btnChicken').onclick = () => setGame('chicken');
document.getElementById('btnBOS').onclick = () => setGame('bos');
document.getElementById('btnSH').onclick = () => setGame('sh');
document.getElementById('btnCustom').onclick = () => setGame('custom');
document.getElementById('btnResetEvo').onclick = resetEvolution;

let frameCount = 0;

function draw() {
    frameCount++;
    const speed = parseInt(speedSlider.value);
    for (let i = 0; i < speed; i++) evolveStep();

    const W = canvas.width, H = canvas.height;
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    // Layout
    const matrixX = W * 0.06;
    const matrixY = H * 0.10;
    const matrixW = Math.min(W * 0.40, 350);
    const matrixH = Math.min(H * 0.38, 280);

    const popAreaX = W * 0.52;
    const popAreaY = H * 0.08;
    const popAreaW = W * 0.43;
    const popAreaH = H * 0.38;

    const chartX = W * 0.06;
    const chartY = H * 0.55;
    const chartW = W * 0.88;
    const chartH = H * 0.28;

    // Draw payoff matrix
    drawPayoffMatrix(matrixX, matrixY, matrixW, matrixH);

    // Draw population
    drawPopulation(popAreaX, popAreaY, popAreaW, popAreaH);

    // Draw evolution chart
    drawEvolutionChart(chartX, chartY, chartW, chartH);

    // Update info
    const nashStrs = game.nash.map(ne => '(' + game.rows[ne[0]] + ', ' + game.cols[ne[1]] + ')').join(', ');
    document.getElementById('nashEq').textContent = nashStrs || 'None (pure)';

    const coopCount = population.filter(p => p.strategy === 0).length;
    document.getElementById('coopPct').textContent = (coopCount / population.length * 100).toFixed(1) + '%';
    document.getElementById('defPct').textContent = ((population.length - coopCount) / population.length * 100).toFixed(1) + '%';
    document.getElementById('genCount').textContent = generation;

    requestAnimationFrame(draw);
}

function drawPayoffMatrix(mx, my, mw, mh) {
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Payoff Matrix', mx + mw / 2, my - 8);

    const cellW = mw / 3;
    const cellH = mh / 3;
    const startX = mx + cellW;
    const startY = my + cellH;

    // Column headers
    ctx.fillStyle = 'rgba(96,165,250,0.8)';
    ctx.font = 'bold 11px sans-serif';
    ctx.fillText('Player 2', mx + mw / 2 + cellW / 2, my + 15);
    for (let c = 0; c < 2; c++) {
        ctx.fillText(game.cols[c], startX + c * cellW + cellW / 2, my + cellH - 5);
    }

    // Row headers
    ctx.fillStyle = 'rgba(74,222,128,0.8)';
    ctx.save();
    ctx.translate(mx + 15, my + mh / 2 + cellH / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Player 1', 0, 0);
    ctx.restore();

    for (let r = 0; r < 2; r++) {
        ctx.textAlign = 'right';
        ctx.fillText(game.rows[r], startX - 8, startY + r * cellH + cellH / 2 + 4);
    }

    // Draw cells
    for (let r = 0; r < 2; r++) {
        for (let c = 0; c < 2; c++) {
            const cx = startX + c * cellW;
            const cy = startY + r * cellH;

            // Check if Nash equilibrium
            const isNash = game.nash.some(ne => ne[0] === r && ne[1] === c);

            // Cell background
            ctx.fillStyle = isNash ? 'rgba(251,191,36,0.15)' : 'rgba(255,255,255,0.03)';
            ctx.fillRect(cx + 2, cy + 2, cellW - 4, cellH - 4);

            // Border
            ctx.strokeStyle = isNash ? '#fbbf24' : 'rgba(255,255,255,0.15)';
            ctx.lineWidth = isNash ? 2 : 1;
            ctx.strokeRect(cx + 2, cy + 2, cellW - 4, cellH - 4);

            // Nash star
            if (isNash) {
                ctx.fillStyle = '#fbbf24';
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText('*', cx + cellW - 6, cy + 16);
            }

            // Payoffs
            const p = game.payoffs[r][c];
            ctx.textAlign = 'center';

            // Row player payoff (green, top-left)
            ctx.fillStyle = '#4ade80';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText(p[0], cx + cellW * 0.35, cy + cellH * 0.45);

            // Separator
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillText(',', cx + cellW / 2, cy + cellH * 0.45);

            // Col player payoff (blue, top-right)
            ctx.fillStyle = '#60a5fa';
            ctx.fillText(p[1], cx + cellW * 0.65, cy + cellH * 0.45);

            // Labels
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.font = '8px sans-serif';
            ctx.fillText('P1    P2', cx + cellW / 2, cy + cellH * 0.72);

            if (isNash) {
                ctx.fillStyle = 'rgba(251,191,36,0.6)';
                ctx.font = 'bold 8px sans-serif';
                ctx.fillText('NASH', cx + cellW / 2, cy + cellH * 0.9);
            }
        }
    }

    // Best response indicators
    ctx.font = '9px sans-serif';
    // For each column, mark row player's best response
    for (let c = 0; c < 2; c++) {
        const bestR = game.payoffs[0][c][0] >= game.payoffs[1][c][0] ? 0 : 1;
        const cx = startX + c * cellW + cellW * 0.35;
        const cy = startY + bestR * cellH + cellH * 0.25;
        ctx.fillStyle = 'rgba(74,222,128,0.4)';
        ctx.beginPath();
        ctx.arc(cx, cy - 3, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    // For each row, mark col player's best response
    for (let r = 0; r < 2; r++) {
        const bestC = game.payoffs[r][0][1] >= game.payoffs[r][1][1] ? 0 : 1;
        const cx = startX + bestC * cellW + cellW * 0.65;
        const cy = startY + r * cellH + cellH * 0.25;
        ctx.fillStyle = 'rgba(96,165,250,0.4)';
        ctx.beginPath();
        ctx.arc(cx, cy - 3, 3, 0, Math.PI * 2);
        ctx.fill();
    }
}

function drawPopulation(px, py, pw, ph) {
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Population (' + population.length + ' agents)', px + pw / 2, py - 8);

    const cols = Math.ceil(Math.sqrt(population.length * pw / ph));
    const rows = Math.ceil(population.length / cols);
    const dotSize = Math.min(pw / cols, ph / rows) * 0.4;

    population.forEach((p, i) => {
        const col = i % cols;
        const row = Math.floor(i / cols);
        const x = px + (col + 0.5) * (pw / cols);
        const y = py + (row + 0.5) * (ph / rows);
        p.x = x;
        p.y = y;

        const color = p.strategy === 0 ? '#4ade80' : '#ef4444';
        const alpha = 0.5 + Math.sin(frameCount * 0.05 + i * 0.3) * 0.2;

        ctx.beginPath();
        ctx.arc(x, y, dotSize, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.globalAlpha = alpha;
        ctx.fill();
        ctx.globalAlpha = 1;
    });

    // Legend
    ctx.fillStyle = '#4ade80';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    ctx.beginPath();
    ctx.arc(px + 5, py + ph + 12, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillText(game.rows[0], px + 14, py + ph + 15);

    ctx.fillStyle = '#ef4444';
    ctx.beginPath();
    ctx.arc(px + pw / 2 + 5, py + ph + 12, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillText(game.rows[1], px + pw / 2 + 14, py + ph + 15);
}

function drawEvolutionChart(cx, cy, cw, ch) {
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Strategy Evolution Over Time', cx, cy - 8);

    // Background
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fillRect(cx, cy, cw, ch);

    // Grid
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 4; i++) {
        const y = cy + (ch / 4) * i;
        ctx.beginPath(); ctx.moveTo(cx, y); ctx.lineTo(cx + cw, y); ctx.stroke();
    }

    // Y axis labels
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.font = '9px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('100%', cx - 5, cy + 4);
    ctx.fillText('50%', cx - 5, cy + ch / 2 + 4);
    ctx.fillText('0%', cx - 5, cy + ch + 4);

    if (coopHistory.length < 2) return;

    // Filled area for strategy 0 (cooperation)
    ctx.beginPath();
    ctx.moveTo(cx, cy + ch);
    coopHistory.forEach((v, i) => {
        const x = cx + (i / (coopHistory.length - 1)) * cw;
        const y = cy + ch - v * ch;
        ctx.lineTo(x, y);
    });
    ctx.lineTo(cx + cw, cy + ch);
    ctx.closePath();
    ctx.fillStyle = 'rgba(74,222,128,0.2)';
    ctx.fill();

    // Fill top area for strategy 1 (defection)
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    coopHistory.forEach((v, i) => {
        const x = cx + (i / (coopHistory.length - 1)) * cw;
        const y = cy + ch - v * ch;
        ctx.lineTo(x, y);
    });
    ctx.lineTo(cx + cw, cy);
    ctx.closePath();
    ctx.fillStyle = 'rgba(239,68,68,0.15)';
    ctx.fill();

    // Line
    ctx.beginPath();
    ctx.strokeStyle = '#4ade80';
    ctx.lineWidth = 2;
    coopHistory.forEach((v, i) => {
        const x = cx + (i / (coopHistory.length - 1)) * cw;
        const y = cy + ch - v * ch;
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();

    // Current percentage
    const latest = coopHistory[coopHistory.length - 1];
    const dotX = cx + cw;
    const dotY = cy + ch - latest * ch;

    ctx.beginPath();
    ctx.arc(dotX, dotY, 4, 0, Math.PI * 2);
    ctx.fillStyle = '#4ade80';
    ctx.fill();

    ctx.fillStyle = '#4ade80';
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(game.rows[0] + ': ' + (latest * 100).toFixed(1) + '%', cx + cw - 10, cy + 15);

    ctx.fillStyle = '#ef4444';
    ctx.fillText(game.rows[1] + ': ' + ((1 - latest) * 100).toFixed(1) + '%', cx + cw - 10, cy + 30);

    // Axis label
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Generation', cx + cw / 2, cy + ch + 18);
}

setGame('pd');
requestAnimationFrame(draw);
</script>
</body>
</html>
