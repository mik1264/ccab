<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diffusion-Limited Aggregation - CCAB</title>
    <link rel="stylesheet" href="../assets/css/navigation.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Spectral:ital,wght@0,400;0,600;1,400&family=Space+Mono:wght@400;700&display=swap');

        :root {
            /* Color scheme matching main index */
            --bg-primary: #0a0e1a;
            --bg-secondary: #111827;
            --text-primary: #e0e0ff;
            --text-secondary: #a0a0c0;
            --text-accent: #fbbf24;
            --theme-color: #667eea;

            /* Spacing */
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;
            --spacing-2xl: 4rem;

            /* Typography */
            --font-display: 'Orbitron', sans-serif;
            --font-heading: 'Spectral', serif;
            --font-mono: 'Space Mono', monospace;
            --font-body: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

            /* Layout */
            --max-width: 1600px;
            --header-height: 64px;

            /* Transitions */
            --transition-base: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: linear-gradient(135deg, var(--bg-primary) 0%, #0f172a 50%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            padding: 20px;
            padding-top: calc(var(--header-height) + 20px);
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            font-family: var(--font-display);
            text-align: center;
            margin-bottom: 10px;
            font-size: clamp(2rem, 5vw, 3rem);
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 50%, var(--theme-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            padding: 12px 24px;
            background: rgba(224, 224, 255, 0.1);
            border: 2px solid rgba(224, 224, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
            color: var(--text-primary);
        }

        .tab:hover {
            background: rgba(224, 224, 255, 0.2);
            transform: translateY(-2px);
        }

        .tab.active {
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border-color: var(--theme-color);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .view {
            display: none;
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .view.active {
            display: block;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        input[type="range"] {
            width: 200px;
        }

        input[type="number"] {
            width: 80px;
            padding: 8px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 1em;
        }

        select {
            padding: 8px;
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 1em;
            cursor: pointer;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--theme-color) 0%, var(--text-accent) 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        canvas {
            display: block;
            margin: 20px auto;
            background: #000;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 100%;
        }

        .stats-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: var(--theme-color);
        }

        .stat-label {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid var(--theme-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .info-box h3 {
            margin-bottom: 10px;
            color: var(--theme-color);
        }

        .info-box ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        .color-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .color-option {
            padding: 8px 16px;
            background: rgba(224, 224, 255, 0.1);
            border: 2px solid rgba(224, 224, 255, 0.2);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .color-option:hover {
            background: rgba(224, 224, 255, 0.2);
        }

        .color-option.active {
            border-color: var(--theme-color);
            background: rgba(102, 126, 234, 0.2);
        }

        .chart-container {
            margin: 20px auto;
            max-width: 800px;
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.8);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }

            .tabs {
                font-size: 0.9em;
            }

            .tab {
                padding: 8px 16px;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            input[type="range"] {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation Header -->
    <nav class="ccab-nav">
        <div class="nav-container">
            <a href="../index.html" class="nav-home">
                <span class="nav-logo">CCAB</span>
                <span class="nav-tagline">Claude Code and Algorithmic Beauty</span>
            </a>
            <div class="nav-breadcrumb"></div>
        </div>
    </nav>

    <div class="container">
        <h1>Diffusion-Limited Aggregation</h1>
        <p class="subtitle">Watch Fractal Growth Through Brownian Motion</p>

        <div class="tabs">
            <div class="tab active" data-view="growth">Growth Mode</div>
            <div class="tab" data-view="multi-seed">Multi-Seed</div>
            <div class="tab" data-view="analysis">Analysis</div>
        </div>

        <!-- Growth Mode View -->
        <div class="view active" id="growth">
            <div class="info-box">
                <h3>About Diffusion-Limited Aggregation</h3>
                <p>DLA is a process where particles undergoing random Brownian motion stick together to form intricate fractal structures.
                This simulation demonstrates the classic algorithm:</p>
                <ul>
                    <li><strong>Random Walk:</strong> Particles move randomly until they touch the aggregate</li>
                    <li><strong>Sticking:</strong> Upon contact, particles adhere with a probability you can control</li>
                    <li><strong>Fractal Growth:</strong> Creates branching patterns similar to lightning, crystals, and coral</li>
                    <li><strong>Natural Examples:</strong> Snowflakes, lightning bolts, electrodeposition, crystal growth, bacterial colonies</li>
                </ul>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="particlesPerFrame">Particles/Frame: <span id="particlesPerFrameVal">5</span></label>
                    <input type="range" id="particlesPerFrame" min="1" max="100" value="5">
                </div>
                <div class="control-group">
                    <label for="stickProb">Stick Probability: <span id="stickProbVal">1.0</span></label>
                    <input type="range" id="stickProb" min="0.1" max="1.0" step="0.1" value="1.0">
                </div>
                <div class="control-group">
                    <label for="speed">Speed: <span id="speedVal">50</span>ms</label>
                    <input type="range" id="speed" min="10" max="100" value="50">
                </div>
                <button id="toggleBtn" onclick="toggleGrowth()">Start</button>
                <button onclick="resetGrowth()">Reset</button>
                <button onclick="stepGrowth()">Step</button>
            </div>

            <div class="control-group" style="align-items: center;">
                <label>Color By:</label>
                <div class="color-selector">
                    <div class="color-option active" data-mode="time" onclick="setColorMode('time')">Arrival Time</div>
                    <div class="color-option" data-mode="distance" onclick="setColorMode('distance')">Distance from Center</div>
                    <div class="color-option" data-mode="branch" onclick="setColorMode('branch')">Branch</div>
                </div>
            </div>

            <canvas id="growthCanvas"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="totalParticles">1</div>
                        <div class="stat-label">Total Particles</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="growthRate">0</div>
                        <div class="stat-label">Particles/Second</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="maxRadius">0</div>
                        <div class="stat-label">Max Radius (px)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="fractalDim">-</div>
                        <div class="stat-label">Fractal Dimension</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Multi-Seed View -->
        <div class="view" id="multi-seed">
            <div class="info-box">
                <h3>Competing Growth Centers</h3>
                <p>Multiple seed points create competing aggregates that grow and interact. Watch how they form
                boundaries and create complex interference patterns. This models phenomena like crystal grain boundaries
                and competing bacterial colonies.</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="numSeeds">Number of Seeds: <span id="numSeedsVal">3</span></label>
                    <input type="range" id="numSeeds" min="2" max="8" value="3">
                </div>
                <div class="control-group">
                    <label for="multiParticles">Particles/Frame: <span id="multiParticlesVal">10</span></label>
                    <input type="range" id="multiParticles" min="1" max="100" value="10">
                </div>
                <div class="control-group">
                    <label for="multiSpeed">Speed: <span id="multiSpeedVal">50</span>ms</label>
                    <input type="range" id="multiSpeed" min="10" max="100" value="50">
                </div>
                <button id="toggleMultiBtn" onclick="toggleMultiSeed()">Start</button>
                <button onclick="resetMultiSeed()">Reset</button>
            </div>

            <canvas id="multiCanvas"></canvas>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="multiTotal">0</div>
                        <div class="stat-label">Total Particles</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="multiLargest">0</div>
                        <div class="stat-label">Largest Cluster</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="multiClusters">0</div>
                        <div class="stat-label">Active Clusters</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Analysis View -->
        <div class="view" id="analysis">
            <div class="info-box">
                <h3>Fractal Dimension Analysis</h3>
                <p>DLA structures exhibit fractal properties with a characteristic dimension around 1.71 in 2D.
                The fractal dimension describes how the mass scales with radius: M ∝ R<sup>D</sup>, where D is the
                fractal dimension. Compare this to regular shapes (D=2 for filled circles) to see the sparse, branching nature.</p>
                <ul>
                    <li><strong>Box Counting:</strong> Classic method for measuring fractal dimension</li>
                    <li><strong>Mass-Radius Scaling:</strong> How particle count grows with distance</li>
                    <li><strong>Expected D ≈ 1.71:</strong> Theoretical value for 2D DLA</li>
                </ul>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="analysisParticles">Target Particles: <span id="analysisParticlesVal">500</span></label>
                    <input type="range" id="analysisParticles" min="100" max="2000" step="100" value="500">
                </div>
                <button onclick="generateForAnalysis()">Generate DLA</button>
                <button onclick="calculateFractalDim()">Calculate Fractal Dimension</button>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <h3 style="text-align: center; margin-bottom: 10px;">DLA Structure</h3>
                    <canvas id="analysisCanvas"></canvas>
                </div>
                <div>
                    <h3 style="text-align: center; margin-bottom: 10px;">Mass-Radius Plot (log-log)</h3>
                    <canvas id="plotCanvas"></canvas>
                </div>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="analysisDim">-</div>
                        <div class="stat-label">Measured Dimension</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="analysisParticleCount">0</div>
                        <div class="stat-label">Particles Analyzed</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="analysisMaxR">0</div>
                        <div class="stat-label">Max Radius</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="rSquared">-</div>
                        <div class="stat-label">R² (fit quality)</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Core DLA Engine with optimized grid-based neighbor checking
        class DLASimulation {
            constructor(canvasId, centerX, centerY) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.centerX = centerX;
                this.centerY = centerY;

                // Aggregate data structures
                this.particles = [{x: centerX, y: centerY, time: 0, branch: 0}];
                this.grid = new Map(); // Fast O(1) lookup for occupied cells
                this.maxRadius = 0;
                this.spawnRadius = 20;
                this.time = 0;
                this.colorMode = 'time';

                // Performance tracking
                this.startTime = Date.now();
                this.lastCountTime = Date.now();
                this.lastCount = 1;

                // Add initial particle to grid
                this.addToGrid(centerX, centerY);
            }

            gridKey(x, y) {
                return `${Math.floor(x)},${Math.floor(y)}`;
            }

            addToGrid(x, y) {
                this.grid.set(this.gridKey(x, y), true);
            }

            isOccupied(x, y) {
                return this.grid.has(this.gridKey(x, y));
            }

            hasNeighbor(x, y) {
                // Check 8 neighbors
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        if (this.isOccupied(x + dx, y + dy)) {
                            return true;
                        }
                    }
                }
                return false;
            }

            spawnWalker() {
                const angle = Math.random() * Math.PI * 2;
                const r = this.spawnRadius;
                return {
                    x: this.centerX + Math.cos(angle) * r,
                    y: this.centerY + Math.sin(angle) * r
                };
            }

            randomWalk(walker) {
                const angle = Math.random() * Math.PI * 2;
                const step = 2;
                walker.x += Math.cos(angle) * step;
                walker.y += Math.sin(angle) * step;
            }

            step(stickProb = 1.0) {
                const walker = this.spawnWalker();
                const maxSteps = 10000;
                let steps = 0;

                while (steps < maxSteps) {
                    this.randomWalk(walker);
                    steps++;

                    // Check if walker is too far
                    const dx = walker.x - this.centerX;
                    const dy = walker.y - this.centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > this.spawnRadius * 2) {
                        return false; // Walker escaped
                    }

                    // Check if adjacent to aggregate
                    const wx = Math.floor(walker.x);
                    const wy = Math.floor(walker.y);

                    if (this.hasNeighbor(wx, wy)) {
                        // Sticking probability check
                        if (Math.random() < stickProb) {
                            this.particles.push({
                                x: wx,
                                y: wy,
                                time: this.time++,
                                branch: this.particles.length % 12 // Color branches
                            });
                            this.addToGrid(wx, wy);

                            // Update max radius and spawn radius
                            if (dist > this.maxRadius) {
                                this.maxRadius = dist;
                                this.spawnRadius = Math.max(20, this.maxRadius + 10);
                            }

                            return true; // Particle stuck
                        }
                    }
                }

                return false; // Max steps reached
            }

            draw(showTrails = false) {
                // Only clear if not showing trails
                if (!showTrails) {
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }

                const maxTime = this.particles.length;

                this.particles.forEach(p => {
                    let color;

                    switch(this.colorMode) {
                        case 'time':
                            const hue = (p.time / maxTime) * 270; // Blue to pink
                            color = `hsl(${240 + hue}, 80%, 60%)`;
                            break;
                        case 'distance':
                            const dx = p.x - this.centerX;
                            const dy = p.y - this.centerY;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const distHue = (dist / this.maxRadius) * 180;
                            color = `hsl(${distHue}, 90%, 60%)`;
                            break;
                        case 'branch':
                            const branchHue = (p.branch / 12) * 360;
                            color = `hsl(${branchHue}, 85%, 65%)`;
                            break;
                    }

                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(p.x - 1, p.y - 1, 2, 2);

                    // Add glow for newer particles
                    if (showTrails && p.time > maxTime - 100) {
                        this.ctx.shadowBlur = 5;
                        this.ctx.shadowColor = color;
                        this.ctx.fillRect(p.x - 1, p.y - 1, 2, 2);
                        this.ctx.shadowBlur = 0;
                    }
                });

                // Draw spawn circle
                this.ctx.strokeStyle = 'rgba(102, 126, 234, 0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.arc(this.centerX, this.centerY, this.spawnRadius, 0, Math.PI * 2);
                this.ctx.stroke();
            }

            getGrowthRate() {
                const now = Date.now();
                const timeDiff = (now - this.lastCountTime) / 1000;
                if (timeDiff > 1) {
                    const rate = (this.particles.length - this.lastCount) / timeDiff;
                    this.lastCount = this.particles.length;
                    this.lastCountTime = now;
                    return Math.round(rate);
                }
                return null;
            }

            estimateFractalDimension() {
                // Simple box-counting estimation
                if (this.particles.length < 100) return null;

                const radii = [];
                const masses = [];

                for (let r = 5; r < this.maxRadius; r += 5) {
                    let count = 0;
                    this.particles.forEach(p => {
                        const dx = p.x - this.centerX;
                        const dy = p.y - this.centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist <= r) count++;
                    });
                    if (count > 0) {
                        radii.push(Math.log(r));
                        masses.push(Math.log(count));
                    }
                }

                if (radii.length < 5) return null;

                // Linear regression in log-log space
                const n = radii.length;
                const sumX = radii.reduce((a, b) => a + b, 0);
                const sumY = masses.reduce((a, b) => a + b, 0);
                const sumXY = radii.reduce((sum, x, i) => sum + x * masses[i], 0);
                const sumX2 = radii.reduce((sum, x) => sum + x * x, 0);

                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                return slope.toFixed(3);
            }

            reset() {
                this.particles = [{x: this.centerX, y: this.centerY, time: 0, branch: 0}];
                this.grid.clear();
                this.addToGrid(this.centerX, this.centerY);
                this.maxRadius = 0;
                this.spawnRadius = 20;
                this.time = 0;
                this.startTime = Date.now();
                this.lastCountTime = Date.now();
                this.lastCount = 1;
            }
        }

        // Multi-seed DLA with competing growth centers
        class MultiSeedDLA {
            constructor(canvasId, numSeeds) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.numSeeds = numSeeds;

                this.particles = [];
                this.grid = new Map();
                this.seeds = [];
                this.maxRadius = 0;

                this.initializeSeeds();
            }

            initializeSeeds() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const spacing = Math.min(this.canvas.width, this.canvas.height) * 0.3;

                for (let i = 0; i < this.numSeeds; i++) {
                    const angle = (i / this.numSeeds) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * spacing;
                    const y = centerY + Math.sin(angle) * spacing;

                    this.seeds.push({x, y, color: i});
                    this.particles.push({x, y, seed: i, time: 0});
                    this.grid.set(`${Math.floor(x)},${Math.floor(y)}`, i);
                }
            }

            gridKey(x, y) {
                return `${Math.floor(x)},${Math.floor(y)}`;
            }

            hasNeighbor(x, y) {
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        const key = this.gridKey(x + dx, y + dy);
                        if (this.grid.has(key)) {
                            return this.grid.get(key);
                        }
                    }
                }
                return -1;
            }

            spawnWalker() {
                return {
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height
                };
            }

            step() {
                const walker = this.spawnWalker();
                const maxSteps = 5000;
                let steps = 0;

                while (steps < maxSteps) {
                    const angle = Math.random() * Math.PI * 2;
                    walker.x += Math.cos(angle) * 2;
                    walker.y += Math.sin(angle) * 2;
                    steps++;

                    if (walker.x < 0 || walker.x >= this.canvas.width ||
                        walker.y < 0 || walker.y >= this.canvas.height) {
                        return false;
                    }

                    const wx = Math.floor(walker.x);
                    const wy = Math.floor(walker.y);
                    const seedIdx = this.hasNeighbor(wx, wy);

                    if (seedIdx >= 0) {
                        this.particles.push({
                            x: wx,
                            y: wy,
                            seed: seedIdx,
                            time: this.particles.length
                        });
                        this.grid.set(this.gridKey(wx, wy), seedIdx);
                        return true;
                    }
                }

                return false;
            }

            draw() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.particles.forEach(p => {
                    const hue = (p.seed / this.numSeeds) * 360;
                    this.ctx.fillStyle = `hsl(${hue}, 85%, 65%)`;
                    this.ctx.fillRect(p.x - 1, p.y - 1, 2, 2);
                });
            }

            getClusterSizes() {
                const sizes = new Array(this.numSeeds).fill(0);
                this.particles.forEach(p => sizes[p.seed]++);
                return sizes;
            }

            reset(numSeeds) {
                this.numSeeds = numSeeds;
                this.particles = [];
                this.grid.clear();
                this.seeds = [];
                this.initializeSeeds();
            }
        }

        // Global state
        let dlaSim;
        let multiSim;
        let growing = false;
        let multiGrowing = false;
        let growthInterval;
        let multiInterval;

        // Initialize
        function init() {
            setupCanvases();
            setupTabs();
            setupControls();
            dlaSim = new DLASimulation('growthCanvas', 400, 300);
            dlaSim.draw();
            updateStats();
        }

        function setupCanvases() {
            const growthCanvas = document.getElementById('growthCanvas');
            const multiCanvas = document.getElementById('multiCanvas');
            const analysisCanvas = document.getElementById('analysisCanvas');
            const plotCanvas = document.getElementById('plotCanvas');

            growthCanvas.width = 800;
            growthCanvas.height = 600;
            multiCanvas.width = 800;
            multiCanvas.height = 600;
            analysisCanvas.width = 400;
            analysisCanvas.height = 400;
            plotCanvas.width = 400;
            plotCanvas.height = 400;
        }

        function setupTabs() {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.view).classList.add('active');
                });
            });
        }

        function setupControls() {
            // Growth mode controls
            document.getElementById('particlesPerFrame').addEventListener('input', (e) => {
                document.getElementById('particlesPerFrameVal').textContent = e.target.value;
            });

            document.getElementById('stickProb').addEventListener('input', (e) => {
                document.getElementById('stickProbVal').textContent = e.target.value;
            });

            document.getElementById('speed').addEventListener('input', (e) => {
                document.getElementById('speedVal').textContent = e.target.value;
                if (growing) {
                    toggleGrowth();
                    toggleGrowth();
                }
            });

            // Multi-seed controls
            document.getElementById('numSeeds').addEventListener('input', (e) => {
                document.getElementById('numSeedsVal').textContent = e.target.value;
            });

            document.getElementById('multiParticles').addEventListener('input', (e) => {
                document.getElementById('multiParticlesVal').textContent = e.target.value;
            });

            document.getElementById('multiSpeed').addEventListener('input', (e) => {
                document.getElementById('multiSpeedVal').textContent = e.target.value;
                if (multiGrowing) {
                    toggleMultiSeed();
                    toggleMultiSeed();
                }
            });

            // Analysis controls
            document.getElementById('analysisParticles').addEventListener('input', (e) => {
                document.getElementById('analysisParticlesVal').textContent = e.target.value;
            });
        }

        // Growth Mode
        function toggleGrowth() {
            if (growing) {
                clearInterval(growthInterval);
                growing = false;
                document.getElementById('toggleBtn').textContent = 'Start';
            } else {
                const speed = parseInt(document.getElementById('speed').value);
                growthInterval = setInterval(updateGrowth, speed);
                growing = true;
                document.getElementById('toggleBtn').textContent = 'Pause';
            }
        }

        function updateGrowth() {
            const particlesPerFrame = parseInt(document.getElementById('particlesPerFrame').value);
            const stickProb = parseFloat(document.getElementById('stickProb').value);

            for (let i = 0; i < particlesPerFrame; i++) {
                dlaSim.step(stickProb);
            }

            dlaSim.draw(true);
            updateStats();

            // Auto-pause if too large
            if (dlaSim.particles.length > 5000) {
                toggleGrowth();
            }
        }

        function resetGrowth() {
            if (growing) toggleGrowth();
            dlaSim.reset();
            dlaSim.draw();
            updateStats();
        }

        function stepGrowth() {
            const stickProb = parseFloat(document.getElementById('stickProb').value);
            dlaSim.step(stickProb);
            dlaSim.draw(true);
            updateStats();
        }

        function setColorMode(mode) {
            dlaSim.colorMode = mode;
            document.querySelectorAll('.color-option').forEach(opt => {
                opt.classList.remove('active');
            });
            document.querySelector(`.color-option[data-mode="${mode}"]`).classList.add('active');
            dlaSim.draw();
        }

        function updateStats() {
            document.getElementById('totalParticles').textContent = dlaSim.particles.length;
            document.getElementById('maxRadius').textContent = Math.round(dlaSim.maxRadius);

            const rate = dlaSim.getGrowthRate();
            if (rate !== null) {
                document.getElementById('growthRate').textContent = rate;
            }

            const dim = dlaSim.estimateFractalDimension();
            if (dim) {
                document.getElementById('fractalDim').textContent = dim;
            }
        }

        // Multi-Seed Mode
        function toggleMultiSeed() {
            if (multiGrowing) {
                clearInterval(multiInterval);
                multiGrowing = false;
                document.getElementById('toggleMultiBtn').textContent = 'Start';
            } else {
                if (!multiSim) {
                    const numSeeds = parseInt(document.getElementById('numSeeds').value);
                    multiSim = new MultiSeedDLA('multiCanvas', numSeeds);
                }
                const speed = parseInt(document.getElementById('multiSpeed').value);
                multiInterval = setInterval(updateMultiSeed, speed);
                multiGrowing = true;
                document.getElementById('toggleMultiBtn').textContent = 'Pause';
            }
        }

        function updateMultiSeed() {
            const particlesPerFrame = parseInt(document.getElementById('multiParticles').value);

            for (let i = 0; i < particlesPerFrame; i++) {
                multiSim.step();
            }

            multiSim.draw();
            updateMultiStats();

            if (multiSim.particles.length > 8000) {
                toggleMultiSeed();
            }
        }

        function resetMultiSeed() {
            if (multiGrowing) toggleMultiSeed();
            const numSeeds = parseInt(document.getElementById('numSeeds').value);
            multiSim = new MultiSeedDLA('multiCanvas', numSeeds);
            multiSim.draw();
            updateMultiStats();
        }

        function updateMultiStats() {
            if (!multiSim) return;

            document.getElementById('multiTotal').textContent = multiSim.particles.length;

            const sizes = multiSim.getClusterSizes();
            const largest = Math.max(...sizes);
            const active = sizes.filter(s => s > 0).length;

            document.getElementById('multiLargest').textContent = largest;
            document.getElementById('multiClusters').textContent = active;
        }

        // Analysis Mode
        function generateForAnalysis() {
            const targetParticles = parseInt(document.getElementById('analysisParticles').value);
            const analysisCanvas = document.getElementById('analysisCanvas');
            const analysisSim = new DLASimulation('analysisCanvas', 200, 200);

            // Generate in background
            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Generating...';

            let generated = 0;
            const batchSize = 50;

            const generateBatch = () => {
                for (let i = 0; i < batchSize && generated < targetParticles; i++) {
                    analysisSim.step(1.0);
                    generated++;
                }

                analysisSim.draw();
                document.getElementById('analysisParticleCount').textContent = analysisSim.particles.length;
                document.getElementById('analysisMaxR').textContent = Math.round(analysisSim.maxRadius);

                if (generated < targetParticles) {
                    setTimeout(generateBatch, 10);
                } else {
                    btn.disabled = false;
                    btn.textContent = 'Generate DLA';
                    window.analysisSim = analysisSim; // Store for dimension calculation
                }
            };

            generateBatch();
        }

        function calculateFractalDim() {
            if (!window.analysisSim) {
                alert('Please generate a DLA structure first!');
                return;
            }

            const sim = window.analysisSim;
            const centerX = sim.centerX;
            const centerY = sim.centerY;

            // Calculate mass vs radius
            const radii = [];
            const masses = [];
            const maxR = sim.maxRadius;

            for (let r = 5; r <= maxR; r += Math.max(1, Math.floor(maxR / 50))) {
                let count = 0;
                sim.particles.forEach(p => {
                    const dx = p.x - centerX;
                    const dy = p.y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= r) count++;
                });

                if (count > 1) {
                    radii.push(r);
                    masses.push(count);
                }
            }

            // Plot on log-log scale
            const plotCanvas = document.getElementById('plotCanvas');
            const ctx = plotCanvas.getContext('2d');

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, plotCanvas.width, plotCanvas.height);

            const logRadii = radii.map(r => Math.log(r));
            const logMasses = masses.map(m => Math.log(m));

            const minLogR = Math.min(...logRadii);
            const maxLogR = Math.max(...logRadii);
            const minLogM = Math.min(...logMasses);
            const maxLogM = Math.max(...logMasses);

            // Draw axes
            ctx.strokeStyle = 'rgba(224, 224, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(40, 10);
            ctx.lineTo(40, 360);
            ctx.lineTo(390, 360);
            ctx.stroke();

            // Draw data points
            ctx.fillStyle = '#667eea';
            logRadii.forEach((logR, i) => {
                const x = 40 + ((logR - minLogR) / (maxLogR - minLogR)) * 350;
                const y = 360 - ((logMasses[i] - minLogM) / (maxLogM - minLogM)) * 350;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // Calculate and draw regression line
            const n = logRadii.length;
            const sumX = logRadii.reduce((a, b) => a + b, 0);
            const sumY = logMasses.reduce((a, b) => a + b, 0);
            const sumXY = logRadii.reduce((sum, x, i) => sum + x * logMasses[i], 0);
            const sumX2 = logRadii.reduce((sum, x) => sum + x * x, 0);
            const sumY2 = logMasses.reduce((sum, y) => sum + y * y, 0);

            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            // R-squared
            const yMean = sumY / n;
            const ssRes = logMasses.reduce((sum, y, i) => {
                const yPred = slope * logRadii[i] + intercept;
                return sum + (y - yPred) * (y - yPred);
            }, 0);
            const ssTot = logMasses.reduce((sum, y) => sum + (y - yMean) * (y - yMean), 0);
            const rSquared = 1 - (ssRes / ssTot);

            // Draw regression line
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const x1 = 40;
            const y1Pred = slope * minLogR + intercept;
            const y1 = 360 - ((y1Pred - minLogM) / (maxLogM - minLogM)) * 350;

            const x2 = 390;
            const y2Pred = slope * maxLogR + intercept;
            const y2 = 360 - ((y2Pred - minLogM) / (maxLogM - minLogM)) * 350;

            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#e0e0ff';
            ctx.font = '12px monospace';
            ctx.fillText('log(Radius)', 180, 390);
            ctx.save();
            ctx.translate(15, 200);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('log(Mass)', 0, 0);
            ctx.restore();

            // Update stats
            document.getElementById('analysisDim').textContent = slope.toFixed(3);
            document.getElementById('rSquared').textContent = rSquared.toFixed(4);
        }

        // Initialize on load
        window.addEventListener('load', init);
    </script>
    <script src="../assets/js/navigation.js"></script>
</body>
</html>
