<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hopcroft DFA Minimization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #c9a227;
            text-decoration: none;
            font-size: 14px;
            opacity: 0.8;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .back-link:hover {
            opacity: 1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 60px 20px 20px;
        }

        h1 {
            text-align: center;
            font-size: 2rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #c9a227, #e0c068);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
            font-size: 0.95rem;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 280px;
            gap: 20px;
        }

        .visualization-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .panel {
            background: rgba(20, 20, 35, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(201, 162, 39, 0.2);
        }

        .panel-title {
            font-size: 0.95rem;
            color: #c9a227;
            margin-bottom: 15px;
        }

        .controls-panel {
            height: fit-content;
        }

        .section-title {
            font-size: 0.85rem;
            color: #c9a227;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #c9a227, #b8941f);
            color: #0a0a0f;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(201, 162, 39, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        canvas {
            width: 100%;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
        }

        .info-box {
            background: rgba(201, 162, 39, 0.1);
            border: 1px solid rgba(201, 162, 39, 0.3);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.8rem;
            color: #ccc;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .partition-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Consolas', monospace;
            font-size: 0.85rem;
        }

        .partition-block {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 8px 10px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border-left: 3px solid #3498db;
        }

        .partition-block.accepting {
            border-left-color: #27ae60;
        }

        .partition-block.splitting {
            border-left-color: #f39c12;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .state-chip {
            padding: 3px 10px;
            background: rgba(201, 162, 39, 0.2);
            color: #c9a227;
            border-radius: 12px;
            font-size: 0.75rem;
        }

        .state-chip.accepting {
            background: rgba(39, 174, 96, 0.2);
            color: #27ae60;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #c9a227;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
        }

        .step-info {
            background: rgba(52, 152, 219, 0.1);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.8rem;
            color: #3498db;
            margin-bottom: 15px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: #aaa;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
        }

        select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 0.85rem;
            margin-bottom: 15px;
        }

        select option {
            background: #1a1a2e;
        }

        @media (max-width: 1000px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            .visualization-area {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">← Back to Gallery</a>

    <div class="container">
        <h1>Hopcroft DFA Minimization</h1>
        <p class="subtitle">Partition refinement algorithm for DFA state minimization - O(n log n)</p>

        <div class="main-layout">
            <div class="visualization-area">
                <div class="panel">
                    <div class="panel-title">Original DFA</div>
                    <canvas id="originalCanvas"></canvas>
                </div>
                <div class="panel">
                    <div class="panel-title">Minimized DFA</div>
                    <canvas id="minimizedCanvas"></canvas>
                </div>
                <div class="panel" style="grid-column: span 2;">
                    <div class="panel-title">Partition Refinement</div>
                    <div class="partition-display" id="partitionDisplay"></div>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #27ae60;"></div>
                            <span>Accepting States</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #3498db;"></div>
                            <span>Non-accepting States</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #f39c12;"></div>
                            <span>Currently Splitting</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel controls-panel">
                <div class="info-box">
                    <strong>Hopcroft's Algorithm</strong><br>
                    Minimizes a DFA by finding equivalent states using partition refinement.
                    States that can't be distinguished by any input string are merged.
                </div>

                <div class="section-title">Example DFA</div>
                <select id="dfaSelect" onchange="loadDFA()">
                    <option value="simple">Simple (accepts strings ending in 'ab')</option>
                    <option value="redundant">Redundant States (ab*)</option>
                    <option value="even">Even number of 1s</option>
                    <option value="complex">Complex (multiple equivalences)</option>
                </select>

                <div class="section-title">Algorithm Control</div>
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="stepAlgorithm()">Step</button>
                    <button class="btn btn-secondary" onclick="runToCompletion()">Run to Completion</button>
                    <button class="btn btn-secondary" onclick="resetAlgorithm()">Reset</button>
                </div>

                <div class="step-info" id="stepInfo">
                    Click "Step" to begin partition refinement
                </div>

                <div class="section-title">Statistics</div>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-value" id="originalStates">0</div>
                        <div class="stat-label">Original</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="minimizedStates">0</div>
                        <div class="stat-label">Minimized</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="partitions">0</div>
                        <div class="stat-label">Partitions</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="steps">0</div>
                        <div class="stat-label">Steps</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const originalCanvas = document.getElementById('originalCanvas');
        const minimizedCanvas = document.getElementById('minimizedCanvas');
        const octx = originalCanvas.getContext('2d');
        const mctx = minimizedCanvas.getContext('2d');

        // Example DFAs
        const dfaExamples = {
            simple: {
                states: ['q0', 'q1', 'q2', 'q3', 'q4'],
                alphabet: ['a', 'b'],
                transitions: {
                    'q0': { 'a': 'q1', 'b': 'q0' },
                    'q1': { 'a': 'q1', 'b': 'q2' },
                    'q2': { 'a': 'q1', 'b': 'q0' },
                    'q3': { 'a': 'q4', 'b': 'q3' },  // Equivalent to q0
                    'q4': { 'a': 'q4', 'b': 'q2' }   // Equivalent to q1
                },
                start: 'q0',
                accepting: ['q2']
            },
            redundant: {
                states: ['A', 'B', 'C', 'D'],
                alphabet: ['a', 'b'],
                transitions: {
                    'A': { 'a': 'B', 'b': 'A' },
                    'B': { 'a': 'B', 'b': 'C' },
                    'C': { 'a': 'B', 'b': 'C' },  // C ≡ B
                    'D': { 'a': 'B', 'b': 'D' }   // D ≡ A
                },
                start: 'A',
                accepting: ['B', 'C']
            },
            even: {
                states: ['S0', 'S1', 'S2', 'S3'],
                alphabet: ['0', '1'],
                transitions: {
                    'S0': { '0': 'S0', '1': 'S1' },
                    'S1': { '0': 'S1', '1': 'S0' },
                    'S2': { '0': 'S2', '1': 'S3' },  // S2 ≡ S0
                    'S3': { '0': 'S3', '1': 'S2' }   // S3 ≡ S1
                },
                start: 'S0',
                accepting: ['S0', 'S2']
            },
            complex: {
                states: ['A', 'B', 'C', 'D', 'E', 'F'],
                alphabet: ['0', '1'],
                transitions: {
                    'A': { '0': 'B', '1': 'C' },
                    'B': { '0': 'A', '1': 'D' },
                    'C': { '0': 'E', '1': 'F' },
                    'D': { '0': 'E', '1': 'F' },  // D ≡ C
                    'E': { '0': 'E', '1': 'F' },
                    'F': { '0': 'F', '1': 'F' }
                },
                start: 'A',
                accepting: ['C', 'D', 'E']
            }
        };

        let currentDFA = null;
        let state = {
            partition: [],
            worklist: [],
            step: 0,
            done: false,
            splittingSet: null,
            splittingSymbol: null
        };

        function resizeCanvases() {
            [originalCanvas, minimizedCanvas].forEach(canvas => {
                const rect = canvas.parentElement.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                canvas.width = (rect.width - 40) * dpr;
                canvas.height = 250 * dpr;
                canvas.style.height = '250px';
                canvas.getContext('2d').scale(dpr, dpr);
            });
        }
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        function loadDFA() {
            const selection = document.getElementById('dfaSelect').value;
            currentDFA = JSON.parse(JSON.stringify(dfaExamples[selection]));
            resetAlgorithm();
        }

        function resetAlgorithm() {
            if (!currentDFA) return;

            // Initial partition: accepting vs non-accepting
            const accepting = currentDFA.states.filter(s => currentDFA.accepting.includes(s));
            const nonAccepting = currentDFA.states.filter(s => !currentDFA.accepting.includes(s));

            state = {
                partition: [],
                worklist: [],
                step: 0,
                done: false,
                splittingSet: null,
                splittingSymbol: null
            };

            if (accepting.length > 0) state.partition.push(accepting);
            if (nonAccepting.length > 0) state.partition.push(nonAccepting);

            // Initialize worklist with smaller set for each symbol
            currentDFA.alphabet.forEach(symbol => {
                const smaller = accepting.length <= nonAccepting.length ? accepting : nonAccepting;
                if (smaller.length > 0) {
                    state.worklist.push({ set: [...smaller], symbol });
                }
            });

            updateUI();
            draw();
        }

        function stepAlgorithm() {
            if (state.done || state.worklist.length === 0) {
                state.done = true;
                state.splittingSet = null;
                document.getElementById('stepInfo').textContent = 'Algorithm complete! DFA is minimized.';
                updateUI();
                draw();
                return;
            }

            state.step++;
            const { set: A, symbol: c } = state.worklist.shift();
            state.splittingSet = A;
            state.splittingSymbol = c;

            // Find states that transition to A on symbol c
            const goesToA = new Set();
            currentDFA.states.forEach(s => {
                const target = currentDFA.transitions[s]?.[c];
                if (target && A.includes(target)) {
                    goesToA.add(s);
                }
            });

            const newPartition = [];
            let splitOccurred = false;

            state.partition.forEach(Y => {
                const intersection = Y.filter(s => goesToA.has(s));
                const difference = Y.filter(s => !goesToA.has(s));

                if (intersection.length > 0 && difference.length > 0) {
                    // Split the set
                    splitOccurred = true;
                    newPartition.push(intersection);
                    newPartition.push(difference);

                    // Update worklist
                    currentDFA.alphabet.forEach(sym => {
                        const inWorklist = state.worklist.some(w =>
                            w.symbol === sym && arraysEqual(w.set, Y)
                        );

                        if (inWorklist) {
                            // Replace Y with both parts
                            state.worklist = state.worklist.filter(w =>
                                !(w.symbol === sym && arraysEqual(w.set, Y))
                            );
                            state.worklist.push({ set: [...intersection], symbol: sym });
                            state.worklist.push({ set: [...difference], symbol: sym });
                        } else {
                            // Add smaller part
                            const smaller = intersection.length <= difference.length ? intersection : difference;
                            state.worklist.push({ set: [...smaller], symbol: sym });
                        }
                    });
                } else {
                    newPartition.push(Y);
                }
            });

            state.partition = newPartition;

            if (splitOccurred) {
                document.getElementById('stepInfo').textContent =
                    `Split on symbol '${c}' using set {${A.join(', ')}}`;
            } else {
                document.getElementById('stepInfo').textContent =
                    `No split needed for symbol '${c}' using set {${A.join(', ')}}`;
            }

            updateUI();
            draw();
        }

        function runToCompletion() {
            while (!state.done && state.worklist.length > 0) {
                stepAlgorithm();
            }
            state.done = true;
            document.getElementById('stepInfo').textContent = 'Algorithm complete! DFA is minimized.';
            updateUI();
            draw();
        }

        function arraysEqual(a, b) {
            if (a.length !== b.length) return false;
            return a.every((v, i) => b.includes(v)) && b.every((v, i) => a.includes(v));
        }

        function updateUI() {
            document.getElementById('originalStates').textContent = currentDFA ? currentDFA.states.length : 0;
            document.getElementById('minimizedStates').textContent = state.partition.length;
            document.getElementById('partitions').textContent = state.partition.length;
            document.getElementById('steps').textContent = state.step;

            // Update partition display
            const display = document.getElementById('partitionDisplay');
            display.innerHTML = state.partition.map((block, i) => {
                const isAccepting = block.some(s => currentDFA.accepting.includes(s));
                const isSplitting = state.splittingSet && block.some(s => state.splittingSet.includes(s));

                return `
                    <div class="partition-block ${isAccepting ? 'accepting' : ''} ${isSplitting ? 'splitting' : ''}">
                        ${block.map(s => `
                            <span class="state-chip ${currentDFA.accepting.includes(s) ? 'accepting' : ''}">${s}</span>
                        `).join('')}
                    </div>
                `;
            }).join('');
        }

        function drawDFA(ctx, canvas, dfa, partition = null) {
            const width = canvas.width / (window.devicePixelRatio || 1);
            const height = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, width, height);

            if (!dfa) return;

            // Calculate state positions
            const states = partition ? partition.map((block, i) => `{${block.join(',')}}`) : dfa.states;
            const statePositions = {};
            const radius = Math.min(width, height) * 0.35;
            const centerX = width / 2;
            const centerY = height / 2;

            states.forEach((s, i) => {
                const angle = (i / states.length) * Math.PI * 2 - Math.PI / 2;
                statePositions[s] = {
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius
                };
            });

            // Draw transitions
            if (partition) {
                // Draw minimized transitions
                partition.forEach((block, i) => {
                    const fromState = `{${block.join(',')}}`;
                    const fromPos = statePositions[fromState];

                    dfa.alphabet.forEach(symbol => {
                        const rep = block[0];
                        const target = dfa.transitions[rep]?.[symbol];
                        if (target) {
                            const targetBlock = partition.find(b => b.includes(target));
                            const toState = `{${targetBlock.join(',')}}`;
                            const toPos = statePositions[toState];

                            if (fromState === toState) {
                                // Self loop
                                drawSelfLoop(ctx, fromPos.x, fromPos.y - 20, symbol);
                            } else {
                                drawArrow(ctx, fromPos, toPos, symbol);
                            }
                        }
                    });
                });
            } else {
                // Draw original transitions
                dfa.states.forEach(from => {
                    const fromPos = statePositions[from];
                    dfa.alphabet.forEach(symbol => {
                        const to = dfa.transitions[from]?.[symbol];
                        if (to) {
                            const toPos = statePositions[to];
                            if (from === to) {
                                drawSelfLoop(ctx, fromPos.x, fromPos.y - 20, symbol);
                            } else {
                                drawArrow(ctx, fromPos, toPos, symbol);
                            }
                        }
                    });
                });
            }

            // Draw states
            states.forEach((s, i) => {
                const pos = statePositions[s];
                const isAccepting = partition ?
                    partition[i].some(st => dfa.accepting.includes(st)) :
                    dfa.accepting.includes(s);
                const isStart = partition ?
                    partition[i].includes(dfa.start) :
                    s === dfa.start;

                // State circle
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 22, 0, Math.PI * 2);
                ctx.fillStyle = isAccepting ? '#27ae60' : '#3498db';
                ctx.fill();

                // Double circle for accepting
                if (isAccepting) {
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 18, 0, Math.PI * 2);
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Start arrow
                if (isStart) {
                    ctx.beginPath();
                    ctx.moveTo(pos.x - 40, pos.y);
                    ctx.lineTo(pos.x - 25, pos.y);
                    ctx.strokeStyle = '#c9a227';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(pos.x - 25, pos.y);
                    ctx.lineTo(pos.x - 32, pos.y - 5);
                    ctx.lineTo(pos.x - 32, pos.y + 5);
                    ctx.closePath();
                    ctx.fillStyle = '#c9a227';
                    ctx.fill();
                }

                // State label
                ctx.font = 'bold 11px Segoe UI';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const label = partition ? (partition[i].length === 1 ? partition[i][0] : `{${partition[i].join(',')}}`.substring(0, 8)) : s;
                ctx.fillText(label, pos.x, pos.y);
            });
        }

        function drawArrow(ctx, from, to, label) {
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            const nx = dx / len;
            const ny = dy / len;

            const startX = from.x + nx * 25;
            const startY = from.y + ny * 25;
            const endX = to.x - nx * 25;
            const endY = to.y - ny * 25;

            // Curve offset for bidirectional
            const offset = 10;
            const midX = (startX + endX) / 2 - ny * offset;
            const midY = (startY + endY) / 2 + nx * offset;

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.quadraticCurveTo(midX, midY, endX, endY);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Arrowhead
            const angle = Math.atan2(endY - midY, endX - midX);
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - 8 * Math.cos(angle - 0.4), endY - 8 * Math.sin(angle - 0.4));
            ctx.lineTo(endX - 8 * Math.cos(angle + 0.4), endY - 8 * Math.sin(angle + 0.4));
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fill();

            // Label
            ctx.font = '10px Segoe UI';
            ctx.fillStyle = '#c9a227';
            ctx.textAlign = 'center';
            ctx.fillText(label, midX, midY - 5);
        }

        function drawSelfLoop(ctx, x, y, label) {
            ctx.beginPath();
            ctx.arc(x, y - 15, 12, 0.5, Math.PI * 2 - 0.5);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            ctx.font = '10px Segoe UI';
            ctx.fillStyle = '#c9a227';
            ctx.textAlign = 'center';
            ctx.fillText(label, x, y - 32);
        }

        function draw() {
            drawDFA(octx, originalCanvas, currentDFA);
            drawDFA(mctx, minimizedCanvas, currentDFA, state.done ? state.partition : null);
        }

        // Expose for enhance.js keyboard shortcuts
        window.reset = function() { loadDFA(); };
        window.init = function() { loadDFA(); };

        // Initialize
        loadDFA();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
