<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Threes: Congregation - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --sage: #8A9A5B;
            --moss: #606C38;
            --earth: #DDA15E;
            --cream: #FEFAE0;
            --terracotta: #BC6C25;
            --dark-moss: #3d4423;

            --cell-width: 72px;
            --cell-height: 88px;
            --cell-gap: 8px;
            --board-padding: 10px;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #FEFAE0 0%, #F4F1DE 50%, #EDE8D5 100%);
            color: var(--moss);
            min-height: 100vh;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        .organic-shape {
            position: fixed;
            border-radius: 63% 37% 54% 46% / 55% 48% 52% 45%;
            opacity: 0.07;
            animation: morph 30s infinite ease-in-out;
            z-index: 0;
            pointer-events: none;
        }

        .shape-1 {
            width: 500px;
            height: 500px;
            background: var(--sage);
            top: -150px;
            left: -150px;
        }

        .shape-2 {
            width: 400px;
            height: 400px;
            background: var(--earth);
            bottom: -100px;
            right: -100px;
            animation-delay: -10s;
        }

        .shape-3 {
            width: 300px;
            height: 300px;
            background: var(--terracotta);
            top: 50%;
            right: -100px;
            animation-delay: -20s;
        }

        @keyframes morph {
            0%, 100% { border-radius: 63% 37% 54% 46% / 55% 48% 52% 45%; transform: rotate(0deg) scale(1); }
            25% { border-radius: 40% 60% 70% 30% / 40% 40% 60% 60%; transform: rotate(90deg) scale(1.05); }
            50% { border-radius: 50% 50% 33% 67% / 55% 27% 73% 45%; transform: rotate(180deg) scale(1); }
            75% { border-radius: 70% 30% 50% 50% / 30% 65% 35% 70%; transform: rotate(270deg) scale(0.95); }
        }

        .back-link {
            position: fixed;
            top: 1rem;
            left: 1rem;
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            color: var(--terracotta);
            text-decoration: none;
            font-weight: 600;
            font-size: 0.9rem;
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .back-link:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateX(-3px);
        }

        .game-container {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            min-height: 100dvh;
            padding: 1rem;
            width: 100%;
            max-width: 500px;
        }

        .header {
            text-align: center;
            margin-bottom: 0.75rem;
        }

        h1 {
            font-family: 'Lora', serif;
            font-size: clamp(1.4rem, 4vw, 1.8rem);
            font-weight: 700;
            color: var(--moss);
            margin-bottom: 0.15rem;
        }

        .subtitle {
            font-size: 0.8rem;
            color: var(--terracotta);
            font-weight: 500;
        }

        .score-container {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
            width: 100%;
            max-width: 336px;
        }

        .score-box {
            flex: 1;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 0.6rem 0.75rem;
            text-align: center;
            transition: transform 0.2s ease;
        }

        .score-box.highlight {
            animation: scorePopAnim 0.3s ease;
        }

        @keyframes scorePopAnim {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .score-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--sage);
            font-weight: 600;
        }

        .score-value {
            font-family: 'Lora', serif;
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--dark-moss);
        }

        .info-row {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
            width: 100%;
            max-width: 336px;
        }

        .next-tile-container {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 0.4rem 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.6rem;
            flex: 1;
        }

        .next-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--sage);
            font-weight: 600;
        }

        .next-tile-preview {
            width: 36px;
            height: 44px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Lora', serif;
            font-weight: 700;
            font-size: 1rem;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
        }

        .era-container {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 0.4rem 0.75rem;
            text-align: center;
            flex: 1;
        }

        .era-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--sage);
            font-weight: 600;
        }

        .era-value {
            font-family: 'Lora', serif;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--dark-moss);
        }

        .board-wrapper {
            position: relative;
        }

        .board {
            background: rgba(96, 108, 56, 0.12);
            border-radius: 14px;
            padding: var(--board-padding);
            display: grid;
            grid-template-columns: repeat(4, var(--cell-width));
            grid-template-rows: repeat(4, var(--cell-height));
            gap: var(--cell-gap);
            box-shadow:
                0 8px 32px rgba(96, 108, 56, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            touch-action: none;
            position: relative;
        }

        .cell {
            background: rgba(255, 255, 255, 0.25);
            border-radius: 8px;
        }

        .tiles-container {
            position: absolute;
            top: var(--board-padding);
            left: var(--board-padding);
            width: calc(4 * var(--cell-width) + 3 * var(--cell-gap));
            height: calc(4 * var(--cell-height) + 3 * var(--cell-gap));
            pointer-events: none;
        }

        .tile {
            position: absolute;
            width: var(--cell-width);
            height: var(--cell-height);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Lora', serif;
            font-weight: 700;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.12);
            z-index: 10;
            will-change: transform;
        }

        .tile.sliding {
            transition: left 0.1s ease-out, top 0.1s ease-out;
        }

        .tile-value {
            font-size: 1.6rem;
            line-height: 1;
        }

        .tile-label {
            font-family: 'Nunito', sans-serif;
            font-size: 0.45rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.02em;
            margin-top: 3px;
            opacity: 0.85;
            text-align: center;
            max-width: 90%;
        }

        /* Tile colors - 1 and 2 are complementary, 3+ form a gradient */
        .tile-1 { background: linear-gradient(135deg, #7FCDCD 0%, #5BB5B5 100%); color: #fff; }
        .tile-2 { background: linear-gradient(135deg, #F5A3A3 0%, #E88888 100%); color: #fff; }
        .tile-3 { background: linear-gradient(135deg, #FEFAE0 0%, #F5F0D0 100%); color: var(--dark-moss); border: 2px solid var(--sage); }
        .tile-6 { background: linear-gradient(135deg, #E8D5B7 0%, #DCC5A0 100%); color: var(--dark-moss); }
        .tile-12 { background: linear-gradient(135deg, #DDA15E 0%, #CC9045 100%); color: #fff; }
        .tile-24 { background: linear-gradient(135deg, #BC6C25 0%, #A55A18 100%); color: #fff; }
        .tile-48 { background: linear-gradient(135deg, #8A9A5B 0%, #758548 100%); color: #fff; }
        .tile-96 { background: linear-gradient(135deg, #606C38 0%, #4D5A2C 100%); color: #fff; }
        .tile-192 { background: linear-gradient(135deg, #4A5628 0%, #3A441E 100%); color: #fff; }
        .tile-384 { background: linear-gradient(135deg, #3d4423 0%, #2D3318 100%); color: #fff; }
        .tile-768 { background: linear-gradient(135deg, #6B4423 0%, #5A3518 100%); color: #fff; }
        .tile-1536 { background: linear-gradient(135deg, #8B4513 0%, #7A3A0F 100%); color: #fff; }
        .tile-3072 { background: linear-gradient(135deg, #B8860B 0%, #9A7209 100%); color: #fff; box-shadow: 0 0 20px rgba(184, 134, 11, 0.4); }
        .tile-6144 { background: linear-gradient(135deg, #DAA520 0%, #C4950F 100%); color: #fff; box-shadow: 0 0 25px rgba(218, 165, 32, 0.5); }

        .tile-new {
            animation: tileAppear 0.15s ease-out;
        }

        .tile-merge {
            animation: tileMerge 0.12s ease-out;
        }

        @keyframes tileAppear {
            0% { transform: scale(0.5); opacity: 0; }
            70% { transform: scale(1.05); }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes tileMerge {
            0% { transform: scale(1); }
            40% { transform: scale(1.12); }
            100% { transform: scale(1); }
        }

        .controls {
            margin-top: 1rem;
            display: flex;
            gap: 0.6rem;
        }

        .btn {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border: 2px solid transparent;
            border-radius: 10px;
            padding: 0.6rem 1.2rem;
            font-family: 'Nunito', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--moss);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.95);
            border-color: var(--earth);
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--sage), var(--moss));
            color: #fff;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, var(--moss), var(--dark-moss));
            border-color: transparent;
        }

        .btn-icon {
            padding: 0.6rem 0.8rem;
            font-size: 1rem;
        }

        .instructions {
            margin-top: 1rem;
            text-align: center;
            font-size: 0.75rem;
            color: var(--sage);
            max-width: 336px;
            line-height: 1.5;
        }

        .instructions kbd {
            background: rgba(255, 255, 255, 0.7);
            padding: 0.1rem 0.35rem;
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.7rem;
        }

        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(254, 250, 224, 0.97);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            backdrop-filter: blur(4px);
        }

        .game-over-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .game-over-content {
            text-align: center;
            padding: 2rem;
            max-width: 360px;
        }

        .game-over-title {
            font-family: 'Lora', serif;
            font-size: 2rem;
            color: var(--moss);
            margin-bottom: 0.4rem;
        }

        .game-over-subtitle {
            font-size: 0.95rem;
            color: var(--terracotta);
            margin-bottom: 1.25rem;
        }

        .final-score {
            font-family: 'Lora', serif;
            font-size: 3.5rem;
            font-weight: 700;
            color: var(--dark-moss);
            margin-bottom: 0.25rem;
            line-height: 1;
        }

        .final-score-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--sage);
            margin-bottom: 1rem;
        }

        .milestone-reached {
            font-size: 0.85rem;
            color: var(--moss);
            margin-bottom: 1.5rem;
            line-height: 1.5;
            font-style: italic;
        }

        .stats-summary {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
            justify-content: center;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-family: 'Lora', serif;
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--moss);
        }

        .stat-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--sage);
        }

        .highest-tile-display {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        /* Responsive adjustments */
        @media (max-width: 380px) {
            :root {
                --cell-width: 62px;
                --cell-height: 76px;
                --cell-gap: 6px;
                --board-padding: 8px;
            }
            .tile-value { font-size: 1.4rem; }
            .tile-label { font-size: 0.4rem; }
        }

        @media (max-height: 680px) {
            .header { margin-bottom: 0.5rem; }
            .subtitle { display: none; }
            h1 { font-size: 1.3rem; }
            .score-container { margin-bottom: 0.5rem; }
            .info-row { margin-bottom: 0.5rem; }
            .controls { margin-top: 0.75rem; }
            .instructions { margin-top: 0.75rem; font-size: 0.7rem; }
            :root {
                --cell-width: 64px;
                --cell-height: 78px;
            }
        }

        /* Swipe indicator */
        .swipe-hint {
            position: absolute;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .swipe-hint.visible {
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div class="organic-shape shape-1"></div>
    <div class="organic-shape shape-2"></div>
    <div class="organic-shape shape-3"></div>

    <a href="index.html" class="back-link">
        <span>←</span>
        <span>Games</span>
    </a>

    <div class="game-container">
        <header class="header">
            <h1>Threes: Congregation</h1>
            <p class="subtitle">The Architecture of American Belief</p>
        </header>

        <div class="score-container">
            <div class="score-box" id="score-box">
                <div class="score-label">Membership</div>
                <div class="score-value" id="score">0</div>
            </div>
            <div class="score-box">
                <div class="score-label">Best</div>
                <div class="score-value" id="best-score">0</div>
            </div>
        </div>

        <div class="info-row">
            <div class="next-tile-container">
                <span class="next-label">Next</span>
                <div class="next-tile-preview" id="next-tile"></div>
            </div>
            <div class="era-container">
                <div class="era-label">Era</div>
                <div class="era-value" id="era">1940s</div>
            </div>
        </div>

        <div class="board-wrapper">
            <div class="board" id="board">
                <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
                <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
                <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
                <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
            </div>
            <div class="tiles-container" id="tiles-container"></div>
        </div>

        <div class="controls">
            <button class="btn btn-icon" id="undo-btn" title="Undo">↶</button>
            <button class="btn btn-primary" id="new-game-btn">New Game</button>
        </div>

        <div class="instructions">
            Swipe or use <kbd>←</kbd><kbd>↑</kbd><kbd>→</kbd><kbd>↓</kbd> to slide.<br>
            <strong>1+2→3</strong>, then merge equals: <strong>3+3→6</strong>, <strong>6+6→12</strong>…
        </div>
    </div>

    <div class="game-over-overlay" id="game-over">
        <div class="game-over-content">
            <h2 class="game-over-title">The Pews Are Full</h2>
            <p class="game-over-subtitle">No room for growth remains</p>

            <div class="final-score" id="final-score">0</div>
            <div class="final-score-label">Total Membership</div>

            <div class="highest-tile-display tile" id="highest-tile-display">
                <span class="tile-value" id="highest-tile-value">0</span>
                <span class="tile-label" id="highest-tile-label"></span>
            </div>

            <p class="milestone-reached" id="milestone-text"></p>

            <div class="stats-summary">
                <div class="stat-item">
                    <div class="stat-value" id="moves-count">0</div>
                    <div class="stat-label">Moves</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="merges-count">0</div>
                    <div class="stat-label">Mergers</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="final-era">2020s</div>
                    <div class="stat-label">Final Era</div>
                </div>
            </div>

            <button class="btn btn-primary" id="play-again-btn">Try Again</button>
        </div>
    </div>

    <script>
        // Threes: Congregation - Game Engine
        const GRID_SIZE = 4;

        // Tile labels themed around the paper's religious demographics
        const TILE_LABELS = {
            1: 'Seeker',
            2: 'Visitor',
            3: 'Member',
            6: 'Deacon',
            12: 'Elder',
            24: 'Pastor',
            48: 'Chapel',
            96: 'Parish',
            192: 'Diocese',
            384: 'District',
            768: 'Synod',
            1536: 'Conference',
            3072: 'Megachurch',
            6144: 'Denomination'
        };

        // Milestones with statistics from the paper
        const MILESTONES = {
            3: 'Your first member joins—73% of Americans held church membership in 1940.',
            6: 'A deacon emerges. Small groups form the backbone of congregational life.',
            12: 'Elders guide your flock. The post-war boom saw 182,856 congregations nationwide.',
            24: 'A pastor leads. By 1960, membership peaked at 76%—the highest in recorded history.',
            48: 'A proper chapel! The median congregation today has just 65 members.',
            96: 'A parish forms. The Mainline denominations once dominated American civic life.',
            192: 'Your diocese spans regions. The UMC had 11 million members at its 1968 peak.',
            384: 'A district takes shape. The SBC grew from 7M (1950) to 16.3M (2006).',
            768: 'Your synod convenes! By 2020, only 47% of Americans held membership.',
            1536: 'A conference assembles. The "Nones" rose from 5% (1972) to 29% (2021).',
            3072: 'MEGACHURCH STATUS! You\'ve joined the 1,750+ megachurches reshaping American faith.',
            6144: 'A DENOMINATION! Like the 21M nondenominational adherents, you\'ve reshaped the landscape.'
        };

        // Eras based on moves (referencing the paper's timeline)
        const ERAS = [
            { moves: 0, name: '1940s', desc: 'Post-war stability' },
            { moves: 15, name: '1950s', desc: 'Suburban boom' },
            { moves: 30, name: '1960s', desc: 'Peak membership' },
            { moves: 50, name: '1970s', desc: 'Cultural shifts' },
            { moves: 75, name: '1980s', desc: 'Moral Majority' },
            { moves: 100, name: '1990s', desc: 'Plateau before decline' },
            { moves: 130, name: '2000s', desc: 'The tipping point' },
            { moves: 165, name: '2010s', desc: 'Accelerated decline' },
            { moves: 200, name: '2020s', desc: 'Below 50% membership' },
            { moves: 250, name: '2030s', desc: 'The Great De-churching' }
        ];

        class ThreesGame {
            constructor() {
                this.grid = [];
                this.score = 0;
                this.bestScore = parseInt(localStorage.getItem('threes-congregation-best') || '0');
                this.moves = 0;
                this.merges = 0;
                this.nextTile = 1;
                this.gameOver = false;
                this.highestTile = 0;
                this.previousState = null;
                this.animating = false;

                // DOM elements
                this.tilesContainer = document.getElementById('tiles-container');
                this.scoreEl = document.getElementById('score');
                this.scoreBoxEl = document.getElementById('score-box');
                this.bestScoreEl = document.getElementById('best-score');
                this.nextTileEl = document.getElementById('next-tile');
                this.eraEl = document.getElementById('era');
                this.gameOverEl = document.getElementById('game-over');
                this.boardEl = document.getElementById('board');

                this.cellWidth = 72;
                this.cellHeight = 88;
                this.cellGap = 8;

                this.init();
                this.setupEventListeners();
                this.updateDimensions();
            }

            updateDimensions() {
                const style = getComputedStyle(document.documentElement);
                this.cellWidth = parseInt(style.getPropertyValue('--cell-width')) || 72;
                this.cellHeight = parseInt(style.getPropertyValue('--cell-height')) || 88;
                this.cellGap = parseInt(style.getPropertyValue('--cell-gap')) || 8;
            }

            init() {
                this.grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
                this.score = 0;
                this.moves = 0;
                this.merges = 0;
                this.gameOver = false;
                this.highestTile = 0;
                this.previousState = null;
                this.animating = false;

                // Place initial tiles (9 tiles like original Threes)
                const positions = this.getRandomPositions(9);
                positions.forEach(pos => {
                    const value = this.getRandomStartTile();
                    this.grid[pos.row][pos.col] = value;
                    this.highestTile = Math.max(this.highestTile, value);
                });

                this.nextTile = this.getRandomNewTile();
                this.render();
                this.updateScore();
                this.updateEra();
                this.updateNextTile();
                this.hideGameOver();
                document.getElementById('undo-btn').disabled = true;
            }

            getRandomPositions(count) {
                const positions = [];
                const available = [];
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        available.push({ row: r, col: c });
                    }
                }
                for (let i = 0; i < count && available.length > 0; i++) {
                    const idx = Math.floor(Math.random() * available.length);
                    positions.push(available.splice(idx, 1)[0]);
                }
                return positions;
            }

            getRandomStartTile() {
                const rand = Math.random();
                if (rand < 0.4) return 1;
                if (rand < 0.8) return 2;
                return 3;
            }

            getRandomNewTile() {
                const rand = Math.random();
                if (rand < 0.35) return 1;
                if (rand < 0.7) return 2;
                if (rand < 0.96) return 3;
                // Rare bonus tile when high tiles exist
                if (this.highestTile >= 48) {
                    const bonusTile = Math.max(6, this.highestTile / 8);
                    // Make sure it's a valid tile value (power of 2 times 3)
                    const validTiles = [6, 12, 24, 48, 96];
                    const filtered = validTiles.filter(t => t <= bonusTile);
                    if (filtered.length > 0) {
                        return filtered[filtered.length - 1];
                    }
                }
                return 3;
            }

            canMerge(a, b) {
                if (a === 0 || b === 0) return false;
                if ((a === 1 && b === 2) || (a === 2 && b === 1)) return true;
                if (a >= 3 && a === b) return true;
                return false;
            }

            getMergeResult(a, b) {
                if ((a === 1 && b === 2) || (a === 2 && b === 1)) return 3;
                if (a >= 3 && a === b) return a * 2;
                return 0;
            }

            saveState() {
                this.previousState = {
                    grid: this.grid.map(row => [...row]),
                    score: this.score,
                    moves: this.moves,
                    merges: this.merges,
                    nextTile: this.nextTile,
                    highestTile: this.highestTile
                };
                document.getElementById('undo-btn').disabled = false;
            }

            undo() {
                if (!this.previousState || this.animating) return;

                this.grid = this.previousState.grid;
                this.score = this.previousState.score;
                this.moves = this.previousState.moves;
                this.merges = this.previousState.merges;
                this.nextTile = this.previousState.nextTile;
                this.highestTile = this.previousState.highestTile;
                this.previousState = null;

                this.render();
                this.updateScore();
                this.updateEra();
                this.updateNextTile();
                document.getElementById('undo-btn').disabled = true;
            }

            move(direction) {
                if (this.gameOver || this.animating) return false;

                this.saveState();

                const oldGrid = this.grid.map(row => [...row]);
                let moved = false;
                const mergedPositions = [];
                const movements = []; // Track movements for animation

                // Process each row/column based on direction
                if (direction === 'left') {
                    for (let r = 0; r < GRID_SIZE; r++) {
                        for (let c = 1; c < GRID_SIZE; c++) {
                            if (this.grid[r][c] !== 0) {
                                if (this.grid[r][c - 1] === 0) {
                                    movements.push({ fromR: r, fromC: c, toR: r, toC: c - 1 });
                                    this.grid[r][c - 1] = this.grid[r][c];
                                    this.grid[r][c] = 0;
                                    moved = true;
                                } else if (this.canMerge(this.grid[r][c - 1], this.grid[r][c])) {
                                    movements.push({ fromR: r, fromC: c, toR: r, toC: c - 1, merge: true });
                                    this.grid[r][c - 1] = this.getMergeResult(this.grid[r][c - 1], this.grid[r][c]);
                                    this.grid[r][c] = 0;
                                    mergedPositions.push({ row: r, col: c - 1 });
                                    moved = true;
                                    this.merges++;
                                }
                            }
                        }
                    }
                } else if (direction === 'right') {
                    for (let r = 0; r < GRID_SIZE; r++) {
                        for (let c = GRID_SIZE - 2; c >= 0; c--) {
                            if (this.grid[r][c] !== 0) {
                                if (this.grid[r][c + 1] === 0) {
                                    movements.push({ fromR: r, fromC: c, toR: r, toC: c + 1 });
                                    this.grid[r][c + 1] = this.grid[r][c];
                                    this.grid[r][c] = 0;
                                    moved = true;
                                } else if (this.canMerge(this.grid[r][c + 1], this.grid[r][c])) {
                                    movements.push({ fromR: r, fromC: c, toR: r, toC: c + 1, merge: true });
                                    this.grid[r][c + 1] = this.getMergeResult(this.grid[r][c + 1], this.grid[r][c]);
                                    this.grid[r][c] = 0;
                                    mergedPositions.push({ row: r, col: c + 1 });
                                    moved = true;
                                    this.merges++;
                                }
                            }
                        }
                    }
                } else if (direction === 'up') {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        for (let r = 1; r < GRID_SIZE; r++) {
                            if (this.grid[r][c] !== 0) {
                                if (this.grid[r - 1][c] === 0) {
                                    movements.push({ fromR: r, fromC: c, toR: r - 1, toC: c });
                                    this.grid[r - 1][c] = this.grid[r][c];
                                    this.grid[r][c] = 0;
                                    moved = true;
                                } else if (this.canMerge(this.grid[r - 1][c], this.grid[r][c])) {
                                    movements.push({ fromR: r, fromC: c, toR: r - 1, toC: c, merge: true });
                                    this.grid[r - 1][c] = this.getMergeResult(this.grid[r - 1][c], this.grid[r][c]);
                                    this.grid[r][c] = 0;
                                    mergedPositions.push({ row: r - 1, col: c });
                                    moved = true;
                                    this.merges++;
                                }
                            }
                        }
                    }
                } else if (direction === 'down') {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        for (let r = GRID_SIZE - 2; r >= 0; r--) {
                            if (this.grid[r][c] !== 0) {
                                if (this.grid[r + 1][c] === 0) {
                                    movements.push({ fromR: r, fromC: c, toR: r + 1, toC: c });
                                    this.grid[r + 1][c] = this.grid[r][c];
                                    this.grid[r][c] = 0;
                                    moved = true;
                                } else if (this.canMerge(this.grid[r + 1][c], this.grid[r][c])) {
                                    movements.push({ fromR: r, fromC: c, toR: r + 1, toC: c, merge: true });
                                    this.grid[r + 1][c] = this.getMergeResult(this.grid[r + 1][c], this.grid[r][c]);
                                    this.grid[r][c] = 0;
                                    mergedPositions.push({ row: r + 1, col: c });
                                    moved = true;
                                    this.merges++;
                                }
                            }
                        }
                    }
                }

                if (moved) {
                    this.moves++;
                    const newTilePos = this.addNewTile(direction, oldGrid);
                    this.calculateScore();
                    this.updateEra();

                    // Animate then render
                    this.animateMove(oldGrid, mergedPositions, newTilePos, () => {
                        this.nextTile = this.getRandomNewTile();
                        this.updateNextTile();

                        if (this.checkGameOver()) {
                            this.gameOver = true;
                            setTimeout(() => this.showGameOver(), 200);
                        }
                    });
                } else {
                    this.previousState = null; // No move, no undo needed
                }

                return moved;
            }

            addNewTile(direction, oldGrid) {
                // Find rows/columns that actually had tiles move
                const movedLines = new Set();

                if (direction === 'left' || direction === 'right') {
                    for (let r = 0; r < GRID_SIZE; r++) {
                        for (let c = 0; c < GRID_SIZE; c++) {
                            if (oldGrid[r][c] !== this.grid[r][c]) {
                                movedLines.add(r);
                                break;
                            }
                        }
                    }
                } else {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        for (let r = 0; r < GRID_SIZE; r++) {
                            if (oldGrid[r][c] !== this.grid[r][c]) {
                                movedLines.add(c);
                                break;
                            }
                        }
                    }
                }

                const candidates = [];
                const movedArray = Array.from(movedLines);

                if (direction === 'left') {
                    for (const r of movedArray) {
                        if (this.grid[r][GRID_SIZE - 1] === 0) {
                            candidates.push({ row: r, col: GRID_SIZE - 1 });
                        }
                    }
                } else if (direction === 'right') {
                    for (const r of movedArray) {
                        if (this.grid[r][0] === 0) {
                            candidates.push({ row: r, col: 0 });
                        }
                    }
                } else if (direction === 'up') {
                    for (const c of movedArray) {
                        if (this.grid[GRID_SIZE - 1][c] === 0) {
                            candidates.push({ row: GRID_SIZE - 1, col: c });
                        }
                    }
                } else if (direction === 'down') {
                    for (const c of movedArray) {
                        if (this.grid[0][c] === 0) {
                            candidates.push({ row: 0, col: c });
                        }
                    }
                }

                if (candidates.length > 0) {
                    const pos = candidates[Math.floor(Math.random() * candidates.length)];
                    this.grid[pos.row][pos.col] = this.nextTile;
                    this.highestTile = Math.max(this.highestTile, this.nextTile);
                    return pos;
                }
                return null;
            }

            animateMove(oldGrid, mergedPositions, newTilePos, callback) {
                this.animating = true;

                // Clear and create tiles at old positions
                this.tilesContainer.innerHTML = '';

                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const val = oldGrid[r][c];
                        if (val !== 0) {
                            const tile = this.createTileElement(val, r, c);
                            this.tilesContainer.appendChild(tile);
                        }
                    }
                }

                // Force reflow
                this.tilesContainer.offsetHeight;

                // Add sliding class and move to new positions
                const tiles = this.tilesContainer.querySelectorAll('.tile');
                tiles.forEach(tile => tile.classList.add('sliding'));

                // Update positions
                setTimeout(() => {
                    this.render(mergedPositions, newTilePos);
                    this.animating = false;
                    callback();
                }, 110);
            }

            createTileElement(val, row, col) {
                const tile = document.createElement('div');
                tile.className = `tile tile-${val}`;
                tile.style.left = `${col * (this.cellWidth + this.cellGap)}px`;
                tile.style.top = `${row * (this.cellHeight + this.cellGap)}px`;

                const valueSpan = document.createElement('span');
                valueSpan.className = 'tile-value';
                valueSpan.textContent = val;
                tile.appendChild(valueSpan);

                if (TILE_LABELS[val]) {
                    const labelSpan = document.createElement('span');
                    labelSpan.className = 'tile-label';
                    labelSpan.textContent = TILE_LABELS[val];
                    tile.appendChild(labelSpan);
                }

                return tile;
            }

            calculateScore() {
                let score = 0;
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const val = this.grid[r][c];
                        if (val >= 3) {
                            // Threes scoring: 3^(log2(val/3) + 1)
                            const power = Math.log2(val / 3) + 1;
                            score += Math.pow(3, power);
                        }
                    }
                }
                this.score = Math.floor(score);
                this.updateScore();
            }

            updateScore() {
                const oldScore = parseInt(this.scoreEl.textContent.replace(/,/g, '')) || 0;
                this.scoreEl.textContent = this.score.toLocaleString();

                if (this.score > oldScore && oldScore > 0) {
                    this.scoreBoxEl.classList.remove('highlight');
                    void this.scoreBoxEl.offsetWidth;
                    this.scoreBoxEl.classList.add('highlight');
                }

                if (this.score > this.bestScore) {
                    this.bestScore = this.score;
                    localStorage.setItem('threes-congregation-best', this.bestScore.toString());
                }
                this.bestScoreEl.textContent = this.bestScore.toLocaleString();
            }

            updateEra() {
                let currentEra = ERAS[0];
                for (const era of ERAS) {
                    if (this.moves >= era.moves) {
                        currentEra = era;
                    }
                }
                this.eraEl.textContent = currentEra.name;
                this.eraEl.title = currentEra.desc;
            }

            updateNextTile() {
                this.nextTileEl.className = `next-tile-preview tile-${this.nextTile}`;
                this.nextTileEl.textContent = this.nextTile;
            }

            checkGameOver() {
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        if (this.grid[r][c] === 0) return false;
                    }
                }
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const val = this.grid[r][c];
                        if (c < GRID_SIZE - 1 && this.canMerge(val, this.grid[r][c + 1])) return false;
                        if (r < GRID_SIZE - 1 && this.canMerge(val, this.grid[r + 1][c])) return false;
                    }
                }
                return true;
            }

            render(mergedPositions = [], newTilePos = null) {
                this.tilesContainer.innerHTML = '';

                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const val = this.grid[r][c];
                        if (val !== 0) {
                            const tile = this.createTileElement(val, r, c);

                            const isMerged = mergedPositions.some(p => p.row === r && p.col === c);
                            const isNew = newTilePos && newTilePos.row === r && newTilePos.col === c;

                            if (isMerged) tile.classList.add('tile-merge');
                            if (isNew) tile.classList.add('tile-new');

                            this.tilesContainer.appendChild(tile);
                            this.highestTile = Math.max(this.highestTile, val);
                        }
                    }
                }
            }

            showGameOver() {
                document.getElementById('final-score').textContent = this.score.toLocaleString();
                document.getElementById('moves-count').textContent = this.moves;
                document.getElementById('merges-count').textContent = this.merges;

                // Get current era
                let currentEra = ERAS[0];
                for (const era of ERAS) {
                    if (this.moves >= era.moves) currentEra = era;
                }
                document.getElementById('final-era').textContent = currentEra.name;

                // Highest tile display
                const displayEl = document.getElementById('highest-tile-display');
                displayEl.className = `highest-tile-display tile tile-${this.highestTile}`;
                document.getElementById('highest-tile-value').textContent = this.highestTile;
                document.getElementById('highest-tile-label').textContent = TILE_LABELS[this.highestTile] || '';

                // Milestone text
                let milestoneText = 'Every congregation starts with a single seeker.';
                const milestoneValues = Object.keys(MILESTONES).map(Number).sort((a, b) => b - a);
                for (const val of milestoneValues) {
                    if (this.highestTile >= val) {
                        milestoneText = MILESTONES[val];
                        break;
                    }
                }
                document.getElementById('milestone-text').textContent = `"${milestoneText}"`;

                this.gameOverEl.classList.add('active');
            }

            hideGameOver() {
                this.gameOverEl.classList.remove('active');
            }

            setupEventListeners() {
                // Keyboard
                document.addEventListener('keydown', (e) => {
                    if (this.gameOver) return;
                    const keyMap = {
                        'ArrowLeft': 'left', 'ArrowRight': 'right',
                        'ArrowUp': 'up', 'ArrowDown': 'down',
                        'a': 'left', 'd': 'right', 'w': 'up', 's': 'down',
                        'h': 'left', 'l': 'right', 'k': 'up', 'j': 'down'
                    };
                    if (keyMap[e.key]) {
                        e.preventDefault();
                        this.move(keyMap[e.key]);
                    }
                    if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
                        e.preventDefault();
                        this.undo();
                    }
                });

                // Touch handling
                let touchStartX = 0, touchStartY = 0;
                let touching = false;

                const handleTouchStart = (e) => {
                    touching = true;
                    const touch = e.touches ? e.touches[0] : e;
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                };

                const handleTouchEnd = (e) => {
                    if (!touching) return;
                    touching = false;

                    const touch = e.changedTouches ? e.changedTouches[0] : e;
                    const dx = touch.clientX - touchStartX;
                    const dy = touch.clientY - touchStartY;
                    const absDx = Math.abs(dx);
                    const absDy = Math.abs(dy);

                    if (Math.max(absDx, absDy) < 25) return;

                    if (absDx > absDy) {
                        this.move(dx > 0 ? 'right' : 'left');
                    } else {
                        this.move(dy > 0 ? 'down' : 'up');
                    }
                };

                this.boardEl.addEventListener('touchstart', handleTouchStart, { passive: true });
                this.boardEl.addEventListener('touchend', handleTouchEnd, { passive: true });

                // Mouse swipe
                let mouseDown = false;
                this.boardEl.addEventListener('mousedown', (e) => {
                    mouseDown = true;
                    touchStartX = e.clientX;
                    touchStartY = e.clientY;
                });

                document.addEventListener('mouseup', (e) => {
                    if (!mouseDown) return;
                    mouseDown = false;

                    const dx = e.clientX - touchStartX;
                    const dy = e.clientY - touchStartY;
                    const absDx = Math.abs(dx);
                    const absDy = Math.abs(dy);

                    if (Math.max(absDx, absDy) < 25) return;

                    if (absDx > absDy) {
                        this.move(dx > 0 ? 'right' : 'left');
                    } else {
                        this.move(dy > 0 ? 'down' : 'up');
                    }
                });

                // Prevent context menu on long press
                this.boardEl.addEventListener('contextmenu', e => e.preventDefault());

                // Buttons
                document.getElementById('new-game-btn').addEventListener('click', () => this.init());
                document.getElementById('play-again-btn').addEventListener('click', () => this.init());
                document.getElementById('undo-btn').addEventListener('click', () => this.undo());

                // Handle resize
                window.addEventListener('resize', () => {
                    this.updateDimensions();
                    this.render();
                });
            }
        }

        // Start game
        const game = new ThreesGame();
    </script>
</body>
</html>
