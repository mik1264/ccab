<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Polymer Chain Random Walk</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; }
.title-overlay {
    position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
    color: #fbbf24; font-size: 20px; font-weight: 600; z-index: 998;
    text-shadow: 0 0 10px rgba(251,191,36,0.5); pointer-events: none;
}
.controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 16px; align-items: center; z-index: 999;
    background: rgba(0,0,0,0.7); padding: 12px 24px; border-radius: 12px;
    border: 1px solid rgba(251,191,36,0.3); flex-wrap: wrap; justify-content: center;
}
.controls label { color: #ccc; font-size: 13px; white-space: nowrap; }
.controls input[type=range] { width: 110px; accent-color: #fbbf24; }
.controls span { color: #fbbf24; font-size: 13px; }
.controls button {
    background: rgba(251,191,36,0.2); color: #fbbf24; border: 1px solid rgba(251,191,36,0.5);
    padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 13px;
}
.controls button:hover { background: rgba(251,191,36,0.4); }
.stats-panel {
    position: fixed; top: 80px; right: 20px; z-index: 998;
    background: rgba(0,0,0,0.6); padding: 12px 16px; border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.1); color: #ccc; font-size: 12px; line-height: 1.8;
}
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">← Back to Gallery</a>
<div class="title-overlay">Polymer Chain Random Walk</div>
<div class="stats-panel" id="stats"></div>
<div class="controls">
    <label>Temperature: <input type="range" id="tempSlider" min="1" max="100" value="50"> <span id="tempVal">50</span></label>
    <label>Chain Length: <input type="range" id="lenSlider" min="10" max="80" value="30"> <span id="lenVal">30</span></label>
    <label>Chains: <input type="range" id="numSlider" min="1" max="12" value="5"> <span id="numVal">5</span></label>
    <button id="resetBtn">Reset</button>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

let temperature = 50;
let chainLength = 30;
let numChains = 5;
let chains = [];
let e2eDistances = [];

const chainColors = [
    '#ff4a6a', '#4a9eff', '#22c55e', '#fbbf24', '#a855f7',
    '#f97316', '#06b6d4', '#ec4899', '#84cc16', '#8b5cf6',
    '#14b8a6', '#f43f5e'
];

const segmentLength = 12;

class Chain {
    constructor(colorIdx) {
        this.color = chainColors[colorIdx % chainColors.length];
        this.segments = [];
        this.generateChain();
    }

    generateChain() {
        this.segments = [];
        let x = W / 2 + (Math.random() - 0.5) * W * 0.4;
        let y = H / 2 + (Math.random() - 0.5) * H * 0.3;
        this.segments.push({ x, y });

        for (let i = 1; i < chainLength; i++) {
            const angle = Math.random() * Math.PI * 2;
            x += Math.cos(angle) * segmentLength;
            y += Math.sin(angle) * segmentLength;
            x = Math.max(20, Math.min(W - 20, x));
            y = Math.max(80, Math.min(H - 100, y));
            this.segments.push({ x, y });
        }
    }

    reptate() {
        const flexibility = temperature / 50;

        // Reptation: snake-like motion along the chain contour
        if (Math.random() < 0.5) {
            // Move from tail
            this.segments.shift();
            const head = this.segments[this.segments.length - 1];
            const prev = this.segments[this.segments.length - 2];
            const baseAngle = Math.atan2(head.y - prev.y, head.x - prev.x);
            const angle = baseAngle + (Math.random() - 0.5) * Math.PI * flexibility;
            const nx = head.x + Math.cos(angle) * segmentLength;
            const ny = head.y + Math.sin(angle) * segmentLength;
            this.segments.push({
                x: Math.max(20, Math.min(W - 20, nx)),
                y: Math.max(80, Math.min(H - 100, ny))
            });
        } else {
            // Move from head
            this.segments.pop();
            const tail = this.segments[0];
            const next = this.segments[1];
            const baseAngle = Math.atan2(tail.y - next.y, tail.x - next.x);
            const angle = baseAngle + (Math.random() - 0.5) * Math.PI * flexibility;
            const nx = tail.x + Math.cos(angle) * segmentLength;
            const ny = tail.y + Math.sin(angle) * segmentLength;
            this.segments.unshift({
                x: Math.max(20, Math.min(W - 20, nx)),
                y: Math.max(80, Math.min(H - 100, ny))
            });
        }

        // Random local wiggling
        for (let i = 1; i < this.segments.length - 1; i++) {
            if (Math.random() < 0.1 * flexibility) {
                const prev = this.segments[i - 1];
                const next = this.segments[i + 1];
                const midX = (prev.x + next.x) / 2;
                const midY = (prev.y + next.y) / 2;
                const angle = Math.random() * Math.PI * 2;
                const wiggle = 3 * flexibility;
                this.segments[i].x = midX + Math.cos(angle) * wiggle;
                this.segments[i].y = midY + Math.sin(angle) * wiggle;
                this.segments[i].x = Math.max(20, Math.min(W - 20, this.segments[i].x));
                this.segments[i].y = Math.max(80, Math.min(H - 100, this.segments[i].y));
            }
        }
    }

    get endToEndDist() {
        const first = this.segments[0];
        const last = this.segments[this.segments.length - 1];
        return Math.sqrt((first.x - last.x) ** 2 + (first.y - last.y) ** 2);
    }

    get radiusOfGyration() {
        const cx = this.segments.reduce((s, p) => s + p.x, 0) / this.segments.length;
        const cy = this.segments.reduce((s, p) => s + p.y, 0) / this.segments.length;
        const rg2 = this.segments.reduce((s, p) => s + (p.x - cx) ** 2 + (p.y - cy) ** 2, 0) / this.segments.length;
        return Math.sqrt(rg2);
    }
}

function init() {
    chains = [];
    e2eDistances = [];
    for (let i = 0; i < numChains; i++) {
        chains.push(new Chain(i));
    }
}
init();

document.getElementById('tempSlider').addEventListener('input', function() {
    temperature = +this.value;
    document.getElementById('tempVal').textContent = this.value;
});
document.getElementById('lenSlider').addEventListener('input', function() {
    chainLength = +this.value;
    document.getElementById('lenVal').textContent = this.value;
    init();
});
document.getElementById('numSlider').addEventListener('input', function() {
    numChains = +this.value;
    document.getElementById('numVal').textContent = this.value;
    init();
});
document.getElementById('resetBtn').addEventListener('click', init);

let frame = 0;
function update() {
    frame++;
    for (let chain of chains) {
        chain.reptate();
    }

    // Record end-to-end distances for histogram
    if (frame % 5 === 0) {
        for (let chain of chains) {
            e2eDistances.push(chain.endToEndDist);
        }
        if (e2eDistances.length > 2000) {
            e2eDistances = e2eDistances.slice(-2000);
        }
    }
}

function drawChain(chain) {
    if (chain.segments.length < 2) return;

    // Draw chain backbone
    ctx.beginPath();
    ctx.moveTo(chain.segments[0].x, chain.segments[0].y);
    for (let i = 1; i < chain.segments.length; i++) {
        ctx.lineTo(chain.segments[i].x, chain.segments[i].y);
    }
    ctx.strokeStyle = chain.color;
    ctx.lineWidth = 3;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.stroke();

    // Draw monomers
    for (let i = 0; i < chain.segments.length; i++) {
        const s = chain.segments[i];
        ctx.beginPath();
        ctx.arc(s.x, s.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = chain.color;
        ctx.fill();
    }

    // Draw end-to-end vector
    const first = chain.segments[0];
    const last = chain.segments[chain.segments.length - 1];
    ctx.beginPath();
    ctx.moveTo(first.x, first.y);
    ctx.lineTo(last.x, last.y);
    ctx.strokeStyle = `${chain.color}55`;
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.stroke();
    ctx.setLineDash([]);

    // End markers
    ctx.beginPath();
    ctx.arc(first.x, first.y, 5, 0, Math.PI * 2);
    ctx.fillStyle = '#fff';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(last.x, last.y, 5, 0, Math.PI * 2);
    ctx.fillStyle = chain.color;
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.5;
    ctx.stroke();
}

function drawHistogram() {
    if (e2eDistances.length < 10) return;
    const gx = 20, gy = 80, gw = 220, gh = 130;

    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(gx, gy, gw, gh + 25, 10);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = '#aaa';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('End-to-End Distance Distribution', gx + gw / 2, gy + 14);

    // Create histogram bins
    const maxDist = Math.max(...e2eDistances);
    const numBins = 20;
    const binWidth = maxDist / numBins;
    const bins = new Array(numBins).fill(0);
    for (let d of e2eDistances) {
        const bin = Math.min(Math.floor(d / binWidth), numBins - 1);
        bins[bin]++;
    }
    const maxBin = Math.max(...bins);

    const barW = (gw - 20) / numBins;
    for (let i = 0; i < numBins; i++) {
        const barH = (bins[i] / maxBin) * (gh - 25);
        const x = gx + 10 + i * barW;
        const y = gy + gh - barH + 5;
        ctx.fillStyle = `hsla(${40 + i * 5}, 80%, 60%, 0.7)`;
        ctx.fillRect(x, y, barW - 1, barH);
    }

    // Gaussian overlay
    const mean = e2eDistances.reduce((a, b) => a + b, 0) / e2eDistances.length;
    const variance = e2eDistances.reduce((s, d) => s + (d - mean) ** 2, 0) / e2eDistances.length;
    const std = Math.sqrt(variance);
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(251,191,36,0.6)';
    ctx.lineWidth = 2;
    for (let i = 0; i <= gw - 20; i++) {
        const d = (i / (gw - 20)) * maxDist;
        const g = Math.exp(-0.5 * ((d - mean) / std) ** 2);
        const y = gy + gh + 5 - g * (gh - 25);
        const x = gx + 10 + i;
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();

    ctx.fillStyle = '#888';
    ctx.font = '9px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`<R> = ${mean.toFixed(1)} px`, gx + 10, gy + gh + 20);
    ctx.fillText(`σ = ${std.toFixed(1)}`, gx + 120, gy + gh + 20);
}

function draw() {
    ctx.fillStyle = 'rgba(10, 14, 26, 0.3)';
    ctx.fillRect(0, 0, W, H);

    for (let chain of chains) drawChain(chain);

    drawHistogram();

    // Stats panel
    const avgE2E = chains.reduce((s, c) => s + c.endToEndDist, 0) / chains.length;
    const avgRg = chains.reduce((s, c) => s + c.radiusOfGyration, 0) / chains.length;
    const theoreticalE2E = segmentLength * Math.sqrt(chainLength);

    document.getElementById('stats').innerHTML =
        `<div style="color:#fbbf24;font-weight:bold;margin-bottom:4px;">Chain Statistics</div>
         Avg End-to-End: ${avgE2E.toFixed(1)} px<br>
         Theory (√N × l): ${theoreticalE2E.toFixed(1)} px<br>
         Avg Rg: ${avgRg.toFixed(1)} px<br>
         Monomers/chain: ${chainLength}<br>
         Segment length: ${segmentLength} px<br>
         Samples: ${e2eDistances.length}`;
}

function animate() {
    update();
    draw();
    requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
