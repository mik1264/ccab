<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPaxos Fast/Slow Paths</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #c9a227;
            text-decoration: none;
            font-size: 14px;
            opacity: 0.8;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .back-link:hover {
            opacity: 1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 60px 20px 20px;
        }

        h1 {
            text-align: center;
            font-size: 2rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #c9a227, #e0c068);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
            font-size: 0.95rem;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }

        .visualization-area {
            display: grid;
            grid-template-rows: 1fr 1fr;
            gap: 20px;
        }

        .panel {
            background: rgba(20, 20, 35, 0.8);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(201, 162, 39, 0.2);
            backdrop-filter: blur(10px);
        }

        .panel-title {
            font-size: 1rem;
            color: #c9a227;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .path-badge {
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .fast-badge {
            background: rgba(39, 174, 96, 0.3);
            color: #27ae60;
        }

        .slow-badge {
            background: rgba(231, 76, 60, 0.3);
            color: #e74c3c;
        }

        .controls-panel {
            height: fit-content;
        }

        .section-title {
            font-size: 0.85rem;
            color: #c9a227;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #c9a227, #b8941f);
            color: #0a0a0f;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(201, 162, 39, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #27ae60, #219a52);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        canvas {
            width: 100%;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #c9a227;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
        }

        .info-box {
            background: rgba(201, 162, 39, 0.1);
            border: 1px solid rgba(201, 162, 39, 0.3);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.8rem;
            color: #ccc;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .replica-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .replica-node {
            aspect-ratio: 1;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .replica-node:hover {
            transform: scale(1.1);
        }

        .replica-node.active {
            background: linear-gradient(135deg, #27ae60, #219a52);
            color: white;
        }

        .replica-node.coordinator {
            border-color: #c9a227;
            box-shadow: 0 0 10px rgba(201, 162, 39, 0.5);
        }

        .replica-node.inactive {
            background: rgba(255, 255, 255, 0.1);
            color: #666;
        }

        .instance-list {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
        }

        .instance-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            margin-bottom: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            font-size: 0.8rem;
        }

        .instance-cmd {
            color: #3498db;
            font-weight: 500;
        }

        .instance-status {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
        }

        .status-preaccepted {
            background: rgba(52, 152, 219, 0.2);
            color: #3498db;
        }

        .status-accepted {
            background: rgba(243, 156, 18, 0.2);
            color: #f39c12;
        }

        .status-committed {
            background: rgba(39, 174, 96, 0.2);
            color: #27ae60;
        }

        .status-executed {
            background: rgba(155, 89, 182, 0.2);
            color: #9b59b6;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: #aaa;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
        }

        @media (max-width: 1000px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="container">
        <h1>EPaxos Fast/Slow Paths</h1>
        <p class="subtitle">Egalitarian Paxos: leaderless consensus with dependency graphs</p>

        <div class="main-layout">
            <div class="visualization-area">
                <div class="panel">
                    <div class="panel-title">
                        Replica Communication
                        <span class="path-badge fast-badge" id="pathBadge">FAST PATH</span>
                    </div>
                    <canvas id="replicaCanvas"></canvas>
                </div>
                <div class="panel">
                    <div class="panel-title">Dependency Graph</div>
                    <canvas id="depCanvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #3498db;"></div>
                            <span>PreAccept</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #f39c12;"></div>
                            <span>Accept</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #27ae60;"></div>
                            <span>Commit</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #9b59b6;"></div>
                            <span>Dependency</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel controls-panel">
                <div class="info-box">
                    <strong>EPaxos</strong> is a leaderless consensus protocol.
                    Commands commit in <strong>1 round trip</strong> (fast path) when there are no conflicts,
                    or <strong>2 round trips</strong> (slow path) when dependencies conflict.
                </div>

                <div class="section-title">Submit Command</div>
                <div class="replica-grid" id="replicaGrid">
                </div>
                <p style="font-size: 0.75rem; color: #888; margin-bottom: 15px;">Click a replica to submit command</p>

                <div class="btn-group">
                    <button class="btn btn-success" onclick="submitNonConflicting()">Non-Conflicting Command</button>
                    <button class="btn btn-danger" onclick="submitConflicting()">Conflicting Command</button>
                    <button class="btn btn-secondary" onclick="executeReady()">Execute Ready Commands</button>
                </div>

                <div class="section-title">Simulation</div>
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="toggleAuto()">Auto: <span id="autoStatus">OFF</span></button>
                    <button class="btn btn-secondary" onclick="resetSim()">Reset</button>
                </div>

                <div class="section-title">Statistics</div>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-value" id="fastCount">0</div>
                        <div class="stat-label">Fast Path</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="slowCount">0</div>
                        <div class="stat-label">Slow Path</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="committed">0</div>
                        <div class="stat-label">Committed</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="executed">0</div>
                        <div class="stat-label">Executed</div>
                    </div>
                </div>

                <div class="section-title">Instances</div>
                <div class="instance-list" id="instanceList">
                </div>
            </div>
        </div>
    </div>

    <script>
        const replicaCanvas = document.getElementById('replicaCanvas');
        const depCanvas = document.getElementById('depCanvas');
        const rctx = replicaCanvas.getContext('2d');
        const dctx = depCanvas.getContext('2d');

        const NUM_REPLICAS = 5;
        const FAST_QUORUM = 4; // F + floor(F/2) + 1 where F=2
        const SLOW_QUORUM = 3; // F + 1

        let state = {
            replicas: [],
            instances: [],
            messages: [],
            fastCount: 0,
            slowCount: 0,
            committed: 0,
            executed: 0,
            time: 0,
            autoMode: false,
            cmdCounter: 0,
            selectedReplica: 0
        };

        // Instance states
        const PREACCEPTED = 'preaccepted';
        const ACCEPTED = 'accepted';
        const COMMITTED = 'committed';
        const EXECUTED = 'executed';

        function resizeCanvases() {
            [replicaCanvas, depCanvas].forEach(canvas => {
                const rect = canvas.parentElement.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                canvas.width = (rect.width - 40) * dpr;
                canvas.height = 200 * dpr;
                canvas.style.height = '200px';
                canvas.getContext('2d').scale(dpr, dpr);
            });
        }
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        // Initialize replicas
        function initReplicas() {
            state.replicas = [];
            const width = replicaCanvas.width / (window.devicePixelRatio || 1);
            const height = replicaCanvas.height / (window.devicePixelRatio || 1);
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.35;

            for (let i = 0; i < NUM_REPLICAS; i++) {
                const angle = (i / NUM_REPLICAS) * Math.PI * 2 - Math.PI / 2;
                state.replicas.push({
                    id: i,
                    name: `R${i + 1}`,
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius,
                    instances: new Map() // instanceId -> local state
                });
            }

            updateReplicaGrid();
        }

        function updateReplicaGrid() {
            const grid = document.getElementById('replicaGrid');
            grid.innerHTML = state.replicas.map((r, i) => `
                <div class="replica-node active ${i === state.selectedReplica ? 'coordinator' : ''}"
                     onclick="selectReplica(${i})">${r.name}</div>
            `).join('');
        }

        function selectReplica(idx) {
            state.selectedReplica = idx;
            updateReplicaGrid();
        }

        // Create a new instance
        function createInstance(coordinatorId, cmd, conflictsWith = []) {
            const instance = {
                id: `${coordinatorId}.${state.cmdCounter++}`,
                cmd: cmd,
                coordinator: coordinatorId,
                status: PREACCEPTED,
                seq: state.instances.length + 1,
                deps: [...conflictsWith],
                preAcceptOKs: new Set([coordinatorId]),
                acceptOKs: new Set([coordinatorId]),
                usedFastPath: true,
                x: 0,
                y: 0
            };

            // Position for dependency graph
            const col = state.instances.length % 6;
            const row = Math.floor(state.instances.length / 6);
            instance.x = 50 + col * 80;
            instance.y = 40 + row * 50;

            state.instances.push(instance);
            state.replicas[coordinatorId].instances.set(instance.id, { ...instance });

            return instance;
        }

        // Message class
        class Message {
            constructor(type, from, to, data) {
                this.type = type;
                this.from = from;
                this.to = to;
                this.data = data;
                this.startTime = state.time;
                this.duration = 25 + Math.random() * 15;
                this.progress = 0;
            }
        }

        // Submit non-conflicting command
        function submitNonConflicting() {
            const coordinator = state.selectedReplica;
            const cmd = `Set(x${state.cmdCounter})`;
            const instance = createInstance(coordinator, cmd);

            // Send PreAccept to all replicas
            state.replicas.forEach((r, i) => {
                if (i !== coordinator) {
                    state.messages.push(new Message('preaccept', coordinator, i, {
                        instanceId: instance.id,
                        cmd: cmd,
                        seq: instance.seq,
                        deps: instance.deps,
                        conflicting: false
                    }));
                }
            });

            updateUI();
        }

        // Submit conflicting command
        function submitConflicting() {
            const coordinator = state.selectedReplica;
            const cmd = `Set(key)`;  // Same key = conflict

            // Find previous instances that conflict
            const conflicts = state.instances
                .filter(inst => inst.cmd.includes('key') && inst.id !== null)
                .slice(-2)
                .map(inst => inst.id);

            const instance = createInstance(coordinator, cmd, conflicts);

            // Send PreAccept with conflicting flag
            state.replicas.forEach((r, i) => {
                if (i !== coordinator) {
                    state.messages.push(new Message('preaccept', coordinator, i, {
                        instanceId: instance.id,
                        cmd: cmd,
                        seq: instance.seq,
                        deps: instance.deps,
                        conflicting: true
                    }));
                }
            });

            updateUI();
        }

        // Process messages
        function processMessages() {
            const toRemove = [];

            state.messages.forEach((msg, idx) => {
                msg.progress += 1 / msg.duration;

                if (msg.progress >= 1) {
                    toRemove.push(idx);
                    handleMessage(msg);
                }
            });

            for (let i = toRemove.length - 1; i >= 0; i--) {
                state.messages.splice(toRemove[i], 1);
            }
        }

        function handleMessage(msg) {
            const instance = state.instances.find(i => i.id === msg.data.instanceId);
            if (!instance) return;

            switch (msg.type) {
                case 'preaccept':
                    // Backup receives PreAccept
                    const localDeps = [...msg.data.deps];

                    // If conflicting, backup might add different deps
                    if (msg.data.conflicting && Math.random() < 0.4) {
                        // Simulate seeing different deps
                        const extraDep = state.instances[Math.floor(Math.random() * state.instances.length)];
                        if (extraDep && !localDeps.includes(extraDep.id)) {
                            localDeps.push(extraDep.id);
                        }
                    }

                    // Store local state
                    state.replicas[msg.to].instances.set(instance.id, {
                        ...msg.data,
                        deps: localDeps
                    });

                    // Send PreAcceptOK
                    state.messages.push(new Message('preacceptok', msg.to, msg.from, {
                        instanceId: instance.id,
                        deps: localDeps,
                        seq: msg.data.seq
                    }));
                    break;

                case 'preacceptok':
                    instance.preAcceptOKs.add(msg.from);
                    const localState = state.replicas[msg.from].instances.get(instance.id);

                    // Check for dep conflicts
                    if (localState && JSON.stringify(localState.deps) !== JSON.stringify(instance.deps)) {
                        instance.usedFastPath = false;
                        // Merge deps
                        localState.deps.forEach(d => {
                            if (!instance.deps.includes(d)) {
                                instance.deps.push(d);
                            }
                        });
                    }

                    // Check if we have enough responses
                    if (instance.status === PREACCEPTED) {
                        if (instance.usedFastPath && instance.preAcceptOKs.size >= FAST_QUORUM) {
                            // Fast path - commit directly
                            instance.status = COMMITTED;
                            state.fastCount++;
                            state.committed++;
                            broadcastCommit(instance);
                            document.getElementById('pathBadge').textContent = 'FAST PATH';
                            document.getElementById('pathBadge').className = 'path-badge fast-badge';
                        } else if (!instance.usedFastPath && instance.preAcceptOKs.size >= SLOW_QUORUM) {
                            // Need slow path - go to Accept phase
                            instance.status = ACCEPTED;
                            broadcastAccept(instance);
                            document.getElementById('pathBadge').textContent = 'SLOW PATH';
                            document.getElementById('pathBadge').className = 'path-badge slow-badge';
                        }
                    }
                    break;

                case 'accept':
                    // Update local deps with merged version
                    state.replicas[msg.to].instances.set(instance.id, {
                        ...msg.data
                    });

                    state.messages.push(new Message('acceptok', msg.to, msg.from, {
                        instanceId: instance.id
                    }));
                    break;

                case 'acceptok':
                    instance.acceptOKs.add(msg.from);
                    if (instance.status === ACCEPTED && instance.acceptOKs.size >= SLOW_QUORUM) {
                        instance.status = COMMITTED;
                        state.slowCount++;
                        state.committed++;
                        broadcastCommit(instance);
                    }
                    break;

                case 'commit':
                    state.replicas[msg.to].instances.set(instance.id, {
                        ...msg.data,
                        status: COMMITTED
                    });
                    break;
            }

            updateUI();
        }

        function broadcastAccept(instance) {
            state.replicas.forEach((r, i) => {
                if (i !== instance.coordinator) {
                    state.messages.push(new Message('accept', instance.coordinator, i, {
                        instanceId: instance.id,
                        cmd: instance.cmd,
                        seq: instance.seq,
                        deps: instance.deps
                    }));
                }
            });
        }

        function broadcastCommit(instance) {
            state.replicas.forEach((r, i) => {
                if (i !== instance.coordinator) {
                    state.messages.push(new Message('commit', instance.coordinator, i, {
                        instanceId: instance.id,
                        cmd: instance.cmd,
                        seq: instance.seq,
                        deps: instance.deps
                    }));
                }
            });
        }

        // Execute ready commands
        function executeReady() {
            // Find committed instances with all deps committed
            const ready = state.instances.filter(inst => {
                if (inst.status !== COMMITTED) return false;
                return inst.deps.every(depId => {
                    const dep = state.instances.find(i => i.id === depId);
                    return !dep || dep.status === EXECUTED;
                });
            });

            // Sort by seq and execute
            ready.sort((a, b) => a.seq - b.seq);
            ready.forEach(inst => {
                inst.status = EXECUTED;
                state.executed++;
            });

            updateUI();
        }

        // Auto mode
        let autoInterval = null;
        function toggleAuto() {
            state.autoMode = !state.autoMode;
            document.getElementById('autoStatus').textContent = state.autoMode ? 'ON' : 'OFF';

            if (state.autoMode) {
                autoInterval = setInterval(() => {
                    if (Math.random() < 0.7) {
                        submitNonConflicting();
                    } else {
                        submitConflicting();
                    }

                    if (state.instances.filter(i => i.status === COMMITTED).length >= 3) {
                        executeReady();
                    }
                }, 1200);
            } else {
                clearInterval(autoInterval);
            }
        }

        // Reset
        function resetSim() {
            if (autoInterval) clearInterval(autoInterval);
            state = {
                replicas: [],
                instances: [],
                messages: [],
                fastCount: 0,
                slowCount: 0,
                committed: 0,
                executed: 0,
                time: 0,
                autoMode: false,
                cmdCounter: 0,
                selectedReplica: 0
            };
            document.getElementById('autoStatus').textContent = 'OFF';
            initReplicas();
            updateUI();
        }

        // Update UI
        function updateUI() {
            document.getElementById('fastCount').textContent = state.fastCount;
            document.getElementById('slowCount').textContent = state.slowCount;
            document.getElementById('committed').textContent = state.committed;
            document.getElementById('executed').textContent = state.executed;

            // Update instance list
            const list = document.getElementById('instanceList');
            list.innerHTML = state.instances.slice(-10).reverse().map(inst => `
                <div class="instance-item">
                    <span class="instance-cmd">${inst.cmd}</span>
                    <span class="instance-status status-${inst.status}">${inst.status}</span>
                </div>
            `).join('');
        }

        // Draw replica communication
        function drawReplicas() {
            const width = replicaCanvas.width / (window.devicePixelRatio || 1);
            const height = replicaCanvas.height / (window.devicePixelRatio || 1);

            rctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            rctx.fillRect(0, 0, width, height);

            // Draw connections between replicas
            rctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            rctx.lineWidth = 1;
            for (let i = 0; i < NUM_REPLICAS; i++) {
                for (let j = i + 1; j < NUM_REPLICAS; j++) {
                    rctx.beginPath();
                    rctx.moveTo(state.replicas[i].x, state.replicas[i].y);
                    rctx.lineTo(state.replicas[j].x, state.replicas[j].y);
                    rctx.stroke();
                }
            }

            // Draw messages
            state.messages.forEach(msg => {
                const from = state.replicas[msg.from];
                const to = state.replicas[msg.to];
                const x = from.x + (to.x - from.x) * msg.progress;
                const y = from.y + (to.y - from.y) * msg.progress;

                // Message line
                rctx.beginPath();
                rctx.moveTo(from.x, from.y);
                rctx.lineTo(x, y);
                rctx.strokeStyle = msg.type.includes('preaccept') ? '#3498db' :
                                  msg.type.includes('accept') ? '#f39c12' :
                                  '#27ae60';
                rctx.lineWidth = 2;
                rctx.stroke();

                // Message dot
                rctx.beginPath();
                rctx.arc(x, y, 5, 0, Math.PI * 2);
                rctx.fillStyle = rctx.strokeStyle;
                rctx.fill();
            });

            // Draw replicas
            state.replicas.forEach((r, i) => {
                rctx.beginPath();
                rctx.arc(r.x, r.y, 25, 0, Math.PI * 2);
                rctx.fillStyle = i === state.selectedReplica ? '#c9a227' : '#27ae60';
                rctx.fill();

                rctx.font = 'bold 14px Segoe UI';
                rctx.fillStyle = 'white';
                rctx.textAlign = 'center';
                rctx.textBaseline = 'middle';
                rctx.fillText(r.name, r.x, r.y);
            });
        }

        // Draw dependency graph
        function drawDependencies() {
            const width = depCanvas.width / (window.devicePixelRatio || 1);
            const height = depCanvas.height / (window.devicePixelRatio || 1);

            dctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            dctx.fillRect(0, 0, width, height);

            if (state.instances.length === 0) {
                dctx.font = '14px Segoe UI';
                dctx.fillStyle = '#666';
                dctx.textAlign = 'center';
                dctx.fillText('Submit commands to see dependency graph', width / 2, height / 2);
                return;
            }

            // Draw dependency edges
            state.instances.forEach(inst => {
                inst.deps.forEach(depId => {
                    const dep = state.instances.find(i => i.id === depId);
                    if (dep) {
                        dctx.beginPath();
                        dctx.moveTo(inst.x, inst.y);
                        dctx.lineTo(dep.x, dep.y);
                        dctx.strokeStyle = '#9b59b6';
                        dctx.lineWidth = 2;
                        dctx.stroke();

                        // Arrowhead
                        const angle = Math.atan2(dep.y - inst.y, dep.x - inst.x);
                        const midX = (inst.x + dep.x) / 2;
                        const midY = (inst.y + dep.y) / 2;
                        dctx.beginPath();
                        dctx.moveTo(midX, midY);
                        dctx.lineTo(midX - 8 * Math.cos(angle - 0.5), midY - 8 * Math.sin(angle - 0.5));
                        dctx.lineTo(midX - 8 * Math.cos(angle + 0.5), midY - 8 * Math.sin(angle + 0.5));
                        dctx.closePath();
                        dctx.fillStyle = '#9b59b6';
                        dctx.fill();
                    }
                });
            });

            // Draw instance nodes
            state.instances.forEach(inst => {
                const color = inst.status === EXECUTED ? '#9b59b6' :
                             inst.status === COMMITTED ? '#27ae60' :
                             inst.status === ACCEPTED ? '#f39c12' : '#3498db';

                dctx.beginPath();
                dctx.arc(inst.x, inst.y, 18, 0, Math.PI * 2);
                dctx.fillStyle = color;
                dctx.fill();

                // Instance label
                dctx.font = 'bold 10px Segoe UI';
                dctx.fillStyle = 'white';
                dctx.textAlign = 'center';
                dctx.textBaseline = 'middle';
                dctx.fillText(inst.id.split('.')[1], inst.x, inst.y);
            });
        }

        // Animation loop
        function animate() {
            state.time++;
            processMessages();
            drawReplicas();
            drawDependencies();
            requestAnimationFrame(animate);
        }

        // Expose functions for enhance.js keyboard shortcuts
        window.reset = function() { initReplicas(); updateUI(); };

        // Initialize
        initReplicas();
        updateUI();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
