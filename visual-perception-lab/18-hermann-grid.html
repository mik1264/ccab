<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hermann Grid & Scintillating Grid</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #111; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
#controls {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
  padding: 18px 24px; border-radius: 14px; color: #ccd; z-index: 100;
  display: flex; flex-wrap: wrap; gap: 14px; align-items: center; max-width: 800px;
  border: 1px solid rgba(255,255,255,0.08);
}
#controls label { font-size: 0.82em; display: flex; align-items: center; gap: 6px; }
#controls input[type=range] { width: 90px; accent-color: #8af; }
button {
  background: rgba(100,140,255,0.2); color: #8af; border: 1px solid rgba(100,140,255,0.3);
  padding: 6px 14px; border-radius: 8px; cursor: pointer; font-size: 0.85em;
}
button:hover { background: rgba(100,140,255,0.35); }
button.active { background: rgba(100,255,140,0.2); color: #8fa; border-color: rgba(100,255,140,0.3); }
#info {
  position: fixed; top: 20px; right: 20px; background: rgba(20,20,40,0.85);
  backdrop-filter: blur(10px); padding: 16px 20px; border-radius: 12px;
  color: #aab; font-size: 0.82em; max-width: 320px; z-index: 100; line-height: 1.5;
  border: 1px solid rgba(255,255,255,0.08);
}
#info strong { color: #dde; }
#fixation {
  position: fixed; top: 65px; left: 50%; transform: translateX(-50%);
  color: rgba(180,200,255,0.6); font-size: 0.9em; z-index: 50;
  text-align: center; pointer-events: none;
}
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>

<div id="fixation">Look at the cross below. Count the dark dots you see at intersections.<br>Now look directly at one intersection -- the dot vanishes!</div>

<div id="info">
  <strong>Hermann Grid</strong><br><br>
  Gray <em>ghost dots</em> appear at intersections of the white lines -- but vanish when you look directly at them!<br><br>
  <strong>Lateral inhibition</strong> in retinal ganglion cells creates this effect. Each cell's receptive field is inhibited more at intersections (4 bright lines meeting) than along edges (2 bright lines), creating a darker signal at intersections in your periphery.
</div>

<div id="controls">
  <label>Grid <input type="range" id="gridSize" min="3" max="12" value="7"> <span id="gridSizeVal">7</span>&times;<span id="gridSizeVal2">7</span></label>
  <label>Square <input type="range" id="sqSize" min="30" max="120" value="70"> <span id="sqSizeVal">70</span>px</label>
  <label>Gap <input type="range" id="gapSize" min="4" max="30" value="12"> <span id="gapSizeVal">12</span>px</label>
  <label>Curve <input type="range" id="curveAmt" min="0" max="20" value="0"> <span id="curveAmtVal">0</span></label>
  <button id="modeHermann" class="active">Hermann</button>
  <button id="modeScint">Scintillating</button>
  <button id="colorClassic" class="active">Classic</button>
  <button id="colorInvert">Inverted</button>
  <button id="colorColored">Colored</button>
  <button id="resetBtn">Reset</button>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

let gridSize = 7;
let sqSize = 70;
let gapSize = 12;
let curveAmt = 0;
let mode = 'hermann'; // 'hermann' or 'scintillating'
let colorScheme = 'classic'; // 'classic', 'invert', 'colored'
let animId;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}

function getColors() {
  switch (colorScheme) {
    case 'classic':
      return { bg: '#ffffff', sq: '#000000', dot: '#ffffff', line: '#ffffff' };
    case 'invert':
      return { bg: '#000000', sq: '#ffffff', dot: '#000000', line: '#000000' };
    case 'colored':
      return { bg: '#2a3a5a', sq: '#1a1a3a', dot: '#6af', line: '#2a3a5a' };
    default:
      return { bg: '#ffffff', sq: '#000000', dot: '#ffffff', line: '#ffffff' };
  }
}

function draw() {
  const colors = getColors();

  // Background matches lines for scintillating mode
  if (mode === 'scintillating') {
    ctx.fillStyle = '#808080';
  } else {
    ctx.fillStyle = colors.bg;
  }
  ctx.fillRect(0, 0, W, H);

  const totalW = gridSize * sqSize + (gridSize + 1) * gapSize;
  const totalH = gridSize * sqSize + (gridSize + 1) * gapSize;
  const ox = (W - totalW) / 2;
  const oy = (H - totalH) / 2;

  if (mode === 'scintillating') {
    // Scintillating grid: gray background, dark squares, white dots at intersections
    // Draw gray lines (background is already gray)
    // Draw black squares
    for (let r = 0; r < gridSize; r++) {
      for (let c = 0; c < gridSize; c++) {
        const x = ox + gapSize + c * (sqSize + gapSize);
        const y = oy + gapSize + r * (sqSize + gapSize);

        if (curveAmt > 0) {
          drawCurvedSquare(x, y, sqSize, sqSize, curveAmt, '#000000');
        } else {
          ctx.fillStyle = '#000000';
          ctx.fillRect(x, y, sqSize, sqSize);
        }
      }
    }

    // Draw white dots at intersections
    for (let r = 0; r <= gridSize; r++) {
      for (let c = 0; c <= gridSize; c++) {
        const x = ox + c * (sqSize + gapSize) + gapSize / 2;
        const y = oy + r * (sqSize + gapSize) + gapSize / 2;

        if (curveAmt > 0) {
          const wobbleX = Math.sin(r * 0.5 + c * 0.3) * curveAmt * 0.5;
          const wobbleY = Math.cos(r * 0.3 + c * 0.5) * curveAmt * 0.5;
          ctx.beginPath();
          ctx.arc(x + wobbleX, y + wobbleY, gapSize * 0.35, 0, Math.PI * 2);
        } else {
          ctx.beginPath();
          ctx.arc(x, y, gapSize * 0.35, 0, Math.PI * 2);
        }
        ctx.fillStyle = '#ffffff';
        ctx.fill();
      }
    }
  } else {
    // Hermann grid: colored squares with line-colored gaps
    for (let r = 0; r < gridSize; r++) {
      for (let c = 0; c < gridSize; c++) {
        const x = ox + gapSize + c * (sqSize + gapSize);
        const y = oy + gapSize + r * (sqSize + gapSize);

        if (curveAmt > 0) {
          drawCurvedSquare(x, y, sqSize, sqSize, curveAmt, colors.sq);
        } else {
          ctx.fillStyle = colors.sq;
          ctx.fillRect(x, y, sqSize, sqSize);
        }
      }
    }
  }

  // Draw fixation cross in center
  const cx = W / 2;
  const cy = H / 2;
  ctx.strokeStyle = mode === 'scintillating' ? '#ff6666' : (colorScheme === 'invert' ? '#f44' : '#f44');
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(cx - 12, cy);
  ctx.lineTo(cx + 12, cy);
  ctx.moveTo(cx, cy - 12);
  ctx.lineTo(cx, cy + 12);
  ctx.stroke();

  // Show curve hint
  if (curveAmt > 0) {
    ctx.font = '14px sans-serif';
    ctx.fillStyle = 'rgba(255,100,100,0.7)';
    ctx.textAlign = 'center';
    ctx.fillText('Curved lines reduce the illusion!', cx, oy - 15);
  }

  animId = requestAnimationFrame(draw);
}

function drawCurvedSquare(x, y, w, h, curve, color) {
  // Draw a square with slightly wavy edges to break the illusion
  ctx.fillStyle = color;
  ctx.beginPath();

  const steps = 20;
  // Top edge
  ctx.moveTo(x, y);
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const px = x + t * w;
    const py = y + Math.sin(t * Math.PI * 2) * curve * 0.3;
    ctx.lineTo(px, py);
  }
  // Right edge
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const px = x + w + Math.sin(t * Math.PI * 2) * curve * 0.3;
    const py = y + t * h;
    ctx.lineTo(px, py);
  }
  // Bottom edge
  for (let i = steps; i >= 0; i--) {
    const t = i / steps;
    const px = x + t * w;
    const py = y + h + Math.sin(t * Math.PI * 2 + 1) * curve * 0.3;
    ctx.lineTo(px, py);
  }
  // Left edge
  for (let i = steps; i >= 0; i--) {
    const t = i / steps;
    const px = x + Math.sin(t * Math.PI * 2 + 1) * curve * 0.3;
    const py = y + t * h;
    ctx.lineTo(px, py);
  }

  ctx.closePath();
  ctx.fill();
}

// Controls
function bindSlider(id, valId, cb) {
  const el = document.getElementById(id);
  const v = document.getElementById(valId);
  el.addEventListener('input', () => { v.textContent = el.value; cb(parseInt(el.value)); });
}

bindSlider('gridSize', 'gridSizeVal', v => {
  gridSize = v;
  document.getElementById('gridSizeVal2').textContent = v;
});
bindSlider('sqSize', 'sqSizeVal', v => { sqSize = v; });
bindSlider('gapSize', 'gapSizeVal', v => { gapSize = v; });
bindSlider('curveAmt', 'curveAmtVal', v => { curveAmt = v; });

document.getElementById('modeHermann').addEventListener('click', () => {
  mode = 'hermann';
  document.getElementById('modeHermann').classList.add('active');
  document.getElementById('modeScint').classList.remove('active');
});
document.getElementById('modeScint').addEventListener('click', () => {
  mode = 'scintillating';
  document.getElementById('modeScint').classList.add('active');
  document.getElementById('modeHermann').classList.remove('active');
});

function setColorScheme(scheme) {
  colorScheme = scheme;
  ['colorClassic','colorInvert','colorColored'].forEach(id => {
    document.getElementById(id).classList.remove('active');
  });
  document.getElementById('color' + scheme.charAt(0).toUpperCase() + scheme.slice(1)).classList.add('active');
}

document.getElementById('colorClassic').addEventListener('click', () => setColorScheme('classic'));
document.getElementById('colorInvert').addEventListener('click', () => setColorScheme('invert'));
document.getElementById('colorColored').addEventListener('click', () => setColorScheme('colored'));

document.getElementById('resetBtn').addEventListener('click', () => window.reset());

window.reset = function() {
  gridSize = 7; sqSize = 70; gapSize = 12; curveAmt = 0;
  mode = 'hermann'; colorScheme = 'classic';
  document.getElementById('gridSize').value = 7;
  document.getElementById('gridSizeVal').textContent = '7';
  document.getElementById('gridSizeVal2').textContent = '7';
  document.getElementById('sqSize').value = 70;
  document.getElementById('sqSizeVal').textContent = '70';
  document.getElementById('gapSize').value = 12;
  document.getElementById('gapSizeVal').textContent = '12';
  document.getElementById('curveAmt').value = 0;
  document.getElementById('curveAmtVal').textContent = '0';
  document.getElementById('modeHermann').classList.add('active');
  document.getElementById('modeScint').classList.remove('active');
  setColorScheme('classic');
};

let resizeTimer;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(resize, 150);
});

resize();
draw();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>