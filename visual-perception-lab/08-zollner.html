<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ZÃ¶llner Illusion</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #fafafa; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
#controls {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(30,30,40,0.85); backdrop-filter: blur(10px);
  padding: 16px 24px; border-radius: 14px; color: #ddd; z-index: 100;
  min-width: 380px; max-width: 520px;
}
#controls h3 { text-align: center; margin-bottom: 8px; color: #8af; font-size: 0.95em; }
.row { display: flex; align-items: center; justify-content: space-between; margin: 4px 0; font-size: 0.82em; }
.row label { flex: 0 0 140px; }
.row input[type=range] { flex: 1; margin: 0 8px; }
.row span { flex: 0 0 48px; text-align: right; }
button {
  background: #335; border: 1px solid #557; color: #aaf; padding: 6px 14px;
  border-radius: 6px; cursor: pointer; font-size: 0.82em; margin: 2px;
}
button:hover { background: #446; }
button.active { background: #448; border-color: #88f; }
#info {
  position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(30,30,40,0.85); backdrop-filter: blur(10px);
  padding: 10px 20px; border-radius: 10px; color: #ccc; z-index: 100;
  font-size: 0.78em; max-width: 640px; text-align: center; line-height: 1.4;
}
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>
<div id="info">The long lines are perfectly PARALLEL, but the short diagonal crossings create an illusion of convergence and divergence.</div>
<div id="controls">
  <h3>Z&ouml;llner Illusion &amp; Related Effects</h3>
  <div class="row"><label>Diagonal Angle</label><input type="range" id="diagAngle" min="5" max="85" value="35"><span id="diagAngleV">35&deg;</span></div>
  <div class="row"><label>Diagonal Spacing</label><input type="range" id="diagSpace" min="8" max="40" value="16"><span id="diagSpaceV">16</span></div>
  <div class="row"><label>Diagonal Length</label><input type="range" id="diagLen" min="8" max="50" value="22"><span id="diagLenV">22</span></div>
  <div class="row"><label>Number of Lines</label><input type="range" id="numLines" min="3" max="12" value="7"><span id="numLinesV">7</span></div>
  <div class="row"><label>Line Spacing</label><input type="range" id="lineSpace" min="30" max="100" value="55"><span id="lineSpaceV">55</span></div>
  <div style="display:flex;justify-content:center;gap:5px;margin-top:8px;flex-wrap:wrap">
    <button id="btnZollner" class="active">Z&ouml;llner</button>
    <button id="btnHering">Hering</button>
    <button id="btnWundt">Wundt</button>
  </div>
  <div style="display:flex;justify-content:center;gap:5px;margin-top:5px;flex-wrap:wrap">
    <button id="btnReveal">Show Guides</button>
    <button id="btnHide">Hide Diagonals</button>
    <button id="btnAnimate">Animate</button>
    <button id="btnReset">Reset</button>
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;
let mode = 'zollner';
let showGuides = false;
let hideDiags = false;
let animating = false;
let animPhase = 0;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function val(id) { return +document.getElementById(id).value; }

['diagAngle','diagSpace','diagLen','numLines','lineSpace'].forEach(id => {
  document.getElementById(id).addEventListener('input', () => {
    const v = val(id);
    document.getElementById(id + 'V').textContent = id === 'diagAngle' ? v + '\u00B0' : v;
  });
});

function drawZollner() {
  let angle = val('diagAngle');
  const spacing = val('diagSpace');
  const dLen = val('diagLen');
  const numL = val('numLines');
  const lSpace = val('lineSpace');

  if (animating) {
    animPhase += 0.008;
    angle = 10 + (Math.sin(animPhase) + 1) / 2 * 70;
    document.getElementById('diagAngle').value = Math.round(angle);
    document.getElementById('diagAngleV').textContent = Math.round(angle) + '\u00B0';
  }

  const totalH = (numL - 1) * lSpace;
  const startY = (H - totalH) / 2;
  const margin = 80;
  const lineLen = W - margin * 2;
  const angleRad = angle * Math.PI / 180;

  for (let i = 0; i < numL; i++) {
    const y = startY + i * lSpace;
    const dir = i % 2 === 0 ? 1 : -1;

    // Main parallel line
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(margin, y);
    ctx.lineTo(W - margin, y);
    ctx.stroke();

    // Diagonals
    if (!hideDiags) {
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 1.2;
      const numD = Math.floor(lineLen / spacing);
      for (let j = 0; j <= numD; j++) {
        const x = margin + j * spacing;
        const dx = Math.cos(angleRad) * dLen;
        const dy = Math.sin(angleRad) * dLen * dir;
        ctx.beginPath();
        ctx.moveTo(x - dx, y - dy);
        ctx.lineTo(x + dx, y + dy);
        ctx.stroke();
      }
    }

    // Guide lines
    if (showGuides) {
      ctx.strokeStyle = 'rgba(255,60,60,0.5)';
      ctx.lineWidth = 1;
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      ctx.moveTo(margin - 20, y);
      ctx.lineTo(W - margin + 20, y);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }
}

function drawHering() {
  const numL = val('numLines');
  const lSpace = val('lineSpace');
  const totalH = (numL - 1) * lSpace;
  const startY = (H - totalH) / 2;
  const margin = 80;
  const cx = W / 2;
  const cy = H / 2;

  // Radial lines (the inducing pattern)
  if (!hideDiags) {
    const numRadial = 24;
    ctx.strokeStyle = '#aaa';
    ctx.lineWidth = 1;
    for (let i = 0; i < numRadial; i++) {
      const angle = (i / numRadial) * Math.PI;
      const dx = Math.cos(angle) * W;
      const dy = Math.sin(angle) * W;
      ctx.beginPath();
      ctx.moveTo(cx - dx, cy - dy);
      ctx.lineTo(cx + dx, cy + dy);
      ctx.stroke();
    }
  }

  // Parallel horizontal lines
  for (let i = 0; i < numL; i++) {
    const y = startY + i * lSpace;
    ctx.strokeStyle = '#d32';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(margin, y);
    ctx.lineTo(W - margin, y);
    ctx.stroke();

    if (showGuides) {
      ctx.strokeStyle = 'rgba(0,100,255,0.4)';
      ctx.lineWidth = 1;
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      ctx.moveTo(margin - 20, y);
      ctx.lineTo(W - margin + 20, y);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  ctx.fillStyle = '#555';
  ctx.font = '13px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('The red lines appear to bow OUTWARD, but they are perfectly straight', cx, H - 200);
}

function drawWundt() {
  const numL = val('numLines');
  const lSpace = val('lineSpace');
  const totalH = (numL - 1) * lSpace;
  const startY = (H - totalH) / 2;
  const margin = 80;
  const cx = W / 2;
  const cy = H / 2;

  // Radial lines from two side vanishing points
  if (!hideDiags) {
    const numRadial = 20;
    ctx.strokeStyle = '#aaa';
    ctx.lineWidth = 1;
    for (let i = 0; i < numRadial; i++) {
      const angle = -Math.PI / 3 + (i / numRadial) * (2 * Math.PI / 3);
      // From left
      ctx.beginPath();
      ctx.moveTo(margin - 40, cy);
      ctx.lineTo(margin - 40 + Math.cos(angle) * W, cy + Math.sin(angle) * W);
      ctx.stroke();
      // From right
      ctx.beginPath();
      ctx.moveTo(W - margin + 40, cy);
      ctx.lineTo(W - margin + 40 - Math.cos(angle) * W, cy + Math.sin(angle) * W);
      ctx.stroke();
    }
  }

  // Parallel horizontal lines
  for (let i = 0; i < numL; i++) {
    const y = startY + i * lSpace;
    ctx.strokeStyle = '#28a';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(margin, y);
    ctx.lineTo(W - margin, y);
    ctx.stroke();

    if (showGuides) {
      ctx.strokeStyle = 'rgba(255,100,0,0.4)';
      ctx.lineWidth = 1;
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      ctx.moveTo(margin - 20, y);
      ctx.lineTo(W - margin + 20, y);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  ctx.fillStyle = '#555';
  ctx.font = '13px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('The blue lines appear to bow INWARD, but they are perfectly straight (opposite of Hering)', cx, H - 200);
}

function draw() {
  ctx.fillStyle = '#fafafa';
  ctx.fillRect(0, 0, W, H);

  if (mode === 'zollner') drawZollner();
  else if (mode === 'hering') drawHering();
  else if (mode === 'wundt') drawWundt();

  requestAnimationFrame(draw);
}

['btnZollner','btnHering','btnWundt'].forEach(id => {
  document.getElementById(id).addEventListener('click', function() {
    mode = id.replace('btn','').toLowerCase();
    document.querySelectorAll('#controls button').forEach(b => b.classList.remove('active'));
    this.classList.add('active');
    // Re-activate toggle states
    if (showGuides) document.getElementById('btnReveal').classList.add('active');
    if (hideDiags) document.getElementById('btnHide').classList.add('active');
    if (animating) document.getElementById('btnAnimate').classList.add('active');
    // Update info text
    const info = document.getElementById('info');
    if (mode === 'zollner') info.textContent = 'The long lines are perfectly PARALLEL, but the short diagonal crossings create an illusion of convergence and divergence.';
    else if (mode === 'hering') info.textContent = 'Hering Illusion: Straight parallel lines appear to bow OUTWARD when superimposed on a radial pattern.';
    else info.textContent = 'Wundt Illusion: Straight parallel lines appear to bow INWARD. The opposite of the Hering illusion.';
  });
});

document.getElementById('btnReveal').addEventListener('click', function() {
  showGuides = !showGuides;
  this.classList.toggle('active', showGuides);
});
document.getElementById('btnHide').addEventListener('click', function() {
  hideDiags = !hideDiags;
  this.classList.toggle('active', hideDiags);
});
document.getElementById('btnAnimate').addEventListener('click', function() {
  animating = !animating;
  animPhase = 0;
  this.classList.toggle('active', animating);
});
document.getElementById('btnReset').addEventListener('click', function() { window.reset(); });

window.reset = function() {
  mode = 'zollner';
  showGuides = false;
  hideDiags = false;
  animating = false;
  animPhase = 0;
  document.getElementById('diagAngle').value = 35;
  document.getElementById('diagSpace').value = 16;
  document.getElementById('diagLen').value = 22;
  document.getElementById('numLines').value = 7;
  document.getElementById('lineSpace').value = 55;
  ['diagAngleV','diagSpaceV','diagLenV','numLinesV','lineSpaceV'].forEach(id => {
    const baseId = id.replace('V','');
    document.getElementById(id).textContent = baseId === 'diagAngle' ? val(baseId) + '\u00B0' : val(baseId);
  });
  document.querySelectorAll('#controls button').forEach(b => b.classList.remove('active'));
  document.getElementById('btnZollner').classList.add('active');
  document.getElementById('info').textContent = 'The long lines are perfectly PARALLEL, but the short diagonal crossings create an illusion of convergence and divergence.';
};

draw();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
