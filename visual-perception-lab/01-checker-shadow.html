<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Checker Shadow Illusion</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a2e; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
#controls {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
  padding: 18px 24px; border-radius: 14px; color: #ccd; z-index: 100;
  display: flex; flex-wrap: wrap; gap: 14px; align-items: center; max-width: 700px;
  border: 1px solid rgba(255,255,255,0.08);
}
#controls label { font-size: 0.85em; display: flex; align-items: center; gap: 6px; }
#controls input[type=range] { width: 100px; accent-color: #8af; }
button {
  background: rgba(100,140,255,0.2); color: #8af; border: 1px solid rgba(100,140,255,0.3);
  padding: 6px 14px; border-radius: 8px; cursor: pointer; font-size: 0.85em;
}
button:hover { background: rgba(100,140,255,0.35); }
button.active { background: rgba(100,255,140,0.2); color: #8fa; border-color: rgba(100,255,140,0.3); }
#info {
  position: fixed; top: 20px; right: 20px; background: rgba(20,20,40,0.85);
  backdrop-filter: blur(10px); padding: 16px 20px; border-radius: 12px;
  color: #aab; font-size: 0.82em; max-width: 300px; z-index: 100; line-height: 1.5;
  border: 1px solid rgba(255,255,255,0.08);
}
#info strong { color: #dde; }
#rgb-display {
  position: fixed; top: 50%; right: 20px; transform: translateY(-50%);
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
  padding: 14px 18px; border-radius: 12px; color: #ccd; font-size: 0.85em;
  z-index: 100; border: 1px solid rgba(255,255,255,0.08);
}
.swatch { display: inline-block; width: 30px; height: 30px; border-radius: 4px; vertical-align: middle; margin: 0 6px; border: 2px solid #555; }
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>

<div id="info">
  <strong>Checker Shadow Illusion</strong><br><br>
  Squares A and B are the <em>exact same shade of gray</em>.
  Your brain compensates for the cylinder's shadow, making square B appear lighter than it really is.<br><br>
  <strong>Adelson (1995)</strong> demonstrated that lightness perception depends on context, not raw pixel values.
</div>

<div id="rgb-display">
  <div>Square A: <span class="swatch" id="swatchA"></span> <span id="rgbA"></span></div>
  <div style="margin-top:8px">Square B: <span class="swatch" id="swatchB"></span> <span id="rgbB"></span></div>
  <div style="margin-top:8px;color:#8fa;font-size:0.9em" id="matchMsg">Both are identical!</div>
</div>

<div id="controls">
  <label>Shadow strength <input type="range" id="shadowStr" min="0" max="100" value="65"></label>
  <button id="btnReveal">Show Bar</button>
  <button id="btnShadow">Remove Shadow</button>
  <button id="btnReset">Reset</button>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

const TARGET_GRAY = 120;
let shadowStrength = 0.65;
let showBar = false;
let showShadow = true;
let shadowFade = 1;
let animatingFade = false;

const BOARD_SIZE = 8;
let cellSize, boardX, boardY;
const SQ_A = { row: 3, col: 3 };
const SQ_B = { row: 5, col: 1 };

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  cellSize = Math.min(W, H) * 0.08;
  boardX = W / 2 - (BOARD_SIZE * cellSize) / 2;
  boardY = H / 2 - (BOARD_SIZE * cellSize) / 2 - 20;
}

function drawBoard() {
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, W, H);

  // Draw perspective floor hint
  ctx.save();
  ctx.fillStyle = '#222240';
  ctx.beginPath();
  ctx.moveTo(boardX - 30, boardY + BOARD_SIZE * cellSize + 10);
  ctx.lineTo(boardX + BOARD_SIZE * cellSize + 30, boardY + BOARD_SIZE * cellSize + 10);
  ctx.lineTo(boardX + BOARD_SIZE * cellSize + 50, boardY + BOARD_SIZE * cellSize + 60);
  ctx.lineTo(boardX - 50, boardY + BOARD_SIZE * cellSize + 60);
  ctx.fill();
  ctx.restore();

  const shadowDark = shadowStrength * shadowFade;

  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      const isLight = (r + c) % 2 === 0;
      let baseGray = isLight ? 200 : 90;

      // Shadow region: elliptical area around cylinder
      const cx = boardX + (SQ_B.col + 0.5) * cellSize;
      const cy = boardY + (SQ_B.row - 0.5) * cellSize;
      const sqCx = boardX + (c + 0.5) * cellSize;
      const sqCy = boardY + (r + 0.5) * cellSize;
      const dx = (sqCx - cx) / (cellSize * 2.5);
      const dy = (sqCy - cy) / (cellSize * 3);
      const dist = Math.sqrt(dx * dx + dy * dy);

      let shadowMult = 1;
      if (dist < 1) {
        shadowMult = 1 - shadowDark * (1 - dist) * 0.7;
      }

      // Special squares: force to TARGET_GRAY before shadow
      const isA = r === SQ_A.row && c === SQ_A.col;
      const isB = r === SQ_B.row && c === SQ_B.col;

      let finalGray;
      if (isA) {
        finalGray = TARGET_GRAY;
      } else if (isB) {
        // B is in shadow; we want it to render as TARGET_GRAY after shadow
        // So its "pre-shadow" value must compensate
        finalGray = showShadow ? TARGET_GRAY : TARGET_GRAY;
        // Actually we paint it as TARGET_GRAY directly, the shadow overlay handles context
      } else {
        finalGray = Math.round(baseGray * shadowMult);
      }

      if (isA || isB) {
        finalGray = TARGET_GRAY;
      }

      ctx.fillStyle = `rgb(${finalGray},${finalGray},${finalGray})`;
      ctx.fillRect(boardX + c * cellSize, boardY + r * cellSize, cellSize, cellSize);
    }
  }

  // Shadow overlay (not on target squares, but around them for context)
  if (showShadow && shadowFade > 0.01) {
    const cx = boardX + (SQ_B.col + 0.5) * cellSize;
    const cy = boardY + (SQ_B.row - 0.5) * cellSize;
    const radius = cellSize * 3;

    ctx.save();
    // Don't shadow the target squares themselves
    for (let r = 0; r < BOARD_SIZE; r++) {
      for (let c = 0; c < BOARD_SIZE; c++) {
        if ((r === SQ_A.row && c === SQ_A.col) || (r === SQ_B.row && c === SQ_B.col)) continue;
        const sqCx = boardX + (c + 0.5) * cellSize;
        const sqCy = boardY + (r + 0.5) * cellSize;
        const dx = (sqCx - cx) / (cellSize * 2.5);
        const dy = (sqCy - cy) / (cellSize * 3);
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 1) {
          const alpha = shadowDark * (1 - dist) * 0.7;
          ctx.fillStyle = `rgba(0,0,0,${alpha})`;
          ctx.fillRect(boardX + c * cellSize, boardY + r * cellSize, cellSize, cellSize);
        }
      }
    }
    ctx.restore();
  }

  // Draw cylinder
  if (showShadow && shadowFade > 0.5) {
    const cylX = boardX + (SQ_B.col + 0.5) * cellSize;
    const cylBottom = boardY + (SQ_B.row - 1) * cellSize;
    const cylW = cellSize * 0.7;
    const cylH = cellSize * 2.2;
    const cylTop = cylBottom - cylH;

    // Cylinder body
    const grad = ctx.createLinearGradient(cylX - cylW, 0, cylX + cylW, 0);
    grad.addColorStop(0, 'rgba(60,60,80,0.95)');
    grad.addColorStop(0.3, 'rgba(120,120,150,0.95)');
    grad.addColorStop(0.7, 'rgba(80,80,100,0.95)');
    grad.addColorStop(1, 'rgba(40,40,60,0.95)');
    ctx.fillStyle = grad;
    ctx.fillRect(cylX - cylW, cylTop, cylW * 2, cylH);

    // Cylinder top (ellipse)
    ctx.beginPath();
    ctx.ellipse(cylX, cylTop, cylW, cellSize * 0.25, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(140,140,170,0.95)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(80,80,100,0.5)';
    ctx.stroke();

    // Cylinder bottom ellipse
    ctx.beginPath();
    ctx.ellipse(cylX, cylBottom, cylW, cellSize * 0.25, 0, 0, Math.PI);
    ctx.fillStyle = 'rgba(50,50,70,0.95)';
    ctx.fill();
  }

  // Mark squares A and B
  const markSquare = (sq, label) => {
    const x = boardX + sq.col * cellSize;
    const y = boardY + sq.row * cellSize;
    ctx.strokeStyle = '#ff6b6b';
    ctx.lineWidth = 3;
    ctx.strokeRect(x + 3, y + 3, cellSize - 6, cellSize - 6);
    ctx.fillStyle = '#ff6b6b';
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(label, x + cellSize / 2, y + cellSize / 2 + 5);
  };
  markSquare(SQ_A, 'A');
  markSquare(SQ_B, 'B');

  // Connecting bar reveal
  if (showBar) {
    const ax = boardX + (SQ_A.col + 0.5) * cellSize;
    const ay = boardY + (SQ_A.row + 0.5) * cellSize;
    const bx = boardX + (SQ_B.col + 0.5) * cellSize;
    const by = boardY + (SQ_B.row + 0.5) * cellSize;

    ctx.fillStyle = `rgb(${TARGET_GRAY},${TARGET_GRAY},${TARGET_GRAY})`;
    ctx.strokeStyle = `rgb(${TARGET_GRAY},${TARGET_GRAY},${TARGET_GRAY})`;
    ctx.lineWidth = cellSize * 0.4;
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.lineTo(bx, by);
    ctx.stroke();

    // Label on bar
    const midX = (ax + bx) / 2;
    const midY = (ay + by) / 2;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 13px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`rgb(${TARGET_GRAY},${TARGET_GRAY},${TARGET_GRAY})`, midX, midY - 20);
  }

  // Update swatch display
  const gray = `rgb(${TARGET_GRAY},${TARGET_GRAY},${TARGET_GRAY})`;
  document.getElementById('swatchA').style.background = gray;
  document.getElementById('swatchB').style.background = gray;
  document.getElementById('rgbA').textContent = gray;
  document.getElementById('rgbB').textContent = gray;
}

function animate() {
  if (animatingFade) {
    if (!showShadow && shadowFade > 0) {
      shadowFade = Math.max(0, shadowFade - 0.03);
      if (shadowFade <= 0) animatingFade = false;
    } else if (showShadow && shadowFade < 1) {
      shadowFade = Math.min(1, shadowFade + 0.03);
      if (shadowFade >= 1) animatingFade = false;
    }
  }
  drawBoard();
  requestAnimationFrame(animate);
}

// Controls
document.getElementById('shadowStr').addEventListener('input', (e) => {
  shadowStrength = e.target.value / 100;
});

document.getElementById('btnReveal').addEventListener('click', function() {
  showBar = !showBar;
  this.textContent = showBar ? 'Hide Bar' : 'Show Bar';
  this.classList.toggle('active', showBar);
});

document.getElementById('btnShadow').addEventListener('click', function() {
  showShadow = !showShadow;
  animatingFade = true;
  this.textContent = showShadow ? 'Remove Shadow' : 'Restore Shadow';
  this.classList.toggle('active', !showShadow);
});

document.getElementById('btnReset').addEventListener('click', reset);

function reset() {
  shadowStrength = 0.65;
  showBar = false;
  showShadow = true;
  shadowFade = 1;
  animatingFade = false;
  document.getElementById('shadowStr').value = 65;
  document.getElementById('btnReveal').textContent = 'Show Bar';
  document.getElementById('btnReveal').classList.remove('active');
  document.getElementById('btnShadow').textContent = 'Remove Shadow';
  document.getElementById('btnShadow').classList.remove('active');
}
window.reset = reset;

window.addEventListener('resize', resize);
resize();
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
