<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Impossible Objects</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a2e; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
#controls {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(20,20,35,0.9); backdrop-filter: blur(10px);
  padding: 16px 24px; border-radius: 14px; color: #ddd; z-index: 100;
  min-width: 380px; max-width: 520px;
}
#controls h3 { text-align: center; margin-bottom: 8px; color: #8af; font-size: 0.95em; }
.row { display: flex; align-items: center; justify-content: space-between; margin: 4px 0; font-size: 0.82em; }
.row label { flex: 0 0 110px; }
.row input[type=range] { flex: 1; margin: 0 8px; }
.row span { flex: 0 0 48px; text-align: right; }
button {
  background: #2a2a45; border: 1px solid #445; color: #aaf; padding: 6px 14px;
  border-radius: 6px; cursor: pointer; font-size: 0.82em; margin: 2px;
}
button:hover { background: #3a3a55; }
button.active { background: #3a3a60; border-color: #88f; }
#info {
  position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(20,20,35,0.9); backdrop-filter: blur(10px);
  padding: 10px 20px; border-radius: 10px; color: #bbb; z-index: 100;
  font-size: 0.78em; max-width: 640px; text-align: center; line-height: 1.4;
}
#objName {
  position: fixed; top: 70px; left: 50%; transform: translateX(-50%);
  color: #8af; font-size: 1.1em; z-index: 100; font-weight: bold;
}
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>
<div id="info">These objects exploit our brain's 3D interpretation of 2D images. Each local corner is valid in 3D, but they are globally contradictory.</div>
<div id="objName">Penrose Triangle</div>
<div id="controls">
  <h3>Impossible Objects</h3>
  <div class="row"><label>Rotation</label><input type="range" id="rotSlider" min="0" max="360" value="0"><span id="rotV">0&deg;</span></div>
  <div class="row"><label>Scale</label><input type="range" id="scaleSlider" min="50" max="200" value="100"><span id="scaleV">100%</span></div>
  <div style="display:flex;justify-content:center;gap:5px;margin-top:8px;flex-wrap:wrap">
    <button id="btnTribar" class="active">Penrose Triangle</button>
    <button id="btnStairs">Penrose Stairs</button>
  </div>
  <div style="display:flex;justify-content:center;gap:5px;margin-top:4px;flex-wrap:wrap">
    <button id="btnBlivet">Blivet</button>
    <button id="btnCube">Impossible Cube</button>
  </div>
  <div style="display:flex;justify-content:center;gap:5px;margin-top:8px;flex-wrap:wrap">
    <button id="btnAutoRotate">Auto-Rotate</button>
    <button id="btnReset">Reset</button>
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;
let currentObj = 'tribar';
let autoRotate = false;
let rotAngle = 0;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function val(id) { return +document.getElementById(id).value; }

document.getElementById('rotSlider').addEventListener('input', () => {
  document.getElementById('rotV').textContent = val('rotSlider') + '\u00B0';
});
document.getElementById('scaleSlider').addEventListener('input', () => {
  document.getElementById('scaleV').textContent = val('scaleSlider') + '%';
});

function drawPenroseTriangle(cx, cy, size, rot) {
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(rot);
  const s = size;
  const t = s * 0.18; // bar thickness
  const h = s * Math.sqrt(3) / 2;
  // Three corners of equilateral triangle
  const ax = 0, ay = -h * 0.6;
  const bx = -s / 2, by = h * 0.4;
  const cx2 = s / 2, cy2 = h * 0.4;

  // Draw three beams with impossible overlap
  // Colors for three faces
  const colors = ['#4488cc', '#55aadd', '#3366aa'];
  const dark = ['#2a5588', '#3388aa', '#224488'];

  // Beam 1: top-left to bottom
  drawBeam(ax, ay, bx, by, t, colors[0], dark[0]);
  // Beam 2: bottom-left to top-right
  drawBeam(bx, by, cx2, cy2, t, colors[1], dark[1]);
  // Beam 3: top-right to top-left (this is the impossible one)
  drawBeam(cx2, cy2, ax, ay, t, colors[2], dark[2]);

  // Impossible junction patch at bottom-left
  ctx.fillStyle = colors[1];
  ctx.beginPath();
  ctx.moveTo(bx - t * 0.5, by + t * 0.6);
  ctx.lineTo(bx + t * 1.2, by + t * 0.6);
  ctx.lineTo(bx + t * 0.4, by - t * 0.6);
  ctx.lineTo(bx - t * 1.0, by - t * 0.6);
  ctx.closePath();
  ctx.fill();

  // Impossible junction patch at top
  ctx.fillStyle = colors[2];
  ctx.beginPath();
  ctx.moveTo(ax - t * 0.8, ay - t * 0.3);
  ctx.lineTo(ax + t * 0.8, ay - t * 0.3);
  ctx.lineTo(ax + t * 0.3, ay + t * 0.7);
  ctx.lineTo(ax - t * 0.3, ay + t * 0.7);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

function drawBeam(x1, y1, x2, y2, t, color, darkColor) {
  const angle = Math.atan2(y2 - y1, x2 - x1);
  const px = Math.cos(angle + Math.PI / 2) * t;
  const py = Math.sin(angle + Math.PI / 2) * t;

  // Light face
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(x1 - px, y1 - py);
  ctx.lineTo(x2 - px, y2 - py);
  ctx.lineTo(x2 + px, y2 + py);
  ctx.lineTo(x1 + px, y1 + py);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = '#1a1a2e';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Dark edge
  ctx.fillStyle = darkColor;
  ctx.beginPath();
  ctx.moveTo(x1 + px, y1 + py);
  ctx.lineTo(x2 + px, y2 + py);
  ctx.lineTo(x2 + px * 0.5, y2 + py + t * 0.3);
  ctx.lineTo(x1 + px * 0.5, y1 + py + t * 0.3);
  ctx.closePath();
  ctx.fill();
}

function drawPenroseStairs(cx, cy, size) {
  ctx.save();
  ctx.translate(cx, cy);
  const s = size * 0.4;
  const steps = 10;
  const colors = ['#cc7744', '#dd9966', '#bb6633', '#aa5522'];

  // Draw isometric staircase that loops forever
  // Top surface of the platform
  ctx.fillStyle = '#ddb888';
  ctx.strokeStyle = '#1a1a2e';
  ctx.lineWidth = 1.5;

  // Four sides of the stepped square
  for (let side = 0; side < 4; side++) {
    ctx.save();
    ctx.rotate(side * Math.PI / 2);
    const stepsPerSide = Math.floor(steps / 4);
    const stepW = s * 2 / stepsPerSide;
    const stepH = s * 0.12;

    for (let i = 0; i < stepsPerSide; i++) {
      const x = -s + i * stepW;
      const y = -s - i * stepH;
      const isoX = (x - y) * 0.7;
      const isoY = (x + y) * 0.35;

      // Step top
      ctx.fillStyle = colors[side];
      ctx.beginPath();
      ctx.moveTo(isoX, isoY);
      ctx.lineTo(isoX + stepW * 0.7, isoY + stepW * 0.35);
      ctx.lineTo(isoX + stepW * 1.4, isoY);
      ctx.lineTo(isoX + stepW * 0.7, isoY - stepW * 0.35);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Step front
      ctx.fillStyle = colors[(side + 2) % 4];
      ctx.beginPath();
      ctx.moveTo(isoX, isoY);
      ctx.lineTo(isoX + stepW * 0.7, isoY + stepW * 0.35);
      ctx.lineTo(isoX + stepW * 0.7, isoY + stepW * 0.35 + stepH);
      ctx.lineTo(isoX, isoY + stepH);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }
    ctx.restore();
  }

  // Draw arrows to show "always ascending"
  ctx.strokeStyle = '#ff6';
  ctx.lineWidth = 2;
  ctx.setLineDash([4, 4]);
  const arrowR = s * 0.6;
  ctx.beginPath();
  ctx.arc(0, 0, arrowR, 0, Math.PI * 1.8);
  ctx.stroke();
  ctx.setLineDash([]);
  // Arrowhead
  const ax = Math.cos(Math.PI * 1.8) * arrowR;
  const ay = Math.sin(Math.PI * 1.8) * arrowR;
  ctx.fillStyle = '#ff6';
  ctx.beginPath();
  ctx.moveTo(ax + 8, ay - 4);
  ctx.lineTo(ax, ay + 8);
  ctx.lineTo(ax - 6, ay - 6);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = '#ff6';
  ctx.font = '11px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Always ascending!', 0, arrowR + 20);

  ctx.restore();
}

function drawBlivet(cx, cy, size) {
  ctx.save();
  ctx.translate(cx, cy);
  const w = size * 1.3;
  const h = size * 0.5;
  const prongt = size * 0.06;
  const prongGap = size * 0.14;

  ctx.strokeStyle = '#88bbee';
  ctx.lineWidth = 2;
  ctx.fillStyle = '#334466';

  // Three prongs on the left that merge into two on the right
  // Top prong
  ctx.fillStyle = '#4488aa';
  ctx.fillRect(-w / 2, -prongGap - prongt, w * 0.55, prongt * 2);
  ctx.strokeRect(-w / 2, -prongGap - prongt, w * 0.55, prongt * 2);

  // Middle prong
  ctx.fillStyle = '#55aacc';
  ctx.fillRect(-w / 2, -prongt, w * 0.55, prongt * 2);
  ctx.strokeRect(-w / 2, -prongt, w * 0.55, prongt * 2);

  // Bottom prong
  ctx.fillStyle = '#4488aa';
  ctx.fillRect(-w / 2, prongGap - prongt, w * 0.55, prongt * 2);
  ctx.strokeRect(-w / 2, prongGap - prongt, w * 0.55, prongt * 2);

  // Right side: two rectangular beams
  // The impossible part - three prongs connect into two channels
  const rStart = -w / 2 + w * 0.45;
  const rEnd = w / 2;

  // Top beam (connects top and middle prongs - impossible!)
  ctx.fillStyle = '#3a6688';
  ctx.beginPath();
  ctx.moveTo(rStart, -prongGap - prongt);
  ctx.lineTo(rEnd, -prongGap - prongt);
  ctx.lineTo(rEnd, -prongt);
  ctx.lineTo(rStart, prongt);
  ctx.lineTo(rStart, -prongGap - prongt);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Bottom beam (connects middle and bottom prongs - impossible!)
  ctx.fillStyle = '#3a7799';
  ctx.beginPath();
  ctx.moveTo(rStart, -prongt);
  ctx.lineTo(rEnd, prongt);
  ctx.lineTo(rEnd, prongGap + prongt);
  ctx.lineTo(rStart, prongGap + prongt);
  ctx.lineTo(rStart, -prongt);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Rounded ends on left
  for (let i = -1; i <= 1; i++) {
    const py = i * prongGap;
    ctx.fillStyle = i === 0 ? '#55aacc' : '#4488aa';
    ctx.beginPath();
    ctx.arc(-w / 2, py, prongt, Math.PI / 2, -Math.PI / 2);
    ctx.fill();
    ctx.stroke();
  }

  ctx.restore();
}

function drawImpossibleCube(cx, cy, size, rot) {
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(rot * 0.3);
  const s = size * 0.4;
  const off = s * 0.35;

  ctx.lineWidth = 3;
  ctx.lineCap = 'round';

  // Back face
  ctx.strokeStyle = '#6688aa';
  ctx.beginPath();
  ctx.moveTo(-s + off, -s + off);
  ctx.lineTo(s + off, -s + off);
  ctx.lineTo(s + off, s + off);
  ctx.lineTo(-s + off, s + off);
  ctx.closePath();
  ctx.stroke();

  // Front face
  ctx.strokeStyle = '#88aadd';
  ctx.beginPath();
  ctx.moveTo(-s, -s);
  ctx.lineTo(s, -s);
  ctx.lineTo(s, s);
  ctx.lineTo(-s, s);
  ctx.closePath();
  ctx.stroke();

  // Connecting edges - but with impossible crossings!
  ctx.lineWidth = 3;

  // Top-left: back over front (normal)
  ctx.strokeStyle = '#6688aa';
  ctx.beginPath();
  ctx.moveTo(-s, -s);
  ctx.lineTo(-s + off, -s + off);
  ctx.stroke();

  // Top-right: front over back (impossible!)
  ctx.strokeStyle = '#88aadd';
  drawEdgeWithBreak(s, -s, s + off, -s + off, s + off * 0.5, -s + off * 0.5, 8);

  // Bottom-right: back over front (normal)
  ctx.strokeStyle = '#6688aa';
  ctx.beginPath();
  ctx.moveTo(s, s);
  ctx.lineTo(s + off, s + off);
  ctx.stroke();

  // Bottom-left: front over back (impossible!)
  ctx.strokeStyle = '#88aadd';
  drawEdgeWithBreak(-s, s, -s + off, s + off, -s + off * 0.5, s + off * 0.5, 8);

  ctx.restore();
}

function drawEdgeWithBreak(x1, y1, x2, y2, bx, by, gap) {
  const angle = Math.atan2(y2 - y1, x2 - x1);
  const len = Math.hypot(x2 - x1, y2 - y1);
  const dx = Math.cos(angle);
  const dy = Math.sin(angle);
  const mid = len / 2;

  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x1 + dx * (mid - gap), y1 + dy * (mid - gap));
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x1 + dx * (mid + gap), y1 + dy * (mid + gap));
  ctx.lineTo(x2, y2);
  ctx.stroke();
}

const objNames = {
  tribar: 'Penrose Triangle (Tribar)',
  stairs: 'Penrose Stairs (Escher Staircase)',
  blivet: "Blivet / Devil's Fork",
  cube: 'Impossible Cube'
};

function draw() {
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, W, H);

  const cx = W / 2;
  const cy = H / 2;
  const scale = val('scaleSlider') / 100;
  const size = Math.min(W, H) * 0.3 * scale;

  if (autoRotate) {
    rotAngle += 0.005;
    document.getElementById('rotSlider').value = Math.round((rotAngle * 180 / Math.PI) % 360);
    document.getElementById('rotV').textContent = Math.round((rotAngle * 180 / Math.PI) % 360) + '\u00B0';
  } else {
    rotAngle = val('rotSlider') * Math.PI / 180;
  }

  ctx.save();
  if (currentObj === 'tribar') {
    drawPenroseTriangle(cx, cy, size, rotAngle);
  } else if (currentObj === 'stairs') {
    ctx.translate(0, 0);
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(rotAngle);
    ctx.translate(-cx, -cy);
    drawPenroseStairs(cx, cy, size);
    ctx.restore();
  } else if (currentObj === 'blivet') {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(rotAngle);
    ctx.translate(-cx, -cy);
    drawBlivet(cx, cy, size);
    ctx.restore();
  } else if (currentObj === 'cube') {
    drawImpossibleCube(cx, cy, size, rotAngle);
  }
  ctx.restore();

  document.getElementById('objName').textContent = objNames[currentObj];

  requestAnimationFrame(draw);
}

['btnTribar','btnStairs','btnBlivet','btnCube'].forEach(id => {
  document.getElementById(id).addEventListener('click', function() {
    currentObj = id.replace('btn','').toLowerCase();
    document.querySelectorAll('#controls button').forEach(b => b.classList.remove('active'));
    this.classList.add('active');
    if (autoRotate) document.getElementById('btnAutoRotate').classList.add('active');
  });
});

document.getElementById('btnAutoRotate').addEventListener('click', function() {
  autoRotate = !autoRotate;
  this.classList.toggle('active', autoRotate);
});

document.getElementById('btnReset').addEventListener('click', function() { window.reset(); });

// Mouse drag rotation
let dragStart = null;
canvas.addEventListener('mousedown', e => { dragStart = { x: e.clientX, rot: val('rotSlider') }; });
canvas.addEventListener('mousemove', e => {
  if (!dragStart || autoRotate) return;
  const dx = e.clientX - dragStart.x;
  const newRot = (dragStart.rot + dx * 0.5 + 360) % 360;
  document.getElementById('rotSlider').value = Math.round(newRot);
  document.getElementById('rotV').textContent = Math.round(newRot) + '\u00B0';
});
canvas.addEventListener('mouseup', () => { dragStart = null; });

window.reset = function() {
  currentObj = 'tribar';
  autoRotate = false;
  rotAngle = 0;
  document.getElementById('rotSlider').value = 0;
  document.getElementById('rotV').textContent = '0\u00B0';
  document.getElementById('scaleSlider').value = 100;
  document.getElementById('scaleV').textContent = '100%';
  document.querySelectorAll('#controls button').forEach(b => b.classList.remove('active'));
  document.getElementById('btnTribar').classList.add('active');
};

draw();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
