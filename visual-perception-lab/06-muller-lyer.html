<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Müller-Lyer Illusion</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #f5f5f5; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
#controls {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(30,30,40,0.85); backdrop-filter: blur(10px);
  padding: 16px 24px; border-radius: 14px; color: #ddd; z-index: 100;
  min-width: 360px; max-width: 500px;
}
#controls h3 { text-align: center; margin-bottom: 8px; color: #8af; font-size: 0.95em; }
.row { display: flex; align-items: center; justify-content: space-between; margin: 5px 0; font-size: 0.82em; }
.row label { flex: 0 0 120px; }
.row input[type=range] { flex: 1; margin: 0 8px; }
.row span { flex: 0 0 42px; text-align: right; }
button {
  background: #335; border: 1px solid #557; color: #aaf; padding: 6px 14px;
  border-radius: 6px; cursor: pointer; font-size: 0.82em; margin: 2px;
}
button:hover { background: #446; }
button.active { background: #448; border-color: #88f; }
#stats {
  position: fixed; top: 20px; right: 20px; background: rgba(30,30,40,0.85);
  backdrop-filter: blur(10px); padding: 12px 18px; border-radius: 10px;
  color: #ddd; z-index: 100; font-size: 0.82em; min-width: 180px;
}
#stats h4 { color: #8af; margin-bottom: 6px; }
#info {
  position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(30,30,40,0.85); backdrop-filter: blur(10px);
  padding: 10px 20px; border-radius: 10px; color: #ccc; z-index: 100;
  font-size: 0.78em; max-width: 600px; text-align: center; line-height: 1.4;
}
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>
<div id="info">Drag the right line's endpoint to match the left line's length, then click "Submit Guess". The Müller-Lyer illusion makes identical lines appear different lengths.</div>
<div id="stats">
  <h4>Trial Results</h4>
  <div id="trialNum">Trial: 1</div>
  <div id="avgError">Avg Error: --</div>
  <div id="lastError">Last Error: --</div>
  <div id="totalTrials">Completed: 0</div>
</div>
<div id="controls">
  <h3>Müller-Lyer Illusion</h3>
  <div class="row"><label>Fin Angle</label><input type="range" id="finAngle" min="10" max="80" value="40"><span id="finAngleV">40°</span></div>
  <div class="row"><label>Fin Length</label><input type="range" id="finLen" min="15" max="80" value="45"><span id="finLenV">45</span></div>
  <div class="row"><label>Line Thickness</label><input type="range" id="thick" min="2" max="8" value="3"><span id="thickV">3</span></div>
  <div style="display:flex;justify-content:center;gap:6px;margin-top:8px;flex-wrap:wrap">
    <button id="btnSubmit">Submit Guess</button>
    <button id="btnReveal">Reveal</button>
    <button id="btnReset">New Trial</button>
    <button id="btnContext">3D Context</button>
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;
const sliders = { finAngle: 'finAngleV', finLen: 'finLenV', thick: 'thickV' };

let trueLength = 200;
let userLength = 200;
let dragging = false;
let revealed = false;
let showContext = false;
let trials = [];
let trialConfig = 0;

const configs = [
  { finAngle: 40, finLen: 45 },
  { finAngle: 30, finLen: 60 },
  { finAngle: 55, finLen: 35 },
  { finAngle: 25, finLen: 70 },
  { finAngle: 50, finLen: 50 },
];

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function val(id) { return +document.getElementById(id).value; }
function updateSliderLabels() {
  document.getElementById('finAngleV').textContent = val('finAngle') + '°';
  document.getElementById('finLenV').textContent = val('finLen');
  document.getElementById('thickV').textContent = val('thick');
}
Object.keys(sliders).forEach(id => {
  document.getElementById(id).addEventListener('input', updateSliderLabels);
});

function drawArrowLine(cx, cy, length, finAngle, finLen, finDir, thickness, color) {
  const halfLen = length / 2;
  const x1 = cx - halfLen;
  const x2 = cx + halfLen;
  const angleRad = finAngle * Math.PI / 180;
  ctx.strokeStyle = color;
  ctx.lineWidth = thickness;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(x1, cy);
  ctx.lineTo(x2, cy);
  ctx.stroke();
  // Draw fins
  const dirs = finDir === 'inward' ? [1, -1] : [-1, 1];
  // Left end fins
  const ldx = Math.cos(angleRad) * finLen * dirs[0];
  const ldy = Math.sin(angleRad) * finLen;
  ctx.beginPath();
  ctx.moveTo(x1 + ldx, cy - ldy); ctx.lineTo(x1, cy); ctx.lineTo(x1 + ldx, cy + ldy);
  ctx.stroke();
  // Right end fins
  const rdx = Math.cos(angleRad) * finLen * dirs[1];
  const rdy = Math.sin(angleRad) * finLen;
  ctx.beginPath();
  ctx.moveTo(x2 + rdx, cy - rdy); ctx.lineTo(x2, cy); ctx.lineTo(x2 + rdx, cy + rdy);
  ctx.stroke();
}

function drawRuler(cx, cy, length, color) {
  const halfLen = length / 2;
  const x1 = cx - halfLen;
  const x2 = cx + halfLen;
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  // Vertical markers
  ctx.beginPath();
  ctx.moveTo(x1, cy - 30); ctx.lineTo(x1, cy + 30);
  ctx.moveTo(x2, cy - 30); ctx.lineTo(x2, cy + 30);
  // Horizontal measure
  ctx.moveTo(x1, cy + 25); ctx.lineTo(x2, cy + 25);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = color;
  ctx.font = '14px monospace';
  ctx.textAlign = 'center';
  ctx.fillText(Math.round(length) + 'px', cx, cy + 42);
}

function draw3DContext() {
  const cx = W / 2;
  const topY = H * 0.15;
  const botY = H * 0.65;
  const midY = (topY + botY) / 2;
  ctx.save();
  // Interior corner (looks close)
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 3;
  const lx = cx - 200;
  ctx.beginPath();
  ctx.moveTo(lx, midY);
  ctx.lineTo(lx - 80, midY - 100);
  ctx.moveTo(lx, midY);
  ctx.lineTo(lx + 80, midY - 100);
  ctx.moveTo(lx, midY);
  ctx.lineTo(lx - 80, midY + 100);
  ctx.moveTo(lx, midY);
  ctx.lineTo(lx + 80, midY + 100);
  ctx.stroke();
  // Vertical line
  ctx.strokeStyle = '#e44';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(lx, midY - 70);
  ctx.lineTo(lx, midY + 70);
  ctx.stroke();
  ctx.fillStyle = '#aaa';
  ctx.font = '13px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Interior corner (close)', lx, midY + 110);

  // Exterior corner (looks far)
  const rx = cx + 200;
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(rx, midY);
  ctx.lineTo(rx - 80, midY - 100);
  ctx.moveTo(rx, midY);
  ctx.lineTo(rx + 80, midY - 100);
  ctx.moveTo(rx, midY);
  ctx.lineTo(rx - 80, midY + 100);
  ctx.moveTo(rx, midY);
  ctx.lineTo(rx + 80, midY + 100);
  ctx.stroke();
  // Now draw outward
  ctx.beginPath();
  ctx.moveTo(rx - 80, midY - 100); ctx.lineTo(rx - 160, midY);
  ctx.moveTo(rx + 80, midY - 100); ctx.lineTo(rx + 160, midY);
  ctx.moveTo(rx - 80, midY + 100); ctx.lineTo(rx - 160, midY);
  ctx.moveTo(rx + 80, midY + 100); ctx.lineTo(rx + 160, midY);
  ctx.stroke();
  ctx.strokeStyle = '#4ae';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(rx, midY - 70);
  ctx.lineTo(rx, midY + 70);
  ctx.stroke();
  ctx.fillStyle = '#aaa';
  ctx.fillText('Exterior corner (far)', rx, midY + 110);
  ctx.fillStyle = '#999';
  ctx.font = '12px sans-serif';
  ctx.fillText('Both red/blue lines are the SAME length', cx, midY + 140);
  ctx.restore();
}

function draw() {
  ctx.fillStyle = '#f5f5f5';
  ctx.fillRect(0, 0, W, H);

  if (showContext) {
    draw3DContext();
    requestAnimationFrame(draw);
    return;
  }

  const finAngle = val('finAngle');
  const finLen = val('finLen');
  const thickness = val('thick');
  const cx = W / 2;
  const topY = H * 0.35;
  const botY = H * 0.55;

  // Top line: outward fins (looks shorter) - this is the reference
  drawArrowLine(cx, topY, trueLength, finAngle, finLen, 'outward', thickness, '#333');
  ctx.fillStyle = '#888';
  ctx.font = '13px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Reference Line (outward fins)', cx, topY - 50);

  // Bottom line: inward fins (looks longer) - user adjustable
  drawArrowLine(cx, botY, userLength, finAngle, finLen, 'inward', thickness, '#333');
  ctx.fillStyle = '#888';
  ctx.fillText('Your Line (inward fins) \u2014 drag endpoints to adjust', cx, botY + 55);

  // Drag handles
  const handleX1 = cx - userLength / 2;
  const handleX2 = cx + userLength / 2;
  ctx.fillStyle = 'rgba(100,150,255,0.3)';
  ctx.beginPath(); ctx.arc(handleX1, botY, 12, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(handleX2, botY, 12, 0, Math.PI * 2); ctx.fill();

  if (revealed) {
    drawRuler(cx, topY, trueLength, '#e44');
    drawRuler(cx, botY, userLength, '#44e');
    // Also show truth
    ctx.strokeStyle = 'rgba(0,200,0,0.4)';
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 4]);
    ctx.beginPath();
    ctx.moveTo(cx - trueLength / 2, topY);
    ctx.lineTo(cx - trueLength / 2, botY);
    ctx.moveTo(cx + trueLength / 2, topY);
    ctx.lineTo(cx + trueLength / 2, botY);
    ctx.stroke();
    ctx.setLineDash([]);
    const error = ((userLength - trueLength) / trueLength * 100).toFixed(1);
    ctx.fillStyle = '#333';
    ctx.font = 'bold 16px sans-serif';
    ctx.fillText('Both lines should be ' + trueLength + 'px. Your line: ' + Math.round(userLength) + 'px (Error: ' + error + '%)', cx, botY + 85);
  }

  requestAnimationFrame(draw);
}

let dragSide = null;
canvas.addEventListener('mousedown', function(e) {
  if (revealed || showContext) return;
  const cx = W / 2;
  const botY = H * 0.55;
  const lx = cx - userLength / 2;
  const rx = cx + userLength / 2;
  const d1 = Math.hypot(e.clientX - lx, e.clientY - botY);
  const d2 = Math.hypot(e.clientX - rx, e.clientY - botY);
  if (d1 < 30) { dragging = true; dragSide = 'left'; }
  else if (d2 < 30) { dragging = true; dragSide = 'right'; }
});
canvas.addEventListener('mousemove', function(e) {
  if (!dragging) return;
  const cx = W / 2;
  const dist = Math.abs(e.clientX - cx);
  userLength = Math.max(60, Math.min(500, dist * 2));
});
canvas.addEventListener('mouseup', function() { dragging = false; dragSide = null; });

// Touch support
canvas.addEventListener('touchstart', function(e) {
  if (revealed || showContext) return;
  const t = e.touches[0];
  const cx = W / 2;
  const botY = H * 0.55;
  const lx = cx - userLength / 2;
  const rx = cx + userLength / 2;
  const d1 = Math.hypot(t.clientX - lx, t.clientY - botY);
  const d2 = Math.hypot(t.clientX - rx, t.clientY - botY);
  if (d1 < 40 || d2 < 40) { dragging = true; e.preventDefault(); }
}, { passive: false });
canvas.addEventListener('touchmove', function(e) {
  if (!dragging) return;
  e.preventDefault();
  const t = e.touches[0];
  const cx = W / 2;
  userLength = Math.max(60, Math.min(500, Math.abs(t.clientX - cx) * 2));
}, { passive: false });
canvas.addEventListener('touchend', function() { dragging = false; });

document.getElementById('btnSubmit').addEventListener('click', function() {
  if (revealed || showContext) return;
  revealed = true;
  const error = (userLength - trueLength) / trueLength * 100;
  trials.push(error);
  updateStats();
});

document.getElementById('btnReveal').addEventListener('click', function() {
  revealed = !revealed;
  document.getElementById('btnReveal').classList.toggle('active', revealed);
});

document.getElementById('btnReset').addEventListener('click', newTrial);
document.getElementById('btnContext').addEventListener('click', function() {
  showContext = !showContext;
  this.classList.toggle('active', showContext);
});

function newTrial() {
  revealed = false;
  document.getElementById('btnReveal').classList.remove('active');
  trueLength = 150 + Math.random() * 150;
  userLength = trueLength * (0.85 + Math.random() * 0.3);
  trialConfig = (trialConfig + 1) % configs.length;
  document.getElementById('finAngle').value = configs[trialConfig].finAngle;
  document.getElementById('finLen').value = configs[trialConfig].finLen;
  updateSliderLabels();
  document.getElementById('trialNum').textContent = 'Trial: ' + (trials.length + 1);
}

function updateStats() {
  const avg = trials.reduce((a, b) => a + Math.abs(b), 0) / trials.length;
  document.getElementById('avgError').textContent = 'Avg Error: ' + avg.toFixed(1) + '%';
  document.getElementById('lastError').textContent = 'Last Error: ' + Math.abs(trials[trials.length - 1]).toFixed(1) + '%';
  document.getElementById('totalTrials').textContent = 'Completed: ' + trials.length;
  document.getElementById('trialNum').textContent = 'Trial: ' + (trials.length + 1);
}

window.reset = function() {
  trials = [];
  trialConfig = 0;
  document.getElementById('avgError').textContent = 'Avg Error: --';
  document.getElementById('lastError').textContent = 'Last Error: --';
  document.getElementById('totalTrials').textContent = 'Completed: 0';
  newTrial();
};

newTrial();
draw();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
