<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Change Blindness</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a2e; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; cursor: crosshair; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
#controls {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
  padding: 18px 24px; border-radius: 14px; color: #ccd; z-index: 100;
  display: flex; flex-wrap: wrap; gap: 14px; align-items: center; max-width: 750px;
  border: 1px solid rgba(255,255,255,0.08);
}
#controls label { font-size: 0.82em; display: flex; align-items: center; gap: 6px; }
button {
  background: rgba(100,140,255,0.2); color: #8af; border: 1px solid rgba(100,140,255,0.3);
  padding: 6px 14px; border-radius: 8px; cursor: pointer; font-size: 0.85em;
}
button:hover { background: rgba(100,140,255,0.35); }
button.active { background: rgba(100,255,140,0.2); color: #8fa; border-color: rgba(100,255,140,0.3); }
#info {
  position: fixed; top: 20px; right: 20px; background: rgba(20,20,40,0.85);
  backdrop-filter: blur(10px); padding: 16px 20px; border-radius: 12px;
  color: #aab; font-size: 0.82em; max-width: 310px; z-index: 100; line-height: 1.5;
  border: 1px solid rgba(255,255,255,0.08);
}
#info strong { color: #dde; }
#status {
  position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
  padding: 12px 20px; border-radius: 10px; color: #ccd; z-index: 100;
  font-size: 0.9em; text-align: center; border: 1px solid rgba(255,255,255,0.08);
}
#status .level { color: #8af; font-weight: bold; }
#status .timer { color: #fa8; }
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>

<div id="status">
  <span class="level" id="levelText">Level 1: Color Change</span> &nbsp;|&nbsp;
  <span class="timer" id="timerText">Time: 0.0s</span> &nbsp;|&nbsp;
  <span id="statsText">Found: 0 | Avg: --</span>
</div>

<div id="info">
  <strong>Change Blindness</strong><br><br>
  Two versions of a scene alternate with a brief blank flash between them. One significant element <em>changes</em>, but the flash makes it nearly impossible to spot.<br><br>
  Click where you think the change is!<br><br>
  <strong>Change blindness</strong> reveals that we do NOT have a detailed internal representation of the visual world. A brief disruption prevents the motion signal that would normally flag changes.
</div>

<div id="controls">
  <button id="nextBtn">Next Scene</button>
  <button id="noFlashBtn">Remove Flash (easy mode)</button>
  <button id="showBtn">Show Change</button>
  <button id="resetBtn">Reset Stats</button>
  <label>Flash Duration <input type="range" id="flashDur" min="50" max="500" value="200" style="width:80px"> <span id="flashDurVal">200</span>ms</label>
  <label>Display Time <input type="range" id="displayTime" min="300" max="2000" value="1000" style="width:80px"> <span id="displayTimeVal">1000</span>ms</label>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

let currentLevel = 0;
let showingA = true;
let flashActive = false;
let noFlash = false;
let found = false;
let showingAnswer = false;
let startTime = Date.now();
let foundTimes = [];
let animId;
let cycleTimer = null;
let flashDuration = 200;
let displayDuration = 1000;

// Scene objects
let sceneObjects = [];
let changeIndex = -1;
let changeType = '';
let changeData = {};

const COLORS = ['#e74c3c','#3498db','#2ecc71','#f39c12','#9b59b6','#1abc9c','#e67e22','#ec407a','#26c6da','#66bb6a'];

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  generateScene();
}

const levels = [
  { name: 'Color Change', type: 'color', difficulty: 'Easy' },
  { name: 'Object Disappears', type: 'remove', difficulty: 'Medium' },
  { name: 'Position Shift', type: 'position', difficulty: 'Hard' },
  { name: 'Size Change', type: 'size', difficulty: 'Medium' },
  { name: 'Background Change', type: 'background', difficulty: 'Very Hard' },
  { name: 'Shape Swap', type: 'shape', difficulty: 'Hard' },
];

function generateScene() {
  sceneObjects = [];
  found = false;
  showingAnswer = false;
  startTime = Date.now();

  const level = levels[currentLevel % levels.length];
  document.getElementById('levelText').textContent =
    `Level ${currentLevel + 1}: ${level.name} (${level.difficulty})`;

  const margin = 120;
  const sceneW = W - margin * 2;
  const sceneH = H - margin * 2;

  // Generate objects - houses, trees, cars, circles, rectangles
  const numObjects = 8 + Math.floor(Math.random() * 6);

  for (let i = 0; i < numObjects; i++) {
    const type = ['house', 'tree', 'car', 'circle', 'rect'][Math.floor(Math.random() * 5)];
    const x = margin + Math.random() * sceneW;
    const y = margin + Math.random() * sceneH * 0.7 + sceneH * 0.15;
    const size = 25 + Math.random() * 40;
    const color = COLORS[Math.floor(Math.random() * COLORS.length)];

    sceneObjects.push({ type, x, y, size, color, visible: true });
  }

  // Pick change target
  changeIndex = Math.floor(Math.random() * sceneObjects.length);
  const obj = sceneObjects[changeIndex];
  changeType = level.type;

  switch (changeType) {
    case 'color': {
      let newColor;
      do { newColor = COLORS[Math.floor(Math.random() * COLORS.length)]; }
      while (newColor === obj.color);
      changeData = { origColor: obj.color, newColor };
      break;
    }
    case 'remove':
      changeData = {};
      break;
    case 'position':
      changeData = { dx: (Math.random() > 0.5 ? 1 : -1) * (30 + Math.random() * 30),
                      dy: (Math.random() > 0.5 ? 1 : -1) * (20 + Math.random() * 20) };
      break;
    case 'size':
      changeData = { origSize: obj.size, newSize: obj.size * (Math.random() > 0.5 ? 1.6 : 0.5) };
      break;
    case 'background':
      changeData = { origBg: '#2c3e50', newBg: '#34495e' };
      break;
    case 'shape': {
      const shapes = ['house','tree','car','circle','rect'];
      let newType;
      do { newType = shapes[Math.floor(Math.random() * shapes.length)]; }
      while (newType === obj.type);
      changeData = { origType: obj.type, newType };
      break;
    }
  }

  startCycle();
}

function drawObject(obj, isB) {
  const isChanged = sceneObjects.indexOf(obj) === changeIndex && isB;

  let { type, x, y, size, color, visible } = obj;

  if (isChanged) {
    switch (changeType) {
      case 'color': color = changeData.newColor; break;
      case 'remove': return;
      case 'position': x += changeData.dx; y += changeData.dy; break;
      case 'size': size = changeData.newSize; break;
      case 'shape': type = changeData.newType; break;
    }
  }

  ctx.save();
  switch (type) {
    case 'house':
      // Body
      ctx.fillStyle = color;
      ctx.fillRect(x - size * 0.5, y - size * 0.4, size, size * 0.7);
      // Roof
      ctx.beginPath();
      ctx.moveTo(x - size * 0.6, y - size * 0.4);
      ctx.lineTo(x, y - size);
      ctx.lineTo(x + size * 0.6, y - size * 0.4);
      ctx.closePath();
      ctx.fillStyle = darken(color, 0.3);
      ctx.fill();
      // Door
      ctx.fillStyle = darken(color, 0.5);
      ctx.fillRect(x - size * 0.1, y, size * 0.2, size * 0.3);
      // Window
      ctx.fillStyle = '#ffe082';
      ctx.fillRect(x + size * 0.15, y - size * 0.2, size * 0.2, size * 0.2);
      break;

    case 'tree':
      // Trunk
      ctx.fillStyle = '#5d4037';
      ctx.fillRect(x - size * 0.1, y - size * 0.3, size * 0.2, size * 0.6);
      // Canopy
      ctx.beginPath();
      ctx.arc(x, y - size * 0.5, size * 0.45, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      break;

    case 'car':
      // Body
      ctx.fillStyle = color;
      roundRect(ctx, x - size * 0.6, y - size * 0.25, size * 1.2, size * 0.35, 4);
      ctx.fill();
      // Top
      ctx.fillStyle = darken(color, 0.15);
      roundRect(ctx, x - size * 0.3, y - size * 0.55, size * 0.7, size * 0.35, 4);
      ctx.fill();
      // Wheels
      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.arc(x - size * 0.3, y + size * 0.1, size * 0.12, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + size * 0.3, y + size * 0.1, size * 0.12, 0, Math.PI * 2);
      ctx.fill();
      break;

    case 'circle':
      ctx.beginPath();
      ctx.arc(x, y, size * 0.4, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      break;

    case 'rect':
      ctx.fillStyle = color;
      ctx.fillRect(x - size * 0.4, y - size * 0.3, size * 0.8, size * 0.6);
      break;
  }
  ctx.restore();
}

function darken(hex, amt) {
  const r = Math.max(0, parseInt(hex.slice(1, 3), 16) * (1 - amt));
  const g = Math.max(0, parseInt(hex.slice(3, 5), 16) * (1 - amt));
  const b = Math.max(0, parseInt(hex.slice(5, 7), 16) * (1 - amt));
  return `rgb(${r|0},${g|0},${b|0})`;
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

function drawScene(isB) {
  // Background
  const bgColor = (changeType === 'background' && isB) ? changeData.newBg : (changeData.origBg || '#2c3e50');
  ctx.fillStyle = bgColor;
  ctx.fillRect(0, 0, W, H);

  // Ground
  ctx.fillStyle = '#27ae60';
  ctx.fillRect(0, H * 0.65, W, H * 0.35);

  // Sky gradient
  const grad = ctx.createLinearGradient(0, 0, 0, H * 0.65);
  grad.addColorStop(0, '#1a237e');
  grad.addColorStop(1, '#42a5f5');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H * 0.65);

  // Sun
  ctx.beginPath();
  ctx.arc(W * 0.8, H * 0.15, 40, 0, Math.PI * 2);
  ctx.fillStyle = '#fff176';
  ctx.fill();

  // Clouds
  drawCloud(W * 0.2, H * 0.12, 50);
  drawCloud(W * 0.5, H * 0.08, 40);
  drawCloud(W * 0.7, H * 0.18, 35);

  // Objects
  sceneObjects.forEach(obj => drawObject(obj, isB));

  // Answer highlight
  if (showingAnswer && changeIndex >= 0) {
    const obj = sceneObjects[changeIndex];
    let tx = obj.x, ty = obj.y;
    if (isB && changeType === 'position') {
      tx += changeData.dx;
      ty += changeData.dy;
    }
    const pulse = Math.sin(Date.now() * 0.008) * 5 + 15;
    ctx.beginPath();
    ctx.arc(tx, ty, obj.size * 0.7 + pulse, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255,255,0,${0.5 + Math.sin(Date.now() * 0.005) * 0.3})`;
    ctx.lineWidth = 3;
    ctx.stroke();
  }
}

function drawCloud(x, y, s) {
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.beginPath();
  ctx.arc(x, y, s * 0.5, 0, Math.PI * 2);
  ctx.arc(x + s * 0.4, y - s * 0.15, s * 0.4, 0, Math.PI * 2);
  ctx.arc(x + s * 0.8, y, s * 0.45, 0, Math.PI * 2);
  ctx.fill();
}

// Alternation cycle
let cycleState = 'A'; // 'A', 'flash', 'B', 'flash'
let cycleTime = 0;

function startCycle() {
  cycleState = 'A';
  cycleTime = Date.now();
}

function draw() {
  const now = Date.now();
  const elapsed = now - cycleTime;

  if (!found) {
    if (noFlash) {
      // No flash mode: alternate directly
      if (elapsed < displayDuration) {
        cycleState = 'A';
      } else if (elapsed < displayDuration * 2) {
        cycleState = 'B';
      } else {
        cycleTime = now;
        cycleState = 'A';
      }
    } else {
      // Normal mode with flash
      const cyclePeriod = displayDuration * 2 + flashDuration * 2;
      const t = elapsed % cyclePeriod;
      if (t < displayDuration) {
        cycleState = 'A';
      } else if (t < displayDuration + flashDuration) {
        cycleState = 'flashA';
      } else if (t < displayDuration * 2 + flashDuration) {
        cycleState = 'B';
      } else {
        cycleState = 'flashB';
      }
    }
  }

  if (cycleState === 'flashA' || cycleState === 'flashB') {
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, W, H);
  } else {
    drawScene(cycleState === 'B');
  }

  // Timer
  if (!found) {
    const t = ((now - startTime) / 1000).toFixed(1);
    document.getElementById('timerText').textContent = 'Time: ' + t + 's';
  }

  animId = requestAnimationFrame(draw);
}

// Click detection
canvas.addEventListener('click', e => {
  if (found) return;

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const obj = sceneObjects[changeIndex];
  let tx = obj.x, ty = obj.y;
  const dist = Math.sqrt((mx - tx) ** 2 + (my - ty) ** 2);

  if (dist < obj.size * 1.2) {
    found = true;
    showingAnswer = true;
    const time = (Date.now() - startTime) / 1000;
    foundTimes.push(time);
    updateStats();
    document.getElementById('timerText').textContent = 'Found in ' + time.toFixed(1) + 's!';
  }
});

function updateStats() {
  const avg = foundTimes.length > 0 ?
    (foundTimes.reduce((a, b) => a + b, 0) / foundTimes.length).toFixed(1) : '--';
  document.getElementById('statsText').textContent =
    `Found: ${foundTimes.length} | Avg: ${avg}s`;
}

// Controls
document.getElementById('nextBtn').addEventListener('click', () => {
  currentLevel++;
  generateScene();
});

document.getElementById('noFlashBtn').addEventListener('click', function() {
  noFlash = !noFlash;
  this.classList.toggle('active');
  this.textContent = noFlash ? 'Add Flash Back' : 'Remove Flash (easy mode)';
});

document.getElementById('showBtn').addEventListener('click', () => {
  showingAnswer = !showingAnswer;
  if (!found && showingAnswer) {
    found = true;
    document.getElementById('timerText').textContent = 'Revealed!';
  }
});

document.getElementById('resetBtn').addEventListener('click', () => window.reset());

document.getElementById('flashDur').addEventListener('input', function() {
  flashDuration = parseInt(this.value);
  document.getElementById('flashDurVal').textContent = this.value;
});

document.getElementById('displayTime').addEventListener('input', function() {
  displayDuration = parseInt(this.value);
  document.getElementById('displayTimeVal').textContent = this.value;
});

window.reset = function() {
  currentLevel = 0;
  foundTimes = [];
  noFlash = false;
  flashDuration = 200;
  displayDuration = 1000;
  document.getElementById('noFlashBtn').classList.remove('active');
  document.getElementById('noFlashBtn').textContent = 'Remove Flash (easy mode)';
  document.getElementById('flashDur').value = 200;
  document.getElementById('flashDurVal').textContent = '200';
  document.getElementById('displayTime').value = 1000;
  document.getElementById('displayTimeVal').textContent = '1000';
  updateStats();
  generateScene();
};

let resizeTimer;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(resize, 150);
});

resize();
draw();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>