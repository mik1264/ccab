<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Watercolor Illusion</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a2e; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; cursor: crosshair; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
#controls {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
  padding: 18px 24px; border-radius: 14px; color: #ccd; z-index: 100;
  display: flex; flex-wrap: wrap; gap: 12px; align-items: center; max-width: 800px;
  border: 1px solid rgba(255,255,255,0.08);
}
#controls label { font-size: 0.82em; display: flex; align-items: center; gap: 5px; white-space: nowrap; }
#controls input[type=range] { width: 80px; accent-color: #8af; }
#controls input[type=color] { width: 30px; height: 24px; border: none; background: none; cursor: pointer; }
button {
  background: rgba(100,140,255,0.2); color: #8af; border: 1px solid rgba(100,140,255,0.3);
  padding: 6px 12px; border-radius: 8px; cursor: pointer; font-size: 0.82em;
}
button:hover { background: rgba(100,140,255,0.35); }
button.active { background: rgba(100,255,140,0.2); color: #8fa; border-color: rgba(100,255,140,0.3); }
#info {
  position: fixed; top: 20px; right: 20px; background: rgba(20,20,40,0.85);
  backdrop-filter: blur(10px); padding: 16px 20px; border-radius: 12px;
  color: #aab; font-size: 0.82em; max-width: 300px; z-index: 100; line-height: 1.5;
  border: 1px solid rgba(255,255,255,0.08);
}
#info strong { color: #dde; }
#pixel-info {
  position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(20,20,40,0.9); backdrop-filter: blur(10px);
  padding: 10px 16px; border-radius: 10px; color: #8fa; font-size: 0.85em;
  z-index: 100; display: none; border: 1px solid rgba(100,255,140,0.2);
}
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>

<div id="info">
  <strong>Watercolor Illusion</strong><br>(Pinna-Brelstaff)<br><br>
  When a dark outer contour and lighter inner contour border a white region, the enclosed area appears <em>tinted</em> with the inner contour's color -- even though it is pure white.<br><br>
  Your brain's <strong>color-filling mechanism</strong> extends the inner edge color into the enclosed space, creating a phantom tint.
</div>

<div id="pixel-info"></div>

<div id="controls">
  <label>Inner <input type="color" id="innerColor" value="#ffa040"></label>
  <label>Outer <input type="color" id="outerColor" value="#804000"></label>
  <label>Width <input type="range" id="lineWidth" min="2" max="12" value="5"></label>
  <label>BG <input type="range" id="bgBright" min="200" max="255" value="255"></label>
  <button id="btnCircle">Circle</button>
  <button id="btnSquare">Square</button>
  <button id="btnStar">Star</button>
  <button id="btnBlob">Blob</button>
  <button id="btnZoom">Zoom Reveal</button>
  <button id="btnClear">Clear</button>
  <button id="btnReset">Reset</button>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const pixelInfo = document.getElementById('pixel-info');
let W, H;

let innerColor = '#ffa040';
let outerColor = '#804000';
let lineW = 5;
let bgBright = 255;
let zoomMode = false;
let shapes = [];
let drawingPoints = [];
let isDrawing = false;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}

function hexToRgb(hex) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return [r, g, b];
}

function makeCircle(cx, cy, radius, segments) {
  const pts = [];
  for (let i = 0; i <= segments; i++) {
    const a = (i / segments) * Math.PI * 2;
    pts.push({ x: cx + Math.cos(a) * radius, y: cy + Math.sin(a) * radius });
  }
  return pts;
}

function makeSquare(cx, cy, size) {
  const h = size / 2;
  return [
    { x: cx - h, y: cy - h }, { x: cx + h, y: cy - h },
    { x: cx + h, y: cy + h }, { x: cx - h, y: cy + h },
    { x: cx - h, y: cy - h }
  ];
}

function makeStar(cx, cy, outerR, innerR, points) {
  const pts = [];
  for (let i = 0; i <= points * 2; i++) {
    const a = (i / (points * 2)) * Math.PI * 2 - Math.PI / 2;
    const r = i % 2 === 0 ? outerR : innerR;
    pts.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });
  }
  return pts;
}

function makeBlob(cx, cy, radius, lobes) {
  const pts = [];
  const segments = 80;
  for (let i = 0; i <= segments; i++) {
    const a = (i / segments) * Math.PI * 2;
    const r = radius * (1 + 0.3 * Math.sin(a * lobes) + 0.15 * Math.cos(a * (lobes + 2)));
    pts.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });
  }
  return pts;
}

function addShape(pts, inner, outer, width) {
  shapes.push({ points: pts, innerColor: inner, outerColor: outer, lineWidth: width });
}

function drawShape(shape) {
  const pts = shape.points;
  if (pts.length < 3) return;

  const lw = shape.lineWidth;

  // Draw outer contour (thicker, darker)
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for (let i = 1; i < pts.length; i++) {
    ctx.lineTo(pts[i].x, pts[i].y);
  }
  ctx.closePath();
  ctx.strokeStyle = shape.outerColor;
  ctx.lineWidth = lw * 2.5;
  ctx.lineJoin = 'round';
  ctx.stroke();

  // Fill interior with background color (this is the illusion -- it's actually white/bg)
  ctx.fillStyle = `rgb(${bgBright},${bgBright},${bgBright})`;
  ctx.fill();

  // Draw inner contour (thinner, lighter/colored)
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for (let i = 1; i < pts.length; i++) {
    ctx.lineTo(pts[i].x, pts[i].y);
  }
  ctx.closePath();
  ctx.strokeStyle = shape.innerColor;
  ctx.lineWidth = lw * 1.2;
  ctx.lineJoin = 'round';
  ctx.stroke();
}

function draw() {
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = `rgb(${bgBright},${bgBright},${bgBright})`;
  ctx.fillRect(0, 0, W, H);

  shapes.forEach(drawShape);

  // Draw in-progress freehand
  if (isDrawing && drawingPoints.length > 1) {
    ctx.beginPath();
    ctx.moveTo(drawingPoints[0].x, drawingPoints[0].y);
    for (let i = 1; i < drawingPoints.length; i++) {
      ctx.lineTo(drawingPoints[i].x, drawingPoints[i].y);
    }
    ctx.strokeStyle = outerColor;
    ctx.lineWidth = lineW * 2;
    ctx.lineJoin = 'round';
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(drawingPoints[0].x, drawingPoints[0].y);
    for (let i = 1; i < drawingPoints.length; i++) {
      ctx.lineTo(drawingPoints[i].x, drawingPoints[i].y);
    }
    ctx.strokeStyle = innerColor;
    ctx.lineWidth = lineW;
    ctx.lineJoin = 'round';
    ctx.stroke();
  }
}

function drawZoom(mx, my) {
  draw();

  // Read pixel at mouse position BEFORE zoom overlay
  const pixel = ctx.getImageData(mx, my, 1, 1).data;
  const r = pixel[0], g = pixel[1], b = pixel[2];

  // Zoom circle
  const zoomR = 100;
  const zoomScale = 5;
  const sourceR = zoomR / zoomScale;

  ctx.save();
  ctx.beginPath();
  ctx.arc(mx, my, zoomR, 0, Math.PI * 2);
  ctx.clip();

  // Draw zoomed region
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(canvas,
    mx - sourceR, my - sourceR, sourceR * 2, sourceR * 2,
    mx - zoomR, my - zoomR, zoomR * 2, zoomR * 2
  );

  // Grid overlay
  ctx.strokeStyle = 'rgba(0,0,0,0.15)';
  ctx.lineWidth = 0.5;
  const step = zoomScale;
  for (let x = mx - zoomR; x < mx + zoomR; x += step) {
    ctx.beginPath(); ctx.moveTo(x, my - zoomR); ctx.lineTo(x, my + zoomR); ctx.stroke();
  }
  for (let y = my - zoomR; y < my + zoomR; y += step) {
    ctx.beginPath(); ctx.moveTo(mx - zoomR, y); ctx.lineTo(mx + zoomR, y); ctx.stroke();
  }

  ctx.restore();

  // Zoom border
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(mx, my, zoomR, 0, Math.PI * 2);
  ctx.stroke();

  // Pixel info
  pixelInfo.style.display = 'block';
  pixelInfo.textContent = `Pixel at cursor: rgb(${r}, ${g}, ${b}) -- ${r === bgBright && g === bgBright && b === bgBright ? 'This is pure background!' : 'This is a contour line'}`;
}

// Mouse events for freehand drawing
canvas.addEventListener('mousedown', (e) => {
  if (zoomMode) return;
  if (e.target !== canvas) return;
  isDrawing = true;
  drawingPoints = [{ x: e.clientX, y: e.clientY }];
});

canvas.addEventListener('mousemove', (e) => {
  if (zoomMode) {
    drawZoom(e.clientX, e.clientY);
    return;
  }
  if (isDrawing) {
    drawingPoints.push({ x: e.clientX, y: e.clientY });
  }
});

canvas.addEventListener('mouseup', () => {
  if (!isDrawing) return;
  isDrawing = false;
  if (drawingPoints.length > 5) {
    // Close the path
    drawingPoints.push(drawingPoints[0]);
    addShape(drawingPoints, innerColor, outerColor, lineW);
  }
  drawingPoints = [];
});

canvas.addEventListener('mouseleave', () => {
  if (zoomMode) {
    pixelInfo.style.display = 'none';
    draw();
  }
});

// Preset buttons
document.getElementById('btnCircle').addEventListener('click', () => {
  addShape(makeCircle(W / 2, H / 2, Math.min(W, H) * 0.2, 60), innerColor, outerColor, lineW);
});
document.getElementById('btnSquare').addEventListener('click', () => {
  addShape(makeSquare(W / 2, H / 2, Math.min(W, H) * 0.35), innerColor, outerColor, lineW);
});
document.getElementById('btnStar').addEventListener('click', () => {
  addShape(makeStar(W / 2, H / 2, Math.min(W, H) * 0.25, Math.min(W, H) * 0.12, 5), innerColor, outerColor, lineW);
});
document.getElementById('btnBlob').addEventListener('click', () => {
  addShape(makeBlob(W / 2, H / 2, Math.min(W, H) * 0.2, 5), innerColor, outerColor, lineW);
});

document.getElementById('btnZoom').addEventListener('click', function() {
  zoomMode = !zoomMode;
  this.classList.toggle('active', zoomMode);
  this.textContent = zoomMode ? 'Exit Zoom' : 'Zoom Reveal';
  canvas.style.cursor = zoomMode ? 'none' : 'crosshair';
  if (!zoomMode) {
    pixelInfo.style.display = 'none';
  }
});

document.getElementById('btnClear').addEventListener('click', () => {
  shapes = [];
});

document.getElementById('innerColor').addEventListener('input', e => { innerColor = e.target.value; });
document.getElementById('outerColor').addEventListener('input', e => { outerColor = e.target.value; });
document.getElementById('lineWidth').addEventListener('input', e => { lineW = +e.target.value; });
document.getElementById('bgBright').addEventListener('input', e => { bgBright = +e.target.value; });

document.getElementById('btnReset').addEventListener('click', reset);

function reset() {
  shapes = [];
  innerColor = '#ffa040';
  outerColor = '#804000';
  lineW = 5;
  bgBright = 255;
  zoomMode = false;
  document.getElementById('innerColor').value = '#ffa040';
  document.getElementById('outerColor').value = '#804000';
  document.getElementById('lineWidth').value = 5;
  document.getElementById('bgBright').value = 255;
  document.getElementById('btnZoom').textContent = 'Zoom Reveal';
  document.getElementById('btnZoom').classList.remove('active');
  canvas.style.cursor = 'crosshair';
  pixelInfo.style.display = 'none';

  // Add default shapes
  addShape(makeCircle(W * 0.3, H * 0.4, Math.min(W, H) * 0.15, 60), innerColor, outerColor, lineW);
  addShape(makeSquare(W * 0.7, H * 0.4, Math.min(W, H) * 0.28), innerColor, outerColor, lineW);
  addShape(makeStar(W * 0.5, H * 0.65, Math.min(W, H) * 0.14, Math.min(W, H) * 0.07, 6), innerColor, outerColor, lineW);
}
window.reset = reset;

function animate() {
  if (!zoomMode) draw();
  requestAnimationFrame(animate);
}

window.addEventListener('resize', () => { resize(); shapes = []; reset(); });
resize();
reset();
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
