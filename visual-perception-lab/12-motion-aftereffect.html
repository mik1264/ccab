<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Motion Aftereffect - Waterfall Illusion</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a2e; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
#controls {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
  padding: 18px 24px; border-radius: 14px; color: #ccd; z-index: 100;
  display: flex; flex-wrap: wrap; gap: 14px; align-items: center; max-width: 800px;
  border: 1px solid rgba(255,255,255,0.08);
}
#controls label { font-size: 0.85em; display: flex; align-items: center; gap: 6px; }
#controls input[type=range] { width: 90px; accent-color: #8af; }
#controls select { background: rgba(60,60,100,0.6); color: #ccd; border: 1px solid rgba(255,255,255,0.15); padding: 4px 8px; border-radius: 6px; font-size: 0.82em; }
button {
  background: rgba(100,140,255,0.2); color: #8af; border: 1px solid rgba(100,140,255,0.3);
  padding: 6px 14px; border-radius: 8px; cursor: pointer; font-size: 0.85em;
}
button:hover { background: rgba(100,140,255,0.35); }
button.active { background: rgba(100,255,140,0.2); color: #8fa; border-color: rgba(100,255,140,0.3); }
#info {
  position: fixed; top: 20px; right: 20px; background: rgba(20,20,40,0.85);
  backdrop-filter: blur(10px); padding: 16px 20px; border-radius: 12px;
  color: #aab; font-size: 0.82em; max-width: 320px; z-index: 100; line-height: 1.5;
  border: 1px solid rgba(255,255,255,0.08);
}
#info strong { color: #dde; }
#phase-display {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
  z-index: 60; pointer-events: none; text-align: center;
}
#countdown {
  color: #ffcc44; font-size: 64px; font-weight: bold;
  text-shadow: 0 0 20px rgba(255,200,0,0.5);
}
#instruction {
  color: rgba(200,200,220,0.9); font-size: 1.1em; margin-top: 10px;
}
#fixation-dot {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
  width: 12px; height: 12px; background: #ff4444; border-radius: 50%;
  z-index: 55; pointer-events: none;
  box-shadow: 0 0 6px rgba(255,0,0,0.6);
}
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>
<div id="fixation-dot"></div>

<div id="phase-display">
  <div id="countdown"></div>
  <div id="instruction"></div>
</div>

<div id="info">
  <strong>Motion Aftereffect</strong><br><br>
  After adapting to motion in one direction, neurons for that direction become fatigued. The imbalance makes static images appear to move in the <em>opposite</em> direction.<br><br>
  This proves motion perception uses <strong>opponent channels</strong> - like color opponent processing.
</div>

<div id="controls">
  <label>Duration <input type="range" id="duration" min="10" max="40" value="20"> <span id="durVal">20s</span></label>
  <label>Motion <select id="motionType">
    <option value="spiral">Expanding Spiral</option>
    <option value="rotate">Rotating Disk</option>
    <option value="waterfall">Waterfall</option>
  </select></label>
  <label>Speed <input type="range" id="speed" min="1" max="10" value="5"></label>
  <label>Test <select id="testImage">
    <option value="checker">Checkerboard</option>
    <option value="face">Face Drawing</option>
    <option value="text">Text</option>
    <option value="dots">Random Dots</option>
  </select></label>
  <button id="btnStart">Start Adaptation</button>
  <button id="btnReset">Reset</button>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

let phase = 'idle'; // idle, adapting, testing
let adaptDuration = 20;
let motionType = 'spiral';
let speedFactor = 5;
let testImage = 'checker';
let adaptStartTime = 0;
let animFrame;
let angle = 0;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  if (phase === 'idle') drawIdleScreen();
  if (phase === 'testing') drawTestImage();
}

function drawIdleScreen() {
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = 'rgba(200,200,220,0.3)';
  ctx.font = '24px Segoe UI, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Press "Start Adaptation" to begin', W/2, H/2 + 60);
  document.getElementById('countdown').textContent = '';
  document.getElementById('instruction').textContent = 'Stare at the red dot during adaptation';
}

function drawSpiral(t) {
  const cx = W/2, cy = H/2;
  const maxR = Math.min(W, H) * 0.45;
  const sp = speedFactor * 0.4;

  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, W, H);

  ctx.save();
  ctx.translate(cx, cy);

  const arms = 6;
  const turns = 4;

  for (let arm = 0; arm < arms; arm++) {
    const armAngle = (arm / arms) * Math.PI * 2;
    ctx.beginPath();

    for (let r = 5; r < maxR; r += 2) {
      const theta = armAngle + (r / maxR) * turns * Math.PI * 2 + t * sp;
      const x = Math.cos(theta) * r;
      const y = Math.sin(theta) * r;
      if (r === 5) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }

    ctx.strokeStyle = arm % 2 === 0 ? '#ffffff' : '#000000';
    ctx.lineWidth = maxR / (arms * 1.5);
    ctx.stroke();
  }

  // Clip to circle
  ctx.restore();
  ctx.save();
  ctx.globalCompositeOperation = 'destination-in';
  ctx.beginPath();
  ctx.arc(cx, cy, maxR, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // Border
  ctx.beginPath();
  ctx.arc(cx, cy, maxR, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(200,200,220,0.3)';
  ctx.lineWidth = 2;
  ctx.stroke();
}

function drawRotatingDisk(t) {
  const cx = W/2, cy = H/2;
  const maxR = Math.min(W, H) * 0.4;
  const sp = speedFactor * 0.6;

  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, W, H);

  const sectors = 12;
  for (let i = 0; i < sectors; i++) {
    const a1 = (i / sectors) * Math.PI * 2 + t * sp;
    const a2 = ((i + 1) / sectors) * Math.PI * 2 + t * sp;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, maxR, a1, a2);
    ctx.closePath();
    ctx.fillStyle = i % 2 === 0 ? '#ffffff' : '#222222';
    ctx.fill();
  }

  // concentric rings for extra effect
  for (let r = maxR * 0.3; r < maxR; r += maxR * 0.2) {
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(128,128,128,0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();
  }
}

function drawWaterfall(t) {
  const sp = speedFactor * 30;
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, W, H);

  const cx = W/2, cy = H/2;
  const hw = Math.min(W, H) * 0.35;

  const stripeH = 20;
  const offset = (t * sp) % (stripeH * 2);

  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, hw, 0, Math.PI * 2);
  ctx.clip();

  for (let y = -stripeH * 2; y < hw * 2 + stripeH * 2; y += stripeH) {
    const yy = cy - hw + y + offset;
    ctx.fillStyle = Math.floor((y + offset) / stripeH) % 2 === 0 ? '#ffffff' : '#222222';
    ctx.fillRect(cx - hw, yy, hw * 2, stripeH);
  }

  ctx.restore();

  ctx.beginPath();
  ctx.arc(cx, cy, hw, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(200,200,220,0.3)';
  ctx.lineWidth = 2;
  ctx.stroke();
}

function drawTestImage() {
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, W, H);

  const cx = W/2, cy = H/2;
  const size = Math.min(W, H) * 0.4;

  if (testImage === 'checker') {
    const cells = 12;
    const cellSize = (size * 2) / cells;
    for (let r = 0; r < cells; r++) {
      for (let c = 0; c < cells; c++) {
        const x = cx - size + c * cellSize;
        const y = cy - size + r * cellSize;
        ctx.fillStyle = (r + c) % 2 === 0 ? '#dddddd' : '#444444';
        ctx.fillRect(x, y, cellSize, cellSize);
      }
    }
  } else if (testImage === 'face') {
    // Simple face
    ctx.strokeStyle = '#cccccc';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(cx, cy, size * 0.6, 0, Math.PI * 2);
    ctx.stroke();
    // Eyes
    ctx.beginPath();
    ctx.arc(cx - size * 0.2, cy - size * 0.15, size * 0.08, 0, Math.PI * 2);
    ctx.fillStyle = '#cccccc';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(cx + size * 0.2, cy - size * 0.15, size * 0.08, 0, Math.PI * 2);
    ctx.fill();
    // Nose
    ctx.beginPath();
    ctx.moveTo(cx, cy - size * 0.05);
    ctx.lineTo(cx - size * 0.06, cy + size * 0.08);
    ctx.lineTo(cx + size * 0.06, cy + size * 0.08);
    ctx.stroke();
    // Mouth
    ctx.beginPath();
    ctx.arc(cx, cy + size * 0.15, size * 0.18, 0.1 * Math.PI, 0.9 * Math.PI);
    ctx.stroke();
  } else if (testImage === 'text') {
    ctx.fillStyle = '#cccccc';
    ctx.font = `bold ${size * 0.15}px Segoe UI, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('THIS TEXT', cx, cy - size * 0.2);
    ctx.fillText('IS', cx, cy);
    ctx.fillText('COMPLETELY', cx, cy + size * 0.2);
    ctx.fillText('STATIC', cx, cy + size * 0.4);
  } else if (testImage === 'dots') {
    const dotCount = 500;
    for (let i = 0; i < dotCount; i++) {
      const a = Math.random() * Math.PI * 2;
      const r = Math.random() * size;
      const x = cx + Math.cos(a) * r;
      const y = cy + Math.sin(a) * r;
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, Math.PI * 2);
      ctx.fillStyle = `hsl(0, 0%, ${30 + Math.random() * 50}%)`;
      ctx.fill();
    }
  }

  document.getElementById('fixation-dot').style.display = 'block';
}

function startAdaptation() {
  if (phase === 'adapting') return;
  phase = 'adapting';
  adaptStartTime = performance.now();
  document.getElementById('btnStart').textContent = 'Adapting...';
  document.getElementById('fixation-dot').style.display = 'block';
  animate();
}

function animate() {
  if (phase !== 'adapting') return;

  const elapsed = (performance.now() - adaptStartTime) / 1000;
  const remaining = Math.max(0, adaptDuration - elapsed);
  const t = elapsed;

  if (motionType === 'spiral') drawSpiral(t);
  else if (motionType === 'rotate') drawRotatingDisk(t);
  else if (motionType === 'waterfall') drawWaterfall(t);

  document.getElementById('countdown').textContent = Math.ceil(remaining);
  document.getElementById('instruction').textContent = 'Stare at the red dot...';

  if (remaining <= 0) {
    phase = 'testing';
    document.getElementById('countdown').textContent = 'NOW LOOK!';
    document.getElementById('instruction').textContent = 'The static image should appear to move!';
    drawTestImage();
    document.getElementById('btnStart').textContent = 'Try Again';

    setTimeout(() => {
      document.getElementById('countdown').textContent = '';
      document.getElementById('instruction').textContent = 'Did you see it? Press "Try Again" to repeat.';
    }, 4000);
    return;
  }

  animFrame = requestAnimationFrame(animate);
}

document.getElementById('btnStart').addEventListener('click', () => {
  cancelAnimationFrame(animFrame);
  phase = 'idle';
  startAdaptation();
});

document.getElementById('btnReset').addEventListener('click', () => window.reset());

document.getElementById('duration').addEventListener('input', e => {
  adaptDuration = parseInt(e.target.value);
  document.getElementById('durVal').textContent = adaptDuration + 's';
});

document.getElementById('motionType').addEventListener('change', e => {
  motionType = e.target.value;
});

document.getElementById('speed').addEventListener('input', e => {
  speedFactor = parseInt(e.target.value);
});

document.getElementById('testImage').addEventListener('change', e => {
  testImage = e.target.value;
  if (phase === 'testing') drawTestImage();
});

window.reset = function() {
  cancelAnimationFrame(animFrame);
  phase = 'idle';
  adaptDuration = 20;
  motionType = 'spiral';
  speedFactor = 5;
  testImage = 'checker';
  angle = 0;
  document.getElementById('duration').value = 20;
  document.getElementById('durVal').textContent = '20s';
  document.getElementById('motionType').value = 'spiral';
  document.getElementById('speed').value = 5;
  document.getElementById('testImage').value = 'checker';
  document.getElementById('btnStart').textContent = 'Start Adaptation';
  document.getElementById('countdown').textContent = '';
  document.getElementById('instruction').textContent = '';
  resize();
};

let resizeTimer;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(resize, 150);
});

resize();
drawIdleScreen();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>