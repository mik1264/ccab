<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bistable Perception</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a2e; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
#controls {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
  padding: 18px 24px; border-radius: 14px; color: #ccd; z-index: 100;
  display: flex; flex-wrap: wrap; gap: 12px; align-items: center; max-width: 800px;
  border: 1px solid rgba(255,255,255,0.08);
}
#controls label { font-size: 0.82em; display: flex; align-items: center; gap: 6px; }
#controls input[type=range] { width: 80px; accent-color: #8af; }
button {
  background: rgba(100,140,255,0.2); color: #8af; border: 1px solid rgba(100,140,255,0.3);
  padding: 6px 14px; border-radius: 8px; cursor: pointer; font-size: 0.85em;
}
button:hover { background: rgba(100,140,255,0.35); }
button.active { background: rgba(100,255,140,0.2); color: #8fa; border-color: rgba(100,255,140,0.3); }
#info {
  position: fixed; top: 20px; right: 20px; background: rgba(20,20,40,0.85);
  backdrop-filter: blur(10px); padding: 16px 20px; border-radius: 12px;
  color: #aab; font-size: 0.82em; max-width: 310px; z-index: 100; line-height: 1.5;
  border: 1px solid rgba(255,255,255,0.08);
}
#info strong { color: #dde; }
.tab-bar {
  position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
  padding: 8px 12px; border-radius: 12px; z-index: 100;
  display: flex; gap: 6px; border: 1px solid rgba(255,255,255,0.08);
}
.tab-bar button { font-size: 0.8em; padding: 6px 16px; }
#flipStats {
  position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
  background: rgba(20,20,40,0.85); backdrop-filter: blur(10px);
  padding: 12px 18px; border-radius: 10px; color: #ccd; z-index: 100;
  font-size: 0.85em; text-align: center; border: 1px solid rgba(255,255,255,0.08);
}
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>

<div class="tab-bar">
  <button id="tabNecker" class="active" onclick="switchTab('necker')">Necker Cube</button>
  <button id="tabRubin" onclick="switchTab('rubin')">Rubin's Vase</button>
  <button id="tabWoman" onclick="switchTab('woman')">Young/Old Woman</button>
  <button id="tabWife" onclick="switchTab('wife')">My Wife & Mother-in-Law</button>
</div>

<div id="flipStats">
  <span id="flipTimer">Timer: 0.0s</span> &nbsp;|&nbsp;
  <span id="flipCount">Flips: 0</span> &nbsp;|&nbsp;
  <span id="flipAvg">Avg: --</span> &nbsp;|&nbsp;
  <button id="flipBtn" onclick="recordFlip()">Tap when it flips</button>
  <button onclick="resetFlipTracker()">Reset timer</button>
</div>

<div id="info">
  <strong>Bistable Perception</strong><br><br>
  Your brain cannot hold both interpretations simultaneously. It alternates, typically every 3-8 seconds.<br><br>
  This <em>bistable rivalry</em> reveals the brain's active role in constructing perception -- the image doesn't change, only your interpretation of it.
</div>

<div id="controls">
  <label>Rotation <input type="range" id="rotation" min="0" max="360" value="25"> <span id="rotationVal">25</span>&deg;</label>
  <label>Size <input type="range" id="cubeSize" min="80" max="300" value="180"> <span id="cubeSizeVal">180</span></label>
  <label>Line Width <input type="range" id="lineW" min="1" max="8" value="3"> <span id="lineWVal">3</span></label>
  <button id="biasA" onclick="setBias('A')">Bias Front-Left</button>
  <button id="biasB" onclick="setBias('B')">Bias Front-Right</button>
  <button id="biasNone" onclick="setBias('none')">No Bias</button>
  <label>Morph <input type="range" id="morphAmt" min="0" max="100" value="50" style="display:none" id="morphSlider"> <span id="morphVal" style="display:none">50</span></label>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;
let currentTab = 'necker';
let bias = 'none';
let rotation = 25;
let cubeSize = 180;
let lineWidth = 3;
let morphAmt = 50;
let animId;

// Flip tracking
let flipTimerStart = null;
let flips = 0;
let flipTimes = [];
let lastFlipTime = 0;
let flipTimerId = null;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}

function switchTab(tab) {
  currentTab = tab;
  document.querySelectorAll('.tab-bar button').forEach(b => b.classList.remove('active'));
  document.getElementById('tab' + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add('active');

  const morphEls = document.querySelectorAll('#morphAmt, #morphVal');
  const cubeEls = document.querySelectorAll('#rotation, #rotationVal, #cubeSize, #cubeSizeVal, #biasA, #biasB, #biasNone');
  if (tab === 'rubin') {
    morphEls.forEach(e => e.style.display = '');
    cubeEls.forEach(e => e.style.display = 'none');
  } else {
    morphEls.forEach(e => e.style.display = 'none');
    cubeEls.forEach(e => e.style.display = '');
  }
}

function recordFlip() {
  if (!flipTimerStart) {
    flipTimerStart = Date.now();
    lastFlipTime = Date.now();
    flips = 0;
    flipTimes = [];
    startFlipTimer();
    return;
  }
  flips++;
  const now = Date.now();
  flipTimes.push(now - lastFlipTime);
  lastFlipTime = now;
  updateFlipStats();
}

function resetFlipTracker() {
  flipTimerStart = null;
  flips = 0;
  flipTimes = [];
  if (flipTimerId) clearInterval(flipTimerId);
  document.getElementById('flipTimer').textContent = 'Timer: 0.0s';
  document.getElementById('flipCount').textContent = 'Flips: 0';
  document.getElementById('flipAvg').textContent = 'Avg: --';
}

function startFlipTimer() {
  if (flipTimerId) clearInterval(flipTimerId);
  flipTimerId = setInterval(() => {
    if (!flipTimerStart) return;
    const el = ((Date.now() - flipTimerStart) / 1000).toFixed(1);
    document.getElementById('flipTimer').textContent = 'Timer: ' + el + 's';
  }, 100);
}

function updateFlipStats() {
  document.getElementById('flipCount').textContent = 'Flips: ' + flips;
  if (flipTimes.length > 0) {
    const avg = (flipTimes.reduce((a, b) => a + b, 0) / flipTimes.length / 1000).toFixed(1);
    document.getElementById('flipAvg').textContent = 'Avg: ' + avg + 's';
  }
}

function setBias(b) {
  bias = b;
}

// ---- Necker Cube ----
function drawNeckerCube() {
  const cx = W / 2;
  const cy = H / 2;
  const s = cubeSize;
  const ang = rotation * Math.PI / 180;

  // 3D cube vertices
  const verts3D = [
    [-1,-1,-1], [1,-1,-1], [1,1,-1], [-1,1,-1],
    [-1,-1,1],  [1,-1,1],  [1,1,1],  [-1,1,1]
  ];

  // Simple isometric projection
  const cosA = Math.cos(ang);
  const sinA = Math.sin(ang);
  const cosB = Math.cos(ang * 0.7);
  const sinB = Math.sin(ang * 0.7);

  function project(v) {
    let x = v[0], y = v[1], z = v[2];
    // Rotate Y axis
    let x2 = x * cosA - z * sinA;
    let z2 = x * sinA + z * cosA;
    // Rotate X axis
    let y2 = y * cosB - z2 * sinB;
    let z3 = y * sinB + z2 * cosB;
    return [cx + x2 * s * 0.5, cy + y2 * s * 0.5, z3];
  }

  const pts = verts3D.map(project);

  const edges = [
    [0,1],[1,2],[2,3],[3,0],
    [4,5],[5,6],[6,7],[7,4],
    [0,4],[1,5],[2,6],[3,7]
  ];

  // Determine which face is "front" based on bias
  const frontEdges = bias === 'A' ? [4,5,6,7] : bias === 'B' ? [0,1,2,3] : [];
  const backEdges = bias === 'A' ? [0,1,2,3] : bias === 'B' ? [4,5,6,7] : [];

  // Draw back edges first (dashed if biased)
  edges.forEach(([a, b]) => {
    const isBack = backEdges.includes(a) && backEdges.includes(b);
    const isFront = frontEdges.includes(a) && frontEdges.includes(b);
    ctx.beginPath();
    ctx.moveTo(pts[a][0], pts[a][1]);
    ctx.lineTo(pts[b][0], pts[b][1]);
    ctx.lineWidth = lineWidth;

    if (bias !== 'none') {
      if (isBack) {
        ctx.strokeStyle = 'rgba(136,170,255,0.3)';
        ctx.setLineDash([6, 4]);
      } else if (isFront) {
        ctx.strokeStyle = '#8af';
        ctx.setLineDash([]);
      } else {
        ctx.strokeStyle = 'rgba(136,170,255,0.65)';
        ctx.setLineDash([]);
      }
    } else {
      ctx.strokeStyle = '#8af';
      ctx.setLineDash([]);
    }
    ctx.stroke();
    ctx.setLineDash([]);
  });

  // Draw comparison cubes
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.font = '14px sans-serif';
  ctx.fillStyle = '#8af';
  ctx.textAlign = 'center';
  ctx.fillText('Interpretation A', cx - s * 1.8, cy - s * 0.8);
  ctx.fillText('Interpretation B', cx + s * 1.8, cy - s * 0.8);

  // Mini cube A
  drawMiniCube(cx - s * 1.8, cy, s * 0.3, ang, 'A');
  // Mini cube B
  drawMiniCube(cx + s * 1.8, cy, s * 0.3, ang, 'B');
  ctx.restore();
}

function drawMiniCube(cx, cy, s, ang, interp) {
  const cosA = Math.cos(ang), sinA = Math.sin(ang);
  const cosB = Math.cos(ang * 0.7), sinB = Math.sin(ang * 0.7);
  const verts3D = [[-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],[-1,-1,1],[1,-1,1],[1,1,1],[-1,1,1]];
  function proj(v) {
    let x2 = v[0]*cosA - v[2]*sinA;
    let z2 = v[0]*sinA + v[2]*cosA;
    let y2 = v[1]*cosB - z2*sinB;
    return [cx + x2*s, cy + y2*s];
  }
  const pts = verts3D.map(proj);
  const edges = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
  const front = interp === 'A' ? [4,5,6,7] : [0,1,2,3];

  // Draw filled front face
  const faceVerts = interp === 'A' ? [4,5,6,7] : [0,1,2,3];
  ctx.beginPath();
  ctx.moveTo(pts[faceVerts[0]][0], pts[faceVerts[0]][1]);
  for (let i = 1; i < 4; i++) ctx.lineTo(pts[faceVerts[i]][0], pts[faceVerts[i]][1]);
  ctx.closePath();
  ctx.fillStyle = interp === 'A' ? 'rgba(100,180,255,0.2)' : 'rgba(255,180,100,0.2)';
  ctx.fill();

  edges.forEach(([a,b]) => {
    const isFront = front.includes(a) && front.includes(b);
    ctx.beginPath();
    ctx.moveTo(pts[a][0], pts[a][1]);
    ctx.lineTo(pts[b][0], pts[b][1]);
    ctx.lineWidth = isFront ? 2.5 : 1;
    ctx.strokeStyle = isFront ? '#8af' : 'rgba(136,170,255,0.4)';
    ctx.stroke();
  });
}

// ---- Rubin's Vase ----
function drawRubinVase() {
  const cx = W / 2;
  const cy = H / 2;
  const s = cubeSize * 0.9;
  const m = morphAmt / 100;

  // Vase profile - the curve that defines both the vase and the faces
  ctx.save();

  // Left half
  ctx.beginPath();
  ctx.moveTo(cx, cy - s * 0.8);

  // Forehead
  ctx.bezierCurveTo(
    cx - s * (0.15 + m * 0.15), cy - s * 0.8,
    cx - s * (0.3 + m * 0.1), cy - s * 0.65,
    cx - s * (0.35 + m * 0.05), cy - s * 0.5
  );
  // Nose
  ctx.bezierCurveTo(
    cx - s * (0.4 + m * 0.08), cy - s * 0.35,
    cx - s * (0.45 + m * 0.05), cy - s * 0.2,
    cx - s * (0.35 + m * 0.05), cy - s * 0.05
  );
  // Lips
  ctx.bezierCurveTo(
    cx - s * (0.3 + m * 0.05), cy + s * 0.05,
    cx - s * (0.38 + m * 0.02), cy + s * 0.1,
    cx - s * (0.3 + m * 0.05), cy + s * 0.2
  );
  // Chin
  ctx.bezierCurveTo(
    cx - s * (0.25 + m * 0.05), cy + s * 0.4,
    cx - s * (0.15 + m * 0.1), cy + s * 0.6,
    cx - s * 0.2, cy + s * 0.8
  );

  // Bottom of vase
  ctx.lineTo(cx + s * 0.2, cy + s * 0.8);

  // Right side (mirror)
  ctx.bezierCurveTo(
    cx + s * (0.15 + m * 0.1), cy + s * 0.6,
    cx + s * (0.25 + m * 0.05), cy + s * 0.4,
    cx + s * (0.3 + m * 0.05), cy + s * 0.2
  );
  ctx.bezierCurveTo(
    cx + s * (0.38 + m * 0.02), cy + s * 0.1,
    cx + s * (0.3 + m * 0.05), cy + s * 0.05,
    cx + s * (0.35 + m * 0.05), cy - s * 0.05
  );
  ctx.bezierCurveTo(
    cx + s * (0.45 + m * 0.05), cy - s * 0.2,
    cx + s * (0.4 + m * 0.08), cy - s * 0.35,
    cx + s * (0.35 + m * 0.05), cy - s * 0.5
  );
  ctx.bezierCurveTo(
    cx + s * (0.3 + m * 0.1), cy - s * 0.65,
    cx + s * (0.15 + m * 0.15), cy - s * 0.8,
    cx, cy - s * 0.8
  );

  ctx.closePath();

  // Vase color
  ctx.fillStyle = '#e8e0d0';
  ctx.fill();

  // Background (faces) color
  ctx.restore();

  // Labels
  ctx.font = '14px sans-serif';
  ctx.fillStyle = 'rgba(136,170,255,0.6)';
  ctx.textAlign = 'center';
  ctx.fillText('Vase... or two faces?', cx, cy + s + 30);
}

// ---- Young/Old Woman (geometric) ----
function drawYoungOldWoman() {
  const cx = W / 2;
  const cy = H / 2;
  const s = cubeSize * 0.8;

  ctx.save();
  ctx.strokeStyle = '#d4c8b0';
  ctx.lineWidth = lineWidth;
  ctx.lineCap = 'round';

  // Head outline / hat brim
  ctx.beginPath();
  ctx.moveTo(cx - s * 0.4, cy - s * 0.1);
  ctx.bezierCurveTo(cx - s * 0.35, cy - s * 0.5, cx - s * 0.1, cy - s * 0.7, cx + s * 0.15, cy - s * 0.65);
  ctx.stroke();

  // Feather / hair band
  ctx.beginPath();
  ctx.moveTo(cx + s * 0.15, cy - s * 0.65);
  ctx.bezierCurveTo(cx + s * 0.25, cy - s * 0.8, cx + s * 0.35, cy - s * 0.55, cx + s * 0.2, cy - s * 0.45);
  ctx.stroke();

  // Hat top
  ctx.beginPath();
  ctx.moveTo(cx - s * 0.1, cy - s * 0.55);
  ctx.bezierCurveTo(cx, cy - s * 0.6, cx + s * 0.1, cy - s * 0.58, cx + s * 0.2, cy - s * 0.45);
  ctx.stroke();

  // Ear / eye
  ctx.beginPath();
  ctx.arc(cx - s * 0.12, cy - s * 0.08, s * 0.04, 0, Math.PI * 2);
  ctx.stroke();

  // Necklace / mouth (young) or eye (old)
  ctx.beginPath();
  ctx.moveTo(cx - s * 0.2, cy + s * 0.02);
  ctx.bezierCurveTo(cx - s * 0.15, cy + s * 0.05, cx - s * 0.08, cy + s * 0.04, cx - s * 0.03, cy);
  ctx.stroke();

  // Chin line (young) / nose (old)
  ctx.beginPath();
  ctx.moveTo(cx - s * 0.18, cy + s * 0.0);
  ctx.bezierCurveTo(cx - s * 0.25, cy + s * 0.15, cx - s * 0.28, cy + s * 0.3, cx - s * 0.2, cy + s * 0.4);
  ctx.stroke();

  // Jawline (old) / neck (young)
  ctx.beginPath();
  ctx.moveTo(cx - s * 0.03, cy);
  ctx.bezierCurveTo(cx + s * 0.05, cy + s * 0.1, cx + s * 0.1, cy + s * 0.3, cx + s * 0.05, cy + s * 0.5);
  ctx.stroke();

  // Neck/shoulder
  ctx.beginPath();
  ctx.moveTo(cx - s * 0.2, cy + s * 0.4);
  ctx.bezierCurveTo(cx - s * 0.35, cy + s * 0.55, cx - s * 0.4, cy + s * 0.7, cx - s * 0.3, cy + s * 0.8);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(cx + s * 0.05, cy + s * 0.5);
  ctx.bezierCurveTo(cx + s * 0.15, cy + s * 0.65, cx + s * 0.25, cy + s * 0.75, cx + s * 0.35, cy + s * 0.8);
  ctx.stroke();

  ctx.restore();

  ctx.font = '14px sans-serif';
  ctx.fillStyle = 'rgba(136,170,255,0.6)';
  ctx.textAlign = 'center';
  ctx.fillText('Young woman looking away... or old woman with large nose?', cx, cy + s + 20);
}

// ---- My Wife and Mother-in-Law ----
function drawWifeMotherInLaw() {
  const cx = W / 2;
  const cy = H / 2;
  const s = cubeSize * 0.9;

  ctx.save();
  ctx.strokeStyle = '#d4c8b0';
  ctx.lineWidth = lineWidth;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  // This is a more detailed version of the classic ambiguous figure
  // Headscarf / hair
  ctx.beginPath();
  ctx.moveTo(cx - s * 0.3, cy - s * 0.15);
  ctx.bezierCurveTo(cx - s * 0.28, cy - s * 0.45, cx - s * 0.05, cy - s * 0.7, cx + s * 0.2, cy - s * 0.6);
  ctx.bezierCurveTo(cx + s * 0.3, cy - s * 0.55, cx + s * 0.35, cy - s * 0.35, cx + s * 0.25, cy - s * 0.2);
  ctx.stroke();

  // Hair band / hat feather
  ctx.beginPath();
  ctx.moveTo(cx + s * 0.2, cy - s * 0.6);
  ctx.bezierCurveTo(cx + s * 0.32, cy - s * 0.75, cx + s * 0.4, cy - s * 0.5, cx + s * 0.25, cy - s * 0.38);
  ctx.stroke();

  // Ear (young) / eye (old)
  ctx.beginPath();
  ctx.ellipse(cx - s * 0.08, cy - s * 0.12, s * 0.035, s * 0.05, -0.2, 0, Math.PI * 2);
  ctx.stroke();

  // Necklace (young) / mouth (old)
  ctx.beginPath();
  ctx.moveTo(cx - s * 0.15, cy + s * 0.02);
  ctx.bezierCurveTo(cx - s * 0.1, cy + s * 0.06, cx - s * 0.02, cy + s * 0.05, cx + s * 0.02, cy - s * 0.01);
  ctx.stroke();

  // Jaw/chin (young) / nose (old)
  ctx.beginPath();
  ctx.moveTo(cx - s * 0.12, cy - s * 0.02);
  ctx.bezierCurveTo(cx - s * 0.2, cy + s * 0.12, cx - s * 0.24, cy + s * 0.28, cx - s * 0.15, cy + s * 0.38);
  ctx.stroke();

  // Neck (young) / chin (old)
  ctx.beginPath();
  ctx.moveTo(cx + s * 0.02, cy - s * 0.01);
  ctx.bezierCurveTo(cx + s * 0.08, cy + s * 0.15, cx + s * 0.12, cy + s * 0.35, cx + s * 0.08, cy + s * 0.5);
  ctx.stroke();

  // Shoulders / body
  ctx.beginPath();
  ctx.moveTo(cx - s * 0.15, cy + s * 0.38);
  ctx.bezierCurveTo(cx - s * 0.3, cy + s * 0.5, cx - s * 0.45, cy + s * 0.65, cx - s * 0.4, cy + s * 0.8);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(cx + s * 0.08, cy + s * 0.5);
  ctx.bezierCurveTo(cx + s * 0.2, cy + s * 0.6, cx + s * 0.35, cy + s * 0.7, cx + s * 0.4, cy + s * 0.8);
  ctx.stroke();

  // Wrap
  ctx.beginPath();
  ctx.moveTo(cx - s * 0.3, cy - s * 0.15);
  ctx.bezierCurveTo(cx - s * 0.35, cy + s * 0.1, cx - s * 0.38, cy + s * 0.35, cx - s * 0.3, cy + s * 0.5);
  ctx.stroke();

  ctx.restore();

  ctx.font = '14px sans-serif';
  ctx.fillStyle = 'rgba(136,170,255,0.6)';
  ctx.textAlign = 'center';
  ctx.fillText('"My Wife and My Mother-in-Law" (W.E. Hill, 1915)', cx, cy + s + 20);
}

function draw() {
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, W, H);

  switch (currentTab) {
    case 'necker': drawNeckerCube(); break;
    case 'rubin': drawRubinVase(); break;
    case 'woman': drawYoungOldWoman(); break;
    case 'wife': drawWifeMotherInLaw(); break;
  }

  animId = requestAnimationFrame(draw);
}

// Controls
function bindSlider(id, valId, cb) {
  const el = document.getElementById(id);
  const v = document.getElementById(valId);
  el.addEventListener('input', () => { v.textContent = el.value; cb(parseInt(el.value)); });
}

bindSlider('rotation', 'rotationVal', v => { rotation = v; });
bindSlider('cubeSize', 'cubeSizeVal', v => { cubeSize = v; });
bindSlider('lineW', 'lineWVal', v => { lineWidth = v; });
bindSlider('morphAmt', 'morphVal', v => { morphAmt = v; });

window.reset = function() {
  rotation = 25; cubeSize = 180; lineWidth = 3; morphAmt = 50; bias = 'none';
  currentTab = 'necker';
  document.getElementById('rotation').value = 25;
  document.getElementById('rotationVal').textContent = '25';
  document.getElementById('cubeSize').value = 180;
  document.getElementById('cubeSizeVal').textContent = '180';
  document.getElementById('lineW').value = 3;
  document.getElementById('lineWVal').textContent = '3';
  document.getElementById('morphAmt').value = 50;
  document.getElementById('morphVal').textContent = '50';
  switchTab('necker');
  resetFlipTracker();
};

let resizeTimer;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(resize, 150);
});

resize();
switchTab('necker');
draw();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>