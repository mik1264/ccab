<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hydroelectric Dam Flow</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; }
#title {
    position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
    color: #fbbf24; font-size: 22px; font-weight: 600;
    text-shadow: 0 0 20px rgba(251,191,36,0.5); z-index: 10;
    pointer-events: none; text-align: center;
}
#controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    background: rgba(0,0,0,0.85); border: 1px solid rgba(251,191,36,0.3);
    border-radius: 12px; padding: 14px 20px; display: flex; gap: 20px;
    align-items: center; z-index: 10; flex-wrap: wrap; justify-content: center;
}
.control-group { display: flex; flex-direction: column; align-items: center; gap: 4px; }
label { color: #fbbf24; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; }
input[type="range"] { width: 130px; accent-color: #fbbf24; }
.value-display { color: #fff; font-size: 13px; font-weight: bold; }
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">&#8592; Back to Gallery</a>
<div id="title">Hydroelectric Dam Flow</div>
<canvas id="canvas"></canvas>
<div id="controls">
    <div class="control-group">
        <label>Gate Opening</label>
        <input type="range" id="gateSlider" min="0" max="100" value="50">
        <span class="value-display" id="gateVal">50%</span>
    </div>
    <div class="control-group">
        <label>Rainfall</label>
        <input type="range" id="rainSlider" min="0" max="100" value="30">
        <span class="value-display" id="rainVal">30%</span>
    </div>
    <div class="control-group">
        <label>Demand</label>
        <input type="range" id="demandSlider" min="0" max="100" value="60">
        <span class="value-display" id="demandVal">60%</span>
    </div>
</div>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

let gateOpening = 50;
let rainfall = 30;
let demand = 60;
let waterLevel = 0.7;
let turbineAngle = 0;
let turbineSpeed = 0;
let waterParticles = [];
let rainDrops = [];
let powerOutput = 0;
let flowRate = 0;
let powerHistory = [];
let levelHistory = [];

document.getElementById('gateSlider').addEventListener('input', e => { gateOpening = +e.target.value; document.getElementById('gateVal').textContent = gateOpening + '%'; });
document.getElementById('rainSlider').addEventListener('input', e => { rainfall = +e.target.value; document.getElementById('rainVal').textContent = rainfall + '%'; });
document.getElementById('demandSlider').addEventListener('input', e => { demand = +e.target.value; document.getElementById('demandVal').textContent = demand + '%'; });

function spawnWaterParticle() {
    const damX = W * 0.45;
    const damTop = H * 0.2;
    const damBottom = H * 0.7;
    const gateY = damTop + (damBottom - damTop) * 0.6;
    const gateH = (damBottom - damTop) * 0.15 * (gateOpening / 100);
    if (gateOpening < 5) return;
    waterParticles.push({
        x: damX + 15,
        y: gateY + Math.random() * gateH,
        vx: 2 + Math.random() * 3 + gateOpening * 0.05,
        vy: 0,
        life: 1,
        throughTurbine: false
    });
}

function drawMountains() {
    ctx.fillStyle = '#1a2a1a';
    ctx.beginPath();
    ctx.moveTo(0, H * 0.3);
    ctx.lineTo(W * 0.1, H * 0.15);
    ctx.lineTo(W * 0.2, H * 0.25);
    ctx.lineTo(W * 0.3, H * 0.12);
    ctx.lineTo(W * 0.45, H * 0.2);
    ctx.lineTo(W * 0.55, H * 0.2);
    ctx.lineTo(W * 0.65, H * 0.15);
    ctx.lineTo(W * 0.8, H * 0.25);
    ctx.lineTo(W * 0.9, H * 0.18);
    ctx.lineTo(W, H * 0.3);
    ctx.lineTo(W, H);
    ctx.lineTo(0, H);
    ctx.closePath();
    ctx.fill();
}

function drawDam() {
    const damX = W * 0.43;
    const damW = W * 0.05;
    const damTop = H * 0.18;
    const damBottom = H * 0.72;

    const damGrad = ctx.createLinearGradient(damX, 0, damX + damW, 0);
    damGrad.addColorStop(0, '#555');
    damGrad.addColorStop(0.5, '#777');
    damGrad.addColorStop(1, '#555');
    ctx.fillStyle = damGrad;
    ctx.fillRect(damX, damTop, damW, damBottom - damTop);
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 2;
    ctx.strokeRect(damX, damTop, damW, damBottom - damTop);

    for (let i = 0; i < 8; i++) {
        const y = damTop + i * (damBottom - damTop) / 8;
        ctx.strokeStyle = 'rgba(150,150,150,0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(damX, y);
        ctx.lineTo(damX + damW, y);
        ctx.stroke();
    }

    const gateY = damTop + (damBottom - damTop) * 0.55;
    const gateH = (damBottom - damTop) * 0.15;
    const gateOpenH = gateH * (gateOpening / 100);
    ctx.fillStyle = '#2a4a6a';
    ctx.fillRect(damX + 5, gateY, damW - 10, gateOpenH);
    ctx.fillStyle = '#444';
    ctx.fillRect(damX + 3, gateY + gateOpenH, damW - 6, gateH - gateOpenH);
    ctx.strokeStyle = '#fbbf24';
    ctx.lineWidth = 1;
    ctx.strokeRect(damX + 3, gateY, damW - 6, gateH);

    return { gateY, gateH, damX, damW, damTop, damBottom };
}

function drawReservoir(damX, damTop, damBottom) {
    const wSurface = damTop + (damBottom - damTop) * (1 - waterLevel);
    const resGrad = ctx.createLinearGradient(0, wSurface, 0, damBottom);
    resGrad.addColorStop(0, 'rgba(30,80,140,0.7)');
    resGrad.addColorStop(0.5, 'rgba(20,60,120,0.8)');
    resGrad.addColorStop(1, 'rgba(10,40,80,0.9)');
    ctx.fillStyle = resGrad;
    ctx.beginPath();
    ctx.moveTo(0, wSurface);
    const waveT = Date.now() / 1000;
    for (let x = 0; x <= damX; x += 4) {
        const wave = Math.sin(x * 0.02 + waveT * 2) * 2 + Math.sin(x * 0.01 + waveT) * 1.5;
        ctx.lineTo(x, wSurface + wave);
    }
    ctx.lineTo(damX, damBottom);
    ctx.lineTo(0, damBottom);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = 'rgba(100,180,255,0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let x = 0; x <= damX; x += 3) {
        const wave = Math.sin(x * 0.02 + waveT * 2) * 2 + Math.sin(x * 0.01 + waveT) * 1.5;
        if (x === 0) ctx.moveTo(x, wSurface + wave);
        else ctx.lineTo(x, wSurface + wave);
    }
    ctx.stroke();
}

function drawDownstream(damX, damW, damBottom) {
    const dsY = damBottom - 10;
    const dsGrad = ctx.createLinearGradient(0, dsY, 0, dsY + 60);
    dsGrad.addColorStop(0, 'rgba(30,80,140,0.5)');
    dsGrad.addColorStop(1, 'rgba(20,60,100,0.3)');
    ctx.fillStyle = dsGrad;
    ctx.beginPath();
    ctx.moveTo(damX + damW, dsY);
    const waveT = Date.now() / 1000;
    for (let x = damX + damW; x <= W; x += 4) {
        const wave = Math.sin(x * 0.03 + waveT * 3) * (1 + flowRate * 0.03);
        ctx.lineTo(x, dsY + wave + 5);
    }
    ctx.lineTo(W, dsY + 50);
    ctx.lineTo(damX + damW, dsY + 50);
    ctx.closePath();
    ctx.fill();
}

function drawTurbine(x, y) {
    const r = 25;
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(turbineAngle);
    ctx.strokeStyle = '#aaa';
    ctx.lineWidth = 3;
    for (let i = 0; i < 6; i++) {
        const a = i * Math.PI / 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
        ctx.stroke();
        ctx.beginPath();
        ctx.ellipse(Math.cos(a) * r * 0.5, Math.sin(a) * r * 0.5, 8, 4, a, 0, Math.PI);
        ctx.fillStyle = 'rgba(150,180,200,0.5)';
        ctx.fill();
    }
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, Math.PI * 2);
    ctx.fillStyle = '#888';
    ctx.fill();
    ctx.strokeStyle = '#aaa';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
    ctx.font = '9px sans-serif';
    ctx.fillStyle = '#aaa';
    ctx.textAlign = 'center';
    ctx.fillText('Turbine', x, y + r + 14);
}

function drawGenerator(x, y) {
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    const glow = powerOutput > 10;
    ctx.fillStyle = glow ? 'rgba(251,191,36,0.2)' : 'rgba(50,50,50,0.5)';
    ctx.fill();
    ctx.strokeStyle = glow ? '#fbbf24' : '#555';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = glow ? '#fbbf24' : '#666';
    ctx.font = 'bold 10px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('G', x, y + 4);
    ctx.font = '9px sans-serif';
    ctx.fillStyle = '#aaa';
    ctx.fillText('Generator', x, y + 32);
    if (glow) {
        for (let i = 0; i < 3; i++) {
            const t = (Date.now() / 500 + i * 0.33) % 1;
            const lx = x + 18 + t * 50;
            ctx.beginPath();
            ctx.moveTo(lx, y - 3);
            ctx.lineTo(lx + 5, y);
            ctx.lineTo(lx, y + 3);
            ctx.lineTo(lx + 3, y);
            ctx.closePath();
            ctx.fillStyle = `rgba(251,191,36,${1 - t})`;
            ctx.fill();
        }
    }
}

function drawRain() {
    if (rainfall < 5) return;
    const intensity = rainfall / 100;
    for (let i = rainDrops.length; i < intensity * 80; i++) {
        rainDrops.push({
            x: Math.random() * W * 0.43,
            y: -10 - Math.random() * 50,
            speed: 5 + Math.random() * 5,
            len: 5 + Math.random() * 10
        });
    }
    rainDrops.forEach(d => {
        d.y += d.speed;
        ctx.beginPath();
        ctx.moveTo(d.x, d.y);
        ctx.lineTo(d.x - 0.5, d.y - d.len);
        ctx.strokeStyle = 'rgba(100,150,255,0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();
    });
    rainDrops = rainDrops.filter(d => d.y < H * 0.7);
}

function drawGraph(data, x, y, w, h, label, color, maxV) {
    ctx.fillStyle = 'rgba(0,0,0,0.65)';
    ctx.strokeStyle = 'rgba(251,191,36,0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(x, y, w, h, 8);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = '#fbbf24';
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(label, x + w / 2, y + 14);
    if (data.length < 2) return;
    const gx = x + 8, gy = y + 20, gw = w - 16, gh = h - 28;
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    const start = Math.max(0, data.length - gw);
    for (let i = start; i < data.length; i++) {
        const px = gx + gw - (data.length - 1 - i);
        const py = gy + gh - (data[i] / maxV) * gh;
        if (i === start) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
    }
    ctx.stroke();
}

function drawStats(x, y) {
    ctx.fillStyle = 'rgba(0,0,0,0.75)';
    ctx.strokeStyle = 'rgba(251,191,36,0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(x, y, 190, 130, 10);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = '#fbbf24';
    ctx.font = 'bold 13px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Dam Statistics', x + 12, y + 22);
    const lines = [
        ['Water Level', (waterLevel * 100).toFixed(1) + '%', '#4af'],
        ['Flow Rate', flowRate.toFixed(1) + ' m\u00b3/s', '#4af'],
        ['Turbine RPM', (turbineSpeed * 60 / (2 * Math.PI)).toFixed(0), '#aaa'],
        ['Power Output', powerOutput.toFixed(1) + ' MW', '#fbbf24'],
        ['Gate Opening', gateOpening + '%', '#4f8']
    ];
    lines.forEach((l, i) => {
        ctx.fillStyle = '#888';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(l[0], x + 12, y + 44 + i * 18);
        ctx.fillStyle = l[2];
        ctx.textAlign = 'right';
        ctx.fillText(l[1], x + 178, y + 44 + i * 18);
    });
}

let lastTime = performance.now();
function animate(now) {
    const dt = (now - lastTime) / 1000;
    lastTime = now;

    waterLevel += rainfall * 0.00003 * dt;
    flowRate = gateOpening * waterLevel * 2;
    waterLevel -= flowRate * 0.0001 * dt;
    waterLevel = Math.max(0.05, Math.min(0.95, waterLevel));

    const head = waterLevel * 50;
    powerOutput = 9.81 * 1000 * flowRate * head * 0.85 / 1e6;
    powerOutput = Math.max(0, powerOutput);

    const targetTurbineSpeed = flowRate * 0.15;
    turbineSpeed += (targetTurbineSpeed - turbineSpeed) * dt * 3;
    turbineAngle += turbineSpeed * dt;

    if (Math.random() < flowRate * 0.03) spawnWaterParticle();
    waterParticles.forEach(p => {
        p.vy += 200 * dt;
        p.x += p.vx * dt * 30;
        p.y += p.vy * dt;
        p.life -= dt * 0.8;
    });
    waterParticles = waterParticles.filter(p => p.life > 0 && p.y < H);

    if (now % 50 < 20) {
        powerHistory.push(powerOutput);
        levelHistory.push(waterLevel * 100);
        if (powerHistory.length > 400) { powerHistory.shift(); levelHistory.shift(); }
    }

    ctx.clearRect(0, 0, W, H);
    const skyGrad = ctx.createLinearGradient(0, 0, 0, H * 0.4);
    skyGrad.addColorStop(0, '#0f1a33');
    skyGrad.addColorStop(1, '#1a2844');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#0d1a0d';
    ctx.fillRect(0, H * 0.35, W, H * 0.65);

    drawMountains();
    drawRain();
    const dam = drawDam();
    drawReservoir(dam.damX, dam.damTop, dam.damBottom);
    drawDownstream(dam.damX, dam.damW, dam.damBottom);

    waterParticles.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(80,160,255,${p.life * 0.6})`;
        ctx.fill();
    });

    const turbX = dam.damX + dam.damW + 35;
    const turbY = dam.damTop + (dam.damBottom - dam.damTop) * 0.65;
    drawTurbine(turbX, turbY);
    drawGenerator(turbX + 70, turbY);

    const panelX = W * 0.65;
    drawStats(panelX, 80);
    const gw = Math.min(250, W * 0.28);
    drawGraph(powerHistory, panelX, 230, gw, 100, 'Power Output (MW)', '#fbbf24', 50);
    drawGraph(levelHistory, panelX, 345, gw, 100, 'Water Level (%)', '#4af', 100);

    requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
</script>
</body>
</html>
