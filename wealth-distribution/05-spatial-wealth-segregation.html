<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Spatial Wealth Segregation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #141e30 0%, #243b55 100%);
            color: #fff; padding: 20px; overflow: hidden;
        }
        .container { display: flex; gap: 20px; height: 97vh; }
        .main { flex: 3; display: flex; flex-direction: column; gap: 15px; }
        .sidebar { flex: 1; max-width: 350px; }
        .panel { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; }
        h1 { font-size: 18px; margin-bottom: 10px; color: #64b5f6; }
        canvas { display: block; background: #000; border-radius: 5px; width: 100%; }
        button { padding: 10px; background: #64b5f6; color: #000; border: none; border-radius: 5px; cursor: pointer; margin: 5px 0; font-weight: bold; }
        .stat { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.1); font-size: 12px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="main">
            <div class="panel">
                <h1>Spatial Wealth Segregation - Economic Geography</h1>
                <canvas id="mainCanvas"></canvas>
            </div>
            <div class="panel">
                <h1>Wealth Density Heatmap</h1>
                <canvas id="heatmap"></canvas>
            </div>
        </div>
        <div class="sidebar">
            <div class="panel">
                <button id="resetBtn">Reset</button>
                <button id="pauseBtn">Pause</button>
                <button id="toggleView">Toggle View Mode</button>
            </div>
            <div class="panel"><h1>Stats</h1><div id="stats"></div></div>
            <div class="panel" style="font-size: 12px; line-height: 1.4;">
                Rich agents (blue) monopolize resource-rich peaks.
                Poor agents (red) scrape margins. Middle class (green) occupy decent patches.
                Pure spatial competition creates economic geography.
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('mainCanvas');
        const heatCanvas = document.getElementById('heatmap');
        const ctx = canvas.getContext('2d');
        const heatCtx = heatCanvas.getContext('2d');

        canvas.width = canvas.parentElement.clientWidth - 30;
        canvas.height = canvas.width * 0.75;
        heatCanvas.width = heatCanvas.parentElement.clientWidth - 30;
        heatCanvas.height = 200;

        const GRID = 60, CELL = canvas.width/GRID, AGENTS = 300, MAX_GRAIN = 50;
        let paused = false, tick = 0, showWealthOnly = false;
        let grain = [], maxCap = [], agents = [];

        function init() {
            grain = []; maxCap = [];
            for (let y = 0; y < GRID; y++) {
                grain[y] = []; maxCap[y] = [];
                for (let x = 0; x < GRID; x++) {
                    const d1 = Math.sqrt((x-20)**2 + (y-20)**2);
                    const d2 = Math.sqrt((x-40)**2 + (y-40)**2);
                    const cap = Math.floor(MAX_GRAIN * (Math.exp(-d1*d1/150) + Math.exp(-d2*d2/150)));
                    maxCap[y][x] = cap;
                    grain[y][x] = cap;
                }
            }

            agents = [];
            for (let i = 0; i < AGENTS; i++) {
                agents.push({
                    x: Math.random()*GRID|0, y: Math.random()*GRID|0,
                    wealth: 30 + Math.random()*20,
                    vision: 1 + Math.random()*6|0,
                    metabolism: 1 + Math.random()*4,
                    age: 0, maxAge: 80 + Math.random()*40|0
                });
            }
            tick = 0;
        }

        function update() {
            if (paused) return;
            for (let y = 0; y < GRID; y++) {
                for (let x = 0; x < GRID; x++) {
                    if (grain[y][x] < maxCap[y][x]) grain[y][x]++;
                }
            }
            agents.forEach(a => {
                let [bx,by,bg] = [a.x, a.y, grain[a.y][a.x]];
                for (let dx = -a.vision; dx <= a.vision; dx++) {
                    for (let dy = -a.vision; dy <= a.vision; dy++) {
                        const nx = (a.x+dx+GRID)%GRID, ny = (a.y+dy+GRID)%GRID;
                        if (grain[ny][nx] > bg) { bg = grain[ny][nx]; bx = nx; by = ny; }
                    }
                }
                a.x = bx; a.y = by;
                a.wealth += grain[a.y][a.x];
                grain[a.y][a.x] = 0;
                a.wealth -= a.metabolism;
                a.age++;
            });
            for (let i = agents.length-1; i >= 0; i--) {
                if (agents[i].wealth <= 0 || agents[i].age >= agents[i].maxAge) {
                    agents[i] = {
                        x: Math.random()*GRID|0, y: Math.random()*GRID|0,
                        wealth: 30 + Math.random()*20,
                        vision: 1 + Math.random()*6|0,
                        metabolism: 1 + Math.random()*4,
                        age: 0, maxAge: 80 + Math.random()*40|0
                    };
                }
            }
            tick++;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!showWealthOnly) {
                for (let y = 0; y < GRID; y++) {
                    for (let x = 0; x < GRID; x++) {
                        const i = grain[y][x] / MAX_GRAIN;
                        ctx.fillStyle = `rgba(0, ${Math.floor(i*120)}, 0, 0.6)`;
                        ctx.fillRect(x*CELL, y*CELL, CELL, CELL);
                    }
                }
            }

            agents.forEach(a => {
                const color = a.wealth<25 ? '#f44336' : a.wealth<100 ? '#4caf50' : '#2196f3';
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.85;
                ctx.beginPath();
                ctx.arc(a.x*CELL+CELL/2, a.y*CELL+CELL/2, CELL*0.4, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });

            // Heatmap - wealth density
            heatCtx.fillStyle = '#000';
            heatCtx.fillRect(0, 0, heatCanvas.width, heatCanvas.height);

            const gridSize = 20;
            const cellW = heatCanvas.width / gridSize;
            const cellH = heatCanvas.height / gridSize;
            const densityGrid = Array(gridSize).fill(0).map(() => Array(gridSize).fill({count:0, wealth:0}));

            agents.forEach(a => {
                const gx = Math.floor((a.x / GRID) * gridSize);
                const gy = Math.floor((a.y / GRID) * gridSize);
                if (gx < gridSize && gy < gridSize) {
                    const old = densityGrid[gy][gx];
                    densityGrid[gy][gx] = {count: old.count+1, wealth: old.wealth+a.wealth};
                }
            });

            const maxDensity = Math.max(...densityGrid.flat().map(d => d.wealth));

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const {wealth} = densityGrid[y][x];
                    const intensity = wealth / maxDensity;
                    const r = Math.floor(intensity * 255);
                    const b = Math.floor((1-intensity) * 255);
                    heatCtx.fillStyle = `rgb(${r}, 0, ${b})`;
                    heatCtx.fillRect(x*cellW, y*cellH, cellW, cellH);
                }
            }

            heatCtx.fillStyle = '#fff';
            heatCtx.font = '12px sans-serif';
            heatCtx.fillText('Wealth Density (red=high, blue=low)', 10, 20);

            const sorted = [...agents].sort((a,b) => b.wealth - a.wealth);
            const top20 = sorted.slice(0, Math.floor(agents.length*0.2));
            const bottom20 = sorted.slice(-Math.floor(agents.length*0.2));

            // Calculate spatial concentration
            const calcCentroid = (list) => {
                const x = list.reduce((s,a) => s+a.x, 0) / list.length;
                const y = list.reduce((s,a) => s+a.y, 0) / list.length;
                return {x, y};
            };
            const richCenter = calcCentroid(top20);
            const poorCenter = calcCentroid(bottom20);
            const separation = Math.sqrt((richCenter.x-poorCenter.x)**2 + (richCenter.y-poorCenter.y)**2);

            const avgWealth = agents.reduce((s,a) => s+a.wealth, 0) / agents.length;
            const totalWealth = agents.reduce((s,a) => s+a.wealth, 0);
            const top20Wealth = (top20.reduce((s,a) => s+a.wealth, 0) / totalWealth * 100).toFixed(1);

            document.getElementById('stats').innerHTML = `
                <div class="stat"><span>Tick:</span><span>${tick}</span></div>
                <div class="stat"><span>Avg Wealth:</span><span>${avgWealth.toFixed(1)}</span></div>
                <div class="stat"><span>Top 20% Own:</span><span style="color:#2196f3">${top20Wealth}%</span></div>
                <div class="stat"><span>Rich Center:</span><span>(${richCenter.x.toFixed(1)}, ${richCenter.y.toFixed(1)})</span></div>
                <div class="stat"><span>Poor Center:</span><span>(${poorCenter.x.toFixed(1)}, ${poorCenter.y.toFixed(1)})</span></div>
                <div class="stat"><span>Separation:</span><span>${separation.toFixed(1)} cells</span></div>
            `;
        }

        function animate() { update(); draw(); requestAnimationFrame(animate); }

        document.getElementById('resetBtn').onclick = init;
        document.getElementById('pauseBtn').onclick = () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        };
        document.getElementById('toggleView').onclick = () => {
            showWealthOnly = !showWealthOnly;
        };

        init();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
