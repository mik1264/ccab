<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Wealth Distribution - Sugarscape Model</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            overflow: hidden;
        }
        .container {
            display: flex;
            height: 100vh;
            padding: 20px;
            gap: 20px;
        }
        .main-canvas {
            flex: 2;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
        }
        .sidebar {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 400px;
        }
        .panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
        }
        h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }
        h2 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #4fc3f7;
        }
        canvas {
            display: block;
            background: #000;
            border-radius: 5px;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            font-size: 14px;
            background: #4fc3f7;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }
        button:hover {
            background: #29b6f6;
        }
        .stat {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .stat-label {
            color: #90caf9;
        }
        .stat-value {
            font-weight: bold;
            color: #fff;
        }
        .description {
            font-size: 13px;
            line-height: 1.5;
            color: #b3d9ff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-canvas">
            <h1>Classic Wealth Distribution</h1>
            <canvas id="mainCanvas"></canvas>
            <canvas id="lorenzCanvas" style="margin-top: 15px;"></canvas>
        </div>
        <div class="sidebar">
            <div class="panel">
                <h2>Controls</h2>
                <div class="controls">
                    <button id="resetBtn">Reset Simulation</button>
                    <button id="pauseBtn">Pause</button>
                </div>
            </div>
            <div class="panel">
                <h2>Statistics</h2>
                <div id="stats"></div>
            </div>
            <div class="panel">
                <h2>About</h2>
                <p class="description">
                    Agents (circles) forage for grain (green background) with heterogeneous vision and metabolism.
                    Color indicates wealth: <span style="color: #f44336">red (poor)</span>,
                    <span style="color: #4caf50">green (middle)</span>,
                    <span style="color: #2196f3">blue (rich)</span>.
                    Watch inequality emerge from equal starting conditions.
                </p>
            </div>
        </div>
    </div>

    <script>
        const mainCanvas = document.getElementById('mainCanvas');
        const lorenzCanvas = document.getElementById('lorenzCanvas');
        const mainCtx = mainCanvas.getContext('2d');
        const lorenzCtx = lorenzCanvas.getContext('2d');

        // Sizing
        mainCanvas.width = mainCanvas.parentElement.clientWidth - 30;
        mainCanvas.height = mainCanvas.width * 0.7;
        lorenzCanvas.width = lorenzCanvas.parentElement.clientWidth - 30;
        lorenzCanvas.height = 250;

        // Parameters
        const GRID_SIZE = 50;
        const CELL_SIZE = mainCanvas.width / GRID_SIZE;
        const AGENT_COUNT = 250;
        const MAX_GRAIN = 50;
        const GRAIN_GROWTH = 1;

        let paused = false;
        let tick = 0;

        // Grain environment
        let grainGrid = [];
        let maxCapacity = [];

        // Agents
        class Agent {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.wealth = 25 + Math.random() * 25; // Start with 25-50
                this.vision = Math.floor(1 + Math.random() * 6); // 1-6 cells
                this.metabolism = 1 + Math.random() * 4; // 1-5 per tick
                this.age = 0;
                this.maxAge = 60 + Math.random() * 60; // 60-120 ticks
            }

            look() {
                let bestX = this.x;
                let bestY = this.y;
                let bestGrain = grainGrid[this.y][this.x];

                for (let dx = -this.vision; dx <= this.vision; dx++) {
                    for (let dy = -this.vision; dy <= this.vision; dy++) {
                        const nx = (this.x + dx + GRID_SIZE) % GRID_SIZE;
                        const ny = (this.y + dy + GRID_SIZE) % GRID_SIZE;
                        if (grainGrid[ny][nx] > bestGrain) {
                            bestGrain = grainGrid[ny][nx];
                            bestX = nx;
                            bestY = ny;
                        }
                    }
                }

                this.x = bestX;
                this.y = bestY;
            }

            harvest() {
                this.wealth += grainGrid[this.y][this.x];
                grainGrid[this.y][this.x] = 0;
            }

            consume() {
                this.wealth -= this.metabolism;
                this.age++;
            }

            isDead() {
                return this.wealth <= 0 || this.age >= this.maxAge;
            }

            getColor() {
                if (this.wealth < 20) return '#f44336'; // Red - poor
                if (this.wealth < 100) return '#4caf50'; // Green - middle
                return '#2196f3'; // Blue - rich
            }
        }

        let agents = [];

        // Initialize
        function init() {
            // Create grain grid with two peaks
            grainGrid = [];
            maxCapacity = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                grainGrid[y] = [];
                maxCapacity[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    // Two Gaussian peaks
                    const d1 = Math.sqrt((x - 15) ** 2 + (y - 15) ** 2);
                    const d2 = Math.sqrt((x - 35) ** 2 + (y - 35) ** 2);
                    const capacity = Math.floor(MAX_GRAIN * (Math.exp(-d1 * d1 / 200) + Math.exp(-d2 * d2 / 200)));
                    maxCapacity[y][x] = capacity;
                    grainGrid[y][x] = capacity;
                }
            }

            // Create agents
            agents = [];
            for (let i = 0; i < AGENT_COUNT; i++) {
                agents.push(new Agent(
                    Math.floor(Math.random() * GRID_SIZE),
                    Math.floor(Math.random() * GRID_SIZE)
                ));
            }

            tick = 0;
        }

        // Update
        function update() {
            if (paused) return;

            // Grow grain
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grainGrid[y][x] < maxCapacity[y][x]) {
                        grainGrid[y][x] = Math.min(grainGrid[y][x] + GRAIN_GROWTH, maxCapacity[y][x]);
                    }
                }
            }

            // Agent behavior
            agents.forEach(agent => {
                agent.look();
                agent.harvest();
                agent.consume();
            });

            // Replace dead agents (maintain constant population)
            for (let i = agents.length - 1; i >= 0; i--) {
                if (agents[i].isDead()) {
                    agents[i] = new Agent(
                        Math.floor(Math.random() * GRID_SIZE),
                        Math.floor(Math.random() * GRID_SIZE)
                    );
                }
            }

            tick++;
        }

        // Draw grain layer
        function drawGrain() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const intensity = grainGrid[y][x] / MAX_GRAIN;
                    mainCtx.fillStyle = `rgba(0, ${Math.floor(intensity * 150)}, 0, 0.8)`;
                    mainCtx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }
        }

        // Draw agents
        function drawAgents() {
            agents.forEach(agent => {
                mainCtx.fillStyle = agent.getColor();
                mainCtx.beginPath();
                mainCtx.arc(
                    agent.x * CELL_SIZE + CELL_SIZE / 2,
                    agent.y * CELL_SIZE + CELL_SIZE / 2,
                    CELL_SIZE * 0.4,
                    0,
                    Math.PI * 2
                );
                mainCtx.fill();
            });
        }

        // Calculate Gini coefficient and draw Lorenz curve
        function drawLorenzCurve() {
            lorenzCtx.fillStyle = '#000';
            lorenzCtx.fillRect(0, 0, lorenzCanvas.width, lorenzCanvas.height);

            // Sort agents by wealth
            const sorted = [...agents].sort((a, b) => a.wealth - b.wealth);
            const totalWealth = sorted.reduce((sum, a) => sum + a.wealth, 0);

            // Draw Lorenz curve
            lorenzCtx.strokeStyle = '#4fc3f7';
            lorenzCtx.lineWidth = 2;
            lorenzCtx.beginPath();

            const padding = 40;
            const width = lorenzCanvas.width - 2 * padding;
            const height = lorenzCanvas.height - 2 * padding;

            let cumulativeWealth = 0;
            let giniArea = 0;

            lorenzCtx.moveTo(padding, lorenzCanvas.height - padding);

            for (let i = 0; i < sorted.length; i++) {
                cumulativeWealth += sorted[i].wealth;
                const x = padding + (i / sorted.length) * width;
                const y = lorenzCanvas.height - padding - (cumulativeWealth / totalWealth) * height;
                lorenzCtx.lineTo(x, y);

                // Calculate area for Gini
                if (i > 0) {
                    giniArea += (cumulativeWealth / totalWealth) / sorted.length;
                }
            }

            lorenzCtx.stroke();

            // Draw equality line
            lorenzCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            lorenzCtx.lineWidth = 1;
            lorenzCtx.setLineDash([5, 5]);
            lorenzCtx.beginPath();
            lorenzCtx.moveTo(padding, lorenzCanvas.height - padding);
            lorenzCtx.lineTo(lorenzCanvas.width - padding, padding);
            lorenzCtx.stroke();
            lorenzCtx.setLineDash([]);

            // Calculate Gini coefficient
            const gini = 1 - 2 * giniArea;

            // Draw axes and labels
            lorenzCtx.fillStyle = '#fff';
            lorenzCtx.font = '12px sans-serif';
            lorenzCtx.fillText('Lorenz Curve - Wealth Inequality', padding, 20);
            lorenzCtx.fillText('Population %', lorenzCanvas.width / 2 - 30, lorenzCanvas.height - 5);
            lorenzCtx.save();
            lorenzCtx.translate(15, lorenzCanvas.height / 2);
            lorenzCtx.rotate(-Math.PI / 2);
            lorenzCtx.fillText('Wealth %', -30, 0);
            lorenzCtx.restore();
            lorenzCtx.fillText(`Gini: ${gini.toFixed(3)}`, lorenzCanvas.width - padding - 80, 20);

            return gini;
        }

        // Update statistics
        function updateStats(gini) {
            const totalWealth = agents.reduce((sum, a) => sum + a.wealth, 0);
            const avgWealth = totalWealth / agents.length;
            const maxWealth = Math.max(...agents.map(a => a.wealth));
            const minWealth = Math.min(...agents.map(a => a.wealth));
            const avgVision = agents.reduce((sum, a) => sum + a.vision, 0) / agents.length;
            const avgMetabolism = agents.reduce((sum, a) => sum + a.metabolism, 0) / agents.length;

            const sorted = [...agents].sort((a, b) => a.wealth - b.wealth);
            const top20Wealth = sorted.slice(-Math.floor(agents.length * 0.2))
                .reduce((sum, a) => sum + a.wealth, 0);
            const top20Percent = (top20Wealth / totalWealth * 100).toFixed(1);

            const statsHTML = `
                <div class="stat"><span class="stat-label">Tick:</span><span class="stat-value">${tick}</span></div>
                <div class="stat"><span class="stat-label">Agents:</span><span class="stat-value">${agents.length}</span></div>
                <div class="stat"><span class="stat-label">Avg Wealth:</span><span class="stat-value">${avgWealth.toFixed(1)}</span></div>
                <div class="stat"><span class="stat-label">Max Wealth:</span><span class="stat-value">${maxWealth.toFixed(1)}</span></div>
                <div class="stat"><span class="stat-label">Min Wealth:</span><span class="stat-value">${minWealth.toFixed(1)}</span></div>
                <div class="stat"><span class="stat-label">Gini Coeff:</span><span class="stat-value">${gini.toFixed(3)}</span></div>
                <div class="stat"><span class="stat-label">Top 20% Own:</span><span class="stat-value">${top20Percent}%</span></div>
                <div class="stat"><span class="stat-label">Avg Vision:</span><span class="stat-value">${avgVision.toFixed(1)}</span></div>
                <div class="stat"><span class="stat-label">Avg Metabolism:</span><span class="stat-value">${avgMetabolism.toFixed(1)}</span></div>
            `;
            document.getElementById('stats').innerHTML = statsHTML;
        }

        // Main loop
        function animate() {
            update();

            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            drawGrain();
            drawAgents();

            const gini = drawLorenzCurve();
            updateStats(gini);

            requestAnimationFrame(animate);
        }

        // Controls
        document.getElementById('resetBtn').addEventListener('click', init);
        document.getElementById('pauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        });

        // Start
        init();
        animate();
    </script>
</body>
</html>
