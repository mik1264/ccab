<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pareto Principle (80-20 Rule) Demonstration</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #12c2e9 0%, #c471ed 50%, #f64f59 100%);
            color: #fff; padding: 20px;
        }
        .container { display: flex; gap: 20px; height: 97vh; }
        .main { flex: 3; display: flex; flex-direction: column; gap: 15px; }
        .panel { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; }
        .sidebar { flex: 1; max-width: 320px; }
        h1 { font-size: 17px; margin-bottom: 10px; }
        canvas { display: block; background: #000; border-radius: 5px; width: 100%; }
        button { padding: 10px; background: #fff; color: #c471ed; border: none; border-radius: 5px; cursor: pointer; margin: 5px 0; font-weight: bold; }
        .stat { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.1); font-size: 12px; }
        .highlight { color: #ffeb3b; font-weight: bold; font-size: 14px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="main">
            <div class="panel"><h1>Wealth Distribution</h1><canvas id="mainCanvas"></canvas></div>
            <div class="panel"><h1>Pareto Chart: Cumulative Wealth %</h1><canvas id="paretoCanvas"></canvas></div>
            <div class="panel"><h1>80-20 Visualization</h1><canvas id="pieCanvas"></canvas></div>
        </div>
        <div class="sidebar">
            <div class="panel"><button id="resetBtn">Reset</button><button id="pauseBtn">Pause</button></div>
            <div class="panel">
                <h1>Pareto Analysis</h1>
                <div id="stats"></div>
            </div>
            <div class="panel" style="font-size: 11px; line-height: 1.3;">
                <strong>Pareto Principle:</strong> Small % of population owns large % of wealth.
                Emerges naturally from heterogeneous foraging despite equal starting conditions.
            </div>
        </div>
    </div>
    <script>
        const mainCanvas = document.getElementById('mainCanvas');
        const paretoCanvas = document.getElementById('paretoCanvas');
        const pieCanvas = document.getElementById('pieCanvas');
        const [mainCtx, paretoCtx, pieCtx] = [mainCanvas, paretoCanvas, pieCanvas].map(c => c.getContext('2d'));

        mainCanvas.width = mainCanvas.parentElement.clientWidth - 30;
        mainCanvas.height = 260;
        paretoCanvas.width = paretoCanvas.parentElement.clientWidth - 30;
        paretoCanvas.height = 240;
        pieCanvas.width = pieCanvas.parentElement.clientWidth - 30;
        pieCanvas.height = 220;

        const GRID = 50, AGENTS = 200, MAX_GRAIN = 50;
        let paused = false, tick = 0;
        let grain = [], maxCap = [], agents = [];

        function init() {
            grain = []; maxCap = [];
            for (let y = 0; y < GRID; y++) {
                grain[y] = []; maxCap[y] = [];
                for (let x = 0; x < GRID; x++) {
                    const d = Math.sqrt((x-25)**2 + (y-25)**2);
                    const cap = Math.floor(MAX_GRAIN * Math.exp(-d*d/200));
                    maxCap[y][x] = cap; grain[y][x] = cap;
                }
            }
            agents = [];
            for (let i = 0; i < AGENTS; i++) {
                agents.push({
                    x: Math.random()*GRID|0, y: Math.random()*GRID|0,
                    wealth: 30, vision: 1 + Math.random()*6|0,
                    metabolism: 1 + Math.random()*4, age: 0, maxAge: 80
                });
            }
            tick = 0;
        }

        function update() {
            if (paused) return;
            for (let y = 0; y < GRID; y++) {
                for (let x = 0; x < GRID; x++) {
                    if (grain[y][x] < maxCap[y][x]) grain[y][x]++;
                }
            }
            agents.forEach(a => {
                let [bx,by,bg] = [a.x, a.y, grain[a.y][a.x]];
                for (let dx = -a.vision; dx <= a.vision; dx++) {
                    for (let dy = -a.vision; dy <= a.vision; dy++) {
                        const nx = (a.x+dx+GRID)%GRID, ny = (a.y+dy+GRID)%GRID;
                        if (grain[ny][nx] > bg) { bg = grain[ny][nx]; bx = nx; by = ny; }
                    }
                }
                a.x = bx; a.y = by;
                a.wealth += grain[a.y][a.x];
                grain[a.y][a.x] = 0;
                a.wealth -= a.metabolism;
                a.age++;
            });
            for (let i = agents.length-1; i >= 0; i--) {
                if (agents[i].wealth <= 0 || agents[i].age >= agents[i].maxAge) {
                    agents[i] = {
                        x: Math.random()*GRID|0, y: Math.random()*GRID|0,
                        wealth: 30, vision: 1 + Math.random()*6|0,
                        metabolism: 1 + Math.random()*4, age: 0, maxAge: 80
                    };
                }
            }
            tick++;
        }

        function draw() {
            const cellSize = mainCanvas.width / GRID;
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);

            for (let y = 0; y < GRID; y++) {
                for (let x = 0; x < GRID; x++) {
                    const i = grain[y][x] / MAX_GRAIN;
                    mainCtx.fillStyle = `rgba(0, ${Math.floor(i*120)}, 0, 0.6)`;
                    mainCtx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
                }
            }
            agents.forEach(a => {
                const color = a.wealth<25 ? '#f44336' : a.wealth<90 ? '#4caf50' : '#2196f3';
                mainCtx.fillStyle = color;
                mainCtx.beginPath();
                mainCtx.arc(a.x*cellSize+cellSize/2, a.y*cellSize+cellSize/2, cellSize*0.4, 0, Math.PI*2);
                mainCtx.fill();
            });

            // Pareto chart
            paretoCtx.fillStyle = '#000';
            paretoCtx.fillRect(0, 0, paretoCanvas.width, paretoCanvas.height);

            const sorted = [...agents].sort((a,b) => b.wealth - a.wealth);
            const totalWealth = sorted.reduce((s,a) => s+a.wealth, 0);

            const pad = 50, w = paretoCanvas.width - 2*pad, h = paretoCanvas.height - 2*pad;

            // Bar chart
            const barWidth = w / AGENTS;
            sorted.forEach((a, i) => {
                const bh = (a.wealth / sorted[0].wealth) * h * 0.5;
                const x = pad + i * barWidth;
                const y = paretoCanvas.height - pad - bh;

                const color = i < AGENTS*0.2 ? '#e91e63' : '#4fc3f7';
                paretoCtx.fillStyle = color;
                paretoCtx.fillRect(x, y, barWidth, bh);
            });

            // Cumulative line
            paretoCtx.strokeStyle = '#ffeb3b';
            paretoCtx.lineWidth = 3;
            paretoCtx.beginPath();

            let cumWealth = 0;
            sorted.forEach((a, i) => {
                cumWealth += a.wealth;
                const x = pad + i * barWidth + barWidth/2;
                const y = paretoCanvas.height - pad - (cumWealth / totalWealth) * h;
                i === 0 ? paretoCtx.moveTo(x, y) : paretoCtx.lineTo(x, y);
            });
            paretoCtx.stroke();

            // 80% line
            paretoCtx.strokeStyle = '#fff';
            paretoCtx.setLineDash([5, 5]);
            paretoCtx.lineWidth = 1;
            const y80 = paretoCanvas.height - pad - 0.8 * h;
            paretoCtx.beginPath();
            paretoCtx.moveTo(pad, y80);
            paretoCtx.lineTo(pad + w, y80);
            paretoCtx.stroke();
            paretoCtx.setLineDash([]);

            // Find where cumulative crosses 80%
            cumWealth = 0;
            let crossIndex = 0;
            for (let i = 0; i < sorted.length; i++) {
                cumWealth += sorted[i].wealth;
                if (cumWealth / totalWealth >= 0.8) {
                    crossIndex = i;
                    break;
                }
            }

            const crossX = pad + crossIndex * barWidth;
            paretoCtx.strokeStyle = '#ffeb3b';
            paretoCtx.lineWidth = 2;
            paretoCtx.beginPath();
            paretoCtx.moveTo(crossX, paretoCanvas.height - pad);
            paretoCtx.lineTo(crossX, y80);
            paretoCtx.stroke();

            paretoCtx.strokeStyle = '#fff';
            paretoCtx.strokeRect(pad, pad, w, h);
            paretoCtx.fillStyle = '#fff';
            paretoCtx.font = '12px sans-serif';
            paretoCtx.fillText('Agents (sorted by wealth) â†’', paretoCanvas.width/2-70, paretoCanvas.height-5);
            paretoCtx.save();
            paretoCtx.translate(10, paretoCanvas.height/2);
            paretoCtx.rotate(-Math.PI/2);
            paretoCtx.fillText('Wealth / Cumulative %', -60, 0);
            paretoCtx.restore();

            paretoCtx.fillStyle = '#ffeb3b';
            paretoCtx.fillText(`Top ${((crossIndex/AGENTS)*100).toFixed(0)}% owns 80%`, crossX+5, y80-10);

            // Pie chart - 80-20 visualization
            pieCtx.fillStyle = '#000';
            pieCtx.fillRect(0, 0, pieCanvas.width, pieCanvas.height);

            const cx = pieCanvas.width / 2, cy = pieCanvas.height / 2, r = Math.min(pieCanvas.width, pieCanvas.height) / 3;

            const top20 = sorted.slice(0, Math.floor(AGENTS*0.2));
            const bottom80 = sorted.slice(Math.floor(AGENTS*0.2));
            const top20Wealth = top20.reduce((s,a) => s+a.wealth, 0);
            const bottom80Wealth = bottom80.reduce((s,a) => s+a.wealth, 0);

            const top20Angle = (top20Wealth / totalWealth) * Math.PI * 2;

            // Top 20%
            pieCtx.fillStyle = '#e91e63';
            pieCtx.beginPath();
            pieCtx.moveTo(cx, cy);
            pieCtx.arc(cx, cy, r, -Math.PI/2, -Math.PI/2 + top20Angle);
            pieCtx.closePath();
            pieCtx.fill();

            // Bottom 80%
            pieCtx.fillStyle = '#4fc3f7';
            pieCtx.beginPath();
            pieCtx.moveTo(cx, cy);
            pieCtx.arc(cx, cy, r, -Math.PI/2 + top20Angle, -Math.PI/2 + Math.PI*2);
            pieCtx.closePath();
            pieCtx.fill();

            // Labels
            pieCtx.fillStyle = '#fff';
            pieCtx.font = '14px sans-serif';
            pieCtx.textAlign = 'center';

            const top20Percent = (top20Wealth / totalWealth * 100).toFixed(1);
            const bottom80Percent = (bottom80Wealth / totalWealth * 100).toFixed(1);

            pieCtx.fillText(`Top 20%`, cx - r/2, cy - r/2);
            pieCtx.fillText(`${top20Percent}% wealth`, cx - r/2, cy - r/2 + 20);

            pieCtx.fillText(`Bottom 80%`, cx + r/2, cy + r/2);
            pieCtx.fillText(`${bottom80Percent}% wealth`, cx + r/2, cy + r/2 + 20);

            pieCtx.fillStyle = '#fff';
            pieCtx.font = '16px sans-serif';
            pieCtx.fillText('Pareto Distribution', cx, cy - r - 20);

            // Stats
            const paretoRatio = (top20Wealth / totalWealth * 100).toFixed(1);
            const ideal80_20 = Math.abs(80 - parseFloat(paretoRatio));

            document.getElementById('stats').innerHTML = `
                <div class="stat"><span>Tick:</span><span>${tick}</span></div>
                <div class="stat"><span class="highlight">Top 20% Own:</span><span class="highlight">${paretoRatio}%</span></div>
                <div class="stat"><span>Bottom 80% Own:</span><span>${bottom80Percent}%</span></div>
                <div class="stat"><span>80-20 Deviation:</span><span>${ideal80_20.toFixed(1)}%</span></div>
                <div class="stat"><span>Top 10% Own:</span><span>${(sorted.slice(0,Math.floor(AGENTS*0.1)).reduce((s,a)=>s+a.wealth,0)/totalWealth*100).toFixed(1)}%</span></div>
                <div class="stat"><span>Top 1% Own:</span><span>${(sorted.slice(0,Math.floor(AGENTS*0.01)).reduce((s,a)=>s+a.wealth,0)/totalWealth*100).toFixed(1)}%</span></div>
                <div class="stat"><span>Gini:</span><span>${calcGini().toFixed(3)}</span></div>
            `;
        }

        function calcGini() {
            const sorted = agents.map(a => a.wealth).sort((a,b) => a-b);
            const total = sorted.reduce((s,w) => s+w, 0);
            if (total === 0) return 0;
            let area = 0;
            for (let i = 0; i < sorted.length; i++) {
                area += sorted[i] / total;
            }
            return 1 - 2*area/sorted.length;
        }

        function animate() { update(); draw(); requestAnimationFrame(animate); }

        document.getElementById('resetBtn').onclick = init;
        document.getElementById('pauseBtn').onclick = () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        };

        init();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
