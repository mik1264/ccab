<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sparse vs Dense Resource Distribution</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #fc4a1a 0%, #f7b733 100%);
            color: #fff; padding: 20px;
        }
        .container { display: flex; gap: 20px; height: 97vh; }
        .main { flex: 3; display: flex; flex-direction: column; gap: 15px; }
        .row { display: flex; gap: 15px; flex: 1; }
        .panel { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; flex: 1; }
        .sidebar { flex: 1; max-width: 300px; }
        h1 { font-size: 16px; margin-bottom: 10px; }
        canvas { display: block; background: #000; border-radius: 5px; width: 100%; }
        button { padding: 10px; background: #fff; color: #fc4a1a; border: none; border-radius: 5px; cursor: pointer; margin: 5px 0; font-weight: bold; }
        .stat { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.1); font-size: 12px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="main">
            <div class="row">
                <div class="panel"><h1>Sparse (Single Peak)</h1><canvas id="sparseCanvas"></canvas></div>
                <div class="panel"><h1>Dense (Uniform)</h1><canvas id="denseCanvas"></canvas></div>
            </div>
            <div class="row">
                <div class="panel"><h1>Spatial Wealth Concentration</h1><canvas id="heatCanvas"></canvas></div>
            </div>
        </div>
        <div class="sidebar">
            <div class="panel"><button id="resetBtn">Reset</button><button id="pauseBtn">Pause</button></div>
            <div class="panel"><h1>Stats</h1><div id="stats"></div></div>
            <div class="panel" style="font-size: 11px; line-height: 1.3;">
                Sparse resources create hotspots and extreme inequality.
                Dense/uniform distribution reduces spatial advantages, moderating inequality.
            </div>
        </div>
    </div>
    <script>
        const sparseCanvas = document.getElementById('sparseCanvas');
        const denseCanvas = document.getElementById('denseCanvas');
        const heatCanvas = document.getElementById('heatCanvas');
        const [sparseCtx, denseCtx, heatCtx] = [sparseCanvas, denseCanvas, heatCanvas].map(c => c.getContext('2d'));

        const size = 300;
        sparseCanvas.width = denseCanvas.width = size;
        sparseCanvas.height = denseCanvas.height = size;
        heatCanvas.width = heatCanvas.parentElement.clientWidth - 30;
        heatCanvas.height = 200;

        const GRID = 42, CELL = size/GRID, AGENTS = 140, MAX_GRAIN = 50;
        let paused = false, tick = 0;

        class Env {
            constructor(sparse) {
                this.sparse = sparse;
                this.grain = []; this.maxCap = []; this.agents = [];
                this.init();
            }
            init() {
                for (let y = 0; y < GRID; y++) {
                    this.grain[y] = []; this.maxCap[y] = [];
                    for (let x = 0; x < GRID; x++) {
                        let cap;
                        if (this.sparse) {
                            const d = Math.sqrt((x-21)**2 + (y-21)**2);
                            cap = Math.floor(MAX_GRAIN * Math.exp(-d*d/120));
                        } else {
                            cap = Math.floor(MAX_GRAIN * (0.3 + Math.random()*0.4));
                        }
                        this.maxCap[y][x] = cap; this.grain[y][x] = cap;
                    }
                }
                for (let i = 0; i < AGENTS; i++) {
                    this.agents.push({
                        x: Math.random()*GRID|0, y: Math.random()*GRID|0,
                        wealth: 30, vision: 1 + Math.random()*6|0,
                        metabolism: 1 + Math.random()*4, age: 0, maxAge: 80
                    });
                }
            }
            update() {
                for (let y = 0; y < GRID; y++) {
                    for (let x = 0; x < GRID; x++) {
                        if (this.grain[y][x] < this.maxCap[y][x]) this.grain[y][x]++;
                    }
                }
                this.agents.forEach(a => {
                    let [bx,by,bg] = [a.x, a.y, this.grain[a.y][a.x]];
                    for (let dx = -a.vision; dx <= a.vision; dx++) {
                        for (let dy = -a.vision; dy <= a.vision; dy++) {
                            const nx = (a.x+dx+GRID)%GRID, ny = (a.y+dy+GRID)%GRID;
                            if (this.grain[ny][nx] > bg) { bg = this.grain[ny][nx]; bx = nx; by = ny; }
                        }
                    }
                    a.x = bx; a.y = by;
                    a.wealth += this.grain[a.y][a.x];
                    this.grain[a.y][a.x] = 0;
                    a.wealth -= a.metabolism;
                    a.age++;
                });
                for (let i = this.agents.length-1; i >= 0; i--) {
                    if (this.agents[i].wealth <= 0 || this.agents[i].age >= this.agents[i].maxAge) {
                        this.agents[i] = {
                            x: Math.random()*GRID|0, y: Math.random()*GRID|0,
                            wealth: 30, vision: 1 + Math.random()*6|0,
                            metabolism: 1 + Math.random()*4, age: 0, maxAge: 80
                        };
                    }
                }
            }
            calcGini() {
                const sorted = this.agents.map(a => a.wealth).sort((a,b) => a-b);
                const total = sorted.reduce((s,w) => s+w, 0);
                if (total === 0) return 0;
                let area = 0;
                for (let i = 0; i < sorted.length; i++) {
                    area += sorted[i] / total;
                }
                return 1 - 2*area/sorted.length;
            }
            calcSpatialConcentration() {
                const sorted = [...this.agents].sort((a,b) => b.wealth - a.wealth);
                const top20 = sorted.slice(0, Math.floor(this.agents.length * 0.2));
                const cx = top20.reduce((s,a) => s+a.x, 0) / top20.length;
                const cy = top20.reduce((s,a) => s+a.y, 0) / top20.length;
                const avgDist = top20.reduce((s,a) => s + Math.sqrt((a.x-cx)**2 + (a.y-cy)**2), 0) / top20.length;
                return avgDist;
            }
            draw(ctx) {
                for (let y = 0; y < GRID; y++) {
                    for (let x = 0; x < GRID; x++) {
                        const i = this.grain[y][x] / MAX_GRAIN;
                        ctx.fillStyle = `rgba(0, ${Math.floor(i*120)}, 0, 0.6)`;
                        ctx.fillRect(x*CELL, y*CELL, CELL, CELL);
                    }
                }
                this.agents.forEach(a => {
                    const color = a.wealth<25 ? '#f44336' : a.wealth<80 ? '#4caf50' : '#2196f3';
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(a.x*CELL+CELL/2, a.y*CELL+CELL/2, CELL*0.35, 0, Math.PI*2);
                    ctx.fill();
                });
            }
        }

        let sparseEnv = new Env(true);
        let denseEnv = new Env(false);

        function update() {
            if (!paused) {
                sparseEnv.update();
                denseEnv.update();
                tick++;
            }
        }

        function draw() {
            sparseCtx.clearRect(0, 0, size, size);
            denseCtx.clearRect(0, 0, size, size);
            sparseEnv.draw(sparseCtx);
            denseEnv.draw(denseCtx);

            // Heatmap comparison
            heatCtx.fillStyle = '#000';
            heatCtx.fillRect(0, 0, heatCanvas.width, heatCanvas.height);

            const gridSize = 15;
            const cellW = heatCanvas.width / (gridSize * 2 + 2);
            const cellH = heatCanvas.height / gridSize;

            const sparseGrid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
            const denseGrid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));

            sparseEnv.agents.forEach(a => {
                const gx = Math.floor((a.x / GRID) * gridSize);
                const gy = Math.floor((a.y / GRID) * gridSize);
                if (gx < gridSize && gy < gridSize) {
                    sparseGrid[gy][gx] += a.wealth;
                }
            });

            denseEnv.agents.forEach(a => {
                const gx = Math.floor((a.x / GRID) * gridSize);
                const gy = Math.floor((a.y / GRID) * gridSize);
                if (gx < gridSize && gy < gridSize) {
                    denseGrid[gy][gx] += a.wealth;
                }
            });

            const maxWealth = Math.max(
                ...sparseGrid.flat(),
                ...denseGrid.flat()
            );

            // Draw sparse heatmap
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const i = sparseGrid[y][x] / maxWealth;
                    const r = Math.floor(i * 255);
                    heatCtx.fillStyle = `rgb(${r}, 0, ${255-r})`;
                    heatCtx.fillRect(x*cellW, y*cellH, cellW, cellH);
                }
            }

            // Draw dense heatmap
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const i = denseGrid[y][x] / maxWealth;
                    const r = Math.floor(i * 255);
                    heatCtx.fillStyle = `rgb(${r}, 0, ${255-r})`;
                    heatCtx.fillRect((gridSize+1+x)*cellW, y*cellH, cellW, cellH);
                }
            }

            heatCtx.fillStyle = '#fff';
            heatCtx.font = '12px sans-serif';
            heatCtx.fillText('Sparse', gridSize*cellW/2-20, heatCanvas.height-5);
            heatCtx.fillText('Dense', (gridSize*1.5+1)*cellW-15, heatCanvas.height-5);

            const sparseGini = sparseEnv.calcGini();
            const denseGini = denseEnv.calcGini();
            const sparseConc = sparseEnv.calcSpatialConcentration();
            const denseConc = denseEnv.calcSpatialConcentration();

            document.getElementById('stats').innerHTML = `
                <div class="stat"><span>Tick:</span><span>${tick}</span></div>
                <div class="stat"><span>Sparse Gini:</span><span>${sparseGini.toFixed(3)}</span></div>
                <div class="stat"><span>Dense Gini:</span><span>${denseGini.toFixed(3)}</span></div>
                <div class="stat"><span>Sparse Cluster:</span><span>${sparseConc.toFixed(1)}</span></div>
                <div class="stat"><span>Dense Cluster:</span><span>${denseConc.toFixed(1)}</span></div>
                <div class="stat"><span>Gini Diff:</span><span>${(sparseGini-denseGini).toFixed(3)}</span></div>
            `;
        }

        function animate() { update(); draw(); requestAnimationFrame(animate); }

        document.getElementById('resetBtn').onclick = () => {
            sparseEnv = new Env(true);
            denseEnv = new Env(false);
            tick = 0;
        };
        document.getElementById('pauseBtn').onclick = () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        };

        animate();
    </script>
</body>
</html>
