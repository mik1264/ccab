<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Multi-Generation Wealth Analysis</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #3a1c71 0%, #d76d77 50%, #ffaf7b 100%);
            color: #fff; padding: 20px;
        }
        .container { display: flex; gap: 20px; height: 97vh; }
        .main { flex: 3; display: flex; flex-direction: column; gap: 15px; }
        .panel { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; }
        .sidebar { flex: 1; max-width: 300px; }
        h1 { font-size: 17px; margin-bottom: 10px; }
        canvas { display: block; background: #000; border-radius: 5px; width: 100%; }
        button { padding: 10px; background: #fff; color: #3a1c71; border: none; border-radius: 5px; cursor: pointer; margin: 5px 0; font-weight: bold; }
        .stat { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.1); font-size: 13px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="main">
            <div class="panel"><h1>Current Population</h1><canvas id="mainCanvas"></canvas></div>
            <div class="panel"><h1>Wealth Distribution by Generation</h1><canvas id="genCanvas"></canvas></div>
            <div class="panel"><h1>Long-Term Gini Trends</h1><canvas id="giniCanvas"></canvas></div>
        </div>
        <div class="sidebar">
            <div class="panel"><button id="resetBtn">Reset</button><button id="pauseBtn">Pause</button></div>
            <div class="panel"><h1>Stats</h1><div id="stats"></div></div>
            <div class="panel" style="font-size: 11px; line-height: 1.3;">
                Track inequality across multiple agent generations.
                Does inequality stabilize, grow, or oscillate?
                Measure long-term convergence.
            </div>
        </div>
    </div>
    <script>
        const mainCanvas = document.getElementById('mainCanvas');
        const genCanvas = document.getElementById('genCanvas');
        const giniCanvas = document.getElementById('giniCanvas');
        const [mainCtx, genCtx, giniCtx] = [mainCanvas, genCanvas, giniCanvas].map(c => c.getContext('2d'));

        mainCanvas.width = mainCanvas.parentElement.clientWidth - 30;
        mainCanvas.height = 260;
        genCanvas.width = genCanvas.parentElement.clientWidth - 30;
        genCanvas.height = 200;
        giniCanvas.width = giniCanvas.parentElement.clientWidth - 30;
        giniCanvas.height = 180;

        const GRID = 50, AGENTS = 180, MAX_GRAIN = 50;
        let paused = false, tick = 0;
        let grain = [], maxCap = [], agents = [];
        let giniHistory = [], genData = {};

        function init() {
            grain = []; maxCap = [];
            for (let y = 0; y < GRID; y++) {
                grain[y] = []; maxCap[y] = [];
                for (let x = 0; x < GRID; x++) {
                    const d = Math.sqrt((x-25)**2 + (y-25)**2);
                    const cap = Math.floor(MAX_GRAIN * Math.exp(-d*d/200));
                    maxCap[y][x] = cap; grain[y][x] = cap;
                }
            }
            agents = [];
            for (let i = 0; i < AGENTS; i++) {
                agents.push({
                    x: Math.random()*GRID|0, y: Math.random()*GRID|0,
                    wealth: 30, vision: 1 + Math.random()*6|0,
                    metabolism: 1 + Math.random()*4, age: 0, maxAge: 80,
                    generation: 0, id: i
                });
            }
            tick = 0; giniHistory = []; genData = {};
        }

        function calcGini() {
            const sorted = agents.map(a => a.wealth).sort((a,b) => a-b);
            const total = sorted.reduce((s,w) => s+w, 0);
            if (total === 0) return 0;
            let area = 0;
            for (let i = 0; i < sorted.length; i++) {
                area += sorted[i] / total;
            }
            return 1 - 2*area/sorted.length;
        }

        function update() {
            if (paused) return;
            for (let y = 0; y < GRID; y++) {
                for (let x = 0; x < GRID; x++) {
                    if (grain[y][x] < maxCap[y][x]) grain[y][x]++;
                }
            }
            agents.forEach(a => {
                let [bx,by,bg] = [a.x, a.y, grain[a.y][a.x]];
                for (let dx = -a.vision; dx <= a.vision; dx++) {
                    for (let dy = -a.vision; dy <= a.vision; dy++) {
                        const nx = (a.x+dx+GRID)%GRID, ny = (a.y+dy+GRID)%GRID;
                        if (grain[ny][nx] > bg) { bg = grain[ny][nx]; bx = nx; by = ny; }
                    }
                }
                a.x = bx; a.y = by;
                a.wealth += grain[a.y][a.x];
                grain[a.y][a.x] = 0;
                a.wealth -= a.metabolism;
                a.age++;
            });
            for (let i = agents.length-1; i >= 0; i--) {
                if (agents[i].wealth <= 0 || agents[i].age >= agents[i].maxAge) {
                    agents[i] = {
                        x: Math.random()*GRID|0, y: Math.random()*GRID|0,
                        wealth: 30, vision: 1 + Math.random()*6|0,
                        metabolism: 1 + Math.random()*4, age: 0, maxAge: 80,
                        generation: agents[i].generation + 1,
                        id: agents[i].id
                    };
                }
            }

            // Track generation data
            agents.forEach(a => {
                if (!genData[a.generation]) {
                    genData[a.generation] = [];
                }
                genData[a.generation].push(a.wealth);
            });

            giniHistory.push(calcGini());
            if (giniHistory.length > 500) giniHistory.shift();
            tick++;
        }

        function draw() {
            const cellSize = mainCanvas.width / GRID;
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);

            for (let y = 0; y < GRID; y++) {
                for (let x = 0; x < GRID; x++) {
                    const i = grain[y][x] / MAX_GRAIN;
                    mainCtx.fillStyle = `rgba(0, ${Math.floor(i*120)}, 0, 0.6)`;
                    mainCtx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
                }
            }
            agents.forEach(a => {
                const color = a.wealth<25 ? '#f44336' : a.wealth<90 ? '#4caf50' : '#2196f3';
                mainCtx.fillStyle = color;
                mainCtx.beginPath();
                mainCtx.arc(a.x*cellSize+cellSize/2, a.y*cellSize+cellSize/2, cellSize*0.4, 0, Math.PI*2);
                mainCtx.fill();
            });

            // Generation wealth box plot
            genCtx.fillStyle = '#000';
            genCtx.fillRect(0, 0, genCanvas.width, genCanvas.height);

            const maxGen = Math.max(...agents.map(a => a.generation));
            const genList = Object.keys(genData).map(Number).sort((a,b) => a-b).slice(-10);

            if (genList.length > 0) {
                const pad = 40, w = genCanvas.width - 2*pad, h = genCanvas.height - 2*pad;
                const maxWealth = Math.max(...agents.map(a => a.wealth), 100);
                const barWidth = w / (genList.length + 1);

                genList.forEach((gen, i) => {
                    const data = genData[gen].sort((a,b) => a-b);
                    if (data.length === 0) return;

                    const q1 = data[Math.floor(data.length * 0.25)];
                    const median = data[Math.floor(data.length * 0.5)];
                    const q3 = data[Math.floor(data.length * 0.75)];
                    const min = data[0];
                    const max = data[data.length - 1];

                    const x = pad + (i + 1) * barWidth;

                    // Whiskers
                    genCtx.strokeStyle = '#fff';
                    genCtx.lineWidth = 1;
                    genCtx.beginPath();
                    genCtx.moveTo(x, genCanvas.height - pad - (min/maxWealth)*h);
                    genCtx.lineTo(x, genCanvas.height - pad - (max/maxWealth)*h);
                    genCtx.stroke();

                    // Box
                    const boxH = ((q3-q1)/maxWealth)*h;
                    const boxY = genCanvas.height - pad - (q3/maxWealth)*h;
                    genCtx.fillStyle = 'rgba(100, 181, 246, 0.6)';
                    genCtx.fillRect(x - barWidth/4, boxY, barWidth/2, boxH);
                    genCtx.strokeRect(x - barWidth/4, boxY, barWidth/2, boxH);

                    // Median line
                    genCtx.strokeStyle = '#ffeb3b';
                    genCtx.lineWidth = 2;
                    genCtx.beginPath();
                    genCtx.moveTo(x - barWidth/4, genCanvas.height - pad - (median/maxWealth)*h);
                    genCtx.lineTo(x + barWidth/4, genCanvas.height - pad - (median/maxWealth)*h);
                    genCtx.stroke();

                    // Label
                    genCtx.fillStyle = '#fff';
                    genCtx.font = '10px sans-serif';
                    genCtx.textAlign = 'center';
                    genCtx.fillText(gen, x, genCanvas.height - pad + 20);
                });

                genCtx.strokeStyle = '#fff';
                genCtx.strokeRect(pad, pad, w, h);
                genCtx.fillStyle = '#fff';
                genCtx.font = '12px sans-serif';
                genCtx.fillText('Wealth Distribution by Generation', pad, 20);
            }

            // Gini over time
            giniCtx.fillStyle = '#000';
            giniCtx.fillRect(0, 0, giniCanvas.width, giniCanvas.height);

            if (giniHistory.length > 1) {
                const pad = 40, w = giniCanvas.width - 2*pad, h = giniCanvas.height - 2*pad;

                giniCtx.strokeStyle = '#e91e63';
                giniCtx.lineWidth = 2;
                giniCtx.beginPath();
                giniHistory.forEach((g, i) => {
                    const x = pad + (i/giniHistory.length)*w;
                    const y = giniCanvas.height - pad - g*h;
                    i===0 ? giniCtx.moveTo(x,y) : giniCtx.lineTo(x,y);
                });
                giniCtx.stroke();

                // Moving average
                const windowSize = 50;
                if (giniHistory.length > windowSize) {
                    giniCtx.strokeStyle = '#ffeb3b';
                    giniCtx.lineWidth = 1;
                    giniCtx.beginPath();
                    for (let i = windowSize; i < giniHistory.length; i++) {
                        const avg = giniHistory.slice(i-windowSize, i).reduce((s,g) => s+g, 0) / windowSize;
                        const x = pad + (i/giniHistory.length)*w;
                        const y = giniCanvas.height - pad - avg*h;
                        i===windowSize ? giniCtx.moveTo(x,y) : giniCtx.lineTo(x,y);
                    }
                    giniCtx.stroke();
                }

                giniCtx.strokeStyle = '#fff';
                giniCtx.strokeRect(pad, pad, w, h);
                giniCtx.fillStyle = '#fff';
                giniCtx.font = '12px sans-serif';
                giniCtx.fillText('Gini Coefficient Over Time', pad, 20);
                giniCtx.fillStyle = '#ffeb3b';
                giniCtx.fillText('(yellow = 50-tick moving avg)', pad, giniCanvas.height-pad+20);
            }

            const gini = calcGini();
            const avgGen = agents.reduce((s,a) => s+a.generation, 0) / agents.length;
            const maxGeneration = Math.max(...agents.map(a => a.generation));
            const avgWealth = agents.reduce((s,a) => s+a.wealth, 0) / agents.length;

            document.getElementById('stats').innerHTML = `
                <div class="stat"><span>Tick:</span><span>${tick}</span></div>
                <div class="stat"><span>Current Gini:</span><span>${gini.toFixed(3)}</span></div>
                <div class="stat"><span>Avg Generation:</span><span>${avgGen.toFixed(1)}</span></div>
                <div class="stat"><span>Max Generation:</span><span>${maxGeneration}</span></div>
                <div class="stat"><span>Avg Wealth:</span><span>${avgWealth.toFixed(1)}</span></div>
            `;
        }

        function animate() { update(); draw(); requestAnimationFrame(animate); }

        document.getElementById('resetBtn').onclick = init;
        document.getElementById('pauseBtn').onclick = () => {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        };

        init();
        animate();
    </script>
</body>
</html>
