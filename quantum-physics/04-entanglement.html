<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Entanglement - Quantum Physics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%); color: #eee; min-height: 100vh; padding: 20px; }
        .back-link { position: fixed; top: 20px; left: 20px; color: #60a5fa; text-decoration: none; font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px; z-index: 100; }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #60a5fa; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(96, 165, 250, 0.1); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #60a5fa; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #050510; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input, .control-group select { width: 100%; }
        .value-display { color: #60a5fa; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #60a5fa; color: #0a0a1a; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .particle-display { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0; }
        .particle-box { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 15px; text-align: center; }
        .particle-label { font-size: 0.8em; opacity: 0.7; margin-bottom: 5px; }
        .particle-state { font-size: 1.5em; font-weight: bold; }
        .spin-up { color: #4ade80; }
        .spin-down { color: #f87171; }
        .unknown { color: #60a5fa; }
        .correlation { background: rgba(96, 165, 250, 0.1); border-radius: 8px; padding: 15px; margin: 15px 0; text-align: center; }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <h1>Quantum Entanglement</h1>
    <p class="subtitle">Correlated particle states and spooky action</p>

    <div class="container">
        <div class="panel">
            <canvas id="canvas" width="800" height="500"></canvas>
        </div>

        <div class="panel">
            <div class="info-box">
                <strong>Entanglement:</strong>
                Two entangled particles share a quantum state. When we measure one,
                we instantly know the other's state - regardless of distance!
                Einstein called this "spooky action at a distance."
                But it cannot transmit information faster than light.
            </div>

            <h3>Entangled Pair State</h3>
            <div class="control-group">
                <select id="stateType" onchange="resetPair()">
                    <option value="singlet">Singlet (|↑↓⟩ - |↓↑⟩)/√2</option>
                    <option value="triplet0">Triplet (|↑↓⟩ + |↓↑⟩)/√2</option>
                    <option value="bell_phi_plus">Bell Φ⁺ (|↑↑⟩ + |↓↓⟩)/√2</option>
                    <option value="bell_phi_minus">Bell Φ⁻ (|↑↑⟩ - |↓↓⟩)/√2</option>
                </select>
            </div>

            <h3>Measurement Angle</h3>
            <div class="control-group">
                <label>Alice's Angle: <span class="value-display" id="aliceAngleVal">0°</span></label>
                <input type="range" id="aliceAngle" min="0" max="360" value="0" oninput="updateAngles()">
            </div>

            <div class="control-group">
                <label>Bob's Angle: <span class="value-display" id="bobAngleVal">0°</span></label>
                <input type="range" id="bobAngle" min="0" max="360" value="0" oninput="updateAngles()">
            </div>

            <button class="btn-primary" onclick="measureBoth()">Measure Both</button>
            <button class="btn-secondary" onclick="measureAlice()">Measure Alice Only</button>
            <button class="btn-secondary" onclick="resetPair()">Create New Pair</button>

            <h3 style="margin-top: 15px;">Measurement Results</h3>
            <div class="particle-display">
                <div class="particle-box">
                    <div class="particle-label">Alice (Particle A)</div>
                    <div class="particle-state" id="aliceState">?</div>
                </div>
                <div class="particle-box">
                    <div class="particle-label">Bob (Particle B)</div>
                    <div class="particle-state" id="bobState">?</div>
                </div>
            </div>

            <div class="correlation">
                <div>Correlation: <span class="value-display" id="correlation">N/A</span></div>
                <div style="font-size: 0.8em; margin-top: 5px;">
                    Trials: <span id="trials">0</span> |
                    Same: <span id="sameCount">0</span> |
                    Opposite: <span id="oppCount">0</span>
                </div>
            </div>

            <button class="btn-secondary" onclick="runBellTest()">Run Bell Test (100 trials)</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let stateType = 'singlet';
        let aliceAngle = 0;
        let bobAngle = 0;
        let aliceMeasured = false;
        let bobMeasured = false;
        let aliceResult = null;
        let bobResult = null;
        let trials = 0;
        let sameCount = 0;
        let oppCount = 0;
        let particles = { a: null, b: null };
        let time = 0;

        function updateAngles() {
            aliceAngle = parseInt(document.getElementById('aliceAngle').value);
            bobAngle = parseInt(document.getElementById('bobAngle').value);
            document.getElementById('aliceAngleVal').textContent = aliceAngle + '°';
            document.getElementById('bobAngleVal').textContent = bobAngle + '°';
        }

        function resetPair() {
            stateType = document.getElementById('stateType').value;
            aliceMeasured = false;
            bobMeasured = false;
            aliceResult = null;
            bobResult = null;

            document.getElementById('aliceState').textContent = '?';
            document.getElementById('aliceState').className = 'particle-state unknown';
            document.getElementById('bobState').textContent = '?';
            document.getElementById('bobState').className = 'particle-state unknown';

            particles = {
                a: { x: canvas.width / 4, y: canvas.height / 2, vx: 0, spin: null },
                b: { x: 3 * canvas.width / 4, y: canvas.height / 2, vx: 0, spin: null }
            };
        }

        function getEntangledResult(angle, isAlice) {
            const rad = angle * Math.PI / 180;

            if (!aliceMeasured && !bobMeasured) {
                // First measurement - random
                return Math.random() < 0.5 ? 'up' : 'down';
            }

            if (isAlice && bobMeasured) {
                // Alice measures after Bob
                return getCorrelatedResult(bobResult, aliceAngle, bobAngle);
            }

            if (!isAlice && aliceMeasured) {
                // Bob measures after Alice
                return getCorrelatedResult(aliceResult, bobAngle, aliceAngle);
            }

            return Math.random() < 0.5 ? 'up' : 'down';
        }

        function getCorrelatedResult(otherResult, myAngle, otherAngle) {
            const angleDiff = (myAngle - otherAngle) * Math.PI / 180;

            // Quantum correlation based on state type
            let probSame;
            if (stateType === 'singlet') {
                // Anti-correlated: probability of opposite = cos²(θ/2)
                probSame = Math.pow(Math.sin(angleDiff / 2), 2);
            } else if (stateType === 'triplet0') {
                // Correlated perpendicular
                probSame = Math.pow(Math.cos(angleDiff / 2), 2);
            } else if (stateType === 'bell_phi_plus' || stateType === 'bell_phi_minus') {
                // Same spin correlation
                probSame = Math.pow(Math.cos(angleDiff / 2), 2);
            }

            const wantSame = Math.random() < probSame;

            if (stateType === 'singlet') {
                // Anti-correlation is natural
                return wantSame ? otherResult : (otherResult === 'up' ? 'down' : 'up');
            } else {
                // Correlation is natural for other Bell states
                return wantSame ? otherResult : (otherResult === 'up' ? 'down' : 'up');
            }
        }

        function measureAlice() {
            if (aliceMeasured) return;

            aliceResult = getEntangledResult(aliceAngle, true);
            aliceMeasured = true;
            particles.a.spin = aliceResult;

            document.getElementById('aliceState').textContent = aliceResult === 'up' ? '↑' : '↓';
            document.getElementById('aliceState').className = 'particle-state ' + (aliceResult === 'up' ? 'spin-up' : 'spin-down');
        }

        function measureBoth() {
            if (!aliceMeasured) measureAlice();

            if (bobMeasured) {
                resetPair();
                return;
            }

            bobResult = getEntangledResult(bobAngle, false);
            bobMeasured = true;
            particles.b.spin = bobResult;

            document.getElementById('bobState').textContent = bobResult === 'up' ? '↑' : '↓';
            document.getElementById('bobState').className = 'particle-state ' + (bobResult === 'up' ? 'spin-up' : 'spin-down');

            // Update statistics
            trials++;
            if (aliceResult === bobResult) sameCount++;
            else oppCount++;

            updateStats();
        }

        function updateStats() {
            document.getElementById('trials').textContent = trials;
            document.getElementById('sameCount').textContent = sameCount;
            document.getElementById('oppCount').textContent = oppCount;

            if (trials > 0) {
                const corr = (sameCount - oppCount) / trials;
                document.getElementById('correlation').textContent = corr.toFixed(3);
            }
        }

        async function runBellTest() {
            trials = 0;
            sameCount = 0;
            oppCount = 0;

            for (let i = 0; i < 100; i++) {
                resetPair();
                // Random angles for Bell test
                document.getElementById('aliceAngle').value = Math.random() * 360;
                document.getElementById('bobAngle').value = Math.random() * 360;
                updateAngles();

                await new Promise(r => setTimeout(r, 20));
                measureAlice();
                await new Promise(r => setTimeout(r, 20));
                measureBoth();
            }
        }

        function draw() {
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            time += 0.02;

            // Draw entanglement visualization (wavy connection)
            if (!aliceMeasured || !bobMeasured) {
                ctx.strokeStyle = 'rgba(96, 165, 250, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let x = particles.a.x; x <= particles.b.x; x += 5) {
                    const progress = (x - particles.a.x) / (particles.b.x - particles.a.x);
                    const y = canvas.height / 2 + Math.sin(x * 0.05 + time * 3) * 20 * Math.sin(progress * Math.PI);
                    if (x === particles.a.x) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // Draw Alice's detector
            ctx.save();
            ctx.translate(particles.a.x, particles.a.y);

            // Detector housing
            ctx.fillStyle = 'rgba(96, 165, 250, 0.2)';
            ctx.beginPath();
            ctx.arc(0, 0, 60, 0, Math.PI * 2);
            ctx.fill();

            // Measurement angle indicator
            ctx.strokeStyle = '#60a5fa';
            ctx.lineWidth = 3;
            const aliceRad = aliceAngle * Math.PI / 180;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(aliceRad) * 50, -Math.sin(aliceRad) * 50);
            ctx.stroke();

            // Particle
            if (aliceMeasured) {
                ctx.fillStyle = aliceResult === 'up' ? '#4ade80' : '#f87171';
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.fill();

                // Spin arrow
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, aliceResult === 'up' ? 10 : -10);
                ctx.lineTo(0, aliceResult === 'up' ? -15 : 15);
                ctx.stroke();
                // Arrow head
                ctx.beginPath();
                const tipY = aliceResult === 'up' ? -15 : 15;
                const dir = aliceResult === 'up' ? 1 : -1;
                ctx.moveTo(-5, tipY + dir * 5);
                ctx.lineTo(0, tipY);
                ctx.lineTo(5, tipY + dir * 5);
                ctx.stroke();
            } else {
                // Superposition visualization
                ctx.fillStyle = 'rgba(96, 165, 250, 0.5)';
                ctx.beginPath();
                ctx.arc(0, 0, 20 + Math.sin(time * 5) * 5, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText('Alice', -20, 90);

            ctx.restore();

            // Draw Bob's detector
            ctx.save();
            ctx.translate(particles.b.x, particles.b.y);

            ctx.fillStyle = 'rgba(250, 204, 21, 0.2)';
            ctx.beginPath();
            ctx.arc(0, 0, 60, 0, Math.PI * 2);
            ctx.fill();

            const bobRad = bobAngle * Math.PI / 180;
            ctx.strokeStyle = '#facc15';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(bobRad) * 50, -Math.sin(bobRad) * 50);
            ctx.stroke();

            if (bobMeasured) {
                ctx.fillStyle = bobResult === 'up' ? '#4ade80' : '#f87171';
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, bobResult === 'up' ? 10 : -10);
                ctx.lineTo(0, bobResult === 'up' ? -15 : 15);
                ctx.stroke();
                ctx.beginPath();
                const tipY = bobResult === 'up' ? -15 : 15;
                const dir = bobResult === 'up' ? 1 : -1;
                ctx.moveTo(-5, tipY + dir * 5);
                ctx.lineTo(0, tipY);
                ctx.lineTo(5, tipY + dir * 5);
                ctx.stroke();
            } else {
                ctx.fillStyle = 'rgba(250, 204, 21, 0.5)';
                ctx.beginPath();
                ctx.arc(0, 0, 20 + Math.sin(time * 5 + 1) * 5, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText('Bob', -15, 90);

            ctx.restore();

            // Source in middle
            ctx.fillStyle = '#c084fc';
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = '12px sans-serif';
            ctx.fillText('Source', canvas.width / 2 - 22, canvas.height / 2 + 35);

            // State label
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px sans-serif';
            const stateLabels = {
                'singlet': '|Ψ⁻⟩ = (|↑↓⟩ - |↓↑⟩)/√2',
                'triplet0': '|Ψ⁺⟩ = (|↑↓⟩ + |↓↑⟩)/√2',
                'bell_phi_plus': '|Φ⁺⟩ = (|↑↑⟩ + |↓↓⟩)/√2',
                'bell_phi_minus': '|Φ⁻⟩ = (|↑↑⟩ - |↓↓⟩)/√2'
            };
            ctx.fillText(stateLabels[stateType], canvas.width / 2 - 80, 30);

            // Distance indicator
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '12px sans-serif';
            ctx.fillText('← Any distance apart →', canvas.width / 2 - 60, canvas.height - 30);
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        resetPair();
        updateAngles();
        animate();
    </script>
</body>
</html>
