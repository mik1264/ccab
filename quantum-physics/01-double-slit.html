<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Double Slit Experiment - Quantum Physics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%); color: #eee; min-height: 100vh; padding: 20px; }
        .back-link { position: fixed; top: 20px; left: 20px; color: #60a5fa; text-decoration: none; font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px; z-index: 100; }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #60a5fa; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(96, 165, 250, 0.1); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #60a5fa; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #050510; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input, .control-group select { width: 100%; }
        .value-display { color: #60a5fa; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #60a5fa; color: #0a0a1a; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0; }
        .stat-box { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px; text-align: center; }
        .stat-value { font-size: 1.3em; font-weight: bold; color: #60a5fa; }
        .stat-label { font-size: 0.75em; opacity: 0.8; }
        .toggle-group { display: flex; gap: 10px; margin: 15px 0; }
        .toggle-btn { flex: 1; padding: 10px; border: 2px solid rgba(96, 165, 250, 0.3); background: transparent; color: #fff; border-radius: 8px; cursor: pointer; }
        .toggle-btn.active { background: #60a5fa; color: #0a0a1a; border-color: #60a5fa; }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <h1>Double Slit Experiment</h1>
    <p class="subtitle">Wave-particle duality demonstration</p>

    <div class="container">
        <div class="panel">
            <canvas id="canvas" width="800" height="500"></canvas>
            <canvas id="patternCanvas" width="800" height="100"></canvas>
        </div>

        <div class="panel">
            <div class="info-box">
                <strong>Double Slit Experiment:</strong>
                Single particles create an interference pattern over time, showing wave-like behavior.
                When we detect which slit particles go through, the interference disappears!
                This demonstrates quantum wave-particle duality.
            </div>

            <h3>Detection Mode</h3>
            <div class="toggle-group">
                <button class="toggle-btn active" id="noDetect" onclick="setDetection(false)">No Detection</button>
                <button class="toggle-btn" id="detect" onclick="setDetection(true)">Detect Path</button>
            </div>

            <div class="control-group">
                <label>Particle Rate: <span class="value-display" id="rateVal">20</span>/s</label>
                <input type="range" id="rateSlider" min="1" max="100" value="20" oninput="updateParam()">
            </div>

            <div class="control-group">
                <label>Slit Separation: <span class="value-display" id="sepVal">60</span>px</label>
                <input type="range" id="sepSlider" min="30" max="120" value="60" oninput="updateParam()">
            </div>

            <div class="control-group">
                <label>Wavelength: <span class="value-display" id="waveVal">40</span></label>
                <input type="range" id="waveSlider" min="20" max="80" value="40" oninput="updateParam()">
            </div>

            <button class="btn-primary" onclick="toggleSimulation()">Start/Stop</button>
            <button class="btn-secondary" onclick="resetExperiment()">Reset Pattern</button>

            <h3 style="margin-top: 15px;">Statistics</h3>
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value" id="particleCount">0</div>
                    <div class="stat-label">Particles</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="patternType">Wave</div>
                    <div class="stat-label">Pattern</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const patternCanvas = document.getElementById('patternCanvas');
        const pctx = patternCanvas.getContext('2d');

        let particles = [];
        let pattern = new Array(patternCanvas.width).fill(0);
        let particleCount = 0;
        let running = false;
        let detectPath = false;
        let rate = 20;
        let slitSeparation = 60;
        let wavelength = 40;
        let lastSpawn = 0;

        const sourceX = 50;
        const slitX = 300;
        const screenX = 750;
        const centerY = canvas.height / 2;

        function updateParam() {
            rate = parseInt(document.getElementById('rateSlider').value);
            slitSeparation = parseInt(document.getElementById('sepSlider').value);
            wavelength = parseInt(document.getElementById('waveSlider').value);
            document.getElementById('rateVal').textContent = rate;
            document.getElementById('sepVal').textContent = slitSeparation;
            document.getElementById('waveVal').textContent = wavelength;
        }

        function setDetection(detect) {
            detectPath = detect;
            document.getElementById('noDetect').className = detect ? 'toggle-btn' : 'toggle-btn active';
            document.getElementById('detect').className = detect ? 'toggle-btn active' : 'toggle-btn';
            document.getElementById('patternType').textContent = detect ? 'Particle' : 'Wave';
            resetExperiment();
        }

        function spawnParticle() {
            const particle = {
                x: sourceX,
                y: centerY,
                vx: 3,
                vy: 0,
                phase: 'source',
                slit: null,
                trail: []
            };
            particles.push(particle);
        }

        function getInterferenceY() {
            // Quantum interference pattern
            const slit1Y = centerY - slitSeparation / 2;
            const slit2Y = centerY + slitSeparation / 2;

            // Calculate interference probability
            const screenCenter = centerY;
            const maxOffset = 150;

            // Generate position based on interference pattern
            let y;
            let attempts = 0;
            do {
                const candidate = screenCenter + (Math.random() - 0.5) * 2 * maxOffset;
                const pathDiff = Math.abs(
                    Math.sqrt(Math.pow(screenX - slitX, 2) + Math.pow(candidate - slit1Y, 2)) -
                    Math.sqrt(Math.pow(screenX - slitX, 2) + Math.pow(candidate - slit2Y, 2))
                );
                const phase = (pathDiff / wavelength) * 2 * Math.PI;
                const probability = Math.pow(Math.cos(phase / 2), 2);
                if (Math.random() < probability) {
                    y = candidate;
                    break;
                }
                attempts++;
            } while (attempts < 100);

            return y || screenCenter;
        }

        function getClassicalY(slit) {
            // Classical two-bump pattern
            const slitY = slit === 1 ? centerY - slitSeparation / 2 : centerY + slitSeparation / 2;
            const spread = 30;
            return slitY + (Math.random() - 0.5) * spread * 2;
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.trail.push({ x: p.x, y: p.y });
                if (p.trail.length > 20) p.trail.shift();

                if (p.phase === 'source') {
                    p.x += p.vx;
                    if (p.x >= slitX - 20) {
                        // Choose slit randomly
                        p.slit = Math.random() < 0.5 ? 1 : 2;
                        p.phase = 'slit';
                        const slitY = p.slit === 1 ? centerY - slitSeparation / 2 : centerY + slitSeparation / 2;
                        const dy = slitY - p.y;
                        const dx = slitX - p.x;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        p.vx = (dx / dist) * 3;
                        p.vy = (dy / dist) * 3;
                    }
                } else if (p.phase === 'slit') {
                    p.x += p.vx;
                    p.y += p.vy;
                    if (p.x >= slitX) {
                        p.phase = 'propagate';
                        if (detectPath) {
                            // Classical behavior when detected
                            p.targetY = getClassicalY(p.slit);
                        } else {
                            // Quantum interference
                            p.targetY = getInterferenceY();
                        }
                        const dy = p.targetY - p.y;
                        const dx = screenX - p.x;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        p.vx = (dx / dist) * 3;
                        p.vy = (dy / dist) * 3;
                    }
                } else if (p.phase === 'propagate') {
                    p.x += p.vx;
                    p.y += p.vy;
                    if (p.x >= screenX) {
                        // Hit screen
                        const screenY = Math.round(p.y);
                        const patternX = Math.floor((screenY - (centerY - 200)) / 400 * patternCanvas.width);
                        if (patternX >= 0 && patternX < pattern.length) {
                            pattern[patternX]++;
                        }
                        particleCount++;
                        document.getElementById('particleCount').textContent = particleCount;
                        particles.splice(i, 1);
                    }
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw source
            ctx.fillStyle = '#60a5fa';
            ctx.beginPath();
            ctx.arc(sourceX, centerY, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = '10px sans-serif';
            ctx.fillText('Source', sourceX - 18, centerY + 30);

            // Draw barrier with slits
            ctx.fillStyle = '#333';
            ctx.fillRect(slitX - 5, 0, 10, centerY - slitSeparation / 2 - 15);
            ctx.fillRect(slitX - 5, centerY - slitSeparation / 2 + 15, 10, slitSeparation - 30);
            ctx.fillRect(slitX - 5, centerY + slitSeparation / 2 + 15, 10, canvas.height);

            // Draw detector icons if detection is on
            if (detectPath) {
                ctx.fillStyle = '#f87171';
                ctx.font = '12px sans-serif';
                ctx.fillText('üëÅ', slitX - 20, centerY - slitSeparation / 2);
                ctx.fillText('üëÅ', slitX - 20, centerY + slitSeparation / 2);
            }

            // Draw screen
            ctx.fillStyle = '#222';
            ctx.fillRect(screenX, centerY - 200, 10, 400);

            // Draw particles with trails
            for (const p of particles) {
                // Draw trail
                ctx.strokeStyle = p.slit === 1 ? 'rgba(96, 165, 250, 0.3)' : 'rgba(250, 204, 21, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                p.trail.forEach((t, i) => {
                    if (i === 0) ctx.moveTo(t.x, t.y);
                    else ctx.lineTo(t.x, t.y);
                });
                ctx.stroke();

                // Draw particle
                ctx.fillStyle = p.slit === 1 ? '#60a5fa' : '#facc15';
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw hits on screen
            const maxHits = Math.max(...pattern, 1);
            for (let i = 0; i < pattern.length; i++) {
                if (pattern[i] > 0) {
                    const y = centerY - 200 + (i / pattern.length) * 400;
                    const intensity = pattern[i] / maxHits;
                    ctx.fillStyle = `rgba(96, 165, 250, ${intensity})`;
                    ctx.fillRect(screenX + 15, y - 1, 5 + intensity * 20, 2);
                }
            }

            // Labels
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText(detectPath ? 'Detection ON - Classical Pattern' : 'No Detection - Interference Pattern', 20, 30);
        }

        function drawPattern() {
            pctx.fillStyle = '#050510';
            pctx.fillRect(0, 0, patternCanvas.width, patternCanvas.height);

            const maxHits = Math.max(...pattern, 1);

            // Draw pattern as histogram
            pctx.fillStyle = '#60a5fa';
            for (let i = 0; i < pattern.length; i++) {
                const height = (pattern[i] / maxHits) * patternCanvas.height * 0.9;
                pctx.fillRect(i, patternCanvas.height - height, 1, height);
            }

            // Draw theoretical curve
            if (particleCount > 100) {
                pctx.strokeStyle = 'rgba(250, 204, 21, 0.5)';
                pctx.lineWidth = 2;
                pctx.beginPath();
                for (let i = 0; i < patternCanvas.width; i++) {
                    const y = (i / patternCanvas.width - 0.5) * 400;
                    let intensity;
                    if (detectPath) {
                        // Two Gaussian bumps
                        const d1 = y + slitSeparation / 2;
                        const d2 = y - slitSeparation / 2;
                        intensity = Math.exp(-d1 * d1 / 800) + Math.exp(-d2 * d2 / 800);
                    } else {
                        // Interference pattern
                        const pathDiff = Math.abs(y) * slitSeparation / 200;
                        intensity = Math.pow(Math.cos(pathDiff * Math.PI / wavelength * 3), 2);
                        intensity *= Math.exp(-y * y / 10000);
                    }
                    const plotY = patternCanvas.height - intensity * patternCanvas.height * 0.4;
                    if (i === 0) pctx.moveTo(i, plotY);
                    else pctx.lineTo(i, plotY);
                }
                pctx.stroke();
            }

            pctx.fillStyle = '#fff';
            pctx.font = '12px sans-serif';
            pctx.fillText('Detection Pattern', 10, 15);
        }

        function toggleSimulation() {
            running = !running;
            if (running) animate();
        }

        function resetExperiment() {
            particles = [];
            pattern = new Array(patternCanvas.width).fill(0);
            particleCount = 0;
            document.getElementById('particleCount').textContent = '0';
            draw();
            drawPattern();
        }

        function animate() {
            if (!running) return;

            const now = Date.now();
            if (now - lastSpawn > 1000 / rate) {
                spawnParticle();
                lastSpawn = now;
            }

            updateParticles();
            draw();
            drawPattern();

            requestAnimationFrame(animate);
        }

        updateParam();
        draw();
        drawPattern();
    </script>
</body>
</html>
