<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Harmonic Oscillator | Quantum Physics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(100, 255, 150, 0.3);
        }
        h1 { color: #64ff96; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        select { padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #64ff96; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #64ff96; color: #0a0a1a;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #88ffb0; }
        .energy-levels { margin: 15px 0; }
        .energy-bar {
            display: flex; align-items: center; gap: 10px;
            padding: 5px 10px; margin: 3px 0; border-radius: 5px;
            cursor: pointer; transition: all 0.2s;
        }
        .energy-bar:hover { background: rgba(100, 255, 150, 0.1); }
        .energy-bar.selected { background: rgba(100, 255, 150, 0.3); }
        .energy-label { font-size: 0.85em; min-width: 40px; }
        .energy-value { font-size: 0.8em; color: #888; flex: 1; }
        .energy-indicator { width: 20px; height: 20px; border-radius: 50%; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #64ff96; font-weight: bold; }
        .formula { font-family: serif; font-style: italic; font-size: 1.1em; text-align: center; margin: 15px 0; color: #64ff96; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #64ff96; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">← Back to Quantum Physics</a>

    <div class="controls">
        <h1>Quantum Harmonic Oscillator</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Quantized energy levels and wave functions</p>

        <div class="control-group">
            <label>Display Mode</label>
            <select id="displayMode">
                <option value="single">Single State</option>
                <option value="superposition">Superposition</option>
                <option value="coherent">Coherent State</option>
            </select>
        </div>

        <div class="energy-levels" id="energyLevels">
            <!-- Energy level buttons -->
        </div>

        <div class="control-group" id="superpositionControls" style="display:none;">
            <label>Second State (n₂): <span class="value" id="n2Value">1</span></label>
            <input type="range" id="n2Slider" min="0" max="9" value="1">
        </div>

        <div class="control-group" id="coherentControls" style="display:none;">
            <label>Coherent Parameter (α): <span class="value" id="alphaValue">2</span></label>
            <input type="range" id="alphaSlider" min="0.5" max="5" step="0.5" value="2">
        </div>

        <div class="control-group">
            <label>Frequency (ω): <span class="value" id="omegaValue">1.0</span></label>
            <input type="range" id="omega" min="0.5" max="3" step="0.1" value="1">
        </div>

        <button id="animateBtn">Animate</button>
        <button id="resetBtn">Reset</button>

        <div class="formula">Eₙ = ℏω(n + ½)</div>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Energy (E/ℏω)</span>
                <span class="stat-value" id="energyDisplay">0.5</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">⟨x⟩</span>
                <span class="stat-value" id="expX">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">⟨p⟩</span>
                <span class="stat-value" id="expP">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Time</span>
                <span class="stat-value" id="timeDisplay">0</span>
            </div>
        </div>

        <div class="info">
            <strong>Hermite polynomials</strong> give the wave functions.<br>
            <strong>Coherent states</strong> are minimum-uncertainty wave packets that oscillate like classical particles.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            createEnergyLevelButtons();
        }
        resize();
        window.onresize = resize;

        let selectedN = 0;
        let n2 = 1;
        let alpha = 2;
        let omega = 1;
        let time = 0;
        let animating = false;
        let displayMode = 'single';

        const hbar = 1;
        const m = 1;

        // Hermite polynomials H_n(x)
        function hermite(n, x) {
            if (n === 0) return 1;
            if (n === 1) return 2 * x;

            let h0 = 1, h1 = 2 * x;
            for (let i = 2; i <= n; i++) {
                const h2 = 2 * x * h1 - 2 * (i - 1) * h0;
                h0 = h1;
                h1 = h2;
            }
            return h1;
        }

        // Factorial
        function factorial(n) {
            if (n <= 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) result *= i;
            return result;
        }

        // QHO wave function ψ_n(x)
        function psiN(n, x, t = 0) {
            const xi = Math.sqrt(m * omega / hbar) * x;
            const norm = Math.pow(m * omega / (Math.PI * hbar), 0.25) / Math.sqrt(Math.pow(2, n) * factorial(n));
            const spatial = norm * hermite(n, xi) * Math.exp(-xi * xi / 2);

            // Time evolution
            const E = hbar * omega * (n + 0.5);
            const phase = -E * t / hbar;

            return {
                real: spatial * Math.cos(phase),
                imag: spatial * Math.sin(phase)
            };
        }

        // Coherent state
        function coherentState(alpha, x, t = 0) {
            // Coherent state is superposition of energy eigenstates
            let psiReal = 0, psiImag = 0;

            const numTerms = 20;
            const alphaSq = alpha * alpha;

            for (let n = 0; n < numTerms; n++) {
                const cn = Math.pow(alpha, n) / Math.sqrt(factorial(n)) * Math.exp(-alphaSq / 2);
                const psi = psiN(n, x, t);

                psiReal += cn * psi.real;
                psiImag += cn * psi.imag;
            }

            return { real: psiReal, imag: psiImag };
        }

        function createEnergyLevelButtons() {
            const container = document.getElementById('energyLevels');
            container.innerHTML = '<div style="font-size:0.85em; color:#888; margin-bottom:5px;">Energy Level (n):</div>';

            const colors = ['#ff6464', '#ff9664', '#ffcc64', '#c8ff64', '#64ff96', '#64ffc8', '#64c8ff', '#6496ff', '#9664ff', '#ff64c8'];

            for (let n = 0; n <= 9; n++) {
                const E = (n + 0.5).toFixed(1);
                const bar = document.createElement('div');
                bar.className = `energy-bar ${n === selectedN ? 'selected' : ''}`;
                bar.innerHTML = `
                    <div class="energy-indicator" style="background:${colors[n]}"></div>
                    <span class="energy-label">n=${n}</span>
                    <span class="energy-value">E = ${E}ℏω</span>
                `;
                bar.onclick = () => {
                    selectedN = n;
                    document.querySelectorAll('.energy-bar').forEach(b => b.classList.remove('selected'));
                    bar.classList.add('selected');
                    updateStats();
                };
                container.appendChild(bar);
            }
        }

        function draw() {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const plotWidth = canvas.width - 350;
            const plotHeight = canvas.height - 100;
            const plotX = 50;
            const plotY = 50;
            const centerY = plotY + plotHeight / 2;

            // Draw potential well
            drawPotential(plotX, plotY, plotWidth, plotHeight);

            // Draw energy levels
            drawEnergyLevels(plotX, plotY, plotWidth, plotHeight);

            // Draw wave function
            drawWaveFunction(plotX, plotY, plotWidth, plotHeight);

            // Draw probability density
            drawProbability(plotX, plotY, plotWidth, plotHeight);

            updateStats();
        }

        function drawPotential(x, y, w, h) {
            const centerX = x + w / 2;
            const centerY = y + h / 2;

            // V(x) = ½mω²x²
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;

            const xScale = w / 10;
            const vScale = h / 12;

            for (let px = 0; px <= w; px++) {
                const xPhys = (px - w / 2) / xScale;
                const V = 0.5 * m * omega * omega * xPhys * xPhys;
                const py = centerY - V * vScale;

                if (px === 0) ctx.moveTo(x + px, py);
                else ctx.lineTo(x + px, py);
            }
            ctx.stroke();

            // Fill potential region
            ctx.beginPath();
            ctx.fillStyle = 'rgba(100, 100, 100, 0.1)';
            ctx.moveTo(x, y + h);
            for (let px = 0; px <= w; px++) {
                const xPhys = (px - w / 2) / xScale;
                const V = 0.5 * m * omega * omega * xPhys * xPhys;
                const py = centerY - V * vScale;
                ctx.lineTo(x + px, py);
            }
            ctx.lineTo(x + w, y + h);
            ctx.closePath();
            ctx.fill();
        }

        function drawEnergyLevels(x, y, w, h) {
            const centerY = y + h / 2;
            const vScale = h / 12;
            const colors = ['#ff6464', '#ff9664', '#ffcc64', '#c8ff64', '#64ff96', '#64ffc8', '#64c8ff', '#6496ff', '#9664ff', '#ff64c8'];

            for (let n = 0; n <= 9; n++) {
                const E = n + 0.5;
                const yPos = centerY - E * vScale;

                if (yPos < y) break;

                ctx.beginPath();
                ctx.strokeStyle = n === selectedN ? colors[n] : `${colors[n]}44`;
                ctx.lineWidth = n === selectedN ? 2 : 1;
                ctx.setLineDash(n === selectedN ? [] : [5, 5]);

                // Draw horizontal line at energy level
                const xRange = Math.sqrt(2 * E / (m * omega * omega));
                const xMin = x + w / 2 - xRange * (w / 10);
                const xMax = x + w / 2 + xRange * (w / 10);

                ctx.moveTo(xMin, yPos);
                ctx.lineTo(xMax, yPos);
                ctx.stroke();
                ctx.setLineDash([]);

                // Label
                if (n <= 5) {
                    ctx.fillStyle = colors[n];
                    ctx.font = '10px sans-serif';
                    ctx.fillText(`n=${n}`, x + w - 30, yPos + 3);
                }
            }
        }

        function drawWaveFunction(x, y, w, h) {
            const centerX = x + w / 2;
            const centerY = y + h / 2;
            const xScale = w / 10;
            const psiScale = h / 8;

            ctx.beginPath();
            ctx.strokeStyle = '#64ff96';
            ctx.lineWidth = 2;

            for (let px = 0; px <= w; px++) {
                const xPhys = (px - w / 2) / xScale;
                let psi;

                if (displayMode === 'single') {
                    psi = psiN(selectedN, xPhys, time);
                } else if (displayMode === 'superposition') {
                    const psi1 = psiN(selectedN, xPhys, time);
                    const psi2 = psiN(n2, xPhys, time);
                    psi = {
                        real: (psi1.real + psi2.real) / Math.sqrt(2),
                        imag: (psi1.imag + psi2.imag) / Math.sqrt(2)
                    };
                } else if (displayMode === 'coherent') {
                    psi = coherentState(alpha, xPhys, time);
                }

                const py = centerY - psi.real * psiScale;
                if (px === 0) ctx.moveTo(x + px, py);
                else ctx.lineTo(x + px, py);
            }
            ctx.stroke();

            // Draw imaginary part (faint)
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 150, 100, 0.5)';
            ctx.lineWidth = 1;

            for (let px = 0; px <= w; px++) {
                const xPhys = (px - w / 2) / xScale;
                let psi;

                if (displayMode === 'single') {
                    psi = psiN(selectedN, xPhys, time);
                } else if (displayMode === 'superposition') {
                    const psi1 = psiN(selectedN, xPhys, time);
                    const psi2 = psiN(n2, xPhys, time);
                    psi = {
                        real: (psi1.real + psi2.real) / Math.sqrt(2),
                        imag: (psi1.imag + psi2.imag) / Math.sqrt(2)
                    };
                } else if (displayMode === 'coherent') {
                    psi = coherentState(alpha, xPhys, time);
                }

                const py = centerY - psi.imag * psiScale;
                if (px === 0) ctx.moveTo(x + px, py);
                else ctx.lineTo(x + px, py);
            }
            ctx.stroke();
        }

        function drawProbability(x, y, w, h) {
            const centerX = x + w / 2;
            const centerY = y + h / 2;
            const xScale = w / 10;
            const probScale = h / 3;

            // Fill probability
            ctx.beginPath();
            ctx.fillStyle = 'rgba(100, 255, 150, 0.2)';
            ctx.moveTo(x, centerY);

            for (let px = 0; px <= w; px++) {
                const xPhys = (px - w / 2) / xScale;
                let psi;

                if (displayMode === 'single') {
                    psi = psiN(selectedN, xPhys, time);
                } else if (displayMode === 'superposition') {
                    const psi1 = psiN(selectedN, xPhys, time);
                    const psi2 = psiN(n2, xPhys, time);
                    psi = {
                        real: (psi1.real + psi2.real) / Math.sqrt(2),
                        imag: (psi1.imag + psi2.imag) / Math.sqrt(2)
                    };
                } else if (displayMode === 'coherent') {
                    psi = coherentState(alpha, xPhys, time);
                }

                const prob = psi.real * psi.real + psi.imag * psi.imag;
                const py = centerY - prob * probScale;
                ctx.lineTo(x + px, py);
            }

            ctx.lineTo(x + w, centerY);
            ctx.closePath();
            ctx.fill();
        }

        function updateStats() {
            let energy;
            if (displayMode === 'single') {
                energy = selectedN + 0.5;
            } else if (displayMode === 'superposition') {
                energy = (selectedN + n2) / 2 + 0.5;
            } else {
                energy = alpha * alpha + 0.5;
            }

            document.getElementById('energyDisplay').textContent = energy.toFixed(2);
            document.getElementById('timeDisplay').textContent = time.toFixed(2);

            // Calculate expectation values
            let expX = 0;
            if (displayMode === 'coherent') {
                expX = Math.sqrt(2 * hbar / (m * omega)) * alpha * Math.cos(omega * time);
            } else if (displayMode === 'superposition' && selectedN !== n2) {
                const dE = Math.abs(n2 - selectedN);
                expX = Math.cos(dE * omega * time) * 0.5;
            }

            document.getElementById('expX').textContent = expX.toFixed(3);
            document.getElementById('expP').textContent = (-m * omega * expX * Math.tan(omega * time)).toFixed(3);
        }

        function animate() {
            if (animating) {
                time += 0.05;
            }
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('displayMode').onchange = (e) => {
            displayMode = e.target.value;
            document.getElementById('superpositionControls').style.display =
                displayMode === 'superposition' ? 'block' : 'none';
            document.getElementById('coherentControls').style.display =
                displayMode === 'coherent' ? 'block' : 'none';
        };

        document.getElementById('n2Slider').oninput = (e) => {
            n2 = parseInt(e.target.value);
            document.getElementById('n2Value').textContent = n2;
        };

        document.getElementById('alphaSlider').oninput = (e) => {
            alpha = parseFloat(e.target.value);
            document.getElementById('alphaValue').textContent = alpha;
        };

        document.getElementById('omega').oninput = (e) => {
            omega = parseFloat(e.target.value);
            document.getElementById('omegaValue').textContent = omega.toFixed(1);
        };

        document.getElementById('animateBtn').onclick = () => {
            animating = !animating;
            document.getElementById('animateBtn').textContent = animating ? 'Pause' : 'Animate';
        };

        document.getElementById('resetBtn').onclick = () => {
            time = 0;
            animating = false;
            document.getElementById('animateBtn').textContent = 'Animate';
        };

        // Initialize
        createEnergyLevelButtons();
        animate();
    </script>
</body>
</html>
