<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wave Function Collapse - Quantum Physics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%); color: #eee; min-height: 100vh; padding: 20px; }
        .back-link { position: fixed; top: 20px; left: 20px; color: #60a5fa; text-decoration: none; font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px; z-index: 100; }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #60a5fa; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(96, 165, 250, 0.1); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #60a5fa; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #050510; cursor: crosshair; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input, .control-group select { width: 100%; }
        .value-display { color: #60a5fa; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #60a5fa; color: #0a0a1a; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .state-indicator { padding: 15px; border-radius: 8px; text-align: center; margin: 15px 0; font-weight: 600; }
        .superposition { background: rgba(96, 165, 250, 0.2); color: #60a5fa; }
        .collapsed { background: rgba(74, 222, 128, 0.2); color: #4ade80; }
        .legend { display: flex; gap: 15px; flex-wrap: wrap; margin: 10px 0; font-size: 0.85em; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <h1>Wave Function Collapse</h1>
    <p class="subtitle">Measurement and probability amplitude</p>

    <div class="container">
        <div class="panel">
            <canvas id="canvas" width="800" height="500"></canvas>
        </div>

        <div class="panel">
            <div class="info-box">
                <strong>Wave Function:</strong>
                Before measurement, a particle exists in a superposition described by œà(x).
                The probability of finding it at position x is |œà(x)|¬≤.
                Measurement collapses the wave function to a definite position.
                <br><br>Click on the canvas to "measure" the particle's position!
            </div>

            <div class="state-indicator superposition" id="stateIndicator">
                üåä Superposition State
            </div>

            <div class="legend">
                <div class="legend-item"><div class="legend-dot" style="background: #60a5fa;"></div> œà(x) - Wave function</div>
                <div class="legend-item"><div class="legend-dot" style="background: #4ade80;"></div> |œà|¬≤ - Probability</div>
            </div>

            <h3>Wave Packet Parameters</h3>
            <div class="control-group">
                <label>Wave Packet Type:</label>
                <select id="waveType" onchange="resetWave()">
                    <option value="gaussian">Gaussian</option>
                    <option value="double">Double Gaussian</option>
                    <option value="uniform">Uniform Superposition</option>
                    <option value="triple">Triple Peak</option>
                </select>
            </div>

            <div class="control-group">
                <label>Spread (œÉ): <span class="value-display" id="spreadVal">50</span></label>
                <input type="range" id="spreadSlider" min="20" max="150" value="50" oninput="updateParam()">
            </div>

            <div class="control-group">
                <label>Momentum (k): <span class="value-display" id="momentumVal">0.05</span></label>
                <input type="range" id="momentumSlider" min="0" max="20" value="5" oninput="updateParam()">
            </div>

            <button class="btn-primary" onclick="measure()">Measure (Random)</button>
            <button class="btn-secondary" onclick="resetWave()">Reset Wave</button>
            <button class="btn-secondary" onclick="toggleEvolution()">Toggle Time Evolution</button>

            <h3 style="margin-top: 15px;">Measurement History</h3>
            <canvas id="histCanvas" width="280" height="80"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const histCanvas = document.getElementById('histCanvas');
        const hctx = histCanvas.getContext('2d');

        let waveFunction = [];
        let collapsed = false;
        let collapsedX = 0;
        let spread = 50;
        let momentum = 0.05;
        let time = 0;
        let evolving = false;
        let measurements = [];

        const n = 400;
        const dx = canvas.width / n;

        function updateParam() {
            spread = parseInt(document.getElementById('spreadSlider').value);
            momentum = parseInt(document.getElementById('momentumSlider').value) / 100;
            document.getElementById('spreadVal').textContent = spread;
            document.getElementById('momentumVal').textContent = momentum.toFixed(2);
            if (!collapsed) initWave();
        }

        function initWave() {
            const waveType = document.getElementById('waveType').value;
            waveFunction = [];

            for (let i = 0; i < n; i++) {
                const x = i * dx;
                let real = 0, imag = 0;

                if (waveType === 'gaussian') {
                    const center = canvas.width / 2;
                    const amp = Math.exp(-Math.pow(x - center, 2) / (2 * spread * spread));
                    real = amp * Math.cos(momentum * x);
                    imag = amp * Math.sin(momentum * x);
                } else if (waveType === 'double') {
                    const center1 = canvas.width / 3;
                    const center2 = 2 * canvas.width / 3;
                    const amp1 = Math.exp(-Math.pow(x - center1, 2) / (2 * spread * spread));
                    const amp2 = Math.exp(-Math.pow(x - center2, 2) / (2 * spread * spread));
                    const amp = (amp1 + amp2) / Math.sqrt(2);
                    real = amp * Math.cos(momentum * x);
                    imag = amp * Math.sin(momentum * x);
                } else if (waveType === 'uniform') {
                    const margin = 50;
                    if (x > margin && x < canvas.width - margin) {
                        const amp = 1 / Math.sqrt(canvas.width - 2 * margin);
                        real = amp * Math.cos(momentum * x);
                        imag = amp * Math.sin(momentum * x);
                    }
                } else if (waveType === 'triple') {
                    const centers = [canvas.width / 4, canvas.width / 2, 3 * canvas.width / 4];
                    let amp = 0;
                    for (const c of centers) {
                        amp += Math.exp(-Math.pow(x - c, 2) / (2 * spread * spread));
                    }
                    amp /= Math.sqrt(3);
                    real = amp * Math.cos(momentum * x);
                    imag = amp * Math.sin(momentum * x);
                }

                waveFunction.push({ real, imag });
            }

            normalize();
        }

        function normalize() {
            let total = 0;
            for (const w of waveFunction) {
                total += w.real * w.real + w.imag * w.imag;
            }
            total *= dx;
            const norm = Math.sqrt(total);
            for (const w of waveFunction) {
                w.real /= norm;
                w.imag /= norm;
            }
        }

        function evolve() {
            if (!evolving || collapsed) return;

            time += 0.1;

            // Simple free particle evolution (phase rotation based on momentum)
            for (let i = 0; i < n; i++) {
                const x = i * dx;
                const phase = -momentum * momentum * time * 0.01;
                const cos = Math.cos(phase);
                const sin = Math.sin(phase);
                const r = waveFunction[i].real;
                const im = waveFunction[i].imag;
                waveFunction[i].real = r * cos - im * sin;
                waveFunction[i].imag = r * sin + im * cos;
            }
        }

        function getProbability(index) {
            const w = waveFunction[index];
            return w.real * w.real + w.imag * w.imag;
        }

        function measure() {
            if (collapsed) {
                resetWave();
                return;
            }

            // Sample from probability distribution
            const probs = [];
            let total = 0;
            for (let i = 0; i < n; i++) {
                const p = getProbability(i);
                probs.push(p);
                total += p;
            }

            let r = Math.random() * total;
            for (let i = 0; i < n; i++) {
                r -= probs[i];
                if (r <= 0) {
                    collapseAt(i * dx);
                    return;
                }
            }
            collapseAt(canvas.width / 2);
        }

        function collapseAt(x) {
            collapsedX = x;
            collapsed = true;
            measurements.push(x);
            if (measurements.length > 50) measurements.shift();

            document.getElementById('stateIndicator').className = 'state-indicator collapsed';
            document.getElementById('stateIndicator').textContent = 'üìç Collapsed at x = ' + Math.round(x);

            // Collapse wave function to delta-like peak
            for (let i = 0; i < n; i++) {
                const pos = i * dx;
                const dist = Math.abs(pos - x);
                const amp = Math.exp(-dist * dist / 100);
                waveFunction[i] = { real: amp, imag: 0 };
            }
            normalize();
        }

        function resetWave() {
            collapsed = false;
            time = 0;
            document.getElementById('stateIndicator').className = 'state-indicator superposition';
            document.getElementById('stateIndicator').textContent = 'üåä Superposition State';
            initWave();
        }

        function toggleEvolution() {
            evolving = !evolving;
        }

        function draw() {
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerY = canvas.height / 2;
            const scale = 300;

            // Draw probability density |œà|¬≤
            ctx.fillStyle = 'rgba(74, 222, 128, 0.3)';
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            for (let i = 0; i < n; i++) {
                const x = i * dx;
                const prob = getProbability(i);
                const y = centerY - prob * scale * 2;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(canvas.width, centerY);
            ctx.closePath();
            ctx.fill();

            // Draw |œà|¬≤ outline
            ctx.strokeStyle = '#4ade80';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < n; i++) {
                const x = i * dx;
                const prob = getProbability(i);
                const y = centerY - prob * scale * 2;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw real part of œà
            ctx.strokeStyle = '#60a5fa';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < n; i++) {
                const x = i * dx;
                const y = centerY + 150 - waveFunction[i].real * scale * 0.5;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw imaginary part of œà
            ctx.strokeStyle = 'rgba(250, 204, 21, 0.7)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i < n; i++) {
                const x = i * dx;
                const y = centerY + 150 - waveFunction[i].imag * scale * 0.5;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw collapsed position marker
            if (collapsed) {
                ctx.strokeStyle = '#f87171';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(collapsedX, 0);
                ctx.lineTo(collapsedX, canvas.height);
                ctx.stroke();

                ctx.fillStyle = '#f87171';
                ctx.beginPath();
                ctx.arc(collapsedX, centerY, 10, 0, Math.PI * 2);
                ctx.fill();
            }

            // Axes
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.moveTo(0, centerY + 150);
            ctx.lineTo(canvas.width, centerY + 150);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#fff';
            ctx.font = '12px sans-serif';
            ctx.fillText('|œà(x)|¬≤ - Probability Density', 20, 30);
            ctx.fillText('Re(œà) and Im(œà)', 20, centerY + 140);
            ctx.fillText('x ‚Üí', canvas.width - 30, centerY + 15);
        }

        function drawHistogram() {
            hctx.fillStyle = '#050510';
            hctx.fillRect(0, 0, histCanvas.width, histCanvas.height);

            if (measurements.length === 0) {
                hctx.fillStyle = 'rgba(255,255,255,0.5)';
                hctx.font = '11px sans-serif';
                hctx.fillText('Measurement histogram will appear here', 20, 45);
                return;
            }

            // Create histogram bins
            const bins = 20;
            const counts = new Array(bins).fill(0);
            for (const m of measurements) {
                const bin = Math.floor(m / canvas.width * bins);
                if (bin >= 0 && bin < bins) counts[bin]++;
            }

            const maxCount = Math.max(...counts, 1);
            const barWidth = histCanvas.width / bins;

            hctx.fillStyle = '#4ade80';
            for (let i = 0; i < bins; i++) {
                const height = (counts[i] / maxCount) * (histCanvas.height - 20);
                hctx.fillRect(i * barWidth + 1, histCanvas.height - height, barWidth - 2, height);
            }

            hctx.fillStyle = '#fff';
            hctx.font = '10px sans-serif';
            hctx.fillText(`${measurements.length} measurements`, 5, 12);
        }

        // Click to measure
        canvas.addEventListener('click', (e) => {
            if (collapsed) {
                resetWave();
            } else {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (canvas.width / rect.width);
                collapseAt(x);
            }
        });

        function animate() {
            evolve();
            draw();
            drawHistogram();
            requestAnimationFrame(animate);
        }

        updateParam();
        initWave();
        animate();
    </script>
</body>
</html>
