<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Tunneling | Quantum Physics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(255, 150, 100, 0.3);
        }
        h1 { color: #ff9664; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"] { width: 100%; }
        .value { float: right; color: #ff9664; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #ff9664; color: #0a0a1a;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #ffb088; }
        .probability-bar {
            height: 30px; background: #222; border-radius: 5px;
            margin: 10px 0; overflow: hidden; display: flex;
        }
        .prob-left { background: #64c8ff; transition: width 0.3s; }
        .prob-barrier { background: #ff9664; transition: width 0.3s; }
        .prob-right { background: #64ff64; transition: width 0.3s; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #ff9664; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #ff9664; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">← Back to Quantum Physics</a>

    <div class="controls">
        <h1>Quantum Tunneling</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Wave function penetrating a potential barrier</p>

        <div class="control-group">
            <label>Barrier Height (V₀): <span class="value" id="heightValue">0.8</span></label>
            <input type="range" id="barrierHeight" min="0.1" max="2" step="0.1" value="0.8">
        </div>

        <div class="control-group">
            <label>Barrier Width: <span class="value" id="widthValue">30</span></label>
            <input type="range" id="barrierWidth" min="10" max="80" value="30">
        </div>

        <div class="control-group">
            <label>Particle Energy (E): <span class="value" id="energyValue">0.5</span></label>
            <input type="range" id="particleEnergy" min="0.1" max="1.5" step="0.1" value="0.5">
        </div>

        <div class="control-group">
            <label>Wave Packet Width: <span class="value" id="packetValue">40</span></label>
            <input type="range" id="packetWidth" min="20" max="80" value="40">
        </div>

        <button id="launchBtn">Launch Particle</button>
        <button id="resetBtn">Reset</button>

        <div style="margin-top:15px; font-size:0.85em; color:#888;">Probability Distribution:</div>
        <div class="probability-bar">
            <div class="prob-left" id="probLeft" style="width:100%"></div>
            <div class="prob-barrier" id="probBarrier" style="width:0%"></div>
            <div class="prob-right" id="probRight" style="width:0%"></div>
        </div>
        <div style="display:flex; justify-content:space-between; font-size:0.75em; color:#888;">
            <span>Reflected</span>
            <span>In Barrier</span>
            <span>Transmitted</span>
        </div>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Transmission Prob (T)</span>
                <span class="stat-value" id="transProb">0%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Reflection Prob (R)</span>
                <span class="stat-value" id="reflProb">100%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">E/V₀ Ratio</span>
                <span class="stat-value" id="evRatio">0.63</span>
            </div>
        </div>

        <div class="info">
            <strong>Tunneling:</strong> Even when E < V₀ (classically forbidden), quantum particles have non-zero probability of penetrating the barrier.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        const N = 2048;
        let psiReal = new Float64Array(N);
        let psiImag = new Float64Array(N);
        let potential = new Float64Array(N);

        let barrierHeight = 0.8;
        let barrierWidth = 30;
        let particleEnergy = 0.5;
        let packetWidth = 40;

        let running = false;
        let launched = false;

        const dx = 1;
        const dt = 0.3;

        function initPotential() {
            const barrierStart = N / 2 - barrierWidth / 2;
            const barrierEnd = N / 2 + barrierWidth / 2;

            for (let i = 0; i < N; i++) {
                if (i >= barrierStart && i <= barrierEnd) {
                    potential[i] = barrierHeight;
                } else {
                    potential[i] = 0;
                }

                // Add walls at edges
                if (i < 50 || i > N - 50) {
                    potential[i] = 10;
                }
            }
        }

        function initWavePacket() {
            initPotential();

            const center = N / 4;
            const k0 = Math.sqrt(2 * particleEnergy); // momentum from energy

            let norm = 0;
            for (let i = 0; i < N; i++) {
                const x = i - center;
                const envelope = Math.exp(-x * x / (2 * packetWidth * packetWidth));
                psiReal[i] = envelope * Math.cos(k0 * i);
                psiImag[i] = envelope * Math.sin(k0 * i);
                norm += psiReal[i] * psiReal[i] + psiImag[i] * psiImag[i];
            }

            norm = Math.sqrt(norm * dx);
            for (let i = 0; i < N; i++) {
                psiReal[i] /= norm;
                psiImag[i] /= norm;
            }

            launched = true;
            running = true;
            document.getElementById('launchBtn').textContent = 'Pause';
        }

        function evolve() {
            const coeff = dt / (2 * dx * dx);

            const newReal = new Float64Array(N);
            const newImag = new Float64Array(N);

            for (let i = 1; i < N - 1; i++) {
                const d2Real = psiReal[i + 1] - 2 * psiReal[i] + psiReal[i - 1];
                const d2Imag = psiImag[i + 1] - 2 * psiImag[i] + psiImag[i - 1];
                const V = potential[i];

                newReal[i] = psiReal[i] + coeff * d2Imag - dt * V * psiImag[i];
                newImag[i] = psiImag[i] - coeff * d2Real + dt * V * psiReal[i];
            }

            // Absorbing boundaries
            for (let i = 0; i < 50; i++) {
                const factor = i / 50;
                newReal[i] *= factor;
                newImag[i] *= factor;
                newReal[N - 1 - i] *= factor;
                newImag[N - 1 - i] *= factor;
            }

            // Renormalize
            let norm = 0;
            for (let i = 0; i < N; i++) {
                norm += newReal[i] * newReal[i] + newImag[i] * newImag[i];
            }
            norm = Math.sqrt(norm * dx);

            for (let i = 0; i < N; i++) {
                psiReal[i] = newReal[i] / norm;
                psiImag[i] = newImag[i] / norm;
            }
        }

        function calculateProbabilities() {
            const barrierStart = N / 2 - barrierWidth / 2;
            const barrierEnd = N / 2 + barrierWidth / 2;

            let probLeft = 0;
            let probBarrier = 0;
            let probRight = 0;

            for (let i = 0; i < N; i++) {
                const prob = psiReal[i] * psiReal[i] + psiImag[i] * psiImag[i];

                if (i < barrierStart) {
                    probLeft += prob;
                } else if (i <= barrierEnd) {
                    probBarrier += prob;
                } else {
                    probRight += prob;
                }
            }

            const total = probLeft + probBarrier + probRight;
            return {
                left: probLeft / total,
                barrier: probBarrier / total,
                right: probRight / total
            };
        }

        function calculateTheoreticalT() {
            // Analytical tunneling probability for rectangular barrier
            if (particleEnergy >= barrierHeight) {
                return 1; // Classical transmission
            }

            const kappa = Math.sqrt(2 * (barrierHeight - particleEnergy));
            const k = Math.sqrt(2 * particleEnergy);
            const L = barrierWidth;

            // T = 1 / (1 + sinh²(κL) * (V₀²)/(4E(V₀-E)))
            const sinh = Math.sinh(kappa * L * 0.1);
            const factor = (barrierHeight * barrierHeight) / (4 * particleEnergy * (barrierHeight - particleEnergy));

            return 1 / (1 + sinh * sinh * factor);
        }

        function draw() {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const plotWidth = canvas.width - 350;
            const plotHeight = canvas.height - 100;
            const plotX = 50;
            const plotY = 50;
            const scaleX = plotWidth / N;
            const baseY = plotY + plotHeight * 0.6;

            // Draw potential barrier
            ctx.beginPath();
            ctx.fillStyle = 'rgba(255, 150, 100, 0.3)';
            const potScale = plotHeight * 0.4 / Math.max(...potential, 1);

            const barrierStart = N / 2 - barrierWidth / 2;
            const barrierEnd = N / 2 + barrierWidth / 2;

            ctx.moveTo(plotX + barrierStart * scaleX, baseY);
            for (let i = barrierStart; i <= barrierEnd; i++) {
                const x = plotX + i * scaleX;
                const y = baseY - potential[i] * potScale;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(plotX + barrierEnd * scaleX, baseY);
            ctx.closePath();
            ctx.fill();

            // Draw potential outline
            ctx.beginPath();
            ctx.strokeStyle = '#ff9664';
            ctx.lineWidth = 2;
            for (let i = 0; i < N; i++) {
                const x = plotX + i * scaleX;
                const y = baseY - potential[i] * potScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw energy level
            const energyY = baseY - particleEnergy * potScale;
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
            ctx.setLineDash([5, 5]);
            ctx.moveTo(plotX, energyY);
            ctx.lineTo(plotX + plotWidth, energyY);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#64c8ff';
            ctx.font = '12px sans-serif';
            ctx.fillText('E', plotX + plotWidth + 10, energyY + 4);

            // Draw probability density
            ctx.beginPath();
            ctx.strokeStyle = '#64c8ff';
            ctx.lineWidth = 2;

            const probScale = plotHeight * 0.5 * N * 0.3;
            for (let i = 0; i < N; i++) {
                const x = plotX + i * scaleX;
                const prob = psiReal[i] * psiReal[i] + psiImag[i] * psiImag[i];
                const y = baseY - prob * probScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Fill probability
            ctx.beginPath();
            ctx.fillStyle = 'rgba(100, 200, 255, 0.3)';
            ctx.moveTo(plotX, baseY);
            for (let i = 0; i < N; i++) {
                const x = plotX + i * scaleX;
                const prob = psiReal[i] * psiReal[i] + psiImag[i] * psiImag[i];
                const y = baseY - prob * probScale;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(plotX + N * scaleX, baseY);
            ctx.closePath();
            ctx.fill();

            // Draw real part (faint)
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.4)';
            ctx.lineWidth = 1;

            const waveScale = plotHeight * 0.3 * Math.sqrt(N);
            for (let i = 0; i < N; i++) {
                const x = plotX + i * scaleX;
                const y = baseY - psiReal[i] * waveScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw baseline
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.moveTo(plotX, baseY);
            ctx.lineTo(plotX + plotWidth, baseY);
            ctx.stroke();

            // Update probability display
            if (launched) {
                const probs = calculateProbabilities();
                document.getElementById('probLeft').style.width = (probs.left * 100) + '%';
                document.getElementById('probBarrier').style.width = (probs.barrier * 100) + '%';
                document.getElementById('probRight').style.width = (probs.right * 100) + '%';

                document.getElementById('transProb').textContent = (probs.right * 100).toFixed(1) + '%';
                document.getElementById('reflProb').textContent = (probs.left * 100).toFixed(1) + '%';
            }

            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '14px sans-serif';
            ctx.fillText('V₀', plotX + N / 2 * scaleX - 10, baseY - barrierHeight * potScale - 10);
        }

        function updateStats() {
            document.getElementById('evRatio').textContent = (particleEnergy / barrierHeight).toFixed(2);

            const T = calculateTheoreticalT();
            // Theoretical values before launch
            if (!launched) {
                document.getElementById('transProb').textContent = (T * 100).toFixed(1) + '% (theory)';
                document.getElementById('reflProb').textContent = ((1 - T) * 100).toFixed(1) + '% (theory)';
            }
        }

        function animate() {
            if (running && launched) {
                for (let i = 0; i < 10; i++) evolve();
            }
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('barrierHeight').oninput = (e) => {
            barrierHeight = parseFloat(e.target.value);
            document.getElementById('heightValue').textContent = barrierHeight.toFixed(1);
            initPotential();
            updateStats();
        };

        document.getElementById('barrierWidth').oninput = (e) => {
            barrierWidth = parseInt(e.target.value);
            document.getElementById('widthValue').textContent = barrierWidth;
            initPotential();
            updateStats();
        };

        document.getElementById('particleEnergy').oninput = (e) => {
            particleEnergy = parseFloat(e.target.value);
            document.getElementById('energyValue').textContent = particleEnergy.toFixed(1);
            updateStats();
        };

        document.getElementById('packetWidth').oninput = (e) => {
            packetWidth = parseInt(e.target.value);
            document.getElementById('packetValue').textContent = packetWidth;
        };

        document.getElementById('launchBtn').onclick = () => {
            if (!launched) {
                initWavePacket();
            } else {
                running = !running;
                document.getElementById('launchBtn').textContent = running ? 'Pause' : 'Resume';
            }
        };

        document.getElementById('resetBtn').onclick = () => {
            psiReal.fill(0);
            psiImag.fill(0);
            launched = false;
            running = false;
            document.getElementById('launchBtn').textContent = 'Launch Particle';
            document.getElementById('probLeft').style.width = '100%';
            document.getElementById('probBarrier').style.width = '0%';
            document.getElementById('probRight').style.width = '0%';
            initPotential();
            updateStats();
        };

        // Initialize
        initPotential();
        updateStats();
        animate();
    </script>
</body>
</html>
