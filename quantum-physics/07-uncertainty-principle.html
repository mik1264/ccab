<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uncertainty Principle | Quantum Physics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(255, 100, 200, 0.3);
        }
        h1 { color: #ff64c8; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"] { width: 100%; }
        .value { float: right; color: #ff64c8; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #ff64c8; color: #fff;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #ff88d8; }
        .uncertainty-display {
            display: grid; grid-template-columns: 1fr 1fr;
            gap: 10px; margin: 15px 0;
        }
        .uncert-box {
            padding: 15px; border-radius: 10px; text-align: center;
        }
        .uncert-x { background: rgba(100, 200, 255, 0.2); }
        .uncert-p { background: rgba(255, 150, 100, 0.2); }
        .uncert-value { font-size: 1.3em; font-weight: bold; }
        .uncert-label { font-size: 0.85em; color: #888; }
        .product-display {
            padding: 15px; border-radius: 10px; text-align: center;
            background: rgba(255, 100, 200, 0.2); margin: 10px 0;
        }
        .formula { font-family: serif; font-style: italic; font-size: 1.2em; margin: 10px 0; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #ff64c8; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">← Back to Quantum Physics</a>

    <div class="controls">
        <h1>Uncertainty Principle</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Δx · Δp ≥ ℏ/2 visualization</p>

        <div class="control-group">
            <label>Position Uncertainty (Δx): <span class="value" id="dxValue">50</span></label>
            <input type="range" id="deltaX" min="10" max="200" value="50">
        </div>

        <div class="control-group">
            <label>Central Momentum (p₀): <span class="value" id="p0Value">0.1</span></label>
            <input type="range" id="momentum" min="-0.3" max="0.3" step="0.01" value="0.1">
        </div>

        <button id="animateBtn">Animate Evolution</button>
        <button id="resetBtn">Reset</button>

        <div class="uncertainty-display">
            <div class="uncert-box uncert-x">
                <div class="uncert-value" id="deltaXDisplay" style="color:#64c8ff;">50</div>
                <div class="uncert-label">Δx (position)</div>
            </div>
            <div class="uncert-box uncert-p">
                <div class="uncert-value" id="deltaPDisplay" style="color:#ff9664;">0.010</div>
                <div class="uncert-label">Δp (momentum)</div>
            </div>
        </div>

        <div class="product-display">
            <div style="color:#888; font-size:0.85em;">Uncertainty Product</div>
            <div class="uncert-value" id="productDisplay" style="color:#ff64c8;">0.500</div>
            <div class="formula">Δx · Δp ≥ ℏ/2 = 0.5</div>
        </div>

        <div style="text-align:center; margin:15px 0;">
            <canvas id="phaseSpace" width="240" height="200"></canvas>
            <div style="font-size:0.8em; color:#888;">Phase Space (x, p)</div>
        </div>

        <div class="info">
            <strong>Heisenberg's Principle:</strong> The more precisely you know position, the less precisely you can know momentum, and vice versa. This is fundamental to nature, not a measurement limitation.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const phaseCanvas = document.getElementById('phaseSpace');
        const phaseCtx = phaseCanvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        const N = 1024;
        let psiReal = new Float64Array(N);
        let psiImag = new Float64Array(N);

        let deltaX = 50;
        let p0 = 0.1;
        let time = 0;
        let animating = false;

        const dx = 1;
        const dt = 0.5;
        const hbar = 1;

        function initWavePacket() {
            const center = N / 2;
            const sigma = deltaX;

            let norm = 0;
            for (let i = 0; i < N; i++) {
                const x = i - center;
                const envelope = Math.exp(-x * x / (4 * sigma * sigma));
                psiReal[i] = envelope * Math.cos(p0 * i);
                psiImag[i] = envelope * Math.sin(p0 * i);
                norm += psiReal[i] * psiReal[i] + psiImag[i] * psiImag[i];
            }

            norm = Math.sqrt(norm * dx);
            for (let i = 0; i < N; i++) {
                psiReal[i] /= norm;
                psiImag[i] /= norm;
            }

            time = 0;
        }

        function evolve() {
            const coeff = dt / (2 * dx * dx);

            const newReal = new Float64Array(N);
            const newImag = new Float64Array(N);

            for (let i = 1; i < N - 1; i++) {
                const d2Real = psiReal[i + 1] - 2 * psiReal[i] + psiReal[i - 1];
                const d2Imag = psiImag[i + 1] - 2 * psiImag[i] + psiImag[i - 1];

                newReal[i] = psiReal[i] + coeff * d2Imag;
                newImag[i] = psiImag[i] - coeff * d2Real;
            }

            // Renormalize
            let norm = 0;
            for (let i = 0; i < N; i++) {
                norm += newReal[i] * newReal[i] + newImag[i] * newImag[i];
            }
            norm = Math.sqrt(norm * dx);

            for (let i = 0; i < N; i++) {
                psiReal[i] = newReal[i] / norm;
                psiImag[i] = newImag[i] / norm;
            }

            time += dt;
        }

        function calculateUncertainties() {
            let expX = 0, expX2 = 0;
            let norm = 0;

            for (let i = 0; i < N; i++) {
                const prob = psiReal[i] * psiReal[i] + psiImag[i] * psiImag[i];
                const x = i - N / 2;
                norm += prob;
                expX += x * prob;
                expX2 += x * x * prob;
            }

            expX /= norm;
            expX2 /= norm;
            const uncertaintyX = Math.sqrt(expX2 - expX * expX);

            // Momentum uncertainty from Fourier transform (using wave packet width)
            // For Gaussian: Δp = ℏ/(2Δx)
            const uncertaintyP = hbar / (2 * uncertaintyX);

            return { deltaX: uncertaintyX, deltaP: uncertaintyP };
        }

        function getMomentumDistribution() {
            // Simple DFT for momentum space
            const momentum = new Float64Array(N);
            const pMax = Math.PI / dx;

            for (let k = 0; k < N; k++) {
                let realSum = 0, imagSum = 0;
                const p = (k < N / 2 ? k : k - N) * (2 * pMax / N);

                for (let x = 0; x < N; x++) {
                    const phase = -p * x * dx;
                    realSum += psiReal[x] * Math.cos(phase) - psiImag[x] * Math.sin(phase);
                    imagSum += psiReal[x] * Math.sin(phase) + psiImag[x] * Math.cos(phase);
                }

                momentum[k] = (realSum * realSum + imagSum * imagSum) / N;
            }

            return momentum;
        }

        function draw() {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const plotWidth = canvas.width - 350;
            const plotX = 50;

            // Draw position space
            drawPositionSpace(plotX, 100, plotWidth, 200);

            // Draw momentum space
            drawMomentumSpace(plotX, 350, plotWidth, 200);

            // Draw phase space
            drawPhaseSpace();

            // Update uncertainty displays
            const uncert = calculateUncertainties();
            document.getElementById('deltaXDisplay').textContent = uncert.deltaX.toFixed(1);
            document.getElementById('deltaPDisplay').textContent = uncert.deltaP.toFixed(4);

            const product = uncert.deltaX * uncert.deltaP;
            document.getElementById('productDisplay').textContent = product.toFixed(3);

            // Color product based on uncertainty principle
            const productEl = document.getElementById('productDisplay');
            if (product >= 0.5) {
                productEl.style.color = '#64ff64';
            } else {
                productEl.style.color = '#ff6464';
            }
        }

        function drawPositionSpace(x, y, w, h) {
            const scaleX = w / N;
            const baseY = y + h / 2;

            // Background
            ctx.fillStyle = 'rgba(100, 200, 255, 0.05)';
            ctx.fillRect(x, y, w, h);

            // Title
            ctx.fillStyle = '#64c8ff';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText('Position Space |ψ(x)|²', x + 10, y + 20);

            // Draw probability density
            ctx.beginPath();
            ctx.strokeStyle = '#64c8ff';
            ctx.lineWidth = 2;

            const probScale = h * 0.8 * N * 0.3;
            for (let i = 0; i < N; i++) {
                const px = x + i * scaleX;
                const prob = psiReal[i] * psiReal[i] + psiImag[i] * psiImag[i];
                const py = baseY - prob * probScale;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Fill
            ctx.beginPath();
            ctx.fillStyle = 'rgba(100, 200, 255, 0.3)';
            ctx.moveTo(x, baseY);
            for (let i = 0; i < N; i++) {
                const px = x + i * scaleX;
                const prob = psiReal[i] * psiReal[i] + psiImag[i] * psiImag[i];
                const py = baseY - prob * probScale;
                ctx.lineTo(px, py);
            }
            ctx.lineTo(x + w, baseY);
            ctx.closePath();
            ctx.fill();

            // Draw uncertainty range
            const uncert = calculateUncertainties();
            const center = N / 2;
            const leftX = x + (center - uncert.deltaX) * scaleX;
            const rightX = x + (center + uncert.deltaX) * scaleX;

            ctx.strokeStyle = 'rgba(255, 100, 200, 0.5)';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(leftX, y);
            ctx.lineTo(leftX, y + h);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(rightX, y);
            ctx.lineTo(rightX, y + h);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#ff64c8';
            ctx.font = '12px sans-serif';
            ctx.fillText('Δx', (leftX + rightX) / 2 - 10, y + h - 10);

            // Baseline
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.moveTo(x, baseY);
            ctx.lineTo(x + w, baseY);
            ctx.stroke();
        }

        function drawMomentumSpace(x, y, w, h) {
            const momentum = getMomentumDistribution();
            const baseY = y + h / 2;

            // Background
            ctx.fillStyle = 'rgba(255, 150, 100, 0.05)';
            ctx.fillRect(x, y, w, h);

            // Title
            ctx.fillStyle = '#ff9664';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText('Momentum Space |φ(p)|²', x + 10, y + 20);

            // Draw momentum distribution
            ctx.beginPath();
            ctx.strokeStyle = '#ff9664';
            ctx.lineWidth = 2;

            const maxMom = Math.max(...momentum);
            const momScale = (h * 0.8) / maxMom;

            // Reorder for display (shift zero to center)
            for (let i = 0; i < N; i++) {
                const idx = (i + N / 2) % N;
                const px = x + (i / N) * w;
                const py = baseY - momentum[idx] * momScale;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Fill
            ctx.beginPath();
            ctx.fillStyle = 'rgba(255, 150, 100, 0.3)';
            ctx.moveTo(x, baseY);
            for (let i = 0; i < N; i++) {
                const idx = (i + N / 2) % N;
                const px = x + (i / N) * w;
                const py = baseY - momentum[idx] * momScale;
                ctx.lineTo(px, py);
            }
            ctx.lineTo(x + w, baseY);
            ctx.closePath();
            ctx.fill();

            // Baseline
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.moveTo(x, baseY);
            ctx.lineTo(x + w, baseY);
            ctx.stroke();

            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.fillText('p', x + w / 2, y + h - 5);
        }

        function drawPhaseSpace() {
            const w = phaseCanvas.width;
            const h = phaseCanvas.height;

            phaseCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            phaseCtx.fillRect(0, 0, w, h);

            // Draw uncertainty ellipse
            const uncert = calculateUncertainties();
            const cx = w / 2;
            const cy = h / 2;

            const scaleX = w / 200;
            const scaleP = h / 0.1;

            // Draw axes
            phaseCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            phaseCtx.beginPath();
            phaseCtx.moveTo(0, cy);
            phaseCtx.lineTo(w, cy);
            phaseCtx.moveTo(cx, 0);
            phaseCtx.lineTo(cx, h);
            phaseCtx.stroke();

            // Draw uncertainty region
            phaseCtx.beginPath();
            phaseCtx.ellipse(cx, cy, uncert.deltaX * scaleX, uncert.deltaP * scaleP, 0, 0, Math.PI * 2);
            phaseCtx.fillStyle = 'rgba(255, 100, 200, 0.3)';
            phaseCtx.fill();
            phaseCtx.strokeStyle = '#ff64c8';
            phaseCtx.lineWidth = 2;
            phaseCtx.stroke();

            // Labels
            phaseCtx.fillStyle = '#888';
            phaseCtx.font = '10px sans-serif';
            phaseCtx.fillText('x', w - 15, cy - 5);
            phaseCtx.fillText('p', cx + 5, 12);

            // Draw minimum uncertainty circle for reference
            const minRadius = Math.sqrt(0.5) * Math.sqrt(scaleX * scaleP);
            phaseCtx.beginPath();
            phaseCtx.arc(cx, cy, minRadius * 10, 0, Math.PI * 2);
            phaseCtx.strokeStyle = 'rgba(100, 255, 100, 0.3)';
            phaseCtx.setLineDash([3, 3]);
            phaseCtx.stroke();
            phaseCtx.setLineDash([]);
        }

        function animate() {
            if (animating) {
                for (let i = 0; i < 5; i++) evolve();
            }
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('deltaX').oninput = (e) => {
            deltaX = parseInt(e.target.value);
            document.getElementById('dxValue').textContent = deltaX;
            initWavePacket();
        };

        document.getElementById('momentum').oninput = (e) => {
            p0 = parseFloat(e.target.value);
            document.getElementById('p0Value').textContent = p0.toFixed(2);
            initWavePacket();
        };

        document.getElementById('animateBtn').onclick = () => {
            animating = !animating;
            document.getElementById('animateBtn').textContent = animating ? 'Pause' : 'Animate Evolution';
        };

        document.getElementById('resetBtn').onclick = () => {
            animating = false;
            document.getElementById('animateBtn').textContent = 'Animate Evolution';
            initWavePacket();
        };

        // Initialize
        initWavePacket();
        animate();
    </script>
</body>
</html>
