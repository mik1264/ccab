<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schrödinger Equation | Quantum Physics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(100, 200, 255, 0.3);
        }
        h1 { color: #64c8ff; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        select { padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #64c8ff; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #64c8ff; color: #0a0a1a;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #8cd8ff; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #64c8ff; font-weight: bold; }
        .legend { display: flex; gap: 15px; margin-top: 10px; font-size: 0.8em; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 20px; height: 3px; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #64c8ff; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">← Back to Quantum Physics</a>

    <div class="controls">
        <h1>Schrödinger Equation</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Time-dependent wave function evolution</p>

        <div class="control-group">
            <label>Potential Well</label>
            <select id="potential">
                <option value="infinite">Infinite Square Well</option>
                <option value="harmonic">Harmonic Oscillator</option>
                <option value="barrier">Potential Barrier</option>
                <option value="step">Step Potential</option>
                <option value="double">Double Well</option>
            </select>
        </div>

        <div class="control-group">
            <label>Energy Level (n): <span class="value" id="nValue">1</span></label>
            <input type="range" id="energyLevel" min="1" max="10" value="1">
        </div>

        <div class="control-group">
            <label>Wave Packet Width: <span class="value" id="sigmaValue">30</span></label>
            <input type="range" id="sigma" min="10" max="100" value="30">
        </div>

        <div class="control-group">
            <label>Initial Momentum: <span class="value" id="k0Value">0.1</span></label>
            <input type="range" id="k0" min="-0.3" max="0.3" step="0.01" value="0.1">
        </div>

        <button id="startBtn">Start</button>
        <button id="resetBtn">Reset Wave Packet</button>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background:#64c8ff"></div>
                <span>|ψ|² (Probability)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background:#ff6464"></div>
                <span>Re(ψ)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background:#64ff64"></div>
                <span>Im(ψ)</span>
            </div>
        </div>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Time</span>
                <span class="stat-value" id="timeDisplay">0.00</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">⟨x⟩</span>
                <span class="stat-value" id="expX">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Δx</span>
                <span class="stat-value" id="uncertX">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Total Probability</span>
                <span class="stat-value" id="totalProb">1.00</span>
            </div>
        </div>

        <div class="info">
            The wave function ψ(x,t) evolves according to<br>
            iℏ ∂ψ/∂t = Ĥψ<br>
            Click on the visualization to add a wave packet!
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initWaveFunction();
        }
        resize();
        window.onresize = resize;

        const N = 1024; // Grid points
        let psiReal = new Float64Array(N);
        let psiImag = new Float64Array(N);
        let potential = new Float64Array(N);
        let running = false;
        let time = 0;

        // Parameters
        let potentialType = 'infinite';
        let energyLevel = 1;
        let sigma = 30;
        let k0 = 0.1;

        const dx = 1;
        const dt = 0.5;
        const hbar = 1;
        const m = 1;

        function initPotential() {
            const wellStart = N * 0.1;
            const wellEnd = N * 0.9;
            const wellCenter = N / 2;

            for (let i = 0; i < N; i++) {
                switch (potentialType) {
                    case 'infinite':
                        potential[i] = (i < wellStart || i > wellEnd) ? 1000 : 0;
                        break;
                    case 'harmonic':
                        const x = (i - wellCenter) / 50;
                        potential[i] = 0.01 * x * x;
                        break;
                    case 'barrier':
                        potential[i] = (i > wellCenter - 20 && i < wellCenter + 20) ? 0.5 : 0;
                        break;
                    case 'step':
                        potential[i] = i > wellCenter ? 0.3 : 0;
                        break;
                    case 'double':
                        const xd = (i - wellCenter) / 50;
                        potential[i] = 0.01 * Math.pow(xd * xd - 4, 2);
                        break;
                }
            }
        }

        function initWaveFunction() {
            initPotential();

            const wellStart = N * 0.1;
            const wellEnd = N * 0.9;
            const wellWidth = wellEnd - wellStart;
            const center = potentialType === 'barrier' ? N * 0.3 : N / 2;

            // Initialize as Gaussian wave packet
            let norm = 0;
            for (let i = 0; i < N; i++) {
                const x = i - center;
                const envelope = Math.exp(-x * x / (2 * sigma * sigma));
                psiReal[i] = envelope * Math.cos(k0 * i);
                psiImag[i] = envelope * Math.sin(k0 * i);
                norm += psiReal[i] * psiReal[i] + psiImag[i] * psiImag[i];
            }

            // Normalize
            norm = Math.sqrt(norm * dx);
            for (let i = 0; i < N; i++) {
                psiReal[i] /= norm;
                psiImag[i] /= norm;
            }

            time = 0;
        }

        function evolve() {
            // Split-step method (simplified)
            const coeff = hbar * dt / (2 * m * dx * dx);

            // Apply kinetic evolution (finite difference)
            const newReal = new Float64Array(N);
            const newImag = new Float64Array(N);

            for (let i = 1; i < N - 1; i++) {
                // Kinetic term
                const d2Real = psiReal[i + 1] - 2 * psiReal[i] + psiReal[i - 1];
                const d2Imag = psiImag[i + 1] - 2 * psiImag[i] + psiImag[i - 1];

                // Potential term
                const V = potential[i];

                // Time evolution: dψ/dt = (i*hbar/2m)∇²ψ - (i/hbar)*V*ψ
                newReal[i] = psiReal[i] + coeff * d2Imag - (dt / hbar) * V * psiImag[i];
                newImag[i] = psiImag[i] - coeff * d2Real + (dt / hbar) * V * psiReal[i];
            }

            // Boundary conditions
            newReal[0] = 0;
            newReal[N - 1] = 0;
            newImag[0] = 0;
            newImag[N - 1] = 0;

            // Renormalize to prevent drift
            let norm = 0;
            for (let i = 0; i < N; i++) {
                norm += newReal[i] * newReal[i] + newImag[i] * newImag[i];
            }
            norm = Math.sqrt(norm * dx);

            for (let i = 0; i < N; i++) {
                psiReal[i] = newReal[i] / norm;
                psiImag[i] = newImag[i] / norm;
            }

            time += dt;
        }

        function calculateExpectations() {
            let totalProb = 0;
            let expX = 0;
            let expX2 = 0;

            for (let i = 0; i < N; i++) {
                const prob = psiReal[i] * psiReal[i] + psiImag[i] * psiImag[i];
                totalProb += prob;
                expX += i * prob;
                expX2 += i * i * prob;
            }

            totalProb *= dx;
            expX *= dx;
            expX2 *= dx;

            const deltaX = Math.sqrt(expX2 - expX * expX);

            return { totalProb, expX, deltaX };
        }

        function draw() {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const plotWidth = canvas.width - 350;
            const plotHeight = canvas.height - 100;
            const plotX = 50;
            const plotY = 50;
            const scaleX = plotWidth / N;
            const baseY = plotY + plotHeight / 2;

            // Draw potential
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            const potMax = Math.max(...potential);
            const potScale = potMax > 0 ? plotHeight * 0.3 / potMax : 1;

            for (let i = 0; i < N; i++) {
                const x = plotX + i * scaleX;
                const y = baseY - potential[i] * potScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Fill potential region
            ctx.beginPath();
            ctx.fillStyle = 'rgba(100, 100, 100, 0.2)';
            ctx.moveTo(plotX, baseY);
            for (let i = 0; i < N; i++) {
                const x = plotX + i * scaleX;
                const y = baseY - potential[i] * potScale;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(plotX + N * scaleX, baseY);
            ctx.closePath();
            ctx.fill();

            // Draw probability density |ψ|²
            ctx.beginPath();
            ctx.strokeStyle = '#64c8ff';
            ctx.lineWidth = 2;

            const probScale = plotHeight * 0.4;
            for (let i = 0; i < N; i++) {
                const x = plotX + i * scaleX;
                const prob = psiReal[i] * psiReal[i] + psiImag[i] * psiImag[i];
                const y = baseY - prob * probScale * N * 0.5;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Fill probability
            ctx.beginPath();
            ctx.fillStyle = 'rgba(100, 200, 255, 0.2)';
            ctx.moveTo(plotX, baseY);
            for (let i = 0; i < N; i++) {
                const x = plotX + i * scaleX;
                const prob = psiReal[i] * psiReal[i] + psiImag[i] * psiImag[i];
                const y = baseY - prob * probScale * N * 0.5;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(plotX + N * scaleX, baseY);
            ctx.closePath();
            ctx.fill();

            // Draw real part
            ctx.beginPath();
            ctx.strokeStyle = '#ff6464';
            ctx.lineWidth = 1;
            const waveScale = plotHeight * 0.3;

            for (let i = 0; i < N; i++) {
                const x = plotX + i * scaleX;
                const y = baseY - psiReal[i] * waveScale * Math.sqrt(N);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw imaginary part
            ctx.beginPath();
            ctx.strokeStyle = '#64ff64';

            for (let i = 0; i < N; i++) {
                const x = plotX + i * scaleX;
                const y = baseY - psiImag[i] * waveScale * Math.sqrt(N);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw baseline
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.moveTo(plotX, baseY);
            ctx.lineTo(plotX + plotWidth, baseY);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.fillText('x', plotX + plotWidth / 2, baseY + 30);
            ctx.fillText('ψ(x,t)', plotX - 30, plotY + 20);

            // Update stats
            const exp = calculateExpectations();
            document.getElementById('timeDisplay').textContent = time.toFixed(2);
            document.getElementById('expX').textContent = exp.expX.toFixed(1);
            document.getElementById('uncertX').textContent = exp.deltaX.toFixed(1);
            document.getElementById('totalProb').textContent = exp.totalProb.toFixed(4);
        }

        function animate() {
            if (running) {
                for (let i = 0; i < 5; i++) evolve();
            }
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('potential').onchange = (e) => {
            potentialType = e.target.value;
            initWaveFunction();
        };

        document.getElementById('energyLevel').oninput = (e) => {
            energyLevel = parseInt(e.target.value);
            document.getElementById('nValue').textContent = energyLevel;
        };

        document.getElementById('sigma').oninput = (e) => {
            sigma = parseInt(e.target.value);
            document.getElementById('sigmaValue').textContent = sigma;
        };

        document.getElementById('k0').oninput = (e) => {
            k0 = parseFloat(e.target.value);
            document.getElementById('k0Value').textContent = k0.toFixed(2);
        };

        document.getElementById('startBtn').onclick = () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start';
        };

        document.getElementById('resetBtn').onclick = initWaveFunction;

        canvas.onclick = (e) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left - 50;
            const plotWidth = canvas.width - 350;
            const center = (clickX / plotWidth) * N;

            if (center > 0 && center < N) {
                // Add a new wave packet at click position
                let norm = 0;
                for (let i = 0; i < N; i++) {
                    const x = i - center;
                    const envelope = Math.exp(-x * x / (2 * sigma * sigma));
                    psiReal[i] += envelope * Math.cos(k0 * i) * 0.5;
                    psiImag[i] += envelope * Math.sin(k0 * i) * 0.5;
                    norm += psiReal[i] * psiReal[i] + psiImag[i] * psiImag[i];
                }

                norm = Math.sqrt(norm * dx);
                for (let i = 0; i < N; i++) {
                    psiReal[i] /= norm;
                    psiImag[i] /= norm;
                }
            }
        };

        // Initialize
        initWaveFunction();
        animate();
    </script>
</body>
</html>
