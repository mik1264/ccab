<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Interference - Quantum Physics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%); color: #eee; min-height: 100vh; padding: 20px; }
        .back-link { position: fixed; top: 20px; left: 20px; color: #60a5fa; text-decoration: none; font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px; z-index: 100; }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #60a5fa; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(96, 165, 250, 0.1); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #60a5fa; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #050510; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input, .control-group select { width: 100%; }
        .value-display { color: #60a5fa; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #60a5fa; color: #0a0a1a; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .output-display { display: flex; gap: 10px; margin: 15px 0; }
        .output-box { flex: 1; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 15px; text-align: center; }
        .output-value { font-size: 1.5em; font-weight: bold; }
        .detector-0 { color: #4ade80; }
        .detector-1 { color: #f87171; }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <h1>Quantum Interference</h1>
    <p class="subtitle">Mach-Zehnder interferometer simulation</p>

    <div class="container">
        <div class="panel">
            <canvas id="canvas" width="800" height="500"></canvas>
        </div>

        <div class="panel">
            <div class="info-box">
                <strong>Mach-Zehnder Interferometer:</strong>
                A photon enters and is split by a beam splitter (BS1).
                It travels both paths simultaneously (superposition).
                The phase shifter changes relative phase.
                At BS2, paths interfere - constructive or destructive!
            </div>

            <h3>Phase Shift</h3>
            <div class="control-group">
                <label>Phase (œÜ): <span class="value-display" id="phaseVal">0¬∞</span></label>
                <input type="range" id="phaseSlider" min="0" max="360" value="0" oninput="updatePhase()">
            </div>

            <h3>Which-Path Detection</h3>
            <div class="control-group">
                <select id="pathDetect" onchange="updateSetup()">
                    <option value="none">No detection (interference)</option>
                    <option value="detect">Detect path (no interference)</option>
                </select>
            </div>

            <button class="btn-primary" onclick="sendPhoton()">Send Photon</button>
            <button class="btn-secondary" onclick="sendMany()">Send 100 Photons</button>
            <button class="btn-secondary" onclick="resetStats()">Reset Statistics</button>

            <h3 style="margin-top: 15px;">Output Probabilities</h3>
            <div class="output-display">
                <div class="output-box">
                    <div class="output-value detector-0" id="prob0">100%</div>
                    <div>Detector D0</div>
                </div>
                <div class="output-box">
                    <div class="output-value detector-1" id="prob1">0%</div>
                    <div>Detector D1</div>
                </div>
            </div>

            <h3>Measurement Results</h3>
            <div class="output-display">
                <div class="output-box">
                    <div class="output-value detector-0" id="count0">0</div>
                    <div>D0 Counts</div>
                </div>
                <div class="output-box">
                    <div class="output-value detector-1" id="count1">0</div>
                    <div>D1 Counts</div>
                </div>
            </div>

            <div style="text-align: center; margin-top: 10px; font-size: 0.85em; opacity: 0.8;">
                Total: <span id="totalCount">0</span>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let phase = 0;
        let pathDetect = false;
        let photons = [];
        let count0 = 0;
        let count1 = 0;
        let time = 0;

        // Component positions
        const source = { x: 50, y: 250 };
        const bs1 = { x: 200, y: 250 };
        const mirror1 = { x: 200, y: 100 };
        const mirror2 = { x: 550, y: 250 };
        const phaseShift = { x: 375, y: 100 };
        const bs2 = { x: 550, y: 100 };
        const d0 = { x: 700, y: 100 };
        const d1 = { x: 550, y: -50 };

        function updatePhase() {
            phase = parseInt(document.getElementById('phaseSlider').value);
            document.getElementById('phaseVal').textContent = phase + '¬∞';
            updateProbabilities();
        }

        function updateSetup() {
            pathDetect = document.getElementById('pathDetect').value === 'detect';
            updateProbabilities();
        }

        function updateProbabilities() {
            let prob0, prob1;

            if (pathDetect) {
                // No interference when path is detected
                prob0 = 0.5;
                prob1 = 0.5;
            } else {
                // Interference based on phase
                const phaseRad = phase * Math.PI / 180;
                prob0 = Math.pow(Math.cos(phaseRad / 2), 2);
                prob1 = Math.pow(Math.sin(phaseRad / 2), 2);
            }

            document.getElementById('prob0').textContent = (prob0 * 100).toFixed(0) + '%';
            document.getElementById('prob1').textContent = (prob1 * 100).toFixed(0) + '%';
        }

        function sendPhoton() {
            const phaseRad = phase * Math.PI / 180;
            let destination;

            if (pathDetect) {
                destination = Math.random() < 0.5 ? 0 : 1;
            } else {
                const prob0 = Math.pow(Math.cos(phaseRad / 2), 2);
                destination = Math.random() < prob0 ? 0 : 1;
            }

            photons.push({
                x: source.x,
                y: source.y,
                phase: 0,
                destination: destination,
                path: 'source',
                progress: 0,
                amplitude: { upper: 1 / Math.sqrt(2), lower: 1 / Math.sqrt(2) },
                detectedPath: pathDetect ? (Math.random() < 0.5 ? 'upper' : 'lower') : null
            });
        }

        function sendMany() {
            for (let i = 0; i < 100; i++) {
                setTimeout(() => sendPhoton(), i * 30);
            }
        }

        function resetStats() {
            count0 = 0;
            count1 = 0;
            photons = [];
            document.getElementById('count0').textContent = '0';
            document.getElementById('count1').textContent = '0';
            document.getElementById('totalCount').textContent = '0';
        }

        function updatePhotons() {
            for (let i = photons.length - 1; i >= 0; i--) {
                const p = photons[i];
                p.progress += 0.02;

                if (p.path === 'source' && p.progress >= 1) {
                    p.path = 'split';
                    p.progress = 0;
                } else if (p.path === 'split' && p.progress >= 1) {
                    p.path = 'mirror';
                    p.progress = 0;
                } else if (p.path === 'mirror' && p.progress >= 1) {
                    p.path = 'toBS2';
                    p.progress = 0;
                } else if (p.path === 'toBS2' && p.progress >= 1) {
                    p.path = 'final';
                    p.progress = 0;
                } else if (p.path === 'final' && p.progress >= 1) {
                    // Record detection
                    if (p.destination === 0) count0++;
                    else count1++;
                    document.getElementById('count0').textContent = count0;
                    document.getElementById('count1').textContent = count1;
                    document.getElementById('totalCount').textContent = count0 + count1;
                    photons.splice(i, 1);
                }
            }
        }

        function drawComponent(x, y, type, label) {
            ctx.save();
            ctx.translate(x, y);

            if (type === 'bs') {
                // Beam splitter (diagonal line)
                ctx.strokeStyle = '#60a5fa';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-15, 15);
                ctx.lineTo(15, -15);
                ctx.stroke();

                ctx.fillStyle = 'rgba(96, 165, 250, 0.3)';
                ctx.fillRect(-15, -15, 30, 30);
            } else if (type === 'mirror') {
                ctx.strokeStyle = '#facc15';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(-15, 15);
                ctx.lineTo(15, -15);
                ctx.stroke();
            } else if (type === 'phase') {
                ctx.fillStyle = 'rgba(192, 132, 252, 0.5)';
                ctx.fillRect(-20, -10, 40, 20);
                ctx.strokeStyle = '#c084fc';
                ctx.lineWidth = 2;
                ctx.strokeRect(-20, -10, 40, 20);
                ctx.fillStyle = '#fff';
                ctx.font = '10px sans-serif';
                ctx.fillText('œÜ', -3, 4);
            } else if (type === 'detector') {
                ctx.fillStyle = label === 'D0' ? '#4ade80' : '#f87171';
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.fill();
            } else if (type === 'source') {
                ctx.fillStyle = '#facc15';
                ctx.beginPath();
                ctx.arc(0, 0, 15, 0, Math.PI * 2);
                ctx.fill();
            }

            if (label) {
                ctx.fillStyle = '#fff';
                ctx.font = '12px sans-serif';
                ctx.fillText(label, -10, 35);
            }

            ctx.restore();
        }

        function drawPath(from, to, color, width) {
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();
        }

        function draw() {
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            time += 0.05;

            // Draw beam paths
            const pathColor = 'rgba(96, 165, 250, 0.3)';
            const pathWidth = 8;

            // Source to BS1
            drawPath(source, bs1, pathColor, pathWidth);
            // Upper path: BS1 -> M1 -> phase -> BS2
            drawPath(bs1, mirror1, pathColor, pathWidth);
            drawPath(mirror1, phaseShift, pathColor, pathWidth);
            drawPath(phaseShift, bs2, pathColor, pathWidth);
            // Lower path: BS1 -> M2 -> BS2
            drawPath(bs1, mirror2, pathColor, pathWidth);
            drawPath(mirror2, { x: bs2.x, y: mirror2.y }, pathColor, pathWidth);
            drawPath({ x: bs2.x, y: mirror2.y }, bs2, pathColor, pathWidth);
            // Output paths
            drawPath(bs2, d0, pathColor, pathWidth);
            drawPath(bs2, { x: bs2.x, y: 50 }, pathColor, pathWidth);

            // Draw components
            drawComponent(source.x, source.y, 'source', 'Source');
            drawComponent(bs1.x, bs1.y, 'bs', 'BS1');
            drawComponent(mirror1.x, mirror1.y, 'mirror', 'M1');
            drawComponent(mirror2.x, mirror2.y, 'mirror', 'M2');
            drawComponent(phaseShift.x, phaseShift.y, 'phase', null);
            drawComponent(bs2.x, bs2.y, 'bs', 'BS2');
            drawComponent(d0.x, d0.y, 'detector', 'D0');
            drawComponent(bs2.x, 50, 'detector', 'D1');

            // Path labels
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '11px sans-serif';
            ctx.fillText('Upper path', 280, 90);
            ctx.fillText('Lower path', 350, 270);

            // Draw photons
            for (const p of photons) {
                let positions = [];

                if (p.path === 'source') {
                    const x = source.x + (bs1.x - source.x) * p.progress;
                    positions.push({ x, y: source.y });
                } else if (p.path === 'split') {
                    // Show superposition - both paths
                    if (!p.detectedPath || p.detectedPath === 'upper') {
                        const x = bs1.x;
                        const y = bs1.y - (bs1.y - mirror1.y) * p.progress;
                        positions.push({ x, y, path: 'upper' });
                    }
                    if (!p.detectedPath || p.detectedPath === 'lower') {
                        const x = bs1.x + (mirror2.x - bs1.x) * p.progress;
                        positions.push({ x, y: bs1.y, path: 'lower' });
                    }
                } else if (p.path === 'mirror') {
                    if (!p.detectedPath || p.detectedPath === 'upper') {
                        const x = mirror1.x + (bs2.x - mirror1.x) * p.progress;
                        positions.push({ x, y: mirror1.y, path: 'upper' });
                    }
                    if (!p.detectedPath || p.detectedPath === 'lower') {
                        const y = mirror2.y - (mirror2.y - bs2.y) * p.progress;
                        positions.push({ x: mirror2.x, y, path: 'lower' });
                    }
                } else if (p.path === 'toBS2') {
                    // Both paths converge at BS2
                    positions.push({ x: bs2.x, y: bs2.y });
                } else if (p.path === 'final') {
                    if (p.destination === 0) {
                        const x = bs2.x + (d0.x - bs2.x) * p.progress;
                        positions.push({ x, y: bs2.y });
                    } else {
                        const y = bs2.y - (bs2.y - 50) * p.progress;
                        positions.push({ x: bs2.x, y });
                    }
                }

                // Draw photon(s)
                for (const pos of positions) {
                    // Wave visualization
                    ctx.strokeStyle = pos.path === 'upper' ? 'rgba(74, 222, 128, 0.5)' :
                                     pos.path === 'lower' ? 'rgba(248, 113, 113, 0.5)' :
                                     'rgba(250, 204, 21, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let i = 0; i < 30; i++) {
                        const waveX = pos.x - i * 2;
                        const waveY = pos.y + Math.sin(i * 0.5 + time * 5) * 5;
                        if (i === 0) ctx.moveTo(waveX, waveY);
                        else ctx.lineTo(waveX, waveY);
                    }
                    ctx.stroke();

                    // Photon particle
                    ctx.fillStyle = '#facc15';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Detection indicator for which-path
            if (pathDetect) {
                ctx.fillStyle = '#f87171';
                ctx.font = 'bold 12px sans-serif';
                ctx.fillText('üëÅ PATH DETECTED', 250, 180);
                ctx.fillText('(No interference)', 250, 195);
            }

            // Info
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText('Mach-Zehnder Interferometer', 20, 30);
            ctx.font = '12px sans-serif';
            ctx.fillText(`Phase: ${phase}¬∞`, 20, 50);
        }

        function animate() {
            updatePhotons();
            draw();
            requestAnimationFrame(animate);
        }

        updatePhase();
        animate();
    </script>
</body>
</html>
