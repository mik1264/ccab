<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle in a Box - Quantum Physics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%); color: #eee; min-height: 100vh; padding: 20px; }
        .back-link { position: fixed; top: 20px; left: 20px; color: #60a5fa; text-decoration: none; font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px; z-index: 100; }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #60a5fa; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(96, 165, 250, 0.1); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #60a5fa; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #050510; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input { width: 100%; }
        .value-display { color: #60a5fa; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #60a5fa; color: #0a0a1a; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .energy-levels { max-height: 200px; overflow-y: auto; }
        .energy-level { display: flex; align-items: center; gap: 10px; padding: 8px; border-radius: 4px; margin: 5px 0; cursor: pointer; transition: background 0.2s; }
        .energy-level:hover { background: rgba(96, 165, 250, 0.1); }
        .energy-level.active { background: rgba(96, 165, 250, 0.2); border: 1px solid rgba(96, 165, 250, 0.5); }
        .level-indicator { width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; }
        .equation { font-family: monospace; font-size: 0.95em; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; margin: 10px 0; text-align: center; }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <h1>Particle in a Box</h1>
    <p class="subtitle">Energy quantization and standing waves</p>

    <div class="container">
        <div class="panel">
            <canvas id="canvas" width="800" height="500"></canvas>
        </div>

        <div class="panel">
            <div class="info-box">
                <strong>Particle in an Infinite Well:</strong>
                A particle confined to a box has quantized energy levels.
                Only certain standing wave patterns fit in the box.
                The energy increases as n²: E<sub>n</sub> = n²π²ℏ²/(2mL²)
            </div>

            <div class="equation">
                ψ<sub>n</sub>(x) = √(2/L) sin(nπx/L)
            </div>

            <h3>Quantum Number (n)</h3>
            <div class="control-group">
                <label>Energy Level: <span class="value-display" id="nVal">1</span></label>
                <input type="range" id="nSlider" min="1" max="8" value="1" oninput="updateLevel()">
            </div>

            <div class="control-group">
                <label>Box Width (L): <span class="value-display" id="widthVal">1.0</span></label>
                <input type="range" id="widthSlider" min="50" max="150" value="100" oninput="updateWidth()">
            </div>

            <h3 style="margin-top: 15px;">Energy Levels</h3>
            <div class="energy-levels" id="energyLevels"></div>

            <button class="btn-primary" onclick="toggleAnimation()">Animate Time Evolution</button>
            <button class="btn-secondary" onclick="showSuperposition()">Create Superposition</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let n = 1;
        let boxWidth = 1.0;
        let time = 0;
        let animating = false;
        let superposition = false;
        let superpositionStates = [1, 2];

        const boxLeft = 100;
        const boxRight = 700;
        const boxY = 300;

        function updateLevel() {
            n = parseInt(document.getElementById('nSlider').value);
            document.getElementById('nVal').textContent = n;
            superposition = false;
            updateEnergyDisplay();
            draw();
        }

        function updateWidth() {
            boxWidth = parseInt(document.getElementById('widthSlider').value) / 100;
            document.getElementById('widthVal').textContent = boxWidth.toFixed(1);
            updateEnergyDisplay();
            draw();
        }

        function updateEnergyDisplay() {
            const container = document.getElementById('energyLevels');
            container.innerHTML = '';

            const colors = ['#60a5fa', '#4ade80', '#facc15', '#f87171', '#c084fc', '#fb923c', '#22d3d8', '#f472b6'];

            for (let i = 8; i >= 1; i--) {
                const energy = i * i / (boxWidth * boxWidth);
                const level = document.createElement('div');
                level.className = `energy-level ${i === n && !superposition ? 'active' : ''}`;
                level.onclick = () => {
                    n = i;
                    document.getElementById('nSlider').value = i;
                    superposition = false;
                    updateEnergyDisplay();
                    draw();
                };

                level.innerHTML = `
                    <div class="level-indicator" style="background: ${colors[i-1]}">n=${i}</div>
                    <div>
                        <div style="font-weight: 600;">E<sub>${i}</sub> = ${energy.toFixed(2)} E₁</div>
                        <div style="font-size: 0.8em; opacity: 0.7;">${i} node${i > 1 ? 's' : ''}</div>
                    </div>
                `;

                container.appendChild(level);
            }
        }

        function waveFunction(x, n, L) {
            // Normalized wave function
            return Math.sqrt(2 / L) * Math.sin(n * Math.PI * x / L);
        }

        function probability(x, n, L) {
            const psi = waveFunction(x, n, L);
            return psi * psi;
        }

        function toggleAnimation() {
            animating = !animating;
        }

        function showSuperposition() {
            superposition = !superposition;
            if (superposition) {
                superpositionStates = [n, n + 1 <= 8 ? n + 1 : 1];
            }
            draw();
        }

        function draw() {
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (animating) {
                time += 0.05;
            }

            const pixelWidth = boxRight - boxLeft;
            const L = boxWidth;

            // Draw infinite potential walls
            ctx.fillStyle = '#333';
            ctx.fillRect(0, 50, boxLeft - 10, canvas.height - 100);
            ctx.fillRect(boxRight + 10, 50, canvas.width - boxRight - 10, canvas.height - 100);

            // Wall labels
            ctx.fillStyle = '#fff';
            ctx.font = '12px sans-serif';
            ctx.fillText('V = ∞', 40, 80);
            ctx.fillText('V = ∞', boxRight + 30, 80);
            ctx.fillText('V = 0', boxLeft + pixelWidth / 2 - 15, 80);

            // Draw box floor
            ctx.strokeStyle = '#60a5fa';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(boxLeft, boxY);
            ctx.lineTo(boxRight, boxY);
            ctx.stroke();

            // x-axis labels
            ctx.fillStyle = '#fff';
            ctx.font = '11px sans-serif';
            ctx.fillText('0', boxLeft - 5, boxY + 20);
            ctx.fillText('L', boxRight - 5, boxY + 20);

            const colors = ['#60a5fa', '#4ade80', '#facc15', '#f87171', '#c084fc', '#fb923c', '#22d3d8', '#f472b6'];

            if (superposition) {
                // Draw superposition of two states
                const n1 = superpositionStates[0];
                const n2 = superpositionStates[1];
                const omega1 = n1 * n1;
                const omega2 = n2 * n2;

                // Probability density for superposition
                ctx.fillStyle = 'rgba(192, 132, 252, 0.3)';
                ctx.beginPath();
                ctx.moveTo(boxLeft, boxY);

                for (let px = 0; px <= pixelWidth; px++) {
                    const x = (px / pixelWidth) * L;
                    const psi1 = waveFunction(x, n1, L) * Math.cos(omega1 * time);
                    const psi2 = waveFunction(x, n2, L) * Math.cos(omega2 * time);
                    const psiTotal = (psi1 + psi2) / Math.sqrt(2);
                    const prob = psiTotal * psiTotal;
                    const y = boxY - prob * 150 * L;
                    ctx.lineTo(boxLeft + px, y);
                }

                ctx.lineTo(boxRight, boxY);
                ctx.closePath();
                ctx.fill();

                // Wave function
                ctx.strokeStyle = '#c084fc';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let px = 0; px <= pixelWidth; px++) {
                    const x = (px / pixelWidth) * L;
                    const psi1 = waveFunction(x, n1, L) * Math.cos(omega1 * time);
                    const psi2 = waveFunction(x, n2, L) * Math.cos(omega2 * time);
                    const psiTotal = (psi1 + psi2) / Math.sqrt(2);
                    const y = boxY - 100 - psiTotal * 80;
                    if (px === 0) ctx.moveTo(boxLeft + px, y);
                    else ctx.lineTo(boxLeft + px, y);
                }
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px sans-serif';
                ctx.fillText(`Superposition: |ψ⟩ = (|${n1}⟩ + |${n2}⟩)/√2`, 20, 30);

            } else {
                // Draw energy level line
                const energyY = boxY - 30 - n * 25;
                ctx.strokeStyle = colors[n - 1];
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(boxLeft, energyY);
                ctx.lineTo(boxRight, energyY);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = colors[n - 1];
                ctx.font = '12px sans-serif';
                ctx.fillText(`E${n} = ${n * n}E₁`, boxRight + 15, energyY + 4);

                // Draw probability density |ψ|²
                ctx.fillStyle = `${colors[n - 1]}40`;
                ctx.beginPath();
                ctx.moveTo(boxLeft, boxY);

                for (let px = 0; px <= pixelWidth; px++) {
                    const x = (px / pixelWidth) * L;
                    const prob = probability(x, n, L);
                    const y = boxY - prob * 150 * L;
                    ctx.lineTo(boxLeft + px, y);
                }

                ctx.lineTo(boxRight, boxY);
                ctx.closePath();
                ctx.fill();

                // Draw |ψ|² outline
                ctx.strokeStyle = colors[n - 1];
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let px = 0; px <= pixelWidth; px++) {
                    const x = (px / pixelWidth) * L;
                    const prob = probability(x, n, L);
                    const y = boxY - prob * 150 * L;
                    if (px === 0) ctx.moveTo(boxLeft + px, y);
                    else ctx.lineTo(boxLeft + px, y);
                }
                ctx.stroke();

                // Draw wave function ψ (with time evolution if animating)
                ctx.strokeStyle = `${colors[n - 1]}99`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();

                const omega = n * n;
                for (let px = 0; px <= pixelWidth; px++) {
                    const x = (px / pixelWidth) * L;
                    let psi = waveFunction(x, n, L);
                    if (animating) {
                        psi *= Math.cos(omega * time);
                    }
                    const y = boxY - 100 - psi * 60;
                    if (px === 0) ctx.moveTo(boxLeft + px, y);
                    else ctx.lineTo(boxLeft + px, y);
                }
                ctx.stroke();

                // Labels
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px sans-serif';
                ctx.fillText(`Quantum State n = ${n}`, 20, 30);

                // Mark nodes
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.font = '10px sans-serif';
                for (let i = 1; i < n; i++) {
                    const nodeX = boxLeft + (i / n) * pixelWidth;
                    ctx.beginPath();
                    ctx.arc(nodeX, boxY, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                if (n > 1) {
                    ctx.fillText(`${n - 1} interior node${n > 2 ? 's' : ''}`, boxLeft + 10, boxY + 40);
                }
            }

            // Legend
            ctx.fillStyle = '#fff';
            ctx.font = '11px sans-serif';
            ctx.fillText('|ψ|² (probability density)', boxLeft, canvas.height - 40);
            ctx.fillText('ψ (wave function)', boxLeft, canvas.height - 25);
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        updateEnergyDisplay();
        animate();
    </script>
</body>
</html>
