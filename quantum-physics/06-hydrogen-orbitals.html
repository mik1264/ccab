<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hydrogen Atom Orbitals - Quantum Physics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%); color: #eee; min-height: 100vh; padding: 20px; }
        .back-link { position: fixed; top: 20px; left: 20px; color: #60a5fa; text-decoration: none; font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px; z-index: 100; }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #60a5fa; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(96, 165, 250, 0.1); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #60a5fa; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #050510; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input, .control-group select { width: 100%; padding: 8px; border-radius: 4px; }
        .value-display { color: #60a5fa; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #60a5fa; color: #0a0a1a; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .orbital-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin: 15px 0; }
        .orbital-btn { padding: 10px 5px; background: rgba(0,0,0,0.2); border: 2px solid transparent; border-radius: 8px; color: #fff; cursor: pointer; text-align: center; font-size: 0.85em; }
        .orbital-btn.active { border-color: #60a5fa; background: rgba(96, 165, 250, 0.2); }
        .orbital-btn:hover { border-color: rgba(96, 165, 250, 0.5); }
        .quantum-numbers { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 15px; margin: 15px 0; font-family: monospace; }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <h1>Hydrogen Atom Orbitals</h1>
    <p class="subtitle">Electron probability density visualization</p>

    <div class="container">
        <div class="panel">
            <canvas id="canvas" width="600" height="600"></canvas>
        </div>

        <div class="panel">
            <div class="info-box">
                <strong>Atomic Orbitals:</strong>
                The electron in a hydrogen atom is described by quantum numbers n, l, m.
                The visualization shows |ψ|² - the probability density of finding the electron.
                <br><br>
                <b>n:</b> Principal (energy level)<br>
                <b>l:</b> Angular momentum (orbital shape)<br>
                <b>m:</b> Magnetic (orbital orientation)
            </div>

            <h3>Quick Select</h3>
            <div class="orbital-grid">
                <button class="orbital-btn active" onclick="setOrbital(1,0,0)">1s</button>
                <button class="orbital-btn" onclick="setOrbital(2,0,0)">2s</button>
                <button class="orbital-btn" onclick="setOrbital(2,1,0)">2p<sub>z</sub></button>
                <button class="orbital-btn" onclick="setOrbital(2,1,1)">2p<sub>x</sub></button>
                <button class="orbital-btn" onclick="setOrbital(3,0,0)">3s</button>
                <button class="orbital-btn" onclick="setOrbital(3,1,0)">3p<sub>z</sub></button>
                <button class="orbital-btn" onclick="setOrbital(3,2,0)">3d<sub>z²</sub></button>
                <button class="orbital-btn" onclick="setOrbital(3,2,1)">3d<sub>xz</sub></button>
                <button class="orbital-btn" onclick="setOrbital(3,2,2)">3d<sub>xy</sub></button>
            </div>

            <h3>Quantum Numbers</h3>
            <div class="control-group">
                <label>n (Principal): <span class="value-display" id="nVal">1</span></label>
                <input type="range" id="nSlider" min="1" max="4" value="1" oninput="updateQuantum()">
            </div>

            <div class="control-group">
                <label>l (Angular): <span class="value-display" id="lVal">0</span></label>
                <input type="range" id="lSlider" min="0" max="0" value="0" oninput="updateQuantum()">
            </div>

            <div class="control-group">
                <label>m (Magnetic): <span class="value-display" id="mVal">0</span></label>
                <input type="range" id="mSlider" min="0" max="0" value="0" oninput="updateQuantum()">
            </div>

            <div class="quantum-numbers">
                <div>Orbital: <span id="orbitalName">1s</span></div>
                <div>ψ<sub>nlm</sub> = R<sub><span id="nlDisplay">10</span></sub>(r) × Y<sub><span id="lmDisplay">0,0</span></sub>(θ,φ)</div>
            </div>

            <div class="control-group">
                <label>View Rotation: <span class="value-display" id="rotVal">0°</span></label>
                <input type="range" id="rotSlider" min="0" max="360" value="0" oninput="updateView()">
            </div>

            <button class="btn-secondary" onclick="toggleAnimation()">Toggle Rotation</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let n = 1, l = 0, m = 0;
        let viewAngle = 0;
        let animating = false;
        let imageData;

        // Factorial function
        function factorial(n) {
            if (n <= 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) result *= i;
            return result;
        }

        // Associated Legendre polynomial (simplified for visualization)
        function legendreP(l, m, x) {
            m = Math.abs(m);
            if (l === 0) return 1;
            if (l === 1) {
                if (m === 0) return x;
                if (m === 1) return -Math.sqrt(1 - x * x);
            }
            if (l === 2) {
                if (m === 0) return 0.5 * (3 * x * x - 1);
                if (m === 1) return -3 * x * Math.sqrt(1 - x * x);
                if (m === 2) return 3 * (1 - x * x);
            }
            if (l === 3) {
                if (m === 0) return 0.5 * x * (5 * x * x - 3);
                if (m === 1) return -1.5 * (5 * x * x - 1) * Math.sqrt(1 - x * x);
                if (m === 2) return 15 * x * (1 - x * x);
                if (m === 3) return -15 * Math.pow(1 - x * x, 1.5);
            }
            return 1;
        }

        // Spherical harmonic (real form for visualization)
        function sphericalHarmonic(l, m, theta, phi) {
            const cosTheta = Math.cos(theta);
            const P = legendreP(l, Math.abs(m), cosTheta);

            if (m > 0) {
                return P * Math.cos(m * phi);
            } else if (m < 0) {
                return P * Math.sin(Math.abs(m) * phi);
            }
            return P;
        }

        // Radial wave function (simplified)
        function radialWave(n, l, r) {
            const a0 = 1; // Bohr radius normalized
            const rho = 2 * r / (n * a0);

            // Exponential decay
            const exp = Math.exp(-rho / 2);

            // Laguerre-like polynomial (simplified)
            let poly = 1;
            if (n === 2 && l === 0) poly = 1 - rho / 2;
            if (n === 2 && l === 1) poly = rho / 3;
            if (n === 3 && l === 0) poly = 1 - 2 * rho / 3 + 2 * rho * rho / 27;
            if (n === 3 && l === 1) poly = (1 - rho / 6) * rho / 6;
            if (n === 3 && l === 2) poly = rho * rho / 30;
            if (n === 4 && l === 0) poly = 1 - 3 * rho / 4 + rho * rho / 8 - rho * rho * rho / 192;

            return Math.pow(rho, l) * exp * poly;
        }

        // Full wave function probability
        function waveFunctionProb(n, l, m, r, theta, phi) {
            const R = radialWave(n, l, r);
            const Y = sphericalHarmonic(l, m, theta, phi);
            return R * R * Y * Y;
        }

        function setOrbital(newN, newL, newM) {
            n = newN;
            l = newL;
            m = newM;

            document.getElementById('nSlider').value = n;
            document.getElementById('lSlider').max = n - 1;
            document.getElementById('lSlider').value = l;
            document.getElementById('mSlider').min = -l;
            document.getElementById('mSlider').max = l;
            document.getElementById('mSlider').value = m;

            updateDisplay();
            renderOrbital();

            // Update active button
            document.querySelectorAll('.orbital-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        function updateQuantum() {
            n = parseInt(document.getElementById('nSlider').value);

            // Update l range
            document.getElementById('lSlider').max = n - 1;
            l = Math.min(l, n - 1);
            document.getElementById('lSlider').value = l;

            // Update m range
            document.getElementById('mSlider').min = -l;
            document.getElementById('mSlider').max = l;
            m = Math.max(-l, Math.min(l, m));
            document.getElementById('mSlider').value = m;

            l = parseInt(document.getElementById('lSlider').value);
            m = parseInt(document.getElementById('mSlider').value);

            updateDisplay();
            renderOrbital();
        }

        function updateDisplay() {
            document.getElementById('nVal').textContent = n;
            document.getElementById('lVal').textContent = l;
            document.getElementById('mVal').textContent = m;

            const orbitalLetters = ['s', 'p', 'd', 'f'];
            const subscripts = {
                '1,0,0': '', '2,0,0': '', '3,0,0': '', '4,0,0': '',
                '2,1,0': 'z', '2,1,1': 'x', '2,1,-1': 'y',
                '3,1,0': 'z', '3,1,1': 'x', '3,1,-1': 'y',
                '3,2,0': 'z²', '3,2,1': 'xz', '3,2,-1': 'yz', '3,2,2': 'xy', '3,2,-2': 'x²-y²'
            };

            const key = `${n},${l},${m}`;
            const sub = subscripts[key] || '';
            document.getElementById('orbitalName').textContent = n + orbitalLetters[l] + (sub ? '_' + sub : '');
            document.getElementById('nlDisplay').textContent = n + '' + l;
            document.getElementById('lmDisplay').textContent = l + ',' + m;
        }

        function updateView() {
            viewAngle = parseInt(document.getElementById('rotSlider').value) * Math.PI / 180;
            document.getElementById('rotVal').textContent = document.getElementById('rotSlider').value + '°';
            renderOrbital();
        }

        function toggleAnimation() {
            animating = !animating;
        }

        function renderOrbital() {
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const scale = 15 / n; // Scale based on principal quantum number

            imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            let maxProb = 0;

            // First pass: find maximum probability
            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const x = (px - centerX) / (scale * 10);
                    const y = (centerY - py) / (scale * 10);

                    // Apply view rotation (around y-axis)
                    const xRot = x * Math.cos(viewAngle);
                    const zRot = x * Math.sin(viewAngle);

                    // Sample through z for 3D effect (simple ray marching)
                    let totalProb = 0;
                    for (let z = -5; z <= 5; z += 0.5) {
                        const zWorld = z / scale + zRot;
                        const r = Math.sqrt(xRot * xRot + y * y + zWorld * zWorld);
                        if (r < 0.01) continue;

                        const theta = Math.acos(y / r);
                        const phi = Math.atan2(zWorld, xRot);

                        const prob = waveFunctionProb(n, l, m, r, theta, phi);
                        totalProb += prob * 0.1;
                    }

                    if (totalProb > maxProb) maxProb = totalProb;
                }
            }

            // Second pass: render with normalization
            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const x = (px - centerX) / (scale * 10);
                    const y = (centerY - py) / (scale * 10);

                    const xRot = x * Math.cos(viewAngle);
                    const zRot = x * Math.sin(viewAngle);

                    let totalProb = 0;
                    for (let z = -5; z <= 5; z += 0.5) {
                        const zWorld = z / scale + zRot;
                        const r = Math.sqrt(xRot * xRot + y * y + zWorld * zWorld);
                        if (r < 0.01) continue;

                        const theta = Math.acos(y / r);
                        const phi = Math.atan2(zWorld, xRot);

                        const prob = waveFunctionProb(n, l, m, r, theta, phi);
                        totalProb += prob * 0.1;
                    }

                    const intensity = Math.pow(totalProb / maxProb, 0.5);
                    const idx = (py * width + px) * 4;

                    // Color based on orbital type
                    if (l === 0) {
                        // s orbital - blue
                        data[idx] = Math.floor(intensity * 96);
                        data[idx + 1] = Math.floor(intensity * 165);
                        data[idx + 2] = Math.floor(intensity * 250);
                    } else if (l === 1) {
                        // p orbital - green
                        data[idx] = Math.floor(intensity * 74);
                        data[idx + 1] = Math.floor(intensity * 222);
                        data[idx + 2] = Math.floor(intensity * 128);
                    } else {
                        // d orbital - purple
                        data[idx] = Math.floor(intensity * 192);
                        data[idx + 1] = Math.floor(intensity * 132);
                        data[idx + 2] = Math.floor(intensity * 252);
                    }
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw nucleus
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
            ctx.fill();

            // Labels
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            const orbitalLetters = ['s', 'p', 'd', 'f'];
            ctx.fillText(`${n}${orbitalLetters[l]} orbital (n=${n}, l=${l}, m=${m})`, 20, 30);
        }

        function animate() {
            if (animating) {
                viewAngle += 0.02;
                document.getElementById('rotSlider').value = (viewAngle * 180 / Math.PI) % 360;
                document.getElementById('rotVal').textContent = Math.round((viewAngle * 180 / Math.PI) % 360) + '°';
                renderOrbital();
            }
            requestAnimationFrame(animate);
        }

        updateDisplay();
        renderOrbital();
        animate();
    </script>
</body>
</html>
