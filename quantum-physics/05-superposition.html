<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Superposition - Quantum Physics</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%); color: #eee; min-height: 100vh; padding: 20px; }
        .back-link { position: fixed; top: 20px; left: 20px; color: #60a5fa; text-decoration: none; font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px; z-index: 100; }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #60a5fa; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(96, 165, 250, 0.1); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #60a5fa; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #050510; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input { width: 100%; }
        .value-display { color: #60a5fa; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #60a5fa; color: #0a0a1a; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .state-equation { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 15px; text-align: center; font-size: 1.2em; margin: 15px 0; font-family: monospace; }
        .probability-bars { margin: 15px 0; }
        .prob-item { margin: 10px 0; }
        .prob-label { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .prob-bar { height: 20px; background: rgba(0,0,0,0.3); border-radius: 10px; overflow: hidden; }
        .prob-fill { height: 100%; transition: width 0.3s; }
        .prob-fill-up { background: linear-gradient(90deg, #4ade80, #22c55e); }
        .prob-fill-down { background: linear-gradient(90deg, #f87171, #ef4444); }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <h1>Quantum Superposition</h1>
    <p class="subtitle">Bloch sphere and qubit states</p>

    <div class="container">
        <div class="panel">
            <canvas id="canvas" width="800" height="500"></canvas>
        </div>

        <div class="panel">
            <div class="info-box">
                <strong>Superposition:</strong>
                A qubit can exist in a superposition |ψ⟩ = α|0⟩ + β|1⟩ where |α|² + |β|² = 1.
                The Bloch sphere represents all possible qubit states.
                The poles are |0⟩ (spin up) and |1⟩ (spin down).
            </div>

            <div class="state-equation" id="stateEq">
                |ψ⟩ = 0.71|0⟩ + 0.71|1⟩
            </div>

            <h3>State Parameters</h3>
            <div class="control-group">
                <label>θ (Polar angle): <span class="value-display" id="thetaVal">90°</span></label>
                <input type="range" id="thetaSlider" min="0" max="180" value="90" oninput="updateState()">
            </div>

            <div class="control-group">
                <label>φ (Azimuthal angle): <span class="value-display" id="phiVal">0°</span></label>
                <input type="range" id="phiSlider" min="0" max="360" value="0" oninput="updateState()">
            </div>

            <h3>Measurement Probabilities</h3>
            <div class="probability-bars">
                <div class="prob-item">
                    <div class="prob-label">
                        <span>|0⟩ (Spin Up)</span>
                        <span class="value-display" id="prob0">50%</span>
                    </div>
                    <div class="prob-bar">
                        <div class="prob-fill prob-fill-up" id="bar0" style="width: 50%;"></div>
                    </div>
                </div>
                <div class="prob-item">
                    <div class="prob-label">
                        <span>|1⟩ (Spin Down)</span>
                        <span class="value-display" id="prob1">50%</span>
                    </div>
                    <div class="prob-bar">
                        <div class="prob-fill prob-fill-down" id="bar1" style="width: 50%;"></div>
                    </div>
                </div>
            </div>

            <button class="btn-primary" onclick="measure()">Measure</button>
            <button class="btn-secondary" onclick="setSpecialState('plus')">|+⟩ State</button>
            <button class="btn-secondary" onclick="setSpecialState('minus')">|-⟩ State</button>
            <button class="btn-secondary" onclick="setSpecialState('i')">|i⟩ State</button>
            <button class="btn-secondary" onclick="animate3D()">Animate Rotation</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let theta = Math.PI / 2; // Polar angle
        let phi = 0; // Azimuthal angle
        let viewAngle = 0.4; // 3D view rotation
        let measured = false;
        let measuredState = null;
        let animating = false;
        let time = 0;

        function updateState() {
            theta = parseInt(document.getElementById('thetaSlider').value) * Math.PI / 180;
            phi = parseInt(document.getElementById('phiSlider').value) * Math.PI / 180;

            document.getElementById('thetaVal').textContent = document.getElementById('thetaSlider').value + '°';
            document.getElementById('phiVal').textContent = document.getElementById('phiSlider').value + '°';

            measured = false;
            measuredState = null;
            updateDisplay();
        }

        function updateDisplay() {
            // Calculate amplitudes
            const alpha = Math.cos(theta / 2);
            const betaReal = Math.sin(theta / 2) * Math.cos(phi);
            const betaImag = Math.sin(theta / 2) * Math.sin(phi);
            const betaMag = Math.sqrt(betaReal * betaReal + betaImag * betaImag);

            // Update state equation
            let eq = '|ψ⟩ = ';
            eq += alpha.toFixed(2) + '|0⟩';
            if (betaImag === 0) {
                eq += (betaReal >= 0 ? ' + ' : ' - ') + Math.abs(betaReal).toFixed(2) + '|1⟩';
            } else {
                eq += ' + (' + betaReal.toFixed(2) + ' + ' + betaImag.toFixed(2) + 'i)|1⟩';
            }
            document.getElementById('stateEq').textContent = eq;

            // Update probabilities
            const prob0 = alpha * alpha;
            const prob1 = betaMag * betaMag;
            document.getElementById('prob0').textContent = (prob0 * 100).toFixed(1) + '%';
            document.getElementById('prob1').textContent = (prob1 * 100).toFixed(1) + '%';
            document.getElementById('bar0').style.width = (prob0 * 100) + '%';
            document.getElementById('bar1').style.width = (prob1 * 100) + '%';
        }

        function setSpecialState(state) {
            if (state === 'plus') {
                document.getElementById('thetaSlider').value = 90;
                document.getElementById('phiSlider').value = 0;
            } else if (state === 'minus') {
                document.getElementById('thetaSlider').value = 90;
                document.getElementById('phiSlider').value = 180;
            } else if (state === 'i') {
                document.getElementById('thetaSlider').value = 90;
                document.getElementById('phiSlider').value = 90;
            }
            updateState();
        }

        function measure() {
            const prob0 = Math.cos(theta / 2) ** 2;
            measuredState = Math.random() < prob0 ? 0 : 1;
            measured = true;

            // Collapse to measured state
            if (measuredState === 0) {
                document.getElementById('thetaSlider').value = 0;
            } else {
                document.getElementById('thetaSlider').value = 180;
            }
            theta = measuredState === 0 ? 0 : Math.PI;
            updateDisplay();
        }

        function animate3D() {
            animating = !animating;
        }

        function project3D(x, y, z) {
            // Simple 3D to 2D projection
            const cos = Math.cos(viewAngle);
            const sin = Math.sin(viewAngle);

            const rotX = x * cos - z * sin;
            const rotZ = x * sin + z * cos;

            const scale = 150;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            return {
                x: centerX + rotX * scale,
                y: centerY - y * scale,
                z: rotZ
            };
        }

        function draw() {
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            time += 0.02;
            if (animating) {
                viewAngle += 0.01;
            }

            const radius = 1;

            // Draw sphere wireframe
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;

            // Latitude circles
            for (let lat = -60; lat <= 60; lat += 30) {
                ctx.beginPath();
                const r = Math.cos(lat * Math.PI / 180);
                const y = Math.sin(lat * Math.PI / 180);
                for (let lon = 0; lon <= 360; lon += 5) {
                    const lonRad = lon * Math.PI / 180;
                    const point = project3D(r * Math.cos(lonRad), y, r * Math.sin(lonRad));
                    if (lon === 0) ctx.moveTo(point.x, point.y);
                    else ctx.lineTo(point.x, point.y);
                }
                ctx.stroke();
            }

            // Longitude circles
            for (let lon = 0; lon < 180; lon += 30) {
                ctx.beginPath();
                const lonRad = lon * Math.PI / 180;
                for (let lat = -90; lat <= 90; lat += 5) {
                    const latRad = lat * Math.PI / 180;
                    const point = project3D(
                        Math.cos(latRad) * Math.cos(lonRad),
                        Math.sin(latRad),
                        Math.cos(latRad) * Math.sin(lonRad)
                    );
                    if (lat === -90) ctx.moveTo(point.x, point.y);
                    else ctx.lineTo(point.x, point.y);
                }
                ctx.stroke();
            }

            // Draw axes
            ctx.lineWidth = 2;

            // Z axis (|0⟩ to |1⟩)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            const zTop = project3D(0, 1.2, 0);
            const zBot = project3D(0, -1.2, 0);
            ctx.moveTo(zTop.x, zTop.y);
            ctx.lineTo(zBot.x, zBot.y);
            ctx.stroke();

            // X axis
            ctx.strokeStyle = 'rgba(96, 165, 250, 0.5)';
            const xPos = project3D(1.2, 0, 0);
            const xNeg = project3D(-1.2, 0, 0);
            ctx.beginPath();
            ctx.moveTo(xPos.x, xPos.y);
            ctx.lineTo(xNeg.x, xNeg.y);
            ctx.stroke();

            // Y axis
            ctx.strokeStyle = 'rgba(250, 204, 21, 0.5)';
            const yPos = project3D(0, 0, 1.2);
            const yNeg = project3D(0, 0, -1.2);
            ctx.beginPath();
            ctx.moveTo(yPos.x, yPos.y);
            ctx.lineTo(yNeg.x, yNeg.y);
            ctx.stroke();

            // Labels for axes
            ctx.font = 'bold 14px sans-serif';
            ctx.fillStyle = '#4ade80';
            ctx.fillText('|0⟩', zTop.x + 10, zTop.y);
            ctx.fillStyle = '#f87171';
            ctx.fillText('|1⟩', zBot.x + 10, zBot.y);
            ctx.fillStyle = '#60a5fa';
            ctx.fillText('|+⟩', xPos.x + 10, xPos.y);
            ctx.fillText('|-⟩', xNeg.x - 25, xNeg.y);
            ctx.fillStyle = '#facc15';
            ctx.fillText('|i⟩', yPos.x + 10, yPos.y);
            ctx.fillText('|-i⟩', yNeg.x - 30, yNeg.y);

            // Calculate state vector position on Bloch sphere
            const stateX = Math.sin(theta) * Math.cos(phi);
            const stateY = Math.sin(theta) * Math.sin(phi);
            const stateZ = Math.cos(theta);

            // Draw state vector
            const origin = project3D(0, 0, 0);
            const statePoint = project3D(stateX, stateZ, stateY);

            // Vector line
            ctx.strokeStyle = measured ? (measuredState === 0 ? '#4ade80' : '#f87171') : '#c084fc';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.lineTo(statePoint.x, statePoint.y);
            ctx.stroke();

            // State point
            ctx.fillStyle = measured ? (measuredState === 0 ? '#4ade80' : '#f87171') : '#c084fc';
            ctx.beginPath();
            ctx.arc(statePoint.x, statePoint.y, 10, 0, Math.PI * 2);
            ctx.fill();

            // Draw projection onto XY plane
            if (!measured) {
                ctx.strokeStyle = 'rgba(192, 132, 252, 0.3)';
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                const projPoint = project3D(stateX, 0, stateY);
                ctx.moveTo(statePoint.x, statePoint.y);
                ctx.lineTo(projPoint.x, projPoint.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw pulsing effect for superposition
            if (!measured) {
                const pulse = Math.sin(time * 3) * 0.5 + 0.5;
                ctx.strokeStyle = `rgba(192, 132, 252, ${pulse * 0.3})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(statePoint.x, statePoint.y, 15 + pulse * 10, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Info text
            ctx.fillStyle = '#fff';
            ctx.font = '14px sans-serif';
            ctx.fillText('Bloch Sphere Representation', 20, 30);
            if (measured) {
                ctx.fillStyle = measuredState === 0 ? '#4ade80' : '#f87171';
                ctx.fillText(`Measured: |${measuredState}⟩`, 20, 50);
            } else {
                ctx.fillStyle = '#c084fc';
                ctx.fillText('Superposition State', 20, 50);
            }
        }

        function animateLoop() {
            draw();
            requestAnimationFrame(animateLoop);
        }

        updateState();
        animateLoop();
    </script>
</body>
</html>
