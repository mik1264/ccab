<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Complete History of Computational Visualizations and Simulations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.8;
            color: #333;
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            overflow-x: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 4rem 2rem;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header .subtitle {
            font-size: 1.2rem;
            opacity: 0.95;
            max-width: 900px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .nav-timeline {
            position: sticky;
            top: 0;
            background: rgba(30, 30, 46, 0.95);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            overflow-x: auto;
        }

        .nav-timeline ul {
            display: flex;
            list-style: none;
            gap: 2rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .nav-timeline a {
            color: #667eea;
            text-decoration: none;
            font-size: 0.9rem;
            white-space: nowrap;
            transition: color 0.3s;
        }

        .nav-timeline a:hover {
            color: #764ba2;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .section {
            background: white;
            border-radius: 15px;
            padding: 3rem;
            margin: 2rem 0;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .section h2 {
            color: #667eea;
            font-size: 2rem;
            margin-bottom: 1.5rem;
            border-left: 4px solid #764ba2;
            padding-left: 1rem;
        }

        .section h3 {
            color: #764ba2;
            font-size: 1.5rem;
            margin: 2rem 0 1rem 0;
        }

        .section p {
            margin-bottom: 1.5rem;
            text-align: justify;
        }

        .highlight {
            background: linear-gradient(120deg, #667eea22 0%, #764ba222 100%);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-weight: 600;
        }

        .visualization {
            margin: 2rem 0;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 1.5rem;
            border: 2px solid #e9ecef;
        }

        .visualization h4 {
            color: #495057;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .viz-canvas {
            width: 100%;
            max-width: 800px;
            height: 400px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: block;
            margin: 0 auto;
        }

        .viz-controls {
            margin-top: 1rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .viz-controls button {
            background: #667eea;
            color: white;
            border: none;
            padding: 0.7rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .viz-controls button:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .viz-controls button:active {
            transform: translateY(0);
        }

        .timeline-marker {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-right: 0.5rem;
        }

        .quote {
            border-left: 4px solid #764ba2;
            padding-left: 1.5rem;
            margin: 2rem 0;
            font-style: italic;
            color: #555;
        }

        .grid-2col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 2rem 0;
        }

        @media (max-width: 768px) {
            .grid-2col {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 1.8rem;
            }

            .section {
                padding: 2rem 1.5rem;
            }

            .nav-timeline ul {
                justify-content: flex-start;
            }
        }

        .footer {
            background: #1e1e2e;
            color: white;
            text-align: center;
            padding: 2rem;
            margin-top: 4rem;
        }

        .footer a {
            color: #667eea;
            text-decoration: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>The Complete History of Computational Visualizations and Simulations</h1>
        <p class="subtitle">
            From Alan Turing's 1952 morphogenesis paper to modern browser-based WebGL simulations—
            the evolution of computational science and the algorithms that democratized mathematical exploration
        </p>
    </div>

    <nav class="nav-timeline">
        <ul>
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#foundations">Theoretical Biology</a></li>
            <li><a href="#automata">Cellular Automata</a></li>
            <li><a href="#agents">Agent-Based Models</a></li>
            <li><a href="#patterns">Chemical Patterns</a></li>
            <li><a href="#swarms">Swarm Intelligence</a></li>
            <li><a href="#chaos">Chaos Theory</a></li>
            <li><a href="#fractals">Fractals</a></li>
            <li><a href="#networks">Networks</a></li>
            <li><a href="#conclusion">Conclusion</a></li>
        </ul>
    </nav>

    <div class="container">
        <!-- INTRODUCTION -->
        <section id="introduction" class="section">
            <h2>Introduction: The Computational Revolution</h2>
            <p>
                <span class="highlight">The evolution of computational science from simple automata to complex systems modeling
                represents one of the most profound intellectual achievements of the 20th century.</span> Beginning with
                Alan Turing's 1952 morphogenesis paper and John von Neumann's self-replicating automata, computational
                visualizations transformed from theoretical curiosities into essential tools spanning biology, physics,
                sociology, and computer graphics.
            </p>
            <p>
                These simulations became canonical educational examples because they demonstrated emergence—how simple
                local rules generate complex global behavior—while remaining accessible enough for students to implement
                and explore. From Conway's Game of Life running on 1970 minicomputers to today's browser-based WebGL
                simulations, this democratization of computational tools enabled millions to experience firsthand the
                mathematical principles underlying natural phenomena.
            </p>
        </section>

        <!-- THEORETICAL BIOLOGY -->
        <section id="foundations" class="section">
            <h2>From Theoretical Biology to Visual Computing</h2>
            <p>
                <span class="timeline-marker">1940s-1950s</span>
                The field's foundation emerged from two parallel developments in the late 1940s. <span class="highlight">John
                von Neumann and Stanisław Ulam at Los Alamos National Laboratory pioneered cellular automata</span> while
                investigating self-replicating machines, with von Neumann's 1966 posthumous publication "Theory of
                Self-Reproducing Automata" establishing the theoretical framework.
            </p>
            <p>
                Simultaneously, <span class="highlight">Alan Turing's 1952 paper "The Chemical Basis of Morphogenesis"</span>
                in Philosophical Transactions of the Royal Society introduced reaction-diffusion systems, proposing that
                two diffusing chemicals (morphogens) with different diffusion rates could spontaneously generate patterns
                from uniform states.
            </p>
        </section>

        <!-- GAME OF LIFE -->
        <section id="automata" class="section">
            <h2>Conway's Game of Life and Cellular Automata</h2>
            <p>
                <span class="timeline-marker">1970</span>
                The breakthrough to mainstream visibility came with <span class="highlight">John Horton Conway's Game of
                Life in 1970</span>, popularized by Martin Gardner's October 1970 Scientific American column "Mathematical
                Games." Conway designed his cellular automaton at Cambridge University using graph paper and Go boards,
                establishing three elegant rules:
            </p>
            <ul style="margin: 1rem 0 1rem 2rem;">
                <li>Cells with 2-3 neighbors survive</li>
                <li>Cells with exactly 3 neighbors are born</li>
                <li>All others die</li>
            </ul>

            <div class="visualization">
                <h4>Interactive: Conway's Game of Life</h4>
                <canvas id="gameOfLife" class="viz-canvas"></canvas>
                <div class="viz-controls">
                    <button onclick="gameOfLife.toggle()">Play/Pause</button>
                    <button onclick="gameOfLife.step()">Step</button>
                    <button onclick="gameOfLife.random()">Random</button>
                    <button onclick="gameOfLife.clear()">Clear</button>
                    <button onclick="gameOfLife.addGlider()">Add Glider</button>
                </div>
            </div>

            <h3>Stephen Wolfram's Elementary Cellular Automata</h3>
            <p>
                <span class="timeline-marker">1983</span>
                The theoretical underpinnings of cellular automata achieved rigorous formulation through
                <span class="highlight">Stephen Wolfram's systematic investigation beginning in 1981</span>. His June 1983
                paper "Statistical Mechanics of Cellular Automata" introduced the influential four-class classification
                system for elementary cellular automata.
            </p>

            <div class="visualization">
                <h4>Interactive: Wolfram Elementary Cellular Automata</h4>
                <canvas id="wolframCA" class="viz-canvas"></canvas>
                <div class="viz-controls">
                    <label style="color: #495057; margin-right: 1rem;">
                        Rule: <input type="number" id="ruleInput" value="30" min="0" max="255"
                        style="width: 60px; padding: 0.4rem; border-radius: 4px; border: 1px solid #ccc;">
                    </label>
                    <button onclick="wolframCA.setRule(parseInt(document.getElementById('ruleInput').value))">Apply Rule</button>
                    <button onclick="wolframCA.setRule(30)">Rule 30</button>
                    <button onclick="wolframCA.setRule(110)">Rule 110</button>
                    <button onclick="wolframCA.setRule(90)">Rule 90</button>
                    <button onclick="wolframCA.reset()">Reset</button>
                </div>
            </div>
        </section>

        <!-- AGENT-BASED MODELS -->
        <section id="agents" class="section">
            <h2>Agent-Based Modeling Transforms Social Science</h2>

            <h3>Schelling's Segregation Model</h3>
            <p>
                <span class="timeline-marker">1971</span>
                While cellular automata explored mathematical abstraction, agent-based modeling emerged from social science.
                <span class="highlight">Thomas Schelling's segregation model</span>, published in the Journal of Mathematical
                Sociology in 1971, demonstrated how mild individual preferences for same-group neighbors (30-50% tolerance)
                produce extreme macro-level segregation.
            </p>

            <h3>Craig Reynolds' Boids</h3>
            <p>
                <span class="timeline-marker">1987</span>
                <span class="highlight">Craig Reynolds revolutionized computer animation with boids in 1987</span>, presenting
                "Flocks, Herds, and Schools: A Distributed Behavioral Model" at SIGGRAPH. His three steering behaviors—
                separation (avoid crowding), alignment (match neighbors' heading), and cohesion (move toward neighbors'
                center)—produced realistic flocking from local rules alone.
            </p>

            <div class="visualization">
                <h4>Interactive: Boids Flocking Simulation</h4>
                <canvas id="boids" class="viz-canvas"></canvas>
                <div class="viz-controls">
                    <button onclick="boids.toggle()">Play/Pause</button>
                    <button onclick="boids.reset()">Reset</button>
                    <button onclick="boids.addBoid()">Add Boid</button>
                    <button onclick="boids.toggleDebug()">Toggle Vectors</button>
                </div>
            </div>
        </section>

        <!-- REACTION-DIFFUSION -->
        <section id="patterns" class="section">
            <h2>Chemical Reactions Generate Biological Patterns</h2>
            <p>
                <span class="timeline-marker">1952-1993</span>
                The connection between computation and biological pattern formation crystallized through
                <span class="highlight">Boris Belousov's discovery of oscillating chemical reactions in 1951</span>.
                Working at Moscow's Institute of Sanitation and Chemistry, Belousov observed potassium bromate, cerium
                sulfate, and malonic acid oscillating between yellow and colorless states.
            </p>
            <p>
                <span class="highlight">P. Gray and S.K. Scott developed their reaction-diffusion model</span> in papers
                from 1983-1985. The Gray-Scott equations describe autocatalytic reaction U + 2V → 3V with feed rate F
                and kill rate k parameters. John Pearson's 1993 Science paper "Complex Patterns in a Simple System"
                popularized computational exploration.
            </p>

            <div class="visualization">
                <h4>Interactive: Gray-Scott Reaction-Diffusion</h4>
                <canvas id="reactionDiffusion" class="viz-canvas"></canvas>
                <div class="viz-controls">
                    <button onclick="reactionDiffusion.toggle()">Play/Pause</button>
                    <button onclick="reactionDiffusion.reset()">Reset</button>
                    <button onclick="reactionDiffusion.setPreset('spots')">Spots</button>
                    <button onclick="reactionDiffusion.setPreset('stripes')">Stripes</button>
                    <button onclick="reactionDiffusion.setPreset('waves')">Waves</button>
                </div>
            </div>

            <h3>Biological Validation of Turing Patterns</h3>
            <p>
                <span class="timeline-marker">2006-2023</span>
                Theoretical predictions met experimental validation through <span class="highlight">zebrafish stripe pattern
                research starting in 2006</span>. Shigeru Kondo's laboratory demonstrated that three pigment cell types—
                melanophores (black), xanthophores (yellow), and iridophores (silvery)—interact through short-range
                repulsion and long-range attraction.
            </p>
        </section>

        <!-- SWARM INTELLIGENCE -->
        <section id="swarms" class="section">
            <h2>Swarm Intelligence: From Biology to Algorithms</h2>
            <p>
                <span class="timeline-marker">1992</span>
                <span class="highlight">Marco Dorigo's ant colony optimization</span>, first proposed in his 1992 PhD thesis
                at Politecnico di Milano, translated foraging behavior into computational algorithms. Inspired by experiments
                on Argentine ants finding shortest paths using pheromone trails, ACO features artificial ants depositing
                pheromone on paths with evaporation over time.
            </p>
            <p>
                <span class="timeline-marker">1995</span>
                <span class="highlight">James Kennedy and Russell Eberhart developed particle swarm optimization</span> at
                the 1995 IEEE International Conference on Neural Networks. Particles represent candidate solutions moving
                through search space tracking their personal best and global best positions.
            </p>
        </section>

        <!-- CHAOS THEORY -->
        <section id="chaos" class="section">
            <h2>Chaos Theory Reveals Fundamental Limits</h2>
            <p>
                <span class="timeline-marker">1963</span>
                <span class="highlight">Edward Lorenz's 1963 paper "Deterministic Nonperiodic Flow"</span> in Journal of
                the Atmospheric Sciences introduced the Lorenz attractor. The MIT meteorologist discovered sensitive
                dependence on initial conditions in winter 1961 when rounding .506127 to .506 produced drastically
                different weather simulations.
            </p>

            <div class="visualization">
                <h4>Interactive: Lorenz Attractor</h4>
                <canvas id="lorenzAttractor" class="viz-canvas"></canvas>
                <div class="viz-controls">
                    <button onclick="lorenz.toggle()">Play/Pause</button>
                    <button onclick="lorenz.reset()">Reset</button>
                    <button onclick="lorenz.addTrajectory()">Add Trajectory</button>
                    <button onclick="lorenz.rotateView()">Rotate View</button>
                </div>
            </div>

            <div class="quote">
                "Predictability: Does the Flap of a Butterfly's Wings in Brazil Set Off a Tornado in Texas?"
                — Edward Lorenz, 1972
            </div>
        </section>

        <!-- FRACTALS -->
        <section id="fractals" class="section">
            <h2>Fractals Bridge Mathematics and Nature</h2>
            <p>
                <span class="timeline-marker">1980</span>
                <span class="highlight">Benoit Mandelbrot first visualized the Mandelbrot set on March 1, 1980</span> at
                IBM's Thomas J. Watson Research Center using computer graphics. Though Robert Brooks and Peter Matelski
                defined the set in 1978, Mandelbrot's December 1980 paper and his 1982 masterwork "The Fractal Geometry
                of Nature" made fractals accessible worldwide.
            </p>

            <div class="visualization">
                <h4>Interactive: Mandelbrot Set Explorer</h4>
                <canvas id="mandelbrot" class="viz-canvas"></canvas>
                <div class="viz-controls">
                    <button onclick="mandelbrot.reset()">Reset View</button>
                    <button onclick="mandelbrot.zoomIn()">Zoom In</button>
                    <button onclick="mandelbrot.zoomOut()">Zoom Out</button>
                    <button onclick="mandelbrot.increaseIterations()">More Detail</button>
                </div>
                <p style="margin-top: 1rem; color: #666; font-size: 0.9rem; text-align: center;">
                    Click to zoom in, shift+click to zoom out
                </p>
            </div>

            <h3>L-Systems Model Plant Growth</h3>
            <p>
                <span class="timeline-marker">1968</span>
                <span class="highlight">Aristid Lindenmayer's 1968 papers</span> in Journal of Theoretical Biology
                introduced L-systems for modeling filamentous organisms. The Hungarian theoretical biologist at Utrecht
                University studied yeast, filamentous fungi, and blue-green bacteria, developing parallel rewriting
                systems where productions apply simultaneously.
            </p>

            <div class="visualization">
                <h4>Interactive: L-Systems Plant Growth</h4>
                <canvas id="lsystems" class="viz-canvas"></canvas>
                <div class="viz-controls">
                    <button onclick="lsystems.setPreset('tree')">Tree</button>
                    <button onclick="lsystems.setPreset('fern')">Fern</button>
                    <button onclick="lsystems.setPreset('bush')">Bush</button>
                    <button onclick="lsystems.grow()">Grow</button>
                    <button onclick="lsystems.reset()">Reset</button>
                </div>
            </div>
        </section>

        <!-- NETWORKS -->
        <section id="networks" class="section">
            <h2>Networks Reveal Universal Organizational Principles</h2>
            <p>
                <span class="timeline-marker">1998</span>
                <span class="highlight">Duncan Watts and Steven Strogatz's June 1998 Nature paper</span> "Collective
                dynamics of 'small-world' networks" resolved the dichotomy between regular and random networks. Their
                model starts with a ring lattice where each vertex connects to k nearest neighbors, then randomly rewires
                each edge with probability p.
            </p>
            <p>
                <span class="timeline-marker">1999</span>
                <span class="highlight">Albert-László Barabási and Réka Albert's October 1999 Science paper</span>
                "Emergence of scaling in random networks" established scale-free networks through growth and preferential
                attachment. This produces power-law degree distribution with no characteristic scale, creating natural
                emergence of "hubs."
            </p>

            <div class="visualization">
                <h4>Interactive: Network Models</h4>
                <canvas id="networks" class="viz-canvas"></canvas>
                <div class="viz-controls">
                    <button onclick="networks.generateSmallWorld()">Small-World</button>
                    <button onclick="networks.generateScaleFree()">Scale-Free</button>
                    <button onclick="networks.generateRandom()">Random</button>
                    <button onclick="networks.simulateEpidemic()">Simulate Epidemic</button>
                </div>
            </div>
        </section>

        <!-- CONCLUSION -->
        <section id="conclusion" class="section">
            <h2>Convergence Enables Modern Computational Science Education</h2>
            <p>
                The synthesis of cellular automata, agent-based modeling, reaction-diffusion systems, swarm intelligence,
                physics simulations, fractals, L-systems, network theory, evolutionary algorithms, and visualization
                technologies created unprecedented educational opportunities. <span class="highlight">A 2025 student with
                browser access can implement Conway's Life, visualize Lorenz attractors, simulate disease spread on
                scale-free networks, evolve L-system plants, and animate boids flocking</span>—all activities requiring
                million-dollar equipment and specialized expertise mere decades ago.
            </p>

            <h3>Why These Visualizations Became Canonical</h3>
            <p>
                These computational visualizations achieved canonical status through converging factors transcending
                individual technical merit:
            </p>
            <ul style="margin: 1rem 0 1rem 2rem; line-height: 2;">
                <li><strong>Pedagogical accessibility</strong> — Simple rules producing complex behavior</li>
                <li><strong>Historical timing</strong> — Technology aligned with conceptual needs</li>
                <li><strong>Visual appeal and emergence</strong> — Aesthetic hooks capturing imagination</li>
                <li><strong>Interdisciplinary relevance</strong> — Principles spanning multiple fields</li>
                <li><strong>Open-source culture</strong> — Free access with extensive documentation</li>
            </ul>

            <div class="quote">
                The 10,000× cost reduction and accessibility transformation from 1970s minicomputers to modern browsers
                fundamentally changed computational science education from elite specialization to universal access.
            </div>

            <p>
                From von Neumann's 1940s self-replicating automata through today's GPU-accelerated web visualizations,
                computational science evolved by making complex phenomena experientially accessible—transforming abstract
                mathematics into interactive exploration tools enabling millions to discover how simple rules generate
                the complex beauty underlying natural and artificial systems.
            </p>

            <p>
                The continuing importance of these simulations extends beyond historical interest. Modern research employs
                these same principles: COVID-19 modeling uses SEIR on networks, climate science applies computational
                fluid dynamics, neuroscience analyzes brain networks, synthetic biology engineers L-system-like gene
                circuits, and AI training uses evolutionary algorithms. <span class="highlight">Educational tools became
                research instruments</span>, and research advances continue feeding back into refined educational
                implementations—a virtuous cycle where accessibility enhances understanding, which enables innovation,
                which produces more powerful yet accessible tools for the next generation of computational scientists.
            </p>
        </section>
    </div>

    <div class="footer">
        <p>Part of the <a href="index.html">CCAB (Claude Code and Algorithmic Beauty)</a> collection</p>
        <p style="margin-top: 0.5rem; opacity: 0.8;">Interactive visualizations powered by HTML5 Canvas & JavaScript</p>
    </div>

    <script>
        // =====================================================
        // GAME OF LIFE IMPLEMENTATION
        // =====================================================
        const gameOfLife = {
            canvas: null,
            ctx: null,
            grid: null,
            cols: 80,
            rows: 40,
            cellSize: 0,
            running: false,
            interval: null,

            init() {
                this.canvas = document.getElementById('gameOfLife');
                if (!this.canvas || !this.canvas.getContext) {
                    console.warn('gameOfLife canvas not found or invalid');
                    return;
                }
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                this.grid = this.makeGrid();
                this.random();
                this.draw();

                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = Math.floor((e.clientX - rect.left) / this.cellSize);
                    const y = Math.floor((e.clientY - rect.top) / this.cellSize);
                    if (x >= 0 && x < this.cols && y >= 0 && y < this.rows) {
                        this.grid[y][x] = 1 - this.grid[y][x];
                        this.draw();
                    }
                });
            },

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.cellSize = this.canvas.width / this.cols;
            },

            makeGrid() {
                return Array(this.rows).fill(null).map(() => Array(this.cols).fill(0));
            },

            random() {
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        this.grid[i][j] = Math.random() > 0.7 ? 1 : 0;
                    }
                }
                this.draw();
            },

            clear() {
                this.grid = this.makeGrid();
                this.draw();
            },

            addGlider() {
                const x = Math.floor(this.cols / 2);
                const y = Math.floor(this.rows / 2);
                this.grid[y][x+1] = 1;
                this.grid[y+1][x+2] = 1;
                this.grid[y+2][x] = 1;
                this.grid[y+2][x+1] = 1;
                this.grid[y+2][x+2] = 1;
                this.draw();
            },

            countNeighbors(x, y) {
                let count = 0;
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        if (i === 0 && j === 0) continue;
                        const col = (x + j + this.cols) % this.cols;
                        const row = (y + i + this.rows) % this.rows;
                        count += this.grid[row][col];
                    }
                }
                return count;
            },

            step() {
                const next = this.makeGrid();
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        const neighbors = this.countNeighbors(j, i);
                        const state = this.grid[i][j];
                        if (state === 1 && (neighbors === 2 || neighbors === 3)) {
                            next[i][j] = 1;
                        } else if (state === 0 && neighbors === 3) {
                            next[i][j] = 1;
                        }
                    }
                }
                this.grid = next;
                this.draw();
            },

            draw() {
                this.ctx.fillStyle = '#f0f0f0';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        if (this.grid[i][j] === 1) {
                            this.ctx.fillStyle = '#667eea';
                            this.ctx.fillRect(j * this.cellSize, i * this.cellSize,
                                            this.cellSize - 1, this.cellSize - 1);
                        }
                    }
                }
            },

            toggle() {
                this.running = !this.running;
                if (this.running) {
                    this.interval = setInterval(() => this.step(), 100);
                } else {
                    clearInterval(this.interval);
                }
            }
        };

        // =====================================================
        // WOLFRAM CA IMPLEMENTATION
        // =====================================================
        const wolframCA = {
            canvas: null,
            ctx: null,
            rule: 30,
            cells: null,
            generation: 0,
            cellSize: 4,

            init() {
                this.canvas = document.getElementById('wolframCA');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                this.reset();
            },

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            },

            reset() {
                this.generation = 0;
                const width = Math.floor(this.canvas.width / this.cellSize);
                this.cells = Array(width).fill(0);
                this.cells[Math.floor(width / 2)] = 1;

                this.ctx.fillStyle = 'white';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.draw();
                this.animate();
            },

            setRule(r) {
                this.rule = r;
                this.reset();
            },

            rules(a, b, c) {
                const s = '' + a + b + c;
                const ruleStr = this.rule.toString(2).padStart(8, '0');
                const index = 7 - parseInt(s, 2);
                return parseInt(ruleStr[index]);
            },

            draw() {
                const y = this.generation * this.cellSize;
                if (y >= this.canvas.height) return false;

                for (let i = 0; i < this.cells.length; i++) {
                    this.ctx.fillStyle = this.cells[i] === 1 ? '#764ba2' : 'white';
                    this.ctx.fillRect(i * this.cellSize, y, this.cellSize, this.cellSize);
                }
                return true;
            },

            nextGeneration() {
                const newCells = Array(this.cells.length).fill(0);
                for (let i = 0; i < this.cells.length; i++) {
                    const left = i === 0 ? 0 : this.cells[i - 1];
                    const center = this.cells[i];
                    const right = i === this.cells.length - 1 ? 0 : this.cells[i + 1];
                    newCells[i] = this.rules(left, center, right);
                }
                this.cells = newCells;
                this.generation++;
            },

            animate() {
                if (this.draw()) {
                    this.nextGeneration();
                    setTimeout(() => this.animate(), 50);
                }
            }
        };

        // =====================================================
        // BOIDS IMPLEMENTATION
        // =====================================================
        const boids = {
            canvas: null,
            ctx: null,
            flock: [],
            running: true,
            showDebug: false,

            init() {
                this.canvas = document.getElementById('boids');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                this.reset();
                this.animate();
            },

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            },

            reset() {
                this.flock = [];
                for (let i = 0; i < 50; i++) {
                    this.addBoid();
                }
            },

            addBoid() {
                this.flock.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    ax: 0,
                    ay: 0
                });
            },

            toggle() {
                this.running = !this.running;
            },

            toggleDebug() {
                this.showDebug = !this.showDebug;
            },

            update() {
                if (!this.running) return;

                for (let boid of this.flock) {
                    let sep = this.separate(boid);
                    let ali = this.align(boid);
                    let coh = this.cohesion(boid);

                    boid.ax = sep.x * 1.5 + ali.x + coh.x;
                    boid.ay = sep.y * 1.5 + ali.y + coh.y;
                }

                for (let boid of this.flock) {
                    boid.vx += boid.ax;
                    boid.vy += boid.ay;

                    const speed = Math.sqrt(boid.vx * boid.vx + boid.vy * boid.vy);
                    const maxSpeed = 3;
                    if (speed > maxSpeed) {
                        boid.vx = (boid.vx / speed) * maxSpeed;
                        boid.vy = (boid.vy / speed) * maxSpeed;
                    }

                    boid.x += boid.vx;
                    boid.y += boid.vy;

                    // Wrap around
                    if (boid.x < 0) boid.x = this.canvas.width;
                    if (boid.x > this.canvas.width) boid.x = 0;
                    if (boid.y < 0) boid.y = this.canvas.height;
                    if (boid.y > this.canvas.height) boid.y = 0;

                    boid.ax = 0;
                    boid.ay = 0;
                }
            },

            separate(boid) {
                const desiredSeparation = 25;
                let steer = { x: 0, y: 0 };
                let count = 0;

                for (let other of this.flock) {
                    const d = Math.sqrt((boid.x - other.x) ** 2 + (boid.y - other.y) ** 2);
                    if (d > 0 && d < desiredSeparation) {
                        let diff = { x: boid.x - other.x, y: boid.y - other.y };
                        const len = Math.sqrt(diff.x * diff.x + diff.y * diff.y);
                        diff.x /= len;
                        diff.y /= len;
                        diff.x /= d;
                        diff.y /= d;
                        steer.x += diff.x;
                        steer.y += diff.y;
                        count++;
                    }
                }

                if (count > 0) {
                    steer.x /= count;
                    steer.y /= count;
                }

                return steer;
            },

            align(boid) {
                const neighborDist = 50;
                let sum = { x: 0, y: 0 };
                let count = 0;

                for (let other of this.flock) {
                    const d = Math.sqrt((boid.x - other.x) ** 2 + (boid.y - other.y) ** 2);
                    if (d > 0 && d < neighborDist) {
                        sum.x += other.vx;
                        sum.y += other.vy;
                        count++;
                    }
                }

                if (count > 0) {
                    sum.x /= count;
                    sum.y /= count;
                    return { x: (sum.x - boid.vx) * 0.05, y: (sum.y - boid.vy) * 0.05 };
                }
                return { x: 0, y: 0 };
            },

            cohesion(boid) {
                const neighborDist = 50;
                let sum = { x: 0, y: 0 };
                let count = 0;

                for (let other of this.flock) {
                    const d = Math.sqrt((boid.x - other.x) ** 2 + (boid.y - other.y) ** 2);
                    if (d > 0 && d < neighborDist) {
                        sum.x += other.x;
                        sum.y += other.y;
                        count++;
                    }
                }

                if (count > 0) {
                    sum.x /= count;
                    sum.y /= count;
                    return { x: (sum.x - boid.x) * 0.01, y: (sum.y - boid.y) * 0.01 };
                }
                return { x: 0, y: 0 };
            },

            draw() {
                this.ctx.fillStyle = '#1a1a2e';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                for (let boid of this.flock) {
                    const angle = Math.atan2(boid.vy, boid.vx);
                    this.ctx.save();
                    this.ctx.translate(boid.x, boid.y);
                    this.ctx.rotate(angle);

                    this.ctx.fillStyle = '#667eea';
                    this.ctx.beginPath();
                    this.ctx.moveTo(8, 0);
                    this.ctx.lineTo(-4, 4);
                    this.ctx.lineTo(-4, -4);
                    this.ctx.closePath();
                    this.ctx.fill();

                    this.ctx.restore();

                    if (this.showDebug) {
                        this.ctx.strokeStyle = 'rgba(118, 75, 162, 0.3)';
                        this.ctx.beginPath();
                        this.ctx.arc(boid.x, boid.y, 50, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                }
            },

            animate() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        };

        // =====================================================
        // REACTION-DIFFUSION IMPLEMENTATION
        // =====================================================
        const reactionDiffusion = {
            canvas: null,
            ctx: null,
            grid: null,
            next: null,
            width: 200,
            height: 100,
            dA: 1.0,
            dB: 0.5,
            feed: 0.055,
            kill: 0.062,
            running: false,

            init() {
                this.canvas = document.getElementById('reactionDiffusion');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                this.reset();
            },

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            },

            reset() {
                this.grid = [];
                this.next = [];

                for (let y = 0; y < this.height; y++) {
                    this.grid[y] = [];
                    this.next[y] = [];
                    for (let x = 0; x < this.width; x++) {
                        this.grid[y][x] = { a: 1, b: 0 };
                        this.next[y][x] = { a: 1, b: 0 };
                    }
                }

                // Add initial seeds
                for (let i = 0; i < 10; i++) {
                    const x = Math.floor(Math.random() * this.width);
                    const y = Math.floor(Math.random() * this.height);
                    for (let dx = -2; dx <= 2; dx++) {
                        for (let dy = -2; dy <= 2; dy++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
                                this.grid[ny][nx].b = 1;
                            }
                        }
                    }
                }

                this.draw();
            },

            setPreset(preset) {
                const presets = {
                    spots: { feed: 0.055, kill: 0.062 },
                    stripes: { feed: 0.035, kill: 0.065 },
                    waves: { feed: 0.014, kill: 0.054 }
                };
                if (presets[preset]) {
                    this.feed = presets[preset].feed;
                    this.kill = presets[preset].kill;
                    this.reset();
                }
            },

            toggle() {
                this.running = !this.running;
                if (this.running) {
                    this.animate();
                }
            },

            laplace(x, y, c) {
                let sum = 0;
                sum += this.grid[y][x][c] * -1;
                sum += this.grid[y][(x + 1) % this.width][c] * 0.2;
                sum += this.grid[y][(x - 1 + this.width) % this.width][c] * 0.2;
                sum += this.grid[(y + 1) % this.height][x][c] * 0.2;
                sum += this.grid[(y - 1 + this.height) % this.height][x][c] * 0.2;
                sum += this.grid[(y + 1) % this.height][(x + 1) % this.width][c] * 0.05;
                sum += this.grid[(y + 1) % this.height][(x - 1 + this.width) % this.width][c] * 0.05;
                sum += this.grid[(y - 1 + this.height) % this.height][(x + 1) % this.width][c] * 0.05;
                sum += this.grid[(y - 1 + this.height) % this.height][(x - 1 + this.width) % this.width][c] * 0.05;
                return sum;
            },

            step() {
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const a = this.grid[y][x].a;
                        const b = this.grid[y][x].b;
                        const reaction = a * b * b;

                        this.next[y][x].a = a +
                            (this.dA * this.laplace(x, y, 'a') - reaction + this.feed * (1 - a));
                        this.next[y][x].b = b +
                            (this.dB * this.laplace(x, y, 'b') + reaction - (this.kill + this.feed) * b);

                        this.next[y][x].a = Math.max(0, Math.min(1, this.next[y][x].a));
                        this.next[y][x].b = Math.max(0, Math.min(1, this.next[y][x].b));
                    }
                }

                [this.grid, this.next] = [this.next, this.grid];
            },

            draw() {
                const cellWidth = this.canvas.width / this.width;
                const cellHeight = this.canvas.height / this.height;

                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const a = this.grid[y][x].a;
                        const b = this.grid[y][x].b;
                        const c = Math.floor((a - b) * 255);
                        this.ctx.fillStyle = `rgb(${c}, ${c}, ${c})`;
                        this.ctx.fillRect(x * cellWidth, y * cellHeight,
                                        Math.ceil(cellWidth), Math.ceil(cellHeight));
                    }
                }
            },

            animate() {
                if (!this.running) return;

                for (let i = 0; i < 10; i++) {
                    this.step();
                }
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        };

        // =====================================================
        // LORENZ ATTRACTOR IMPLEMENTATION
        // =====================================================
        const lorenz = {
            canvas: null,
            ctx: null,
            points: [],
            rotation: 0,
            running: true,
            sigma: 10,
            rho: 28,
            beta: 8/3,

            init() {
                this.canvas = document.getElementById('lorenzAttractor');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                this.addTrajectory();
                this.animate();
            },

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            },

            addTrajectory() {
                this.points.push({
                    x: Math.random() * 0.02 - 0.01,
                    y: Math.random() * 0.02 - 0.01,
                    z: Math.random() * 0.02 - 0.01,
                    trail: [],
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`
                });
            },

            reset() {
                this.points = [];
                this.addTrajectory();
            },

            toggle() {
                this.running = !this.running;
            },

            rotateView() {
                this.rotation += 0.5;
            },

            update() {
                if (!this.running) return;

                for (let p of this.points) {
                    const dt = 0.005;
                    const dx = this.sigma * (p.y - p.x) * dt;
                    const dy = (p.x * (this.rho - p.z) - p.y) * dt;
                    const dz = (p.x * p.y - this.beta * p.z) * dt;

                    p.x += dx;
                    p.y += dy;
                    p.z += dz;

                    p.trail.push({ x: p.x, y: p.y, z: p.z });
                    if (p.trail.length > 1000) {
                        p.trail.shift();
                    }
                }
            },

            draw() {
                this.ctx.fillStyle = 'rgba(26, 26, 46, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                const scale = 8;

                for (let p of this.points) {
                    this.ctx.strokeStyle = p.color;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();

                    let first = true;
                    for (let point of p.trail) {
                        // Simple 3D rotation
                        const angle = this.rotation * Math.PI / 180;
                        const x = point.x * Math.cos(angle) - point.z * Math.sin(angle);
                        const z = point.x * Math.sin(angle) + point.z * Math.cos(angle);

                        const screenX = cx + x * scale;
                        const screenY = cy + point.y * scale;

                        if (first) {
                            this.ctx.moveTo(screenX, screenY);
                            first = false;
                        } else {
                            this.ctx.lineTo(screenX, screenY);
                        }
                    }
                    this.ctx.stroke();
                }
            },

            animate() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        };

        // =====================================================
        // MANDELBROT SET IMPLEMENTATION
        // =====================================================
        const mandelbrot = {
            canvas: null,
            ctx: null,
            centerX: -0.5,
            centerY: 0,
            zoom: 1,
            maxIterations: 100,

            init() {
                this.canvas = document.getElementById('mandelbrot');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                this.draw();

                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    const scale = 3.5 / this.zoom;
                    const newCenterX = this.centerX + (x - this.canvas.width / 2) * scale / this.canvas.width;
                    const newCenterY = this.centerY + (y - this.canvas.height / 2) * scale / this.canvas.height;

                    this.centerX = newCenterX;
                    this.centerY = newCenterY;

                    if (e.shiftKey) {
                        this.zoom /= 2;
                    } else {
                        this.zoom *= 2;
                    }

                    this.draw();
                });
            },

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            },

            reset() {
                this.centerX = -0.5;
                this.centerY = 0;
                this.zoom = 1;
                this.maxIterations = 100;
                this.draw();
            },

            zoomIn() {
                this.zoom *= 2;
                this.draw();
            },

            zoomOut() {
                this.zoom /= 2;
                this.draw();
            },

            increaseIterations() {
                this.maxIterations += 50;
                this.draw();
            },

            mandelbrotIterations(cx, cy) {
                let x = 0, y = 0;
                let iteration = 0;

                while (x * x + y * y <= 4 && iteration < this.maxIterations) {
                    const xtemp = x * x - y * y + cx;
                    y = 2 * x * y + cy;
                    x = xtemp;
                    iteration++;
                }

                return iteration;
            },

            draw() {
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const scale = 3.5 / this.zoom;

                for (let px = 0; px < this.canvas.width; px++) {
                    for (let py = 0; py < this.canvas.height; py++) {
                        const x = this.centerX + (px - this.canvas.width / 2) * scale / this.canvas.width;
                        const y = this.centerY + (py - this.canvas.height / 2) * scale / this.canvas.height;

                        const iterations = this.mandelbrotIterations(x, y);

                        const idx = (py * this.canvas.width + px) * 4;

                        if (iterations === this.maxIterations) {
                            imageData.data[idx] = 0;
                            imageData.data[idx + 1] = 0;
                            imageData.data[idx + 2] = 0;
                        } else {
                            const hue = (iterations / this.maxIterations) * 360;
                            const sat = 100;
                            const light = iterations < this.maxIterations ? 50 : 0;

                            const rgb = this.hslToRgb(hue, sat, light);
                            imageData.data[idx] = rgb.r;
                            imageData.data[idx + 1] = rgb.g;
                            imageData.data[idx + 2] = rgb.b;
                        }
                        imageData.data[idx + 3] = 255;
                    }
                }

                this.ctx.putImageData(imageData, 0, 0);
            },

            hslToRgb(h, s, l) {
                h /= 360;
                s /= 100;
                l /= 100;

                let r, g, b;

                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };

                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }

                return {
                    r: Math.round(r * 255),
                    g: Math.round(g * 255),
                    b: Math.round(b * 255)
                };
            }
        };

        // =====================================================
        // L-SYSTEMS IMPLEMENTATION
        // =====================================================
        const lsystems = {
            canvas: null,
            ctx: null,
            axiom: 'F',
            rules: {},
            angle: 25,
            iterations: 0,
            maxIterations: 5,
            sentence: '',

            init() {
                this.canvas = document.getElementById('lsystems');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                this.setPreset('tree');
            },

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            },

            setPreset(preset) {
                const presets = {
                    tree: {
                        axiom: 'F',
                        rules: { 'F': 'FF+[+F-F-F]-[-F+F+F]' },
                        angle: 25,
                        maxIterations: 4
                    },
                    fern: {
                        axiom: 'X',
                        rules: { 'X': 'F+[[X]-X]-F[-FX]+X', 'F': 'FF' },
                        angle: 25,
                        maxIterations: 5
                    },
                    bush: {
                        axiom: 'F',
                        rules: { 'F': 'F[+F]F[-F]F' },
                        angle: 20,
                        maxIterations: 4
                    }
                };

                if (presets[preset]) {
                    this.axiom = presets[preset].axiom;
                    this.rules = presets[preset].rules;
                    this.angle = presets[preset].angle;
                    this.maxIterations = presets[preset].maxIterations;
                    this.reset();
                }
            },

            reset() {
                this.iterations = 0;
                this.sentence = this.axiom;
                this.draw();
            },

            grow() {
                if (this.iterations < this.maxIterations) {
                    let newSentence = '';
                    for (let char of this.sentence) {
                        newSentence += this.rules[char] || char;
                    }
                    this.sentence = newSentence;
                    this.iterations++;
                    this.draw();
                }
            },

            draw() {
                this.ctx.fillStyle = '#f8f9fa';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.strokeStyle = '#2d5016';
                this.ctx.lineWidth = Math.max(1, 6 - this.iterations);

                const len = Math.min(this.canvas.width, this.canvas.height) / (Math.pow(2, this.iterations) * 2);

                this.ctx.save();
                this.ctx.translate(this.canvas.width / 2, this.canvas.height - 20);
                this.ctx.rotate(-Math.PI / 2);

                const stack = [];

                for (let char of this.sentence) {
                    if (char === 'F') {
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, 0);
                        this.ctx.lineTo(len, 0);
                        this.ctx.stroke();
                        this.ctx.translate(len, 0);
                    } else if (char === '+') {
                        this.ctx.rotate(this.angle * Math.PI / 180);
                    } else if (char === '-') {
                        this.ctx.rotate(-this.angle * Math.PI / 180);
                    } else if (char === '[') {
                        stack.push({
                            x: this.ctx.getTransform().e,
                            y: this.ctx.getTransform().f,
                            transform: this.ctx.getTransform()
                        });
                        this.ctx.save();
                    } else if (char === ']') {
                        this.ctx.restore();
                    }
                }

                this.ctx.restore();
            }
        };

        // =====================================================
        // NETWORKS IMPLEMENTATION
        // =====================================================
        const networks = {
            canvas: null,
            ctx: null,
            nodes: [],
            edges: [],
            infected: new Set(),
            running: false,

            init() {
                this.canvas = document.getElementById('networks');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                this.generateSmallWorld();
            },

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            },

            generateSmallWorld() {
                this.nodes = [];
                this.edges = [];
                this.infected.clear();
                this.running = false;

                const n = 50;
                const k = 4;
                const p = 0.1;

                // Create nodes in circle
                for (let i = 0; i < n; i++) {
                    const angle = (i / n) * Math.PI * 2;
                    const radius = Math.min(this.canvas.width, this.canvas.height) * 0.4;
                    this.nodes.push({
                        x: this.canvas.width / 2 + Math.cos(angle) * radius,
                        y: this.canvas.height / 2 + Math.sin(angle) * radius,
                        id: i
                    });
                }

                // Create ring lattice
                for (let i = 0; i < n; i++) {
                    for (let j = 1; j <= k / 2; j++) {
                        this.edges.push({
                            from: i,
                            to: (i + j) % n
                        });
                    }
                }

                // Rewire with probability p
                for (let i = this.edges.length - 1; i >= 0; i--) {
                    if (Math.random() < p) {
                        this.edges[i].to = Math.floor(Math.random() * n);
                    }
                }

                this.draw();
            },

            generateScaleFree() {
                this.nodes = [];
                this.edges = [];
                this.infected.clear();
                this.running = false;

                const n = 50;
                const m = 2;

                // Start with small connected network
                for (let i = 0; i < m + 1; i++) {
                    const angle = (i / (m + 1)) * Math.PI * 2;
                    const radius = Math.min(this.canvas.width, this.canvas.height) * 0.4;
                    this.nodes.push({
                        x: this.canvas.width / 2 + Math.cos(angle) * radius,
                        y: this.canvas.height / 2 + Math.sin(angle) * radius,
                        id: i,
                        degree: m
                    });
                }

                for (let i = 0; i < m + 1; i++) {
                    for (let j = i + 1; j < m + 1; j++) {
                        this.edges.push({ from: i, to: j });
                    }
                }

                // Preferential attachment
                for (let i = m + 1; i < n; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * Math.min(this.canvas.width, this.canvas.height) * 0.4;
                    this.nodes.push({
                        x: this.canvas.width / 2 + Math.cos(angle) * radius,
                        y: this.canvas.height / 2 + Math.sin(angle) * radius,
                        id: i,
                        degree: 0
                    });

                    const totalDegree = this.edges.length * 2;
                    const targets = new Set();

                    while (targets.size < m) {
                        let sum = 0;
                        let r = Math.random() * totalDegree;

                        for (let j = 0; j < i; j++) {
                            sum += this.nodes[j].degree;
                            if (sum >= r && !targets.has(j)) {
                                targets.add(j);
                                break;
                            }
                        }
                    }

                    targets.forEach(target => {
                        this.edges.push({ from: i, to: target });
                        this.nodes[i].degree++;
                        this.nodes[target].degree++;
                    });
                }

                this.draw();
            },

            generateRandom() {
                this.nodes = [];
                this.edges = [];
                this.infected.clear();
                this.running = false;

                const n = 50;
                const p = 0.05;

                for (let i = 0; i < n; i++) {
                    const angle = (i / n) * Math.PI * 2;
                    const radius = Math.min(this.canvas.width, this.canvas.height) * 0.4;
                    this.nodes.push({
                        x: this.canvas.width / 2 + Math.cos(angle) * radius,
                        y: this.canvas.height / 2 + Math.sin(angle) * radius,
                        id: i
                    });
                }

                for (let i = 0; i < n; i++) {
                    for (let j = i + 1; j < n; j++) {
                        if (Math.random() < p) {
                            this.edges.push({ from: i, to: j });
                        }
                    }
                }

                this.draw();
            },

            simulateEpidemic() {
                this.infected.clear();
                this.infected.add(Math.floor(Math.random() * this.nodes.length));
                this.running = true;
                this.animateEpidemic();
            },

            animateEpidemic() {
                if (!this.running || this.infected.size === this.nodes.length) {
                    this.running = false;
                    return;
                }

                const newInfected = new Set(this.infected);

                this.infected.forEach(nodeId => {
                    this.edges.forEach(edge => {
                        if (edge.from === nodeId && !this.infected.has(edge.to)) {
                            if (Math.random() < 0.3) {
                                newInfected.add(edge.to);
                            }
                        }
                        if (edge.to === nodeId && !this.infected.has(edge.from)) {
                            if (Math.random() < 0.3) {
                                newInfected.add(edge.from);
                            }
                        }
                    });
                });

                this.infected = newInfected;
                this.draw();

                setTimeout(() => this.animateEpidemic(), 500);
            },

            draw() {
                this.ctx.fillStyle = '#1a1a2e';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw edges
                this.ctx.strokeStyle = 'rgba(102, 126, 234, 0.3)';
                this.ctx.lineWidth = 1;
                this.edges.forEach(edge => {
                    const from = this.nodes[edge.from];
                    const to = this.nodes[edge.to];
                    this.ctx.beginPath();
                    this.ctx.moveTo(from.x, from.y);
                    this.ctx.lineTo(to.x, to.y);
                    this.ctx.stroke();
                });

                // Draw nodes
                this.nodes.forEach(node => {
                    this.ctx.fillStyle = this.infected.has(node.id) ? '#e63946' : '#667eea';
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, 5, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
        };

        // =====================================================
        // INITIALIZE ALL VISUALIZATIONS
        // =====================================================
        window.addEventListener('DOMContentLoaded', () => {
            const inits = [
                ['gameOfLife', gameOfLife],
                ['wolframCA', wolframCA],
                ['boids', boids],
                ['reactionDiffusion', reactionDiffusion],
                ['lorenz', lorenz],
                ['mandelbrot', mandelbrot],
                ['lsystems', lsystems],
                ['networks', networks]
            ];
            inits.forEach(([name, obj]) => {
                try {
                    if (obj && typeof obj.init === 'function') obj.init();
                } catch (e) {
                    console.warn(`Failed to init ${name}:`, e.message);
                }
            });
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            gameOfLife.resize();
            gameOfLife.draw();
            wolframCA.resize();
            boids.resize();
            reactionDiffusion.resize();
            lorenz.resize();
            mandelbrot.resize();
            mandelbrot.draw();
            lsystems.resize();
            lsystems.draw();
            networks.resize();
            networks.draw();
        });

        // Smooth scrolling for navigation
        document.querySelectorAll('.nav-timeline a').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
        });
    </script>
    <script src="assets/js/enhance.js" defer></script>
</body>
</html>
