<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Thermohaline Circulation</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Nunito', sans-serif; }
canvas { display: block; }
.title-overlay {
    position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
    color: #fff; font-size: 1.4rem; font-weight: 600;
    text-shadow: 0 2px 10px rgba(0,0,0,0.7);
    pointer-events: none; z-index: 10; text-align: center;
}
.title-overlay .subtitle {
    font-size: 0.8rem; opacity: 0.7; margin-top: 4px; font-weight: 300;
}
.organic-back-link {
    position: fixed; top: 20px; left: 20px; z-index: 100;
    display: flex; align-items: center; gap: 8px;
    padding: 8px 16px; border-radius: 20px;
    background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);
    color: #fff; text-decoration: none; font-size: 0.9rem;
    transition: background 0.3s;
}
.organic-back-link:hover { background: rgba(255,255,255,0.2); }
.controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 20px; align-items: center; z-index: 10; flex-wrap: wrap; justify-content: center;
    background: rgba(0,0,0,0.6); backdrop-filter: blur(10px);
    padding: 12px 24px; border-radius: 20px; color: #fff; font-size: 0.85rem;
}
.controls label { display: flex; align-items: center; gap: 8px; white-space: nowrap; }
.controls input[type="range"] { width: 100px; }
</style>
</head>
<body>
<a href="../index.html" class="organic-back-link">
    <span class="back-arrow">&larr;</span>
    <span class="back-text">Gallery</span>
</a>
<div class="title-overlay">
    Thermohaline Circulation
    <div class="subtitle">The global ocean conveyor belt &mdash; driven by temperature and salinity</div>
</div>
<div class="controls">
    <label>Flow Speed: <input type="range" id="flowSlider" min="0.3" max="3" step="0.1" value="1"> <span id="flowVal">1.0</span></label>
    <label>Temp Diff: <input type="range" id="tempSlider" min="0.3" max="3" step="0.1" value="1.5"> <span id="tempVal">1.5</span></label>
    <label>Salinity: <input type="range" id="salSlider" min="0.3" max="2" step="0.1" value="1"> <span id="salVal">1.0</span></label>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

const NUM_PARTICLES = 2500;
const particles = [];

// Ocean cross-section boundaries
function getOceanBounds() {
    const margin = 60;
    const top = H * 0.2;
    const bottom = H * 0.85;
    const left = margin;
    const right = W - margin;
    return { top, bottom, left, right, midY: (top + bottom) / 2 };
}

// The circulation path is an elongated loop
// Top: warm surface current flowing right (equator to pole)
// Right: sinking (cold, salty water at pole)
// Bottom: cold deep current flowing left
// Left: upwelling (warming)
function getPathPosition(t, bounds) {
    // t goes from 0 to 1 around the loop
    t = ((t % 1) + 1) % 1;
    const { top, bottom, left, right } = bounds;
    const surfaceY = top + 30;
    const deepY = bottom - 30;
    const turnR = (deepY - surfaceY) / 2;

    if (t < 0.4) {
        // Top: surface current flowing right
        const frac = t / 0.4;
        return {
            x: left + frac * (right - left - turnR),
            y: surfaceY + Math.sin(frac * Math.PI * 4) * 8,
            temp: 0.8 - frac * 0.3,
            depth: 0
        };
    } else if (t < 0.5) {
        // Right: sinking
        const frac = (t - 0.4) / 0.1;
        const angle = -Math.PI / 2 + frac * Math.PI;
        const cx = right - turnR;
        const cy = (surfaceY + deepY) / 2;
        return {
            x: cx + Math.cos(angle) * turnR,
            y: cy + Math.sin(angle) * turnR,
            temp: 0.5 - frac * 0.3,
            depth: frac
        };
    } else if (t < 0.9) {
        // Bottom: deep current flowing left
        const frac = (t - 0.5) / 0.4;
        return {
            x: right - turnR - frac * (right - left - turnR),
            y: deepY + Math.sin(frac * Math.PI * 3) * 5,
            temp: 0.2 + frac * 0.1,
            depth: 1
        };
    } else {
        // Left: upwelling
        const frac = (t - 0.9) / 0.1;
        const angle = Math.PI / 2 + frac * Math.PI;
        const cx = left + turnR;
        const cy = (surfaceY + deepY) / 2;
        return {
            x: cx + Math.cos(angle) * turnR,
            y: cy + Math.sin(angle) * turnR,
            temp: 0.3 + frac * 0.5,
            depth: 1 - frac
        };
    }
}

class Particle {
    constructor() {
        this.t = Math.random();
        this.offset = (Math.random() - 0.5) * 40;
        this.speed = 0.8 + Math.random() * 0.4;
        this.size = 1.5 + Math.random() * 2;
    }
    update(flowSpeed) {
        this.t += 0.0005 * flowSpeed * this.speed;
        if (this.t > 1) this.t -= 1;
    }
    draw(tempDiff, salinity) {
        const bounds = getOceanBounds();
        const pos = getPathPosition(this.t, bounds);

        const px = pos.x;
        const py = pos.y + this.offset * (1 - pos.depth * 0.5);

        // Temperature coloring
        const temp = pos.temp * tempDiff;
        let r, g, b;
        if (temp > 0.6) {
            const t2 = (temp - 0.6) / 0.9;
            r = 180 + t2 * 75; g = 60 + t2 * 40; b = 30;
        } else if (temp > 0.3) {
            const t2 = (temp - 0.3) / 0.3;
            r = 60 + t2 * 120; g = 100 + t2 * (-40); b = 180 - t2 * 150;
        } else {
            const t2 = temp / 0.3;
            r = 20 + t2 * 40; g = 40 + t2 * 60; b = 200 + t2 * (-20);
        }

        // Salinity affects brightness
        const salBright = 0.7 + salinity * 0.3;
        r = Math.min(255, Math.floor(r * salBright));
        g = Math.min(255, Math.floor(g * salBright));
        b = Math.min(255, Math.floor(b * salBright));

        ctx.fillStyle = `rgba(${r},${g},${b},0.7)`;
        ctx.beginPath();
        ctx.arc(px, py, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

for (let i = 0; i < NUM_PARTICLES; i++) {
    particles.push(new Particle());
}

function drawOceanCrossSection(bounds) {
    const { top, bottom, left, right } = bounds;

    // Ocean body
    const grad = ctx.createLinearGradient(0, top, 0, bottom);
    grad.addColorStop(0, 'rgba(10, 40, 80, 0.4)');
    grad.addColorStop(0.3, 'rgba(8, 30, 60, 0.5)');
    grad.addColorStop(1, 'rgba(5, 15, 35, 0.6)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.roundRect(left, top, right - left, bottom - top, 20);
    ctx.fill();

    // Surface wave effect
    ctx.strokeStyle = 'rgba(100, 180, 255, 0.2)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    const time = Date.now() * 0.001;
    for (let x = left; x <= right; x += 3) {
        const y = top + Math.sin(x * 0.02 + time) * 3 + Math.sin(x * 0.01 + time * 0.7) * 2;
        if (x === left) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Depth labels
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.font = '11px sans-serif';
    ctx.fillText('Surface (0m)', left + 10, top + 45);
    ctx.fillText('Deep Ocean (4000m)', left + 10, bottom - 15);

    // Region labels
    ctx.fillStyle = 'rgba(255,200,100,0.15)';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Equator (Warm)', left + 60, top - 10);
    ctx.fillText('Poles (Cold, Salty)', right - 80, top - 10);
    ctx.textAlign = 'left';

    // Arrow indicators on path
    drawPathArrows(bounds);
}

function drawPathArrows(bounds) {
    const arrowPoints = [0.1, 0.2, 0.3, 0.45, 0.6, 0.7, 0.8, 0.95];
    for (const t of arrowPoints) {
        const pos = getPathPosition(t, bounds);
        const pos2 = getPathPosition(t + 0.005, bounds);
        const angle = Math.atan2(pos2.y - pos.y, pos2.x - pos.x);

        ctx.save();
        ctx.translate(pos.x, pos.y);
        ctx.rotate(angle);
        ctx.fillStyle = pos.temp > 0.5 ? 'rgba(255,150,80,0.2)' : 'rgba(80,150,255,0.2)';
        ctx.beginPath();
        ctx.moveTo(8, 0);
        ctx.lineTo(-4, -4);
        ctx.lineTo(-4, 4);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
}

function drawLabels(bounds) {
    const { top, bottom, left, right } = bounds;

    // Warm current label
    ctx.fillStyle = 'rgba(255, 130, 60, 0.3)';
    ctx.font = 'bold 13px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('\u2192 Warm Surface Current \u2192', (left + right) / 2, top + 25);

    // Cold current label
    ctx.fillStyle = 'rgba(80, 150, 255, 0.3)';
    ctx.fillText('\u2190 Cold Deep Current \u2190', (left + right) / 2, bottom - 25);

    // Sinking label
    ctx.save();
    ctx.translate(right - 20, (top + bottom) / 2);
    ctx.rotate(Math.PI / 2);
    ctx.fillStyle = 'rgba(100, 130, 255, 0.25)';
    ctx.fillText('\u2193 Sinking (Dense) \u2193', 0, 0);
    ctx.restore();

    // Upwelling label
    ctx.save();
    ctx.translate(left + 20, (top + bottom) / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillStyle = 'rgba(255, 180, 100, 0.25)';
    ctx.fillText('\u2191 Upwelling \u2191', 0, 0);
    ctx.restore();

    ctx.textAlign = 'left';
}

function drawTemperatureLegend() {
    const x = W - 180;
    const y = H * 0.2 + 20;
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath();
    ctx.roundRect(x - 10, y - 10, 170, 60, 10);
    ctx.fill();

    const grad = ctx.createLinearGradient(x, y, x + 140, y);
    grad.addColorStop(0, '#1430c8');
    grad.addColorStop(0.5, '#3c64b4');
    grad.addColorStop(1, '#ff6030');
    ctx.fillStyle = grad;
    ctx.fillRect(x, y + 5, 140, 12);

    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.font = '10px sans-serif';
    ctx.fillText('Temperature', x + 35, y);
    ctx.fillText('Cold', x, y + 35);
    ctx.textAlign = 'right';
    ctx.fillText('Warm', x + 140, y + 35);
    ctx.textAlign = 'left';
}

function animate() {
    const flowSpeed = parseFloat(document.getElementById('flowSlider').value);
    const tempDiff = parseFloat(document.getElementById('tempSlider').value);
    const salinity = parseFloat(document.getElementById('salSlider').value);
    document.getElementById('flowVal').textContent = flowSpeed.toFixed(1);
    document.getElementById('tempVal').textContent = tempDiff.toFixed(1);
    document.getElementById('salVal').textContent = salinity.toFixed(1);

    ctx.fillStyle = 'rgba(10, 14, 26, 0.2)';
    ctx.fillRect(0, 0, W, H);

    const bounds = getOceanBounds();
    drawOceanCrossSection(bounds);
    drawLabels(bounds);
    drawTemperatureLegend();

    for (const p of particles) {
        p.update(flowSpeed);
        p.draw(tempDiff, salinity);
    }

    requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
