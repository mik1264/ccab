<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rotating Cube</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0a0a0a;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            padding: 10px 15px;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="info">3D Rotating Cube - Drag to rotate!</div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let angleX = 0;
        let angleY = 0;
        let angleZ = 0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Define cube vertices
        const vertices = [
            [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1], // Back face
            [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]      // Front face
        ];

        const edges = [
            [0, 1], [1, 2], [2, 3], [3, 0], // Back face
            [4, 5], [5, 6], [6, 7], [7, 4], // Front face
            [0, 4], [1, 5], [2, 6], [3, 7]  // Connecting edges
        ];

        function rotateX(point, angle) {
            const [x, y, z] = point;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return [x, y * cos - z * sin, y * sin + z * cos];
        }

        function rotateY(point, angle) {
            const [x, y, z] = point;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return [x * cos + z * sin, y, -x * sin + z * cos];
        }

        function rotateZ(point, angle) {
            const [x, y, z] = point;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return [x * cos - y * sin, x * sin + y * cos, z];
        }

        function project(point) {
            const scale = 150;
            const distance = 5;
            const [x, y, z] = point;
            const factor = distance / (distance + z);
            return [
                canvas.width / 2 + x * scale * factor,
                canvas.height / 2 + y * scale * factor
            ];
        }

        function animate() {
            ctx.fillStyle = 'rgba(10, 10, 10, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!isDragging) {
                angleX += 0.01;
                angleY += 0.01;
                angleZ += 0.005;
            }

            // Transform vertices
            const transformedVertices = vertices.map(v => {
                let point = rotateX(v, angleX);
                point = rotateY(point, angleY);
                point = rotateZ(point, angleZ);
                return point;
            });

            // Draw edges
            edges.forEach(([start, end]) => {
                const [x1, y1] = project(transformedVertices[start]);
                const [x2, y2] = project(transformedVertices[end]);

                const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
                gradient.addColorStop(0, '#00ffff');
                gradient.addColorStop(1, '#ff00ff');

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            });

            // Draw vertices
            transformedVertices.forEach(v => {
                const [x, y] = project(v);
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            });

            requestAnimationFrame(animate);
        }

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                angleY += deltaX * 0.01;
                angleX += deltaY * 0.01;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Expose for enhance.js keyboard shortcuts
        window.reset = function() { angleX = 0; angleY = 0; angleZ = 0; };

        animate();
    </script>
    <script src="../../assets/js/enhance.js" defer></script>
</body>
</html>
