<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reaction-Diffusion - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0e1a;
            --theme-color: #667eea;
            --text-accent: #fbbf24;
            --bg-secondary: #141827;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --border-color: #1e293b;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Navigation Header */
        .nav-header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        .nav-header a {
            color: var(--text-secondary);
            text-decoration: none;
            transition: color 0.3s;
        }

        .nav-header a:hover {
            color: var(--theme-color);
        }

        .nav-header h1 {
            color: var(--text-accent);
            font-size: 1.5rem;
        }

        /* Main Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Tab Navigation */
        .tabs {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            border-bottom: 2px solid var(--border-color);
        }

        .tab {
            background: none;
            border: none;
            color: var(--text-secondary);
            padding: 1rem 1.5rem;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
        }

        .tab:hover {
            color: var(--text-primary);
        }

        .tab.active {
            color: var(--theme-color);
            border-bottom-color: var(--theme-color);
        }

        /* Tab Content */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Canvas Container */
        .canvas-container {
            position: relative;
            background: var(--bg-secondary);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            cursor: crosshair;
        }

        /* Controls Panel */
        .controls {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }

        .control-group {
            margin-bottom: 1.5rem;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            display: block;
            color: var(--text-primary);
            font-weight: 500;
            margin-bottom: 0.5rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--border-color);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--theme-color);
            border-radius: 50%;
            cursor: pointer;
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--theme-color);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .range-value {
            display: inline-block;
            color: var(--text-accent);
            font-family: monospace;
            margin-left: 0.5rem;
        }

        /* Buttons */
        .button-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        button {
            background: var(--theme-color);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
        }

        /* Preset Grid */
        .preset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .preset-btn {
            width: 100%;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            padding: 1rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .preset-btn:hover {
            border-color: var(--theme-color);
            background: rgba(102, 126, 234, 0.1);
        }

        /* Color Map Selector */
        .colormap-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .colormap-option {
            padding: 0.5rem;
            text-align: center;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s;
        }

        .colormap-option:hover,
        .colormap-option.active {
            border-color: var(--theme-color);
            background: rgba(102, 126, 234, 0.1);
        }

        /* Info Text */
        .info {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.6;
        }

        /* Parameter Space Grid */
        #parameterCanvas {
            cursor: pointer;
        }

        .grid-info {
            background: var(--bg-primary);
            padding: 1rem;
            border-radius: 6px;
            margin-top: 1rem;
        }

        .grid-info p {
            margin-bottom: 0.5rem;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            .nav-header {
                padding: 1rem;
            }

            .preset-grid {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            }
        }
    </style>
</head>
<body>
    <!-- Navigation Header -->
    <nav class="nav-header">
        <a href="../index.html">‚Üê Back to CCAB</a>
        <h1>Reaction-Diffusion</h1>
    </nav>

    <!-- Main Container -->
    <div class="container">
        <!-- Tab Navigation -->
        <div class="tabs">
            <button class="tab active" data-tab="gray-scott">Gray-Scott</button>
            <button class="tab" data-tab="parameter-space">Parameter Space</button>
            <button class="tab" data-tab="interactive">Interactive</button>
        </div>

        <!-- Gray-Scott Tab -->
        <div class="tab-content active" id="gray-scott">
            <div class="canvas-container">
                <canvas id="grayScottCanvas" width="800" height="600"></canvas>
            </div>

            <div class="controls">
                <div class="preset-grid">
                    <button class="preset-btn" data-preset="mitosis">Mitosis</button>
                    <button class="preset-btn" data-preset="coral">Coral</button>
                    <button class="preset-btn" data-preset="fingerprints">Fingerprints</button>
                    <button class="preset-btn" data-preset="maze">Maze</button>
                    <button class="preset-btn" data-preset="spots">Spots</button>
                    <button class="preset-btn" data-preset="stripes">Stripes</button>
                </div>

                <div class="control-group">
                    <label>Feed Rate (f): <span class="range-value" id="feedValue">0.055</span></label>
                    <input type="range" id="feedRate" min="0.01" max="0.1" step="0.001" value="0.055">
                </div>

                <div class="control-group">
                    <label>Kill Rate (k): <span class="range-value" id="killValue">0.062</span></label>
                    <input type="range" id="killRate" min="0.01" max="0.1" step="0.001" value="0.062">
                </div>

                <div class="control-group">
                    <label>Diffusion A (Du): <span class="range-value" id="diffAValue">1.0</span></label>
                    <input type="range" id="diffA" min="0.1" max="2.0" step="0.05" value="1.0">
                </div>

                <div class="control-group">
                    <label>Diffusion B (Dv): <span class="range-value" id="diffBValue">0.5</span></label>
                    <input type="range" id="diffB" min="0.1" max="1.0" step="0.05" value="0.5">
                </div>

                <div class="control-group">
                    <label>Color Map</label>
                    <div class="colormap-grid">
                        <div class="colormap-option active" data-colormap="viridis">Viridis</div>
                        <div class="colormap-option" data-colormap="plasma">Plasma</div>
                        <div class="colormap-option" data-colormap="inferno">Inferno</div>
                        <div class="colormap-option" data-colormap="thermal">Thermal</div>
                        <div class="colormap-option" data-colormap="rainbow">Rainbow</div>
                    </div>
                </div>

                <div class="button-group">
                    <button id="resetBtn">Reset</button>
                    <button id="pauseBtn">Pause</button>
                    <button id="randomizeBtn" class="secondary">Randomize</button>
                </div>

                <div class="info">
                    <p>The Gray-Scott model simulates reaction-diffusion systems where two chemicals interact to create self-organizing patterns.</p>
                    <p>Click and drag on the canvas to add chemical B and watch patterns emerge.</p>
                </div>
            </div>
        </div>

        <!-- Parameter Space Tab -->
        <div class="tab-content" id="parameter-space">
            <div class="canvas-container">
                <canvas id="parameterCanvas" width="800" height="600"></canvas>
            </div>

            <div class="controls">
                <div class="button-group">
                    <button id="generateGridBtn">Generate Grid</button>
                    <button id="resetGridBtn" class="secondary">Reset</button>
                </div>

                <div class="grid-info">
                    <p><strong>Parameter Space Exploration</strong></p>
                    <p>This grid shows different pattern types across various combinations of feed (f) and kill (k) rates.</p>
                    <p>Each cell represents a different parameter combination, revealing the diversity of Turing patterns.</p>
                    <p>Click on any cell to apply those parameters to the Gray-Scott tab.</p>
                </div>
            </div>
        </div>

        <!-- Interactive Tab -->
        <div class="tab-content" id="interactive">
            <div class="canvas-container">
                <canvas id="interactiveCanvas" width="800" height="600"></canvas>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Brush Size: <span class="range-value" id="brushValue">30</span></label>
                    <input type="range" id="brushSize" min="5" max="100" step="5" value="30">
                </div>

                <div class="button-group">
                    <button id="clearInteractiveBtn">Clear</button>
                    <button id="pauseInteractiveBtn">Pause</button>
                    <button id="drawModeBtn">Draw Mode: Add B</button>
                </div>

                <div class="info">
                    <p>Click and drag to paint chemical B onto the canvas.</p>
                    <p>Experiment with different brush sizes and drawing patterns to create unique formations.</p>
                    <p>Toggle draw mode to either add or remove chemical B.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // WebGL Utilities
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        function createTexture(gl, width, height, data = null) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, data);
            return texture;
        }

        function createFramebuffer(gl, texture) {
            const fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            return fb;
        }

        // Vertex Shader (shared)
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_texCoord;
            void main() {
                v_texCoord = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // Fragment Shader for Reaction-Diffusion
        const reactionDiffusionShaderSource = `
            precision highp float;
            varying vec2 v_texCoord;
            uniform sampler2D u_state;
            uniform vec2 u_resolution;
            uniform float u_feed;
            uniform float u_kill;
            uniform float u_diffA;
            uniform float u_diffB;
            uniform float u_dt;

            void main() {
                vec2 pixel = 1.0 / u_resolution;

                // Sample current state
                vec2 state = texture2D(u_state, v_texCoord).rg;
                float a = state.r;
                float b = state.g;

                // Compute Laplacian using convolution kernel
                vec2 laplacian = vec2(0.0);

                // 3x3 kernel weights
                laplacian += texture2D(u_state, v_texCoord + vec2(-pixel.x, 0.0)).rg * 0.2;
                laplacian += texture2D(u_state, v_texCoord + vec2(pixel.x, 0.0)).rg * 0.2;
                laplacian += texture2D(u_state, v_texCoord + vec2(0.0, -pixel.y)).rg * 0.2;
                laplacian += texture2D(u_state, v_texCoord + vec2(0.0, pixel.y)).rg * 0.2;
                laplacian += texture2D(u_state, v_texCoord + vec2(-pixel.x, -pixel.y)).rg * 0.05;
                laplacian += texture2D(u_state, v_texCoord + vec2(pixel.x, -pixel.y)).rg * 0.05;
                laplacian += texture2D(u_state, v_texCoord + vec2(-pixel.x, pixel.y)).rg * 0.05;
                laplacian += texture2D(u_state, v_texCoord + vec2(pixel.x, pixel.y)).rg * 0.05;
                laplacian -= state * 1.0;

                // Gray-Scott equations
                float abb = a * b * b;
                float da = u_diffA * laplacian.r - abb + u_feed * (1.0 - a);
                float db = u_diffB * laplacian.g + abb - (u_kill + u_feed) * b;

                // Update state
                a += da * u_dt;
                b += db * u_dt;

                // Clamp values
                a = clamp(a, 0.0, 1.0);
                b = clamp(b, 0.0, 1.0);

                gl_FragColor = vec4(a, b, 0.0, 1.0);
            }
        `;

        // Fragment Shader for Rendering
        const renderShaderSource = `
            precision highp float;
            varying vec2 v_texCoord;
            uniform sampler2D u_state;
            uniform int u_colormap;

            vec3 viridis(float t) {
                const vec3 c0 = vec3(0.267, 0.005, 0.329);
                const vec3 c1 = vec3(0.283, 0.141, 0.458);
                const vec3 c2 = vec3(0.254, 0.265, 0.530);
                const vec3 c3 = vec3(0.207, 0.372, 0.553);
                const vec3 c4 = vec3(0.164, 0.471, 0.558);
                const vec3 c5 = vec3(0.128, 0.567, 0.551);
                const vec3 c6 = vec3(0.135, 0.659, 0.518);
                const vec3 c7 = vec3(0.267, 0.749, 0.441);
                const vec3 c8 = vec3(0.478, 0.821, 0.318);
                const vec3 c9 = vec3(0.741, 0.873, 0.150);
                const vec3 c10 = vec3(0.993, 0.906, 0.144);

                if (t < 0.1) return mix(c0, c1, t * 10.0);
                else if (t < 0.2) return mix(c1, c2, (t - 0.1) * 10.0);
                else if (t < 0.3) return mix(c2, c3, (t - 0.2) * 10.0);
                else if (t < 0.4) return mix(c3, c4, (t - 0.3) * 10.0);
                else if (t < 0.5) return mix(c4, c5, (t - 0.4) * 10.0);
                else if (t < 0.6) return mix(c5, c6, (t - 0.5) * 10.0);
                else if (t < 0.7) return mix(c6, c7, (t - 0.6) * 10.0);
                else if (t < 0.8) return mix(c7, c8, (t - 0.7) * 10.0);
                else if (t < 0.9) return mix(c8, c9, (t - 0.8) * 10.0);
                else return mix(c9, c10, (t - 0.9) * 10.0);
            }

            vec3 plasma(float t) {
                const vec3 c0 = vec3(0.050, 0.030, 0.529);
                const vec3 c1 = vec3(0.280, 0.014, 0.605);
                const vec3 c2 = vec3(0.480, 0.003, 0.658);
                const vec3 c3 = vec3(0.647, 0.125, 0.597);
                const vec3 c4 = vec3(0.785, 0.278, 0.490);
                const vec3 c5 = vec3(0.892, 0.434, 0.365);
                const vec3 c6 = vec3(0.969, 0.596, 0.227);
                const vec3 c7 = vec3(0.992, 0.769, 0.114);
                const vec3 c8 = vec3(0.957, 0.949, 0.131);

                if (t < 0.125) return mix(c0, c1, t * 8.0);
                else if (t < 0.25) return mix(c1, c2, (t - 0.125) * 8.0);
                else if (t < 0.375) return mix(c2, c3, (t - 0.25) * 8.0);
                else if (t < 0.5) return mix(c3, c4, (t - 0.375) * 8.0);
                else if (t < 0.625) return mix(c4, c5, (t - 0.5) * 8.0);
                else if (t < 0.75) return mix(c5, c6, (t - 0.625) * 8.0);
                else if (t < 0.875) return mix(c6, c7, (t - 0.75) * 8.0);
                else return mix(c7, c8, (t - 0.875) * 8.0);
            }

            vec3 inferno(float t) {
                vec3 c0 = vec3(0.0, 0.0, 0.0);
                vec3 c1 = vec3(0.3, 0.0, 0.3);
                vec3 c2 = vec3(0.6, 0.1, 0.3);
                vec3 c3 = vec3(0.9, 0.3, 0.2);
                vec3 c4 = vec3(1.0, 0.6, 0.1);
                vec3 c5 = vec3(1.0, 0.9, 0.5);

                if (t < 0.2) return mix(c0, c1, t * 5.0);
                else if (t < 0.4) return mix(c1, c2, (t - 0.2) * 5.0);
                else if (t < 0.6) return mix(c2, c3, (t - 0.4) * 5.0);
                else if (t < 0.8) return mix(c3, c4, (t - 0.6) * 5.0);
                else return mix(c4, c5, (t - 0.8) * 5.0);
            }

            vec3 thermal(float t) {
                vec3 c0 = vec3(0.0, 0.0, 0.0);
                vec3 c1 = vec3(0.3, 0.0, 0.5);
                vec3 c2 = vec3(0.8, 0.0, 0.0);
                vec3 c3 = vec3(1.0, 0.5, 0.0);
                vec3 c4 = vec3(1.0, 1.0, 0.0);
                vec3 c5 = vec3(1.0, 1.0, 1.0);

                if (t < 0.2) return mix(c0, c1, t * 5.0);
                else if (t < 0.4) return mix(c1, c2, (t - 0.2) * 5.0);
                else if (t < 0.6) return mix(c2, c3, (t - 0.4) * 5.0);
                else if (t < 0.8) return mix(c3, c4, (t - 0.6) * 5.0);
                else return mix(c4, c5, (t - 0.8) * 5.0);
            }

            vec3 rainbow(float t) {
                float r = abs(2.0 * t - 0.5);
                float g = sin(t * 3.14159);
                float b = cos(t * 3.14159 * 0.5);
                return vec3(r, g, b);
            }

            void main() {
                float value = texture2D(u_state, v_texCoord).g;
                vec3 color;

                if (u_colormap == 0) color = viridis(value);
                else if (u_colormap == 1) color = plasma(value);
                else if (u_colormap == 2) color = inferno(value);
                else if (u_colormap == 3) color = thermal(value);
                else color = rainbow(value);

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Reaction-Diffusion Simulator Class
        class ReactionDiffusion {
            constructor(canvas, width, height) {
                this.canvas = canvas;
                this.width = width;
                this.height = height;
                this.canvas.width = width;
                this.canvas.height = height;

                const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });
                if (!gl) {
                    alert('WebGL not supported');
                    return;
                }

                // Enable float textures
                const ext = gl.getExtension('OES_texture_float');
                if (!ext) {
                    alert('OES_texture_float not supported');
                    return;
                }

                this.gl = gl;
                this.setupShaders();
                this.setupGeometry();
                this.setupTextures();

                this.params = {
                    feed: 0.055,
                    kill: 0.062,
                    diffA: 1.0,
                    diffB: 0.5,
                    dt: 1.0
                };

                this.colormap = 0;
                this.paused = false;
                this.currentFB = 0;

                this.initialize();
            }

            setupShaders() {
                const gl = this.gl;

                const vertShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
                const reactionFragShader = createShader(gl, gl.FRAGMENT_SHADER, reactionDiffusionShaderSource);
                const renderFragShader = createShader(gl, gl.FRAGMENT_SHADER, renderShaderSource);

                this.reactionProgram = createProgram(gl, vertShader, reactionFragShader);
                this.renderProgram = createProgram(gl, vertShader, renderFragShader);
            }

            setupGeometry() {
                const gl = this.gl;
                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                const vertices = new Float32Array([
                    -1, -1,
                    1, -1,
                    -1, 1,
                    1, 1
                ]);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                this.positionBuffer = buffer;
            }

            setupTextures() {
                const gl = this.gl;
                this.textures = [
                    createTexture(gl, this.width, this.height),
                    createTexture(gl, this.width, this.height)
                ];

                this.framebuffers = [
                    createFramebuffer(gl, this.textures[0]),
                    createFramebuffer(gl, this.textures[1])
                ];
            }

            initialize() {
                const data = new Float32Array(this.width * this.height * 4);

                // Initialize with A=1, B=0
                for (let i = 0; i < this.width * this.height; i++) {
                    data[i * 4] = 1.0;     // A
                    data[i * 4 + 1] = 0.0; // B
                    data[i * 4 + 2] = 0.0;
                    data[i * 4 + 3] = 1.0;
                }

                // Add random seeds
                const numSeeds = 50;
                for (let i = 0; i < numSeeds; i++) {
                    const x = Math.floor(Math.random() * this.width);
                    const y = Math.floor(Math.random() * this.height);
                    const radius = 5;

                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            if (dx * dx + dy * dy <= radius * radius) {
                                const px = (x + dx + this.width) % this.width;
                                const py = (y + dy + this.height) % this.height;
                                const idx = (py * this.width + px) * 4;
                                data[idx] = 0.0;
                                data[idx + 1] = 1.0;
                            }
                        }
                    }
                }

                const gl = this.gl;
                gl.bindTexture(gl.TEXTURE_2D, this.textures[0]);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.FLOAT, data);
                gl.bindTexture(gl.TEXTURE_2D, this.textures[1]);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.FLOAT, data);
            }

            addChemical(x, y, radius) {
                const gl = this.gl;

                // Read current state
                const data = new Float32Array(this.width * this.height * 4);
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[this.currentFB]);
                gl.readPixels(0, 0, this.width, this.height, gl.RGBA, gl.FLOAT, data);

                // Add chemical B in circular region
                const px = Math.floor(x * this.width);
                const py = Math.floor((1.0 - y) * this.height);

                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        if (dx * dx + dy * dy <= radius * radius) {
                            const ix = (px + dx + this.width) % this.width;
                            const iy = (py + dy + this.height) % this.height;
                            const idx = (iy * this.width + ix) * 4;
                            data[idx] = 0.0;
                            data[idx + 1] = 1.0;
                        }
                    }
                }

                // Update texture
                gl.bindTexture(gl.TEXTURE_2D, this.textures[this.currentFB]);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.FLOAT, data);
            }

            step() {
                if (this.paused) return;

                const gl = this.gl;

                // Reaction-diffusion step
                gl.useProgram(this.reactionProgram);
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[1 - this.currentFB]);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.textures[this.currentFB]);

                const posLoc = gl.getAttribLocation(this.reactionProgram, 'a_position');
                gl.enableVertexAttribArray(posLoc);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

                gl.uniform1i(gl.getUniformLocation(this.reactionProgram, 'u_state'), 0);
                gl.uniform2f(gl.getUniformLocation(this.reactionProgram, 'u_resolution'), this.width, this.height);
                gl.uniform1f(gl.getUniformLocation(this.reactionProgram, 'u_feed'), this.params.feed);
                gl.uniform1f(gl.getUniformLocation(this.reactionProgram, 'u_kill'), this.params.kill);
                gl.uniform1f(gl.getUniformLocation(this.reactionProgram, 'u_diffA'), this.params.diffA);
                gl.uniform1f(gl.getUniformLocation(this.reactionProgram, 'u_diffB'), this.params.diffB);
                gl.uniform1f(gl.getUniformLocation(this.reactionProgram, 'u_dt'), this.params.dt);

                gl.viewport(0, 0, this.width, this.height);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                this.currentFB = 1 - this.currentFB;
            }

            render() {
                const gl = this.gl;

                // Render to screen
                gl.useProgram(this.renderProgram);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.textures[this.currentFB]);

                const posLoc = gl.getAttribLocation(this.renderProgram, 'a_position');
                gl.enableVertexAttribArray(posLoc);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

                gl.uniform1i(gl.getUniformLocation(this.renderProgram, 'u_state'), 0);
                gl.uniform1i(gl.getUniformLocation(this.renderProgram, 'u_colormap'), this.colormap);

                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }
        }

        // Initialize simulators
        const grayScottSim = new ReactionDiffusion(
            document.getElementById('grayScottCanvas'),
            512, 384
        );

        const interactiveSim = new ReactionDiffusion(
            document.getElementById('interactiveCanvas'),
            512, 384
        );

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;

                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

                tab.classList.add('active');
                document.getElementById(tabName).classList.add('active');
            });
        });

        // Presets
        const presets = {
            mitosis: { feed: 0.055, kill: 0.062 },
            coral: { feed: 0.039, kill: 0.058 },
            fingerprints: { feed: 0.025, kill: 0.056 },
            maze: { feed: 0.029, kill: 0.057 },
            spots: { feed: 0.014, kill: 0.054 },
            stripes: { feed: 0.035, kill: 0.065 }
        };

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = presets[btn.dataset.preset];
                grayScottSim.params.feed = preset.feed;
                grayScottSim.params.kill = preset.kill;

                document.getElementById('feedRate').value = preset.feed;
                document.getElementById('killRate').value = preset.kill;
                document.getElementById('feedValue').textContent = preset.feed.toFixed(3);
                document.getElementById('killValue').textContent = preset.kill.toFixed(3);

                grayScottSim.initialize();
            });
        });

        // Controls
        document.getElementById('feedRate').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            grayScottSim.params.feed = value;
            document.getElementById('feedValue').textContent = value.toFixed(3);
        });

        document.getElementById('killRate').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            grayScottSim.params.kill = value;
            document.getElementById('killValue').textContent = value.toFixed(3);
        });

        document.getElementById('diffA').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            grayScottSim.params.diffA = value;
            document.getElementById('diffAValue').textContent = value.toFixed(2);
        });

        document.getElementById('diffB').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            grayScottSim.params.diffB = value;
            document.getElementById('diffBValue').textContent = value.toFixed(2);
        });

        // Color maps
        const colormaps = { viridis: 0, plasma: 1, inferno: 2, thermal: 3, rainbow: 4 };

        document.querySelectorAll('.colormap-option').forEach(option => {
            option.addEventListener('click', () => {
                document.querySelectorAll('.colormap-option').forEach(o => o.classList.remove('active'));
                option.classList.add('active');
                grayScottSim.colormap = colormaps[option.dataset.colormap];
                interactiveSim.colormap = colormaps[option.dataset.colormap];
            });
        });

        // Buttons
        document.getElementById('resetBtn').addEventListener('click', () => {
            grayScottSim.initialize();
        });

        document.getElementById('pauseBtn').addEventListener('click', (e) => {
            grayScottSim.paused = !grayScottSim.paused;
            e.target.textContent = grayScottSim.paused ? 'Resume' : 'Pause';
        });

        document.getElementById('randomizeBtn').addEventListener('click', () => {
            grayScottSim.params.feed = 0.01 + Math.random() * 0.09;
            grayScottSim.params.kill = 0.01 + Math.random() * 0.09;

            document.getElementById('feedRate').value = grayScottSim.params.feed;
            document.getElementById('killRate').value = grayScottSim.params.kill;
            document.getElementById('feedValue').textContent = grayScottSim.params.feed.toFixed(3);
            document.getElementById('killValue').textContent = grayScottSim.params.kill.toFixed(3);

            grayScottSim.initialize();
        });

        // Mouse interaction for Gray-Scott
        let isDrawing = false;

        document.getElementById('grayScottCanvas').addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = e.target.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            grayScottSim.addChemical(x, y, 15);
        });

        document.getElementById('grayScottCanvas').addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const rect = e.target.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            grayScottSim.addChemical(x, y, 15);
        });

        document.getElementById('grayScottCanvas').addEventListener('mouseup', () => {
            isDrawing = false;
        });

        document.getElementById('grayScottCanvas').addEventListener('mouseleave', () => {
            isDrawing = false;
        });

        // Interactive tab controls
        let brushSize = 30;
        let drawMode = true; // true = add B, false = remove B

        document.getElementById('brushSize').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushValue').textContent = brushSize;
        });

        document.getElementById('clearInteractiveBtn').addEventListener('click', () => {
            interactiveSim.initialize();
        });

        document.getElementById('pauseInteractiveBtn').addEventListener('click', (e) => {
            interactiveSim.paused = !interactiveSim.paused;
            e.target.textContent = interactiveSim.paused ? 'Resume' : 'Pause';
        });

        document.getElementById('drawModeBtn').addEventListener('click', (e) => {
            drawMode = !drawMode;
            e.target.textContent = drawMode ? 'Draw Mode: Add B' : 'Draw Mode: Remove B';
        });

        // Interactive canvas mouse events
        let isDrawingInteractive = false;

        document.getElementById('interactiveCanvas').addEventListener('mousedown', (e) => {
            isDrawingInteractive = true;
            const rect = e.target.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            interactiveSim.addChemical(x, y, brushSize / 2);
        });

        document.getElementById('interactiveCanvas').addEventListener('mousemove', (e) => {
            if (!isDrawingInteractive) return;
            const rect = e.target.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            interactiveSim.addChemical(x, y, brushSize / 2);
        });

        document.getElementById('interactiveCanvas').addEventListener('mouseup', () => {
            isDrawingInteractive = false;
        });

        document.getElementById('interactiveCanvas').addEventListener('mouseleave', () => {
            isDrawingInteractive = false;
        });

        // Parameter Space Grid
        const paramCanvas = document.getElementById('parameterCanvas');
        const paramCtx = paramCanvas.getContext('2d');
        let paramGridData = null;
        const gridSize = 8;
        const cellWidth = paramCanvas.width / gridSize;
        const cellHeight = paramCanvas.height / gridSize;

        function generateParameterGrid() {
            const tempCanvas = document.createElement('canvas');
            const gridSims = [];
            const simSize = 64;

            paramGridData = [];

            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const feed = 0.01 + (i / gridSize) * 0.09;
                    const kill = 0.01 + (j / gridSize) * 0.09;

                    paramGridData.push({ feed, kill, x: i, y: j });

                    tempCanvas.width = simSize;
                    tempCanvas.height = simSize;
                    const sim = new ReactionDiffusion(tempCanvas, simSize, simSize);
                    sim.params.feed = feed;
                    sim.params.kill = kill;
                    gridSims.push({ sim, x: i, y: j });
                }
            }

            // Run simulations
            let steps = 0;
            const maxSteps = 2000;

            function stepGrid() {
                if (steps < maxSteps) {
                    gridSims.forEach(({ sim }) => {
                        sim.step();
                        if (steps % 10 === 0) sim.render();
                    });
                    steps++;
                    requestAnimationFrame(stepGrid);
                } else {
                    // Draw final result
                    gridSims.forEach(({ sim, x, y }) => {
                        sim.render();
                        paramCtx.drawImage(
                            sim.canvas,
                            x * cellWidth,
                            y * cellHeight,
                            cellWidth,
                            cellHeight
                        );
                    });

                    // Draw grid lines
                    paramCtx.strokeStyle = '#1e293b';
                    paramCtx.lineWidth = 2;
                    for (let i = 0; i <= gridSize; i++) {
                        paramCtx.beginPath();
                        paramCtx.moveTo(i * cellWidth, 0);
                        paramCtx.lineTo(i * cellWidth, paramCanvas.height);
                        paramCtx.stroke();

                        paramCtx.beginPath();
                        paramCtx.moveTo(0, i * cellHeight);
                        paramCtx.lineTo(paramCanvas.width, i * cellHeight);
                        paramCtx.stroke();
                    }
                }
            }

            stepGrid();
        }

        document.getElementById('generateGridBtn').addEventListener('click', generateParameterGrid);

        document.getElementById('resetGridBtn').addEventListener('click', () => {
            paramCtx.fillStyle = '#0a0e1a';
            paramCtx.fillRect(0, 0, paramCanvas.width, paramCanvas.height);
            paramGridData = null;
        });

        paramCanvas.addEventListener('click', (e) => {
            if (!paramGridData) return;

            const rect = paramCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / rect.width * gridSize);
            const y = Math.floor((e.clientY - rect.top) / rect.height * gridSize);

            const cell = paramGridData.find(d => d.x === x && d.y === y);
            if (cell) {
                grayScottSim.params.feed = cell.feed;
                grayScottSim.params.kill = cell.kill;

                document.getElementById('feedRate').value = cell.feed;
                document.getElementById('killRate').value = cell.kill;
                document.getElementById('feedValue').textContent = cell.feed.toFixed(3);
                document.getElementById('killValue').textContent = cell.kill.toFixed(3);

                grayScottSim.initialize();

                // Switch to Gray-Scott tab
                document.querySelector('.tab[data-tab="gray-scott"]').click();
            }
        });

        // Animation loop
        function animate() {
            // Update simulations (multiple steps per frame for speed)
            for (let i = 0; i < 4; i++) {
                grayScottSim.step();
                interactiveSim.step();
            }

            grayScottSim.render();
            interactiveSim.render();

            requestAnimationFrame(animate);
        }

        animate();

        // Touch support
        function addTouchSupport(canvas, simulator, radiusFn) {
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const x = (touch.clientX - rect.left) / rect.width;
                const y = (touch.clientY - rect.top) / rect.height;
                simulator.addChemical(x, y, radiusFn());
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const x = (touch.clientX - rect.left) / rect.width;
                const y = (touch.clientY - rect.top) / rect.height;
                simulator.addChemical(x, y, radiusFn());
            });
        }

        addTouchSupport(document.getElementById('grayScottCanvas'), grayScottSim, () => 15);
        addTouchSupport(document.getElementById('interactiveCanvas'), interactiveSim, () => brushSize / 2);
    </script>
</body>
</html>