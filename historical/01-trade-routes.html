<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trade Route Emergence | Historical Simulations</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(217, 119, 6, 0.3);
        }
        h1 { color: #d97706; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"], select { width: 100%; }
        .value { float: right; color: #d97706; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #d97706; color: white;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #f59e0b; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #d97706; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #d97706; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        .legend {
            display: flex; gap: 15px; flex-wrap: wrap;
            margin-top: 10px; font-size: 0.8em;
        }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 12px; height: 12px; border-radius: 50%; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Historical</a>

    <div class="controls">
        <h1>Trade Route Emergence</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Network formation simulation</p>

        <div class="control-group">
            <label>Number of Settlements: <span class="value" id="settlementsValue">8</span></label>
            <input type="range" id="settlements" min="4" max="20" value="8">
        </div>

        <div class="control-group">
            <label>Resource Types: <span class="value" id="resourcesValue">4</span></label>
            <input type="range" id="resources" min="2" max="8" value="4">
        </div>

        <div class="control-group">
            <label>Terrain Difficulty: <span class="value" id="terrainValue">0.5</span></label>
            <input type="range" id="terrain" min="0" max="1" step="0.1" value="0.5">
        </div>

        <div class="control-group">
            <label>Trade Threshold: <span class="value" id="thresholdValue">0.3</span></label>
            <input type="range" id="threshold" min="0.1" max="0.8" step="0.1" value="0.3">
        </div>

        <button id="regenerateBtn">Generate New Map</button>
        <button id="evolveBtn">Evolve Trade Routes</button>
        <button id="stepBtn" style="background:#444">Single Step</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Active Routes</span>
                <span class="stat-value" id="routeCount">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Total Trade Volume</span>
                <span class="stat-value" id="tradeVolume">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Network Density</span>
                <span class="stat-value" id="density">0%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Simulation Step</span>
                <span class="stat-value" id="stepCount">0</span>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item"><div class="legend-color" style="background:#ef4444"></div>Grain</div>
            <div class="legend-item"><div class="legend-color" style="background:#3b82f6"></div>Metal</div>
            <div class="legend-item"><div class="legend-color" style="background:#22c55e"></div>Spice</div>
            <div class="legend-item"><div class="legend-color" style="background:#a855f7"></div>Cloth</div>
        </div>

        <div class="info">
            <strong>Trade routes</strong> emerge between settlements with complementary resources.<br>
            <strong>Terrain</strong> affects route cost. Routes optimize over time.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        let numSettlements = 8;
        let numResources = 4;
        let terrainDifficulty = 0.5;
        let tradeThreshold = 0.3;
        let settlements = [];
        let routes = [];
        let terrain = [];
        let stepCount = 0;
        let evolving = false;

        const resourceNames = ['Grain', 'Metal', 'Spice', 'Cloth', 'Wood', 'Stone', 'Salt', 'Gold'];
        const resourceColors = ['#ef4444', '#3b82f6', '#22c55e', '#a855f7', '#84cc16', '#6b7280', '#f472b6', '#fbbf24'];

        const mapWidth = 800;
        const mapHeight = 600;

        function generateTerrain() {
            terrain = [];
            const resolution = 20;

            // Simple Perlin-like noise using multiple sine waves
            for (let x = 0; x < mapWidth; x += resolution) {
                for (let y = 0; y < mapHeight; y += resolution) {
                    let difficulty = 0;
                    difficulty += Math.sin(x * 0.01) * 0.3;
                    difficulty += Math.sin(y * 0.015) * 0.3;
                    difficulty += Math.sin((x + y) * 0.008) * 0.2;
                    difficulty += Math.random() * 0.2;
                    difficulty = (difficulty + 1) * 0.5 * terrainDifficulty;
                    terrain.push({ x, y, difficulty: Math.max(0.1, Math.min(1, difficulty)) });
                }
            }
        }

        function generateSettlements() {
            settlements = [];
            const margin = 80;
            const minDist = 100;

            for (let i = 0; i < numSettlements; i++) {
                let attempts = 0;
                let x, y, valid;

                do {
                    x = margin + Math.random() * (mapWidth - 2 * margin);
                    y = margin + Math.random() * (mapHeight - 2 * margin);
                    valid = true;

                    for (const s of settlements) {
                        const dist = Math.sqrt(Math.pow(x - s.x, 2) + Math.pow(y - s.y, 2));
                        if (dist < minDist) {
                            valid = false;
                            break;
                        }
                    }
                    attempts++;
                } while (!valid && attempts < 100);

                // Assign resources - each settlement produces some and needs others
                const produces = [];
                const needs = [];
                const numProduces = 1 + Math.floor(Math.random() * 2);

                for (let j = 0; j < numProduces; j++) {
                    let r;
                    do {
                        r = Math.floor(Math.random() * numResources);
                    } while (produces.includes(r));
                    produces.push(r);
                }

                for (let j = 0; j < numResources; j++) {
                    if (!produces.includes(j) && Math.random() > 0.5) {
                        needs.push(j);
                    }
                }

                settlements.push({
                    id: i,
                    x, y,
                    name: `City ${i + 1}`,
                    produces,
                    needs,
                    wealth: 100,
                    population: 100 + Math.floor(Math.random() * 400)
                });
            }
        }

        function calculateRouteCost(s1, s2) {
            const dx = s2.x - s1.x;
            const dy = s2.y - s1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Sample terrain along route
            let totalDifficulty = 0;
            const steps = Math.ceil(dist / 20);

            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const px = s1.x + dx * t;
                const py = s1.y + dy * t;

                // Find nearest terrain cell
                let minDist = Infinity;
                let terrainDiff = 0.5;
                for (const cell of terrain) {
                    const d = Math.sqrt(Math.pow(px - cell.x, 2) + Math.pow(py - cell.y, 2));
                    if (d < minDist) {
                        minDist = d;
                        terrainDiff = cell.difficulty;
                    }
                }
                totalDifficulty += terrainDiff;
            }

            return dist * (1 + totalDifficulty / steps);
        }

        function calculateTradeValue(s1, s2) {
            // Trade value based on complementary resources
            let value = 0;

            for (const r of s1.produces) {
                if (s2.needs.includes(r)) {
                    value += 10;
                }
            }

            for (const r of s2.produces) {
                if (s1.needs.includes(r)) {
                    value += 10;
                }
            }

            // Population bonus
            value *= Math.sqrt(s1.population * s2.population) / 200;

            return value;
        }

        function initializeRoutes() {
            routes = [];

            for (let i = 0; i < settlements.length; i++) {
                for (let j = i + 1; j < settlements.length; j++) {
                    const s1 = settlements[i];
                    const s2 = settlements[j];
                    const cost = calculateRouteCost(s1, s2);
                    const value = calculateTradeValue(s1, s2);

                    if (value > 0) {
                        routes.push({
                            from: i,
                            to: j,
                            cost,
                            value,
                            volume: 0,
                            active: false
                        });
                    }
                }
            }
        }

        function evolveStep() {
            stepCount++;

            // Evaluate and activate profitable routes
            for (const route of routes) {
                const profitability = route.value / route.cost;

                if (!route.active && profitability > tradeThreshold) {
                    route.active = true;
                    route.volume = route.value;
                } else if (route.active) {
                    // Existing routes grow or shrink
                    if (profitability > tradeThreshold) {
                        route.volume = Math.min(route.volume * 1.1, route.value * 2);
                    } else {
                        route.volume *= 0.9;
                        if (route.volume < 1) {
                            route.active = false;
                            route.volume = 0;
                        }
                    }
                }
            }

            // Update settlement wealth based on trade
            for (const settlement of settlements) {
                let tradeIncome = 0;
                for (const route of routes) {
                    if (route.active && (route.from === settlement.id || route.to === settlement.id)) {
                        tradeIncome += route.volume * 0.1;
                    }
                }
                settlement.wealth += tradeIncome;
                settlement.population = Math.max(50, settlement.population + (tradeIncome > 5 ? 2 : -1));
            }

            updateStats();
        }

        function updateStats() {
            const activeRoutes = routes.filter(r => r.active).length;
            const totalVolume = routes.reduce((sum, r) => sum + r.volume, 0);
            const maxRoutes = (numSettlements * (numSettlements - 1)) / 2;
            const density = ((activeRoutes / maxRoutes) * 100).toFixed(1);

            document.getElementById('routeCount').textContent = activeRoutes;
            document.getElementById('tradeVolume').textContent = Math.floor(totalVolume);
            document.getElementById('density').textContent = density + '%';
            document.getElementById('stepCount').textContent = stepCount;
        }

        function getMapOffset() {
            return {
                x: (canvas.width - 350 - mapWidth) / 2,
                y: (canvas.height - mapHeight) / 2
            };
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const offset = getMapOffset();

            // Draw terrain
            const resolution = 20;
            for (const cell of terrain) {
                const brightness = Math.floor((1 - cell.difficulty) * 60 + 20);
                ctx.fillStyle = `rgb(${brightness}, ${brightness + 10}, ${brightness - 10})`;
                ctx.fillRect(offset.x + cell.x, offset.y + cell.y, resolution, resolution);
            }

            // Draw map border
            ctx.strokeStyle = '#d97706';
            ctx.lineWidth = 2;
            ctx.strokeRect(offset.x, offset.y, mapWidth, mapHeight);

            // Draw routes
            for (const route of routes) {
                if (!route.active) continue;

                const s1 = settlements[route.from];
                const s2 = settlements[route.to];

                ctx.beginPath();
                ctx.moveTo(offset.x + s1.x, offset.y + s1.y);
                ctx.lineTo(offset.x + s2.x, offset.y + s2.y);

                const alpha = Math.min(1, route.volume / 50);
                const width = Math.max(1, Math.min(8, route.volume / 10));

                ctx.strokeStyle = `rgba(217, 119, 6, ${alpha})`;
                ctx.lineWidth = width;
                ctx.stroke();

                // Draw trade volume indicator
                const midX = (s1.x + s2.x) / 2;
                const midY = (s1.y + s2.y) / 2;
                ctx.fillStyle = 'rgba(217, 119, 6, 0.8)';
                ctx.beginPath();
                ctx.arc(offset.x + midX, offset.y + midY, width + 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw settlements
            for (const settlement of settlements) {
                const size = Math.max(15, Math.sqrt(settlement.population) / 2);

                // Settlement circle
                ctx.beginPath();
                ctx.arc(offset.x + settlement.x, offset.y + settlement.y, size, 0, Math.PI * 2);
                ctx.fillStyle = '#2d3748';
                ctx.fill();
                ctx.strokeStyle = '#d97706';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Resource indicators
                const numProduces = settlement.produces.length;
                settlement.produces.forEach((r, i) => {
                    const angle = (i / numProduces) * Math.PI * 2 - Math.PI / 2;
                    const rx = settlement.x + Math.cos(angle) * (size - 5);
                    const ry = settlement.y + Math.sin(angle) * (size - 5);

                    ctx.beginPath();
                    ctx.arc(offset.x + rx, offset.y + ry, 4, 0, Math.PI * 2);
                    ctx.fillStyle = resourceColors[r];
                    ctx.fill();
                });

                // Settlement name
                ctx.fillStyle = '#fff';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(settlement.name, offset.x + settlement.x, offset.y + settlement.y + size + 15);

                // Population
                ctx.fillStyle = '#888';
                ctx.font = '9px sans-serif';
                ctx.fillText(`Pop: ${settlement.population}`, offset.x + settlement.x, offset.y + settlement.y + size + 27);
            }

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Trade Route Emergence', canvas.width / 2 - 100, 35);

            if (evolving) {
                evolveStep();
            }

            requestAnimationFrame(draw);
        }

        function regenerate() {
            stepCount = 0;
            evolving = false;
            generateTerrain();
            generateSettlements();
            initializeRoutes();
            updateStats();
        }

        // Event listeners
        document.getElementById('settlements').oninput = (e) => {
            numSettlements = parseInt(e.target.value);
            document.getElementById('settlementsValue').textContent = numSettlements;
        };

        document.getElementById('resources').oninput = (e) => {
            numResources = parseInt(e.target.value);
            document.getElementById('resourcesValue').textContent = numResources;
        };

        document.getElementById('terrain').oninput = (e) => {
            terrainDifficulty = parseFloat(e.target.value);
            document.getElementById('terrainValue').textContent = terrainDifficulty.toFixed(1);
        };

        document.getElementById('threshold').oninput = (e) => {
            tradeThreshold = parseFloat(e.target.value);
            document.getElementById('thresholdValue').textContent = tradeThreshold.toFixed(1);
        };

        document.getElementById('regenerateBtn').onclick = regenerate;

        document.getElementById('evolveBtn').onclick = () => {
            evolving = !evolving;
            document.getElementById('evolveBtn').textContent = evolving ? 'Stop Evolution' : 'Evolve Trade Routes';
        };

        document.getElementById('stepBtn').onclick = () => {
            evolving = false;
            evolveStep();
        };

        // Initialize
        regenerate();
        draw();
    </script>
</body>
</html>
