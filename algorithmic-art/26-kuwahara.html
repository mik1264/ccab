<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kuwahara Painterly Filter - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #1a1520 0%, #2d1f35 50%, #1a1520 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10000;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #BC6C25;
            text-decoration: none;
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: rgba(254, 250, 224, 0.95);
            border-radius: 20px;
            border: 2px solid rgba(138, 154, 91, 0.3);
            transition: all 0.3s ease;
        }

        .organic-back-link:hover {
            background: rgba(254, 250, 224, 1);
            transform: translateX(-5px);
        }

        .container {
            max-width: 1200px;
            margin: 60px auto 0;
        }

        h1 {
            text-align: center;
            font-size: 2rem;
            margin-bottom: 0.5rem;
            color: #e8a87c;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 1.5rem;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .canvas-panel h4 {
            color: #e8a87c;
            margin-bottom: 10px;
        }

        canvas {
            border: 2px solid rgba(232, 168, 124, 0.3);
            border-radius: 8px;
            max-width: 100%;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 20px;
        }

        .panel h3 {
            color: #e8a87c;
            margin-bottom: 15px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            color: #aaa;
            font-size: 0.85rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        .control-group span {
            color: #e8a87c;
            font-size: 0.9rem;
        }

        select {
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #e0e0e0;
            font-family: inherit;
            cursor: pointer;
        }

        .buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #e8a87c, #c77c4a);
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(232, 168, 124, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .progress {
            margin-top: 15px;
            color: #888;
            font-size: 0.9rem;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
        }

        .info-panel h4 {
            color: #e8a87c;
            margin-bottom: 10px;
        }

        .info-panel p {
            font-size: 0.9rem;
            line-height: 1.6;
            color: #aaa;
            margin-bottom: 10px;
        }

        .quadrant-diagram {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            width: 100px;
            height: 100px;
            margin: 15px auto;
        }

        .quadrant {
            background: rgba(232, 168, 124, 0.3);
            border: 1px solid #e8a87c;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            color: #e8a87c;
        }

        @media (max-width: 800px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link">‚Üê Back to Gallery</a>

    <div class="container">
        <h1>Kuwahara Painterly Filter</h1>
        <p class="subtitle">Edge-preserving smoothing for artistic abstraction</p>

        <div class="main-grid">
            <div class="canvas-panel">
                <h4>Original Image</h4>
                <canvas id="sourceCanvas" width="400" height="400"></canvas>
            </div>
            <div class="canvas-panel">
                <h4>Kuwahara Filtered</h4>
                <canvas id="outputCanvas" width="400" height="400"></canvas>
            </div>
        </div>

        <div class="panel">
            <h3>Filter Controls</h3>
            <div class="controls">
                <div class="control-group">
                    <label>Kernel Size: <span id="kernelVal">5</span></label>
                    <input type="range" id="kernelSize" min="3" max="15" step="2" value="5">
                </div>

                <div class="control-group">
                    <label>Iterations: <span id="iterVal">1</span></label>
                    <input type="range" id="iterations" min="1" max="5" step="1" value="1">
                </div>

                <div class="control-group">
                    <label>Variance Blend: <span id="blendVal">0.0</span></label>
                    <input type="range" id="varBlend" min="0" max="1" step="0.1" value="0">
                </div>

                <div class="control-group">
                    <label>Source Image</label>
                    <select id="sourceImage">
                        <option value="gradient">Color Gradient</option>
                        <option value="landscape">Landscape Pattern</option>
                        <option value="portrait">Portrait Pattern</option>
                        <option value="flowers">Flowers Pattern</option>
                        <option value="noise">Noise + Shapes</option>
                    </select>
                </div>
            </div>

            <div class="buttons">
                <button onclick="applyFilter()" id="applyBtn">Apply Kuwahara Filter</button>
                <button onclick="generateSource()">New Source Image</button>
                <button onclick="applyMultiple(3)">Apply 3x</button>
                <button onclick="applyMultiple(5)">Apply 5x</button>
            </div>

            <div class="progress" id="progress">Ready to filter</div>
        </div>

        <div class="info-panel">
            <h4>How the Kuwahara Filter Works</h4>
            <p>
                The Kuwahara filter is a non-linear smoothing filter that preserves edges while
                reducing noise. Named after Michiyoshi Kuwahara, it was developed for medical
                imaging but is now widely used for artistic effects.
            </p>

            <div class="quadrant-diagram">
                <div class="quadrant">Q1</div>
                <div class="quadrant">Q2</div>
                <div class="quadrant">Q3</div>
                <div class="quadrant">Q4</div>
            </div>

            <p>
                For each pixel, the filter divides the neighborhood into 4 overlapping quadrants.
                It calculates the mean and variance of each quadrant, then outputs the mean of
                the quadrant with the lowest variance (most uniform region).
            </p>
            <p>
                This produces a painterly effect: flat areas become smoother while edges remain sharp,
                similar to brush strokes in impressionist painting. The effect intensifies with
                larger kernel sizes and multiple iterations.
            </p>
        </div>
    </div>

    <script>
        const sourceCanvas = document.getElementById('sourceCanvas');
        const outputCanvas = document.getElementById('outputCanvas');
        const srcCtx = sourceCanvas.getContext('2d');
        const outCtx = outputCanvas.getContext('2d');

        let kernelSize = 5;
        let iterations = 1;
        let varianceBlend = 0;
        let sourceType = 'gradient';

        // Generate procedural source images
        function generateSource() {
            const width = sourceCanvas.width;
            const height = sourceCanvas.height;
            const imageData = srcCtx.createImageData(width, height);
            const data = imageData.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    let r, g, b;

                    switch (sourceType) {
                        case 'gradient':
                            // Colorful gradient with shapes
                            r = Math.sin(x * 0.03) * 127 + 128;
                            g = Math.sin(y * 0.03 + 1) * 127 + 128;
                            b = Math.sin((x + y) * 0.02) * 127 + 128;

                            // Add some circles
                            const dist1 = Math.sqrt((x - 100) ** 2 + (y - 100) ** 2);
                            const dist2 = Math.sqrt((x - 300) ** 2 + (y - 300) ** 2);
                            if (dist1 < 80) { r = 255; g *= 0.5; b *= 0.5; }
                            if (dist2 < 60) { r *= 0.5; g = 255; b *= 0.5; }
                            break;

                        case 'landscape':
                            // Sky and ground with sun
                            if (y < height * 0.6) {
                                // Sky gradient
                                const skyT = y / (height * 0.6);
                                r = 135 + skyT * 50;
                                g = 206 - skyT * 50;
                                b = 250 - skyT * 30;

                                // Sun
                                const sunDist = Math.sqrt((x - 320) ** 2 + (y - 80) ** 2);
                                if (sunDist < 40) {
                                    r = 255;
                                    g = 220;
                                    b = 100;
                                }
                            } else {
                                // Ground
                                const groundNoise = Math.sin(x * 0.1) * 20 + Math.sin(y * 0.15) * 15;
                                r = 34 + groundNoise;
                                g = 139 + groundNoise;
                                b = 34 + groundNoise * 0.5;
                            }
                            break;

                        case 'portrait':
                            // Abstract face-like pattern
                            const cx = width / 2;
                            const cy = height / 2;
                            const faceDist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);

                            if (faceDist < 150) {
                                // Face
                                r = 255 - faceDist * 0.3;
                                g = 220 - faceDist * 0.3;
                                b = 180 - faceDist * 0.2;

                                // Eyes
                                const leftEyeDist = Math.sqrt((x - cx + 50) ** 2 + (y - cy + 30) ** 2);
                                const rightEyeDist = Math.sqrt((x - cx - 50) ** 2 + (y - cy + 30) ** 2);
                                if (leftEyeDist < 20 || rightEyeDist < 20) {
                                    r = 50; g = 100; b = 150;
                                }

                                // Mouth
                                if (y > cy + 40 && y < cy + 60 && Math.abs(x - cx) < 40) {
                                    r = 200; g = 100; b = 100;
                                }
                            } else {
                                r = 100 + Math.sin(x * 0.05) * 30;
                                g = 80 + Math.sin(y * 0.05) * 30;
                                b = 120;
                            }
                            break;

                        case 'flowers':
                            // Flower garden pattern
                            r = 50 + Math.sin(y * 0.1) * 20;
                            g = 100 + Math.sin(x * 0.1) * 30;
                            b = 50;

                            // Draw flowers at grid positions
                            for (let fx = 50; fx < width; fx += 100) {
                                for (let fy = 50; fy < height; fy += 100) {
                                    const flowerDist = Math.sqrt((x - fx) ** 2 + (y - fy) ** 2);
                                    const angle = Math.atan2(y - fy, x - fx);
                                    const petal = Math.cos(angle * 5) * 15 + 25;

                                    if (flowerDist < petal) {
                                        const hue = (fx + fy) * 0.5;
                                        r = 200 + Math.sin(hue * 0.1) * 55;
                                        g = 100 + Math.cos(hue * 0.1) * 50;
                                        b = 150 + Math.sin(hue * 0.15) * 50;
                                    }
                                    if (flowerDist < 8) {
                                        r = 255; g = 200; b = 50;
                                    }
                                }
                            }
                            break;

                        case 'noise':
                            // Noise with geometric shapes
                            r = Math.random() * 50 + 100;
                            g = Math.random() * 50 + 100;
                            b = Math.random() * 50 + 100;

                            // Triangle
                            if (y > 50 && y < 200 && x > 50 + (y - 50) * 0.5 && x < 200 - (y - 50) * 0.5) {
                                r = 220; g = 50; b = 50;
                            }

                            // Rectangle
                            if (x > 220 && x < 350 && y > 100 && y < 250) {
                                r = 50; g = 50; b = 220;
                            }

                            // Circle
                            const circDist = Math.sqrt((x - 150) ** 2 + (y - 320) ** 2);
                            if (circDist < 60) {
                                r = 50; g = 200; b = 50;
                            }
                            break;
                    }

                    data[idx] = Math.max(0, Math.min(255, r));
                    data[idx + 1] = Math.max(0, Math.min(255, g));
                    data[idx + 2] = Math.max(0, Math.min(255, b));
                    data[idx + 3] = 255;
                }
            }

            srcCtx.putImageData(imageData, 0, 0);
            outCtx.putImageData(imageData, 0, 0);
        }

        // Kuwahara filter implementation
        function kuwaharaFilter(inputData, outputData, width, height) {
            const input = inputData.data;
            const output = outputData.data;
            const halfKernel = Math.floor(kernelSize / 2);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;

                    // Define 4 overlapping quadrants
                    const quadrants = [
                        { x1: -halfKernel, x2: 0, y1: -halfKernel, y2: 0 }, // Top-left
                        { x1: 0, x2: halfKernel, y1: -halfKernel, y2: 0 }, // Top-right
                        { x1: -halfKernel, x2: 0, y1: 0, y2: halfKernel }, // Bottom-left
                        { x1: 0, x2: halfKernel, y1: 0, y2: halfKernel }  // Bottom-right
                    ];

                    let minVariance = Infinity;
                    let bestMean = [0, 0, 0];
                    const quadrantData = [];

                    for (const q of quadrants) {
                        let sumR = 0, sumG = 0, sumB = 0;
                        let sumR2 = 0, sumG2 = 0, sumB2 = 0;
                        let count = 0;

                        for (let ky = q.y1; ky <= q.y2; ky++) {
                            for (let kx = q.x1; kx <= q.x2; kx++) {
                                const px = Math.max(0, Math.min(width - 1, x + kx));
                                const py = Math.max(0, Math.min(height - 1, y + ky));
                                const pIdx = (py * width + px) * 4;

                                const r = input[pIdx];
                                const g = input[pIdx + 1];
                                const b = input[pIdx + 2];

                                sumR += r;
                                sumG += g;
                                sumB += b;
                                sumR2 += r * r;
                                sumG2 += g * g;
                                sumB2 += b * b;
                                count++;
                            }
                        }

                        if (count > 0) {
                            const meanR = sumR / count;
                            const meanG = sumG / count;
                            const meanB = sumB / count;

                            // Calculate variance (using luminance)
                            const varR = sumR2 / count - meanR * meanR;
                            const varG = sumG2 / count - meanG * meanG;
                            const varB = sumB2 / count - meanB * meanB;
                            const variance = 0.299 * varR + 0.587 * varG + 0.114 * varB;

                            quadrantData.push({ mean: [meanR, meanG, meanB], variance });

                            if (variance < minVariance) {
                                minVariance = variance;
                                bestMean = [meanR, meanG, meanB];
                            }
                        }
                    }

                    // Optional: blend based on variance weights
                    if (varianceBlend > 0 && quadrantData.length > 0) {
                        let totalWeight = 0;
                        let blendedR = 0, blendedG = 0, blendedB = 0;

                        for (const qd of quadrantData) {
                            const weight = 1 / (1 + qd.variance);
                            blendedR += qd.mean[0] * weight;
                            blendedG += qd.mean[1] * weight;
                            blendedB += qd.mean[2] * weight;
                            totalWeight += weight;
                        }

                        blendedR /= totalWeight;
                        blendedG /= totalWeight;
                        blendedB /= totalWeight;

                        output[idx] = bestMean[0] * (1 - varianceBlend) + blendedR * varianceBlend;
                        output[idx + 1] = bestMean[1] * (1 - varianceBlend) + blendedG * varianceBlend;
                        output[idx + 2] = bestMean[2] * (1 - varianceBlend) + blendedB * varianceBlend;
                    } else {
                        output[idx] = bestMean[0];
                        output[idx + 1] = bestMean[1];
                        output[idx + 2] = bestMean[2];
                    }
                    output[idx + 3] = 255;
                }
            }
        }

        function applyFilter() {
            const width = outputCanvas.width;
            const height = outputCanvas.height;

            document.getElementById('progress').textContent = 'Applying filter...';
            document.getElementById('applyBtn').disabled = true;

            // Use setTimeout to allow UI to update
            setTimeout(() => {
                let currentData = srcCtx.getImageData(0, 0, width, height);

                for (let i = 0; i < iterations; i++) {
                    const outputData = outCtx.createImageData(width, height);
                    kuwaharaFilter(currentData, outputData, width, height);
                    currentData = outputData;
                    document.getElementById('progress').textContent = `Iteration ${i + 1}/${iterations}`;
                }

                outCtx.putImageData(currentData, 0, 0);
                document.getElementById('progress').textContent = `Filter applied (kernel: ${kernelSize}, iterations: ${iterations})`;
                document.getElementById('applyBtn').disabled = false;
            }, 50);
        }

        function applyMultiple(count) {
            const originalIterations = iterations;
            iterations = count;
            applyFilter();
            iterations = originalIterations;
        }

        // Event listeners
        document.getElementById('kernelSize').addEventListener('input', function() {
            kernelSize = parseInt(this.value);
            document.getElementById('kernelVal').textContent = kernelSize;
        });

        document.getElementById('iterations').addEventListener('input', function() {
            iterations = parseInt(this.value);
            document.getElementById('iterVal').textContent = iterations;
        });

        document.getElementById('varBlend').addEventListener('input', function() {
            varianceBlend = parseFloat(this.value);
            document.getElementById('blendVal').textContent = varianceBlend.toFixed(1);
        });

        document.getElementById('sourceImage').addEventListener('change', function() {
            sourceType = this.value;
            generateSource();
        });

        // Initialize
        generateSource();
    </script>
</body>
</html>
