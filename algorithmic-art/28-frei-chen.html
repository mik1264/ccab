<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frei-Chen Edge Energy Visualizer - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a2632 50%, #0f1419 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10000;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #BC6C25;
            text-decoration: none;
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: rgba(254, 250, 224, 0.95);
            border-radius: 20px;
            transition: all 0.3s ease;
        }

        .organic-back-link:hover {
            background: rgba(254, 250, 224, 1);
            transform: translateX(-5px);
        }

        .container { max-width: 1400px; margin: 60px auto 0; }

        h1 {
            text-align: center;
            font-size: 2rem;
            margin-bottom: 0.5rem;
            color: #00ff88;
        }

        .subtitle { text-align: center; color: #888; margin-bottom: 1.5rem; }

        .grid-3x3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .canvas-panel {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            padding: 10px;
            border: 1px solid rgba(0, 255, 136, 0.2);
            text-align: center;
        }

        .canvas-panel h5 {
            color: #00ff88;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }

        canvas {
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 6px;
            width: 100%;
            height: auto;
        }

        .panel {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(0, 255, 136, 0.2);
            margin-bottom: 20px;
        }

        .panel h3 { color: #00ff88; margin-bottom: 15px; }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
        }

        .control-group { display: flex; flex-direction: column; gap: 5px; }
        .control-group label { color: #aaa; font-size: 0.85rem; }
        .control-group input[type="range"] { width: 100%; cursor: pointer; }
        .control-group span { color: #00ff88; }

        select {
            padding: 8px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 6px;
            color: #e0e0e0;
            font-family: inherit;
        }

        .buttons { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 15px; }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #00ff88, #00aa55);
            border: none;
            border-radius: 6px;
            color: #000;
            cursor: pointer;
            font-family: inherit;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.4);
        }

        .kernel-display {
            display: grid;
            grid-template-columns: repeat(3, 40px);
            gap: 2px;
            margin: 10px auto;
            width: fit-content;
        }

        .kernel-cell {
            width: 40px;
            height: 30px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            color: #00ff88;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
        }

        .info-panel h4 { color: #00ff88; margin-bottom: 10px; }
        .info-panel p { font-size: 0.9rem; line-height: 1.6; color: #aaa; margin-bottom: 10px; }

        @media (max-width: 900px) {
            .grid-3x3 { grid-template-columns: repeat(2, 1fr); }
        }

        @media (max-width: 600px) {
            .grid-3x3 { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link">← Back to Gallery</a>

    <div class="container">
        <h1>Frei-Chen Edge Energy Visualizer</h1>
        <p class="subtitle">9 basis kernels for complete edge analysis</p>

        <div class="grid-3x3">
            <div class="canvas-panel">
                <h5>Original</h5>
                <canvas id="sourceCanvas" width="200" height="200"></canvas>
            </div>
            <div class="canvas-panel">
                <h5>F1 - Edge (0°)</h5>
                <canvas id="f1Canvas" width="200" height="200"></canvas>
            </div>
            <div class="canvas-panel">
                <h5>F2 - Edge (90°)</h5>
                <canvas id="f2Canvas" width="200" height="200"></canvas>
            </div>
            <div class="canvas-panel">
                <h5>F3 - Edge (45°)</h5>
                <canvas id="f3Canvas" width="200" height="200"></canvas>
            </div>
            <div class="canvas-panel">
                <h5>F4 - Edge (135°)</h5>
                <canvas id="f4Canvas" width="200" height="200"></canvas>
            </div>
            <div class="canvas-panel">
                <h5>F5 - Line (0°)</h5>
                <canvas id="f5Canvas" width="200" height="200"></canvas>
            </div>
            <div class="canvas-panel">
                <h5>F6 - Line (45°)</h5>
                <canvas id="f6Canvas" width="200" height="200"></canvas>
            </div>
            <div class="canvas-panel">
                <h5>F7 - Discrete Laplacian</h5>
                <canvas id="f7Canvas" width="200" height="200"></canvas>
            </div>
            <div class="canvas-panel">
                <h5>Combined Edge Map</h5>
                <canvas id="combinedCanvas" width="200" height="200"></canvas>
            </div>
        </div>

        <div class="panel">
            <h3>Controls</h3>
            <div class="controls">
                <div class="control-group">
                    <label>Edge Threshold: <span id="threshVal">0.2</span></label>
                    <input type="range" id="threshold" min="0" max="1" step="0.05" value="0.2">
                </div>

                <div class="control-group">
                    <label>Edge Strength: <span id="strengthVal">1.0</span></label>
                    <input type="range" id="strength" min="0.5" max="3" step="0.1" value="1">
                </div>

                <div class="control-group">
                    <label>Source Image</label>
                    <select id="sourceImage">
                        <option value="shapes">Geometric Shapes</option>
                        <option value="checkerboard">Checkerboard</option>
                        <option value="gradient">Gradients</option>
                        <option value="text">Text Pattern</option>
                    </select>
                </div>
            </div>

            <div class="buttons">
                <button onclick="applyFreiChen()">Apply Frei-Chen</button>
                <button onclick="generateSource()">New Source</button>
            </div>
        </div>

        <div class="info-panel">
            <h4>About Frei-Chen Edge Detection</h4>
            <p>
                The Frei-Chen edge detection method uses 9 orthonormal basis kernels that form
                a complete basis for any 3×3 image patch. Unlike Sobel or Prewitt, Frei-Chen
                can decompose an image region into edge, line, and average components.
            </p>
            <p>
                <strong>Kernels F1-F4:</strong> Detect edges at 0°, 90°, 45°, and 135° orientations<br>
                <strong>Kernels F5-F6:</strong> Detect lines (ridges) at 0° and 45°<br>
                <strong>Kernels F7-F8:</strong> Discrete Laplacian (spot detection)<br>
                <strong>Kernel F9:</strong> Average (constant component)
            </p>
            <p>
                The edge energy is computed as the ratio of edge subspace energy to total energy,
                providing a normalized edge strength measure.
            </p>
        </div>
    </div>

    <script>
        const canvases = {
            source: document.getElementById('sourceCanvas'),
            f1: document.getElementById('f1Canvas'),
            f2: document.getElementById('f2Canvas'),
            f3: document.getElementById('f3Canvas'),
            f4: document.getElementById('f4Canvas'),
            f5: document.getElementById('f5Canvas'),
            f6: document.getElementById('f6Canvas'),
            f7: document.getElementById('f7Canvas'),
            combined: document.getElementById('combinedCanvas')
        };

        const contexts = {};
        for (const [key, canvas] of Object.entries(canvases)) {
            contexts[key] = canvas.getContext('2d');
        }

        // Frei-Chen kernels (normalized)
        const sqrt2 = Math.sqrt(2);
        const kernels = {
            // Edge detection kernels
            f1: [
                [1, sqrt2, 1],
                [0, 0, 0],
                [-1, -sqrt2, -1]
            ].map(row => row.map(v => v / (2 * sqrt2 + 2))),

            f2: [
                [1, 0, -1],
                [sqrt2, 0, -sqrt2],
                [1, 0, -1]
            ].map(row => row.map(v => v / (2 * sqrt2 + 2))),

            f3: [
                [0, -1, sqrt2],
                [1, 0, -1],
                [-sqrt2, 1, 0]
            ].map(row => row.map(v => v / (2 * sqrt2 + 2))),

            f4: [
                [sqrt2, -1, 0],
                [-1, 0, 1],
                [0, 1, -sqrt2]
            ].map(row => row.map(v => v / (2 * sqrt2 + 2))),

            // Line detection kernels
            f5: [
                [0, 1, 0],
                [-1, 0, -1],
                [0, 1, 0]
            ].map(row => row.map(v => v / 2)),

            f6: [
                [-1, 0, 1],
                [0, 0, 0],
                [1, 0, -1]
            ].map(row => row.map(v => v / 2)),

            // Discrete Laplacian (simplified)
            f7: [
                [1, -2, 1],
                [-2, 4, -2],
                [1, -2, 1]
            ].map(row => row.map(v => v / 6))
        };

        let threshold = 0.2;
        let strength = 1.0;
        let sourceType = 'shapes';

        function generateSource() {
            const width = canvases.source.width;
            const height = canvases.source.height;
            const ctx = contexts.source;
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    let gray = 200;

                    switch (sourceType) {
                        case 'shapes':
                            // Rectangle
                            if (x > 30 && x < 80 && y > 30 && y < 80) gray = 50;
                            // Circle
                            const d1 = Math.sqrt((x - 140) ** 2 + (y - 60) ** 2);
                            if (d1 < 40) gray = 80;
                            // Triangle
                            if (y > 100 && y < 180 && x > 20 + (y - 100) * 0.5 && x < 100 - (y - 100) * 0.5) gray = 30;
                            // Diagonal line
                            if (Math.abs(x - y - 20) < 3 && x > 100 && x < 180) gray = 20;
                            break;

                        case 'checkerboard':
                            const cx = Math.floor(x / 25);
                            const cy = Math.floor(y / 25);
                            gray = (cx + cy) % 2 === 0 ? 40 : 200;
                            break;

                        case 'gradient':
                            gray = x * 1.275;
                            // Add vertical bands
                            if (x % 50 < 5) gray = 50;
                            break;

                        case 'text':
                            // Simple text-like pattern
                            gray = 220;
                            const lx = x % 30;
                            const ly = y % 40;
                            if (ly > 10 && ly < 30 && lx > 5 && lx < 25) {
                                if ((ly < 15 || ly > 25) || (lx < 10 || lx > 20)) {
                                    gray = 30;
                                }
                            }
                            break;
                    }

                    data[idx] = gray;
                    data[idx + 1] = gray;
                    data[idx + 2] = gray;
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
            applyFreiChen();
        }

        function convolve(gray, width, height, kernel) {
            const result = new Float32Array(width * height);

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let sum = 0;

                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = (y + ky) * width + (x + kx);
                            sum += gray[idx] * kernel[ky + 1][kx + 1];
                        }
                    }

                    result[y * width + x] = sum;
                }
            }

            return result;
        }

        function drawResponse(canvas, response, colorize = false) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            // Find min/max for normalization
            let min = Infinity, max = -Infinity;
            for (let i = 0; i < response.length; i++) {
                min = Math.min(min, response[i]);
                max = Math.max(max, response[i]);
            }

            const range = max - min || 1;

            for (let i = 0; i < response.length; i++) {
                let val = ((response[i] - min) / range) * strength;
                val = Math.max(0, Math.min(1, val));

                if (val < threshold) val = 0;

                const byte = Math.floor(val * 255);

                if (colorize) {
                    // Color based on sign
                    const orig = response[i];
                    if (orig > 0) {
                        data[i * 4] = byte;
                        data[i * 4 + 1] = byte / 2;
                        data[i * 4 + 2] = 0;
                    } else {
                        data[i * 4] = 0;
                        data[i * 4 + 1] = byte / 2;
                        data[i * 4 + 2] = byte;
                    }
                } else {
                    data[i * 4] = byte;
                    data[i * 4 + 1] = byte;
                    data[i * 4 + 2] = byte;
                }
                data[i * 4 + 3] = 255;
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function applyFreiChen() {
            const width = canvases.source.width;
            const height = canvases.source.height;

            // Get grayscale
            const srcData = contexts.source.getImageData(0, 0, width, height).data;
            const gray = new Float32Array(width * height);
            for (let i = 0; i < gray.length; i++) {
                gray[i] = srcData[i * 4] / 255;
            }

            // Apply each kernel
            const responses = {};
            for (const [name, kernel] of Object.entries(kernels)) {
                responses[name] = convolve(gray, width, height, kernel);
            }

            // Draw individual responses
            drawResponse(canvases.f1, responses.f1);
            drawResponse(canvases.f2, responses.f2);
            drawResponse(canvases.f3, responses.f3);
            drawResponse(canvases.f4, responses.f4);
            drawResponse(canvases.f5, responses.f5);
            drawResponse(canvases.f6, responses.f6);
            drawResponse(canvases.f7, responses.f7);

            // Combine edge responses (F1-F4)
            const combined = new Float32Array(width * height);
            for (let i = 0; i < combined.length; i++) {
                const e1 = responses.f1[i];
                const e2 = responses.f2[i];
                const e3 = responses.f3[i];
                const e4 = responses.f4[i];

                // Edge energy: sqrt(sum of squared responses)
                combined[i] = Math.sqrt(e1 * e1 + e2 * e2 + e3 * e3 + e4 * e4);
            }

            drawResponse(canvases.combined, combined, true);
        }

        // Event listeners
        document.getElementById('threshold').addEventListener('input', function() {
            threshold = parseFloat(this.value);
            document.getElementById('threshVal').textContent = threshold.toFixed(2);
            applyFreiChen();
        });

        document.getElementById('strength').addEventListener('input', function() {
            strength = parseFloat(this.value);
            document.getElementById('strengthVal').textContent = strength.toFixed(1);
            applyFreiChen();
        });

        document.getElementById('sourceImage').addEventListener('change', function() {
            sourceType = this.value;
            generateSource();
        });

        // Initialize
        generateSource();
    </script>
</body>
</html>
