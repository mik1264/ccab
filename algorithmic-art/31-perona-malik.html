<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perona-Malik Anisotropic Diffusion - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #0a1520 0%, #152535 50%, #0a1520 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .organic-back-link {
            position: fixed; top: 20px; left: 20px; z-index: 10000;
            display: inline-flex; align-items: center; gap: 0.5rem;
            color: #BC6C25; text-decoration: none; font-weight: 600;
            padding: 0.5rem 1rem; background: rgba(254, 250, 224, 0.95);
            border-radius: 20px; transition: all 0.3s ease;
        }

        .organic-back-link:hover { background: rgba(254, 250, 224, 1); transform: translateX(-5px); }

        .container { max-width: 1200px; margin: 60px auto 0; }

        h1 { text-align: center; font-size: 2rem; margin-bottom: 0.5rem; color: #66ccaa; }
        .subtitle { text-align: center; color: #888; margin-bottom: 1.5rem; }

        .main-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;
        }

        .canvas-panel {
            background: rgba(255, 255, 255, 0.03); border-radius: 12px;
            padding: 15px; border: 1px solid rgba(102, 204, 170, 0.2); text-align: center;
        }

        .canvas-panel h4 { color: #66ccaa; margin-bottom: 10px; }

        canvas {
            border: 2px solid rgba(102, 204, 170, 0.3); border-radius: 8px;
            max-width: 100%;
        }

        .small-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px; }

        .panel {
            background: rgba(255, 255, 255, 0.03); border-radius: 12px;
            padding: 20px; border: 1px solid rgba(102, 204, 170, 0.2); margin-bottom: 20px;
        }

        .panel h3 { color: #66ccaa; margin-bottom: 15px; }

        .controls {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px;
        }

        .control-group { display: flex; flex-direction: column; gap: 5px; }
        .control-group label { color: #aaa; font-size: 0.85rem; }
        .control-group input[type="range"] { width: 100%; cursor: pointer; }
        .control-group span { color: #66ccaa; }

        select {
            padding: 8px; background: rgba(102, 204, 170, 0.1);
            border: 1px solid rgba(102, 204, 170, 0.3);
            border-radius: 6px; color: #e0e0e0; font-family: inherit;
        }

        .buttons { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 15px; }

        button {
            padding: 10px 20px; background: linear-gradient(135deg, #66ccaa, #449977);
            border: none; border-radius: 6px; color: white; cursor: pointer;
            font-family: inherit; transition: all 0.3s ease;
        }

        button:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(102, 204, 170, 0.4); }

        .equation {
            font-family: 'Times New Roman', serif; font-style: italic;
            color: #88ddbb; text-align: center; padding: 15px;
            background: rgba(0, 0, 0, 0.3); border-radius: 6px; margin: 10px 0;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.3); border-radius: 8px; padding: 15px;
        }

        .info-panel h4 { color: #66ccaa; margin-bottom: 10px; }
        .info-panel p { font-size: 0.9rem; line-height: 1.6; color: #aaa; margin-bottom: 10px; }

        @media (max-width: 800px) {
            .main-grid, .small-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link">← Back to Gallery</a>

    <div class="container">
        <h1>Perona-Malik Anisotropic Diffusion</h1>
        <p class="subtitle">Edge-preserving smoothing via nonlinear diffusion</p>

        <div class="main-grid">
            <div class="canvas-panel">
                <h4>Original (Noisy)</h4>
                <canvas id="sourceCanvas" width="300" height="300"></canvas>
            </div>
            <div class="canvas-panel">
                <h4>After Diffusion</h4>
                <canvas id="outputCanvas" width="300" height="300"></canvas>
            </div>
        </div>

        <div class="small-grid">
            <div class="canvas-panel">
                <h4>Diffusion Coefficient c(x,y)</h4>
                <canvas id="coeffCanvas" width="200" height="200"></canvas>
            </div>
            <div class="canvas-panel">
                <h4>Gradient Magnitude |∇I|</h4>
                <canvas id="gradCanvas" width="200" height="200"></canvas>
            </div>
        </div>

        <div class="panel">
            <h3>Diffusion Parameters</h3>
            <div class="controls">
                <div class="control-group">
                    <label>Kappa (κ): <span id="kappaVal">15</span></label>
                    <input type="range" id="kappa" min="5" max="50" value="15">
                </div>

                <div class="control-group">
                    <label>Time Step (dt): <span id="dtVal">0.15</span></label>
                    <input type="range" id="dt" min="0.05" max="0.25" step="0.01" value="0.15">
                </div>

                <div class="control-group">
                    <label>Iterations: <span id="iterVal">20</span></label>
                    <input type="range" id="iterations" min="1" max="100" value="20">
                </div>

                <div class="control-group">
                    <label>Noise Level: <span id="noiseVal">30</span></label>
                    <input type="range" id="noise" min="0" max="80" value="30">
                </div>

                <div class="control-group">
                    <label>Conductance Function</label>
                    <select id="conductance">
                        <option value="pm1">PM1: exp(-(|∇I|/κ)²)</option>
                        <option value="pm2">PM2: 1/(1+(|∇I|/κ)²)</option>
                        <option value="tukey">Tukey biweight</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Source Image</label>
                    <select id="sourceImage">
                        <option value="shapes">Geometric Shapes</option>
                        <option value="gradient">Gradient + Edges</option>
                        <option value="portrait">Portrait</option>
                    </select>
                </div>
            </div>

            <div class="equation">
                ∂I/∂t = div(c(x,y,t)·∇I) = c·ΔI + ∇c·∇I
            </div>

            <div class="buttons">
                <button onclick="applyDiffusion()">Apply Diffusion</button>
                <button onclick="stepDiffusion()">Single Step</button>
                <button onclick="generateSource()">New Source</button>
                <button onclick="toggleAnimation()">Animate</button>
            </div>
        </div>

        <div class="info-panel">
            <h4>About Perona-Malik Diffusion</h4>
            <p>
                Perona and Malik (1990) introduced anisotropic diffusion as a technique for
                edge-preserving smoothing. Unlike isotropic diffusion (Gaussian blur), this
                method adapts the diffusion rate based on local image gradients.
            </p>
            <p>
                <strong>Kappa (κ):</strong> Controls edge sensitivity. Higher values allow more
                diffusion across edges. Lower values preserve more edges but may leave noise.<br>
                <strong>Time Step (dt):</strong> Must be small (≤0.25) for stability.<br>
                <strong>Iterations:</strong> More iterations = more smoothing.
            </p>
            <p>
                The conductance function c(|∇I|) approaches 1 in flat regions (allowing diffusion)
                and approaches 0 at edges (stopping diffusion), creating edge-preserving behavior.
            </p>
        </div>
    </div>

    <script>
        const sourceCanvas = document.getElementById('sourceCanvas');
        const outputCanvas = document.getElementById('outputCanvas');
        const coeffCanvas = document.getElementById('coeffCanvas');
        const gradCanvas = document.getElementById('gradCanvas');

        const srcCtx = sourceCanvas.getContext('2d');
        const outCtx = outputCanvas.getContext('2d');
        const coeffCtx = coeffCanvas.getContext('2d');
        const gradCtx = gradCanvas.getContext('2d');

        let kappa = 15;
        let dt = 0.15;
        let iterations = 20;
        let noiseLevel = 30;
        let conductanceFunc = 'pm1';
        let sourceType = 'shapes';
        let animating = false;
        let currentImage = null;

        // Conductance functions
        const conductance = {
            pm1: (grad, k) => Math.exp(-Math.pow(grad / k, 2)),
            pm2: (grad, k) => 1 / (1 + Math.pow(grad / k, 2)),
            tukey: (grad, k) => grad < k ? Math.pow(1 - Math.pow(grad / k, 2), 2) : 0
        };

        function generateSource() {
            const width = sourceCanvas.width;
            const height = sourceCanvas.height;
            const imageData = srcCtx.createImageData(width, height);
            const data = imageData.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    let gray = 128;

                    switch (sourceType) {
                        case 'shapes':
                            gray = 200;
                            // Rectangle
                            if (x > 40 && x < 120 && y > 40 && y < 120) gray = 50;
                            // Circle
                            const d1 = Math.sqrt((x - 200) ** 2 + (y - 100) ** 2);
                            if (d1 < 50) gray = 80;
                            // Triangle
                            if (y > 150 && y < 260 && x > 30 + (y - 150) * 0.5 && x < 140 - (y - 150) * 0.5) gray = 30;
                            // Ellipse
                            const d2 = Math.sqrt(((x - 220) / 60) ** 2 + ((y - 220) / 30) ** 2);
                            if (d2 < 1) gray = 100;
                            break;

                        case 'gradient':
                            gray = x * 0.85;
                            // Add some step edges
                            if (x > 100 && x < 110) gray = 30;
                            if (x > 200 && x < 210) gray = 220;
                            break;

                        case 'portrait':
                            const cx = width / 2, cy = height / 2;
                            const fd = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                            if (fd < 120) {
                                gray = 220 - fd * 0.5;
                                const el = Math.sqrt((x - cx + 35) ** 2 + (y - cy + 25) ** 2);
                                const er = Math.sqrt((x - cx - 35) ** 2 + (y - cy + 25) ** 2);
                                if (el < 18 || er < 18) gray = 40;
                                if (y > cy + 30 && y < cy + 50 && Math.abs(x - cx) < 30) gray = 150;
                            } else {
                                gray = 240;
                            }
                            break;
                    }

                    // Add noise
                    gray += (Math.random() - 0.5) * noiseLevel * 2;
                    gray = Math.max(0, Math.min(255, gray));

                    data[idx] = data[idx + 1] = data[idx + 2] = gray;
                    data[idx + 3] = 255;
                }
            }

            srcCtx.putImageData(imageData, 0, 0);
            currentImage = new Float32Array(width * height);
            for (let i = 0; i < currentImage.length; i++) {
                currentImage[i] = data[i * 4];
            }

            updateOutput();
        }

        function computeGradient(image, width, height) {
            const gradX = new Float32Array(width * height);
            const gradY = new Float32Array(width * height);
            const gradMag = new Float32Array(width * height);

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    const dx = (image[idx + 1] - image[idx - 1]) / 2;
                    const dy = (image[idx + width] - image[idx - width]) / 2;
                    gradX[idx] = dx;
                    gradY[idx] = dy;
                    gradMag[idx] = Math.sqrt(dx * dx + dy * dy);
                }
            }

            return { gradX, gradY, gradMag };
        }

        function diffusionStep(image, width, height) {
            const { gradX, gradY, gradMag } = computeGradient(image, width, height);
            const newImage = new Float32Array(image);
            const cFunc = conductance[conductanceFunc];
            const coeffs = new Float32Array(width * height);

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;

                    // Compute conductance coefficients for neighbors
                    const cN = cFunc(gradMag[idx - width], kappa);
                    const cS = cFunc(gradMag[idx + width], kappa);
                    const cE = cFunc(gradMag[idx + 1], kappa);
                    const cW = cFunc(gradMag[idx - 1], kappa);

                    coeffs[idx] = (cN + cS + cE + cW) / 4;

                    // Compute differences
                    const dN = image[idx - width] - image[idx];
                    const dS = image[idx + width] - image[idx];
                    const dE = image[idx + 1] - image[idx];
                    const dW = image[idx - 1] - image[idx];

                    // Update
                    newImage[idx] = image[idx] + dt * (cN * dN + cS * dS + cE * dE + cW * dW);
                }
            }

            return { image: newImage, coeffs, gradMag };
        }

        function applyDiffusion() {
            const width = sourceCanvas.width;
            const height = sourceCanvas.height;

            // Reset from source
            const srcData = srcCtx.getImageData(0, 0, width, height).data;
            currentImage = new Float32Array(width * height);
            for (let i = 0; i < currentImage.length; i++) {
                currentImage[i] = srcData[i * 4];
            }

            let result;
            for (let i = 0; i < iterations; i++) {
                result = diffusionStep(currentImage, width, height);
                currentImage = result.image;
            }

            updateOutput();
            drawCoefficients(result.coeffs, width, height);
            drawGradient(result.gradMag, width, height);
        }

        function stepDiffusion() {
            const width = sourceCanvas.width;
            const height = sourceCanvas.height;

            if (!currentImage) {
                const srcData = srcCtx.getImageData(0, 0, width, height).data;
                currentImage = new Float32Array(width * height);
                for (let i = 0; i < currentImage.length; i++) {
                    currentImage[i] = srcData[i * 4];
                }
            }

            const result = diffusionStep(currentImage, width, height);
            currentImage = result.image;

            updateOutput();
            drawCoefficients(result.coeffs, width, height);
            drawGradient(result.gradMag, width, height);
        }

        function updateOutput() {
            const width = outputCanvas.width;
            const height = outputCanvas.height;
            const imageData = outCtx.createImageData(width, height);

            for (let i = 0; i < currentImage.length; i++) {
                const val = Math.max(0, Math.min(255, currentImage[i]));
                imageData.data[i * 4] = val;
                imageData.data[i * 4 + 1] = val;
                imageData.data[i * 4 + 2] = val;
                imageData.data[i * 4 + 3] = 255;
            }

            outCtx.putImageData(imageData, 0, 0);
        }

        function drawCoefficients(coeffs, srcW, srcH) {
            const width = coeffCanvas.width;
            const height = coeffCanvas.height;
            const scaleX = srcW / width;
            const scaleY = srcH / height;
            const imageData = coeffCtx.createImageData(width, height);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const srcX = Math.floor(x * scaleX);
                    const srcY = Math.floor(y * scaleY);
                    const srcIdx = srcY * srcW + srcX;
                    const val = Math.floor(coeffs[srcIdx] * 255);

                    const idx = (y * width + x) * 4;
                    imageData.data[idx] = val * 0.4;
                    imageData.data[idx + 1] = val;
                    imageData.data[idx + 2] = val * 0.6;
                    imageData.data[idx + 3] = 255;
                }
            }

            coeffCtx.putImageData(imageData, 0, 0);
        }

        function drawGradient(gradMag, srcW, srcH) {
            const width = gradCanvas.width;
            const height = gradCanvas.height;
            const scaleX = srcW / width;
            const scaleY = srcH / height;
            const imageData = gradCtx.createImageData(width, height);

            let maxGrad = 1;
            for (let i = 0; i < gradMag.length; i++) {
                if (gradMag[i] > maxGrad) maxGrad = gradMag[i];
            }

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const srcX = Math.floor(x * scaleX);
                    const srcY = Math.floor(y * scaleY);
                    const srcIdx = srcY * srcW + srcX;
                    const val = Math.floor((gradMag[srcIdx] / maxGrad) * 255);

                    const idx = (y * width + x) * 4;
                    imageData.data[idx] = val;
                    imageData.data[idx + 1] = val;
                    imageData.data[idx + 2] = val;
                    imageData.data[idx + 3] = 255;
                }
            }

            gradCtx.putImageData(imageData, 0, 0);
        }

        let animationId;
        function toggleAnimation() {
            if (animating) {
                animating = false;
                cancelAnimationFrame(animationId);
            } else {
                animating = true;
                animate();
            }
        }

        function animate() {
            if (!animating) return;
            stepDiffusion();
            animationId = requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('kappa').addEventListener('input', function() {
            kappa = parseInt(this.value);
            document.getElementById('kappaVal').textContent = kappa;
        });

        document.getElementById('dt').addEventListener('input', function() {
            dt = parseFloat(this.value);
            document.getElementById('dtVal').textContent = dt.toFixed(2);
        });

        document.getElementById('iterations').addEventListener('input', function() {
            iterations = parseInt(this.value);
            document.getElementById('iterVal').textContent = iterations;
        });

        document.getElementById('noise').addEventListener('input', function() {
            noiseLevel = parseInt(this.value);
            document.getElementById('noiseVal').textContent = noiseLevel;
        });

        document.getElementById('conductance').addEventListener('change', function() {
            conductanceFunc = this.value;
        });

        document.getElementById('sourceImage').addEventListener('change', function() {
            sourceType = this.value;
            generateSource();
        });

        // Initialize
        generateSource();
        applyDiffusion();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
