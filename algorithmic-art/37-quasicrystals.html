<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cut-and-Project Quasicrystals</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        .canvas-area {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        canvas {
            background: #000;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(78, 205, 196, 0.2);
        }
        h1 {
            color: #4ecdc4;
            font-size: 1.3rem;
            margin-bottom: 5px;
        }
        .subtitle {
            color: #888;
            font-size: 0.8rem;
            margin-bottom: 20px;
            line-height: 1.4;
        }
        .back-link {
            display: inline-block;
            color: #4ecdc4;
            text-decoration: none;
            margin-bottom: 15px;
            font-size: 0.85rem;
        }
        .back-link:hover {
            color: #ff6b6b;
        }
        .section {
            margin-bottom: 20px;
        }
        .section-header {
            color: #ff6b6b;
            font-size: 0.85rem;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(255, 107, 107, 0.3);
        }
        .control-group {
            margin-bottom: 12px;
        }
        .control-group label {
            display: block;
            color: #aaa;
            font-size: 0.75rem;
            margin-bottom: 4px;
        }
        .control-group input[type="range"] {
            width: 100%;
            accent-color: #4ecdc4;
        }
        .control-group select {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 0.85rem;
        }
        .button-row {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        button {
            flex: 1;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .checkbox-group label {
            color: #aaa;
            font-size: 0.8rem;
        }
        .info-box {
            background: rgba(78, 205, 196, 0.1);
            border-left: 3px solid #4ecdc4;
            padding: 12px;
            border-radius: 0 8px 8px 0;
            font-size: 0.75rem;
            color: #aaa;
            line-height: 1.5;
        }
        .stats {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            font-size: 0.75rem;
            margin-bottom: 15px;
        }
        .stats span {
            color: #4ecdc4;
        }
        .color-scheme {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        .color-btn {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            border: 2px solid transparent;
            cursor: pointer;
        }
        .color-btn.selected {
            border-color: #fff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <a href="index.html" class="back-link">← Back to Gallery</a>
            <h1>Cut-and-Project Quasicrystals</h1>
            <p class="subtitle">Generate quasiperiodic tilings by projecting higher-dimensional lattices</p>

            <div class="stats">
                Vertices: <span id="vertexCount">0</span> |
                Tiles: <span id="tileCount">0</span> |
                Symmetry: <span id="symmetryType">5-fold</span>
            </div>

            <div class="section">
                <div class="section-header">Symmetry Type</div>
                <div class="control-group">
                    <select id="symmetrySelect">
                        <option value="5">Penrose (5-fold, from 5D)</option>
                        <option value="8">Ammann-Beenker (8-fold, from 4D)</option>
                        <option value="10">Decagonal (10-fold, from 5D)</option>
                        <option value="12">Dodecagonal (12-fold, from 6D)</option>
                    </select>
                </div>
            </div>

            <div class="section">
                <div class="section-header">Projection Parameters</div>
                <div class="control-group">
                    <label>Projection Angle: <span id="angleValue">0.00</span>°</label>
                    <input type="range" id="angleSlider" min="-30" max="30" step="0.5" value="0">
                </div>
                <div class="control-group">
                    <label>Window Size: <span id="windowValue">1.00</span></label>
                    <input type="range" id="windowSlider" min="0.5" max="2" step="0.05" value="1">
                </div>
                <div class="control-group">
                    <label>Lattice Range: <span id="rangeValue">8</span></label>
                    <input type="range" id="rangeSlider" min="3" max="15" value="8">
                </div>
                <div class="control-group">
                    <label>Zoom: <span id="zoomValue">30</span></label>
                    <input type="range" id="zoomSlider" min="15" max="80" value="30">
                </div>
            </div>

            <div class="section">
                <div class="section-header">Visualization</div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showTiles" checked>
                    <label for="showTiles">Show Tiles</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showEdges" checked>
                    <label for="showEdges">Show Edges</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showVertices">
                    <label for="showVertices">Show Vertices</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="colorByType" checked>
                    <label for="colorByType">Color by Tile Type</label>
                </div>
            </div>

            <div class="section">
                <div class="section-header">Color Scheme</div>
                <div class="color-scheme" id="colorScheme"></div>
            </div>

            <div class="section">
                <div class="button-row">
                    <button id="regenerate">Regenerate</button>
                </div>
                <div class="button-row">
                    <button id="animate">Animate Angle</button>
                </div>
            </div>

            <div class="info-box">
                <strong>Cut-and-Project Method:</strong><br>
                Quasicrystals are generated by projecting a slice of a higher-dimensional periodic lattice onto a lower-dimensional space at an "irrational" angle.
                <br><br>
                The <strong>acceptance window</strong> determines which lattice points are included. Points whose perpendicular projection falls within this window are projected to form the tiling.
                <br><br>
                Unlike periodic crystals, quasicrystals never repeat but maintain long-range order, exhibiting forbidden symmetries like 5-fold or 12-fold.
            </div>
        </div>

        <div class="canvas-area">
            <canvas id="canvas" width="700" height="700"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;

        // Color schemes
        const colorSchemes = [
            ['#4ecdc4', '#ff6b6b', '#ffd93d', '#6c5ce7', '#a29bfe'],
            ['#00b894', '#0984e3', '#e17055', '#fdcb6e', '#d63031'],
            ['#2d3436', '#636e72', '#b2bec3', '#dfe6e9', '#74b9ff'],
            ['#fab1a0', '#81ecec', '#74b9ff', '#a29bfe', '#fd79a8'],
            ['#1a1a2e', '#16213e', '#0f3460', '#e94560', '#533483']
        ];

        let currentScheme = 0;
        let symmetry = 5;
        let projAngle = 0;
        let windowSize = 1;
        let latticeRange = 8;
        let zoom = 30;
        let showTiles = true;
        let showEdges = true;
        let showVertices = false;
        let colorByType = true;
        let isAnimating = false;
        let animationId = null;

        // Create color scheme buttons
        function createColorSchemeUI() {
            const container = document.getElementById('colorScheme');
            colorSchemes.forEach((scheme, i) => {
                const btn = document.createElement('div');
                btn.className = 'color-btn' + (i === 0 ? ' selected' : '');
                btn.style.background = `linear-gradient(135deg, ${scheme[0]}, ${scheme[1]})`;
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    currentScheme = i;
                    generateAndDraw();
                });
                container.appendChild(btn);
            });
        }

        // Golden ratio for Penrose
        const phi = (1 + Math.sqrt(5)) / 2;

        // Generate projection basis vectors for different symmetries
        function getBasisVectors(n) {
            const vectors = [];
            for (let i = 0; i < n; i++) {
                const angle = (2 * Math.PI * i) / n;
                vectors.push({
                    x: Math.cos(angle),
                    y: Math.sin(angle)
                });
            }
            return vectors;
        }

        // Project a point from nD to 2D
        function projectPoint(coords, basis, angleOffset = 0) {
            let x = 0, y = 0;

            for (let i = 0; i < coords.length; i++) {
                const angle = (2 * Math.PI * i) / basis.length + (angleOffset * Math.PI / 180);
                x += coords[i] * Math.cos(angle);
                y += coords[i] * Math.sin(angle);
            }

            return { x, y };
        }

        // Check if point is within acceptance window
        function inAcceptanceWindow(coords, perpBasis, windowSize) {
            // Project onto perpendicular space
            let perpDist = 0;
            const n = coords.length;

            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    // Perpendicular distance component
                    const diff = coords[i] - coords[j];
                    perpDist += diff * diff;
                }
            }

            perpDist = Math.sqrt(perpDist / n);

            // Acceptance window is typically a hypercube or rhombic shape
            return perpDist < windowSize * 2;
        }

        // Generate quasicrystal vertices
        function generateVertices() {
            const vertices = [];
            const vertexMap = new Map();
            const n = symmetry;
            const range = latticeRange;

            // For higher symmetry, we sample from nD integer lattice
            function* generateCoords(depth, current) {
                if (depth === n) {
                    yield [...current];
                    return;
                }
                for (let i = -range; i <= range; i++) {
                    current.push(i);
                    yield* generateCoords(depth + 1, current);
                    current.pop();
                }
            }

            // Limit computation for higher dimensions
            const maxCoords = n <= 5 ? range : Math.min(range, 5);

            for (let i0 = -maxCoords; i0 <= maxCoords; i0++) {
                for (let i1 = -maxCoords; i1 <= maxCoords; i1++) {
                    for (let i2 = -maxCoords; i2 <= maxCoords; i2++) {
                        for (let i3 = -maxCoords; i3 <= maxCoords; i3++) {
                            let coords;
                            if (n === 5) {
                                for (let i4 = -maxCoords; i4 <= maxCoords; i4++) {
                                    coords = [i0, i1, i2, i3, i4];
                                    processCoord(coords);
                                }
                            } else if (n === 8 || n === 4) {
                                coords = [i0, i1, i2, i3];
                                processCoord(coords);
                            } else if (n === 10) {
                                for (let i4 = -Math.min(maxCoords, 3); i4 <= Math.min(maxCoords, 3); i4++) {
                                    coords = [i0, i1, i2, i3, i4];
                                    processCoord(coords);
                                }
                            } else if (n === 12 || n === 6) {
                                for (let i4 = -Math.min(maxCoords, 3); i4 <= Math.min(maxCoords, 3); i4++) {
                                    for (let i5 = -Math.min(maxCoords, 3); i5 <= Math.min(maxCoords, 3); i5++) {
                                        coords = [i0, i1, i2, i3, i4, i5];
                                        processCoord(coords);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            function processCoord(coords) {
                if (inAcceptanceWindow(coords, null, windowSize)) {
                    const projected = projectPoint(coords, getBasisVectors(n), projAngle);
                    const key = `${projected.x.toFixed(4)},${projected.y.toFixed(4)}`;

                    if (!vertexMap.has(key)) {
                        vertexMap.set(key, {
                            x: projected.x,
                            y: projected.y,
                            coords: coords.slice()
                        });
                    }
                }
            }

            return Array.from(vertexMap.values());
        }

        // Find tiles (rhombi) by connecting nearby vertices
        function findTiles(vertices) {
            const tiles = [];
            const edgeLength = 1.0;
            const tolerance = 0.15;

            // Build spatial index
            const grid = new Map();
            const cellSize = edgeLength * 2;

            vertices.forEach((v, i) => {
                const cx = Math.floor(v.x / cellSize);
                const cy = Math.floor(v.y / cellSize);
                const key = `${cx},${cy}`;
                if (!grid.has(key)) grid.set(key, []);
                grid.get(key).push(i);
            });

            // Find neighbors for each vertex
            const neighbors = vertices.map(() => []);

            vertices.forEach((v, i) => {
                const cx = Math.floor(v.x / cellSize);
                const cy = Math.floor(v.y / cellSize);

                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const key = `${cx + dx},${cy + dy}`;
                        const cell = grid.get(key);
                        if (!cell) continue;

                        for (const j of cell) {
                            if (i >= j) continue;
                            const dist = Math.sqrt(
                                (v.x - vertices[j].x) ** 2 +
                                (v.y - vertices[j].y) ** 2
                            );
                            if (Math.abs(dist - edgeLength) < tolerance) {
                                neighbors[i].push(j);
                                neighbors[j].push(i);
                            }
                        }
                    }
                }
            });

            // Find rhombus tiles
            const foundTiles = new Set();

            vertices.forEach((v, i) => {
                const iNeighbors = neighbors[i];

                for (let ni = 0; ni < iNeighbors.length; ni++) {
                    for (let nj = ni + 1; nj < iNeighbors.length; nj++) {
                        const j = iNeighbors[ni];
                        const k = iNeighbors[nj];

                        // Find fourth vertex
                        const jNeighbors = neighbors[j];
                        const kNeighbors = neighbors[k];

                        for (const l of jNeighbors) {
                            if (l !== i && kNeighbors.includes(l)) {
                                // Found a rhombus: i, j, l, k
                                const indices = [i, j, l, k].sort((a, b) => a - b);
                                const key = indices.join(',');

                                if (!foundTiles.has(key)) {
                                    foundTiles.add(key);

                                    // Calculate tile angle for coloring
                                    const dx1 = vertices[j].x - vertices[i].x;
                                    const dy1 = vertices[j].y - vertices[i].y;
                                    const angle1 = Math.atan2(dy1, dx1);

                                    const dx2 = vertices[k].x - vertices[i].x;
                                    const dy2 = vertices[k].y - vertices[i].y;
                                    const angle2 = Math.atan2(dy2, dx2);

                                    // Rhombus angle
                                    let rhombAngle = Math.abs(angle1 - angle2);
                                    if (rhombAngle > Math.PI) rhombAngle = 2 * Math.PI - rhombAngle;

                                    tiles.push({
                                        vertices: [i, j, l, k],
                                        angle: rhombAngle,
                                        center: {
                                            x: (vertices[i].x + vertices[j].x + vertices[l].x + vertices[k].x) / 4,
                                            y: (vertices[i].y + vertices[j].y + vertices[l].y + vertices[k].y) / 4
                                        }
                                    });
                                }
                            }
                        }
                    }
                }
            });

            return tiles;
        }

        // Drawing
        let vertices = [];
        let tiles = [];

        function generateAndDraw() {
            vertices = generateVertices();
            tiles = findTiles(vertices);

            document.getElementById('vertexCount').textContent = vertices.length;
            document.getElementById('tileCount').textContent = tiles.length;

            draw();
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            const colors = colorSchemes[currentScheme];

            // Draw tiles
            if (showTiles && tiles.length > 0) {
                tiles.forEach(tile => {
                    const pts = tile.vertices.map(i => vertices[i]);

                    // Order vertices for proper polygon drawing
                    const cx = tile.center.x;
                    const cy = tile.center.y;
                    pts.sort((a, b) => {
                        return Math.atan2(a.y - cy, a.x - cx) - Math.atan2(b.y - cy, b.x - cx);
                    });

                    ctx.beginPath();
                    ctx.moveTo(centerX + pts[0].x * zoom, centerY + pts[0].y * zoom);
                    for (let i = 1; i < pts.length; i++) {
                        ctx.lineTo(centerX + pts[i].x * zoom, centerY + pts[i].y * zoom);
                    }
                    ctx.closePath();

                    if (colorByType) {
                        // Color based on rhombus angle
                        const angleIndex = Math.floor((tile.angle / Math.PI) * colors.length) % colors.length;
                        ctx.fillStyle = colors[angleIndex] + '88';
                    } else {
                        ctx.fillStyle = colors[0] + '44';
                    }
                    ctx.fill();
                });
            }

            // Draw edges
            if (showEdges && tiles.length > 0) {
                ctx.strokeStyle = colorByType ? '#fff' : colors[1];
                ctx.lineWidth = 1;

                const drawnEdges = new Set();
                tiles.forEach(tile => {
                    const pts = tile.vertices.map(i => vertices[i]);
                    const cx = tile.center.x;
                    const cy = tile.center.y;
                    pts.sort((a, b) => {
                        return Math.atan2(a.y - cy, a.x - cx) - Math.atan2(b.y - cy, b.x - cx);
                    });

                    for (let i = 0; i < pts.length; i++) {
                        const a = pts[i];
                        const b = pts[(i + 1) % pts.length];
                        const key = `${Math.min(a.x, b.x).toFixed(3)},${Math.min(a.y, b.y).toFixed(3)}-${Math.max(a.x, b.x).toFixed(3)},${Math.max(a.y, b.y).toFixed(3)}`;

                        if (!drawnEdges.has(key)) {
                            drawnEdges.add(key);
                            ctx.beginPath();
                            ctx.moveTo(centerX + a.x * zoom, centerY + a.y * zoom);
                            ctx.lineTo(centerX + b.x * zoom, centerY + b.y * zoom);
                            ctx.stroke();
                        }
                    }
                });
            }

            // Draw vertices
            if (showVertices) {
                ctx.fillStyle = colors[2];
                vertices.forEach(v => {
                    ctx.beginPath();
                    ctx.arc(centerX + v.x * zoom, centerY + v.y * zoom, 2, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }

        // Event listeners
        document.getElementById('symmetrySelect').addEventListener('change', (e) => {
            symmetry = parseInt(e.target.value);
            const names = { 5: '5-fold', 8: '8-fold', 10: '10-fold', 12: '12-fold' };
            document.getElementById('symmetryType').textContent = names[symmetry];
            generateAndDraw();
        });

        document.getElementById('angleSlider').addEventListener('input', (e) => {
            projAngle = parseFloat(e.target.value);
            document.getElementById('angleValue').textContent = projAngle.toFixed(2);
            generateAndDraw();
        });

        document.getElementById('windowSlider').addEventListener('input', (e) => {
            windowSize = parseFloat(e.target.value);
            document.getElementById('windowValue').textContent = windowSize.toFixed(2);
            generateAndDraw();
        });

        document.getElementById('rangeSlider').addEventListener('input', (e) => {
            latticeRange = parseInt(e.target.value);
            document.getElementById('rangeValue').textContent = latticeRange;
            generateAndDraw();
        });

        document.getElementById('zoomSlider').addEventListener('input', (e) => {
            zoom = parseFloat(e.target.value);
            document.getElementById('zoomValue').textContent = zoom;
            draw();
        });

        document.getElementById('showTiles').addEventListener('change', (e) => {
            showTiles = e.target.checked;
            draw();
        });

        document.getElementById('showEdges').addEventListener('change', (e) => {
            showEdges = e.target.checked;
            draw();
        });

        document.getElementById('showVertices').addEventListener('change', (e) => {
            showVertices = e.target.checked;
            draw();
        });

        document.getElementById('colorByType').addEventListener('change', (e) => {
            colorByType = e.target.checked;
            draw();
        });

        document.getElementById('regenerate').addEventListener('click', generateAndDraw);

        document.getElementById('animate').addEventListener('click', () => {
            isAnimating = !isAnimating;
            document.getElementById('animate').textContent = isAnimating ? 'Stop' : 'Animate Angle';

            if (isAnimating) {
                function animateAngle() {
                    if (!isAnimating) return;
                    projAngle = (projAngle + 0.2) % 360;
                    document.getElementById('angleSlider').value = projAngle;
                    document.getElementById('angleValue').textContent = projAngle.toFixed(2);
                    generateAndDraw();
                    animationId = requestAnimationFrame(animateAngle);
                }
                animateAngle();
            } else {
                cancelAnimationFrame(animationId);
            }
        });

        // Initialize
        createColorSchemeUI();
        generateAndDraw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
