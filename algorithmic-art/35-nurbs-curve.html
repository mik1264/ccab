<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NURBS Curve Playground</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .sidebar {
            width: 320px;
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        .canvas-area {
            flex: 1;
            position: relative;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        h1 {
            color: #4ecdc4;
            font-size: 1.4rem;
            margin-bottom: 5px;
        }
        .subtitle {
            color: #888;
            font-size: 0.85rem;
            margin-bottom: 20px;
        }
        .back-link {
            display: inline-block;
            color: #4ecdc4;
            text-decoration: none;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }
        .back-link:hover {
            color: #ff6b6b;
        }
        .section {
            margin-bottom: 20px;
        }
        .section-header {
            color: #ff6b6b;
            font-size: 0.9rem;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(255, 107, 107, 0.3);
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            color: #aaa;
            font-size: 0.8rem;
            margin-bottom: 5px;
        }
        .control-group input[type="range"] {
            width: 100%;
            accent-color: #4ecdc4;
        }
        .control-group select {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: #e0e0e0;
        }
        .button-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        button {
            flex: 1;
            padding: 8px 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        button.danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }
        .control-points-list {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
        }
        .control-point-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            margin-bottom: 5px;
        }
        .control-point-item.selected {
            background: rgba(78, 205, 196, 0.2);
            border: 1px solid #4ecdc4;
        }
        .point-index {
            color: #4ecdc4;
            font-weight: bold;
            min-width: 25px;
        }
        .weight-input {
            width: 60px;
            padding: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 0.85rem;
        }
        .knot-vector {
            font-family: monospace;
            font-size: 0.8rem;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            word-break: break-all;
            color: #4ecdc4;
        }
        .info-box {
            background: rgba(78, 205, 196, 0.1);
            border-left: 3px solid #4ecdc4;
            padding: 10px;
            border-radius: 0 5px 5px 0;
            margin-top: 10px;
        }
        .info-box p {
            font-size: 0.8rem;
            color: #aaa;
            line-height: 1.5;
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.75rem;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }
        .stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.8rem;
        }
        .stats span {
            color: #4ecdc4;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <a href="index.html" class="back-link">← Back to Gallery</a>
            <h1>NURBS Curve Playground</h1>
            <p class="subtitle">Non-Uniform Rational B-Spline with interactive knot vector & weights</p>

            <div class="section">
                <div class="section-header">Curve Settings</div>
                <div class="control-group">
                    <label>Degree: <span id="degreeValue">3</span></label>
                    <input type="range" id="degreeSlider" min="1" max="5" value="3">
                </div>
                <div class="control-group">
                    <label>Knot Type</label>
                    <select id="knotType">
                        <option value="uniform">Uniform (clamped)</option>
                        <option value="nonuniform">Non-Uniform</option>
                        <option value="bezier">Bezier (full multiplicity)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Curve Samples: <span id="samplesValue">100</span></label>
                    <input type="range" id="samplesSlider" min="20" max="500" value="100">
                </div>
            </div>

            <div class="section">
                <div class="section-header">Control Points</div>
                <div class="button-row">
                    <button id="addPoint">+ Add Point</button>
                    <button id="removePoint" class="danger">- Remove</button>
                </div>
                <div class="button-row">
                    <button id="resetPoints">Reset Default</button>
                </div>
                <div id="controlPointsList" class="control-points-list"></div>
            </div>

            <div class="section">
                <div class="section-header">Knot Vector</div>
                <div class="knot-vector" id="knotVector">[0, 0, 0, 0, 1, 2, 3, 3, 3, 3]</div>
                <div class="button-row" style="margin-top: 10px;">
                    <button id="editKnots">Edit Knots</button>
                </div>
            </div>

            <div class="section">
                <div class="section-header">Visualization</div>
                <div class="control-group">
                    <label><input type="checkbox" id="showControlPolygon" checked> Control Polygon</label>
                </div>
                <div class="control-group">
                    <label><input type="checkbox" id="showBasisFunctions"> Basis Functions</label>
                </div>
                <div class="control-group">
                    <label><input type="checkbox" id="showKnotPositions" checked> Knot Positions on Curve</label>
                </div>
            </div>

            <div class="info-box">
                <p><strong>NURBS</strong> (Non-Uniform Rational B-Spline) curves are defined by:</p>
                <p>• <strong>Control Points:</strong> Click & drag to move</p>
                <p>• <strong>Weights:</strong> Higher = curve pulled closer</p>
                <p>• <strong>Knot Vector:</strong> Determines where/how control points affect curve</p>
                <p>• <strong>Degree:</strong> Polynomial order (higher = smoother)</p>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #4ecdc4;"></div>
                    <span>NURBS Curve</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6b6b;"></div>
                    <span>Control Points</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(255,255,255,0.3);"></div>
                    <span>Control Polygon</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffd93d;"></div>
                    <span>Knot Positions</span>
                </div>
            </div>
        </div>

        <div class="canvas-area">
            <canvas id="canvas"></canvas>
            <div class="stats">
                Points: <span id="pointCount">6</span> |
                Degree: <span id="statDegree">3</span> |
                Knots: <span id="knotCount">10</span>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // UI elements
        const degreeSlider = document.getElementById('degreeSlider');
        const degreeValue = document.getElementById('degreeValue');
        const knotTypeSelect = document.getElementById('knotType');
        const samplesSlider = document.getElementById('samplesSlider');
        const samplesValue = document.getElementById('samplesValue');
        const controlPointsList = document.getElementById('controlPointsList');
        const knotVectorDisplay = document.getElementById('knotVector');

        // State
        let controlPoints = [];
        let weights = [];
        let knots = [];
        let degree = 3;
        let samples = 100;
        let selectedPoint = -1;
        let isDragging = false;
        let showControlPolygon = true;
        let showBasisFunctions = false;
        let showKnotPositions = true;

        // Initialize with default control points
        function initDefaultPoints() {
            const w = canvas.width;
            const h = canvas.height;
            controlPoints = [
                { x: w * 0.1, y: h * 0.7 },
                { x: w * 0.2, y: h * 0.3 },
                { x: w * 0.4, y: h * 0.2 },
                { x: w * 0.6, y: h * 0.5 },
                { x: w * 0.7, y: h * 0.8 },
                { x: w * 0.9, y: h * 0.4 }
            ];
            weights = controlPoints.map(() => 1.0);
            updateKnotVector();
        }

        // Generate knot vector based on type
        function updateKnotVector() {
            const n = controlPoints.length;
            const p = degree;
            const knotCount = n + p + 1;

            if (knotTypeSelect.value === 'uniform') {
                // Clamped uniform knot vector
                knots = [];
                for (let i = 0; i < knotCount; i++) {
                    if (i <= p) {
                        knots.push(0);
                    } else if (i >= n) {
                        knots.push(n - p);
                    } else {
                        knots.push(i - p);
                    }
                }
            } else if (knotTypeSelect.value === 'bezier') {
                // Bezier-like: full multiplicity at ends only
                knots = [];
                for (let i = 0; i <= p; i++) knots.push(0);
                for (let i = 0; i <= p; i++) knots.push(1);
            } else {
                // Non-uniform: add some variation
                knots = [];
                for (let i = 0; i <= p; i++) knots.push(0);
                for (let i = 1; i < n - p; i++) {
                    knots.push(i + Math.sin(i) * 0.3);
                }
                for (let i = 0; i <= p; i++) knots.push(n - p);
            }

            knotVectorDisplay.textContent = '[' + knots.map(k => k.toFixed(2)).join(', ') + ']';
            document.getElementById('knotCount').textContent = knots.length;
        }

        // Cox-de Boor recursion formula for B-spline basis functions
        function basisFunction(i, p, t, knots) {
            if (p === 0) {
                return (t >= knots[i] && t < knots[i + 1]) ? 1 : 0;
            }

            let left = 0, right = 0;

            const denom1 = knots[i + p] - knots[i];
            if (denom1 !== 0) {
                left = ((t - knots[i]) / denom1) * basisFunction(i, p - 1, t, knots);
            }

            const denom2 = knots[i + p + 1] - knots[i + 1];
            if (denom2 !== 0) {
                right = ((knots[i + p + 1] - t) / denom2) * basisFunction(i + 1, p - 1, t, knots);
            }

            return left + right;
        }

        // Evaluate NURBS curve at parameter t
        function evaluateNURBS(t) {
            const n = controlPoints.length;
            let numeratorX = 0, numeratorY = 0, denominator = 0;

            // Handle boundary case
            if (t >= knots[knots.length - 1]) {
                t = knots[knots.length - 1] - 0.0001;
            }

            for (let i = 0; i < n; i++) {
                const basis = basisFunction(i, degree, t, knots);
                const weightedBasis = basis * weights[i];
                numeratorX += weightedBasis * controlPoints[i].x;
                numeratorY += weightedBasis * controlPoints[i].y;
                denominator += weightedBasis;
            }

            if (denominator === 0) {
                return null;
            }

            return {
                x: numeratorX / denominator,
                y: numeratorY / denominator
            };
        }

        // Resize canvas
        function resize() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            if (controlPoints.length === 0) {
                canvas.width = rect.width;
                canvas.height = rect.height;
                initDefaultPoints();
            }
        }

        // Update control points list UI
        function updateControlPointsList() {
            controlPointsList.innerHTML = '';
            controlPoints.forEach((pt, i) => {
                const item = document.createElement('div');
                item.className = 'control-point-item' + (i === selectedPoint ? ' selected' : '');
                item.innerHTML = `
                    <span class="point-index">P${i}</span>
                    <span style="flex:1; font-size:0.75rem; color:#888;">
                        (${Math.round(pt.x)}, ${Math.round(pt.y)})
                    </span>
                    <label style="font-size:0.75rem; color:#aaa;">w:</label>
                    <input type="number" class="weight-input" value="${weights[i].toFixed(2)}"
                           step="0.1" min="0.1" max="10" data-index="${i}">
                `;
                item.addEventListener('click', (e) => {
                    if (e.target.tagName !== 'INPUT') {
                        selectedPoint = i;
                        updateControlPointsList();
                        draw();
                    }
                });
                controlPointsList.appendChild(item);
            });

            // Weight input handlers
            document.querySelectorAll('.weight-input').forEach(input => {
                input.addEventListener('change', (e) => {
                    const idx = parseInt(e.target.dataset.index);
                    weights[idx] = Math.max(0.1, parseFloat(e.target.value) || 1);
                    draw();
                });
            });

            document.getElementById('pointCount').textContent = controlPoints.length;
        }

        // Draw everything
        function draw() {
            const w = canvas.width / window.devicePixelRatio;
            const h = canvas.height / window.devicePixelRatio;

            ctx.clearRect(0, 0, w, h);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for (let x = 0; x < w; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for (let y = 0; y < h; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            if (controlPoints.length < degree + 1) {
                ctx.fillStyle = '#ff6b6b';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`Need at least ${degree + 1} control points for degree ${degree}`, w/2, h/2);
                return;
            }

            // Draw control polygon
            if (showControlPolygon) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(controlPoints[0].x, controlPoints[0].y);
                for (let i = 1; i < controlPoints.length; i++) {
                    ctx.lineTo(controlPoints[i].x, controlPoints[i].y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw NURBS curve
            const tMin = knots[degree];
            const tMax = knots[knots.length - degree - 1];
            const curvePoints = [];

            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 3;
            ctx.beginPath();

            let firstPoint = true;
            for (let i = 0; i <= samples; i++) {
                const t = tMin + (tMax - tMin) * (i / samples);
                const pt = evaluateNURBS(t);
                if (pt) {
                    curvePoints.push({ t, ...pt });
                    if (firstPoint) {
                        ctx.moveTo(pt.x, pt.y);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(pt.x, pt.y);
                    }
                }
            }
            ctx.stroke();

            // Draw knot positions on curve
            if (showKnotPositions) {
                const uniqueKnots = [...new Set(knots.filter(k => k >= tMin && k <= tMax))];
                uniqueKnots.forEach(t => {
                    const pt = evaluateNURBS(t);
                    if (pt) {
                        ctx.fillStyle = '#ffd93d';
                        ctx.beginPath();
                        ctx.arc(pt.x, pt.y, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                });
            }

            // Draw control points
            controlPoints.forEach((pt, i) => {
                const isSelected = i === selectedPoint;
                const radius = isSelected ? 12 : 8 + weights[i] * 2;

                // Point glow
                if (isSelected) {
                    ctx.fillStyle = 'rgba(255, 107, 107, 0.3)';
                    ctx.beginPath();
                    ctx.arc(pt.x, pt.y, radius + 6, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Point fill
                ctx.fillStyle = isSelected ? '#ff6b6b' : `hsl(${i * 40}, 70%, 60%)`;
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Point stroke
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`P${i}`, pt.x, pt.y);

                // Weight indicator
                if (weights[i] !== 1) {
                    ctx.fillStyle = '#ffd93d';
                    ctx.font = '10px sans-serif';
                    ctx.fillText(`w=${weights[i].toFixed(1)}`, pt.x, pt.y + radius + 12);
                }
            });

            // Draw basis functions if enabled
            if (showBasisFunctions) {
                const basisHeight = 100;
                const basisY = h - basisHeight - 20;

                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(10, basisY - 10, w - 20, basisHeight + 20);

                // Axis
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(30, basisY + basisHeight);
                ctx.lineTo(w - 30, basisY + basisHeight);
                ctx.stroke();

                // Draw each basis function
                for (let i = 0; i < controlPoints.length; i++) {
                    ctx.strokeStyle = `hsl(${i * 40}, 70%, 60%)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();

                    for (let s = 0; s <= 200; s++) {
                        const t = tMin + (tMax - tMin) * (s / 200);
                        const basis = basisFunction(i, degree, t, knots);
                        const x = 30 + (w - 60) * (s / 200);
                        const y = basisY + basisHeight - basis * basisHeight;

                        if (s === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }

                ctx.fillStyle = '#fff';
                ctx.font = '10px sans-serif';
                ctx.fillText('Basis Functions N(t)', 40, basisY);
            }

            document.getElementById('statDegree').textContent = degree;
        }

        // Mouse interaction
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left),
                y: (e.clientY - rect.top)
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);

            // Check if clicking on a control point
            for (let i = 0; i < controlPoints.length; i++) {
                const pt = controlPoints[i];
                const dist = Math.sqrt((pos.x - pt.x) ** 2 + (pos.y - pt.y) ** 2);
                if (dist < 15) {
                    selectedPoint = i;
                    isDragging = true;
                    updateControlPointsList();
                    draw();
                    return;
                }
            }

            selectedPoint = -1;
            updateControlPointsList();
            draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging && selectedPoint >= 0) {
                const pos = getMousePos(e);
                controlPoints[selectedPoint] = pos;
                updateControlPointsList();
                draw();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('dblclick', (e) => {
            const pos = getMousePos(e);
            controlPoints.push(pos);
            weights.push(1.0);
            updateKnotVector();
            updateControlPointsList();
            draw();
        });

        // Event listeners
        degreeSlider.addEventListener('input', (e) => {
            degree = parseInt(e.target.value);
            degreeValue.textContent = degree;
            updateKnotVector();
            draw();
        });

        knotTypeSelect.addEventListener('change', () => {
            updateKnotVector();
            draw();
        });

        samplesSlider.addEventListener('input', (e) => {
            samples = parseInt(e.target.value);
            samplesValue.textContent = samples;
            draw();
        });

        document.getElementById('addPoint').addEventListener('click', () => {
            const lastPt = controlPoints[controlPoints.length - 1];
            controlPoints.push({ x: lastPt.x + 50, y: lastPt.y });
            weights.push(1.0);
            updateKnotVector();
            updateControlPointsList();
            draw();
        });

        document.getElementById('removePoint').addEventListener('click', () => {
            if (controlPoints.length > degree + 1) {
                if (selectedPoint >= 0) {
                    controlPoints.splice(selectedPoint, 1);
                    weights.splice(selectedPoint, 1);
                    selectedPoint = -1;
                } else {
                    controlPoints.pop();
                    weights.pop();
                }
                updateKnotVector();
                updateControlPointsList();
                draw();
            }
        });

        document.getElementById('resetPoints').addEventListener('click', () => {
            initDefaultPoints();
            selectedPoint = -1;
            updateControlPointsList();
            draw();
        });

        document.getElementById('editKnots').addEventListener('click', () => {
            const input = prompt('Enter knot vector (comma-separated):', knots.join(', '));
            if (input) {
                try {
                    const newKnots = input.split(',').map(s => parseFloat(s.trim()));
                    if (newKnots.length === controlPoints.length + degree + 1) {
                        knots = newKnots;
                        knotTypeSelect.value = 'nonuniform';
                        knotVectorDisplay.textContent = '[' + knots.map(k => k.toFixed(2)).join(', ') + ']';
                        document.getElementById('knotCount').textContent = knots.length;
                        draw();
                    } else {
                        alert(`Knot vector must have ${controlPoints.length + degree + 1} elements (n + p + 1)`);
                    }
                } catch (e) {
                    alert('Invalid knot vector format');
                }
            }
        });

        document.getElementById('showControlPolygon').addEventListener('change', (e) => {
            showControlPolygon = e.target.checked;
            draw();
        });

        document.getElementById('showBasisFunctions').addEventListener('change', (e) => {
            showBasisFunctions = e.target.checked;
            draw();
        });

        document.getElementById('showKnotPositions').addEventListener('change', (e) => {
            showKnotPositions = e.target.checked;
            draw();
        });

        // Initialize
        window.addEventListener('resize', () => {
            resize();
            draw();
        });

        resize();
        updateControlPointsList();
        draw();
    </script>
</body>
</html>
