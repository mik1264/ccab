<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cylindrical Anamorphosis Maker - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10000;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #BC6C25;
            text-decoration: none;
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: rgba(254, 250, 224, 0.95);
            border-radius: 20px;
            border: 2px solid rgba(138, 154, 91, 0.3);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(96, 108, 56, 0.15);
        }

        .organic-back-link:hover {
            background: rgba(254, 250, 224, 1);
            transform: translateX(-5px);
            border-color: #DDA15E;
        }

        .container {
            max-width: 1400px;
            margin: 60px auto 0;
        }

        h1 {
            text-align: center;
            font-size: 2rem;
            margin-bottom: 0.5rem;
            color: #c9a227;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 1.5rem;
            font-size: 1rem;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel h3 {
            color: #c9a227;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .canvas-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: #1a1a2e;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group.full-width {
            grid-column: span 2;
        }

        .control-group label {
            color: #aaa;
            font-size: 0.85rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        .control-group span {
            color: #c9a227;
            font-size: 0.9rem;
        }

        .shape-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        button {
            padding: 8px 16px;
            background: linear-gradient(135deg, #c9a227, #8b6914);
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(201, 162, 39, 0.3);
        }

        button.active {
            box-shadow: 0 0 10px rgba(201, 162, 39, 0.6);
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .info-panel h4 {
            color: #c9a227;
            margin-bottom: 10px;
        }

        .info-panel p {
            font-size: 0.9rem;
            line-height: 1.6;
            color: #aaa;
        }

        .equation {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: #88ccff;
            text-align: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            margin: 10px 0;
        }

        .mirror-indicator {
            position: absolute;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8rem;
            pointer-events: none;
        }

        @media (max-width: 900px) {
            .main-layout {
                grid-template-columns: 1fr;
            }

            .controls {
                grid-template-columns: 1fr;
            }

            .control-group.full-width {
                grid-column: span 1;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link">← Back to Gallery</a>

    <div class="container">
        <h1>Cylindrical Anamorphosis Maker</h1>
        <p class="subtitle">Draw an image and see it distorted for cylindrical mirror revelation</p>

        <div class="main-layout">
            <div class="panel">
                <h3>Original Image (Draw Here)</h3>
                <div class="canvas-container">
                    <canvas id="sourceCanvas" width="400" height="400"></canvas>
                </div>
            </div>

            <div class="panel">
                <h3>Anamorphic Distortion (View with Cylinder)</h3>
                <div class="canvas-container">
                    <canvas id="distortedCanvas" width="400" height="400"></canvas>
                    <div class="mirror-indicator" id="mirrorLabel">Place mirror here</div>
                </div>
            </div>
        </div>

        <div class="panel">
            <h3>Controls</h3>
            <div class="controls">
                <div class="control-group">
                    <label>Mirror Radius: <span id="radiusVal">60</span>px</label>
                    <input type="range" id="mirrorRadius" min="30" max="100" value="60">
                </div>

                <div class="control-group">
                    <label>Distortion Intensity: <span id="intensityVal">1.0</span></label>
                    <input type="range" id="intensity" min="0.5" max="2" step="0.1" value="1">
                </div>

                <div class="control-group">
                    <label>Angular Sectors: <span id="sectorsVal">72</span></label>
                    <input type="range" id="sectors" min="24" max="120" step="4" value="72">
                </div>

                <div class="control-group">
                    <label>Radial Rings: <span id="ringsVal">50</span></label>
                    <input type="range" id="rings" min="20" max="100" step="5" value="50">
                </div>

                <div class="control-group">
                    <label>Brush Size: <span id="brushVal">15</span>px</label>
                    <input type="range" id="brushSize" min="5" max="50" value="15">
                </div>

                <div class="control-group">
                    <label>Brush Color</label>
                    <input type="color" id="brushColor" value="#c9a227">
                </div>

                <div class="control-group full-width">
                    <label>Draw Shapes:</label>
                    <div class="shape-buttons">
                        <button onclick="setShape('freehand')" id="btn-freehand" class="active">Freehand</button>
                        <button onclick="drawStar()">Star</button>
                        <button onclick="drawCircle()">Circle</button>
                        <button onclick="drawHeart()">Heart</button>
                        <button onclick="drawSpiral()">Spiral</button>
                        <button onclick="clearCanvas()">Clear</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <h4>How Cylindrical Anamorphosis Works</h4>
            <p>
                Anamorphosis is an optical illusion where a distorted image becomes recognizable when viewed
                from a specific angle or reflected in a cylindrical mirror. The technique was popularized
                during the Renaissance and Victorian era.
            </p>
            <div class="equation">
                r' = f(r, θ) | θ' = θ | Polar coordinate transformation
            </div>
            <p>
                The distorted image is created by mapping each point from Cartesian coordinates to a
                polar grid centered where the cylindrical mirror will be placed. The radial distance
                is compressed near the center and stretched toward the edges, creating the characteristic
                "smeared" appearance that reforms when reflected.
            </p>
        </div>
    </div>

    <script>
        const sourceCanvas = document.getElementById('sourceCanvas');
        const distortedCanvas = document.getElementById('distortedCanvas');
        const srcCtx = sourceCanvas.getContext('2d');
        const dstCtx = distortedCanvas.getContext('2d');
        const mirrorLabel = document.getElementById('mirrorLabel');

        // Controls
        const mirrorRadiusSlider = document.getElementById('mirrorRadius');
        const intensitySlider = document.getElementById('intensity');
        const sectorsSlider = document.getElementById('sectors');
        const ringsSlider = document.getElementById('rings');
        const brushSizeSlider = document.getElementById('brushSize');
        const brushColorInput = document.getElementById('brushColor');

        // State
        let isDrawing = false;
        let lastX = 0, lastY = 0;
        let currentShape = 'freehand';
        let mirrorRadius = 60;
        let intensity = 1.0;
        let sectors = 72;
        let rings = 50;
        let brushSize = 15;
        let brushColor = '#c9a227';

        // Initialize
        function init() {
            srcCtx.fillStyle = '#1a1a2e';
            srcCtx.fillRect(0, 0, sourceCanvas.width, sourceCanvas.height);

            dstCtx.fillStyle = '#1a1a2e';
            dstCtx.fillRect(0, 0, distortedCanvas.width, distortedCanvas.height);

            updateDistortion();
            updateMirrorLabel();
        }

        // Update mirror label position
        function updateMirrorLabel() {
            const cx = distortedCanvas.width / 2;
            const cy = distortedCanvas.height / 2;
            mirrorLabel.style.left = `${cx - 40}px`;
            mirrorLabel.style.top = `${cy - 10}px`;
        }

        // Drawing functions
        sourceCanvas.addEventListener('mousedown', startDraw);
        sourceCanvas.addEventListener('mousemove', draw);
        sourceCanvas.addEventListener('mouseup', stopDraw);
        sourceCanvas.addEventListener('mouseout', stopDraw);

        function startDraw(e) {
            if (currentShape !== 'freehand') return;
            isDrawing = true;
            const rect = sourceCanvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
        }

        function draw(e) {
            if (!isDrawing || currentShape !== 'freehand') return;
            const rect = sourceCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            srcCtx.strokeStyle = brushColor;
            srcCtx.lineWidth = brushSize;
            srcCtx.lineCap = 'round';
            srcCtx.lineJoin = 'round';

            srcCtx.beginPath();
            srcCtx.moveTo(lastX, lastY);
            srcCtx.lineTo(x, y);
            srcCtx.stroke();

            lastX = x;
            lastY = y;

            requestAnimationFrame(updateDistortion);
        }

        function stopDraw() {
            isDrawing = false;
        }

        function setShape(shape) {
            currentShape = shape;
            document.querySelectorAll('.shape-buttons button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById('btn-freehand').classList.add('active');
        }

        function clearCanvas() {
            srcCtx.fillStyle = '#1a1a2e';
            srcCtx.fillRect(0, 0, sourceCanvas.width, sourceCanvas.height);
            updateDistortion();
        }

        function drawStar() {
            const cx = sourceCanvas.width / 2;
            const cy = sourceCanvas.height / 2;
            const spikes = 5;
            const outerRadius = 150;
            const innerRadius = 60;

            srcCtx.beginPath();
            srcCtx.strokeStyle = brushColor;
            srcCtx.lineWidth = brushSize;

            for (let i = 0; i < spikes * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i * Math.PI) / spikes - Math.PI / 2;
                const x = cx + Math.cos(angle) * radius;
                const y = cy + Math.sin(angle) * radius;

                if (i === 0) srcCtx.moveTo(x, y);
                else srcCtx.lineTo(x, y);
            }
            srcCtx.closePath();
            srcCtx.stroke();
            updateDistortion();
        }

        function drawCircle() {
            const cx = sourceCanvas.width / 2;
            const cy = sourceCanvas.height / 2;

            srcCtx.beginPath();
            srcCtx.strokeStyle = brushColor;
            srcCtx.lineWidth = brushSize;
            srcCtx.arc(cx, cy, 120, 0, Math.PI * 2);
            srcCtx.stroke();
            updateDistortion();
        }

        function drawHeart() {
            const cx = sourceCanvas.width / 2;
            const cy = sourceCanvas.height / 2;
            const scale = 8;

            srcCtx.beginPath();
            srcCtx.strokeStyle = brushColor;
            srcCtx.lineWidth = brushSize;

            for (let t = 0; t <= Math.PI * 2; t += 0.05) {
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));

                const px = cx + x * scale;
                const py = cy + y * scale;

                if (t === 0) srcCtx.moveTo(px, py);
                else srcCtx.lineTo(px, py);
            }
            srcCtx.closePath();
            srcCtx.stroke();
            updateDistortion();
        }

        function drawSpiral() {
            const cx = sourceCanvas.width / 2;
            const cy = sourceCanvas.height / 2;

            srcCtx.beginPath();
            srcCtx.strokeStyle = brushColor;
            srcCtx.lineWidth = brushSize / 2;

            for (let t = 0; t < Math.PI * 8; t += 0.05) {
                const r = 10 + t * 15;
                const x = cx + Math.cos(t) * r;
                const y = cy + Math.sin(t) * r;

                if (t === 0) srcCtx.moveTo(x, y);
                else srcCtx.lineTo(x, y);
            }
            srcCtx.stroke();
            updateDistortion();
        }

        // Core anamorphic distortion
        function updateDistortion() {
            const srcWidth = sourceCanvas.width;
            const srcHeight = sourceCanvas.height;
            const dstWidth = distortedCanvas.width;
            const dstHeight = distortedCanvas.height;

            const srcData = srcCtx.getImageData(0, 0, srcWidth, srcHeight);
            const dstData = dstCtx.createImageData(dstWidth, dstHeight);

            const centerX = dstWidth / 2;
            const centerY = dstHeight / 2;
            const maxRadius = Math.min(centerX, centerY);

            // Map from distorted to source
            for (let y = 0; y < dstHeight; y++) {
                for (let x = 0; x < dstWidth; x++) {
                    // Convert to polar coordinates (relative to center)
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    const theta = Math.atan2(dy, dx);

                    // Skip if inside mirror zone
                    if (r < mirrorRadius) {
                        const idx = (y * dstWidth + x) * 4;
                        dstData.data[idx] = 60;
                        dstData.data[idx + 1] = 60;
                        dstData.data[idx + 2] = 80;
                        dstData.data[idx + 3] = 255;
                        continue;
                    }

                    // Inverse polar transformation
                    // Map the ring [mirrorRadius, maxRadius] to full image
                    const normalizedR = (r - mirrorRadius) / (maxRadius - mirrorRadius);

                    // Compression function for anamorphosis
                    const compressedR = Math.pow(normalizedR, 1 / intensity);

                    // Convert back to Cartesian for source lookup
                    // The source image is treated as rectangular
                    const srcX = (theta / Math.PI + 1) * 0.5 * srcWidth;
                    const srcY = (1 - compressedR) * srcHeight;

                    if (srcX >= 0 && srcX < srcWidth && srcY >= 0 && srcY < srcHeight) {
                        const srcIdx = (Math.floor(srcY) * srcWidth + Math.floor(srcX)) * 4;
                        const dstIdx = (y * dstWidth + x) * 4;

                        dstData.data[dstIdx] = srcData.data[srcIdx];
                        dstData.data[dstIdx + 1] = srcData.data[srcIdx + 1];
                        dstData.data[dstIdx + 2] = srcData.data[srcIdx + 2];
                        dstData.data[dstIdx + 3] = srcData.data[srcIdx + 3];
                    }
                }
            }

            dstCtx.putImageData(dstData, 0, 0);

            // Draw mirror circle indicator
            dstCtx.strokeStyle = 'rgba(200, 200, 220, 0.5)';
            dstCtx.lineWidth = 2;
            dstCtx.setLineDash([5, 5]);
            dstCtx.beginPath();
            dstCtx.arc(centerX, centerY, mirrorRadius, 0, Math.PI * 2);
            dstCtx.stroke();
            dstCtx.setLineDash([]);

            // Draw grid for visualization
            dstCtx.strokeStyle = 'rgba(200, 200, 220, 0.1)';
            dstCtx.lineWidth = 1;

            // Radial lines
            for (let i = 0; i < sectors; i++) {
                const angle = (i / sectors) * Math.PI * 2;
                dstCtx.beginPath();
                dstCtx.moveTo(centerX + Math.cos(angle) * mirrorRadius, centerY + Math.sin(angle) * mirrorRadius);
                dstCtx.lineTo(centerX + Math.cos(angle) * maxRadius, centerY + Math.sin(angle) * maxRadius);
                dstCtx.stroke();
            }

            // Concentric rings
            for (let i = 1; i <= rings; i++) {
                const r = mirrorRadius + (maxRadius - mirrorRadius) * (i / rings);
                dstCtx.beginPath();
                dstCtx.arc(centerX, centerY, r, 0, Math.PI * 2);
                dstCtx.stroke();
            }
        }

        // Event listeners for controls
        mirrorRadiusSlider.addEventListener('input', function() {
            mirrorRadius = parseInt(this.value);
            document.getElementById('radiusVal').textContent = mirrorRadius;
            updateDistortion();
        });

        intensitySlider.addEventListener('input', function() {
            intensity = parseFloat(this.value);
            document.getElementById('intensityVal').textContent = intensity.toFixed(1);
            updateDistortion();
        });

        sectorsSlider.addEventListener('input', function() {
            sectors = parseInt(this.value);
            document.getElementById('sectorsVal').textContent = sectors;
            updateDistortion();
        });

        ringsSlider.addEventListener('input', function() {
            rings = parseInt(this.value);
            document.getElementById('ringsVal').textContent = rings;
            updateDistortion();
        });

        brushSizeSlider.addEventListener('input', function() {
            brushSize = parseInt(this.value);
            document.getElementById('brushVal').textContent = brushSize;
        });

        brushColorInput.addEventListener('input', function() {
            brushColor = this.value;
        });

        // Initialize
        // Expose for enhance.js keyboard shortcuts
        window.reset = init;
        window.init = init;

        init();
        drawSpiral(); // Start with a demo shape
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
