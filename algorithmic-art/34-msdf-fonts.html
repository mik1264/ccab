<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MSDF Font Rendering Zoom Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #ff6b6b;
            text-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
        }
        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 20px;
        }
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .panel h2 {
            color: #4ecdc4;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
        .canvas-container {
            position: relative;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        canvas {
            display: block;
            width: 100%;
            cursor: crosshair;
        }
        .zoom-indicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #4ecdc4;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .control-group label {
            color: #aaa;
            font-size: 0.85rem;
        }
        .control-group input[type="range"] {
            width: 100%;
            accent-color: #ff6b6b;
        }
        .control-group select, .control-group input[type="text"] {
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 14px;
        }
        .control-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .control-row button {
            flex: 1;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .control-row button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        .control-row button.active {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }
        .comparison-item {
            text-align: center;
        }
        .comparison-item canvas {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
        }
        .comparison-item p {
            margin-top: 5px;
            color: #aaa;
            font-size: 0.85rem;
        }
        .info-panel {
            background: rgba(78, 205, 196, 0.1);
            border-left: 4px solid #4ecdc4;
            padding: 15px;
            border-radius: 0 10px 10px 0;
            margin-top: 20px;
        }
        .info-panel h3 {
            color: #4ecdc4;
            margin-bottom: 10px;
        }
        .info-panel p {
            color: #bbb;
            line-height: 1.6;
            font-size: 0.9rem;
        }
        .color-legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        .back-link {
            display: inline-block;
            color: #4ecdc4;
            text-decoration: none;
            margin-bottom: 20px;
            transition: color 0.3s;
        }
        .back-link:hover {
            color: #ff6b6b;
        }
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Gallery</a>
        <h1>MSDF Font Rendering Zoom Tool</h1>
        <p class="subtitle">Compare SDF vs MSDF — See how multi-channel preserves sharp corners at any scale</p>

        <div class="controls">
            <div class="control-group">
                <label>Character</label>
                <input type="text" id="charInput" value="A" maxlength="1">
            </div>
            <div class="control-group">
                <label>Zoom Level: <span id="zoomValue">1.0</span>x</label>
                <input type="range" id="zoomSlider" min="1" max="20" step="0.5" value="1">
            </div>
            <div class="control-group">
                <label>Field Resolution</label>
                <select id="resolutionSelect">
                    <option value="16">16×16 (Very Low)</option>
                    <option value="32" selected>32×32 (Low)</option>
                    <option value="64">64×64 (Medium)</option>
                    <option value="128">128×128 (High)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Smoothing</label>
                <input type="range" id="smoothingSlider" min="0.01" max="0.5" step="0.01" value="0.1">
            </div>
        </div>

        <div class="main-content">
            <div class="panel">
                <h2>Standard SDF (Single Channel)</h2>
                <div class="canvas-container">
                    <canvas id="sdfCanvas" width="400" height="400"></canvas>
                    <div class="zoom-indicator">Zoom: <span id="sdfZoom">1.0</span>x</div>
                </div>
                <p style="color: #aaa; font-size: 0.9rem;">
                    Notice the rounded corners and artifacts at sharp edges. Single-channel SDF stores only distance to nearest edge.
                </p>
            </div>

            <div class="panel">
                <h2>MSDF (Multi-Channel)</h2>
                <div class="canvas-container">
                    <canvas id="msdfCanvas" width="400" height="400"></canvas>
                    <div class="zoom-indicator">Zoom: <span id="msdfZoom">1.0</span>x</div>
                </div>
                <p style="color: #aaa; font-size: 0.9rem;">
                    Sharp corners preserved! RGB channels encode directional distance, reconstructed via median function.
                </p>
            </div>
        </div>

        <div class="comparison">
            <div class="comparison-item">
                <canvas id="sdfFieldCanvas" width="200" height="200"></canvas>
                <p>SDF Field (Grayscale)</p>
            </div>
            <div class="comparison-item">
                <canvas id="msdfFieldCanvas" width="200" height="200"></canvas>
                <p>MSDF Field (RGB Channels)</p>
            </div>
        </div>

        <div class="info-panel">
            <h3>How MSDF Works</h3>
            <p>
                <strong>The Problem:</strong> Standard Signed Distance Fields (SDF) use a single value per pixel
                representing distance to the nearest edge. This works well for smooth curves but fails at sharp
                corners—they become rounded when zoomed in.
            </p>
            <p style="margin-top: 10px;">
                <strong>The Solution:</strong> Multi-channel SDF (MSDF) uses RGB channels to encode directional
                edge information. Each channel stores the distance to edges in different quadrants. The final
                distance is computed using the <em>median</em> of R, G, B values, which correctly reconstructs
                sharp corners at any scale.
            </p>
            <div class="color-legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff4444;"></div>
                    <span>Red Channel</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #44ff44;"></div>
                    <span>Green Channel</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4444ff;"></div>
                    <span>Blue Channel</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvases
        const sdfCanvas = document.getElementById('sdfCanvas');
        const msdfCanvas = document.getElementById('msdfCanvas');
        const sdfFieldCanvas = document.getElementById('sdfFieldCanvas');
        const msdfFieldCanvas = document.getElementById('msdfFieldCanvas');

        const sdfCtx = sdfCanvas.getContext('2d');
        const msdfCtx = msdfCanvas.getContext('2d');
        const sdfFieldCtx = sdfFieldCanvas.getContext('2d');
        const msdfFieldCtx = msdfFieldCanvas.getContext('2d');

        // Controls
        const charInput = document.getElementById('charInput');
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomValue = document.getElementById('zoomValue');
        const resolutionSelect = document.getElementById('resolutionSelect');
        const smoothingSlider = document.getElementById('smoothingSlider');

        let currentChar = 'A';
        let currentZoom = 1.0;
        let fieldResolution = 32;
        let smoothing = 0.1;

        // SDF and MSDF data
        let sdfField = null;
        let msdfField = null;

        // Generate character outline points
        function getCharacterOutline(char, resolution) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = resolution;
            tempCanvas.height = resolution;
            const ctx = tempCanvas.getContext('2d');

            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, resolution, resolution);

            ctx.fillStyle = 'black';
            ctx.font = `bold ${resolution * 0.8}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(char, resolution / 2, resolution / 2 + resolution * 0.05);

            const imageData = ctx.getImageData(0, 0, resolution, resolution);
            return imageData.data;
        }

        // Generate SDF field
        function generateSDF(charData, resolution) {
            const field = new Float32Array(resolution * resolution);
            const maxDist = resolution / 4;

            for (let y = 0; y < resolution; y++) {
                for (let x = 0; x < resolution; x++) {
                    const idx = (y * resolution + x) * 4;
                    const inside = charData[idx] < 128;

                    let minDist = maxDist;

                    // Search for nearest edge
                    const searchRadius = Math.ceil(maxDist);
                    for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                        for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < resolution && ny >= 0 && ny < resolution) {
                                const nidx = (ny * resolution + nx) * 4;
                                const nInside = charData[nidx] < 128;

                                if (inside !== nInside) {
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    minDist = Math.min(minDist, dist);
                                }
                            }
                        }
                    }

                    field[y * resolution + x] = inside ? minDist : -minDist;
                }
            }

            return field;
        }

        // Generate MSDF field with directional channels
        function generateMSDF(charData, resolution) {
            const field = {
                r: new Float32Array(resolution * resolution),
                g: new Float32Array(resolution * resolution),
                b: new Float32Array(resolution * resolution)
            };
            const maxDist = resolution / 4;

            // Find edges with direction
            const edges = [];
            for (let y = 0; y < resolution; y++) {
                for (let x = 0; x < resolution; x++) {
                    const idx = (y * resolution + x) * 4;
                    const inside = charData[idx] < 128;

                    // Check neighbors for edges
                    const neighbors = [
                        [x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1],
                        [x + 1, y + 1], [x - 1, y - 1], [x + 1, y - 1], [x - 1, y + 1]
                    ];

                    for (const [nx, ny] of neighbors) {
                        if (nx >= 0 && nx < resolution && ny >= 0 && ny < resolution) {
                            const nidx = (ny * resolution + nx) * 4;
                            const nInside = charData[nidx] < 128;

                            if (inside !== nInside) {
                                // Calculate edge direction
                                const dx = nx - x;
                                const dy = ny - y;
                                const angle = Math.atan2(dy, dx);
                                edges.push({ x: (x + nx) / 2, y: (y + ny) / 2, angle, inside });
                            }
                        }
                    }
                }
            }

            // Calculate distance for each channel based on edge direction
            for (let y = 0; y < resolution; y++) {
                for (let x = 0; x < resolution; x++) {
                    const idx = (y * resolution + x) * 4;
                    const inside = charData[idx] < 128;

                    let minDistR = maxDist;
                    let minDistG = maxDist;
                    let minDistB = maxDist;

                    for (const edge of edges) {
                        const dx = edge.x - x;
                        const dy = edge.y - y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < maxDist) {
                            // Assign to channels based on edge angle
                            // This simulates the quadrant-based channel assignment
                            const edgeAngle = edge.angle;

                            // Red: horizontal edges (left/right)
                            if (Math.abs(Math.cos(edgeAngle)) > 0.5) {
                                minDistR = Math.min(minDistR, dist);
                            }

                            // Green: vertical edges (up/down)
                            if (Math.abs(Math.sin(edgeAngle)) > 0.5) {
                                minDistG = Math.min(minDistG, dist);
                            }

                            // Blue: diagonal edges
                            const normalizedAngle = ((edgeAngle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                            if ((normalizedAngle > Math.PI / 4 && normalizedAngle < 3 * Math.PI / 4) ||
                                (normalizedAngle > 5 * Math.PI / 4 && normalizedAngle < 7 * Math.PI / 4)) {
                                minDistB = Math.min(minDistB, dist);
                            } else {
                                minDistB = Math.min(minDistB, dist);
                            }
                        }
                    }

                    const sign = inside ? 1 : -1;
                    const pidx = y * resolution + x;
                    field.r[pidx] = sign * minDistR;
                    field.g[pidx] = sign * minDistG;
                    field.b[pidx] = sign * minDistB;
                }
            }

            return field;
        }

        // Median of three values
        function median(a, b, c) {
            return Math.max(Math.min(a, b), Math.min(Math.max(a, b), c));
        }

        // Sample SDF with bilinear interpolation
        function sampleSDF(field, x, y, resolution) {
            x = Math.max(0, Math.min(resolution - 1.001, x));
            y = Math.max(0, Math.min(resolution - 1.001, y));

            const x0 = Math.floor(x);
            const y0 = Math.floor(y);
            const x1 = Math.min(x0 + 1, resolution - 1);
            const y1 = Math.min(y0 + 1, resolution - 1);

            const fx = x - x0;
            const fy = y - y0;

            const v00 = field[y0 * resolution + x0];
            const v10 = field[y0 * resolution + x1];
            const v01 = field[y1 * resolution + x0];
            const v11 = field[y1 * resolution + x1];

            return (v00 * (1 - fx) * (1 - fy) +
                    v10 * fx * (1 - fy) +
                    v01 * (1 - fx) * fy +
                    v11 * fx * fy);
        }

        // Render SDF to canvas
        function renderSDF(ctx, field, resolution, zoom, canvasSize, smooth) {
            const imageData = ctx.createImageData(canvasSize, canvasSize);
            const data = imageData.data;

            const centerX = resolution / 2;
            const centerY = resolution / 2;

            for (let py = 0; py < canvasSize; py++) {
                for (let px = 0; px < canvasSize; px++) {
                    // Map canvas coordinates to field coordinates with zoom
                    const nx = (px / canvasSize - 0.5) / zoom + 0.5;
                    const ny = (py / canvasSize - 0.5) / zoom + 0.5;

                    const fx = nx * resolution;
                    const fy = ny * resolution;

                    const dist = sampleSDF(field, fx, fy, resolution);

                    // Apply smoothstep for anti-aliasing
                    const pixelDist = dist / resolution * canvasSize / zoom;
                    const alpha = smoothstep(-smooth * 10, smooth * 10, pixelDist);

                    const idx = (py * canvasSize + px) * 4;
                    data[idx] = 255 * alpha;
                    data[idx + 1] = 255 * alpha;
                    data[idx + 2] = 255 * alpha;
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Render MSDF to canvas
        function renderMSDF(ctx, field, resolution, zoom, canvasSize, smooth) {
            const imageData = ctx.createImageData(canvasSize, canvasSize);
            const data = imageData.data;

            for (let py = 0; py < canvasSize; py++) {
                for (let px = 0; px < canvasSize; px++) {
                    const nx = (px / canvasSize - 0.5) / zoom + 0.5;
                    const ny = (py / canvasSize - 0.5) / zoom + 0.5;

                    const fx = nx * resolution;
                    const fy = ny * resolution;

                    // Sample each channel
                    const r = sampleSDF(field.r, fx, fy, resolution);
                    const g = sampleSDF(field.g, fx, fy, resolution);
                    const b = sampleSDF(field.b, fx, fy, resolution);

                    // Use median of RGB for final distance
                    const dist = median(r, g, b);

                    const pixelDist = dist / resolution * canvasSize / zoom;
                    const alpha = smoothstep(-smooth * 10, smooth * 10, pixelDist);

                    const idx = (py * canvasSize + px) * 4;
                    data[idx] = 255 * alpha;
                    data[idx + 1] = 255 * alpha;
                    data[idx + 2] = 255 * alpha;
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Smoothstep function
        function smoothstep(edge0, edge1, x) {
            const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
            return t * t * (3 - 2 * t);
        }

        // Render field visualization
        function renderFieldVisualization() {
            // SDF Field visualization
            const sdfImageData = sdfFieldCtx.createImageData(200, 200);
            const sdfData = sdfImageData.data;

            for (let y = 0; y < 200; y++) {
                for (let x = 0; x < 200; x++) {
                    const fx = x / 200 * fieldResolution;
                    const fy = y / 200 * fieldResolution;
                    const dist = sampleSDF(sdfField, fx, fy, fieldResolution);

                    // Normalize to 0-255
                    const normalized = (dist / (fieldResolution / 4) + 1) * 0.5;
                    const value = Math.max(0, Math.min(255, normalized * 255));

                    const idx = (y * 200 + x) * 4;
                    sdfData[idx] = value;
                    sdfData[idx + 1] = value;
                    sdfData[idx + 2] = value;
                    sdfData[idx + 3] = 255;
                }
            }
            sdfFieldCtx.putImageData(sdfImageData, 0, 0);

            // MSDF Field visualization (RGB channels)
            const msdfImageData = msdfFieldCtx.createImageData(200, 200);
            const msdfData = msdfImageData.data;

            for (let y = 0; y < 200; y++) {
                for (let x = 0; x < 200; x++) {
                    const fx = x / 200 * fieldResolution;
                    const fy = y / 200 * fieldResolution;

                    const r = sampleSDF(msdfField.r, fx, fy, fieldResolution);
                    const g = sampleSDF(msdfField.g, fx, fy, fieldResolution);
                    const b = sampleSDF(msdfField.b, fx, fy, fieldResolution);

                    const normalize = (v) => Math.max(0, Math.min(255, (v / (fieldResolution / 4) + 1) * 0.5 * 255));

                    const idx = (y * 200 + x) * 4;
                    msdfData[idx] = normalize(r);
                    msdfData[idx + 1] = normalize(g);
                    msdfData[idx + 2] = normalize(b);
                    msdfData[idx + 3] = 255;
                }
            }
            msdfFieldCtx.putImageData(msdfImageData, 0, 0);
        }

        // Generate and render everything
        function update() {
            const charData = getCharacterOutline(currentChar, fieldResolution);
            sdfField = generateSDF(charData, fieldResolution);
            msdfField = generateMSDF(charData, fieldResolution);

            renderSDF(sdfCtx, sdfField, fieldResolution, currentZoom, 400, smoothing);
            renderMSDF(msdfCtx, msdfField, fieldResolution, currentZoom, 400, smoothing);
            renderFieldVisualization();

            document.getElementById('sdfZoom').textContent = currentZoom.toFixed(1);
            document.getElementById('msdfZoom').textContent = currentZoom.toFixed(1);
        }

        // Event listeners
        charInput.addEventListener('input', (e) => {
            if (e.target.value.length > 0) {
                currentChar = e.target.value[0];
                update();
            }
        });

        zoomSlider.addEventListener('input', (e) => {
            currentZoom = parseFloat(e.target.value);
            zoomValue.textContent = currentZoom.toFixed(1);
            renderSDF(sdfCtx, sdfField, fieldResolution, currentZoom, 400, smoothing);
            renderMSDF(msdfCtx, msdfField, fieldResolution, currentZoom, 400, smoothing);
            document.getElementById('sdfZoom').textContent = currentZoom.toFixed(1);
            document.getElementById('msdfZoom').textContent = currentZoom.toFixed(1);
        });

        resolutionSelect.addEventListener('change', (e) => {
            fieldResolution = parseInt(e.target.value);
            update();
        });

        smoothingSlider.addEventListener('input', (e) => {
            smoothing = parseFloat(e.target.value);
            renderSDF(sdfCtx, sdfField, fieldResolution, currentZoom, 400, smoothing);
            renderMSDF(msdfCtx, msdfField, fieldResolution, currentZoom, 400, smoothing);
        });

        // Mouse wheel zoom
        [sdfCanvas, msdfCanvas].forEach(canvas => {
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.5 : 0.5;
                currentZoom = Math.max(1, Math.min(20, currentZoom + delta));
                zoomSlider.value = currentZoom;
                zoomValue.textContent = currentZoom.toFixed(1);
                renderSDF(sdfCtx, sdfField, fieldResolution, currentZoom, 400, smoothing);
                renderMSDF(msdfCtx, msdfField, fieldResolution, currentZoom, 400, smoothing);
                document.getElementById('sdfZoom').textContent = currentZoom.toFixed(1);
                document.getElementById('msdfZoom').textContent = currentZoom.toFixed(1);
            });
        });

        // Initial render
        update();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
