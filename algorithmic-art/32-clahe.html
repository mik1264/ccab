<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CLAHE Contrast Enhancer - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #1a1525 0%, #252035 50%, #1a1525 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .organic-back-link {
            position: fixed; top: 20px; left: 20px; z-index: 10000;
            display: inline-flex; align-items: center; gap: 0.5rem;
            color: #BC6C25; text-decoration: none; font-weight: 600;
            padding: 0.5rem 1rem; background: rgba(254, 250, 224, 0.95);
            border-radius: 20px; transition: all 0.3s ease;
        }

        .organic-back-link:hover { background: rgba(254, 250, 224, 1); transform: translateX(-5px); }

        .container { max-width: 1200px; margin: 60px auto 0; }

        h1 { text-align: center; font-size: 2rem; margin-bottom: 0.5rem; color: #cc88ff; }
        .subtitle { text-align: center; color: #888; margin-bottom: 1.5rem; }

        .main-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }

        .canvas-panel {
            background: rgba(255, 255, 255, 0.03); border-radius: 12px;
            padding: 15px; border: 1px solid rgba(204, 136, 255, 0.2); text-align: center;
        }

        .canvas-panel h4 { color: #cc88ff; margin-bottom: 10px; }

        canvas { border: 2px solid rgba(204, 136, 255, 0.3); border-radius: 8px; max-width: 100%; }

        .histogram-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px; }

        .panel {
            background: rgba(255, 255, 255, 0.03); border-radius: 12px;
            padding: 20px; border: 1px solid rgba(204, 136, 255, 0.2); margin-bottom: 20px;
        }

        .panel h3 { color: #cc88ff; margin-bottom: 15px; }

        .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; }

        .control-group { display: flex; flex-direction: column; gap: 5px; }
        .control-group label { color: #aaa; font-size: 0.85rem; }
        .control-group input[type="range"] { width: 100%; cursor: pointer; }
        .control-group span { color: #cc88ff; }

        select {
            padding: 8px; background: rgba(204, 136, 255, 0.1);
            border: 1px solid rgba(204, 136, 255, 0.3);
            border-radius: 6px; color: #e0e0e0; font-family: inherit;
        }

        .buttons { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 15px; }

        button {
            padding: 10px 20px; background: linear-gradient(135deg, #cc88ff, #9955cc);
            border: none; border-radius: 6px; color: white; cursor: pointer;
            font-family: inherit; transition: all 0.3s ease;
        }

        button:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(204, 136, 255, 0.4); }

        .info-panel { background: rgba(0, 0, 0, 0.3); border-radius: 8px; padding: 15px; }
        .info-panel h4 { color: #cc88ff; margin-bottom: 10px; }
        .info-panel p { font-size: 0.9rem; line-height: 1.6; color: #aaa; margin-bottom: 10px; }

        @media (max-width: 800px) {
            .main-grid, .histogram-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link">← Back to Gallery</a>

    <div class="container">
        <h1>CLAHE Contrast Enhancer</h1>
        <p class="subtitle">Contrast Limited Adaptive Histogram Equalization</p>

        <div class="main-grid">
            <div class="canvas-panel">
                <h4>Original Image</h4>
                <canvas id="sourceCanvas" width="300" height="300"></canvas>
            </div>
            <div class="canvas-panel">
                <h4>CLAHE Enhanced</h4>
                <canvas id="outputCanvas" width="300" height="300"></canvas>
            </div>
        </div>

        <div class="histogram-grid">
            <div class="canvas-panel">
                <h4>Original Histogram</h4>
                <canvas id="histSourceCanvas" width="256" height="150"></canvas>
            </div>
            <div class="canvas-panel">
                <h4>Enhanced Histogram</h4>
                <canvas id="histOutputCanvas" width="256" height="150"></canvas>
            </div>
        </div>

        <div class="panel">
            <h3>CLAHE Parameters</h3>
            <div class="controls">
                <div class="control-group">
                    <label>Tile Size: <span id="tileVal">8</span>×<span id="tileVal2">8</span></label>
                    <input type="range" id="tileSize" min="2" max="16" step="2" value="8">
                </div>

                <div class="control-group">
                    <label>Clip Limit: <span id="clipVal">2.0</span></label>
                    <input type="range" id="clipLimit" min="1" max="10" step="0.5" value="2">
                </div>

                <div class="control-group">
                    <label>Number of Bins: <span id="binsVal">256</span></label>
                    <input type="range" id="numBins" min="64" max="256" step="32" value="256">
                </div>

                <div class="control-group">
                    <label>Source Image</label>
                    <select id="sourceImage">
                        <option value="lowcontrast">Low Contrast</option>
                        <option value="dark">Dark Image</option>
                        <option value="bright">Bright Image</option>
                        <option value="uneven">Uneven Lighting</option>
                    </select>
                </div>
            </div>

            <div class="buttons">
                <button onclick="applyCLAHE()">Apply CLAHE</button>
                <button onclick="applyGlobalHE()">Compare: Global HE</button>
                <button onclick="generateSource()">New Source</button>
            </div>
        </div>

        <div class="info-panel">
            <h4>About CLAHE</h4>
            <p>
                CLAHE (Contrast Limited Adaptive Histogram Equalization) improves on standard
                histogram equalization by operating on small regions (tiles) rather than the
                entire image. This preserves local contrast and prevents over-amplification.
            </p>
            <p>
                <strong>Tile Size:</strong> Divides the image into tiles for local processing.<br>
                <strong>Clip Limit:</strong> Limits contrast amplification to prevent noise enhancement.
                The clipped portion is redistributed uniformly across the histogram.<br>
                <strong>Bilinear Interpolation:</strong> Tile boundaries are smoothed by interpolating
                between neighboring tile transformations.
            </p>
            <p>
                CLAHE is widely used in medical imaging, satellite imagery, and photography
                to enhance details in images with poor lighting or low contrast.
            </p>
        </div>
    </div>

    <script>
        const sourceCanvas = document.getElementById('sourceCanvas');
        const outputCanvas = document.getElementById('outputCanvas');
        const histSourceCanvas = document.getElementById('histSourceCanvas');
        const histOutputCanvas = document.getElementById('histOutputCanvas');

        const srcCtx = sourceCanvas.getContext('2d');
        const outCtx = outputCanvas.getContext('2d');
        const histSrcCtx = histSourceCanvas.getContext('2d');
        const histOutCtx = histOutputCanvas.getContext('2d');

        let tileSize = 8;
        let clipLimit = 2.0;
        let numBins = 256;
        let sourceType = 'lowcontrast';

        function generateSource() {
            const width = sourceCanvas.width;
            const height = sourceCanvas.height;
            const imageData = srcCtx.createImageData(width, height);
            const data = imageData.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    let gray = 128;

                    switch (sourceType) {
                        case 'lowcontrast':
                            // Low contrast scene
                            gray = 100 + Math.sin(x * 0.05) * 20 + Math.cos(y * 0.05) * 20;
                            const d1 = Math.sqrt((x - 150) ** 2 + (y - 150) ** 2);
                            if (d1 < 80) gray = 120 - d1 * 0.2;
                            break;

                        case 'dark':
                            gray = 30 + Math.random() * 40;
                            const d2 = Math.sqrt((x - 150) ** 2 + (y - 150) ** 2);
                            if (d2 < 100) gray = 50 + (100 - d2) * 0.3;
                            break;

                        case 'bright':
                            gray = 200 + Math.random() * 40;
                            if (x > 50 && x < 250 && y > 50 && y < 250) {
                                gray = 180 + Math.sin((x + y) * 0.1) * 20;
                            }
                            break;

                        case 'uneven':
                            // Left side dark, right side bright
                            const t = x / width;
                            gray = 40 + t * 180 + Math.random() * 20;
                            // Add some features
                            const d3 = Math.sqrt((x - 80) ** 2 + (y - 150) ** 2);
                            const d4 = Math.sqrt((x - 220) ** 2 + (y - 150) ** 2);
                            if (d3 < 50) gray = Math.max(20, gray - 40);
                            if (d4 < 50) gray = Math.min(235, gray + 40);
                            break;
                    }

                    gray = Math.max(0, Math.min(255, gray));
                    data[idx] = data[idx + 1] = data[idx + 2] = gray;
                    data[idx + 3] = 255;
                }
            }

            srcCtx.putImageData(imageData, 0, 0);
            drawHistogram(imageData, histSrcCtx);
        }

        function computeHistogram(data, startX, startY, tileW, tileH, imgW) {
            const hist = new Array(numBins).fill(0);
            const binSize = 256 / numBins;

            for (let y = startY; y < startY + tileH; y++) {
                for (let x = startX; x < startX + tileW; x++) {
                    const idx = (y * imgW + x) * 4;
                    const bin = Math.min(numBins - 1, Math.floor(data[idx] / binSize));
                    hist[bin]++;
                }
            }

            return hist;
        }

        function clipHistogram(hist, limit) {
            const clipped = [...hist];
            let excess = 0;

            // Clip and count excess
            for (let i = 0; i < clipped.length; i++) {
                if (clipped[i] > limit) {
                    excess += clipped[i] - limit;
                    clipped[i] = limit;
                }
            }

            // Redistribute excess uniformly
            const increment = excess / numBins;
            for (let i = 0; i < clipped.length; i++) {
                clipped[i] += increment;
            }

            return clipped;
        }

        function createLUT(hist, numPixels) {
            const lut = new Array(numBins);
            let cdf = 0;
            const scale = 255 / numPixels;

            for (let i = 0; i < numBins; i++) {
                cdf += hist[i];
                lut[i] = Math.round(cdf * scale);
            }

            return lut;
        }

        function applyCLAHE() {
            const width = sourceCanvas.width;
            const height = sourceCanvas.height;

            const srcData = srcCtx.getImageData(0, 0, width, height);
            const outData = outCtx.createImageData(width, height);

            const tileW = Math.floor(width / tileSize);
            const tileH = Math.floor(height / tileSize);
            const pixelsPerTile = tileW * tileH;
            const actualClipLimit = clipLimit * pixelsPerTile / numBins;

            // Compute LUTs for all tiles
            const luts = [];
            for (let ty = 0; ty < tileSize; ty++) {
                luts[ty] = [];
                for (let tx = 0; tx < tileSize; tx++) {
                    const startX = tx * tileW;
                    const startY = ty * tileH;
                    let hist = computeHistogram(srcData.data, startX, startY, tileW, tileH, width);
                    hist = clipHistogram(hist, actualClipLimit);
                    luts[ty][tx] = createLUT(hist, pixelsPerTile);
                }
            }

            // Apply with bilinear interpolation
            const binSize = 256 / numBins;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const pixel = srcData.data[idx];
                    const bin = Math.min(numBins - 1, Math.floor(pixel / binSize));

                    // Find surrounding tiles
                    const tx = Math.min(tileSize - 1, Math.max(0, Math.floor((x - tileW / 2) / tileW)));
                    const ty = Math.min(tileSize - 1, Math.max(0, Math.floor((y - tileH / 2) / tileH)));
                    const tx2 = Math.min(tileSize - 1, tx + 1);
                    const ty2 = Math.min(tileSize - 1, ty + 1);

                    // Interpolation weights
                    const centerX = (tx + 0.5) * tileW;
                    const centerY = (ty + 0.5) * tileH;
                    const fx = Math.max(0, Math.min(1, (x - centerX) / tileW + 0.5));
                    const fy = Math.max(0, Math.min(1, (y - centerY) / tileH + 0.5));

                    // Bilinear interpolation of LUT values
                    const v00 = luts[ty][tx][bin];
                    const v10 = luts[ty][tx2][bin];
                    const v01 = luts[ty2][tx][bin];
                    const v11 = luts[ty2][tx2][bin];

                    const v0 = v00 * (1 - fx) + v10 * fx;
                    const v1 = v01 * (1 - fx) + v11 * fx;
                    const newVal = Math.round(v0 * (1 - fy) + v1 * fy);

                    outData.data[idx] = outData.data[idx + 1] = outData.data[idx + 2] = newVal;
                    outData.data[idx + 3] = 255;
                }
            }

            outCtx.putImageData(outData, 0, 0);
            drawHistogram(outData, histOutCtx);
        }

        function applyGlobalHE() {
            const width = sourceCanvas.width;
            const height = sourceCanvas.height;

            const srcData = srcCtx.getImageData(0, 0, width, height);
            const outData = outCtx.createImageData(width, height);

            // Compute global histogram
            const hist = new Array(256).fill(0);
            for (let i = 0; i < srcData.data.length; i += 4) {
                hist[srcData.data[i]]++;
            }

            // Compute CDF
            const cdf = new Array(256);
            cdf[0] = hist[0];
            for (let i = 1; i < 256; i++) {
                cdf[i] = cdf[i - 1] + hist[i];
            }

            // Normalize
            const numPixels = width * height;
            const lut = cdf.map(v => Math.round((v / numPixels) * 255));

            // Apply
            for (let i = 0; i < srcData.data.length; i += 4) {
                const newVal = lut[srcData.data[i]];
                outData.data[i] = outData.data[i + 1] = outData.data[i + 2] = newVal;
                outData.data[i + 3] = 255;
            }

            outCtx.putImageData(outData, 0, 0);
            drawHistogram(outData, histOutCtx);
        }

        function drawHistogram(imageData, ctx) {
            const hist = new Array(256).fill(0);

            for (let i = 0; i < imageData.data.length; i += 4) {
                hist[imageData.data[i]]++;
            }

            const maxVal = Math.max(...hist);
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;

            ctx.fillStyle = '#1a1525';
            ctx.fillRect(0, 0, width, height);

            for (let i = 0; i < 256; i++) {
                const h = (hist[i] / maxVal) * height * 0.9;
                const gradient = ctx.createLinearGradient(0, height - h, 0, height);
                gradient.addColorStop(0, '#cc88ff');
                gradient.addColorStop(1, '#9955cc');
                ctx.fillStyle = gradient;
                ctx.fillRect(i, height - h, 1, h);
            }
        }

        // Event listeners
        document.getElementById('tileSize').addEventListener('input', function() {
            tileSize = parseInt(this.value);
            document.getElementById('tileVal').textContent = tileSize;
            document.getElementById('tileVal2').textContent = tileSize;
        });

        document.getElementById('clipLimit').addEventListener('input', function() {
            clipLimit = parseFloat(this.value);
            document.getElementById('clipVal').textContent = clipLimit.toFixed(1);
        });

        document.getElementById('numBins').addEventListener('input', function() {
            numBins = parseInt(this.value);
            document.getElementById('binsVal').textContent = numBins;
        });

        document.getElementById('sourceImage').addEventListener('change', function() {
            sourceType = this.value;
            generateSource();
        });

        // Initialize
        generateSource();
        applyCLAHE();
    </script>
</body>
</html>
