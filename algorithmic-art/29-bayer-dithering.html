<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bayer Ordered Dithering - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #1a1520 0%, #251a30 50%, #1a1520 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10000;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #BC6C25;
            text-decoration: none;
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: rgba(254, 250, 224, 0.95);
            border-radius: 20px;
            transition: all 0.3s ease;
        }

        .organic-back-link:hover {
            background: rgba(254, 250, 224, 1);
            transform: translateX(-5px);
        }

        .container { max-width: 1200px; margin: 60px auto 0; }

        h1 { text-align: center; font-size: 2rem; margin-bottom: 0.5rem; color: #ff88cc; }
        .subtitle { text-align: center; color: #888; margin-bottom: 1.5rem; }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 136, 204, 0.2);
            text-align: center;
        }

        .canvas-panel h4 { color: #ff88cc; margin-bottom: 10px; }

        canvas {
            border: 2px solid rgba(255, 136, 204, 0.3);
            border-radius: 8px;
            max-width: 100%;
            image-rendering: pixelated;
        }

        .matrix-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .matrix-panel {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            border: 1px solid rgba(255, 136, 204, 0.2);
        }

        .matrix-panel h5 { color: #ff88cc; margin-bottom: 8px; font-size: 0.85rem; }

        .bayer-matrix {
            display: grid;
            gap: 1px;
            margin: 0 auto;
            width: fit-content;
        }

        .matrix-cell {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            border-radius: 2px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 136, 204, 0.2);
            margin-bottom: 20px;
        }

        .panel h3 { color: #ff88cc; margin-bottom: 15px; }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
        }

        .control-group { display: flex; flex-direction: column; gap: 5px; }
        .control-group label { color: #aaa; font-size: 0.85rem; }
        .control-group input[type="range"] { width: 100%; cursor: pointer; }
        .control-group span { color: #ff88cc; }

        select {
            padding: 8px;
            background: rgba(255, 136, 204, 0.1);
            border: 1px solid rgba(255, 136, 204, 0.3);
            border-radius: 6px;
            color: #e0e0e0;
            font-family: inherit;
        }

        .buttons { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 15px; }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #ff88cc, #cc5588);
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 136, 204, 0.4);
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
        }

        .info-panel h4 { color: #ff88cc; margin-bottom: 10px; }
        .info-panel p { font-size: 0.9rem; line-height: 1.6; color: #aaa; margin-bottom: 10px; }

        @media (max-width: 800px) {
            .main-grid, .matrix-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link">← Back to Gallery</a>

    <div class="container">
        <h1>Bayer Ordered Dithering</h1>
        <p class="subtitle">Threshold matrix dithering for halftone and retro effects</p>

        <div class="main-grid">
            <div class="canvas-panel">
                <h4>Original Grayscale</h4>
                <canvas id="sourceCanvas" width="256" height="256"></canvas>
            </div>
            <div class="canvas-panel">
                <h4>Bayer Dithered</h4>
                <canvas id="outputCanvas" width="256" height="256"></canvas>
            </div>
        </div>

        <div class="matrix-grid">
            <div class="matrix-panel">
                <h5>Bayer 2×2</h5>
                <div id="matrix2" class="bayer-matrix"></div>
            </div>
            <div class="matrix-panel">
                <h5>Bayer 4×4</h5>
                <div id="matrix4" class="bayer-matrix"></div>
            </div>
            <div class="matrix-panel">
                <h5>Bayer 8×8</h5>
                <div id="matrix8" class="bayer-matrix"></div>
            </div>
            <div class="matrix-panel">
                <h5>Current Threshold Map</h5>
                <canvas id="thresholdCanvas" width="64" height="64"></canvas>
            </div>
        </div>

        <div class="panel">
            <h3>Controls</h3>
            <div class="controls">
                <div class="control-group">
                    <label>Matrix Size</label>
                    <select id="matrixSize">
                        <option value="2">2×2</option>
                        <option value="4" selected>4×4</option>
                        <option value="8">8×8</option>
                        <option value="16">16×16</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Levels: <span id="levelsVal">2</span></label>
                    <input type="range" id="levels" min="2" max="16" value="2">
                </div>

                <div class="control-group">
                    <label>Spread: <span id="spreadVal">1.0</span></label>
                    <input type="range" id="spread" min="0.5" max="2" step="0.1" value="1">
                </div>

                <div class="control-group">
                    <label>Source Pattern</label>
                    <select id="sourcePattern">
                        <option value="gradient">Gradient</option>
                        <option value="radial">Radial</option>
                        <option value="spheres">Spheres</option>
                        <option value="portrait">Portrait</option>
                    </select>
                </div>
            </div>

            <div class="buttons">
                <button onclick="applyDithering()">Apply Dithering</button>
                <button onclick="generateSource()">New Source</button>
                <button onclick="toggleColor()">Toggle Color</button>
                <button onclick="animateGradient()">Animate</button>
            </div>
        </div>

        <div class="info-panel">
            <h4>About Bayer Dithering</h4>
            <p>
                Bayer ordered dithering uses a threshold matrix to determine whether each pixel
                should be light or dark. The matrix values are carefully arranged to produce
                visually pleasing patterns when tiled across an image.
            </p>
            <p>
                The Bayer matrix is generated recursively: each larger matrix is built from the
                previous size using the formula M(2n) = [4M(n), 4M(n)+2; 4M(n)+3, 4M(n)+1].
                This creates a pattern that minimizes visual artifacts.
            </p>
            <p>
                Unlike error diffusion dithering (like Floyd-Steinberg), ordered dithering is
                highly parallelizable and produces consistent, tile-able patterns. It was
                commonly used in early computer graphics and video games.
            </p>
        </div>
    </div>

    <script>
        const sourceCanvas = document.getElementById('sourceCanvas');
        const outputCanvas = document.getElementById('outputCanvas');
        const thresholdCanvas = document.getElementById('thresholdCanvas');
        const srcCtx = sourceCanvas.getContext('2d');
        const outCtx = outputCanvas.getContext('2d');
        const threshCtx = thresholdCanvas.getContext('2d');

        let matrixSize = 4;
        let levels = 2;
        let spread = 1.0;
        let sourcePattern = 'gradient';
        let useColor = false;
        let animating = false;

        // Generate Bayer matrix recursively
        function generateBayerMatrix(n) {
            if (n === 1) return [[0]];

            const smaller = generateBayerMatrix(n / 2);
            const size = smaller.length;
            const matrix = [];

            for (let y = 0; y < n; y++) {
                matrix[y] = [];
                for (let x = 0; x < n; x++) {
                    const sx = x % size;
                    const sy = y % size;
                    const quadrant = (Math.floor(y / size) * 2 + Math.floor(x / size));
                    const offsets = [0, 2, 3, 1];
                    matrix[y][x] = 4 * smaller[sy][sx] + offsets[quadrant];
                }
            }

            return matrix;
        }

        // Display matrix in DOM
        function displayMatrix(containerId, matrix) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            container.style.gridTemplateColumns = `repeat(${matrix.length}, 20px)`;

            const max = matrix.length * matrix.length - 1;

            for (let y = 0; y < matrix.length; y++) {
                for (let x = 0; x < matrix.length; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell';
                    cell.textContent = matrix[y][x];

                    const brightness = (matrix[y][x] / max) * 255;
                    const textColor = brightness > 128 ? '#000' : '#fff';
                    cell.style.background = `rgb(${brightness}, ${brightness * 0.5 + 100}, ${brightness * 0.7 + 100})`;
                    cell.style.color = textColor;

                    container.appendChild(cell);
                }
            }
        }

        // Draw threshold map preview
        function drawThresholdMap(matrix) {
            const size = matrix.length;
            const scale = Math.floor(64 / size);
            const imageData = threshCtx.createImageData(64, 64);
            const data = imageData.data;
            const max = size * size;

            for (let y = 0; y < 64; y++) {
                for (let x = 0; x < 64; x++) {
                    const mx = Math.floor(x / scale) % size;
                    const my = Math.floor(y / scale) % size;
                    const val = Math.floor((matrix[my][mx] / max) * 255);

                    const idx = (y * 64 + x) * 4;
                    data[idx] = val;
                    data[idx + 1] = val;
                    data[idx + 2] = val;
                    data[idx + 3] = 255;
                }
            }

            threshCtx.putImageData(imageData, 0, 0);
        }

        function generateSource(time = 0) {
            const width = sourceCanvas.width;
            const height = sourceCanvas.height;
            const imageData = srcCtx.createImageData(width, height);
            const data = imageData.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    let r, g, b;

                    switch (sourcePattern) {
                        case 'gradient':
                            const t = (x + time) / width;
                            r = g = b = t * 255;
                            break;

                        case 'radial':
                            const cx = width / 2, cy = height / 2;
                            const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                            const maxDist = Math.sqrt(cx ** 2 + cy ** 2);
                            r = g = b = (1 - dist / maxDist) * 255;
                            break;

                        case 'spheres':
                            r = g = b = 30;
                            const spheres = [
                                { x: 80, y: 80, r: 60 },
                                { x: 180, y: 120, r: 50 },
                                { x: 120, y: 180, r: 40 }
                            ];
                            for (const s of spheres) {
                                const d = Math.sqrt((x - s.x) ** 2 + (y - s.y) ** 2);
                                if (d < s.r) {
                                    const norm = 1 - d / s.r;
                                    const shade = Math.sqrt(1 - (d / s.r) ** 2) * 200 + 55;
                                    r = g = b = Math.max(r, shade);
                                }
                            }
                            break;

                        case 'portrait':
                            const pcx = width / 2, pcy = height / 2;
                            const faceDist = Math.sqrt((x - pcx) ** 2 + (y - pcy) ** 2);
                            if (faceDist < 100) {
                                r = g = b = 200 - faceDist * 0.5;
                                // Eyes
                                const le = Math.sqrt((x - pcx + 30) ** 2 + (y - pcy + 20) ** 2);
                                const re = Math.sqrt((x - pcx - 30) ** 2 + (y - pcy + 20) ** 2);
                                if (le < 15 || re < 15) r = g = b = 50;
                            } else {
                                r = g = b = 220;
                            }
                            break;
                    }

                    if (useColor) {
                        data[idx] = r;
                        data[idx + 1] = g * 0.8;
                        data[idx + 2] = b * 0.6;
                    } else {
                        data[idx] = r;
                        data[idx + 1] = g;
                        data[idx + 2] = b;
                    }
                    data[idx + 3] = 255;
                }
            }

            srcCtx.putImageData(imageData, 0, 0);
        }

        function applyDithering() {
            const width = outputCanvas.width;
            const height = outputCanvas.height;

            const srcData = srcCtx.getImageData(0, 0, width, height);
            const outData = outCtx.createImageData(width, height);
            const src = srcData.data;
            const out = outData.data;

            const matrix = generateBayerMatrix(matrixSize);
            const matrixMax = matrixSize * matrixSize;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const mx = x % matrixSize;
                    const my = y % matrixSize;
                    const threshold = (matrix[my][mx] + 0.5) / matrixMax;

                    for (let c = 0; c < 3; c++) {
                        const value = src[idx + c] / 255;
                        const adjusted = value + (threshold - 0.5) * spread / levels;

                        // Quantize to number of levels
                        const quantized = Math.floor(adjusted * levels) / (levels - 1);
                        out[idx + c] = Math.max(0, Math.min(255, quantized * 255));
                    }
                    out[idx + 3] = 255;
                }
            }

            outCtx.putImageData(outData, 0, 0);
        }

        function toggleColor() {
            useColor = !useColor;
            generateSource();
            applyDithering();
        }

        let animationId;
        function animateGradient() {
            if (animating) {
                animating = false;
                cancelAnimationFrame(animationId);
                return;
            }

            animating = true;
            let time = 0;

            function animate() {
                if (!animating) return;
                generateSource(time);
                applyDithering();
                time += 2;
                animationId = requestAnimationFrame(animate);
            }
            animate();
        }

        // Event listeners
        document.getElementById('matrixSize').addEventListener('change', function() {
            matrixSize = parseInt(this.value);
            const matrix = generateBayerMatrix(matrixSize);
            drawThresholdMap(matrix);
            applyDithering();
        });

        document.getElementById('levels').addEventListener('input', function() {
            levels = parseInt(this.value);
            document.getElementById('levelsVal').textContent = levels;
            applyDithering();
        });

        document.getElementById('spread').addEventListener('input', function() {
            spread = parseFloat(this.value);
            document.getElementById('spreadVal').textContent = spread.toFixed(1);
            applyDithering();
        });

        document.getElementById('sourcePattern').addEventListener('change', function() {
            sourcePattern = this.value;
            generateSource();
            applyDithering();
        });

        // Initialize
        displayMatrix('matrix2', generateBayerMatrix(2));
        displayMatrix('matrix4', generateBayerMatrix(4));
        displayMatrix('matrix8', generateBayerMatrix(8));
        drawThresholdMap(generateBayerMatrix(4));
        generateSource();
        applyDithering();
    </script>
</body>
</html>
