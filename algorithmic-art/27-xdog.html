<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XDoG Sketch Effect - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 50%, #1a1a1a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .organic-back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10000;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #BC6C25;
            text-decoration: none;
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: rgba(254, 250, 224, 0.95);
            border-radius: 20px;
            border: 2px solid rgba(138, 154, 91, 0.3);
            transition: all 0.3s ease;
        }

        .organic-back-link:hover {
            background: rgba(254, 250, 224, 1);
            transform: translateX(-5px);
        }

        .container {
            max-width: 1200px;
            margin: 60px auto 0;
        }

        h1 {
            text-align: center;
            font-size: 2rem;
            margin-bottom: 0.5rem;
            color: #fff;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 1.5rem;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .canvas-panel h4 {
            color: #ccc;
            margin-bottom: 10px;
        }

        canvas {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            max-width: 100%;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 20px;
        }

        .panel h3 {
            color: #fff;
            margin-bottom: 15px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            color: #aaa;
            font-size: 0.85rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        .control-group span {
            color: #fff;
            font-size: 0.9rem;
        }

        select {
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #e0e0e0;
            font-family: inherit;
        }

        .buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #555, #333);
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.2);
        }

        .presets {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .preset-btn {
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.85rem;
        }

        .preset-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .equation {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: #aaa;
            text-align: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            margin: 15px 0;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
        }

        .info-panel h4 {
            color: #fff;
            margin-bottom: 10px;
        }

        .info-panel p {
            font-size: 0.9rem;
            line-height: 1.6;
            color: #aaa;
            margin-bottom: 10px;
        }

        @media (max-width: 800px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="organic-back-link">← Back to Gallery</a>

    <div class="container">
        <h1>XDoG Sketch Effect</h1>
        <p class="subtitle">Extended Difference of Gaussians for stylized edge drawing</p>

        <div class="main-grid">
            <div class="canvas-panel">
                <h4>Original</h4>
                <canvas id="sourceCanvas" width="400" height="400"></canvas>
            </div>
            <div class="canvas-panel">
                <h4>XDoG Result</h4>
                <canvas id="outputCanvas" width="400" height="400"></canvas>
            </div>
        </div>

        <div class="panel">
            <h3>XDoG Parameters</h3>

            <div class="presets">
                <button class="preset-btn" onclick="loadPreset('pencil')">Pencil Sketch</button>
                <button class="preset-btn" onclick="loadPreset('ink')">Ink Drawing</button>
                <button class="preset-btn" onclick="loadPreset('soft')">Soft Edges</button>
                <button class="preset-btn" onclick="loadPreset('bold')">Bold Lines</button>
                <button class="preset-btn" onclick="loadPreset('woodcut')">Woodcut Style</button>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Sigma (σ): <span id="sigmaVal">1.0</span></label>
                    <input type="range" id="sigma" min="0.3" max="3" step="0.1" value="1.0">
                </div>

                <div class="control-group">
                    <label>Sigma Ratio (k): <span id="kVal">1.6</span></label>
                    <input type="range" id="kRatio" min="1.1" max="5" step="0.1" value="1.6">
                </div>

                <div class="control-group">
                    <label>Sharpness (p): <span id="pVal">20</span></label>
                    <input type="range" id="sharpness" min="1" max="100" step="1" value="20">
                </div>

                <div class="control-group">
                    <label>Threshold (ε): <span id="epsVal">0.01</span></label>
                    <input type="range" id="epsilon" min="0" max="0.1" step="0.005" value="0.01">
                </div>

                <div class="control-group">
                    <label>Phi (φ): <span id="phiVal">1</span></label>
                    <input type="range" id="phi" min="0.1" max="10" step="0.1" value="1">
                </div>

                <div class="control-group">
                    <label>Source Image</label>
                    <select id="sourceImage">
                        <option value="portrait">Portrait</option>
                        <option value="landscape">Landscape</option>
                        <option value="still-life">Still Life</option>
                        <option value="geometric">Geometric</option>
                    </select>
                </div>
            </div>

            <div class="equation">
                XDoG(x) = (1 + p) · G<sub>σ</sub>(x) - p · G<sub>kσ</sub>(x)
            </div>

            <div class="buttons">
                <button onclick="applyXDoG()">Apply XDoG Filter</button>
                <button onclick="generateSource()">New Source</button>
                <button onclick="toggleInvert()">Toggle Invert</button>
            </div>
        </div>

        <div class="info-panel">
            <h4>About XDoG (Extended Difference of Gaussians)</h4>
            <p>
                XDoG is an extension of the classic Difference of Gaussians (DoG) edge detection
                method. While standard DoG approximates the Laplacian of Gaussian, XDoG adds
                parameters for artistic control, enabling stylized sketch-like rendering.
            </p>
            <p>
                <strong>Parameters:</strong><br>
                • <strong>σ (Sigma):</strong> Base blur amount - larger values detect thicker edges<br>
                • <strong>k (Sigma Ratio):</strong> Ratio between the two Gaussian blurs<br>
                • <strong>p (Sharpness):</strong> Edge contrast amplification<br>
                • <strong>ε (Epsilon):</strong> Threshold for binary output<br>
                • <strong>φ (Phi):</strong> Soft threshold sharpness
            </p>
            <p>
                The thresholding step uses a smooth transition: T(u) = 1 if u ≥ ε, else 1 + tanh(φ · (u - ε))
            </p>
        </div>
    </div>

    <script>
        const sourceCanvas = document.getElementById('sourceCanvas');
        const outputCanvas = document.getElementById('outputCanvas');
        const srcCtx = sourceCanvas.getContext('2d');
        const outCtx = outputCanvas.getContext('2d');

        // Parameters
        let sigma = 1.0;
        let kRatio = 1.6;
        let sharpness = 20;
        let epsilon = 0.01;
        let phi = 1;
        let inverted = false;
        let sourceType = 'portrait';

        // Presets
        const presets = {
            pencil: { sigma: 0.8, kRatio: 1.6, sharpness: 30, epsilon: 0.01, phi: 2 },
            ink: { sigma: 1.2, kRatio: 2.0, sharpness: 50, epsilon: 0.02, phi: 5 },
            soft: { sigma: 2.0, kRatio: 1.4, sharpness: 10, epsilon: 0.005, phi: 0.5 },
            bold: { sigma: 1.5, kRatio: 3.0, sharpness: 80, epsilon: 0.03, phi: 8 },
            woodcut: { sigma: 1.0, kRatio: 4.0, sharpness: 100, epsilon: 0.05, phi: 10 }
        };

        function loadPreset(name) {
            const p = presets[name];
            sigma = p.sigma;
            kRatio = p.kRatio;
            sharpness = p.sharpness;
            epsilon = p.epsilon;
            phi = p.phi;

            document.getElementById('sigma').value = sigma;
            document.getElementById('kRatio').value = kRatio;
            document.getElementById('sharpness').value = sharpness;
            document.getElementById('epsilon').value = epsilon;
            document.getElementById('phi').value = phi;

            document.getElementById('sigmaVal').textContent = sigma.toFixed(1);
            document.getElementById('kVal').textContent = kRatio.toFixed(1);
            document.getElementById('pVal').textContent = sharpness;
            document.getElementById('epsVal').textContent = epsilon.toFixed(3);
            document.getElementById('phiVal').textContent = phi.toFixed(1);

            applyXDoG();
        }

        // Generate Gaussian kernel
        function createGaussianKernel(sigma) {
            const size = Math.ceil(sigma * 6) | 1; // Ensure odd
            const kernel = [];
            const half = Math.floor(size / 2);
            let sum = 0;

            for (let i = -half; i <= half; i++) {
                const val = Math.exp(-(i * i) / (2 * sigma * sigma));
                kernel.push(val);
                sum += val;
            }

            return kernel.map(v => v / sum);
        }

        // Apply 1D convolution (separable)
        function convolve1D(data, width, height, kernel, horizontal) {
            const output = new Float32Array(width * height);
            const half = Math.floor(kernel.length / 2);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let sum = 0;

                    for (let k = -half; k <= half; k++) {
                        let px, py;
                        if (horizontal) {
                            px = Math.max(0, Math.min(width - 1, x + k));
                            py = y;
                        } else {
                            px = x;
                            py = Math.max(0, Math.min(height - 1, y + k));
                        }

                        sum += data[py * width + px] * kernel[k + half];
                    }

                    output[y * width + x] = sum;
                }
            }

            return output;
        }

        // Gaussian blur (separable)
        function gaussianBlur(data, width, height, sigma) {
            const kernel = createGaussianKernel(sigma);
            let result = convolve1D(data, width, height, kernel, true); // Horizontal
            result = convolve1D(result, width, height, kernel, false);  // Vertical
            return result;
        }

        // Convert to grayscale
        function toGrayscale(imageData) {
            const data = imageData.data;
            const gray = new Float32Array(imageData.width * imageData.height);

            for (let i = 0; i < gray.length; i++) {
                const idx = i * 4;
                // Luminance formula
                gray[i] = (0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2]) / 255;
            }

            return gray;
        }

        // XDoG thresholding function
        function xdogThreshold(u) {
            if (u >= epsilon) {
                return 1;
            } else {
                return 1 + Math.tanh(phi * (u - epsilon));
            }
        }

        // Apply XDoG filter
        function applyXDoG() {
            const width = sourceCanvas.width;
            const height = sourceCanvas.height;

            const inputData = srcCtx.getImageData(0, 0, width, height);
            const outputData = outCtx.createImageData(width, height);

            // Convert to grayscale
            const gray = toGrayscale(inputData);

            // Apply two Gaussian blurs
            const g1 = gaussianBlur(gray, width, height, sigma);
            const g2 = gaussianBlur(gray, width, height, sigma * kRatio);

            // Compute XDoG: (1+p)*G1 - p*G2
            const xdog = new Float32Array(width * height);
            for (let i = 0; i < xdog.length; i++) {
                const diff = (1 + sharpness) * g1[i] - sharpness * g2[i];
                xdog[i] = xdogThreshold(diff);
            }

            // Output
            const output = outputData.data;
            for (let i = 0; i < xdog.length; i++) {
                let val = xdog[i];
                if (inverted) val = 1 - val;
                const byte = Math.max(0, Math.min(255, Math.floor(val * 255)));

                output[i * 4] = byte;
                output[i * 4 + 1] = byte;
                output[i * 4 + 2] = byte;
                output[i * 4 + 3] = 255;
            }

            outCtx.putImageData(outputData, 0, 0);
        }

        // Generate source images
        function generateSource() {
            const width = sourceCanvas.width;
            const height = sourceCanvas.height;
            const imageData = srcCtx.createImageData(width, height);
            const data = imageData.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    let r, g, b;

                    switch (sourceType) {
                        case 'portrait':
                            // Abstract face
                            const cx = width / 2;
                            const cy = height / 2;
                            const faceDist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);

                            if (faceDist < 160) {
                                r = g = b = 255 - faceDist * 0.5;

                                // Features
                                const leftEye = Math.sqrt((x - cx + 50) ** 2 + (y - cy + 30) ** 2);
                                const rightEye = Math.sqrt((x - cx - 50) ** 2 + (y - cy + 30) ** 2);
                                const nose = Math.abs(x - cx) < 10 && y > cy && y < cy + 50;
                                const mouth = y > cy + 60 && y < cy + 80 && Math.abs(x - cx) < 40;

                                if (leftEye < 25 || rightEye < 25) {
                                    if (leftEye < 10 || rightEye < 10) {
                                        r = g = b = 30;
                                    } else {
                                        r = g = b = 200;
                                    }
                                }
                                if (nose) r = g = b = 220;
                                if (mouth) r = g = b = 180;
                            } else {
                                r = g = b = 240;
                            }
                            break;

                        case 'landscape':
                            if (y < height * 0.5) {
                                // Sky
                                r = g = b = 220 - y * 0.2;
                            } else {
                                // Mountains
                                const mtn = Math.sin(x * 0.03) * 50 + Math.sin(x * 0.01) * 30;
                                if (y < height * 0.5 + 80 + mtn) {
                                    r = g = b = 100 + (y - height * 0.5) * 0.5;
                                } else {
                                    // Foreground
                                    r = g = b = 80 + Math.random() * 20;
                                }
                            }
                            break;

                        case 'still-life':
                            r = g = b = 240; // Background

                            // Vase
                            const vaseCx = width * 0.5;
                            const vaseCy = height * 0.6;
                            const vaseWidth = 60 + Math.sin((y - vaseCy) * 0.05) * 20;
                            if (y > height * 0.35 && y < height * 0.85 && Math.abs(x - vaseCx) < vaseWidth) {
                                r = g = b = 150;
                            }

                            // Fruit
                            const apples = [
                                { x: width * 0.25, y: height * 0.75, r: 45 },
                                { x: width * 0.75, y: height * 0.7, r: 50 },
                                { x: width * 0.6, y: height * 0.8, r: 35 }
                            ];
                            for (const apple of apples) {
                                const dist = Math.sqrt((x - apple.x) ** 2 + (y - apple.y) ** 2);
                                if (dist < apple.r) {
                                    r = g = b = 120 + (apple.r - dist);
                                }
                            }
                            break;

                        case 'geometric':
                            r = g = b = 255;

                            // Triangle
                            if (x > 50 && x < 200 && y > 50) {
                                const tri = y - 50 < (x - 50) && y - 50 < (200 - x);
                                if (tri) r = g = b = 50;
                            }

                            // Circle
                            const circleDist = Math.sqrt((x - 300) ** 2 + (y - 150) ** 2);
                            if (circleDist < 80) r = g = b = 100;

                            // Rectangle
                            if (x > 100 && x < 300 && y > 250 && y < 350) {
                                r = g = b = 150;
                            }

                            // Lines
                            if (Math.abs((x - 200) - (y - 200)) < 3) r = g = b = 0;
                            break;
                    }

                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                    data[idx + 3] = 255;
                }
            }

            srcCtx.putImageData(imageData, 0, 0);
            applyXDoG();
        }

        function toggleInvert() {
            inverted = !inverted;
            applyXDoG();
        }

        // Event listeners
        document.getElementById('sigma').addEventListener('input', function() {
            sigma = parseFloat(this.value);
            document.getElementById('sigmaVal').textContent = sigma.toFixed(1);
            applyXDoG();
        });

        document.getElementById('kRatio').addEventListener('input', function() {
            kRatio = parseFloat(this.value);
            document.getElementById('kVal').textContent = kRatio.toFixed(1);
            applyXDoG();
        });

        document.getElementById('sharpness').addEventListener('input', function() {
            sharpness = parseInt(this.value);
            document.getElementById('pVal').textContent = sharpness;
            applyXDoG();
        });

        document.getElementById('epsilon').addEventListener('input', function() {
            epsilon = parseFloat(this.value);
            document.getElementById('epsVal').textContent = epsilon.toFixed(3);
            applyXDoG();
        });

        document.getElementById('phi').addEventListener('input', function() {
            phi = parseFloat(this.value);
            document.getElementById('phiVal').textContent = phi.toFixed(1);
            applyXDoG();
        });

        document.getElementById('sourceImage').addEventListener('change', function() {
            sourceType = this.value;
            generateSource();
        });

        // Initialize
        generateSource();
    </script>
</body>
</html>
