<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyclic Cellular Automata - Spiral Patterns - CCAB</title>
    <meta name="description" content="Cyclic Cellular Automata by David Griffeath. Watch mesmerizing spiral patterns emerge from simple rules. Perfect spirals, demons, and turbulent phases.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f1a;
            min-height: 100vh;
            color: #e8e6e1;
            overflow: hidden;
        }
        #container { display: flex; height: 100vh; }
        #canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #controls {
            width: 300px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid #333;
        }
        h2 {
            color: #e056fd;
            margin-bottom: 15px;
            font-size: 1.3em;
            border-bottom: 1px solid #e056fd;
            padding-bottom: 10px;
        }
        h3 {
            color: #f9ca24;
            margin: 15px 0 10px;
            font-size: 0.95em;
        }
        .control-group { margin-bottom: 12px; }
        label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 0.85em;
        }
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
            accent-color: #e056fd;
        }
        .value {
            color: #e056fd;
            font-weight: bold;
            float: right;
        }
        select {
            width: 100%;
            padding: 8px;
            background: #222;
            border: 1px solid #444;
            color: #fff;
            border-radius: 4px;
        }
        button {
            width: 48%;
            padding: 10px;
            margin: 5px 1%;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s;
        }
        .run-btn { background: #e056fd; color: #000; }
        .run-btn:hover { background: #f085ff; }
        .reset-btn { background: #ff6b6b; color: white; }
        .reset-btn:hover { background: #ff8787; }
        .stats-panel {
            background: rgba(224, 86, 253, 0.1);
            border: 1px solid #e056fd;
            border-radius: 5px;
            padding: 10px;
            margin-top: 15px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 0.8em;
        }
        .stat-label { color: #888; }
        .stat-value { color: #e056fd; font-weight: bold; }
        .info-box {
            background: rgba(224, 86, 253, 0.1);
            border-left: 3px solid #e056fd;
            padding: 10px;
            margin-top: 15px;
            font-size: 0.75em;
            line-height: 1.5;
        }
        .back-link {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #e056fd;
            text-decoration: none;
            font-size: 0.9em;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 5px;
        }
        .back-link:hover { color: #f085ff; }
        .preset-btn {
            width: 48%;
            padding: 8px;
            margin: 2px 1%;
            font-size: 0.7em;
            background: #333;
            color: #ccc;
        }
        .preset-btn:hover { background: #e056fd; color: #000; }
        .color-preview {
            width: 100%;
            height: 30px;
            border-radius: 4px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>
    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        <div id="controls">
            <h2>üåÄ Cyclic CA</h2>

            <h3>Rule: R/T/C/N</h3>
            <div class="control-group">
                <label>Range (R): <span class="value" id="range-val">1</span></label>
                <input type="range" id="range" min="1" max="5" step="1" value="1">
            </div>
            <div class="control-group">
                <label>Threshold (T): <span class="value" id="threshold-val">3</span></label>
                <input type="range" id="threshold" min="1" max="15" step="1" value="3">
            </div>
            <div class="control-group">
                <label>States (C): <span class="value" id="states-val">4</span></label>
                <input type="range" id="states" min="3" max="24" step="1" value="4">
            </div>
            <div class="control-group">
                <label>Neighborhood:</label>
                <select id="neighborhood">
                    <option value="moore">Moore (8 neighbors)</option>
                    <option value="neumann">Von Neumann (4 neighbors)</option>
                </select>
            </div>

            <h3>Presets</h3>
            <div>
                <button class="preset-btn" onclick="preset('perfect')">Perfect Spirals</button>
                <button class="preset-btn" onclick="preset('diamond')">Diamond Spirals</button>
            </div>
            <div>
                <button class="preset-btn" onclick="preset('cyclic')">Cyclic Griffeath</button>
                <button class="preset-btn" onclick="preset('turbulent')">Turbulent</button>
            </div>
            <div>
                <button class="preset-btn" onclick="preset('amoeba')">Amoeba</button>
                <button class="preset-btn" onclick="preset('crystal')">Crystal</button>
            </div>

            <h3>Color Palette</h3>
            <div class="control-group">
                <select id="palette" onchange="updatePalette()">
                    <option value="rainbow">Rainbow</option>
                    <option value="fire">Fire</option>
                    <option value="ocean">Ocean</option>
                    <option value="plasma">Plasma</option>
                    <option value="grayscale">Grayscale</option>
                    <option value="neon">Neon</option>
                </select>
                <canvas id="color-preview" class="color-preview"></canvas>
            </div>

            <h3>Grid Size</h3>
            <div class="control-group">
                <label>Resolution: <span class="value" id="size-val">200</span></label>
                <input type="range" id="size" min="100" max="400" step="50" value="200">
            </div>

            <h3>Speed</h3>
            <div class="control-group">
                <label>Delay: <span class="value" id="delay-val">0</span>ms</label>
                <input type="range" id="delay" min="0" max="100" step="10" value="0">
            </div>

            <div style="margin: 15px 0;">
                <button class="run-btn" id="run-btn" onclick="toggleRun()">Pause</button>
                <button class="reset-btn" onclick="reset()">Reset</button>
            </div>

            <div class="stats-panel">
                <div class="stat-row">
                    <span class="stat-label">Generation:</span>
                    <span class="stat-value" id="gen-stat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Rule:</span>
                    <span class="stat-value" id="rule-stat">1/3/4/M</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Active Cells:</span>
                    <span class="stat-value" id="active-stat">0%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">FPS:</span>
                    <span class="stat-value" id="fps-stat">0</span>
                </div>
            </div>

            <div class="info-box">
                <strong>Cyclic CA Rules:</strong><br>
                A cell advances to state (s+1) mod C if at least T neighbors within range R have state (s+1) mod C.<br><br>
                <strong>Demons:</strong> Cycles of adjacent cells with consecutive states that spin and emit spiral waves.<br><br>
                <strong>Tip:</strong> Low thresholds create faster spirals. Higher states create more intricate patterns.
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const previewCanvas = document.getElementById('color-preview');
        const previewCtx = previewCanvas.getContext('2d');

        let gridSize = 200;
        let range = 1;
        let threshold = 3;
        let numStates = 4;
        let neighborhoodType = 'moore';

        let grid, nextGrid;
        let running = true;
        let generation = 0;
        let delay = 0;
        let colors = [];
        let palette = 'rainbow';

        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;

        function resize() {
            const container = document.getElementById('canvas-container');
            const size = Math.min(container.clientWidth, container.clientHeight) - 40;
            canvas.width = gridSize;
            canvas.height = gridSize;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
        }

        function generatePalette() {
            colors = [];
            for (let i = 0; i < numStates; i++) {
                const t = i / numStates;
                let r, g, b;

                switch (palette) {
                    case 'rainbow':
                        const hue = t * 360;
                        [r, g, b] = hslToRgb(hue / 360, 0.85, 0.55);
                        break;
                    case 'fire':
                        r = Math.floor(255 * Math.min(1, t * 2));
                        g = Math.floor(255 * Math.max(0, t * 2 - 0.5));
                        b = Math.floor(128 * Math.max(0, t * 3 - 2));
                        break;
                    case 'ocean':
                        r = Math.floor(20 + 100 * t);
                        g = Math.floor(100 + 100 * t);
                        b = Math.floor(150 + 105 * t);
                        break;
                    case 'plasma':
                        r = Math.floor(128 + 127 * Math.sin(t * Math.PI * 2));
                        g = Math.floor(128 + 127 * Math.sin(t * Math.PI * 2 + 2));
                        b = Math.floor(128 + 127 * Math.sin(t * Math.PI * 2 + 4));
                        break;
                    case 'grayscale':
                        r = g = b = Math.floor(255 * t);
                        break;
                    case 'neon':
                        const h = (t * 0.8 + 0.75) % 1; // Magenta to cyan
                        [r, g, b] = hslToRgb(h, 1, 0.5);
                        break;
                    default:
                        [r, g, b] = hslToRgb(t, 0.85, 0.55);
                }

                colors.push(`rgb(${r},${g},${b})`);
            }

            updatePalettePreview();
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function updatePalettePreview() {
            previewCanvas.width = 250;
            previewCanvas.height = 20;
            for (let i = 0; i < numStates; i++) {
                previewCtx.fillStyle = colors[i];
                previewCtx.fillRect(i * (250 / numStates), 0, 250 / numStates + 1, 20);
            }
        }

        function initGrid() {
            grid = new Uint8Array(gridSize * gridSize);
            nextGrid = new Uint8Array(gridSize * gridSize);

            for (let i = 0; i < grid.length; i++) {
                grid[i] = Math.floor(Math.random() * numStates);
            }

            generation = 0;
        }

        function getNeighbors(x, y) {
            const neighbors = [];

            for (let dy = -range; dy <= range; dy++) {
                for (let dx = -range; dx <= range; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    if (neighborhoodType === 'neumann' && Math.abs(dx) + Math.abs(dy) > range) continue;

                    const nx = (x + dx + gridSize) % gridSize;
                    const ny = (y + dy + gridSize) % gridSize;
                    neighbors.push(grid[ny * gridSize + nx]);
                }
            }

            return neighbors;
        }

        function step() {
            let activeCount = 0;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const idx = y * gridSize + x;
                    const currentState = grid[idx];
                    const nextState = (currentState + 1) % numStates;

                    const neighbors = getNeighbors(x, y);
                    let count = 0;

                    for (const n of neighbors) {
                        if (n === nextState) count++;
                    }

                    if (count >= threshold) {
                        nextGrid[idx] = nextState;
                        activeCount++;
                    } else {
                        nextGrid[idx] = currentState;
                    }
                }
            }

            // Swap grids
            [grid, nextGrid] = [nextGrid, grid];
            generation++;

            document.getElementById('active-stat').textContent = ((activeCount / grid.length) * 100).toFixed(1) + '%';
        }

        function draw() {
            const imageData = ctx.createImageData(gridSize, gridSize);

            for (let i = 0; i < grid.length; i++) {
                const state = grid[i];
                const color = colors[state];

                // Parse rgb(r,g,b) string
                const match = color.match(/rgb\((\d+),(\d+),(\d+)\)/);
                const r = parseInt(match[1]);
                const g = parseInt(match[2]);
                const b = parseInt(match[3]);

                const idx = i * 4;
                imageData.data[idx] = r;
                imageData.data[idx + 1] = g;
                imageData.data[idx + 2] = b;
                imageData.data[idx + 3] = 255;
            }

            ctx.putImageData(imageData, 0, 0);

            document.getElementById('gen-stat').textContent = generation;

            // FPS calculation
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = now;
                document.getElementById('fps-stat').textContent = fps;
            }
        }

        function animate() {
            if (running) {
                step();
                draw();
            }

            if (delay > 0) {
                setTimeout(() => requestAnimationFrame(animate), delay);
            } else {
                requestAnimationFrame(animate);
            }
        }

        function preset(name) {
            switch (name) {
                case 'perfect':
                    range = 1; threshold = 3; numStates = 4; neighborhoodType = 'moore';
                    break;
                case 'diamond':
                    range = 1; threshold = 1; numStates = 15; neighborhoodType = 'neumann';
                    break;
                case 'cyclic':
                    range = 3; threshold = 5; numStates = 8; neighborhoodType = 'moore';
                    break;
                case 'turbulent':
                    range = 2; threshold = 5; numStates = 8; neighborhoodType = 'moore';
                    break;
                case 'amoeba':
                    range = 2; threshold = 10; numStates = 16; neighborhoodType = 'moore';
                    break;
                case 'crystal':
                    range = 1; threshold = 2; numStates = 6; neighborhoodType = 'neumann';
                    break;
            }

            updateControls();
            generatePalette();
            initGrid();
            updateRuleStat();
        }

        function updateControls() {
            document.getElementById('range').value = range;
            document.getElementById('threshold').value = threshold;
            document.getElementById('states').value = numStates;
            document.getElementById('neighborhood').value = neighborhoodType;
            document.getElementById('range-val').textContent = range;
            document.getElementById('threshold-val').textContent = threshold;
            document.getElementById('states-val').textContent = numStates;
        }

        function updateRuleStat() {
            const n = neighborhoodType === 'moore' ? 'M' : 'N';
            document.getElementById('rule-stat').textContent = `${range}/${threshold}/${numStates}/${n}`;
        }

        function updatePalette() {
            palette = document.getElementById('palette').value;
            generatePalette();
        }

        window.updatePalette = updatePalette;

        function toggleRun() {
            running = !running;
            document.getElementById('run-btn').textContent = running ? 'Pause' : 'Run';
        }

        function reset() {
            initGrid();
        }

        window.preset = preset;
        window.toggleRun = toggleRun;
        window.reset = reset;

        function setupControls() {
            document.getElementById('range').addEventListener('input', (e) => {
                range = parseInt(e.target.value);
                document.getElementById('range-val').textContent = range;
                updateRuleStat();
            });
            document.getElementById('threshold').addEventListener('input', (e) => {
                threshold = parseInt(e.target.value);
                document.getElementById('threshold-val').textContent = threshold;
                updateRuleStat();
            });
            document.getElementById('states').addEventListener('input', (e) => {
                numStates = parseInt(e.target.value);
                document.getElementById('states-val').textContent = numStates;
                generatePalette();
                initGrid();
                updateRuleStat();
            });
            document.getElementById('neighborhood').addEventListener('change', (e) => {
                neighborhoodType = e.target.value;
                updateRuleStat();
            });
            document.getElementById('size').addEventListener('input', (e) => {
                gridSize = parseInt(e.target.value);
                document.getElementById('size-val').textContent = gridSize;
                resize();
                initGrid();
            });
            document.getElementById('delay').addEventListener('input', (e) => {
                delay = parseInt(e.target.value);
                document.getElementById('delay-val').textContent = delay;
            });
        }

        window.addEventListener('resize', resize);

        setupControls();
        generatePalette();
        resize();
        initGrid();
        updateRuleStat();
        animate();
    </script>
</body>
</html>
