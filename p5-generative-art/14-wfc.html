<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wave Function Collapse - P5.js Generative Art - CCAB</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #0a0e1a; }
        .back-link {
            position: fixed; top: 10px; left: 10px; padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7); color: #ec4899; text-decoration: none;
            border-radius: 6px; font-size: 14px; z-index: 999;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        .back-link:hover { background: rgba(236, 72, 153, 0.2); }
        .controls {
            position: fixed; top: 10px; right: 10px; background: rgba(0, 0, 0, 0.7);
            padding: 15px; border-radius: 8px; color: #e8e6e1;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 12px; z-index: 999;
        }
        .controls label { display: block; margin-bottom: 8px; }
        #loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ec4899; font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }
        .spinner {
            width: 50px; height: 50px; border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: #ec4899; border-radius: 50%; animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to P5.js Gallery</a>
    <div id="loading"><div class="spinner"></div><p>Loading...</p></div>
    <div class="controls">
        <label>Speed: <input type="range" id="speed" min="1" max="20" value="5"></label>
        <div>Status: <span id="status">Running...</span></div>
        <button onclick="reset()" style="margin-top: 10px; padding: 5px 10px; cursor: pointer;">Reset</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        // Simple tile-based WFC with pipes/circuit pattern
        const TILE_SIZE = 30;
        let cols, rows;
        let grid = [];
        let speed = 5;

        // Tile definitions: [top, right, bottom, left] edges
        // 0 = empty, 1 = connection
        const tiles = [
            { edges: [0, 0, 0, 0], color: [10, 20, 30] },      // Empty
            { edges: [1, 1, 1, 1], color: [236, 72, 153] },    // Cross
            { edges: [1, 0, 1, 0], color: [180, 100, 200] },   // Vertical
            { edges: [0, 1, 0, 1], color: [180, 100, 200] },   // Horizontal
            { edges: [1, 1, 0, 0], color: [100, 150, 200] },   // Corner TL
            { edges: [0, 1, 1, 0], color: [100, 150, 200] },   // Corner TR
            { edges: [0, 0, 1, 1], color: [100, 150, 200] },   // Corner BR
            { edges: [1, 0, 0, 1], color: [100, 150, 200] },   // Corner BL
            { edges: [1, 0, 0, 0], color: [150, 80, 150] },    // End T
            { edges: [0, 1, 0, 0], color: [150, 80, 150] },    // End R
            { edges: [0, 0, 1, 0], color: [150, 80, 150] },    // End B
            { edges: [0, 0, 0, 1], color: [150, 80, 150] },    // End L
        ];

        class Cell {
            constructor() {
                this.collapsed = false;
                this.options = [...Array(tiles.length).keys()];
            }
        }

        function checkValid(options, validOptions) {
            return options.filter(opt => validOptions.includes(opt));
        }

        function reset() {
            cols = floor(width / TILE_SIZE);
            rows = floor(height / TILE_SIZE);
            grid = [];

            for (let i = 0; i < cols * rows; i++) {
                grid[i] = new Cell();
            }
            document.getElementById('status').textContent = 'Running...';
            loop();
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            document.getElementById('loading').style.display = 'none';

            document.getElementById('speed').addEventListener('input', (e) => {
                speed = parseInt(e.target.value);
            });

            reset();
        }

        function draw() {
            background(10, 14, 26);

            // Draw grid
            for (let j = 0; j < rows; j++) {
                for (let i = 0; i < cols; i++) {
                    let cell = grid[i + j * cols];
                    if (cell.collapsed) {
                        let tile = tiles[cell.options[0]];
                        fill(tile.color[0], tile.color[1], tile.color[2]);
                        noStroke();
                        rect(i * TILE_SIZE, j * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                        // Draw connections
                        stroke(255);
                        strokeWeight(3);
                        let cx = i * TILE_SIZE + TILE_SIZE / 2;
                        let cy = j * TILE_SIZE + TILE_SIZE / 2;
                        let edges = tile.edges;

                        if (edges[0]) line(cx, cy, cx, j * TILE_SIZE);
                        if (edges[1]) line(cx, cy, (i + 1) * TILE_SIZE, cy);
                        if (edges[2]) line(cx, cy, cx, (j + 1) * TILE_SIZE);
                        if (edges[3]) line(cx, cy, i * TILE_SIZE, cy);
                    } else {
                        // Show entropy
                        let entropy = cell.options.length;
                        fill(40, 40, 50);
                        noStroke();
                        rect(i * TILE_SIZE, j * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        fill(100);
                        textSize(10);
                        textAlign(CENTER, CENTER);
                        text(entropy, i * TILE_SIZE + TILE_SIZE / 2, j * TILE_SIZE + TILE_SIZE / 2);
                    }
                }
            }

            // WFC step
            for (let s = 0; s < speed; s++) {
                // Find cell with lowest entropy
                let minEntropy = Infinity;
                let minCells = [];

                for (let i = 0; i < grid.length; i++) {
                    let cell = grid[i];
                    if (!cell.collapsed && cell.options.length > 0) {
                        if (cell.options.length < minEntropy) {
                            minEntropy = cell.options.length;
                            minCells = [i];
                        } else if (cell.options.length === minEntropy) {
                            minCells.push(i);
                        }
                    }
                }

                if (minCells.length === 0) {
                    document.getElementById('status').textContent = 'Complete!';
                    noLoop();
                    return;
                }

                // Collapse random cell with lowest entropy
                let idx = random(minCells);
                let cell = grid[floor(idx)];
                if (cell.options.length === 0) {
                    document.getElementById('status').textContent = 'Contradiction! Reset.';
                    noLoop();
                    return;
                }
                cell.collapsed = true;
                cell.options = [random(cell.options)];

                // Propagate constraints
                propagate();
            }
        }

        function propagate() {
            let changed = true;
            while (changed) {
                changed = false;
                for (let j = 0; j < rows; j++) {
                    for (let i = 0; i < cols; i++) {
                        let idx = i + j * cols;
                        let cell = grid[idx];
                        if (cell.collapsed) continue;

                        let newOptions = [...cell.options];

                        // Check each neighbor
                        // Top
                        if (j > 0) {
                            let neighbor = grid[i + (j - 1) * cols];
                            let validEdges = neighbor.options.map(o => tiles[o].edges[2]);
                            newOptions = newOptions.filter(o => validEdges.includes(tiles[o].edges[0]));
                        }
                        // Right
                        if (i < cols - 1) {
                            let neighbor = grid[(i + 1) + j * cols];
                            let validEdges = neighbor.options.map(o => tiles[o].edges[3]);
                            newOptions = newOptions.filter(o => validEdges.includes(tiles[o].edges[1]));
                        }
                        // Bottom
                        if (j < rows - 1) {
                            let neighbor = grid[i + (j + 1) * cols];
                            let validEdges = neighbor.options.map(o => tiles[o].edges[0]);
                            newOptions = newOptions.filter(o => validEdges.includes(tiles[o].edges[2]));
                        }
                        // Left
                        if (i > 0) {
                            let neighbor = grid[(i - 1) + j * cols];
                            let validEdges = neighbor.options.map(o => tiles[o].edges[1]);
                            newOptions = newOptions.filter(o => validEdges.includes(tiles[o].edges[3]));
                        }

                        if (newOptions.length < cell.options.length) {
                            cell.options = newOptions;
                            changed = true;
                        }
                    }
                }
            }
        }

        // Expose for enhance.js
        window.reset = function() { reset(); loop(); };

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            reset();
        }
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
