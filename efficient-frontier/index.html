<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Portfolio Efficient Frontier</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; }
#title { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); color: #fbbf24; font-size: 20px; font-weight: 700; z-index: 999; text-shadow: 0 0 20px rgba(251,191,36,0.5); font-family: sans-serif; }
#controls { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); display: flex; gap: 14px; z-index: 999; background: rgba(0,0,0,0.75); padding: 12px 20px; border-radius: 10px; align-items: center; flex-wrap: wrap; justify-content: center; }
#controls label { color: #ccc; font-size: 11px; display: flex; flex-direction: column; align-items: center; gap: 2px; }
#controls input[type=range] { width: 100px; accent-color: #fbbf24; }
#controls span { color: #fbbf24; font-size: 11px; }
#controls button { background: rgba(251,191,36,0.2); color: #fbbf24; border: 1px solid #fbbf24; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-size: 11px; }
#controls button:hover { background: rgba(251,191,36,0.4); }
#legend { position: fixed; top: 50px; right: 15px; color: #ccc; font-size: 11px; z-index: 999; background: rgba(0,0,0,0.65); padding: 10px; border-radius: 8px; line-height: 1.8; }
.leg-item { display: flex; align-items: center; gap: 6px; }
.leg-dot { width: 8px; height: 8px; border-radius: 50%; }
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">‚Üê Back to Gallery</a>
<div id="title">Portfolio Efficient Frontier</div>
<div id="legend"></div>
<canvas id="canvas"></canvas>
<div id="controls">
    <label>Risk-Free Rate (%) <input type="range" id="rf" min="0" max="8" step="0.25" value="2"><span id="rfVal">2.0%</span></label>
    <label>Num Assets <input type="range" id="numAssets" min="3" max="12" step="1" value="6"><span id="numVal">6</span></label>
    <button id="btnRegen">Regenerate Assets</button>
    <button id="btnMore">+1000 Portfolios</button>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

const rfSlider = document.getElementById('rf');
const numSlider = document.getElementById('numAssets');

rfSlider.oninput = () => document.getElementById('rfVal').textContent = rfSlider.value + '%';
numSlider.oninput = () => { document.getElementById('numVal').textContent = numSlider.value; generateAssets(); };

const assetColors = ['#4ade80','#60a5fa','#f472b6','#fbbf24','#a78bfa','#f97316','#22d3ee','#e879f9','#84cc16','#fb923c','#38bdf8','#f43f5e'];
const assetNames = ['Tech','Health','Energy','Finance','Consumer','Industrial','Materials','Utilities','Real Estate','Telecom','Crypto','Commodities'];

let assets = [];
let portfolios = [];
let frontierPortfolios = [];
let maxPortfolios = 3000;
let generating = false;

function generateAssets() {
    const n = parseInt(numSlider.value);
    assets = [];
    for (let i = 0; i < n; i++) {
        assets.push({
            name: assetNames[i],
            color: assetColors[i],
            expectedReturn: 0.02 + Math.random() * 0.18, // 2-20%
            volatility: 0.05 + Math.random() * 0.35, // 5-40%
        });
    }

    // Generate correlation matrix (simplified - use random but ensure positive semi-definite-ish)
    const corr = [];
    for (let i = 0; i < n; i++) {
        corr[i] = [];
        for (let j = 0; j < n; j++) {
            if (i === j) corr[i][j] = 1;
            else if (j < i) corr[i][j] = corr[j][i];
            else corr[i][j] = -0.3 + Math.random() * 0.8;
        }
    }

    assets.corr = corr;
    portfolios = [];
    frontierPortfolios = [];
    updateLegend();
    generatePortfolios(2000);
}

function updateLegend() {
    const legendEl = document.getElementById('legend');
    legendEl.innerHTML = '<div style="margin-bottom:4px;color:#fbbf24;font-weight:bold;">Assets</div>';
    assets.forEach(a => {
        const div = document.createElement('div');
        div.className = 'leg-item';
        div.innerHTML = `<div class="leg-dot" style="background:${a.color}"></div>${a.name} (R:${(a.expectedReturn*100).toFixed(1)}%, V:${(a.volatility*100).toFixed(1)}%)`;
        legendEl.appendChild(div);
    });
}

function portfolioStats(weights) {
    const n = assets.length;
    let ret = 0;
    for (let i = 0; i < n; i++) ret += weights[i] * assets[i].expectedReturn;

    let variance = 0;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            variance += weights[i] * weights[j] * assets[i].volatility * assets[j].volatility * assets.corr[i][j];
        }
    }

    return { ret, risk: Math.sqrt(Math.max(0, variance)) };
}

function randomWeights() {
    const n = assets.length;
    const w = [];
    let sum = 0;
    for (let i = 0; i < n; i++) {
        w[i] = Math.random();
        sum += w[i];
    }
    for (let i = 0; i < n; i++) w[i] /= sum;
    return w;
}

function generatePortfolios(count) {
    for (let i = 0; i < count; i++) {
        const w = randomWeights();
        const stats = portfolioStats(w);
        portfolios.push({ weights: w, ret: stats.ret, risk: stats.risk });
    }

    // Find efficient frontier
    findFrontier();
}

function findFrontier() {
    // Sort by risk, then find the envelope
    const sorted = [...portfolios].sort((a, b) => a.risk - b.risk);
    frontierPortfolios = [];

    const numBins = 100;
    const minRisk = sorted[0].risk;
    const maxRisk = sorted[sorted.length - 1].risk;
    const binWidth = (maxRisk - minRisk) / numBins;

    for (let b = 0; b < numBins; b++) {
        const riskLow = minRisk + b * binWidth;
        const riskHigh = riskLow + binWidth;
        const inBin = sorted.filter(p => p.risk >= riskLow && p.risk < riskHigh);
        if (inBin.length > 0) {
            const best = inBin.reduce((a, b) => a.ret > b.ret ? a : b);
            frontierPortfolios.push(best);
        }
    }
}

document.getElementById('btnRegen').onclick = generateAssets;
document.getElementById('btnMore').onclick = () => generatePortfolios(1000);

function draw() {
    const W = canvas.width, H = canvas.height;
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    if (assets.length === 0) {
        requestAnimationFrame(draw);
        return;
    }

    const rf = parseFloat(rfSlider.value) / 100;

    // Chart area
    const chartLeft = W * 0.10;
    const chartRight = W * 0.75;
    const chartTop = H * 0.10;
    const chartBottom = H * 0.82;
    const chartW = chartRight - chartLeft;
    const chartH = chartBottom - chartTop;

    // Find ranges
    let minRisk = Infinity, maxRisk = 0, minRet = Infinity, maxRet = 0;
    portfolios.forEach(p => {
        if (p.risk < minRisk) minRisk = p.risk;
        if (p.risk > maxRisk) maxRisk = p.risk;
        if (p.ret < minRet) minRet = p.ret;
        if (p.ret > maxRet) maxRet = p.ret;
    });
    assets.forEach(a => {
        if (a.volatility > maxRisk) maxRisk = a.volatility;
        if (a.expectedReturn > maxRet) maxRet = a.expectedReturn;
    });
    minRisk = 0;
    minRet = Math.min(0, minRet);
    maxRisk *= 1.15;
    maxRet *= 1.15;

    const mapX = (risk) => chartLeft + ((risk - minRisk) / (maxRisk - minRisk)) * chartW;
    const mapY = (ret) => chartBottom - ((ret - minRet) / (maxRet - minRet)) * chartH;

    // Grid
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 10; i++) {
        const x = chartLeft + (chartW / 10) * i;
        ctx.beginPath(); ctx.moveTo(x, chartTop); ctx.lineTo(x, chartBottom); ctx.stroke();
        const y = chartTop + (chartH / 10) * i;
        ctx.beginPath(); ctx.moveTo(chartLeft, y); ctx.lineTo(chartRight, y); ctx.stroke();
    }

    // Axes
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(chartLeft, chartTop);
    ctx.lineTo(chartLeft, chartBottom);
    ctx.lineTo(chartRight, chartBottom);
    ctx.stroke();

    // Axis labels
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Risk (Std. Dev.)', chartLeft + chartW / 2, chartBottom + 35);
    ctx.save();
    ctx.translate(chartLeft - 45, chartTop + chartH / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Expected Return', 0, 0);
    ctx.restore();

    // Tick labels
    ctx.font = '9px sans-serif';
    ctx.textAlign = 'right';
    for (let i = 0; i <= 5; i++) {
        const ret = minRet + ((maxRet - minRet) / 5) * i;
        ctx.fillText((ret * 100).toFixed(1) + '%', chartLeft - 5, mapY(ret) + 3);
    }
    ctx.textAlign = 'center';
    for (let i = 0; i <= 5; i++) {
        const risk = minRisk + ((maxRisk - minRisk) / 5) * i;
        ctx.fillText((risk * 100).toFixed(1) + '%', mapX(risk), chartBottom + 15);
    }

    // Draw random portfolios
    portfolios.forEach(p => {
        ctx.beginPath();
        ctx.arc(mapX(p.risk), mapY(p.ret), 2, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        ctx.fill();
    });

    // Draw efficient frontier
    if (frontierPortfolios.length > 1) {
        // Filled area below frontier
        ctx.beginPath();
        frontierPortfolios.forEach((p, i) => {
            const x = mapX(p.risk), y = mapY(p.ret);
            if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        });
        const lastFP = frontierPortfolios[frontierPortfolios.length - 1];
        ctx.lineTo(mapX(lastFP.risk), chartBottom);
        ctx.lineTo(mapX(frontierPortfolios[0].risk), chartBottom);
        ctx.closePath();
        ctx.fillStyle = 'rgba(74,222,128,0.04)';
        ctx.fill();

        // Frontier line
        ctx.beginPath();
        ctx.strokeStyle = '#4ade80';
        ctx.lineWidth = 3;
        frontierPortfolios.forEach((p, i) => {
            const x = mapX(p.risk), y = mapY(p.ret);
            if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        });
        ctx.stroke();

        // Glow
        ctx.beginPath();
        ctx.strokeStyle = '#4ade80';
        ctx.lineWidth = 8;
        ctx.globalAlpha = 0.15;
        frontierPortfolios.forEach((p, i) => {
            const x = mapX(p.risk), y = mapY(p.ret);
            if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        });
        ctx.stroke();
        ctx.globalAlpha = 1;

        // Frontier dots
        frontierPortfolios.forEach(p => {
            ctx.beginPath();
            ctx.arc(mapX(p.risk), mapY(p.ret), 3, 0, Math.PI * 2);
            ctx.fillStyle = '#4ade80';
            ctx.fill();
        });

        // Capital Market Line (from risk-free to tangent portfolio)
        // Find tangent portfolio (max Sharpe ratio)
        let bestSharpe = -Infinity;
        let tangentPort = null;
        frontierPortfolios.forEach(p => {
            const sharpe = (p.ret - rf) / p.risk;
            if (sharpe > bestSharpe) {
                bestSharpe = sharpe;
                tangentPort = p;
            }
        });

        if (tangentPort) {
            // CML line
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(251,191,36,0.6)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            const cmlSlope = (tangentPort.ret - rf) / tangentPort.risk;
            ctx.moveTo(mapX(0), mapY(rf));
            const endRisk = maxRisk;
            const endRet = rf + cmlSlope * endRisk;
            ctx.lineTo(mapX(endRisk), mapY(endRet));
            ctx.stroke();
            ctx.setLineDash([]);

            // Tangent portfolio marker
            ctx.beginPath();
            ctx.arc(mapX(tangentPort.risk), mapY(tangentPort.ret), 7, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(251,191,36,0.4)';
            ctx.fill();
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = '#fbbf24';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Tangent Portfolio', mapX(tangentPort.risk) + 10, mapY(tangentPort.ret) - 5);
            ctx.font = '9px sans-serif';
            ctx.fillText('Sharpe: ' + bestSharpe.toFixed(2), mapX(tangentPort.risk) + 10, mapY(tangentPort.ret) + 8);

            // Risk-free point
            ctx.beginPath();
            ctx.arc(mapX(0), mapY(rf), 5, 0, Math.PI * 2);
            ctx.fillStyle = '#fbbf24';
            ctx.fill();
            ctx.fillText('Rf = ' + (rf * 100).toFixed(1) + '%', mapX(0) + 8, mapY(rf) + 4);

            // CML label
            ctx.fillStyle = 'rgba(251,191,36,0.5)';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Capital Market Line', mapX(endRisk * 0.7), mapY(rf + cmlSlope * endRisk * 0.7) - 10);
        }
    }

    // Draw individual assets (large dots)
    assets.forEach((a, i) => {
        ctx.beginPath();
        ctx.arc(mapX(a.volatility), mapY(a.expectedReturn), 8, 0, Math.PI * 2);
        ctx.fillStyle = a.color;
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.fillStyle = a.color;
        ctx.font = 'bold 10px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(a.name, mapX(a.volatility) + 12, mapY(a.expectedReturn) + 4);
    });

    // Legend labels
    ctx.fillStyle = '#4ade80';
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Efficient Frontier', chartLeft + 10, chartTop + 15);
    ctx.fillStyle = 'rgba(251,191,36,0.7)';
    ctx.fillText('Capital Market Line', chartLeft + 10, chartTop + 30);
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.font = '10px sans-serif';
    ctx.fillText(portfolios.length + ' random portfolios', chartLeft + 10, chartTop + 45);

    // Minimum variance portfolio marker
    if (frontierPortfolios.length > 0) {
        const mvp = frontierPortfolios.reduce((a, b) => a.risk < b.risk ? a : b);
        ctx.beginPath();
        ctx.arc(mapX(mvp.risk), mapY(mvp.ret), 6, 0, Math.PI * 2);
        ctx.strokeStyle = '#22d3ee';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = '#22d3ee';
        ctx.font = '9px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText('Min Variance', mapX(mvp.risk) - 10, mapY(mvp.ret) + 4);
    }

    requestAnimationFrame(draw);
}

generateAssets();
requestAnimationFrame(draw);
</script>
</body>
</html>
