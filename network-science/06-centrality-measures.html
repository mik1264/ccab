<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centrality Measures | Network Science</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 20px; border-radius: 15px;
            min-width: 300px;
            border: 1px solid rgba(150, 200, 255, 0.3);
        }
        h1 { color: #96c8ff; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        select { width: 100%; padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #96c8ff; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #96c8ff; color: #0a0a1a;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #b4daff; }
        .centrality-tabs { display: flex; gap: 5px; flex-wrap: wrap; margin: 10px 0; }
        .tab {
            flex: 1; min-width: 70px;
            padding: 8px 5px; border: none; border-radius: 5px;
            background: rgba(150, 200, 255, 0.1);
            color: #96c8ff; cursor: pointer;
            font-size: 0.8em; text-align: center;
            transition: all 0.2s;
        }
        .tab.active { background: #96c8ff; color: #0a0a1a; }
        .tab:hover:not(.active) { background: rgba(150, 200, 255, 0.2); }
        .top-nodes { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .top-node { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.85em; }
        .node-id { color: #96c8ff; }
        .node-value { color: #aaa; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #96c8ff; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        .centrality-desc { font-size: 0.85em; color: #888; margin: 10px 0; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Network Science</a>

    <div class="controls">
        <h1>Centrality Measures</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Compare different ways to identify important nodes</p>

        <div class="control-group">
            <label>Network Type</label>
            <select id="networkType">
                <option value="barabasi">Scale-Free (BA)</option>
                <option value="random">Random (ER)</option>
                <option value="grid">Grid Lattice</option>
                <option value="star">Star Network</option>
            </select>
        </div>

        <div class="centrality-tabs">
            <button class="tab active" data-centrality="degree">Degree</button>
            <button class="tab" data-centrality="betweenness">Between.</button>
            <button class="tab" data-centrality="closeness">Close.</button>
            <button class="tab" data-centrality="eigenvector">Eigen.</button>
            <button class="tab" data-centrality="pagerank">PageRank</button>
        </div>

        <div class="centrality-desc" id="centralityDesc">
            <strong>Degree Centrality:</strong> Number of direct connections. Simple but effective for finding highly connected hubs.
        </div>

        <button id="generateBtn">Generate Network</button>
        <button id="compareBtn">Compare All</button>

        <div class="top-nodes">
            <div style="font-size:0.9em; color:#96c8ff; margin-bottom:10px;">Top 5 Most Central Nodes:</div>
            <div id="topNodesList"></div>
        </div>

        <div class="info">
            <strong>Node size</strong> = centrality value<br>
            <strong>Node color</strong> = centrality gradient (yellow = high)
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let centralities = {};
        let currentCentrality = 'degree';

        const descriptions = {
            degree: '<strong>Degree Centrality:</strong> Number of direct connections. Simple but effective for finding highly connected hubs.',
            betweenness: '<strong>Betweenness Centrality:</strong> How often a node lies on shortest paths between others. Identifies bridges and gatekeepers.',
            closeness: '<strong>Closeness Centrality:</strong> Average distance to all other nodes. Central nodes can reach everyone quickly.',
            eigenvector: '<strong>Eigenvector Centrality:</strong> Connections weighted by how central neighbors are. Being connected to important nodes matters.',
            pagerank: '<strong>PageRank:</strong> Google\'s algorithm - probability of random walk arriving here. Fame through famous connections.'
        };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        function generateBarabasi(n = 80, m = 2) {
            nodes = [];
            edges = [];

            const cx = (canvas.width - 320) / 2;
            const cy = canvas.height / 2;

            for (let i = 0; i <= m; i++) {
                nodes.push({ id: i, x: cx + Math.random() * 200 - 100, y: cy + Math.random() * 200 - 100, vx: 0, vy: 0 });
            }

            for (let i = 0; i <= m; i++) {
                for (let j = i + 1; j <= m; j++) {
                    edges.push({ source: i, target: j });
                }
            }

            for (let i = m + 1; i < n; i++) {
                nodes.push({ id: i, x: cx + Math.random() * 400 - 200, y: cy + Math.random() * 400 - 200, vx: 0, vy: 0 });

                const totalDegree = edges.length * 2;
                const targets = new Set();

                while (targets.size < m) {
                    let r = Math.random() * totalDegree;
                    for (let j = 0; j < i; j++) {
                        const deg = edges.filter(e => e.source === j || e.target === j).length;
                        r -= deg;
                        if (r <= 0) { targets.add(j); break; }
                    }
                }

                targets.forEach(t => edges.push({ source: i, target: t }));
            }
        }

        function generateRandom(n = 80, p = 0.05) {
            nodes = [];
            edges = [];

            const cx = (canvas.width - 320) / 2;
            const cy = canvas.height / 2;

            for (let i = 0; i < n; i++) {
                const angle = (i / n) * Math.PI * 2;
                nodes.push({ id: i, x: cx + Math.cos(angle) * 200, y: cy + Math.sin(angle) * 200, vx: 0, vy: 0 });
            }

            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    if (Math.random() < p) edges.push({ source: i, target: j });
                }
            }
        }

        function generateGrid(size = 8) {
            nodes = [];
            edges = [];

            const cx = (canvas.width - 320) / 2;
            const cy = canvas.height / 2;
            const spacing = 50;

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const id = i * size + j;
                    nodes.push({
                        id,
                        x: cx + (j - size/2) * spacing,
                        y: cy + (i - size/2) * spacing,
                        vx: 0, vy: 0
                    });

                    if (j > 0) edges.push({ source: id, target: id - 1 });
                    if (i > 0) edges.push({ source: id, target: id - size });
                }
            }
        }

        function generateStar(n = 30) {
            nodes = [];
            edges = [];

            const cx = (canvas.width - 320) / 2;
            const cy = canvas.height / 2;

            nodes.push({ id: 0, x: cx, y: cy, vx: 0, vy: 0 });

            for (let i = 1; i < n; i++) {
                const angle = (i / (n-1)) * Math.PI * 2;
                nodes.push({ id: i, x: cx + Math.cos(angle) * 200, y: cy + Math.sin(angle) * 200, vx: 0, vy: 0 });
                edges.push({ source: 0, target: i });
            }
        }

        function calculateDegree() {
            const deg = {};
            nodes.forEach(n => deg[n.id] = 0);
            edges.forEach(e => {
                deg[e.source]++;
                deg[e.target]++;
            });
            return deg;
        }

        function calculateBetweenness() {
            const bc = {};
            nodes.forEach(n => bc[n.id] = 0);

            const adj = nodes.map(() => []);
            edges.forEach(e => {
                adj[e.source].push(e.target);
                adj[e.target].push(e.source);
            });

            for (let s = 0; s < nodes.length; s++) {
                const stack = [];
                const pred = nodes.map(() => []);
                const sigma = new Array(nodes.length).fill(0);
                sigma[s] = 1;
                const dist = new Array(nodes.length).fill(-1);
                dist[s] = 0;

                const queue = [s];
                while (queue.length > 0) {
                    const v = queue.shift();
                    stack.push(v);

                    for (const w of adj[v]) {
                        if (dist[w] < 0) {
                            queue.push(w);
                            dist[w] = dist[v] + 1;
                        }
                        if (dist[w] === dist[v] + 1) {
                            sigma[w] += sigma[v];
                            pred[w].push(v);
                        }
                    }
                }

                const delta = new Array(nodes.length).fill(0);
                while (stack.length > 0) {
                    const w = stack.pop();
                    for (const v of pred[w]) {
                        delta[v] += (sigma[v] / sigma[w]) * (1 + delta[w]);
                    }
                    if (w !== s) bc[w] += delta[w];
                }
            }

            // Normalize
            const n = nodes.length;
            const norm = (n - 1) * (n - 2);
            Object.keys(bc).forEach(k => bc[k] /= norm);

            return bc;
        }

        function calculateCloseness() {
            const cc = {};
            const adj = nodes.map(() => []);
            edges.forEach(e => {
                adj[e.source].push(e.target);
                adj[e.target].push(e.source);
            });

            nodes.forEach((_, s) => {
                const dist = new Array(nodes.length).fill(Infinity);
                dist[s] = 0;
                const queue = [s];

                while (queue.length > 0) {
                    const v = queue.shift();
                    for (const w of adj[v]) {
                        if (dist[w] === Infinity) {
                            dist[w] = dist[v] + 1;
                            queue.push(w);
                        }
                    }
                }

                const totalDist = dist.filter(d => d !== Infinity && d > 0).reduce((a, b) => a + b, 0);
                cc[s] = totalDist > 0 ? (nodes.length - 1) / totalDist : 0;
            });

            return cc;
        }

        function calculateEigenvector(iterations = 100) {
            const ec = {};
            let x = nodes.map(() => 1);

            const adj = nodes.map(() => []);
            edges.forEach(e => {
                adj[e.source].push(e.target);
                adj[e.target].push(e.source);
            });

            for (let iter = 0; iter < iterations; iter++) {
                const newX = nodes.map((_, i) => {
                    return adj[i].reduce((sum, j) => sum + x[j], 0);
                });

                const norm = Math.sqrt(newX.reduce((s, v) => s + v * v, 0)) || 1;
                x = newX.map(v => v / norm);
            }

            nodes.forEach((n, i) => ec[n.id] = x[i]);
            return ec;
        }

        function calculatePageRank(damping = 0.85, iterations = 50) {
            const pr = {};
            const n = nodes.length;
            let scores = nodes.map(() => 1 / n);

            const adj = nodes.map(() => []);
            const outDegree = nodes.map(() => 0);

            edges.forEach(e => {
                adj[e.target].push(e.source);
                adj[e.source].push(e.target);
                outDegree[e.source]++;
                outDegree[e.target]++;
            });

            for (let iter = 0; iter < iterations; iter++) {
                const newScores = nodes.map((_, i) => {
                    let sum = 0;
                    for (const j of adj[i]) {
                        sum += scores[j] / (outDegree[j] || 1);
                    }
                    return (1 - damping) / n + damping * sum;
                });
                scores = newScores;
            }

            nodes.forEach((node, i) => pr[node.id] = scores[i]);
            return pr;
        }

        function calculateAllCentralities() {
            centralities = {
                degree: calculateDegree(),
                betweenness: calculateBetweenness(),
                closeness: calculateCloseness(),
                eigenvector: calculateEigenvector(),
                pagerank: calculatePageRank()
            };
            updateTopNodes();
        }

        function updateTopNodes() {
            const c = centralities[currentCentrality];
            if (!c) return;

            const sorted = Object.entries(c).sort((a, b) => b[1] - a[1]).slice(0, 5);

            const list = document.getElementById('topNodesList');
            list.innerHTML = sorted.map(([id, val], i) => `
                <div class="top-node">
                    <span class="node-id">${i + 1}. Node ${id}</span>
                    <span class="node-value">${val.toFixed(4)}</span>
                </div>
            `).join('');
        }

        function applyForces() {
            const k = Math.sqrt((canvas.width * canvas.height) / nodes.length) * 0.3;

            nodes.forEach(n => { n.vx = 0; n.vy = 0; });

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = k * k / dist * 0.2;

                    nodes[i].vx -= (dx / dist) * force;
                    nodes[i].vy -= (dy / dist) * force;
                    nodes[j].vx += (dx / dist) * force;
                    nodes[j].vy += (dy / dist) * force;
                }
            }

            edges.forEach(e => {
                const source = nodes[e.source];
                const target = nodes[e.target];
                const dx = target.x - source.x;
                const dy = target.y - source.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                const force = dist / k * 0.3;

                source.vx += (dx / dist) * force;
                source.vy += (dy / dist) * force;
                target.vx -= (dx / dist) * force;
                target.vy -= (dy / dist) * force;
            });

            const cx = (canvas.width - 320) / 2;
            const cy = canvas.height / 2;
            nodes.forEach(n => {
                n.vx += (cx - n.x) * 0.005;
                n.vy += (cy - n.y) * 0.005;
                n.x += n.vx * 0.1;
                n.y += n.vy * 0.1;
                n.x = Math.max(50, Math.min(canvas.width - 370, n.x));
                n.y = Math.max(50, Math.min(canvas.height - 50, n.y));
            });
        }

        function draw() {
            ctx.fillStyle = 'rgba(10, 10, 26, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const c = centralities[currentCentrality] || {};
            const values = Object.values(c);
            const maxC = Math.max(...values, 0.001);
            const minC = Math.min(...values, 0);

            // Draw edges
            ctx.strokeStyle = 'rgba(150, 200, 255, 0.15)';
            ctx.lineWidth = 1;
            edges.forEach(e => {
                ctx.beginPath();
                ctx.moveTo(nodes[e.source].x, nodes[e.source].y);
                ctx.lineTo(nodes[e.target].x, nodes[e.target].y);
                ctx.stroke();
            });

            // Draw nodes
            nodes.forEach(node => {
                const val = c[node.id] || 0;
                const norm = (val - minC) / (maxC - minC);
                const size = 4 + norm * 16;

                // Color gradient: blue (low) -> yellow (high)
                const r = Math.floor(150 + norm * 105);
                const g = Math.floor(200 + norm * 55);
                const b = Math.floor(255 - norm * 200);

                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fill();

                // Glow for top nodes
                if (norm > 0.7) {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, size + 5, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.2)`;
                    ctx.fill();
                }
            });
        }

        function animate() {
            applyForces();
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('networkType').onchange = (e) => {
            const type = e.target.value;
            if (type === 'barabasi') generateBarabasi();
            else if (type === 'random') generateRandom();
            else if (type === 'grid') generateGrid();
            else if (type === 'star') generateStar();
            calculateAllCentralities();
        };

        document.querySelectorAll('.tab').forEach(tab => {
            tab.onclick = () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                currentCentrality = tab.dataset.centrality;
                document.getElementById('centralityDesc').innerHTML = descriptions[currentCentrality];
                updateTopNodes();
            };
        });

        document.getElementById('generateBtn').onclick = () => {
            const type = document.getElementById('networkType').value;
            if (type === 'barabasi') generateBarabasi();
            else if (type === 'random') generateRandom();
            else if (type === 'grid') generateGrid();
            else if (type === 'star') generateStar();
            calculateAllCentralities();
        };

        document.getElementById('compareBtn').onclick = () => {
            // Cycle through centralities
            const order = ['degree', 'betweenness', 'closeness', 'eigenvector', 'pagerank'];
            let i = 0;

            const cycle = () => {
                currentCentrality = order[i];
                document.querySelectorAll('.tab').forEach(t => {
                    t.classList.toggle('active', t.dataset.centrality === currentCentrality);
                });
                document.getElementById('centralityDesc').innerHTML = descriptions[currentCentrality];
                updateTopNodes();
                i++;
                if (i < order.length) setTimeout(cycle, 1500);
            };

            cycle();
        };

        // Initialize
        generateBarabasi();
        calculateAllCentralities();
        animate();
    </script>
</body>
</html>
