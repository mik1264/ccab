<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Community Detection - Network Science</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #eee; min-height: 100vh; padding: 20px; }
        .back-link { position: fixed; top: 20px; left: 20px; color: #4ade80; text-decoration: none; font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px; z-index: 100; }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #4ade80; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(74, 222, 128, 0.1); border: 1px solid rgba(74, 222, 128, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #4ade80; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #0a0a15; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input, .control-group select { width: 100%; padding: 8px; border-radius: 6px; }
        .value-display { color: #4ade80; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #4ade80; color: #1a1a2e; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .community-list { max-height: 200px; overflow-y: auto; }
        .community-item { display: flex; align-items: center; gap: 10px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 6px; margin: 5px 0; }
        .community-color { width: 20px; height: 20px; border-radius: 50%; }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <h1>Community Detection</h1>
    <p class="subtitle">Modularity optimization and clustering</p>

    <div class="container">
        <div class="panel">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>

        <div class="panel">
            <div class="info-box">
                <strong>Community Detection:</strong>
                Find groups of densely connected nodes.
                <b>Modularity</b> measures quality of partition.
                <b>Louvain algorithm</b> greedily optimizes modularity.
                Communities represent functional groups in networks.
            </div>

            <h3>Algorithm</h3>
            <div class="control-group">
                <select id="algorithmSelect">
                    <option value="louvain">Louvain (Modularity)</option>
                    <option value="label">Label Propagation</option>
                    <option value="spectral">Spectral Clustering</option>
                </select>
            </div>

            <div class="control-group">
                <label>Nodes: <span class="value-display" id="nVal">60</span></label>
                <input type="range" id="nSlider" min="30" max="100" value="60" oninput="updateParam()">
            </div>

            <div class="control-group">
                <label>Communities: <span class="value-display" id="kVal">4</span></label>
                <input type="range" id="kSlider" min="2" max="8" value="4" oninput="updateParam()">
            </div>

            <div class="control-group">
                <label>Inter-community edges: <span class="value-display" id="pVal">10%</span></label>
                <input type="range" id="pSlider" min="5" max="40" value="10" oninput="updateParam()">
            </div>

            <button class="btn-primary" onclick="generateNetwork()">Generate Network</button>
            <button class="btn-secondary" onclick="detectCommunities()">Detect Communities</button>
            <button class="btn-secondary" onclick="showGroundTruth()">Show Ground Truth</button>

            <h3 style="margin-top: 15px;">Modularity: <span class="value-display" id="modularity">0.00</span></h3>

            <h3>Detected Communities</h3>
            <div class="community-list" id="communityList"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let n = 60;
        let k = 4; // Number of true communities
        let interProb = 0.1;
        let showTruth = false;

        const colors = ['#4ade80', '#f87171', '#22d3ee', '#facc15', '#a78bfa', '#f472b6', '#fb923c', '#6366f1'];

        function updateParam() {
            n = parseInt(document.getElementById('nSlider').value);
            k = parseInt(document.getElementById('kSlider').value);
            interProb = parseInt(document.getElementById('pSlider').value) / 100;
            document.getElementById('nVal').textContent = n;
            document.getElementById('kVal').textContent = k;
            document.getElementById('pVal').textContent = Math.round(interProb * 100) + '%';
        }

        function generateNetwork() {
            nodes = [];
            edges = [];
            showTruth = false;

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            // Create nodes with ground truth communities
            const communitySize = Math.floor(n / k);
            for (let i = 0; i < n; i++) {
                const community = Math.min(Math.floor(i / communitySize), k - 1);
                const angle = (2 * Math.PI * community) / k;
                const r = 150;
                const jitter = 50;

                nodes.push({
                    id: i,
                    trueCommunity: community,
                    detectedCommunity: 0,
                    x: cx + r * Math.cos(angle) + (Math.random() - 0.5) * jitter * 2,
                    y: cy + r * Math.sin(angle) + (Math.random() - 0.5) * jitter * 2,
                    vx: 0, vy: 0
                });
            }

            // Create edges - dense within communities, sparse between
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const sameComm = nodes[i].trueCommunity === nodes[j].trueCommunity;
                    const prob = sameComm ? 0.4 : interProb;

                    if (Math.random() < prob) {
                        edges.push([i, j]);
                    }
                }
            }

            // Initialize all to same community
            nodes.forEach(n => n.detectedCommunity = 0);

            layoutNetwork();
            calculateModularity();
            updateCommunityList();
            draw();
        }

        function layoutNetwork() {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            for (let iter = 0; iter < 100; iter++) {
                // Repulsion
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const dx = nodes[j].x - nodes[i].x;
                        const dy = nodes[j].y - nodes[i].y;
                        const dist = Math.max(Math.sqrt(dx * dx + dy * dy), 1);
                        const force = 3000 / (dist * dist);
                        nodes[i].vx -= (dx / dist) * force;
                        nodes[i].vy -= (dy / dist) * force;
                        nodes[j].vx += (dx / dist) * force;
                        nodes[j].vy += (dy / dist) * force;
                    }
                }

                // Attraction along edges
                for (const [i, j] of edges) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const force = (dist - 50) * 0.05;
                    nodes[i].vx += (dx / dist) * force;
                    nodes[i].vy += (dy / dist) * force;
                    nodes[j].vx -= (dx / dist) * force;
                    nodes[j].vy -= (dy / dist) * force;
                }

                // Center gravity
                nodes.forEach(node => {
                    node.vx += (cx - node.x) * 0.005;
                    node.vy += (cy - node.y) * 0.005;
                    node.x += node.vx * 0.1;
                    node.y += node.vy * 0.1;
                    node.vx *= 0.9;
                    node.vy *= 0.9;
                });
            }
        }

        function detectCommunities() {
            const algorithm = document.getElementById('algorithmSelect').value;
            showTruth = false;

            if (algorithm === 'louvain') {
                louvainAlgorithm();
            } else if (algorithm === 'label') {
                labelPropagation();
            } else {
                spectralClustering();
            }

            calculateModularity();
            updateCommunityList();
            draw();
        }

        function louvainAlgorithm() {
            // Initialize each node in its own community
            nodes.forEach((n, i) => n.detectedCommunity = i);

            let improved = true;
            let iterations = 0;

            while (improved && iterations < 100) {
                improved = false;
                iterations++;

                for (const node of nodes) {
                    const currentComm = node.detectedCommunity;
                    let bestComm = currentComm;
                    let bestGain = 0;

                    // Get neighbor communities
                    const neighborComms = new Set();
                    edges.forEach(([i, j]) => {
                        if (i === node.id) neighborComms.add(nodes[j].detectedCommunity);
                        if (j === node.id) neighborComms.add(nodes[i].detectedCommunity);
                    });

                    // Try moving to each neighbor community
                    for (const comm of neighborComms) {
                        if (comm === currentComm) continue;
                        const gain = calculateModularityGain(node, comm);
                        if (gain > bestGain) {
                            bestGain = gain;
                            bestComm = comm;
                        }
                    }

                    if (bestComm !== currentComm) {
                        node.detectedCommunity = bestComm;
                        improved = true;
                    }
                }
            }

            // Renumber communities
            renumberCommunities();
        }

        function calculateModularityGain(node, newComm) {
            // Simplified modularity gain calculation
            const m = edges.length;
            let ki = 0; // Degree of node
            let kiIn = 0; // Edges to new community
            let sumIn = 0; // Total degree in new community

            edges.forEach(([i, j]) => {
                if (i === node.id || j === node.id) {
                    ki++;
                    const other = i === node.id ? nodes[j] : nodes[i];
                    if (other.detectedCommunity === newComm) kiIn++;
                }
            });

            nodes.forEach(n => {
                if (n.detectedCommunity === newComm) {
                    edges.forEach(([i, j]) => {
                        if (i === n.id || j === n.id) sumIn++;
                    });
                }
            });

            return (kiIn / m) - (ki * sumIn) / (2 * m * m);
        }

        function labelPropagation() {
            // Initialize with unique labels
            nodes.forEach((n, i) => n.detectedCommunity = i);

            for (let iter = 0; iter < 20; iter++) {
                const order = [...nodes].sort(() => Math.random() - 0.5);

                for (const node of order) {
                    const neighborLabels = {};
                    edges.forEach(([i, j]) => {
                        if (i === node.id) {
                            const label = nodes[j].detectedCommunity;
                            neighborLabels[label] = (neighborLabels[label] || 0) + 1;
                        }
                        if (j === node.id) {
                            const label = nodes[i].detectedCommunity;
                            neighborLabels[label] = (neighborLabels[label] || 0) + 1;
                        }
                    });

                    if (Object.keys(neighborLabels).length > 0) {
                        const maxCount = Math.max(...Object.values(neighborLabels));
                        const maxLabels = Object.keys(neighborLabels).filter(l => neighborLabels[l] === maxCount);
                        node.detectedCommunity = parseInt(maxLabels[Math.floor(Math.random() * maxLabels.length)]);
                    }
                }
            }

            renumberCommunities();
        }

        function spectralClustering() {
            // Simplified: just use k-means on positions
            // (Real spectral clustering would use eigenvectors of Laplacian)
            const centroids = [];
            for (let i = 0; i < k; i++) {
                centroids.push({
                    x: nodes[Math.floor(Math.random() * n)].x,
                    y: nodes[Math.floor(Math.random() * n)].y
                });
            }

            for (let iter = 0; iter < 20; iter++) {
                // Assign to nearest centroid
                nodes.forEach(node => {
                    let minDist = Infinity;
                    centroids.forEach((c, i) => {
                        const dist = Math.sqrt(Math.pow(node.x - c.x, 2) + Math.pow(node.y - c.y, 2));
                        if (dist < minDist) {
                            minDist = dist;
                            node.detectedCommunity = i;
                        }
                    });
                });

                // Update centroids
                centroids.forEach((c, i) => {
                    const members = nodes.filter(n => n.detectedCommunity === i);
                    if (members.length > 0) {
                        c.x = members.reduce((s, n) => s + n.x, 0) / members.length;
                        c.y = members.reduce((s, n) => s + n.y, 0) / members.length;
                    }
                });
            }
        }

        function renumberCommunities() {
            const commMap = {};
            let nextComm = 0;
            nodes.forEach(n => {
                if (!(n.detectedCommunity in commMap)) {
                    commMap[n.detectedCommunity] = nextComm++;
                }
                n.detectedCommunity = commMap[n.detectedCommunity];
            });
        }

        function calculateModularity() {
            const m = edges.length;
            if (m === 0) {
                document.getElementById('modularity').textContent = '0.00';
                return;
            }

            const degrees = nodes.map(() => 0);
            edges.forEach(([i, j]) => { degrees[i]++; degrees[j]++; });

            let Q = 0;
            edges.forEach(([i, j]) => {
                const comm = showTruth ? 'trueCommunity' : 'detectedCommunity';
                if (nodes[i][comm] === nodes[j][comm]) {
                    Q += 1 - (degrees[i] * degrees[j]) / (2 * m);
                }
            });

            Q /= m;
            document.getElementById('modularity').textContent = Q.toFixed(3);
        }

        function updateCommunityList() {
            const comm = showTruth ? 'trueCommunity' : 'detectedCommunity';
            const counts = {};
            nodes.forEach(n => {
                counts[n[comm]] = (counts[n[comm]] || 0) + 1;
            });

            const list = document.getElementById('communityList');
            list.innerHTML = Object.entries(counts)
                .sort((a, b) => b[1] - a[1])
                .map(([c, count]) => `
                    <div class="community-item">
                        <div class="community-color" style="background: ${colors[c % colors.length]}"></div>
                        <span>Community ${parseInt(c) + 1}: ${count} nodes</span>
                    </div>
                `).join('');
        }

        function showGroundTruth() {
            showTruth = true;
            calculateModularity();
            updateCommunityList();
            draw();
        }

        function draw() {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const comm = showTruth ? 'trueCommunity' : 'detectedCommunity';

            // Draw edges
            for (const [i, j] of edges) {
                const sameComm = nodes[i][comm] === nodes[j][comm];
                ctx.strokeStyle = sameComm ? colors[nodes[i][comm] % colors.length] + '60' : 'rgba(255,255,255,0.1)';
                ctx.lineWidth = sameComm ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(nodes[i].x, nodes[i].y);
                ctx.lineTo(nodes[j].x, nodes[j].y);
                ctx.stroke();
            }

            // Draw nodes
            for (const node of nodes) {
                ctx.fillStyle = colors[node[comm] % colors.length];
                ctx.beginPath();
                ctx.arc(node.x, node.y, 8, 0, Math.PI * 2);
                ctx.fill();
            }

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText(showTruth ? 'Ground Truth Communities' : 'Detected Communities', 20, 30);
        }

        updateParam();
        generateNetwork();
    </script>
</body>
</html>
