<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Small World Networks - Network Science</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #eee; min-height: 100vh; padding: 20px; }
        .back-link { position: fixed; top: 20px; left: 20px; color: #4ade80; text-decoration: none; font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px; z-index: 100; }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #4ade80; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 320px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(74, 222, 128, 0.1); border: 1px solid rgba(74, 222, 128, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #4ade80; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #0a0a15; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input { width: 100%; }
        .value-display { color: #4ade80; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #4ade80; color: #1a1a2e; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .metrics-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0; }
        .metric-box { background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; text-align: center; }
        .metric-value { font-size: 1.5em; color: #4ade80; }
        .metric-label { font-size: 0.75em; opacity: 0.7; }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <h1>Small World Networks</h1>
    <p class="subtitle">Watts-Strogatz model - high clustering, short paths</p>

    <div class="container">
        <div class="panel">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>

        <div class="panel">
            <div class="info-box">
                <strong>Small World Networks (Watts & Strogatz, 1998):</strong>
                Start with a ring lattice where each node connects to k neighbors.
                With probability p, rewire each edge to a random node.
                Low p = high clustering, high path length.
                High p = random graph.
                Intermediate p = "small world" with both high clustering AND short paths.
            </div>

            <h3>Parameters</h3>

            <div class="control-group">
                <label>Nodes (n): <span class="value-display" id="nVal">30</span></label>
                <input type="range" id="nSlider" min="10" max="60" value="30" oninput="updateParam()">
            </div>

            <div class="control-group">
                <label>Neighbors (k): <span class="value-display" id="kVal">4</span></label>
                <input type="range" id="kSlider" min="2" max="10" step="2" value="4" oninput="updateParam()">
            </div>

            <div class="control-group">
                <label>Rewiring Probability (p): <span class="value-display" id="pVal">0.00</span></label>
                <input type="range" id="pSlider" min="0" max="100" value="0" oninput="updateParam()">
            </div>

            <button class="btn-primary" onclick="generateNetwork()">Generate Network</button>
            <button class="btn-secondary" onclick="animateRewiring()">Animate Rewiring</button>

            <h3 style="margin-top: 20px;">Network Metrics</h3>
            <div class="metrics-grid">
                <div class="metric-box">
                    <div class="metric-value" id="clustering">0.00</div>
                    <div class="metric-label">Clustering Coefficient</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value" id="pathLength">0.00</div>
                    <div class="metric-label">Avg Path Length</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value" id="edges">0</div>
                    <div class="metric-label">Edges</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value" id="diameter">0</div>
                    <div class="metric-label">Diameter</div>
                </div>
            </div>

            <canvas id="metricsCanvas" width="300" height="150"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const metricsCanvas = document.getElementById('metricsCanvas');
        const mctx = metricsCanvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let n = 30, k = 4, p = 0;
        let metricsHistory = [];

        function updateParam() {
            n = parseInt(document.getElementById('nSlider').value);
            k = parseInt(document.getElementById('kSlider').value);
            p = parseInt(document.getElementById('pSlider').value) / 100;
            document.getElementById('nVal').textContent = n;
            document.getElementById('kVal').textContent = k;
            document.getElementById('pVal').textContent = p.toFixed(2);
            generateNetwork();
        }

        function generateNetwork() {
            nodes = [];
            edges = [];

            // Create ring lattice
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const radius = Math.min(cx, cy) - 50;

            for (let i = 0; i < n; i++) {
                const angle = (2 * Math.PI * i) / n - Math.PI / 2;
                nodes.push({
                    id: i,
                    x: cx + radius * Math.cos(angle),
                    y: cy + radius * Math.sin(angle),
                    neighbors: new Set()
                });
            }

            // Add edges to k/2 neighbors on each side
            for (let i = 0; i < n; i++) {
                for (let j = 1; j <= k / 2; j++) {
                    const neighbor = (i + j) % n;
                    addEdge(i, neighbor);
                }
            }

            // Rewire with probability p
            const edgesToRewire = [...edges];
            for (const edge of edgesToRewire) {
                if (Math.random() < p) {
                    const [i, j] = edge;
                    // Find new target
                    let newTarget;
                    let attempts = 0;
                    do {
                        newTarget = Math.floor(Math.random() * n);
                        attempts++;
                    } while ((newTarget === i || nodes[i].neighbors.has(newTarget)) && attempts < 100);

                    if (attempts < 100) {
                        removeEdge(i, j);
                        addEdge(i, newTarget);
                    }
                }
            }

            calculateMetrics();
            draw();
        }

        function addEdge(i, j) {
            if (i > j) [i, j] = [j, i];
            const key = `${i}-${j}`;
            if (!edges.some(e => e[0] === i && e[1] === j)) {
                edges.push([i, j]);
                nodes[i].neighbors.add(j);
                nodes[j].neighbors.add(i);
            }
        }

        function removeEdge(i, j) {
            if (i > j) [i, j] = [j, i];
            edges = edges.filter(e => !(e[0] === i && e[1] === j));
            nodes[i].neighbors.delete(j);
            nodes[j].neighbors.delete(i);
        }

        function calculateMetrics() {
            // Clustering coefficient
            let totalClustering = 0;
            for (const node of nodes) {
                const neighbors = [...node.neighbors];
                if (neighbors.length < 2) continue;

                let triangles = 0;
                for (let i = 0; i < neighbors.length; i++) {
                    for (let j = i + 1; j < neighbors.length; j++) {
                        if (nodes[neighbors[i]].neighbors.has(neighbors[j])) {
                            triangles++;
                        }
                    }
                }
                const possible = (neighbors.length * (neighbors.length - 1)) / 2;
                totalClustering += triangles / possible;
            }
            const clustering = totalClustering / n;

            // Average path length (BFS)
            let totalPath = 0;
            let pathCount = 0;
            let maxPath = 0;

            for (let i = 0; i < n; i++) {
                const dist = bfs(i);
                for (let j = i + 1; j < n; j++) {
                    if (dist[j] < Infinity) {
                        totalPath += dist[j];
                        pathCount++;
                        maxPath = Math.max(maxPath, dist[j]);
                    }
                }
            }

            const avgPath = pathCount > 0 ? totalPath / pathCount : 0;

            document.getElementById('clustering').textContent = clustering.toFixed(3);
            document.getElementById('pathLength').textContent = avgPath.toFixed(2);
            document.getElementById('edges').textContent = edges.length;
            document.getElementById('diameter').textContent = maxPath;

            metricsHistory.push({ p, clustering, avgPath });
            if (metricsHistory.length > 20) metricsHistory.shift();
            drawMetricsChart();
        }

        function bfs(start) {
            const dist = new Array(n).fill(Infinity);
            dist[start] = 0;
            const queue = [start];

            while (queue.length > 0) {
                const curr = queue.shift();
                for (const neighbor of nodes[curr].neighbors) {
                    if (dist[neighbor] === Infinity) {
                        dist[neighbor] = dist[curr] + 1;
                        queue.push(neighbor);
                    }
                }
            }
            return dist;
        }

        function draw() {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw edges
            ctx.strokeStyle = 'rgba(74, 222, 128, 0.3)';
            ctx.lineWidth = 1;
            for (const [i, j] of edges) {
                ctx.beginPath();
                ctx.moveTo(nodes[i].x, nodes[i].y);
                ctx.lineTo(nodes[j].x, nodes[j].y);
                ctx.stroke();
            }

            // Draw nodes
            for (const node of nodes) {
                const degree = node.neighbors.size;
                const size = 5 + degree;

                ctx.fillStyle = '#4ade80';
                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(node.id, node.x, node.y + 3);
            }

            // Title
            ctx.fillStyle = '#4ade80';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`Watts-Strogatz Network (n=${n}, k=${k}, p=${p.toFixed(2)})`, 20, 30);
        }

        function drawMetricsChart() {
            mctx.fillStyle = '#0a0a15';
            mctx.fillRect(0, 0, metricsCanvas.width, metricsCanvas.height);

            if (metricsHistory.length < 2) return;

            // Normalize values
            const maxC = Math.max(...metricsHistory.map(h => h.clustering), 0.1);
            const maxL = Math.max(...metricsHistory.map(h => h.avgPath), 1);

            const w = metricsCanvas.width - 40;
            const h = metricsCanvas.height - 30;

            // Draw clustering line
            mctx.strokeStyle = '#4ade80';
            mctx.lineWidth = 2;
            mctx.beginPath();
            metricsHistory.forEach((d, i) => {
                const x = 30 + (i / (metricsHistory.length - 1)) * w;
                const y = 10 + h * (1 - d.clustering / maxC);
                if (i === 0) mctx.moveTo(x, y);
                else mctx.lineTo(x, y);
            });
            mctx.stroke();

            // Draw path length line
            mctx.strokeStyle = '#22d3ee';
            mctx.beginPath();
            metricsHistory.forEach((d, i) => {
                const x = 30 + (i / (metricsHistory.length - 1)) * w;
                const y = 10 + h * (1 - d.avgPath / maxL);
                if (i === 0) mctx.moveTo(x, y);
                else mctx.lineTo(x, y);
            });
            mctx.stroke();

            // Legend
            mctx.font = '10px sans-serif';
            mctx.fillStyle = '#4ade80';
            mctx.fillText('Clustering', 35, 20);
            mctx.fillStyle = '#22d3ee';
            mctx.fillText('Path Length', 100, 20);
        }

        async function animateRewiring() {
            metricsHistory = [];
            for (let pVal = 0; pVal <= 100; pVal += 5) {
                p = pVal / 100;
                document.getElementById('pSlider').value = pVal;
                document.getElementById('pVal').textContent = p.toFixed(2);
                generateNetwork();
                await new Promise(r => setTimeout(r, 200));
            }
        }

        generateNetwork();
    </script>
</body>
</html>
