<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Graphs - Network Science</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #eee; min-height: 100vh; padding: 20px; }
        .back-link { position: fixed; top: 20px; left: 20px; color: #4ade80; text-decoration: none; font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px; z-index: 100; }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #4ade80; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(74, 222, 128, 0.1); border: 1px solid rgba(74, 222, 128, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #4ade80; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #0a0a15; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input { width: 100%; }
        .value-display { color: #4ade80; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #4ade80; color: #1a1a2e; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0; }
        .stat-box { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 12px; text-align: center; }
        .stat-value { font-size: 1.3em; font-weight: bold; color: #4ade80; }
        .stat-label { font-size: 0.75em; opacity: 0.8; margin-top: 3px; }
        .phase-indicator { padding: 10px; border-radius: 8px; text-align: center; font-weight: 600; margin: 10px 0; }
        .subcritical { background: rgba(96, 165, 250, 0.2); color: #60a5fa; }
        .critical { background: rgba(250, 204, 21, 0.2); color: #facc15; }
        .supercritical { background: rgba(74, 222, 128, 0.2); color: #4ade80; }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <h1>Random Graphs</h1>
    <p class="subtitle">Erd≈ës-R√©nyi model and phase transitions</p>

    <div class="container">
        <div class="panel">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>

        <div class="panel">
            <div class="info-box">
                <strong>Erd≈ës-R√©nyi Random Graph G(n,p):</strong>
                Each edge exists with probability p. At the critical point p = 1/n,
                a giant component emerges. This phase transition is one of the
                most fundamental results in random graph theory.
            </div>

            <div class="phase-indicator" id="phaseIndicator">Subcritical Phase</div>

            <h3>Parameters</h3>
            <div class="control-group">
                <label>Number of Nodes (n): <span class="value-display" id="nVal">60</span></label>
                <input type="range" id="nSlider" min="30" max="100" value="60" oninput="updateParam()">
            </div>

            <div class="control-group">
                <label>Edge Probability (p): <span class="value-display" id="pVal">0.017</span></label>
                <input type="range" id="pSlider" min="0" max="100" value="17" oninput="updateParam()">
            </div>

            <div class="control-group">
                <label>Critical p = 1/n: <span class="value-display" id="criticalP">0.017</span></label>
            </div>

            <button class="btn-primary" onclick="generateGraph()">Generate Graph</button>
            <button class="btn-secondary" onclick="animateTransition()">Animate Phase Transition</button>

            <h3 style="margin-top: 15px;">Network Statistics</h3>
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-value" id="numEdges">0</div>
                    <div class="stat-label">Edges</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="numComponents">0</div>
                    <div class="stat-label">Components</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="giantSize">0</div>
                    <div class="stat-label">Giant Component</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="avgDegree">0.0</div>
                    <div class="stat-label">Avg Degree</div>
                </div>
            </div>

            <h3 style="margin-top: 10px;">Giant Component vs p</h3>
            <canvas id="chartCanvas" width="280" height="120"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const chartCanvas = document.getElementById('chartCanvas');
        const cctx = chartCanvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let n = 60;
        let p = 0.017;
        let components = [];
        let transitionHistory = [];
        let running = false;

        function updateParam() {
            n = parseInt(document.getElementById('nSlider').value);
            p = parseInt(document.getElementById('pSlider').value) / (n * 60); // Scale with n
            document.getElementById('nVal').textContent = n;
            document.getElementById('pVal').textContent = p.toFixed(4);
            document.getElementById('criticalP').textContent = (1 / n).toFixed(4);

            updatePhaseIndicator();
        }

        function updatePhaseIndicator() {
            const critical = 1 / n;
            const indicator = document.getElementById('phaseIndicator');

            if (p < critical * 0.8) {
                indicator.textContent = 'üîµ Subcritical Phase (p < 1/n)';
                indicator.className = 'phase-indicator subcritical';
            } else if (p > critical * 1.2) {
                indicator.textContent = 'üü¢ Supercritical Phase (p > 1/n)';
                indicator.className = 'phase-indicator supercritical';
            } else {
                indicator.textContent = 'üü° Critical Phase (p ‚âà 1/n)';
                indicator.className = 'phase-indicator critical';
            }
        }

        function generateGraph() {
            nodes = [];
            edges = [];

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            // Create nodes
            for (let i = 0; i < n; i++) {
                const angle = (2 * Math.PI * i) / n;
                const r = 220;
                nodes.push({
                    id: i,
                    x: cx + r * Math.cos(angle),
                    y: cy + r * Math.sin(angle),
                    degree: 0,
                    component: -1,
                    vx: 0, vy: 0
                });
            }

            // Create edges with probability p
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    if (Math.random() < p) {
                        edges.push([i, j]);
                        nodes[i].degree++;
                        nodes[j].degree++;
                    }
                }
            }

            findComponents();
            layoutNetwork();
            updateStats();
            draw();
        }

        function findComponents() {
            components = [];
            nodes.forEach(n => n.component = -1);
            let componentId = 0;

            function bfs(start) {
                const component = [start];
                const queue = [start];
                nodes[start].component = componentId;

                while (queue.length > 0) {
                    const nodeId = queue.shift();
                    for (const [i, j] of edges) {
                        let neighbor = null;
                        if (i === nodeId && nodes[j].component === -1) neighbor = j;
                        if (j === nodeId && nodes[i].component === -1) neighbor = i;
                        if (neighbor !== null) {
                            nodes[neighbor].component = componentId;
                            component.push(neighbor);
                            queue.push(neighbor);
                        }
                    }
                }
                return component;
            }

            for (let i = 0; i < n; i++) {
                if (nodes[i].component === -1) {
                    const component = bfs(i);
                    components.push(component);
                    componentId++;
                }
            }

            // Sort by size (largest first)
            components.sort((a, b) => b.length - a.length);
        }

        function layoutNetwork() {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            // Position components in clusters
            if (components.length > 1) {
                const giant = components[0];
                const giantCx = cx;
                const giantCy = cy;

                // Position giant component nodes
                giant.forEach((nodeId, i) => {
                    const angle = (2 * Math.PI * i) / giant.length;
                    const r = Math.min(150, 30 + giant.length * 2);
                    nodes[nodeId].x = giantCx + r * Math.cos(angle) + (Math.random() - 0.5) * 20;
                    nodes[nodeId].y = giantCy + r * Math.sin(angle) + (Math.random() - 0.5) * 20;
                });

                // Position smaller components around the edge
                for (let c = 1; c < components.length; c++) {
                    const comp = components[c];
                    const angle = (2 * Math.PI * c) / Math.max(components.length - 1, 1);
                    const compCx = cx + 250 * Math.cos(angle);
                    const compCy = cy + 250 * Math.sin(angle);

                    comp.forEach((nodeId, i) => {
                        const nodeAngle = (2 * Math.PI * i) / comp.length;
                        const r = Math.min(30, 10 + comp.length * 3);
                        nodes[nodeId].x = compCx + r * Math.cos(nodeAngle);
                        nodes[nodeId].y = compCy + r * Math.sin(nodeAngle);
                    });
                }
            }

            // Force-directed refinement
            for (let iter = 0; iter < 30; iter++) {
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (nodes[i].component !== nodes[j].component) continue;
                        const dx = nodes[j].x - nodes[i].x;
                        const dy = nodes[j].y - nodes[i].y;
                        const dist = Math.max(Math.sqrt(dx * dx + dy * dy), 1);
                        const force = 1000 / (dist * dist);
                        nodes[i].vx -= (dx / dist) * force;
                        nodes[i].vy -= (dy / dist) * force;
                        nodes[j].vx += (dx / dist) * force;
                        nodes[j].vy += (dy / dist) * force;
                    }
                }

                for (const [i, j] of edges) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const force = (dist - 40) * 0.15;
                    nodes[i].vx += (dx / dist) * force;
                    nodes[i].vy += (dy / dist) * force;
                    nodes[j].vx -= (dx / dist) * force;
                    nodes[j].vy -= (dy / dist) * force;
                }

                nodes.forEach(node => {
                    node.x += node.vx * 0.1;
                    node.y += node.vy * 0.1;
                    node.vx *= 0.8;
                    node.vy *= 0.8;
                    // Keep in bounds
                    node.x = Math.max(30, Math.min(canvas.width - 30, node.x));
                    node.y = Math.max(30, Math.min(canvas.height - 30, node.y));
                });
            }
        }

        function updateStats() {
            const giantSize = components.length > 0 ? components[0].length : 0;
            const totalDegree = nodes.reduce((s, n) => s + n.degree, 0);
            const avgDegree = n > 0 ? totalDegree / n : 0;

            document.getElementById('numEdges').textContent = edges.length;
            document.getElementById('numComponents').textContent = components.length;
            document.getElementById('giantSize').textContent = giantSize + ' (' + (giantSize / n * 100).toFixed(0) + '%)';
            document.getElementById('avgDegree').textContent = avgDegree.toFixed(2);
        }

        async function animateTransition() {
            if (running) {
                running = false;
                return;
            }
            running = true;
            transitionHistory = [];

            const steps = 50;
            for (let i = 0; i <= steps && running; i++) {
                p = (i / steps) * (3 / n); // Go from 0 to 3/n
                document.getElementById('pSlider').value = p * n * 60;
                document.getElementById('pVal').textContent = p.toFixed(4);
                updatePhaseIndicator();

                generateGraph();

                const giantSize = components.length > 0 ? components[0].length / n : 0;
                transitionHistory.push({ p, giantSize });
                drawChart();

                await new Promise(r => setTimeout(r, 100));
            }

            running = false;
        }

        function draw() {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Color palette for components
            const colors = ['#4ade80', '#60a5fa', '#f472b6', '#facc15', '#c084fc', '#fb923c', '#22d3d8'];

            // Draw edges
            for (const [i, j] of edges) {
                const comp = nodes[i].component;
                ctx.strokeStyle = comp === 0 ? 'rgba(74, 222, 128, 0.5)' : 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = comp === 0 ? 1.5 : 1;
                ctx.beginPath();
                ctx.moveTo(nodes[i].x, nodes[i].y);
                ctx.lineTo(nodes[j].x, nodes[j].y);
                ctx.stroke();
            }

            // Draw nodes
            for (const node of nodes) {
                const comp = node.component;
                const isGiant = comp === 0 && components[0].length > n * 0.1;
                const color = isGiant ? colors[0] : colors[Math.min(comp, colors.length - 1)];
                const size = isGiant ? 6 + node.degree : 4 + node.degree * 0.5;

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Labels
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText(`n = ${n}, p = ${p.toFixed(4)}`, 20, 30);
            ctx.fillText(`Critical p = ${(1/n).toFixed(4)}`, 20, 50);

            const ratio = p * n;
            ctx.fillText(`p √ó n = ${ratio.toFixed(2)} (giant emerges at ~1)`, 20, 70);
        }

        function drawChart() {
            cctx.fillStyle = '#0a0a15';
            cctx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);

            // Draw critical line
            const criticalX = (1 / n) / (3 / n) * chartCanvas.width;
            cctx.strokeStyle = 'rgba(250, 204, 21, 0.5)';
            cctx.setLineDash([5, 5]);
            cctx.beginPath();
            cctx.moveTo(criticalX, 0);
            cctx.lineTo(criticalX, chartCanvas.height);
            cctx.stroke();
            cctx.setLineDash([]);

            if (transitionHistory.length < 2) {
                cctx.fillStyle = '#fff';
                cctx.font = '10px sans-serif';
                cctx.fillText('Click "Animate Phase Transition"', 5, 60);
                return;
            }

            // Draw curve
            cctx.strokeStyle = '#4ade80';
            cctx.lineWidth = 2;
            cctx.beginPath();
            transitionHistory.forEach((h, i) => {
                const x = (h.p / (3 / n)) * chartCanvas.width;
                const y = chartCanvas.height - h.giantSize * chartCanvas.height;
                if (i === 0) cctx.moveTo(x, y);
                else cctx.lineTo(x, y);
            });
            cctx.stroke();

            // Current position
            const currentX = (p / (3 / n)) * chartCanvas.width;
            const currentGiant = components.length > 0 ? components[0].length / n : 0;
            const currentY = chartCanvas.height - currentGiant * chartCanvas.height;
            cctx.fillStyle = '#f87171';
            cctx.beginPath();
            cctx.arc(currentX, currentY, 5, 0, Math.PI * 2);
            cctx.fill();

            // Labels
            cctx.fillStyle = '#fff';
            cctx.font = '9px sans-serif';
            cctx.fillText('p ‚Üí', chartCanvas.width - 20, chartCanvas.height - 5);
            cctx.fillText('Giant', 5, 12);
        }

        updateParam();
        generateGraph();
        drawChart();
    </script>
</body>
</html>
