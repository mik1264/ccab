<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Visualization Layouts | Network Science</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; cursor: grab; }
        #canvas:active { cursor: grabbing; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(200, 150, 255, 0.3);
        }
        h1 { color: #c896ff; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        select, input[type="range"] { width: 100%; }
        select { padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #c896ff; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #c896ff; color: #0a0a1a;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #dcb4ff; }
        .layout-tabs { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin: 10px 0; }
        .tab {
            padding: 8px 5px; border: none; border-radius: 5px;
            background: rgba(200, 150, 255, 0.1);
            color: #c896ff; cursor: pointer;
            font-size: 0.8em; text-align: center;
        }
        .tab.active { background: #c896ff; color: #0a0a1a; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #c896ff; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #c896ff; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Network Science</a>

    <div class="controls">
        <h1>Network Layouts</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Compare different graph visualization algorithms</p>

        <div class="control-group">
            <label>Network Type</label>
            <select id="networkType">
                <option value="barabasi">Scale-Free</option>
                <option value="random">Random</option>
                <option value="tree">Tree</option>
                <option value="grid">Grid</option>
            </select>
        </div>

        <div class="control-group">
            <label>Nodes: <span class="value" id="nodeValue">60</span></label>
            <input type="range" id="nodeCount" min="20" max="150" value="60">
        </div>

        <div class="layout-tabs">
            <button class="tab active" data-layout="force">Force-Directed</button>
            <button class="tab" data-layout="circular">Circular</button>
            <button class="tab" data-layout="radial">Radial</button>
            <button class="tab" data-layout="hierarchical">Hierarchical</button>
            <button class="tab" data-layout="spectral">Spectral</button>
            <button class="tab" data-layout="random">Random</button>
        </div>

        <button id="generateBtn">Generate Network</button>
        <button id="applyLayoutBtn">Apply Layout</button>
        <button id="animateBtn">Animate Transition</button>

        <div class="control-group">
            <label>Force Strength: <span class="value" id="forceValue">1.0</span></label>
            <input type="range" id="forceStrength" min="0.1" max="3" step="0.1" value="1">
        </div>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="statsNodes">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="statsEdges">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Layout</span>
                <span class="stat-value" id="statsLayout">Force</span>
            </div>
        </div>

        <div class="info">
            <strong>Drag nodes</strong> to manually adjust positions.<br><br>
            Different layouts reveal different network structures - try each one!
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let layout = 'force';
        let dragging = null;
        let forceStrength = 1;
        let animating = false;
        let targetPositions = {};

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        const cx = () => (canvas.width - 300) / 2;
        const cy = () => canvas.height / 2;

        function generateBarabasi(n, m = 2) {
            nodes = [];
            edges = [];

            for (let i = 0; i <= m; i++) {
                nodes.push({ id: i, x: cx() + Math.random() * 100 - 50, y: cy() + Math.random() * 100 - 50, vx: 0, vy: 0 });
            }

            for (let i = 0; i <= m; i++) {
                for (let j = i + 1; j <= m; j++) {
                    edges.push({ source: i, target: j });
                }
            }

            for (let i = m + 1; i < n; i++) {
                nodes.push({ id: i, x: cx() + Math.random() * 200 - 100, y: cy() + Math.random() * 200 - 100, vx: 0, vy: 0 });

                const degrees = nodes.slice(0, i).map(n => edges.filter(e => e.source === n.id || e.target === n.id).length);
                const totalDegree = degrees.reduce((a, b) => a + b, 0);
                const targets = new Set();

                while (targets.size < m) {
                    let r = Math.random() * totalDegree;
                    for (let j = 0; j < i; j++) {
                        r -= degrees[j];
                        if (r <= 0) { targets.add(j); break; }
                    }
                }

                targets.forEach(t => edges.push({ source: i, target: t }));
            }
        }

        function generateRandom(n, p = 0.05) {
            nodes = [];
            edges = [];

            for (let i = 0; i < n; i++) {
                nodes.push({ id: i, x: cx() + Math.random() * 200 - 100, y: cy() + Math.random() * 200 - 100, vx: 0, vy: 0 });
            }

            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    if (Math.random() < p) edges.push({ source: i, target: j });
                }
            }
        }

        function generateTree(n) {
            nodes = [];
            edges = [];

            for (let i = 0; i < n; i++) {
                nodes.push({ id: i, x: cx() + Math.random() * 200 - 100, y: cy() + Math.random() * 200 - 100, vx: 0, vy: 0, depth: 0 });
                if (i > 0) {
                    const parent = Math.floor((i - 1) / 2);
                    edges.push({ source: parent, target: i });
                    nodes[i].parent = parent;
                    nodes[i].depth = nodes[parent].depth + 1;
                }
            }
        }

        function generateGrid(size = 8) {
            nodes = [];
            edges = [];

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const id = i * size + j;
                    nodes.push({ id, x: cx() + Math.random() * 200 - 100, y: cy() + Math.random() * 200 - 100, vx: 0, vy: 0, row: i, col: j });

                    if (j > 0) edges.push({ source: id, target: id - 1 });
                    if (i > 0) edges.push({ source: id, target: id - size });
                }
            }
        }

        function applyForceLayout() {
            const k = Math.sqrt((canvas.width * canvas.height) / nodes.length) * 0.3 * forceStrength;

            if (dragging !== null) return;

            nodes.forEach(n => { n.vx = 0; n.vy = 0; });

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = k * k / dist * 0.3;

                    nodes[i].vx -= (dx / dist) * force;
                    nodes[i].vy -= (dy / dist) * force;
                    nodes[j].vx += (dx / dist) * force;
                    nodes[j].vy += (dy / dist) * force;
                }
            }

            edges.forEach(e => {
                const source = nodes[e.source];
                const target = nodes[e.target];
                const dx = target.x - source.x;
                const dy = target.y - source.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                const force = dist / k * 0.3 * forceStrength;

                source.vx += (dx / dist) * force;
                source.vy += (dy / dist) * force;
                target.vx -= (dx / dist) * force;
                target.vy -= (dy / dist) * force;
            });

            nodes.forEach(n => {
                n.vx += (cx() - n.x) * 0.005;
                n.vy += (cy() - n.y) * 0.005;
                n.x += n.vx * 0.1;
                n.y += n.vy * 0.1;
                n.x = Math.max(50, Math.min(canvas.width - 350, n.x));
                n.y = Math.max(50, Math.min(canvas.height - 50, n.y));
            });
        }

        function circularLayout() {
            const r = Math.min(cx(), cy()) * 0.7;
            nodes.forEach((n, i) => {
                const angle = (i / nodes.length) * Math.PI * 2 - Math.PI / 2;
                targetPositions[n.id] = { x: cx() + Math.cos(angle) * r, y: cy() + Math.sin(angle) * r };
            });
        }

        function radialLayout() {
            // Find node with highest degree as center
            const degrees = nodes.map(n => edges.filter(e => e.source === n.id || e.target === n.id).length);
            const centerIdx = degrees.indexOf(Math.max(...degrees));

            // BFS to find distances
            const dist = new Array(nodes.length).fill(Infinity);
            dist[centerIdx] = 0;
            const queue = [centerIdx];
            const adj = nodes.map(() => []);
            edges.forEach(e => {
                adj[e.source].push(e.target);
                adj[e.target].push(e.source);
            });

            while (queue.length > 0) {
                const v = queue.shift();
                for (const u of adj[v]) {
                    if (dist[u] === Infinity) {
                        dist[u] = dist[v] + 1;
                        queue.push(u);
                    }
                }
            }

            const maxDist = Math.max(...dist.filter(d => d !== Infinity));
            const levels = [];
            for (let d = 0; d <= maxDist; d++) {
                levels.push(nodes.filter((_, i) => dist[i] === d).map(n => n.id));
            }

            levels.forEach((level, d) => {
                const r = d * 80;
                level.forEach((id, i) => {
                    const angle = (i / level.length) * Math.PI * 2 - Math.PI / 2;
                    targetPositions[id] = { x: cx() + Math.cos(angle) * r, y: cy() + Math.sin(angle) * r };
                });
            });
        }

        function hierarchicalLayout() {
            // Find root (node with highest degree or first node)
            const degrees = nodes.map(n => edges.filter(e => e.source === n.id || e.target === n.id).length);
            const root = degrees.indexOf(Math.max(...degrees));

            // BFS for levels
            const dist = new Array(nodes.length).fill(Infinity);
            dist[root] = 0;
            const queue = [root];
            const adj = nodes.map(() => []);
            edges.forEach(e => {
                adj[e.source].push(e.target);
                adj[e.target].push(e.source);
            });

            while (queue.length > 0) {
                const v = queue.shift();
                for (const u of adj[v]) {
                    if (dist[u] === Infinity) {
                        dist[u] = dist[v] + 1;
                        queue.push(u);
                    }
                }
            }

            const maxDist = Math.max(...dist.filter(d => d !== Infinity));
            const levels = [];
            for (let d = 0; d <= maxDist; d++) {
                levels.push(nodes.filter((_, i) => dist[i] === d).map(n => n.id));
            }

            const levelHeight = (canvas.height - 100) / (levels.length || 1);
            levels.forEach((level, d) => {
                const levelWidth = (canvas.width - 400) / (level.length + 1);
                level.forEach((id, i) => {
                    targetPositions[id] = {
                        x: 50 + levelWidth * (i + 1),
                        y: 50 + d * levelHeight
                    };
                });
            });
        }

        function spectralLayout() {
            // Simplified spectral layout using power iteration
            const n = nodes.length;
            if (n === 0) return;

            const adj = nodes.map(() => []);
            edges.forEach(e => {
                adj[e.source].push(e.target);
                adj[e.target].push(e.source);
            });

            // Laplacian matrix power iteration for second eigenvector
            let x = nodes.map(() => Math.random() - 0.5);
            let y = nodes.map(() => Math.random() - 0.5);

            for (let iter = 0; iter < 50; iter++) {
                // Laplacian multiplication
                const newX = nodes.map((_, i) => {
                    const deg = adj[i].length;
                    let sum = deg * x[i];
                    for (const j of adj[i]) sum -= x[j];
                    return sum;
                });

                const newY = nodes.map((_, i) => {
                    const deg = adj[i].length;
                    let sum = deg * y[i];
                    for (const j of adj[i]) sum -= y[j];
                    return sum;
                });

                // Orthogonalize y against x
                const dotXY = x.reduce((s, xi, i) => s + xi * newY[i], 0);
                const dotXX = x.reduce((s, xi) => s + xi * xi, 0);
                for (let i = 0; i < n; i++) newY[i] -= (dotXY / dotXX) * x[i];

                // Normalize
                const normX = Math.sqrt(newX.reduce((s, v) => s + v * v, 0)) || 1;
                const normY = Math.sqrt(newY.reduce((s, v) => s + v * v, 0)) || 1;
                x = newX.map(v => v / normX);
                y = newY.map(v => v / normY);
            }

            const scale = Math.min(cx(), cy()) * 0.7;
            const minX = Math.min(...x), maxX = Math.max(...x);
            const minY = Math.min(...y), maxY = Math.max(...y);

            nodes.forEach((node, i) => {
                const nx = (x[i] - minX) / (maxX - minX || 1) * 2 - 1;
                const ny = (y[i] - minY) / (maxY - minY || 1) * 2 - 1;
                targetPositions[node.id] = { x: cx() + nx * scale, y: cy() + ny * scale };
            });
        }

        function randomLayout() {
            const r = Math.min(cx(), cy()) * 0.8;
            nodes.forEach(n => {
                targetPositions[n.id] = {
                    x: cx() + (Math.random() - 0.5) * r * 2,
                    y: cy() + (Math.random() - 0.5) * r * 2
                };
            });
        }

        function applyLayout() {
            targetPositions = {};

            switch (layout) {
                case 'force': break; // Force is continuous
                case 'circular': circularLayout(); break;
                case 'radial': radialLayout(); break;
                case 'hierarchical': hierarchicalLayout(); break;
                case 'spectral': spectralLayout(); break;
                case 'random': randomLayout(); break;
            }

            if (layout !== 'force') {
                nodes.forEach(n => {
                    if (targetPositions[n.id]) {
                        n.x = targetPositions[n.id].x;
                        n.y = targetPositions[n.id].y;
                    }
                });
            }

            document.getElementById('statsLayout').textContent = layout.charAt(0).toUpperCase() + layout.slice(1);
        }

        function animateTransition() {
            targetPositions = {};

            switch (layout) {
                case 'circular': circularLayout(); break;
                case 'radial': radialLayout(); break;
                case 'hierarchical': hierarchicalLayout(); break;
                case 'spectral': spectralLayout(); break;
                case 'random': randomLayout(); break;
                default: return;
            }

            animating = true;
            let progress = 0;

            const startPositions = {};
            nodes.forEach(n => startPositions[n.id] = { x: n.x, y: n.y });

            function step() {
                progress += 0.02;
                if (progress >= 1) {
                    progress = 1;
                    animating = false;
                }

                const ease = 1 - Math.pow(1 - progress, 3); // Ease out cubic

                nodes.forEach(n => {
                    if (targetPositions[n.id]) {
                        n.x = startPositions[n.id].x + (targetPositions[n.id].x - startPositions[n.id].x) * ease;
                        n.y = startPositions[n.id].y + (targetPositions[n.id].y - startPositions[n.id].y) * ease;
                    }
                });

                if (animating) requestAnimationFrame(step);
            }

            step();
        }

        function draw() {
            ctx.fillStyle = 'rgba(10, 10, 26, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw edges
            ctx.strokeStyle = 'rgba(200, 150, 255, 0.3)';
            ctx.lineWidth = 1;
            edges.forEach(e => {
                ctx.beginPath();
                ctx.moveTo(nodes[e.source].x, nodes[e.source].y);
                ctx.lineTo(nodes[e.target].x, nodes[e.target].y);
                ctx.stroke();
            });

            // Draw nodes
            nodes.forEach(node => {
                const deg = edges.filter(e => e.source === node.id || e.target === node.id).length;
                const size = 4 + Math.min(deg, 8);

                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                ctx.fillStyle = dragging === node.id ? '#fff' : '#c896ff';
                ctx.fill();
            });
        }

        function animate() {
            if (layout === 'force' && !animating) {
                applyForceLayout();
            }
            draw();
            requestAnimationFrame(animate);
        }

        function updateStats() {
            document.getElementById('statsNodes').textContent = nodes.length;
            document.getElementById('statsEdges').textContent = edges.length;
        }

        // Event listeners
        document.getElementById('networkType').onchange = (e) => {
            const n = parseInt(document.getElementById('nodeCount').value);
            switch (e.target.value) {
                case 'barabasi': generateBarabasi(n); break;
                case 'random': generateRandom(n); break;
                case 'tree': generateTree(n); break;
                case 'grid': generateGrid(Math.floor(Math.sqrt(n))); break;
            }
            applyLayout();
            updateStats();
        };

        document.getElementById('nodeCount').oninput = (e) => {
            document.getElementById('nodeValue').textContent = e.target.value;
        };

        document.getElementById('forceStrength').oninput = (e) => {
            forceStrength = parseFloat(e.target.value);
            document.getElementById('forceValue').textContent = forceStrength.toFixed(1);
        };

        document.querySelectorAll('.tab').forEach(tab => {
            tab.onclick = () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                layout = tab.dataset.layout;
                applyLayout();
            };
        });

        document.getElementById('generateBtn').onclick = () => {
            const n = parseInt(document.getElementById('nodeCount').value);
            const type = document.getElementById('networkType').value;
            switch (type) {
                case 'barabasi': generateBarabasi(n); break;
                case 'random': generateRandom(n); break;
                case 'tree': generateTree(n); break;
                case 'grid': generateGrid(Math.floor(Math.sqrt(n))); break;
            }
            applyLayout();
            updateStats();
        };

        document.getElementById('applyLayoutBtn').onclick = applyLayout;
        document.getElementById('animateBtn').onclick = animateTransition;

        // Drag handling
        canvas.onmousedown = (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            for (const node of nodes) {
                const dx = node.x - x;
                const dy = node.y - y;
                if (dx * dx + dy * dy < 150) {
                    dragging = node.id;
                    break;
                }
            }
        };

        canvas.onmousemove = (e) => {
            if (dragging !== null) {
                const rect = canvas.getBoundingClientRect();
                const node = nodes.find(n => n.id === dragging);
                if (node) {
                    node.x = e.clientX - rect.left;
                    node.y = e.clientY - rect.top;
                }
            }
        };

        canvas.onmouseup = () => { dragging = null; };
        canvas.onmouseleave = () => { dragging = null; };

        // Initialize
        generateBarabasi(60);
        updateStats();
        animate();
    </script>
</body>
</html>
