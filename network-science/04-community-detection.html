<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Community Detection | Network Science</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(255, 200, 100, 0.3);
        }
        h1 { color: #ffc864; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"] { width: 100%; }
        select { width: 100%; padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #ffc864; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #ffc864; color: #0a0a1a;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #ffd88c; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #ffc864; font-weight: bold; }
        .community-legend { margin-top: 15px; }
        .legend-item { display: flex; align-items: center; gap: 8px; padding: 3px 0; font-size: 0.85em; }
        .legend-color { width: 15px; height: 15px; border-radius: 3px; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #ffc864; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Network Science</a>

    <div class="controls">
        <h1>Community Detection</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Louvain algorithm for modularity optimization</p>

        <div class="control-group">
            <label>Network Type</label>
            <select id="networkType">
                <option value="planted">Planted Partition</option>
                <option value="random">Random Network</option>
                <option value="karate">Karate Club</option>
            </select>
        </div>

        <div class="control-group">
            <label>Communities: <span class="value" id="commValue">4</span></label>
            <input type="range" id="numComm" min="2" max="8" value="4">
        </div>

        <div class="control-group">
            <label>Nodes per Community: <span class="value" id="nodesValue">20</span></label>
            <input type="range" id="nodesPerComm" min="10" max="40" value="20">
        </div>

        <div class="control-group">
            <label>Internal Edge Prob: <span class="value" id="pInValue">0.3</span></label>
            <input type="range" id="pIn" min="0.1" max="0.8" step="0.05" value="0.3">
        </div>

        <div class="control-group">
            <label>External Edge Prob: <span class="value" id="pOutValue">0.01</span></label>
            <input type="range" id="pOut" min="0" max="0.1" step="0.005" value="0.01">
        </div>

        <button id="generateBtn">Generate Network</button>
        <button id="detectBtn">Detect Communities</button>
        <button id="stepBtn">Step Algorithm</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="nodeCount">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="edgeCount">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Communities Found</span>
                <span class="stat-value" id="commCount">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Modularity</span>
                <span class="stat-value" id="modularity">0</span>
            </div>
        </div>

        <div class="community-legend" id="legend"></div>

        <div class="info">
            <strong>Modularity:</strong> Measures quality of community partition. Higher values indicate denser connections within communities vs between them.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let communities = [];
        let m = 0; // total edge weight

        const colors = [
            '#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3',
            '#f38181', '#aa96da', '#fcbad3', '#a8d8ea'
        ];

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        function generatePlantedPartition() {
            const numComm = parseInt(document.getElementById('numComm').value);
            const nodesPerComm = parseInt(document.getElementById('nodesPerComm').value);
            const pIn = parseFloat(document.getElementById('pIn').value);
            const pOut = parseFloat(document.getElementById('pOut').value);

            nodes = [];
            edges = [];

            const cx = (canvas.width - 300) / 2;
            const cy = canvas.height / 2;
            const bigR = Math.min(cx, cy) * 0.7;

            // Create nodes in community clusters
            for (let c = 0; c < numComm; c++) {
                const commAngle = (c / numComm) * Math.PI * 2;
                const commX = cx + Math.cos(commAngle) * bigR * 0.5;
                const commY = cy + Math.sin(commAngle) * bigR * 0.5;

                for (let i = 0; i < nodesPerComm; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * bigR * 0.3;
                    nodes.push({
                        id: nodes.length,
                        x: commX + Math.cos(angle) * r,
                        y: commY + Math.sin(angle) * r,
                        vx: 0, vy: 0,
                        trueCommunity: c,
                        community: nodes.length // Initially each node is its own community
                    });
                }
            }

            // Create edges
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const p = nodes[i].trueCommunity === nodes[j].trueCommunity ? pIn : pOut;
                    if (Math.random() < p) {
                        edges.push({ source: i, target: j });
                    }
                }
            }

            m = edges.length;
            updateStats();
        }

        function generateKarateClub() {
            // Zachary's Karate Club network
            nodes = [];
            edges = [];

            const n = 34;
            const cx = (canvas.width - 300) / 2;
            const cy = canvas.height / 2;

            for (let i = 0; i < n; i++) {
                const angle = (i / n) * Math.PI * 2;
                const r = 200;
                nodes.push({
                    id: i,
                    x: cx + Math.cos(angle) * r + (Math.random() - 0.5) * 50,
                    y: cy + Math.sin(angle) * r + (Math.random() - 0.5) * 50,
                    vx: 0, vy: 0,
                    trueCommunity: i < 17 ? 0 : 1,
                    community: i
                });
            }

            const karateEdges = [
                [0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[0,7],[0,8],[0,10],[0,11],[0,12],[0,13],[0,17],[0,19],[0,21],[0,31],
                [1,2],[1,3],[1,7],[1,13],[1,17],[1,19],[1,21],[1,30],
                [2,3],[2,7],[2,8],[2,9],[2,13],[2,27],[2,28],[2,32],
                [3,7],[3,12],[3,13],
                [4,6],[4,10],
                [5,6],[5,10],[5,16],
                [6,16],
                [8,30],[8,32],[8,33],
                [9,33],
                [13,33],
                [14,32],[14,33],
                [15,32],[15,33],
                [18,32],[18,33],
                [19,33],
                [20,32],[20,33],
                [22,32],[22,33],
                [23,25],[23,27],[23,29],[23,32],[23,33],
                [24,25],[24,27],[24,31],
                [25,31],
                [26,29],[26,33],
                [27,33],
                [28,31],[28,33],
                [29,32],[29,33],
                [30,32],[30,33],
                [31,32],[31,33],
                [32,33]
            ];

            karateEdges.forEach(([i, j]) => {
                edges.push({ source: i, target: j });
            });

            m = edges.length;
            updateStats();
        }

        function generateRandom() {
            const n = parseInt(document.getElementById('numComm').value) * parseInt(document.getElementById('nodesPerComm').value);
            nodes = [];
            edges = [];

            const cx = (canvas.width - 300) / 2;
            const cy = canvas.height / 2;

            for (let i = 0; i < n; i++) {
                const angle = (i / n) * Math.PI * 2;
                const r = 200;
                nodes.push({
                    id: i,
                    x: cx + Math.cos(angle) * r,
                    y: cy + Math.sin(angle) * r,
                    vx: 0, vy: 0,
                    trueCommunity: 0,
                    community: i
                });
            }

            const p = 0.05;
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    if (Math.random() < p) {
                        edges.push({ source: i, target: j });
                    }
                }
            }

            m = edges.length;
            updateStats();
        }

        function getDegree(nodeId) {
            return edges.filter(e => e.source === nodeId || e.target === nodeId).length;
        }

        function getEdgesBetween(comm1, comm2) {
            return edges.filter(e => {
                const c1 = nodes[e.source].community;
                const c2 = nodes[e.target].community;
                return (c1 === comm1 && c2 === comm2) || (c1 === comm2 && c2 === comm1);
            }).length;
        }

        function calculateModularity() {
            if (m === 0) return 0;

            let Q = 0;
            const commSet = new Set(nodes.map(n => n.community));

            commSet.forEach(c => {
                const nodesInComm = nodes.filter(n => n.community === c);
                let Lc = 0; // edges within community
                let kc = 0; // sum of degrees in community

                nodesInComm.forEach(node => {
                    kc += getDegree(node.id);
                });

                edges.forEach(e => {
                    if (nodes[e.source].community === c && nodes[e.target].community === c) {
                        Lc++;
                    }
                });

                Q += Lc / m - Math.pow(kc / (2 * m), 2);
            });

            return Q;
        }

        function louvainStep() {
            let improved = false;

            // Shuffle node order
            const order = nodes.map((_, i) => i).sort(() => Math.random() - 0.5);

            order.forEach(nodeId => {
                const node = nodes[nodeId];
                const currentComm = node.community;

                // Find neighboring communities
                const neighborComms = new Set();
                edges.forEach(e => {
                    if (e.source === nodeId) neighborComms.add(nodes[e.target].community);
                    if (e.target === nodeId) neighborComms.add(nodes[e.source].community);
                });

                let bestComm = currentComm;
                let bestDeltaQ = 0;

                neighborComms.forEach(newComm => {
                    if (newComm === currentComm) return;

                    // Calculate modularity gain
                    node.community = newComm;
                    const newQ = calculateModularity();
                    node.community = currentComm;
                    const oldQ = calculateModularity();

                    const deltaQ = newQ - oldQ;
                    if (deltaQ > bestDeltaQ) {
                        bestDeltaQ = deltaQ;
                        bestComm = newComm;
                    }
                });

                if (bestComm !== currentComm) {
                    node.community = bestComm;
                    improved = true;
                }
            });

            // Renumber communities
            const commMap = {};
            let nextComm = 0;
            nodes.forEach(n => {
                if (commMap[n.community] === undefined) {
                    commMap[n.community] = nextComm++;
                }
                n.community = commMap[n.community];
            });

            updateStats();
            return improved;
        }

        function detectCommunities() {
            // Reset communities
            nodes.forEach((n, i) => n.community = i);

            // Run Louvain until no improvement
            let iter = 0;
            while (louvainStep() && iter < 50) {
                iter++;
            }

            updateStats();
        }

        function applyForces() {
            const k = Math.sqrt((canvas.width * canvas.height) / nodes.length) * 0.3;

            nodes.forEach(n => { n.vx = 0; n.vy = 0; });

            // Repulsion
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = k * k / dist * 0.3;

                    nodes[i].vx -= (dx / dist) * force;
                    nodes[i].vy -= (dy / dist) * force;
                    nodes[j].vx += (dx / dist) * force;
                    nodes[j].vy += (dy / dist) * force;
                }
            }

            // Attraction along edges
            edges.forEach(e => {
                const source = nodes[e.source];
                const target = nodes[e.target];
                const dx = target.x - source.x;
                const dy = target.y - source.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                const force = dist / k * 0.5;

                source.vx += (dx / dist) * force;
                source.vy += (dy / dist) * force;
                target.vx -= (dx / dist) * force;
                target.vy -= (dy / dist) * force;
            });

            // Same-community attraction
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    if (nodes[i].community === nodes[j].community) {
                        const dx = nodes[j].x - nodes[i].x;
                        const dy = nodes[j].y - nodes[i].y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        const force = 0.1;

                        nodes[i].vx += (dx / dist) * force;
                        nodes[i].vy += (dy / dist) * force;
                        nodes[j].vx -= (dx / dist) * force;
                        nodes[j].vy -= (dy / dist) * force;
                    }
                }
            }

            // Center gravity
            const cx = (canvas.width - 300) / 2;
            const cy = canvas.height / 2;
            nodes.forEach(n => {
                n.vx += (cx - n.x) * 0.01;
                n.vy += (cy - n.y) * 0.01;
            });

            nodes.forEach(n => {
                n.x += n.vx * 0.1;
                n.y += n.vy * 0.1;
                n.x = Math.max(50, Math.min(canvas.width - 350, n.x));
                n.y = Math.max(50, Math.min(canvas.height - 50, n.y));
            });
        }

        function draw() {
            ctx.fillStyle = 'rgba(10, 10, 26, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw edges
            edges.forEach(e => {
                const source = nodes[e.source];
                const target = nodes[e.target];
                const sameComm = source.community === target.community;

                ctx.strokeStyle = sameComm ?
                    `${colors[source.community % colors.length]}66` :
                    'rgba(255,255,255,0.1)';
                ctx.lineWidth = sameComm ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(target.x, target.y);
                ctx.stroke();
            });

            // Draw nodes
            nodes.forEach(node => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, 6, 0, Math.PI * 2);
                ctx.fillStyle = colors[node.community % colors.length];
                ctx.fill();
            });
        }

        function updateStats() {
            const commSet = new Set(nodes.map(n => n.community));
            const Q = calculateModularity();

            document.getElementById('nodeCount').textContent = nodes.length;
            document.getElementById('edgeCount').textContent = edges.length;
            document.getElementById('commCount').textContent = commSet.size;
            document.getElementById('modularity').textContent = Q.toFixed(4);

            // Update legend
            const legend = document.getElementById('legend');
            legend.innerHTML = '<div style="font-size:0.85em; color:#888; margin-bottom:5px;">Communities:</div>';

            const commSizes = {};
            nodes.forEach(n => {
                commSizes[n.community] = (commSizes[n.community] || 0) + 1;
            });

            Object.entries(commSizes).sort((a, b) => b[1] - a[1]).forEach(([comm, size]) => {
                legend.innerHTML += `
                    <div class="legend-item">
                        <div class="legend-color" style="background:${colors[comm % colors.length]}"></div>
                        <span>Community ${parseInt(comm)+1}: ${size} nodes</span>
                    </div>
                `;
            });
        }

        function animate() {
            applyForces();
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('networkType').onchange = (e) => {
            const type = e.target.value;
            if (type === 'planted') generatePlantedPartition();
            else if (type === 'karate') generateKarateClub();
            else generateRandom();
        };

        ['numComm', 'nodesPerComm', 'pIn', 'pOut'].forEach(id => {
            document.getElementById(id).oninput = (e) => {
                const valueId = id === 'numComm' ? 'commValue' :
                               id === 'nodesPerComm' ? 'nodesValue' :
                               id === 'pIn' ? 'pInValue' : 'pOutValue';
                document.getElementById(valueId).textContent = e.target.value;
            };
        });

        document.getElementById('generateBtn').onclick = () => {
            const type = document.getElementById('networkType').value;
            if (type === 'planted') generatePlantedPartition();
            else if (type === 'karate') generateKarateClub();
            else generateRandom();
        };

        document.getElementById('detectBtn').onclick = detectCommunities;
        document.getElementById('stepBtn').onclick = louvainStep;

        // Initialize
        generatePlantedPartition();
        animate();
    </script>
</body>
</html>
