<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Link Prediction - Network Science</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #eee; min-height: 100vh; padding: 20px; }
        .back-link { position: fixed; top: 20px; left: 20px; color: #4ade80; text-decoration: none; font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px; z-index: 100; }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #4ade80; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(74, 222, 128, 0.1); border: 1px solid rgba(74, 222, 128, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #4ade80; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #0a0a15; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input, .control-group select { width: 100%; }
        .value-display { color: #4ade80; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #4ade80; color: #1a1a2e; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .prediction-list { max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px; font-size: 0.85em; }
        .prediction-item { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .prediction-item:last-child { border-bottom: none; }
        .score { color: #4ade80; font-family: monospace; }
        .legend { display: flex; gap: 15px; flex-wrap: wrap; margin: 10px 0; }
        .legend-item { display: flex; align-items: center; gap: 5px; font-size: 0.85em; }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <h1>Link Prediction</h1>
    <p class="subtitle">Common neighbors, Jaccard, Adamic-Adar similarity</p>

    <div class="container">
        <div class="panel">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>

        <div class="panel">
            <div class="info-box">
                <strong>Link Prediction:</strong>
                Predicts missing or future edges based on network structure.
                <b>Common Neighbors:</b> Count shared connections<br>
                <b>Jaccard:</b> Normalized common neighbors<br>
                <b>Adamic-Adar:</b> Weighted by neighbor rarity
            </div>

            <div class="legend">
                <div class="legend-item"><div class="legend-dot" style="background: #4ade80;"></div> Existing Edge</div>
                <div class="legend-item"><div class="legend-dot" style="background: #facc15;"></div> Predicted Edge</div>
                <div class="legend-item"><div class="legend-dot" style="background: #f87171;"></div> Selected Pair</div>
            </div>

            <h3>Prediction Method</h3>
            <div class="control-group">
                <select id="methodSelect" onchange="computePredictions()">
                    <option value="common">Common Neighbors</option>
                    <option value="jaccard">Jaccard Coefficient</option>
                    <option value="adamic">Adamic-Adar Index</option>
                    <option value="preferential">Preferential Attachment</option>
                </select>
            </div>

            <div class="control-group">
                <label>Network Size: <span class="value-display" id="nVal">40</span></label>
                <input type="range" id="nSlider" min="20" max="70" value="40" oninput="updateParam()">
            </div>

            <div class="control-group">
                <label>Show Top Predictions: <span class="value-display" id="topVal">5</span></label>
                <input type="range" id="topSlider" min="1" max="20" value="5" oninput="updateTopK()">
            </div>

            <button class="btn-primary" onclick="generateNetwork()">Generate Network</button>
            <button class="btn-secondary" onclick="addPredictedEdge()">Add Best Prediction</button>

            <h3 style="margin-top: 15px;">Top Predicted Links</h3>
            <div class="prediction-list" id="predictionList">
                Generate a network to see predictions...
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let predictions = [];
        let n = 40;
        let topK = 5;
        let selectedPair = null;

        function updateParam() {
            n = parseInt(document.getElementById('nSlider').value);
            document.getElementById('nVal').textContent = n;
        }

        function updateTopK() {
            topK = parseInt(document.getElementById('topSlider').value);
            document.getElementById('topVal').textContent = topK;
            displayPredictions();
            draw();
        }

        function generateNetwork() {
            nodes = [];
            edges = [];
            predictions = [];
            selectedPair = null;

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            // Create nodes in clusters
            const numClusters = 3;
            for (let i = 0; i < n; i++) {
                const cluster = Math.floor(i / (n / numClusters));
                const clusterAngle = (2 * Math.PI * cluster) / numClusters;
                const clusterCx = cx + 120 * Math.cos(clusterAngle);
                const clusterCy = cy + 120 * Math.sin(clusterAngle);
                const angle = Math.random() * 2 * Math.PI;
                const r = 30 + Math.random() * 70;
                nodes.push({
                    id: i,
                    cluster: cluster,
                    x: clusterCx + r * Math.cos(angle),
                    y: clusterCy + r * Math.sin(angle),
                    degree: 0,
                    vx: 0, vy: 0
                });
            }

            // Create edges within clusters (higher probability)
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const sameCluster = nodes[i].cluster === nodes[j].cluster;
                    const p = sameCluster ? 0.3 : 0.05;
                    if (Math.random() < p) {
                        edges.push([i, j]);
                        nodes[i].degree++;
                        nodes[j].degree++;
                    }
                }
            }

            layoutNetwork();
            computePredictions();
            draw();
        }

        function layoutNetwork() {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            for (let iter = 0; iter < 50; iter++) {
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const dx = nodes[j].x - nodes[i].x;
                        const dy = nodes[j].y - nodes[i].y;
                        const dist = Math.max(Math.sqrt(dx * dx + dy * dy), 1);
                        const force = 2000 / (dist * dist);
                        nodes[i].vx -= (dx / dist) * force;
                        nodes[i].vy -= (dy / dist) * force;
                        nodes[j].vx += (dx / dist) * force;
                        nodes[j].vy += (dy / dist) * force;
                    }
                }

                for (const [i, j] of edges) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const force = (dist - 60) * 0.1;
                    nodes[i].vx += (dx / dist) * force;
                    nodes[i].vy += (dy / dist) * force;
                    nodes[j].vx -= (dx / dist) * force;
                    nodes[j].vy -= (dy / dist) * force;
                }

                nodes.forEach(node => {
                    node.vx += (cx - node.x) * 0.01;
                    node.vy += (cy - node.y) * 0.01;
                    node.x += node.vx * 0.1;
                    node.y += node.vy * 0.1;
                    node.vx *= 0.9;
                    node.vy *= 0.9;
                });
            }
        }

        function hasEdge(i, j) {
            return edges.some(e => (e[0] === i && e[1] === j) || (e[0] === j && e[1] === i));
        }

        function getNeighbors(nodeId) {
            const neighbors = new Set();
            for (const [i, j] of edges) {
                if (i === nodeId) neighbors.add(j);
                if (j === nodeId) neighbors.add(i);
            }
            return neighbors;
        }

        function computePredictions() {
            const method = document.getElementById('methodSelect').value;
            predictions = [];

            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    if (hasEdge(i, j)) continue;

                    const neighborsI = getNeighbors(i);
                    const neighborsJ = getNeighbors(j);
                    const common = [...neighborsI].filter(n => neighborsJ.has(n));

                    let score = 0;
                    if (method === 'common') {
                        score = common.length;
                    } else if (method === 'jaccard') {
                        const union = new Set([...neighborsI, ...neighborsJ]);
                        score = union.size > 0 ? common.length / union.size : 0;
                    } else if (method === 'adamic') {
                        score = common.reduce((sum, cn) => {
                            const deg = nodes[cn].degree;
                            return sum + (deg > 1 ? 1 / Math.log(deg) : 0);
                        }, 0);
                    } else if (method === 'preferential') {
                        score = nodes[i].degree * nodes[j].degree;
                    }

                    if (score > 0) {
                        predictions.push({ i, j, score, common: common.length });
                    }
                }
            }

            predictions.sort((a, b) => b.score - a.score);
            displayPredictions();
            draw();
        }

        function displayPredictions() {
            const list = document.getElementById('predictionList');
            const method = document.getElementById('methodSelect').value;
            const top = predictions.slice(0, topK);

            if (top.length === 0) {
                list.innerHTML = '<div style="opacity: 0.6;">No predictions available</div>';
                return;
            }

            list.innerHTML = top.map((p, idx) => `
                <div class="prediction-item" onclick="selectPair(${p.i}, ${p.j})" style="cursor: pointer;">
                    <span>#${idx + 1}: Node ${p.i} ↔ Node ${p.j}</span>
                    <span class="score">${p.score.toFixed(3)}</span>
                </div>
            `).join('');
        }

        function selectPair(i, j) {
            selectedPair = [i, j];
            draw();
        }

        function addPredictedEdge() {
            if (predictions.length === 0) return;
            const best = predictions[0];
            edges.push([best.i, best.j]);
            nodes[best.i].degree++;
            nodes[best.j].degree++;
            computePredictions();
        }

        function draw() {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw predicted edges (top K)
            const topPredictions = predictions.slice(0, topK);
            for (const pred of topPredictions) {
                const ni = nodes[pred.i];
                const nj = nodes[pred.j];
                const isSelected = selectedPair &&
                    ((selectedPair[0] === pred.i && selectedPair[1] === pred.j) ||
                     (selectedPair[0] === pred.j && selectedPair[1] === pred.i));

                ctx.strokeStyle = isSelected ? '#f87171' : '#facc15';
                ctx.lineWidth = isSelected ? 3 : 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(ni.x, ni.y);
                ctx.lineTo(nj.x, nj.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw existing edges
            ctx.strokeStyle = 'rgba(74, 222, 128, 0.4)';
            ctx.lineWidth = 1;
            for (const [i, j] of edges) {
                ctx.beginPath();
                ctx.moveTo(nodes[i].x, nodes[i].y);
                ctx.lineTo(nodes[j].x, nodes[j].y);
                ctx.stroke();
            }

            // Draw nodes
            const clusterColors = ['#4ade80', '#60a5fa', '#f472b6'];
            for (const node of nodes) {
                const size = 5 + node.degree;
                const isInSelected = selectedPair && (selectedPair[0] === node.id || selectedPair[1] === node.id);

                ctx.fillStyle = isInSelected ? '#f87171' : clusterColors[node.cluster];
                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                ctx.fill();

                if (isInSelected) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            // Draw common neighbors for selected pair
            if (selectedPair) {
                const neighborsI = getNeighbors(selectedPair[0]);
                const neighborsJ = getNeighbors(selectedPair[1]);
                const common = [...neighborsI].filter(n => neighborsJ.has(n));

                for (const cn of common) {
                    ctx.strokeStyle = '#facc15';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(nodes[cn].x, nodes[cn].y, 10 + nodes[cn].degree, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            const method = document.getElementById('methodSelect').value;
            ctx.fillText(`Method: ${method.toUpperCase()}`, 20, 30);
        }

        // Click to select node pair
        let firstSelected = null;
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            for (const node of nodes) {
                const dx = node.x - x;
                const dy = node.y - y;
                if (Math.sqrt(dx * dx + dy * dy) < 15) {
                    if (firstSelected === null) {
                        firstSelected = node.id;
                    } else if (firstSelected !== node.id) {
                        selectedPair = [firstSelected, node.id];
                        firstSelected = null;
                        draw();
                    }
                    return;
                }
            }
            firstSelected = null;
            selectedPair = null;
            draw();
        });

        updateParam();
        generateNetwork();
    </script>
</body>
</html>
