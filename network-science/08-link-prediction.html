<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Link Prediction | Network Science</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; cursor: crosshair; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(100, 255, 200, 0.3);
        }
        h1 { color: #64ffc8; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        select { width: 100%; padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #64ffc8; color: #0a0a1a;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #8cffdc; }
        .method-tabs { display: flex; gap: 5px; flex-wrap: wrap; margin: 10px 0; }
        .tab {
            flex: 1; min-width: 60px;
            padding: 8px 5px; border: none; border-radius: 5px;
            background: rgba(100, 255, 200, 0.1);
            color: #64ffc8; cursor: pointer;
            font-size: 0.75em; text-align: center;
        }
        .tab.active { background: #64ffc8; color: #0a0a1a; }
        .prediction-list { margin-top: 15px; max-height: 200px; overflow-y: auto; }
        .prediction { display: flex; justify-content: space-between; padding: 5px; font-size: 0.85em; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .prediction:hover { background: rgba(100,255,200,0.1); }
        .node-pair { color: #64ffc8; }
        .score { color: #aaa; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #64ffc8; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        .selected-node { padding: 5px 10px; background: rgba(100,255,200,0.2); border-radius: 5px; margin: 5px 0; font-size: 0.9em; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">← Back to Network Science</a>

    <div class="controls">
        <h1>Link Prediction</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Predict missing or future connections</p>

        <div class="method-tabs">
            <button class="tab active" data-method="common">Common Neighbors</button>
            <button class="tab" data-method="jaccard">Jaccard</button>
            <button class="tab" data-method="adamic">Adamic-Adar</button>
            <button class="tab" data-method="preferential">Preferential</button>
        </div>

        <button id="generateBtn">Generate Network</button>
        <button id="predictBtn">Predict Links</button>
        <button id="revealBtn">Reveal True Links</button>

        <div class="selected-node" id="selectedNode">Click a node to select</div>

        <div class="prediction-list" id="predictions">
            <div style="color:#888; font-size:0.85em;">Top predicted links will appear here</div>
        </div>

        <div class="info">
            <strong>Click nodes</strong> to see predicted links for that node.<br><br>
            <strong>Green dashed lines:</strong> Predicted links<br>
            <strong>Methods:</strong> Common Neighbors, Jaccard Coefficient, Adamic-Adar Index, Preferential Attachment
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let hiddenEdges = [];
        let predictions = [];
        let selectedNode = null;
        let method = 'common';

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        function generateNetwork() {
            nodes = [];
            edges = [];
            hiddenEdges = [];
            predictions = [];
            selectedNode = null;

            const n = 50;
            const cx = (canvas.width - 300) / 2;
            const cy = canvas.height / 2;

            // Generate a community structure network
            const communities = 3;
            const nodesPerComm = Math.floor(n / communities);

            for (let c = 0; c < communities; c++) {
                const commAngle = (c / communities) * Math.PI * 2;
                const commX = cx + Math.cos(commAngle) * 150;
                const commY = cy + Math.sin(commAngle) * 150;

                for (let i = 0; i < nodesPerComm; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * 80;
                    nodes.push({
                        id: nodes.length,
                        x: commX + Math.cos(angle) * r,
                        y: commY + Math.sin(angle) * r,
                        vx: 0, vy: 0,
                        community: c
                    });
                }
            }

            // Create edges
            const allPossibleEdges = [];
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const sameComm = nodes[i].community === nodes[j].community;
                    const prob = sameComm ? 0.3 : 0.05;
                    if (Math.random() < prob) {
                        allPossibleEdges.push({ source: i, target: j });
                    }
                }
            }

            // Hide 20% of edges for prediction
            allPossibleEdges.forEach(e => {
                if (Math.random() < 0.2) {
                    hiddenEdges.push(e);
                } else {
                    edges.push(e);
                }
            });

            updatePredictions();
            document.getElementById('selectedNode').textContent = 'Click a node to select';
        }

        function getNeighbors(nodeId) {
            const neighbors = new Set();
            edges.forEach(e => {
                if (e.source === nodeId) neighbors.add(e.target);
                if (e.target === nodeId) neighbors.add(e.source);
            });
            return neighbors;
        }

        function commonNeighbors(a, b) {
            const na = getNeighbors(a);
            const nb = getNeighbors(b);
            let count = 0;
            na.forEach(n => { if (nb.has(n)) count++; });
            return count;
        }

        function jaccardCoefficient(a, b) {
            const na = getNeighbors(a);
            const nb = getNeighbors(b);
            let intersection = 0;
            na.forEach(n => { if (nb.has(n)) intersection++; });
            const union = na.size + nb.size - intersection;
            return union > 0 ? intersection / union : 0;
        }

        function adamicAdar(a, b) {
            const na = getNeighbors(a);
            const nb = getNeighbors(b);
            let score = 0;
            na.forEach(n => {
                if (nb.has(n)) {
                    const degree = getNeighbors(n).size;
                    if (degree > 1) score += 1 / Math.log(degree);
                }
            });
            return score;
        }

        function preferentialAttachment(a, b) {
            return getNeighbors(a).size * getNeighbors(b).size;
        }

        function calculateScore(a, b) {
            switch (method) {
                case 'common': return commonNeighbors(a, b);
                case 'jaccard': return jaccardCoefficient(a, b);
                case 'adamic': return adamicAdar(a, b);
                case 'preferential': return preferentialAttachment(a, b);
                default: return 0;
            }
        }

        function updatePredictions() {
            predictions = [];

            // Get all non-existing edges
            const existingEdges = new Set();
            edges.forEach(e => {
                existingEdges.add(`${Math.min(e.source, e.target)}-${Math.max(e.source, e.target)}`);
            });

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const key = `${i}-${j}`;
                    if (!existingEdges.has(key)) {
                        const score = calculateScore(i, j);
                        if (score > 0) {
                            predictions.push({ source: i, target: j, score });
                        }
                    }
                }
            }

            predictions.sort((a, b) => b.score - a.score);
            displayPredictions();
        }

        function displayPredictions() {
            const container = document.getElementById('predictions');
            let filtered = predictions;

            if (selectedNode !== null) {
                filtered = predictions.filter(p => p.source === selectedNode || p.target === selectedNode);
            }

            const top10 = filtered.slice(0, 10);

            if (top10.length === 0) {
                container.innerHTML = '<div style="color:#888; font-size:0.85em;">No predictions available</div>';
                return;
            }

            container.innerHTML = top10.map(p => {
                const isHidden = hiddenEdges.some(h =>
                    (h.source === p.source && h.target === p.target) ||
                    (h.source === p.target && h.target === p.source)
                );
                return `
                    <div class="prediction" style="${isHidden ? 'background:rgba(100,255,100,0.1);' : ''}">
                        <span class="node-pair">${p.source} ↔ ${p.target}</span>
                        <span class="score">${p.score.toFixed(3)}${isHidden ? ' ✓' : ''}</span>
                    </div>
                `;
            }).join('');
        }

        function revealHiddenEdges() {
            hiddenEdges.forEach(e => {
                edges.push(e);
            });
            hiddenEdges = [];
            updatePredictions();
        }

        function applyForces() {
            const k = Math.sqrt((canvas.width * canvas.height) / nodes.length) * 0.4;

            nodes.forEach(n => { n.vx = 0; n.vy = 0; });

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = k * k / dist * 0.3;

                    nodes[i].vx -= (dx / dist) * force;
                    nodes[i].vy -= (dy / dist) * force;
                    nodes[j].vx += (dx / dist) * force;
                    nodes[j].vy += (dy / dist) * force;
                }
            }

            edges.forEach(e => {
                const source = nodes[e.source];
                const target = nodes[e.target];
                const dx = target.x - source.x;
                const dy = target.y - source.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                const force = dist / k * 0.5;

                source.vx += (dx / dist) * force;
                source.vy += (dy / dist) * force;
                target.vx -= (dx / dist) * force;
                target.vy -= (dy / dist) * force;
            });

            const cx = (canvas.width - 300) / 2;
            const cy = canvas.height / 2;
            nodes.forEach(n => {
                n.vx += (cx - n.x) * 0.01;
                n.vy += (cy - n.y) * 0.01;
                n.x += n.vx * 0.1;
                n.y += n.vy * 0.1;
                n.x = Math.max(50, Math.min(canvas.width - 350, n.x));
                n.y = Math.max(50, Math.min(canvas.height - 50, n.y));
            });
        }

        function draw() {
            ctx.fillStyle = 'rgba(10, 10, 26, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw existing edges
            ctx.strokeStyle = 'rgba(100, 255, 200, 0.3)';
            ctx.lineWidth = 1;
            edges.forEach(e => {
                ctx.beginPath();
                ctx.moveTo(nodes[e.source].x, nodes[e.source].y);
                ctx.lineTo(nodes[e.target].x, nodes[e.target].y);
                ctx.stroke();
            });

            // Draw predicted edges for selected node
            if (selectedNode !== null) {
                const relevantPreds = predictions
                    .filter(p => p.source === selectedNode || p.target === selectedNode)
                    .slice(0, 5);

                ctx.setLineDash([5, 5]);
                relevantPreds.forEach((p, i) => {
                    const alpha = 0.8 - i * 0.15;
                    ctx.strokeStyle = `rgba(100, 255, 200, ${alpha})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(nodes[p.source].x, nodes[p.source].y);
                    ctx.lineTo(nodes[p.target].x, nodes[p.target].y);
                    ctx.stroke();
                });
                ctx.setLineDash([]);
            }

            // Draw nodes
            const colors = ['#ff6b6b', '#4ecdc4', '#ffe66d'];
            nodes.forEach(node => {
                const isSelected = node.id === selectedNode;
                const size = isSelected ? 10 : 6;

                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                ctx.fillStyle = isSelected ? '#64ffc8' : colors[node.community];
                ctx.fill();

                if (isSelected) {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, 15, 0, Math.PI * 2);
                    ctx.strokeStyle = '#64ffc8';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
        }

        function animate() {
            applyForces();
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.querySelectorAll('.tab').forEach(tab => {
            tab.onclick = () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                method = tab.dataset.method;
                updatePredictions();
            };
        });

        document.getElementById('generateBtn').onclick = generateNetwork;
        document.getElementById('predictBtn').onclick = updatePredictions;
        document.getElementById('revealBtn').onclick = revealHiddenEdges;

        canvas.onclick = (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            for (const node of nodes) {
                const dx = node.x - x;
                const dy = node.y - y;
                if (dx * dx + dy * dy < 150) {
                    selectedNode = node.id;
                    document.getElementById('selectedNode').textContent = `Selected: Node ${node.id}`;
                    displayPredictions();
                    return;
                }
            }

            selectedNode = null;
            document.getElementById('selectedNode').textContent = 'Click a node to select';
            displayPredictions();
        };

        // Initialize
        generateNetwork();
        animate();
    </script>
</body>
</html>
