<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Opinion Dynamics - Network Science</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #eee; min-height: 100vh; padding: 20px; }
        .back-link { position: fixed; top: 20px; left: 20px; color: #4ade80; text-decoration: none; font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px; z-index: 100; }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #4ade80; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(74, 222, 128, 0.1); border: 1px solid rgba(74, 222, 128, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #4ade80; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #0a0a15; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input, .control-group select { width: 100%; }
        .value-display { color: #4ade80; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #4ade80; color: #1a1a2e; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .opinion-bar { height: 20px; background: linear-gradient(to right, #f87171, #facc15, #4ade80); border-radius: 10px; margin: 10px 0; position: relative; }
        .opinion-marker { position: absolute; top: -5px; width: 4px; height: 30px; background: #fff; border-radius: 2px; }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <h1>Opinion Dynamics</h1>
    <p class="subtitle">DeGroot model of consensus formation</p>

    <div class="container">
        <div class="panel">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>

        <div class="panel">
            <div class="info-box">
                <strong>DeGroot Model:</strong>
                Each agent updates their opinion by averaging with neighbors.
                Over time, connected components converge to consensus.
                With bounded confidence, agents only interact if opinions are close enough,
                leading to polarization or fragmentation.
            </div>

            <h3>Model</h3>
            <div class="control-group">
                <select id="modelSelect" onchange="resetSimulation()">
                    <option value="degroot">DeGroot (Average)</option>
                    <option value="bounded">Bounded Confidence</option>
                    <option value="voter">Voter Model</option>
                </select>
            </div>

            <div class="control-group">
                <label>Agents: <span class="value-display" id="nVal">50</span></label>
                <input type="range" id="nSlider" min="20" max="100" value="50" oninput="updateParam()">
            </div>

            <div class="control-group" id="confidenceControl">
                <label>Confidence Threshold: <span class="value-display" id="confVal">0.3</span></label>
                <input type="range" id="confSlider" min="5" max="50" value="30" oninput="updateParam()">
            </div>

            <div class="control-group">
                <label>Stubbornness: <span class="value-display" id="stubVal">0%</span></label>
                <input type="range" id="stubSlider" min="0" max="50" value="0" oninput="updateParam()">
            </div>

            <button class="btn-primary" onclick="runSimulation()">Run Simulation</button>
            <button class="btn-secondary" onclick="stepSimulation()">Step</button>
            <button class="btn-secondary" onclick="resetSimulation()">Reset</button>

            <h3 style="margin-top: 15px;">Opinion Distribution</h3>
            <div class="opinion-bar" id="opinionBar"></div>

            <h3>Statistics</h3>
            <div style="font-size: 0.9em;">
                <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                    <span>Step:</span><span class="value-display" id="stepCount">0</span>
                </div>
                <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                    <span>Opinion Variance:</span><span class="value-display" id="variance">0.00</span>
                </div>
                <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                    <span>Clusters:</span><span class="value-display" id="clusters">1</span>
                </div>
            </div>

            <h3 style="margin-top: 15px;">Opinion Over Time</h3>
            <canvas id="chartCanvas" width="280" height="150"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const chartCanvas = document.getElementById('chartCanvas');
        const cctx = chartCanvas.getContext('2d');

        let agents = [];
        let edges = [];
        let n = 50;
        let confidence = 0.3;
        let stubbornness = 0;
        let step = 0;
        let history = [];
        let running = false;

        function updateParam() {
            n = parseInt(document.getElementById('nSlider').value);
            confidence = parseInt(document.getElementById('confSlider').value) / 100;
            stubbornness = parseInt(document.getElementById('stubSlider').value) / 100;
            document.getElementById('nVal').textContent = n;
            document.getElementById('confVal').textContent = confidence.toFixed(2);
            document.getElementById('stubVal').textContent = Math.round(stubbornness * 100) + '%';

            const model = document.getElementById('modelSelect').value;
            document.getElementById('confidenceControl').style.display = model === 'bounded' ? 'block' : 'none';
        }

        function resetSimulation() {
            running = false;
            step = 0;
            history = [];
            agents = [];
            edges = [];

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            // Create agents with random opinions
            for (let i = 0; i < n; i++) {
                const angle = (2 * Math.PI * i) / n;
                const r = 200;
                agents.push({
                    id: i,
                    opinion: Math.random(),
                    initialOpinion: 0,
                    stubborn: Math.random() < stubbornness,
                    x: cx + r * Math.cos(angle),
                    y: cy + r * Math.sin(angle),
                    vx: 0, vy: 0
                });
                agents[i].initialOpinion = agents[i].opinion;
            }

            // Create network (random geometric graph)
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const dx = agents[i].x - agents[j].x;
                    const dy = agents[i].y - agents[j].y;
                    if (Math.sqrt(dx * dx + dy * dy) < 150) {
                        edges.push([i, j]);
                    }
                }
            }

            updateParam();
            updateStats();
            draw();
            drawChart();
        }

        function stepSimulation() {
            const model = document.getElementById('modelSelect').value;
            step++;

            if (model === 'degroot') {
                // DeGroot averaging
                const newOpinions = agents.map(agent => {
                    if (agent.stubborn) return agent.opinion;

                    const neighbors = edges
                        .filter(e => e[0] === agent.id || e[1] === agent.id)
                        .map(e => e[0] === agent.id ? agents[e[1]] : agents[e[0]]);

                    if (neighbors.length === 0) return agent.opinion;

                    const sum = neighbors.reduce((s, n) => s + n.opinion, agent.opinion);
                    return sum / (neighbors.length + 1);
                });

                agents.forEach((a, i) => a.opinion = newOpinions[i]);

            } else if (model === 'bounded') {
                // Bounded confidence (Deffuant model)
                const i = Math.floor(Math.random() * n);
                const neighbors = edges
                    .filter(e => e[0] === i || e[1] === i)
                    .map(e => e[0] === i ? e[1] : e[0]);

                if (neighbors.length > 0 && !agents[i].stubborn) {
                    const j = neighbors[Math.floor(Math.random() * neighbors.length)];
                    if (Math.abs(agents[i].opinion - agents[j].opinion) < confidence) {
                        const avg = (agents[i].opinion + agents[j].opinion) / 2;
                        if (!agents[i].stubborn) agents[i].opinion = agents[i].opinion * 0.5 + avg * 0.5;
                        if (!agents[j].stubborn) agents[j].opinion = agents[j].opinion * 0.5 + avg * 0.5;
                    }
                }

            } else if (model === 'voter') {
                // Voter model - copy random neighbor
                const i = Math.floor(Math.random() * n);
                if (agents[i].stubborn) return;

                const neighbors = edges
                    .filter(e => e[0] === i || e[1] === i)
                    .map(e => e[0] === i ? e[1] : e[0]);

                if (neighbors.length > 0) {
                    const j = neighbors[Math.floor(Math.random() * neighbors.length)];
                    agents[i].opinion = agents[j].opinion;
                }
            }

            // Record history
            history.push(agents.map(a => a.opinion));
            if (history.length > 200) history.shift();

            updateStats();
            draw();
            drawChart();
        }

        function updateStats() {
            document.getElementById('stepCount').textContent = step;

            const mean = agents.reduce((s, a) => s + a.opinion, 0) / n;
            const variance = agents.reduce((s, a) => s + Math.pow(a.opinion - mean, 2), 0) / n;
            document.getElementById('variance').textContent = variance.toFixed(4);

            // Count clusters (opinions within 0.1 of each other)
            const clusters = countClusters();
            document.getElementById('clusters').textContent = clusters;

            updateOpinionBar();
        }

        function countClusters() {
            const sorted = agents.map(a => a.opinion).sort((a, b) => a - b);
            let clusters = 1;
            for (let i = 1; i < sorted.length; i++) {
                if (sorted[i] - sorted[i - 1] > 0.1) clusters++;
            }
            return clusters;
        }

        function updateOpinionBar() {
            const bar = document.getElementById('opinionBar');
            bar.innerHTML = agents.map(a => {
                const left = a.opinion * 100;
                return `<div class="opinion-marker" style="left: ${left}%"></div>`;
            }).join('');
        }

        function draw() {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw edges
            for (const [i, j] of edges) {
                const ai = agents[i], aj = agents[j];
                const opinionDiff = Math.abs(ai.opinion - aj.opinion);
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.3 - opinionDiff * 0.3})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(ai.x, ai.y);
                ctx.lineTo(aj.x, aj.y);
                ctx.stroke();
            }

            // Draw agents
            for (const agent of agents) {
                const hue = agent.opinion * 120; // Red (0) to Green (120)
                const size = agent.stubborn ? 12 : 8;

                ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                ctx.beginPath();
                ctx.arc(agent.x, agent.y, size, 0, Math.PI * 2);
                ctx.fill();

                if (agent.stubborn) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText(`Step: ${step}`, 20, 30);
        }

        function drawChart() {
            cctx.fillStyle = '#0a0a15';
            cctx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);

            if (history.length < 2) return;

            // Draw opinion trajectories
            for (let i = 0; i < n; i++) {
                const hue = agents[i].initialOpinion * 120;
                cctx.strokeStyle = `hsla(${hue}, 70%, 50%, 0.5)`;
                cctx.lineWidth = 1;
                cctx.beginPath();

                for (let t = 0; t < history.length; t++) {
                    const x = (t / (history.length - 1)) * chartCanvas.width;
                    const y = (1 - history[t][i]) * chartCanvas.height;
                    if (t === 0) cctx.moveTo(x, y);
                    else cctx.lineTo(x, y);
                }
                cctx.stroke();
            }
        }

        async function runSimulation() {
            if (running) {
                running = false;
                return;
            }
            running = true;

            while (running && step < 500) {
                const model = document.getElementById('modelSelect').value;
                const iterations = model === 'bounded' || model === 'voter' ? 10 : 1;
                for (let i = 0; i < iterations; i++) {
                    stepSimulation();
                }
                await new Promise(r => setTimeout(r, 50));
            }

            running = false;
        }

        resetSimulation();
    </script>
</body>
</html>
