<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Resilience - Network Science</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #eee; min-height: 100vh; padding: 20px; }
        .back-link { position: fixed; top: 20px; left: 20px; color: #4ade80; text-decoration: none; font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px; z-index: 100; }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #4ade80; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(74, 222, 128, 0.1); border: 1px solid rgba(74, 222, 128, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #4ade80; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #0a0a15; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input { width: 100%; }
        .value-display { color: #4ade80; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #4ade80; color: #1a1a2e; }
        .btn-danger { background: #f87171; color: #fff; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .comparison { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0; }
        .metric-box { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px; text-align: center; }
        .metric-value { font-size: 1.5em; font-weight: bold; color: #4ade80; }
        .metric-label { font-size: 0.8em; opacity: 0.8; }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <h1>Network Resilience</h1>
    <p class="subtitle">Targeted vs random attack robustness</p>

    <div class="container">
        <div class="panel">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>

        <div class="panel">
            <div class="info-box">
                <strong>Network Resilience:</strong>
                Scale-free networks are robust to random failures but vulnerable to targeted attacks on hubs.
                Random networks are more uniformly affected by both attack types.
                This has implications for infrastructure protection.
            </div>

            <h3>Attack Mode</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <button class="btn-primary" id="randomBtn" onclick="setAttackMode('random')">Random</button>
                <button class="btn-secondary" id="targetedBtn" onclick="setAttackMode('targeted')">Targeted</button>
            </div>

            <div class="control-group">
                <label>Network Size: <span class="value-display" id="nVal">50</span></label>
                <input type="range" id="nSlider" min="30" max="100" value="50" oninput="updateParam()">
            </div>

            <div class="control-group">
                <label>Network Type:</label>
                <select id="networkType" style="width: 100%; padding: 8px; border-radius: 4px;">
                    <option value="scalefree">Scale-Free (Barabási-Albert)</option>
                    <option value="random">Random (Erdős-Rényi)</option>
                </select>
            </div>

            <button class="btn-primary" onclick="generateNetwork()">Generate Network</button>
            <button class="btn-danger" onclick="attackNode()">Attack Node</button>
            <button class="btn-secondary" onclick="autoAttack()">Auto Attack</button>

            <h3 style="margin-top: 15px;">Network Metrics</h3>
            <div class="comparison">
                <div class="metric-box">
                    <div class="metric-value" id="nodesRemaining">50</div>
                    <div class="metric-label">Nodes Remaining</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value" id="giantComponent">50</div>
                    <div class="metric-label">Giant Component</div>
                </div>
            </div>
            <div class="comparison">
                <div class="metric-box">
                    <div class="metric-value" id="avgDegree">0.0</div>
                    <div class="metric-label">Avg Degree</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value" id="components">1</div>
                    <div class="metric-label">Components</div>
                </div>
            </div>

            <h3 style="margin-top: 15px;">Giant Component Size</h3>
            <canvas id="chartCanvas" width="280" height="120"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const chartCanvas = document.getElementById('chartCanvas');
        const cctx = chartCanvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let n = 50;
        let attackMode = 'random';
        let history = [];
        let running = false;

        function updateParam() {
            n = parseInt(document.getElementById('nSlider').value);
            document.getElementById('nVal').textContent = n;
        }

        function setAttackMode(mode) {
            attackMode = mode;
            document.getElementById('randomBtn').className = mode === 'random' ? 'btn-primary' : 'btn-secondary';
            document.getElementById('targetedBtn').className = mode === 'targeted' ? 'btn-primary' : 'btn-secondary';
        }

        function generateNetwork() {
            running = false;
            nodes = [];
            edges = [];
            history = [];

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const networkType = document.getElementById('networkType').value;

            for (let i = 0; i < n; i++) {
                const angle = (2 * Math.PI * i) / n + Math.random() * 0.3;
                const r = 180 + Math.random() * 50;
                nodes.push({
                    id: i,
                    x: cx + r * Math.cos(angle),
                    y: cy + r * Math.sin(angle),
                    degree: 0,
                    removed: false,
                    vx: 0, vy: 0
                });
            }

            if (networkType === 'scalefree') {
                // Barabási-Albert preferential attachment
                for (let i = 0; i < Math.min(3, n); i++) {
                    for (let j = 0; j < i; j++) {
                        addEdge(i, j);
                    }
                }
                for (let i = 3; i < n; i++) {
                    const totalDegree = nodes.slice(0, i).reduce((s, n) => s + Math.max(n.degree, 1), 0);
                    const targets = new Set();
                    while (targets.size < 2) {
                        let r = Math.random() * totalDegree;
                        for (let j = 0; j < i; j++) {
                            r -= Math.max(nodes[j].degree, 1);
                            if (r <= 0) { targets.add(j); break; }
                        }
                    }
                    for (const t of targets) addEdge(i, t);
                }
            } else {
                // Erdős-Rényi random graph
                const p = 4 / n;
                for (let i = 0; i < n; i++) {
                    for (let j = i + 1; j < n; j++) {
                        if (Math.random() < p) addEdge(i, j);
                    }
                }
            }

            layoutNetwork();
            recordHistory();
            updateStats();
            draw();
            drawChart();
        }

        function addEdge(i, j) {
            edges.push([i, j]);
            nodes[i].degree++;
            nodes[j].degree++;
        }

        function layoutNetwork() {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            for (let iter = 0; iter < 50; iter++) {
                for (let i = 0; i < nodes.length; i++) {
                    if (nodes[i].removed) continue;
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (nodes[j].removed) continue;
                        const dx = nodes[j].x - nodes[i].x;
                        const dy = nodes[j].y - nodes[i].y;
                        const dist = Math.max(Math.sqrt(dx * dx + dy * dy), 1);
                        const force = 3000 / (dist * dist);
                        nodes[i].vx -= (dx / dist) * force;
                        nodes[i].vy -= (dy / dist) * force;
                        nodes[j].vx += (dx / dist) * force;
                        nodes[j].vy += (dy / dist) * force;
                    }
                }

                for (const [i, j] of edges) {
                    if (nodes[i].removed || nodes[j].removed) continue;
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const force = (dist - 70) * 0.1;
                    nodes[i].vx += (dx / dist) * force;
                    nodes[i].vy += (dy / dist) * force;
                    nodes[j].vx -= (dx / dist) * force;
                    nodes[j].vy -= (dy / dist) * force;
                }

                nodes.forEach(node => {
                    if (node.removed) return;
                    node.vx += (cx - node.x) * 0.01;
                    node.vy += (cy - node.y) * 0.01;
                    node.x += node.vx * 0.1;
                    node.y += node.vy * 0.1;
                    node.vx *= 0.9;
                    node.vy *= 0.9;
                });
            }
        }

        function attackNode() {
            const active = nodes.filter(n => !n.removed);
            if (active.length === 0) return;

            let target;
            if (attackMode === 'targeted') {
                // Target highest degree node
                target = active.reduce((max, n) => n.degree > max.degree ? n : max, active[0]);
            } else {
                // Random attack
                target = active[Math.floor(Math.random() * active.length)];
            }

            target.removed = true;

            // Update neighbor degrees
            for (const [i, j] of edges) {
                if (i === target.id && !nodes[j].removed) nodes[j].degree--;
                if (j === target.id && !nodes[i].removed) nodes[i].degree--;
            }

            recordHistory();
            updateStats();
            draw();
            drawChart();
        }

        async function autoAttack() {
            if (running) {
                running = false;
                return;
            }
            running = true;

            while (running && nodes.some(n => !n.removed)) {
                attackNode();
                await new Promise(r => setTimeout(r, 200));
            }

            running = false;
        }

        function findComponents() {
            const active = nodes.filter(n => !n.removed);
            const visited = new Set();
            const components = [];

            function bfs(start) {
                const component = [start];
                const queue = [start];
                visited.add(start.id);

                while (queue.length > 0) {
                    const node = queue.shift();
                    for (const [i, j] of edges) {
                        if (nodes[i].removed || nodes[j].removed) continue;
                        let neighbor = null;
                        if (i === node.id && !visited.has(j)) neighbor = nodes[j];
                        if (j === node.id && !visited.has(i)) neighbor = nodes[i];
                        if (neighbor) {
                            visited.add(neighbor.id);
                            component.push(neighbor);
                            queue.push(neighbor);
                        }
                    }
                }
                return component;
            }

            for (const node of active) {
                if (!visited.has(node.id)) {
                    components.push(bfs(node));
                }
            }

            return components;
        }

        function recordHistory() {
            const components = findComponents();
            const giantSize = components.length > 0 ? Math.max(...components.map(c => c.length)) : 0;
            history.push({
                removed: nodes.filter(n => n.removed).length,
                giantComponent: giantSize
            });
        }

        function updateStats() {
            const active = nodes.filter(n => !n.removed);
            const components = findComponents();
            const giantSize = components.length > 0 ? Math.max(...components.map(c => c.length)) : 0;
            const totalDegree = active.reduce((s, n) => s + n.degree, 0);
            const avgDegree = active.length > 0 ? totalDegree / active.length : 0;

            document.getElementById('nodesRemaining').textContent = active.length;
            document.getElementById('giantComponent').textContent = giantSize;
            document.getElementById('avgDegree').textContent = avgDegree.toFixed(1);
            document.getElementById('components').textContent = components.length;
        }

        function draw() {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw edges
            for (const [i, j] of edges) {
                if (nodes[i].removed || nodes[j].removed) continue;
                ctx.strokeStyle = 'rgba(74, 222, 128, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(nodes[i].x, nodes[i].y);
                ctx.lineTo(nodes[j].x, nodes[j].y);
                ctx.stroke();
            }

            // Draw nodes
            for (const node of nodes) {
                if (node.removed) continue;
                const size = 5 + node.degree * 1.5;
                const hue = node.degree > 5 ? 0 : 120; // Red for hubs, green for others
                ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Attack mode indicator
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText(`Attack Mode: ${attackMode.toUpperCase()}`, 20, 30);
        }

        function drawChart() {
            cctx.fillStyle = '#0a0a15';
            cctx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);

            if (history.length < 2) return;

            cctx.strokeStyle = '#4ade80';
            cctx.lineWidth = 2;
            cctx.beginPath();
            history.forEach((h, i) => {
                const x = (i / (history.length - 1)) * chartCanvas.width;
                const y = chartCanvas.height - (h.giantComponent / n) * chartCanvas.height;
                if (i === 0) cctx.moveTo(x, y);
                else cctx.lineTo(x, y);
            });
            cctx.stroke();

            cctx.fillStyle = '#fff';
            cctx.font = '10px sans-serif';
            cctx.fillText('Giant Component vs Removed Nodes', 5, 12);
        }

        // Click to remove node
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            for (const node of nodes) {
                if (node.removed) continue;
                const dx = node.x - x;
                const dy = node.y - y;
                if (Math.sqrt(dx * dx + dy * dy) < 15) {
                    node.removed = true;
                    for (const [i, j] of edges) {
                        if (i === node.id && !nodes[j].removed) nodes[j].degree--;
                        if (j === node.id && !nodes[i].removed) nodes[i].degree--;
                    }
                    recordHistory();
                    updateStats();
                    draw();
                    drawChart();
                    break;
                }
            }
        });

        updateParam();
        generateNetwork();
    </script>
</body>
</html>
