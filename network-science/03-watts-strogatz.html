<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Watts-Strogatz Small World | Network Science</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(150, 255, 150, 0.3);
        }
        h1 { color: #96ff96; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"] { width: 100%; }
        .value { float: right; color: #96ff96; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #96ff96; color: #0a0a1a;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #b8ffb8; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #96ff96; font-weight: bold; }
        .network-type { padding: 10px; margin: 10px 0; border-radius: 8px; text-align: center; }
        .regular { background: rgba(100,100,255,0.2); color: #88f; }
        .small-world { background: rgba(150,255,150,0.2); color: #96ff96; }
        .random { background: rgba(255,100,100,0.2); color: #f88; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #96ff96; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        #metricsChart { margin-top: 10px; background: rgba(0,0,0,0.3); border-radius: 8px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">← Back to Network Science</a>

    <div class="controls">
        <h1>Watts-Strogatz Model</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Small-world network with tunable rewiring</p>

        <div class="control-group">
            <label>Nodes (n): <span class="value" id="nValue">60</span></label>
            <input type="range" id="nNodes" min="20" max="120" value="60">
        </div>

        <div class="control-group">
            <label>Neighbors (k): <span class="value" id="kValue">4</span></label>
            <input type="range" id="kNeighbors" min="2" max="10" step="2" value="4">
        </div>

        <div class="control-group">
            <label>Rewiring Prob (β): <span class="value" id="betaValue">0.1</span></label>
            <input type="range" id="beta" min="0" max="1" step="0.01" value="0.1">
        </div>

        <div class="network-type" id="networkType">Small World</div>

        <button id="generateBtn">Generate Network</button>
        <button id="animateBetaBtn">Animate β</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Clustering Coef</span>
                <span class="stat-value" id="clustering">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Avg Path Length</span>
                <span class="stat-value" id="pathLength">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Rewired Edges</span>
                <span class="stat-value" id="rewiredCount">0</span>
            </div>
        </div>

        <canvas id="metricsChart" width="240" height="80"></canvas>

        <div class="info">
            <strong>Small World:</strong> High clustering (like regular lattice) + short path lengths (like random graph). Achieved with small rewiring probability β ≈ 0.01-0.1.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const chartCanvas = document.getElementById('metricsChart');
        const chartCtx = chartCanvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let n = 60;
        let k = 4;
        let beta = 0.1;
        let rewiredCount = 0;
        let animatingBeta = false;
        let metricsHistory = [];

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        function generateNetwork() {
            nodes = [];
            edges = [];
            rewiredCount = 0;

            const cx = (canvas.width - 300) / 2;
            const cy = canvas.height / 2;
            const r = Math.min(cx, cy) * 0.8;

            // Create nodes in a ring
            for (let i = 0; i < n; i++) {
                const angle = (i / n) * Math.PI * 2 - Math.PI / 2;
                nodes.push({
                    id: i,
                    x: cx + Math.cos(angle) * r,
                    y: cy + Math.sin(angle) * r,
                    angle: angle
                });
            }

            // Create regular ring lattice edges
            const edgeSet = new Set();
            for (let i = 0; i < n; i++) {
                for (let j = 1; j <= k / 2; j++) {
                    const target = (i + j) % n;
                    const edgeKey = Math.min(i, target) + '-' + Math.max(i, target);
                    if (!edgeSet.has(edgeKey)) {
                        edges.push({ source: i, target: target, rewired: false });
                        edgeSet.add(edgeKey);
                    }
                }
            }

            // Rewire edges with probability beta
            edges.forEach(edge => {
                if (Math.random() < beta) {
                    // Find new target
                    let newTarget;
                    let attempts = 0;
                    do {
                        newTarget = Math.floor(Math.random() * n);
                        attempts++;
                    } while (
                        (newTarget === edge.source ||
                         newTarget === edge.target ||
                         edgeSet.has(Math.min(edge.source, newTarget) + '-' + Math.max(edge.source, newTarget))) &&
                        attempts < 100
                    );

                    if (attempts < 100) {
                        edgeSet.delete(Math.min(edge.source, edge.target) + '-' + Math.max(edge.source, edge.target));
                        edge.target = newTarget;
                        edge.rewired = true;
                        edgeSet.add(Math.min(edge.source, newTarget) + '-' + Math.max(edge.source, newTarget));
                        rewiredCount++;
                    }
                }
            });

            updateStats();
            draw();
        }

        function calculateClustering() {
            // Build adjacency list
            const adj = nodes.map(() => new Set());
            edges.forEach(e => {
                adj[e.source].add(e.target);
                adj[e.target].add(e.source);
            });

            let totalC = 0;
            let count = 0;

            nodes.forEach((_, i) => {
                const neighbors = Array.from(adj[i]);
                if (neighbors.length < 2) return;

                let triangles = 0;
                for (let a = 0; a < neighbors.length; a++) {
                    for (let b = a + 1; b < neighbors.length; b++) {
                        if (adj[neighbors[a]].has(neighbors[b])) {
                            triangles++;
                        }
                    }
                }

                const possible = neighbors.length * (neighbors.length - 1) / 2;
                totalC += triangles / possible;
                count++;
            });

            return count > 0 ? totalC / count : 0;
        }

        function calculateAvgPathLength() {
            // BFS from each node
            const adj = nodes.map(() => []);
            edges.forEach(e => {
                adj[e.source].push(e.target);
                adj[e.target].push(e.source);
            });

            let totalDist = 0;
            let pairs = 0;

            for (let start = 0; start < n; start++) {
                const dist = new Array(n).fill(Infinity);
                dist[start] = 0;
                const queue = [start];

                while (queue.length > 0) {
                    const curr = queue.shift();
                    for (const next of adj[curr]) {
                        if (dist[next] === Infinity) {
                            dist[next] = dist[curr] + 1;
                            queue.push(next);
                        }
                    }
                }

                for (let i = start + 1; i < n; i++) {
                    if (dist[i] !== Infinity) {
                        totalDist += dist[i];
                        pairs++;
                    }
                }
            }

            return pairs > 0 ? totalDist / pairs : 0;
        }

        function draw() {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw edges
            edges.forEach(e => {
                const source = nodes[e.source];
                const target = nodes[e.target];

                ctx.beginPath();
                if (e.rewired) {
                    ctx.strokeStyle = 'rgba(255, 150, 150, 0.6)';
                    ctx.lineWidth = 2;
                } else {
                    ctx.strokeStyle = 'rgba(150, 255, 150, 0.3)';
                    ctx.lineWidth = 1;
                }
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(target.x, target.y);
                ctx.stroke();
            });

            // Draw nodes
            nodes.forEach(node => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#96ff96';
                ctx.fill();
                ctx.strokeStyle = '#0a0a1a';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        function updateStats() {
            const clustering = calculateClustering();
            const pathLength = calculateAvgPathLength();

            document.getElementById('clustering').textContent = clustering.toFixed(3);
            document.getElementById('pathLength').textContent = pathLength.toFixed(2);
            document.getElementById('rewiredCount').textContent = rewiredCount;

            // Network type indicator
            const type = document.getElementById('networkType');
            if (beta < 0.01) {
                type.textContent = 'Regular Lattice';
                type.className = 'network-type regular';
            } else if (beta > 0.5) {
                type.textContent = 'Random Network';
                type.className = 'network-type random';
            } else {
                type.textContent = 'Small World';
                type.className = 'network-type small-world';
            }

            // Record metrics
            metricsHistory.push({ beta, clustering, pathLength });
            if (metricsHistory.length > 50) metricsHistory.shift();

            drawMetricsChart();
        }

        function drawMetricsChart() {
            const w = chartCanvas.width;
            const h = chartCanvas.height;
            chartCtx.fillStyle = 'rgba(0,0,0,0.5)';
            chartCtx.fillRect(0, 0, w, h);

            if (metricsHistory.length < 2) return;

            // Normalize values
            const maxC = Math.max(...metricsHistory.map(m => m.clustering), 0.001);
            const maxL = Math.max(...metricsHistory.map(m => m.pathLength), 0.001);

            // Draw clustering
            chartCtx.strokeStyle = '#96ff96';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();
            metricsHistory.forEach((m, i) => {
                const x = (i / (metricsHistory.length - 1)) * w;
                const y = h - (m.clustering / maxC) * (h - 20) - 10;
                if (i === 0) chartCtx.moveTo(x, y);
                else chartCtx.lineTo(x, y);
            });
            chartCtx.stroke();

            // Draw path length
            chartCtx.strokeStyle = '#ff9696';
            chartCtx.beginPath();
            metricsHistory.forEach((m, i) => {
                const x = (i / (metricsHistory.length - 1)) * w;
                const y = h - (m.pathLength / maxL) * (h - 20) - 10;
                if (i === 0) chartCtx.moveTo(x, y);
                else chartCtx.lineTo(x, y);
            });
            chartCtx.stroke();

            // Labels
            chartCtx.font = '10px sans-serif';
            chartCtx.fillStyle = '#96ff96';
            chartCtx.fillText('C', 5, 12);
            chartCtx.fillStyle = '#ff9696';
            chartCtx.fillText('L', 20, 12);
        }

        function animate() {
            if (animatingBeta) {
                beta += 0.005;
                if (beta > 1) {
                    beta = 0;
                    metricsHistory = [];
                }
                document.getElementById('beta').value = beta;
                document.getElementById('betaValue').textContent = beta.toFixed(2);
                generateNetwork();
            }

            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('nNodes').oninput = (e) => {
            n = parseInt(e.target.value);
            document.getElementById('nValue').textContent = n;
        };

        document.getElementById('kNeighbors').oninput = (e) => {
            k = parseInt(e.target.value);
            document.getElementById('kValue').textContent = k;
        };

        document.getElementById('beta').oninput = (e) => {
            beta = parseFloat(e.target.value);
            document.getElementById('betaValue').textContent = beta.toFixed(2);
        };

        document.getElementById('generateBtn').onclick = generateNetwork;

        document.getElementById('animateBetaBtn').onclick = () => {
            animatingBeta = !animatingBeta;
            if (animatingBeta) {
                beta = 0;
                metricsHistory = [];
                document.getElementById('animateBetaBtn').textContent = 'Stop Animation';
            } else {
                document.getElementById('animateBetaBtn').textContent = 'Animate β';
            }
        };

        // Initialize
        generateNetwork();
        animate();
    </script>
</body>
</html>
