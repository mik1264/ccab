<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Barabási-Albert Network | Network Science</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(100, 200, 255, 0.3);
        }
        h1 { color: #64c8ff; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        input[type="range"] { width: 100%; }
        .value { float: right; color: #64c8ff; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #64c8ff; color: #0a0a1a;
            font-weight: bold; cursor: pointer;
            transition: all 0.3s;
        }
        button:hover { background: #8ed8ff; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #64c8ff; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #64c8ff; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        #degreeChart { margin-top: 10px; background: rgba(0,0,0,0.3); border-radius: 8px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">← Back to Network Science</a>

    <div class="controls">
        <h1>Barabási-Albert Network</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Scale-free network with preferential attachment</p>

        <div class="control-group">
            <label>Network Size (n): <span class="value" id="nValue">100</span></label>
            <input type="range" id="nNodes" min="20" max="300" value="100">
        </div>

        <div class="control-group">
            <label>Edges per Node (m): <span class="value" id="mValue">2</span></label>
            <input type="range" id="mEdges" min="1" max="5" value="2">
        </div>

        <div class="control-group">
            <label>Animation Speed: <span class="value" id="speedValue">50</span></label>
            <input type="range" id="speed" min="1" max="100" value="50">
        </div>

        <button id="generateBtn">Generate Network</button>
        <button id="stepBtn">Step (Add Node)</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="nodeCount">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="edgeCount">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Max Degree</span>
                <span class="stat-value" id="maxDegree">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Avg Degree</span>
                <span class="stat-value" id="avgDegree">0</span>
            </div>
        </div>

        <canvas id="degreeChart" width="240" height="100"></canvas>

        <div class="info">
            <strong>Preferential Attachment:</strong> New nodes connect preferentially to high-degree nodes (the "rich get richer" effect), creating power-law degree distributions.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const chartCanvas = document.getElementById('degreeChart');
        const chartCtx = chartCanvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let targetN = 100;
        let m = 2;
        let animating = false;
        let animationId = null;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        function initNetwork() {
            nodes = [];
            edges = [];

            // Start with m+1 fully connected nodes
            for (let i = 0; i <= m; i++) {
                nodes.push({
                    id: i,
                    x: canvas.width/2 + Math.cos(i * 2 * Math.PI / (m+1)) * 100,
                    y: canvas.height/2 + Math.sin(i * 2 * Math.PI / (m+1)) * 100,
                    vx: 0, vy: 0,
                    degree: m
                });
            }

            // Connect initial nodes
            for (let i = 0; i <= m; i++) {
                for (let j = i + 1; j <= m; j++) {
                    edges.push({ source: i, target: j });
                }
            }

            updateStats();
            draw();
        }

        function addNode() {
            if (nodes.length >= targetN) return false;

            const newId = nodes.length;
            const newNode = {
                id: newId,
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: 0, vy: 0,
                degree: 0
            };

            // Preferential attachment
            const totalDegree = nodes.reduce((sum, n) => sum + n.degree, 0);
            const targets = new Set();

            while (targets.size < m) {
                let r = Math.random() * totalDegree;
                for (const node of nodes) {
                    r -= node.degree;
                    if (r <= 0) {
                        targets.add(node.id);
                        break;
                    }
                }
            }

            targets.forEach(targetId => {
                edges.push({ source: newId, target: targetId });
                nodes[targetId].degree++;
                newNode.degree++;
            });

            nodes.push(newNode);
            return true;
        }

        function applyForces() {
            const k = Math.sqrt((canvas.width * canvas.height) / nodes.length) * 0.5;

            // Reset velocities
            nodes.forEach(n => { n.vx = 0; n.vy = 0; });

            // Repulsion between all nodes
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = k * k / dist;

                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;

                    nodes[i].vx -= fx;
                    nodes[i].vy -= fy;
                    nodes[j].vx += fx;
                    nodes[j].vy += fy;
                }
            }

            // Attraction along edges
            edges.forEach(e => {
                const source = nodes[e.source];
                const target = nodes[e.target];
                const dx = target.x - source.x;
                const dy = target.y - source.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                const force = dist / k;

                const fx = (dx / dist) * force;
                const fy = (dy / dist) * force;

                source.vx += fx;
                source.vy += fy;
                target.vx -= fx;
                target.vy -= fy;
            });

            // Center gravity
            nodes.forEach(n => {
                n.vx += (canvas.width/2 - n.x) * 0.01;
                n.vy += (canvas.height/2 - n.y) * 0.01;
            });

            // Apply velocities with damping
            nodes.forEach(n => {
                n.x += n.vx * 0.1;
                n.y += n.vy * 0.1;

                // Keep in bounds
                n.x = Math.max(50, Math.min(canvas.width - 350, n.x));
                n.y = Math.max(50, Math.min(canvas.height - 50, n.y));
            });
        }

        function draw() {
            ctx.fillStyle = 'rgba(10, 10, 26, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw edges
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.2)';
            ctx.lineWidth = 1;
            edges.forEach(e => {
                const source = nodes[e.source];
                const target = nodes[e.target];
                ctx.beginPath();
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(target.x, target.y);
                ctx.stroke();
            });

            // Draw nodes
            const maxDeg = Math.max(...nodes.map(n => n.degree), 1);
            nodes.forEach(n => {
                const size = 3 + (n.degree / maxDeg) * 15;
                const alpha = 0.5 + (n.degree / maxDeg) * 0.5;

                ctx.beginPath();
                ctx.arc(n.x, n.y, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(100, 200, 255, ${alpha})`;
                ctx.fill();

                // Glow for high-degree nodes
                if (n.degree > maxDeg * 0.5) {
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, size + 5, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(100, 200, 255, 0.1)`;
                    ctx.fill();
                }
            });
        }

        function updateStats() {
            const maxDeg = Math.max(...nodes.map(n => n.degree), 0);
            const avgDeg = nodes.length > 0 ?
                (nodes.reduce((s, n) => s + n.degree, 0) / nodes.length).toFixed(2) : 0;

            document.getElementById('nodeCount').textContent = nodes.length;
            document.getElementById('edgeCount').textContent = edges.length;
            document.getElementById('maxDegree').textContent = maxDeg;
            document.getElementById('avgDegree').textContent = avgDeg;

            drawDegreeChart();
        }

        function drawDegreeChart() {
            const w = chartCanvas.width;
            const h = chartCanvas.height;
            chartCtx.fillStyle = 'rgba(0,0,0,0.5)';
            chartCtx.fillRect(0, 0, w, h);

            if (nodes.length === 0) return;

            // Create degree histogram
            const degreeCounts = {};
            nodes.forEach(n => {
                degreeCounts[n.degree] = (degreeCounts[n.degree] || 0) + 1;
            });

            const degrees = Object.keys(degreeCounts).map(Number).sort((a, b) => a - b);
            const maxCount = Math.max(...Object.values(degreeCounts));
            const maxDegree = Math.max(...degrees);

            // Draw bars
            chartCtx.fillStyle = '#64c8ff';
            degrees.forEach(deg => {
                const x = (deg / maxDegree) * (w - 20) + 10;
                const barH = (degreeCounts[deg] / maxCount) * (h - 20);
                chartCtx.fillRect(x - 3, h - barH - 10, 6, barH);
            });

            // Labels
            chartCtx.fillStyle = '#666';
            chartCtx.font = '10px sans-serif';
            chartCtx.fillText('Degree Distribution', 10, 12);
        }

        let lastAddTime = 0;
        function animate(time) {
            const speed = parseInt(document.getElementById('speed').value);
            const interval = 1000 / speed;

            if (time - lastAddTime > interval && nodes.length < targetN) {
                addNode();
                updateStats();
                lastAddTime = time;
            }

            applyForces();
            draw();

            if (animating) {
                animationId = requestAnimationFrame(animate);
            }
        }

        // Event listeners
        document.getElementById('nNodes').oninput = (e) => {
            targetN = parseInt(e.target.value);
            document.getElementById('nValue').textContent = targetN;
        };

        document.getElementById('mEdges').oninput = (e) => {
            m = parseInt(e.target.value);
            document.getElementById('mValue').textContent = m;
        };

        document.getElementById('speed').oninput = (e) => {
            document.getElementById('speedValue').textContent = e.target.value;
        };

        document.getElementById('generateBtn').onclick = () => {
            animating = true;
            initNetwork();
            lastAddTime = 0;
            if (!animationId) animate(0);
        };

        document.getElementById('stepBtn').onclick = () => {
            if (nodes.length === 0) initNetwork();
            else {
                addNode();
                updateStats();
            }
            applyForces();
            draw();
        };

        // Initialize
        initNetwork();
        animating = true;
        animate(0);
    </script>
</body>
</html>
