<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centrality Measures - Network Science</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #eee; min-height: 100vh; padding: 20px; }
        .back-link { position: fixed; top: 20px; left: 20px; color: #4ade80; text-decoration: none; font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px; z-index: 100; }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #4ade80; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(74, 222, 128, 0.1); border: 1px solid rgba(74, 222, 128, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #4ade80; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #0a0a15; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input, .control-group select { width: 100%; padding: 8px; border-radius: 4px; }
        .value-display { color: #4ade80; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #4ade80; color: #1a1a2e; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .top-nodes { max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px; }
        .node-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 5px; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .node-item:last-child { border-bottom: none; }
        .node-bar { height: 4px; background: #4ade80; border-radius: 2px; margin-top: 3px; }
        .centrality-badge { padding: 2px 8px; border-radius: 10px; font-size: 0.8em; font-weight: 600; }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <h1>Centrality Measures</h1>
    <p class="subtitle">Degree, betweenness, closeness, and PageRank</p>

    <div class="container">
        <div class="panel">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>

        <div class="panel">
            <div class="info-box">
                <strong>Centrality Measures:</strong><br>
                <b>Degree:</b> Number of connections<br>
                <b>Betweenness:</b> Bridges between communities<br>
                <b>Closeness:</b> Average distance to all nodes<br>
                <b>PageRank:</b> Importance from neighbors
            </div>

            <h3>Centrality Type</h3>
            <div class="control-group">
                <select id="centralitySelect" onchange="computeCentrality()">
                    <option value="degree">Degree Centrality</option>
                    <option value="betweenness">Betweenness Centrality</option>
                    <option value="closeness">Closeness Centrality</option>
                    <option value="pagerank">PageRank</option>
                    <option value="eigenvector">Eigenvector Centrality</option>
                </select>
            </div>

            <div class="control-group">
                <label>Network Size: <span class="value-display" id="nVal">50</span></label>
                <input type="range" id="nSlider" min="20" max="80" value="50" oninput="updateParam()">
            </div>

            <div class="control-group">
                <label>Network Type:</label>
                <select id="networkType" onchange="generateNetwork()">
                    <option value="scalefree">Scale-Free</option>
                    <option value="clustered">Clustered</option>
                    <option value="random">Random</option>
                </select>
            </div>

            <button class="btn-primary" onclick="generateNetwork()">Generate Network</button>

            <h3 style="margin-top: 15px;">Top 10 Central Nodes</h3>
            <div class="top-nodes" id="topNodes">
                Generate a network to see rankings...
            </div>

            <h3 style="margin-top: 15px;">Distribution</h3>
            <canvas id="chartCanvas" width="280" height="100"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const chartCanvas = document.getElementById('chartCanvas');
        const cctx = chartCanvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let n = 50;
        let centrality = [];
        let selectedNode = null;

        function updateParam() {
            n = parseInt(document.getElementById('nSlider').value);
            document.getElementById('nVal').textContent = n;
        }

        function generateNetwork() {
            nodes = [];
            edges = [];
            selectedNode = null;

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const networkType = document.getElementById('networkType').value;

            for (let i = 0; i < n; i++) {
                const angle = (2 * Math.PI * i) / n;
                const r = 200;
                nodes.push({
                    id: i,
                    x: cx + r * Math.cos(angle),
                    y: cy + r * Math.sin(angle),
                    degree: 0,
                    centrality: 0,
                    vx: 0, vy: 0
                });
            }

            if (networkType === 'scalefree') {
                for (let i = 0; i < Math.min(3, n); i++) {
                    for (let j = 0; j < i; j++) addEdge(i, j);
                }
                for (let i = 3; i < n; i++) {
                    const totalDegree = nodes.slice(0, i).reduce((s, n) => s + Math.max(n.degree, 1), 0);
                    const targets = new Set();
                    while (targets.size < 2) {
                        let r = Math.random() * totalDegree;
                        for (let j = 0; j < i; j++) {
                            r -= Math.max(nodes[j].degree, 1);
                            if (r <= 0) { targets.add(j); break; }
                        }
                    }
                    for (const t of targets) addEdge(i, t);
                }
            } else if (networkType === 'clustered') {
                const numClusters = 4;
                for (let i = 0; i < n; i++) {
                    const cluster = Math.floor(i / (n / numClusters));
                    nodes[i].cluster = cluster;
                    const clusterAngle = (2 * Math.PI * cluster) / numClusters;
                    nodes[i].x = cx + 150 * Math.cos(clusterAngle) + (Math.random() - 0.5) * 100;
                    nodes[i].y = cy + 150 * Math.sin(clusterAngle) + (Math.random() - 0.5) * 100;
                }
                for (let i = 0; i < n; i++) {
                    for (let j = i + 1; j < n; j++) {
                        const sameCluster = nodes[i].cluster === nodes[j].cluster;
                        const p = sameCluster ? 0.4 : 0.02;
                        if (Math.random() < p) addEdge(i, j);
                    }
                }
            } else {
                const p = 4 / n;
                for (let i = 0; i < n; i++) {
                    for (let j = i + 1; j < n; j++) {
                        if (Math.random() < p) addEdge(i, j);
                    }
                }
            }

            layoutNetwork();
            computeCentrality();
        }

        function addEdge(i, j) {
            edges.push([i, j]);
            nodes[i].degree++;
            nodes[j].degree++;
        }

        function layoutNetwork() {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            for (let iter = 0; iter < 60; iter++) {
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const dx = nodes[j].x - nodes[i].x;
                        const dy = nodes[j].y - nodes[i].y;
                        const dist = Math.max(Math.sqrt(dx * dx + dy * dy), 1);
                        const force = 3000 / (dist * dist);
                        nodes[i].vx -= (dx / dist) * force;
                        nodes[i].vy -= (dy / dist) * force;
                        nodes[j].vx += (dx / dist) * force;
                        nodes[j].vy += (dy / dist) * force;
                    }
                }

                for (const [i, j] of edges) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const force = (dist - 60) * 0.1;
                    nodes[i].vx += (dx / dist) * force;
                    nodes[i].vy += (dy / dist) * force;
                    nodes[j].vx -= (dx / dist) * force;
                    nodes[j].vy -= (dy / dist) * force;
                }

                nodes.forEach(node => {
                    node.vx += (cx - node.x) * 0.01;
                    node.vy += (cy - node.y) * 0.01;
                    node.x += node.vx * 0.1;
                    node.y += node.vy * 0.1;
                    node.vx *= 0.9;
                    node.vy *= 0.9;
                });
            }
        }

        function getNeighbors(nodeId) {
            const neighbors = [];
            for (const [i, j] of edges) {
                if (i === nodeId) neighbors.push(j);
                if (j === nodeId) neighbors.push(i);
            }
            return neighbors;
        }

        function computeShortestPaths() {
            const dist = Array(n).fill(null).map(() => Array(n).fill(Infinity));
            for (let i = 0; i < n; i++) dist[i][i] = 0;
            for (const [i, j] of edges) {
                dist[i][j] = 1;
                dist[j][i] = 1;
            }
            for (let k = 0; k < n; k++) {
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        if (dist[i][k] + dist[k][j] < dist[i][j]) {
                            dist[i][j] = dist[i][k] + dist[k][j];
                        }
                    }
                }
            }
            return dist;
        }

        function computeCentrality() {
            const type = document.getElementById('centralitySelect').value;

            if (type === 'degree') {
                const maxDegree = Math.max(...nodes.map(n => n.degree));
                nodes.forEach(node => {
                    node.centrality = maxDegree > 0 ? node.degree / maxDegree : 0;
                });
            } else if (type === 'betweenness') {
                // Approximate betweenness
                const betweenness = Array(n).fill(0);
                const dist = computeShortestPaths();

                for (let s = 0; s < n; s++) {
                    for (let t = s + 1; t < n; t++) {
                        if (dist[s][t] === Infinity) continue;
                        for (let v = 0; v < n; v++) {
                            if (v === s || v === t) continue;
                            if (dist[s][v] + dist[v][t] === dist[s][t]) {
                                betweenness[v]++;
                            }
                        }
                    }
                }

                const maxBet = Math.max(...betweenness, 1);
                nodes.forEach((node, i) => {
                    node.centrality = betweenness[i] / maxBet;
                });
            } else if (type === 'closeness') {
                const dist = computeShortestPaths();
                nodes.forEach((node, i) => {
                    const totalDist = dist[i].reduce((s, d) => s + (d === Infinity ? 0 : d), 0);
                    const reachable = dist[i].filter(d => d !== Infinity && d > 0).length;
                    node.centrality = reachable > 0 ? reachable / totalDist : 0;
                });
                const maxClose = Math.max(...nodes.map(n => n.centrality));
                nodes.forEach(node => {
                    node.centrality = maxClose > 0 ? node.centrality / maxClose : 0;
                });
            } else if (type === 'pagerank') {
                const d = 0.85;
                let pr = Array(n).fill(1 / n);

                for (let iter = 0; iter < 50; iter++) {
                    const newPr = Array(n).fill((1 - d) / n);
                    for (let i = 0; i < n; i++) {
                        const neighbors = getNeighbors(i);
                        for (const j of neighbors) {
                            const jNeighbors = getNeighbors(j);
                            if (jNeighbors.length > 0) {
                                newPr[i] += d * pr[j] / jNeighbors.length;
                            }
                        }
                    }
                    pr = newPr;
                }

                const maxPr = Math.max(...pr);
                nodes.forEach((node, i) => {
                    node.centrality = maxPr > 0 ? pr[i] / maxPr : 0;
                });
            } else if (type === 'eigenvector') {
                let scores = Array(n).fill(1);

                for (let iter = 0; iter < 50; iter++) {
                    const newScores = Array(n).fill(0);
                    for (let i = 0; i < n; i++) {
                        const neighbors = getNeighbors(i);
                        for (const j of neighbors) {
                            newScores[i] += scores[j];
                        }
                    }
                    const norm = Math.sqrt(newScores.reduce((s, x) => s + x * x, 0));
                    for (let i = 0; i < n; i++) {
                        scores[i] = norm > 0 ? newScores[i] / norm : 0;
                    }
                }

                const maxScore = Math.max(...scores);
                nodes.forEach((node, i) => {
                    node.centrality = maxScore > 0 ? scores[i] / maxScore : 0;
                });
            }

            updateTopNodes();
            draw();
            drawChart();
        }

        function updateTopNodes() {
            const sorted = [...nodes].sort((a, b) => b.centrality - a.centrality);
            const top10 = sorted.slice(0, 10);
            const type = document.getElementById('centralitySelect').value;

            document.getElementById('topNodes').innerHTML = top10.map((node, i) => `
                <div class="node-item" onclick="selectNode(${node.id})" style="cursor: pointer;">
                    <span>#${i + 1} Node ${node.id}</span>
                    <span class="value-display">${node.centrality.toFixed(3)}</span>
                </div>
                <div class="node-bar" style="width: ${node.centrality * 100}%"></div>
            `).join('');
        }

        function selectNode(id) {
            selectedNode = id;
            draw();
        }

        function draw() {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw edges
            for (const [i, j] of edges) {
                const isHighlighted = selectedNode !== null && (i === selectedNode || j === selectedNode);
                ctx.strokeStyle = isHighlighted ? 'rgba(250, 204, 21, 0.8)' : 'rgba(255, 255, 255, 0.15)';
                ctx.lineWidth = isHighlighted ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(nodes[i].x, nodes[i].y);
                ctx.lineTo(nodes[j].x, nodes[j].y);
                ctx.stroke();
            }

            // Draw nodes
            for (const node of nodes) {
                const size = 5 + node.centrality * 20;
                const hue = 120 - node.centrality * 120; // Green to red based on centrality
                const isSelected = node.id === selectedNode;

                ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                ctx.fill();

                if (isSelected) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // Show node label
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px sans-serif';
                    ctx.fillText(`Node ${node.id}: ${node.centrality.toFixed(3)}`, node.x + size + 5, node.y + 4);
                }
            }

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            const type = document.getElementById('centralitySelect').value;
            ctx.fillText(`Centrality: ${type.toUpperCase()}`, 20, 30);
        }

        function drawChart() {
            cctx.fillStyle = '#0a0a15';
            cctx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);

            // Histogram of centrality values
            const bins = 20;
            const histogram = Array(bins).fill(0);
            nodes.forEach(node => {
                const bin = Math.min(Math.floor(node.centrality * bins), bins - 1);
                histogram[bin]++;
            });

            const maxCount = Math.max(...histogram, 1);
            const barWidth = chartCanvas.width / bins;

            cctx.fillStyle = '#4ade80';
            histogram.forEach((count, i) => {
                const height = (count / maxCount) * (chartCanvas.height - 20);
                cctx.fillRect(i * barWidth + 1, chartCanvas.height - height, barWidth - 2, height);
            });

            cctx.fillStyle = '#fff';
            cctx.font = '10px sans-serif';
            cctx.fillText('Centrality Distribution', 5, 12);
        }

        // Click to select node
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            for (const node of nodes) {
                const dx = node.x - x;
                const dy = node.y - y;
                const size = 5 + node.centrality * 20;
                if (Math.sqrt(dx * dx + dy * dy) < size + 5) {
                    selectedNode = node.id;
                    draw();
                    return;
                }
            }
            selectedNode = null;
            draw();
        });

        updateParam();
        generateNetwork();
    </script>
</body>
</html>
