<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Walk on Networks | Network Science</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; cursor: pointer; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(255, 200, 100, 0.3);
        }
        h1 { color: #ffc864; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        select, input[type="range"] { width: 100%; }
        select { padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #ffc864; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #ffc864; color: #0a0a1a;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #ffd88c; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #ffc864; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #ffc864; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        #visitChart { margin-top: 10px; background: rgba(0,0,0,0.3); border-radius: 8px; }
        .walk-type { display: flex; gap: 5px; margin: 10px 0; }
        .walk-btn {
            flex: 1; padding: 8px; border: none; border-radius: 5px;
            background: rgba(255,200,100,0.1); color: #ffc864;
            cursor: pointer; font-size: 0.8em;
        }
        .walk-btn.active { background: #ffc864; color: #0a0a1a; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Network Science</a>

    <div class="controls">
        <h1>Random Walk</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">Explore networks through random traversal</p>

        <div class="walk-type">
            <button class="walk-btn active" data-type="simple">Simple</button>
            <button class="walk-btn" data-type="self-avoiding">Self-Avoiding</button>
            <button class="walk-btn" data-type="biased">Degree-Biased</button>
        </div>

        <div class="control-group">
            <label>Walk Speed: <span class="value" id="speedValue">5</span></label>
            <input type="range" id="speed" min="1" max="20" value="5">
        </div>

        <div class="control-group">
            <label>Trail Length: <span class="value" id="trailValue">50</span></label>
            <input type="range" id="trailLength" min="10" max="200" value="50">
        </div>

        <button id="generateBtn">Generate Network</button>
        <button id="startBtn">Start Walk</button>
        <button id="stepBtn">Step</button>
        <button id="resetBtn">Reset Visits</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Current Node</span>
                <span class="stat-value" id="currentNode">-</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Steps Taken</span>
                <span class="stat-value" id="stepsTaken">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Nodes Visited</span>
                <span class="stat-value" id="nodesVisited">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Coverage</span>
                <span class="stat-value" id="coverage">0%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Most Visited</span>
                <span class="stat-value" id="mostVisited">-</span>
            </div>
        </div>

        <canvas id="visitChart" width="240" height="80"></canvas>

        <div class="info">
            <strong>Click a node</strong> to start walk from there.<br><br>
            <strong>Simple:</strong> Uniform random neighbor<br>
            <strong>Self-Avoiding:</strong> Avoid recently visited<br>
            <strong>Degree-Biased:</strong> Prefer high-degree nodes
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const chartCanvas = document.getElementById('visitChart');
        const chartCtx = chartCanvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let currentNode = null;
        let stepCount = 0;
        let running = false;
        let walkType = 'simple';
        let trail = [];
        let trailLength = 50;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        function generateNetwork() {
            nodes = [];
            edges = [];
            currentNode = null;
            stepCount = 0;
            trail = [];

            const n = 60;
            const m = 2;
            const cx = (canvas.width - 300) / 2;
            const cy = canvas.height / 2;

            // Generate Barabasi-Albert network
            for (let i = 0; i <= m; i++) {
                nodes.push({
                    id: i,
                    x: cx + Math.random() * 100 - 50,
                    y: cy + Math.random() * 100 - 50,
                    vx: 0, vy: 0,
                    visits: 0
                });
            }

            for (let i = 0; i <= m; i++) {
                for (let j = i + 1; j <= m; j++) {
                    edges.push({ source: i, target: j });
                }
            }

            for (let i = m + 1; i < n; i++) {
                nodes.push({
                    id: i,
                    x: cx + Math.random() * 300 - 150,
                    y: cy + Math.random() * 300 - 150,
                    vx: 0, vy: 0,
                    visits: 0
                });

                const degrees = nodes.slice(0, i).map(n => edges.filter(e => e.source === n.id || e.target === n.id).length);
                const totalDegree = degrees.reduce((a, b) => a + b, 0);
                const targets = new Set();

                while (targets.size < m) {
                    let r = Math.random() * totalDegree;
                    for (let j = 0; j < i; j++) {
                        r -= degrees[j];
                        if (r <= 0) { targets.add(j); break; }
                    }
                }

                targets.forEach(t => edges.push({ source: i, target: t }));
            }

            // Start at random node
            currentNode = Math.floor(Math.random() * nodes.length);
            nodes[currentNode].visits = 1;
            trail.push(currentNode);

            updateStats();
        }

        function getNeighbors(nodeId) {
            const neighbors = [];
            edges.forEach(e => {
                if (e.source === nodeId) neighbors.push(e.target);
                if (e.target === nodeId) neighbors.push(e.source);
            });
            return neighbors;
        }

        function getDegree(nodeId) {
            return edges.filter(e => e.source === nodeId || e.target === nodeId).length;
        }

        function step() {
            if (currentNode === null) return;

            const neighbors = getNeighbors(currentNode);
            if (neighbors.length === 0) return;

            let nextNode;

            if (walkType === 'simple') {
                nextNode = neighbors[Math.floor(Math.random() * neighbors.length)];
            } else if (walkType === 'self-avoiding') {
                // Avoid recently visited if possible
                const recent = new Set(trail.slice(-10));
                const unvisited = neighbors.filter(n => !recent.has(n));
                const pool = unvisited.length > 0 ? unvisited : neighbors;
                nextNode = pool[Math.floor(Math.random() * pool.length)];
            } else if (walkType === 'biased') {
                // Prefer higher degree nodes
                const degrees = neighbors.map(n => getDegree(n));
                const totalDegree = degrees.reduce((a, b) => a + b, 0);
                let r = Math.random() * totalDegree;
                for (let i = 0; i < neighbors.length; i++) {
                    r -= degrees[i];
                    if (r <= 0) { nextNode = neighbors[i]; break; }
                }
                if (nextNode === undefined) nextNode = neighbors[0];
            }

            currentNode = nextNode;
            nodes[currentNode].visits++;
            stepCount++;

            trail.push(currentNode);
            if (trail.length > trailLength) trail.shift();

            updateStats();
        }

        function resetVisits() {
            nodes.forEach(n => n.visits = 0);
            stepCount = 0;
            trail = [];
            if (currentNode !== null) {
                nodes[currentNode].visits = 1;
                trail.push(currentNode);
            }
            updateStats();
        }

        function applyForces() {
            const k = Math.sqrt((canvas.width * canvas.height) / nodes.length) * 0.4;

            nodes.forEach(n => { n.vx = 0; n.vy = 0; });

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = k * k / dist * 0.2;

                    nodes[i].vx -= (dx / dist) * force;
                    nodes[i].vy -= (dy / dist) * force;
                    nodes[j].vx += (dx / dist) * force;
                    nodes[j].vy += (dy / dist) * force;
                }
            }

            edges.forEach(e => {
                const source = nodes[e.source];
                const target = nodes[e.target];
                const dx = target.x - source.x;
                const dy = target.y - source.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                const force = dist / k * 0.3;

                source.vx += (dx / dist) * force;
                source.vy += (dy / dist) * force;
                target.vx -= (dx / dist) * force;
                target.vy -= (dy / dist) * force;
            });

            const cx = (canvas.width - 300) / 2;
            const cy = canvas.height / 2;
            nodes.forEach(n => {
                n.vx += (cx - n.x) * 0.005;
                n.vy += (cy - n.y) * 0.005;
                n.x += n.vx * 0.1;
                n.y += n.vy * 0.1;
                n.x = Math.max(50, Math.min(canvas.width - 350, n.x));
                n.y = Math.max(50, Math.min(canvas.height - 50, n.y));
            });
        }

        function draw() {
            ctx.fillStyle = 'rgba(10, 10, 26, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const maxVisits = Math.max(...nodes.map(n => n.visits), 1);

            // Draw edges
            edges.forEach(e => {
                const source = nodes[e.source];
                const target = nodes[e.target];
                ctx.strokeStyle = 'rgba(255, 200, 100, 0.15)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(target.x, target.y);
                ctx.stroke();
            });

            // Draw trail
            if (trail.length > 1) {
                ctx.strokeStyle = 'rgba(255, 200, 100, 0.6)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let i = 0; i < trail.length; i++) {
                    const node = nodes[trail[i]];
                    const alpha = (i / trail.length);
                    if (i === 0) {
                        ctx.moveTo(node.x, node.y);
                    } else {
                        ctx.lineTo(node.x, node.y);
                    }
                }
                ctx.stroke();

                // Trail dots
                trail.forEach((id, i) => {
                    const node = nodes[id];
                    const alpha = 0.3 + (i / trail.length) * 0.7;
                    const size = 2 + (i / trail.length) * 3;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 200, 100, ${alpha})`;
                    ctx.fill();
                });
            }

            // Draw nodes
            nodes.forEach(node => {
                const visitRatio = node.visits / maxVisits;
                const size = 5 + visitRatio * 10;

                // Color based on visits
                const r = 100 + visitRatio * 155;
                const g = 100 + visitRatio * 100;
                const b = 150 - visitRatio * 100;

                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fill();

                // Current node indicator
                if (node.id === currentNode) {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, size + 8, 0, Math.PI * 2);
                    ctx.strokeStyle = '#ffc864';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // Pulse effect
                    const pulse = Math.sin(Date.now() / 200) * 5 + 15;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, size + pulse, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255, 200, 100, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
        }

        function drawVisitChart() {
            const w = chartCanvas.width;
            const h = chartCanvas.height;
            chartCtx.fillStyle = 'rgba(0,0,0,0.5)';
            chartCtx.fillRect(0, 0, w, h);

            const sorted = [...nodes].sort((a, b) => b.visits - a.visits);
            const maxVisits = sorted[0]?.visits || 1;
            const barWidth = w / Math.min(sorted.length, 30);

            sorted.slice(0, 30).forEach((node, i) => {
                const barH = (node.visits / maxVisits) * (h - 20);
                const x = i * barWidth;

                chartCtx.fillStyle = node.id === currentNode ? '#ffc864' : '#8a6030';
                chartCtx.fillRect(x + 1, h - barH - 10, barWidth - 2, barH);
            });

            chartCtx.fillStyle = '#666';
            chartCtx.font = '10px sans-serif';
            chartCtx.fillText('Visit Distribution (top 30)', 5, 12);
        }

        function updateStats() {
            const visited = nodes.filter(n => n.visits > 0).length;
            const maxVisits = Math.max(...nodes.map(n => n.visits));
            const mostVisitedNode = nodes.find(n => n.visits === maxVisits);

            document.getElementById('currentNode').textContent = currentNode !== null ? currentNode : '-';
            document.getElementById('stepsTaken').textContent = stepCount;
            document.getElementById('nodesVisited').textContent = visited;
            document.getElementById('coverage').textContent = (visited / nodes.length * 100).toFixed(1) + '%';
            document.getElementById('mostVisited').textContent = mostVisitedNode ?
                `${mostVisitedNode.id} (${maxVisits})` : '-';

            drawVisitChart();
        }

        let lastStepTime = 0;
        function animate(time) {
            applyForces();
            draw();

            if (running) {
                const speed = parseInt(document.getElementById('speed').value);
                const interval = 1000 / speed;

                if (time - lastStepTime > interval) {
                    step();
                    lastStepTime = time;
                }
            }

            requestAnimationFrame(animate);
        }

        // Event listeners
        document.querySelectorAll('.walk-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.walk-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                walkType = btn.dataset.type;
            };
        });

        document.getElementById('speed').oninput = (e) => {
            document.getElementById('speedValue').textContent = e.target.value;
        };

        document.getElementById('trailLength').oninput = (e) => {
            trailLength = parseInt(e.target.value);
            document.getElementById('trailValue').textContent = trailLength;
        };

        document.getElementById('generateBtn').onclick = generateNetwork;
        document.getElementById('stepBtn').onclick = step;
        document.getElementById('resetBtn').onclick = resetVisits;

        document.getElementById('startBtn').onclick = () => {
            running = !running;
            document.getElementById('startBtn').textContent = running ? 'Pause' : 'Start Walk';
        };

        canvas.onclick = (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            for (const node of nodes) {
                const dx = node.x - x;
                const dy = node.y - y;
                if (dx * dx + dy * dy < 200) {
                    currentNode = node.id;
                    node.visits++;
                    trail = [currentNode];
                    updateStats();
                    break;
                }
            }
        };

        // Initialize
        generateNetwork();
        animate(0);
    </script>
</body>
</html>
