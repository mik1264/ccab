<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scale-Free Networks - Network Science</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #eee; min-height: 100vh; padding: 20px; }
        .back-link { position: fixed; top: 20px; left: 20px; color: #4ade80; text-decoration: none; font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px; z-index: 100; }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #4ade80; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 320px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(74, 222, 128, 0.1); border: 1px solid rgba(74, 222, 128, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #4ade80; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #0a0a15; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input { width: 100%; }
        .value-display { color: #4ade80; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #4ade80; color: #1a1a2e; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .metrics-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0; }
        .metric-box { background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; text-align: center; }
        .metric-value { font-size: 1.3em; color: #4ade80; }
        .metric-label { font-size: 0.75em; opacity: 0.7; }
        .hub-list { max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px; }
        .hub-item { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <h1>Scale-Free Networks</h1>
    <p class="subtitle">Barabási-Albert preferential attachment</p>

    <div class="container">
        <div class="panel">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>

        <div class="panel">
            <div class="info-box">
                <strong>Scale-Free Networks (Barabási & Albert, 1999):</strong>
                New nodes attach preferentially to high-degree nodes ("rich get richer").
                Results in power-law degree distribution P(k) ~ k^(-γ).
                Few "hub" nodes with many connections, many nodes with few.
                Examples: WWW, social networks, protein interactions.
            </div>

            <h3>Parameters</h3>

            <div class="control-group">
                <label>Total Nodes: <span class="value-display" id="nVal">50</span></label>
                <input type="range" id="nSlider" min="20" max="150" value="50" oninput="updateParam()">
            </div>

            <div class="control-group">
                <label>Edges per new node (m): <span class="value-display" id="mVal">2</span></label>
                <input type="range" id="mSlider" min="1" max="5" value="2" oninput="updateParam()">
            </div>

            <button class="btn-primary" onclick="generateNetwork()">Generate Network</button>
            <button class="btn-secondary" onclick="animateGrowth()">Animate Growth</button>

            <h3 style="margin-top: 20px;">Network Metrics</h3>
            <div class="metrics-grid">
                <div class="metric-box">
                    <div class="metric-value" id="nodes">0</div>
                    <div class="metric-label">Nodes</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value" id="edges">0</div>
                    <div class="metric-label">Edges</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value" id="maxDegree">0</div>
                    <div class="metric-label">Max Degree (Hub)</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value" id="avgDegree">0</div>
                    <div class="metric-label">Avg Degree</div>
                </div>
            </div>

            <h3>Top Hubs</h3>
            <div class="hub-list" id="hubList"></div>

            <h3 style="margin-top: 15px;">Degree Distribution</h3>
            <canvas id="distCanvas" width="300" height="120"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const distCanvas = document.getElementById('distCanvas');
        const dctx = distCanvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let n = 50, m = 2;
        let animating = false;

        function updateParam() {
            n = parseInt(document.getElementById('nSlider').value);
            m = parseInt(document.getElementById('mSlider').value);
            document.getElementById('nVal').textContent = n;
            document.getElementById('mVal').textContent = m;
        }

        function generateNetwork() {
            animating = false;
            nodes = [];
            edges = [];

            // Start with m+1 fully connected nodes
            for (let i = 0; i <= m; i++) {
                nodes.push({ id: i, degree: m, x: 0, y: 0 });
                for (let j = 0; j < i; j++) {
                    edges.push([i, j]);
                }
            }

            // Add remaining nodes with preferential attachment
            for (let i = m + 1; i < n; i++) {
                nodes.push({ id: i, degree: 0, x: 0, y: 0 });
                const targets = selectTargets(m);
                for (const t of targets) {
                    edges.push([i, t]);
                    nodes[i].degree++;
                    nodes[t].degree++;
                }
            }

            layoutNetwork();
            updateMetrics();
            draw();
        }

        function selectTargets(count) {
            const targets = new Set();
            const totalDegree = nodes.slice(0, -1).reduce((s, n) => s + n.degree, 0);

            while (targets.size < count) {
                let r = Math.random() * totalDegree;
                for (let i = 0; i < nodes.length - 1; i++) {
                    r -= nodes[i].degree;
                    if (r <= 0) {
                        targets.add(i);
                        break;
                    }
                }
            }
            return [...targets];
        }

        function layoutNetwork() {
            // Force-directed layout
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            // Initialize positions
            nodes.forEach((node, i) => {
                const angle = (2 * Math.PI * i) / nodes.length;
                const r = 150 + Math.random() * 100;
                node.x = cx + r * Math.cos(angle);
                node.y = cy + r * Math.sin(angle);
                node.vx = 0;
                node.vy = 0;
            });

            // Simulate forces
            for (let iter = 0; iter < 100; iter++) {
                // Repulsion between all nodes
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const dx = nodes[j].x - nodes[i].x;
                        const dy = nodes[j].y - nodes[i].y;
                        const dist = Math.max(Math.sqrt(dx * dx + dy * dy), 1);
                        const force = 5000 / (dist * dist);
                        const fx = (dx / dist) * force;
                        const fy = (dy / dist) * force;
                        nodes[i].vx -= fx;
                        nodes[i].vy -= fy;
                        nodes[j].vx += fx;
                        nodes[j].vy += fy;
                    }
                }

                // Attraction along edges
                for (const [i, j] of edges) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const force = (dist - 80) * 0.1;
                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;
                    nodes[i].vx += fx;
                    nodes[i].vy += fy;
                    nodes[j].vx -= fx;
                    nodes[j].vy -= fy;
                }

                // Center gravity
                nodes.forEach(node => {
                    node.vx += (cx - node.x) * 0.01;
                    node.vy += (cy - node.y) * 0.01;
                });

                // Apply velocities with damping
                nodes.forEach(node => {
                    node.x += node.vx * 0.1;
                    node.y += node.vy * 0.1;
                    node.vx *= 0.9;
                    node.vy *= 0.9;
                });
            }
        }

        function updateMetrics() {
            document.getElementById('nodes').textContent = nodes.length;
            document.getElementById('edges').textContent = edges.length;

            const maxDeg = Math.max(...nodes.map(n => n.degree));
            const avgDeg = nodes.reduce((s, n) => s + n.degree, 0) / nodes.length;

            document.getElementById('maxDegree').textContent = maxDeg;
            document.getElementById('avgDegree').textContent = avgDeg.toFixed(1);

            // Top hubs
            const sorted = [...nodes].sort((a, b) => b.degree - a.degree).slice(0, 5);
            document.getElementById('hubList').innerHTML = sorted.map((n, i) =>
                `<div class="hub-item"><span>#${i + 1} Node ${n.id}</span><span>${n.degree} connections</span></div>`
            ).join('');

            drawDistribution();
        }

        function draw() {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const maxDegree = Math.max(...nodes.map(n => n.degree));

            // Draw edges
            ctx.strokeStyle = 'rgba(74, 222, 128, 0.2)';
            ctx.lineWidth = 1;
            for (const [i, j] of edges) {
                ctx.beginPath();
                ctx.moveTo(nodes[i].x, nodes[i].y);
                ctx.lineTo(nodes[j].x, nodes[j].y);
                ctx.stroke();
            }

            // Draw nodes (size by degree)
            for (const node of nodes) {
                const size = 4 + (node.degree / maxDegree) * 20;
                const hue = 120 + (node.degree / maxDegree) * 60;

                ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Title
            ctx.fillStyle = '#4ade80';
            ctx.font = 'bold 16px sans-serif';
            ctx.fillText(`Barabási-Albert Network (n=${nodes.length}, m=${m})`, 20, 30);
        }

        function drawDistribution() {
            dctx.fillStyle = '#0a0a15';
            dctx.fillRect(0, 0, distCanvas.width, distCanvas.height);

            // Calculate degree histogram
            const degreeCounts = {};
            nodes.forEach(n => {
                degreeCounts[n.degree] = (degreeCounts[n.degree] || 0) + 1;
            });

            const degrees = Object.keys(degreeCounts).map(Number).sort((a, b) => a - b);
            const maxCount = Math.max(...Object.values(degreeCounts));

            const barWidth = (distCanvas.width - 40) / degrees.length;

            degrees.forEach((deg, i) => {
                const count = degreeCounts[deg];
                const height = (count / maxCount) * (distCanvas.height - 30);
                const x = 30 + i * barWidth;

                dctx.fillStyle = '#4ade80';
                dctx.fillRect(x, distCanvas.height - 20 - height, barWidth - 2, height);

                if (degrees.length < 20) {
                    dctx.fillStyle = '#fff';
                    dctx.font = '9px sans-serif';
                    dctx.textAlign = 'center';
                    dctx.fillText(deg, x + barWidth / 2, distCanvas.height - 5);
                }
            });

            dctx.fillStyle = '#fff';
            dctx.font = '10px sans-serif';
            dctx.fillText('Degree Distribution (Power Law)', 10, 12);
        }

        async function animateGrowth() {
            if (animating) {
                animating = false;
                return;
            }
            animating = true;

            nodes = [];
            edges = [];

            // Start with initial clique
            for (let i = 0; i <= m; i++) {
                nodes.push({ id: i, degree: m, x: canvas.width / 2 + Math.random() * 100 - 50, y: canvas.height / 2 + Math.random() * 100 - 50, vx: 0, vy: 0 });
                for (let j = 0; j < i; j++) {
                    edges.push([i, j]);
                }
            }

            updateMetrics();
            draw();

            // Add nodes one by one
            for (let i = m + 1; i < n && animating; i++) {
                nodes.push({
                    id: i,
                    degree: 0,
                    x: canvas.width / 2 + Math.random() * 200 - 100,
                    y: canvas.height / 2 + Math.random() * 200 - 100,
                    vx: 0, vy: 0
                });

                const targets = selectTargets(m);
                for (const t of targets) {
                    edges.push([i, t]);
                    nodes[i].degree++;
                    nodes[t].degree++;
                }

                // Quick layout iteration
                for (let iter = 0; iter < 20; iter++) {
                    simulateForces();
                }

                updateMetrics();
                draw();
                await new Promise(r => setTimeout(r, 100));
            }

            animating = false;
        }

        function simulateForces() {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.max(Math.sqrt(dx * dx + dy * dy), 1);
                    const force = 3000 / (dist * dist);
                    nodes[i].vx -= (dx / dist) * force;
                    nodes[i].vy -= (dy / dist) * force;
                    nodes[j].vx += (dx / dist) * force;
                    nodes[j].vy += (dy / dist) * force;
                }
            }

            for (const [i, j] of edges) {
                const dx = nodes[j].x - nodes[i].x;
                const dy = nodes[j].y - nodes[i].y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0) {
                    const force = (dist - 60) * 0.05;
                    nodes[i].vx += (dx / dist) * force;
                    nodes[i].vy += (dy / dist) * force;
                    nodes[j].vx -= (dx / dist) * force;
                    nodes[j].vy -= (dy / dist) * force;
                }
            }

            nodes.forEach(node => {
                node.vx += (cx - node.x) * 0.005;
                node.vy += (cy - node.y) * 0.005;
                node.x += node.vx * 0.2;
                node.y += node.vy * 0.2;
                node.vx *= 0.8;
                node.vy *= 0.8;
            });
        }

        updateParam();
        generateNetwork();
    </script>
</body>
</html>
