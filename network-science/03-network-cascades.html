<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Cascades - Network Science</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #eee; min-height: 100vh; padding: 20px; }
        .back-link { position: fixed; top: 20px; left: 20px; color: #4ade80; text-decoration: none; font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px; z-index: 100; }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #4ade80; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(74, 222, 128, 0.1); border: 1px solid rgba(74, 222, 128, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #4ade80; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #0a0a15; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input { width: 100%; }
        .value-display { color: #4ade80; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #4ade80; color: #1a1a2e; }
        .btn-danger { background: #f87171; color: #fff; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .status-bar { display: flex; height: 30px; border-radius: 8px; overflow: hidden; margin: 15px 0; }
        .status-segment { display: flex; align-items: center; justify-content: center; font-size: 0.85em; font-weight: 600; transition: width 0.3s; }
        .cascade-log { max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px; font-family: monospace; font-size: 0.8em; }
        .cascade-log div { padding: 2px 0; }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back</a>
    <h1>Network Cascades</h1>
    <p class="subtitle">Failure cascades in interdependent networks</p>

    <div class="container">
        <div class="panel">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>

        <div class="panel">
            <div class="info-box">
                <strong>Cascading Failures:</strong>
                When a node fails, its neighbors may become overloaded.
                If load exceeds capacity, they fail too, potentially triggering a cascade.
                Models power grid failures, financial contagion, and system collapses.
            </div>

            <h3>Network Status</h3>
            <div class="status-bar">
                <div class="status-segment" id="activeBar" style="width: 100%; background: #4ade80;">Active: 100%</div>
                <div class="status-segment" id="failedBar" style="width: 0%; background: #f87171;">Failed: 0%</div>
            </div>

            <h3>Controls</h3>
            <div class="control-group">
                <label>Network Size: <span class="value-display" id="sizeVal">40</span></label>
                <input type="range" id="sizeSlider" min="20" max="80" value="40" oninput="updateParam()">
            </div>

            <div class="control-group">
                <label>Node Capacity: <span class="value-display" id="capacityVal">1.2</span>x</label>
                <input type="range" id="capacitySlider" min="100" max="200" value="120" oninput="updateParam()">
            </div>

            <div class="control-group">
                <label>Load Redistribution: <span class="value-display" id="redistVal">100%</span></label>
                <input type="range" id="redistSlider" min="0" max="100" value="100" oninput="updateParam()">
            </div>

            <button class="btn-primary" onclick="generateNetwork()">Generate Network</button>
            <button class="btn-danger" onclick="triggerFailure()">Trigger Random Failure</button>
            <button class="btn-secondary" onclick="targetHub()">Target Hub</button>
            <button class="btn-secondary" onclick="runCascade()">Auto-Cascade</button>

            <h3 style="margin-top: 15px;">Cascade Log</h3>
            <div class="cascade-log" id="cascadeLog">Click a node or use buttons to trigger failures...</div>

            <canvas id="chartCanvas" width="280" height="120" style="margin-top: 15px;"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const chartCanvas = document.getElementById('chartCanvas');
        const cctx = chartCanvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let n = 40;
        let capacityMultiplier = 1.2;
        let redistribution = 1.0;
        let cascadeHistory = [];
        let running = false;

        function updateParam() {
            n = parseInt(document.getElementById('sizeSlider').value);
            capacityMultiplier = parseInt(document.getElementById('capacitySlider').value) / 100;
            redistribution = parseInt(document.getElementById('redistSlider').value) / 100;
            document.getElementById('sizeVal').textContent = n;
            document.getElementById('capacityVal').textContent = capacityMultiplier.toFixed(1);
            document.getElementById('redistVal').textContent = Math.round(redistribution * 100) + '%';
        }

        function generateNetwork() {
            running = false;
            nodes = [];
            edges = [];
            cascadeHistory = [];

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            // Create scale-free network
            for (let i = 0; i < n; i++) {
                const angle = (2 * Math.PI * i) / n + Math.random() * 0.3;
                const r = 150 + Math.random() * 100;
                nodes.push({
                    id: i,
                    x: cx + r * Math.cos(angle),
                    y: cy + r * Math.sin(angle),
                    degree: 0,
                    load: 0,
                    capacity: 0,
                    failed: false,
                    vx: 0, vy: 0
                });
            }

            // Preferential attachment
            for (let i = 0; i < Math.min(3, n); i++) {
                for (let j = 0; j < i; j++) {
                    addEdge(i, j);
                }
            }

            for (let i = 3; i < n; i++) {
                const totalDegree = nodes.slice(0, i).reduce((s, n) => s + Math.max(n.degree, 1), 0);
                let added = 0;
                while (added < 2) {
                    let r = Math.random() * totalDegree;
                    for (let j = 0; j < i; j++) {
                        r -= Math.max(nodes[j].degree, 1);
                        if (r <= 0) {
                            if (!hasEdge(i, j)) {
                                addEdge(i, j);
                                added++;
                            }
                            break;
                        }
                    }
                }
            }

            // Set initial load and capacity
            nodes.forEach(node => {
                node.load = node.degree;
                node.capacity = node.degree * capacityMultiplier;
            });

            layoutNetwork();
            updateDisplay();
            draw();
            log('Network generated with ' + n + ' nodes');
        }

        function addEdge(i, j) {
            edges.push([i, j]);
            nodes[i].degree++;
            nodes[j].degree++;
        }

        function hasEdge(i, j) {
            return edges.some(e => (e[0] === i && e[1] === j) || (e[0] === j && e[1] === i));
        }

        function layoutNetwork() {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            for (let iter = 0; iter < 50; iter++) {
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const dx = nodes[j].x - nodes[i].x;
                        const dy = nodes[j].y - nodes[i].y;
                        const dist = Math.max(Math.sqrt(dx * dx + dy * dy), 1);
                        const force = 3000 / (dist * dist);
                        nodes[i].vx -= (dx / dist) * force;
                        nodes[i].vy -= (dy / dist) * force;
                        nodes[j].vx += (dx / dist) * force;
                        nodes[j].vy += (dy / dist) * force;
                    }
                }

                for (const [i, j] of edges) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const force = (dist - 80) * 0.1;
                    nodes[i].vx += (dx / dist) * force;
                    nodes[i].vy += (dy / dist) * force;
                    nodes[j].vx -= (dx / dist) * force;
                    nodes[j].vy -= (dy / dist) * force;
                }

                nodes.forEach(node => {
                    node.vx += (cx - node.x) * 0.01;
                    node.vy += (cy - node.y) * 0.01;
                    node.x += node.vx * 0.1;
                    node.y += node.vy * 0.1;
                    node.vx *= 0.9;
                    node.vy *= 0.9;
                });
            }
        }

        function failNode(nodeId) {
            if (nodes[nodeId].failed) return [];

            nodes[nodeId].failed = true;
            const failedLoad = nodes[nodeId].load;
            log(`Node ${nodeId} failed (load: ${failedLoad.toFixed(1)})`);

            // Redistribute load to neighbors
            const neighbors = edges.filter(e => e[0] === nodeId || e[1] === nodeId)
                .map(e => e[0] === nodeId ? e[1] : e[0])
                .filter(id => !nodes[id].failed);

            const newFailures = [];

            if (neighbors.length > 0) {
                const loadPerNeighbor = (failedLoad * redistribution) / neighbors.length;
                for (const nid of neighbors) {
                    nodes[nid].load += loadPerNeighbor;
                    if (nodes[nid].load > nodes[nid].capacity) {
                        newFailures.push(nid);
                    }
                }
            }

            return newFailures;
        }

        async function triggerFailure() {
            const active = nodes.filter(n => !n.failed);
            if (active.length === 0) return;

            const target = active[Math.floor(Math.random() * active.length)];
            await propagateCascade([target.id]);
        }

        async function targetHub() {
            const active = nodes.filter(n => !n.failed).sort((a, b) => b.degree - a.degree);
            if (active.length === 0) return;

            log('Targeting hub node ' + active[0].id + ' (degree: ' + active[0].degree + ')');
            await propagateCascade([active[0].id]);
        }

        async function propagateCascade(initialFailures) {
            let toFail = [...initialFailures];

            while (toFail.length > 0) {
                const nextFail = [];
                for (const id of toFail) {
                    const newFailures = failNode(id);
                    nextFail.push(...newFailures);
                }
                toFail = [...new Set(nextFail)];

                cascadeHistory.push(nodes.filter(n => n.failed).length);
                updateDisplay();
                draw();
                drawChart();

                if (toFail.length > 0) {
                    await new Promise(r => setTimeout(r, 300));
                }
            }
        }

        async function runCascade() {
            if (running) {
                running = false;
                return;
            }
            running = true;

            while (running && nodes.some(n => !n.failed)) {
                await triggerFailure();
                await new Promise(r => setTimeout(r, 500));
            }

            running = false;
        }

        function updateDisplay() {
            const active = nodes.filter(n => !n.failed).length;
            const failed = nodes.filter(n => n.failed).length;
            const total = nodes.length;

            document.getElementById('activeBar').style.width = (active / total * 100) + '%';
            document.getElementById('activeBar').textContent = `Active: ${Math.round(active / total * 100)}%`;
            document.getElementById('failedBar').style.width = (failed / total * 100) + '%';
            document.getElementById('failedBar').textContent = failed > 0 ? `Failed: ${Math.round(failed / total * 100)}%` : '';
        }

        function log(msg) {
            const logDiv = document.getElementById('cascadeLog');
            logDiv.innerHTML = `<div>${msg}</div>` + logDiv.innerHTML;
            if (logDiv.children.length > 20) {
                logDiv.removeChild(logDiv.lastChild);
            }
        }

        function draw() {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw edges
            for (const [i, j] of edges) {
                const ni = nodes[i], nj = nodes[j];
                ctx.strokeStyle = (ni.failed || nj.failed) ? 'rgba(248, 113, 113, 0.3)' : 'rgba(74, 222, 128, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(ni.x, ni.y);
                ctx.lineTo(nj.x, nj.y);
                ctx.stroke();
            }

            // Draw nodes
            for (const node of nodes) {
                const size = 6 + node.degree * 1.5;
                const loadRatio = node.load / node.capacity;

                if (node.failed) {
                    ctx.fillStyle = '#f87171';
                } else if (loadRatio > 0.9) {
                    ctx.fillStyle = '#facc15';
                } else {
                    ctx.fillStyle = '#4ade80';
                }

                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                ctx.fill();

                // Load indicator
                if (!node.failed) {
                    ctx.strokeStyle = loadRatio > 0.9 ? '#facc15' : '#4ade80';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, size + 3, -Math.PI / 2, -Math.PI / 2 + (2 * Math.PI * loadRatio));
                    ctx.stroke();
                }
            }
        }

        function drawChart() {
            cctx.fillStyle = '#0a0a15';
            cctx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);

            if (cascadeHistory.length < 2) return;

            cctx.strokeStyle = '#f87171';
            cctx.lineWidth = 2;
            cctx.beginPath();
            cascadeHistory.forEach((count, i) => {
                const x = (i / (cascadeHistory.length - 1)) * chartCanvas.width;
                const y = chartCanvas.height - (count / nodes.length) * chartCanvas.height;
                if (i === 0) cctx.moveTo(x, y);
                else cctx.lineTo(x, y);
            });
            cctx.stroke();

            cctx.fillStyle = '#fff';
            cctx.font = '10px sans-serif';
            cctx.fillText('Cascade Size Over Time', 5, 12);
        }

        // Click to fail node
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            for (const node of nodes) {
                const dx = node.x - x;
                const dy = node.y - y;
                if (Math.sqrt(dx * dx + dy * dy) < 15) {
                    propagateCascade([node.id]);
                    break;
                }
            }
        });

        updateParam();
        generateNetwork();
    </script>
</body>
</html>
