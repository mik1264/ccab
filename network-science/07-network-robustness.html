<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Robustness | Network Science</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        #canvas { display: block; }
        .controls {
            position: fixed;
            top: 20px; right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 20px; border-radius: 15px;
            min-width: 280px;
            border: 1px solid rgba(255, 100, 100, 0.3);
        }
        h1 { color: #ff6464; font-size: 1.3em; margin-bottom: 15px; }
        .control-group { margin: 15px 0; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.9em; }
        select { width: 100%; padding: 8px; border-radius: 5px; background: #333; color: #fff; border: none; }
        .value { float: right; color: #ff6464; }
        button {
            width: 100%; padding: 10px; margin: 5px 0;
            border: none; border-radius: 8px;
            background: #ff6464; color: #fff;
            font-weight: bold; cursor: pointer;
        }
        button:hover { background: #ff8888; }
        .stats { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 0.9em; }
        .stat-label { color: #888; }
        .stat-value { color: #ff6464; font-weight: bold; }
        .info { font-size: 0.8em; color: #666; margin-top: 15px; line-height: 1.5; }
        a.back-link {
            position: fixed; top: 20px; left: 20px;
            color: #ff6464; text-decoration: none;
            background: rgba(0,0,0,0.8); padding: 10px 20px;
            border-radius: 25px; font-size: 0.9em;
        }
        #chart { margin-top: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; }
        .attack-type { display: flex; gap: 10px; margin: 10px 0; }
        .attack-btn {
            flex: 1; padding: 8px; border: none; border-radius: 5px;
            background: rgba(255,100,100,0.2); color: #ff6464;
            cursor: pointer; font-size: 0.85em;
        }
        .attack-btn.active { background: #ff6464; color: #fff; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="index.html" class="back-link">‚Üê Back to Network Science</a>

    <div class="controls">
        <h1>Network Robustness</h1>
        <p style="font-size:0.85em; color:#888; margin-bottom:15px;">How networks respond to random failures vs targeted attacks</p>

        <div class="control-group">
            <label>Network Type</label>
            <select id="networkType">
                <option value="barabasi">Scale-Free (Vulnerable to attacks)</option>
                <option value="random">Random (Robust to attacks)</option>
            </select>
        </div>

        <div class="attack-type">
            <button class="attack-btn active" data-attack="random">Random Failure</button>
            <button class="attack-btn" data-attack="targeted">Targeted Attack</button>
        </div>

        <button id="generateBtn">Generate Network</button>
        <button id="removeBtn">Remove Node</button>
        <button id="attackBtn">Run Full Attack</button>
        <button id="resetBtn">Reset</button>

        <div class="stats">
            <div class="stat-row">
                <span class="stat-label">Original Nodes</span>
                <span class="stat-value" id="originalNodes">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Remaining Nodes</span>
                <span class="stat-value" id="remainingNodes">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Removed</span>
                <span class="stat-value" id="removedCount">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Giant Component</span>
                <span class="stat-value" id="giantSize">0%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Components</span>
                <span class="stat-value" id="componentCount">0</span>
            </div>
        </div>

        <canvas id="chart" width="240" height="120"></canvas>

        <div class="info">
            <strong>Scale-free networks:</strong> Robust to random failures (most nodes have few connections), but vulnerable to targeted hub removal.<br><br>
            <strong>Random networks:</strong> More evenly affected by both attack types.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const chartCanvas = document.getElementById('chart');
        const chartCtx = chartCanvas.getContext('2d');

        let originalNodes = [];
        let originalEdges = [];
        let nodes = [];
        let edges = [];
        let removed = [];
        let attackType = 'random';
        let history = [];

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.onresize = resize;

        function generateBarabasi(n = 100, m = 2) {
            nodes = [];
            edges = [];
            removed = [];
            history = [];

            const cx = (canvas.width - 300) / 2;
            const cy = canvas.height / 2;

            for (let i = 0; i <= m; i++) {
                nodes.push({ id: i, x: cx + Math.random() * 200 - 100, y: cy + Math.random() * 200 - 100, vx: 0, vy: 0, alive: true });
            }

            for (let i = 0; i <= m; i++) {
                for (let j = i + 1; j <= m; j++) {
                    edges.push({ source: i, target: j });
                }
            }

            for (let i = m + 1; i < n; i++) {
                nodes.push({ id: i, x: cx + Math.random() * 400 - 200, y: cy + Math.random() * 400 - 200, vx: 0, vy: 0, alive: true });

                const degrees = nodes.slice(0, i).map(n => edges.filter(e => e.source === n.id || e.target === n.id).length);
                const totalDegree = degrees.reduce((a, b) => a + b, 0);
                const targets = new Set();

                while (targets.size < m) {
                    let r = Math.random() * totalDegree;
                    for (let j = 0; j < i; j++) {
                        r -= degrees[j];
                        if (r <= 0) { targets.add(j); break; }
                    }
                }

                targets.forEach(t => edges.push({ source: i, target: t }));
            }

            originalNodes = JSON.parse(JSON.stringify(nodes));
            originalEdges = JSON.parse(JSON.stringify(edges));
            recordHistory();
        }

        function generateRandom(n = 100, p = 0.04) {
            nodes = [];
            edges = [];
            removed = [];
            history = [];

            const cx = (canvas.width - 300) / 2;
            const cy = canvas.height / 2;

            for (let i = 0; i < n; i++) {
                const angle = (i / n) * Math.PI * 2;
                nodes.push({ id: i, x: cx + Math.cos(angle) * 200, y: cy + Math.sin(angle) * 200, vx: 0, vy: 0, alive: true });
            }

            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    if (Math.random() < p) edges.push({ source: i, target: j });
                }
            }

            originalNodes = JSON.parse(JSON.stringify(nodes));
            originalEdges = JSON.parse(JSON.stringify(edges));
            recordHistory();
        }

        function getDegree(nodeId) {
            return edges.filter(e =>
                (e.source === nodeId || e.target === nodeId) &&
                nodes.find(n => n.id === e.source)?.alive &&
                nodes.find(n => n.id === e.target)?.alive
            ).length;
        }

        function findComponents() {
            const aliveNodes = nodes.filter(n => n.alive);
            if (aliveNodes.length === 0) return [];

            const parent = {};
            aliveNodes.forEach(n => parent[n.id] = n.id);

            function find(x) {
                if (parent[x] !== x) parent[x] = find(parent[x]);
                return parent[x];
            }

            function union(x, y) {
                const px = find(x), py = find(y);
                if (px !== py) parent[px] = py;
            }

            edges.forEach(e => {
                const sourceAlive = nodes.find(n => n.id === e.source)?.alive;
                const targetAlive = nodes.find(n => n.id === e.target)?.alive;
                if (sourceAlive && targetAlive) {
                    union(e.source, e.target);
                }
            });

            const components = {};
            aliveNodes.forEach(n => {
                const root = find(n.id);
                if (!components[root]) components[root] = [];
                components[root].push(n.id);
            });

            return Object.values(components).sort((a, b) => b.length - a.length);
        }

        function removeNode() {
            const aliveNodes = nodes.filter(n => n.alive);
            if (aliveNodes.length === 0) return;

            let targetNode;

            if (attackType === 'random') {
                targetNode = aliveNodes[Math.floor(Math.random() * aliveNodes.length)];
            } else {
                // Targeted: remove highest degree node
                let maxDeg = -1;
                aliveNodes.forEach(n => {
                    const deg = getDegree(n.id);
                    if (deg > maxDeg) {
                        maxDeg = deg;
                        targetNode = n;
                    }
                });
            }

            if (targetNode) {
                targetNode.alive = false;
                removed.push(targetNode.id);
                recordHistory();
            }

            updateStats();
        }

        function recordHistory() {
            const aliveNodes = nodes.filter(n => n.alive);
            const components = findComponents();
            const giantSize = components.length > 0 ? components[0].length : 0;
            const fraction = originalNodes.length > 0 ? giantSize / originalNodes.length : 0;

            history.push({
                removed: removed.length,
                giantFraction: fraction,
                components: components.length
            });
        }

        function runFullAttack() {
            const interval = setInterval(() => {
                const aliveNodes = nodes.filter(n => n.alive);
                if (aliveNodes.length <= 1) {
                    clearInterval(interval);
                    return;
                }
                removeNode();
            }, 50);
        }

        function reset() {
            nodes = JSON.parse(JSON.stringify(originalNodes));
            edges = JSON.parse(JSON.stringify(originalEdges));
            removed = [];
            history = [];
            recordHistory();
            updateStats();
        }

        function applyForces() {
            const aliveNodes = nodes.filter(n => n.alive);
            const k = Math.sqrt((canvas.width * canvas.height) / aliveNodes.length) * 0.3;

            aliveNodes.forEach(n => { n.vx = 0; n.vy = 0; });

            for (let i = 0; i < aliveNodes.length; i++) {
                for (let j = i + 1; j < aliveNodes.length; j++) {
                    const dx = aliveNodes[j].x - aliveNodes[i].x;
                    const dy = aliveNodes[j].y - aliveNodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = k * k / dist * 0.2;

                    aliveNodes[i].vx -= (dx / dist) * force;
                    aliveNodes[i].vy -= (dy / dist) * force;
                    aliveNodes[j].vx += (dx / dist) * force;
                    aliveNodes[j].vy += (dy / dist) * force;
                }
            }

            edges.forEach(e => {
                const source = nodes.find(n => n.id === e.source);
                const target = nodes.find(n => n.id === e.target);
                if (!source?.alive || !target?.alive) return;

                const dx = target.x - source.x;
                const dy = target.y - source.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                const force = dist / k * 0.2;

                source.vx += (dx / dist) * force;
                source.vy += (dy / dist) * force;
                target.vx -= (dx / dist) * force;
                target.vy -= (dy / dist) * force;
            });

            const cx = (canvas.width - 300) / 2;
            const cy = canvas.height / 2;
            aliveNodes.forEach(n => {
                n.vx += (cx - n.x) * 0.005;
                n.vy += (cy - n.y) * 0.005;
                n.x += n.vx * 0.1;
                n.y += n.vy * 0.1;
                n.x = Math.max(50, Math.min(canvas.width - 350, n.x));
                n.y = Math.max(50, Math.min(canvas.height - 50, n.y));
            });
        }

        function draw() {
            ctx.fillStyle = 'rgba(10, 10, 26, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const components = findComponents();
            const nodeToComp = {};
            components.forEach((comp, i) => {
                comp.forEach(id => nodeToComp[id] = i);
            });

            // Draw edges
            edges.forEach(e => {
                const source = nodes.find(n => n.id === e.source);
                const target = nodes.find(n => n.id === e.target);
                if (!source?.alive || !target?.alive) return;

                const isGiant = nodeToComp[e.source] === 0 && nodeToComp[e.target] === 0 && components[0]?.length > 1;
                ctx.strokeStyle = isGiant ? 'rgba(255,100,100,0.3)' : 'rgba(100,100,150,0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(target.x, target.y);
                ctx.stroke();
            });

            // Draw nodes
            nodes.forEach(node => {
                if (!node.alive) return;

                const isGiant = nodeToComp[node.id] === 0 && components[0]?.length > 1;
                const deg = getDegree(node.id);
                const size = 3 + Math.min(deg, 10);

                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                ctx.fillStyle = isGiant ? '#ff6464' : '#6464aa';
                ctx.fill();
            });

            drawChart();
        }

        function drawChart() {
            const w = chartCanvas.width;
            const h = chartCanvas.height;
            chartCtx.fillStyle = 'rgba(0,0,0,0.5)';
            chartCtx.fillRect(0, 0, w, h);

            if (history.length < 2) return;

            chartCtx.strokeStyle = '#ff6464';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();

            const maxRemoved = originalNodes.length;
            history.forEach((h, i) => {
                const x = (h.removed / maxRemoved) * (w - 20) + 10;
                const y = (1 - h.giantFraction) * (h.height - 30) + 15;
                const yPos = (1 - h.giantFraction) * (chartCanvas.height - 30) + 15;
                if (i === 0) chartCtx.moveTo(x, yPos);
                else chartCtx.lineTo(x, yPos);
            });
            chartCtx.stroke();

            chartCtx.fillStyle = '#666';
            chartCtx.font = '10px sans-serif';
            chartCtx.fillText('Giant Component vs Nodes Removed', 10, 12);
        }

        function updateStats() {
            const aliveNodes = nodes.filter(n => n.alive);
            const components = findComponents();
            const giantSize = components.length > 0 ? components[0].length : 0;

            document.getElementById('originalNodes').textContent = originalNodes.length;
            document.getElementById('remainingNodes').textContent = aliveNodes.length;
            document.getElementById('removedCount').textContent = removed.length;
            document.getElementById('giantSize').textContent = originalNodes.length > 0 ?
                (giantSize / originalNodes.length * 100).toFixed(1) + '%' : '0%';
            document.getElementById('componentCount').textContent = components.length;
        }

        function animate() {
            applyForces();
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.getElementById('networkType').onchange = (e) => {
            if (e.target.value === 'barabasi') generateBarabasi();
            else generateRandom();
            updateStats();
        };

        document.querySelectorAll('.attack-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.attack-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                attackType = btn.dataset.attack;
            };
        });

        document.getElementById('generateBtn').onclick = () => {
            const type = document.getElementById('networkType').value;
            if (type === 'barabasi') generateBarabasi();
            else generateRandom();
            updateStats();
        };

        document.getElementById('removeBtn').onclick = removeNode;
        document.getElementById('attackBtn').onclick = runFullAttack;
        document.getElementById('resetBtn').onclick = reset;

        // Initialize
        generateBarabasi();
        updateStats();
        animate();
    </script>
</body>
</html>
