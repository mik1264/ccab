<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rumor Spreading - Network Science</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #eee; min-height: 100vh; padding: 20px; }
        .back-link { position: fixed; top: 20px; left: 20px; color: #4ade80; text-decoration: none; font-weight: 600; padding: 8px 16px; background: rgba(0,0,0,0.3); border-radius: 20px; z-index: 100; }
        h1 { text-align: center; margin: 40px 0 10px; font-size: 2.2em; color: #4ade80; }
        .subtitle { text-align: center; opacity: 0.8; margin-bottom: 20px; }
        .container { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 25px; }
        .info-box { background: rgba(74, 222, 128, 0.1); border: 1px solid rgba(74, 222, 128, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 0.85em; line-height: 1.6; }
        h3 { color: #4ade80; margin-bottom: 15px; }
        canvas { width: 100%; border-radius: 8px; background: #0a0a15; }
        .control-group { margin: 15px 0; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input { width: 100%; }
        .value-display { color: #4ade80; font-family: monospace; }
        button { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; }
        .btn-primary { background: #4ade80; color: #1a1a2e; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .status-bar { display: flex; height: 30px; border-radius: 8px; overflow: hidden; margin: 15px 0; }
        .status-segment { display: flex; align-items: center; justify-content: center; font-size: 0.8em; font-weight: 600; transition: width 0.3s; }
        .legend { display: flex; gap: 15px; flex-wrap: wrap; margin: 10px 0; }
        .legend-item { display: flex; align-items: center; gap: 5px; font-size: 0.85em; }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; }
        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back</a>
    <h1>Rumor Spreading</h1>
    <p class="subtitle">SIR model on network topology</p>

    <div class="container">
        <div class="panel">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>

        <div class="panel">
            <div class="info-box">
                <strong>SIR Model for Rumors:</strong>
                <b>Ignorant (S)</b> - hasn't heard the rumor<br>
                <b>Spreader (I)</b> - actively spreading<br>
                <b>Stifler (R)</b> - knows but stopped spreading<br>
                Spreaders become stiflers when they meet another spreader or stifler.
            </div>

            <div class="legend">
                <div class="legend-item"><div class="legend-dot" style="background: #6b7280;"></div> Ignorant</div>
                <div class="legend-item"><div class="legend-dot" style="background: #f87171;"></div> Spreader</div>
                <div class="legend-item"><div class="legend-dot" style="background: #4ade80;"></div> Stifler</div>
            </div>

            <h3>Population Status</h3>
            <div class="status-bar">
                <div class="status-segment" id="ignorantBar" style="width: 100%; background: #6b7280;"></div>
                <div class="status-segment" id="spreaderBar" style="width: 0%; background: #f87171;"></div>
                <div class="status-segment" id="stiflerBar" style="width: 0%; background: #4ade80;"></div>
            </div>

            <h3>Parameters</h3>
            <div class="control-group">
                <label>Network Size: <span class="value-display" id="nVal">60</span></label>
                <input type="range" id="nSlider" min="30" max="100" value="60" oninput="updateParam()">
            </div>

            <div class="control-group">
                <label>Spreading Rate (β): <span class="value-display" id="betaVal">0.3</span></label>
                <input type="range" id="betaSlider" min="10" max="90" value="30" oninput="updateParam()">
            </div>

            <div class="control-group">
                <label>Stifling Rate (γ): <span class="value-display" id="gammaVal">0.1</span></label>
                <input type="range" id="gammaSlider" min="5" max="50" value="10" oninput="updateParam()">
            </div>

            <button class="btn-primary" onclick="startRumor()">Start Rumor</button>
            <button class="btn-secondary" onclick="stepSimulation()">Step</button>
            <button class="btn-secondary" onclick="resetSimulation()">Reset</button>

            <h3 style="margin-top: 15px;">Spread Over Time</h3>
            <canvas id="chartCanvas" width="280" height="150"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const chartCanvas = document.getElementById('chartCanvas');
        const cctx = chartCanvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let n = 60;
        let beta = 0.3; // Spreading rate
        let gamma = 0.1; // Stifling rate
        let history = [];
        let running = false;

        const IGNORANT = 0;
        const SPREADER = 1;
        const STIFLER = 2;

        function updateParam() {
            n = parseInt(document.getElementById('nSlider').value);
            beta = parseInt(document.getElementById('betaSlider').value) / 100;
            gamma = parseInt(document.getElementById('gammaSlider').value) / 100;
            document.getElementById('nVal').textContent = n;
            document.getElementById('betaVal').textContent = beta.toFixed(2);
            document.getElementById('gammaVal').textContent = gamma.toFixed(2);
        }

        function resetSimulation() {
            running = false;
            history = [];
            nodes = [];
            edges = [];

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            // Create scale-free network
            for (let i = 0; i < n; i++) {
                const angle = (2 * Math.PI * i) / n + Math.random() * 0.2;
                const r = 180 + Math.random() * 50;
                nodes.push({
                    id: i,
                    state: IGNORANT,
                    x: cx + r * Math.cos(angle),
                    y: cy + r * Math.sin(angle),
                    degree: 0,
                    vx: 0, vy: 0
                });
            }

            // Build network
            for (let i = 0; i < Math.min(3, n); i++) {
                for (let j = 0; j < i; j++) {
                    edges.push([i, j]);
                    nodes[i].degree++;
                    nodes[j].degree++;
                }
            }

            for (let i = 3; i < n; i++) {
                const totalDeg = nodes.slice(0, i).reduce((s, n) => s + Math.max(n.degree, 1), 0);
                const targets = new Set();
                while (targets.size < 2) {
                    let r = Math.random() * totalDeg;
                    for (let j = 0; j < i; j++) {
                        r -= Math.max(nodes[j].degree, 1);
                        if (r <= 0) { targets.add(j); break; }
                    }
                }
                for (const t of targets) {
                    edges.push([i, t]);
                    nodes[i].degree++;
                    nodes[t].degree++;
                }
            }

            layoutNetwork();
            updateDisplay();
            draw();
            drawChart();
        }

        function layoutNetwork() {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            for (let iter = 0; iter < 50; iter++) {
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const dx = nodes[j].x - nodes[i].x;
                        const dy = nodes[j].y - nodes[i].y;
                        const dist = Math.max(Math.sqrt(dx * dx + dy * dy), 1);
                        const force = 4000 / (dist * dist);
                        nodes[i].vx -= (dx / dist) * force;
                        nodes[i].vy -= (dy / dist) * force;
                        nodes[j].vx += (dx / dist) * force;
                        nodes[j].vy += (dy / dist) * force;
                    }
                }

                for (const [i, j] of edges) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const force = (dist - 70) * 0.1;
                    nodes[i].vx += (dx / dist) * force;
                    nodes[i].vy += (dy / dist) * force;
                    nodes[j].vx -= (dx / dist) * force;
                    nodes[j].vy -= (dy / dist) * force;
                }

                nodes.forEach(node => {
                    node.vx += (cx - node.x) * 0.01;
                    node.vy += (cy - node.y) * 0.01;
                    node.x += node.vx * 0.1;
                    node.y += node.vy * 0.1;
                    node.vx *= 0.9;
                    node.vy *= 0.9;
                });
            }
        }

        function startRumor() {
            // Reset all to ignorant
            nodes.forEach(n => n.state = IGNORANT);
            history = [];

            // Pick random starter (prefer high-degree)
            const sorted = [...nodes].sort((a, b) => b.degree - a.degree);
            const starter = sorted[Math.floor(Math.random() * 5)];
            starter.state = SPREADER;

            updateDisplay();
            draw();
            runSimulation();
        }

        function stepSimulation() {
            const spreaders = nodes.filter(n => n.state === SPREADER);
            if (spreaders.length === 0) return false;

            // Each spreader tries to spread to neighbors
            for (const spreader of spreaders) {
                const neighbors = edges
                    .filter(e => e[0] === spreader.id || e[1] === spreader.id)
                    .map(e => e[0] === spreader.id ? nodes[e[1]] : nodes[e[0]]);

                let metSpreaderOrStifler = false;

                for (const neighbor of neighbors) {
                    if (neighbor.state === IGNORANT && Math.random() < beta) {
                        neighbor.state = SPREADER;
                    } else if (neighbor.state !== IGNORANT) {
                        metSpreaderOrStifler = true;
                    }
                }

                // Stifling
                if (metSpreaderOrStifler && Math.random() < gamma) {
                    spreader.state = STIFLER;
                }
            }

            recordHistory();
            updateDisplay();
            draw();
            drawChart();

            return spreaders.length > 0;
        }

        function recordHistory() {
            const counts = [0, 0, 0];
            nodes.forEach(n => counts[n.state]++);
            history.push(counts);
            if (history.length > 200) history.shift();
        }

        function updateDisplay() {
            const counts = [0, 0, 0];
            nodes.forEach(n => counts[n.state]++);

            const total = nodes.length;
            document.getElementById('ignorantBar').style.width = (counts[0] / total * 100) + '%';
            document.getElementById('spreaderBar').style.width = (counts[1] / total * 100) + '%';
            document.getElementById('stiflerBar').style.width = (counts[2] / total * 100) + '%';
        }

        function draw() {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw edges
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 1;
            for (const [i, j] of edges) {
                ctx.beginPath();
                ctx.moveTo(nodes[i].x, nodes[i].y);
                ctx.lineTo(nodes[j].x, nodes[j].y);
                ctx.stroke();
            }

            // Draw nodes
            const colors = ['#6b7280', '#f87171', '#4ade80'];
            for (const node of nodes) {
                const size = 6 + node.degree;
                ctx.fillStyle = colors[node.state];
                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                ctx.fill();

                if (node.state === SPREADER) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }

        function drawChart() {
            cctx.fillStyle = '#0a0a15';
            cctx.fillRect(0, 0, chartCanvas.width, chartCanvas.height);

            if (history.length < 2) return;

            const colors = ['#6b7280', '#f87171', '#4ade80'];
            const labels = ['Ignorant', 'Spreader', 'Stifler'];

            for (let s = 0; s < 3; s++) {
                cctx.strokeStyle = colors[s];
                cctx.lineWidth = 2;
                cctx.beginPath();
                history.forEach((h, i) => {
                    const x = (i / (history.length - 1)) * chartCanvas.width;
                    const y = chartCanvas.height - (h[s] / n) * chartCanvas.height;
                    if (i === 0) cctx.moveTo(x, y);
                    else cctx.lineTo(x, y);
                });
                cctx.stroke();
            }

            // Legend
            cctx.font = '9px sans-serif';
            labels.forEach((label, i) => {
                cctx.fillStyle = colors[i];
                cctx.fillText(label, 5 + i * 60, 12);
            });
        }

        async function runSimulation() {
            if (running) return;
            running = true;

            while (running && nodes.some(n => n.state === SPREADER)) {
                stepSimulation();
                await new Promise(r => setTimeout(r, 100));
            }

            running = false;
        }

        // Click to infect node
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            for (const node of nodes) {
                const dx = node.x - x;
                const dy = node.y - y;
                if (Math.sqrt(dx * dx + dy * dy) < 15) {
                    if (node.state === IGNORANT) {
                        node.state = SPREADER;
                        recordHistory();
                        updateDisplay();
                        draw();
                        drawChart();
                        runSimulation();
                    }
                    break;
                }
            }
        });

        updateParam();
        resetSimulation();
    </script>
</body>
</html>
