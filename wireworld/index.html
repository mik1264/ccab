<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wireworld - Logic Circuit Cellular Automaton - CCAB</title>
    <meta name="description" content="Wireworld cellular automaton for simulating digital circuits and logic gates. Draw wires and watch electrons flow through your designs.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a1a;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            display: flex;
        }

        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            padding: 10px 18px;
            background: rgba(0, 0, 0, 0.6);
            color: #ffc107;
            text-decoration: none;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 193, 7, 0.3);
            transition: all 0.3s ease;
        }

        .back-link:hover {
            background: rgba(255, 193, 7, 0.2);
            transform: translateX(-4px);
        }

        #main-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 60px 20px 20px;
        }

        canvas {
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(255, 193, 7, 0.2);
            cursor: crosshair;
        }

        #sidebar {
            width: 280px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid rgba(255, 193, 7, 0.2);
        }

        #sidebar h2 {
            color: #ffc107;
            font-size: 1.3em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 193, 7, 0.3);
        }

        #sidebar h3 {
            color: #ffca28;
            font-size: 0.9em;
            margin: 15px 0 10px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #ffc107;
            font-weight: bold;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin: 10px 0;
        }

        .tool-btn {
            padding: 10px;
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            color: #ffc107;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            text-align: center;
            transition: all 0.3s;
        }

        .tool-btn:hover {
            background: rgba(255, 193, 7, 0.2);
        }

        .tool-btn.active {
            background: rgba(255, 193, 7, 0.4);
            border-color: #ffc107;
        }

        .tool-btn .icon {
            font-size: 18px;
            display: block;
            margin-bottom: 4px;
        }

        .preset-btn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            color: #ffc107;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .preset-btn:hover {
            background: rgba(255, 193, 7, 0.3);
        }

        .control-row {
            display: flex;
            gap: 8px;
            margin: 10px 0;
        }

        .control-row button {
            flex: 1;
            padding: 10px;
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.4);
            color: #ffc107;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .control-row button:hover {
            background: rgba(255, 193, 7, 0.4);
        }

        .control-row button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-group {
            margin: 10px 0;
        }

        .control-group label {
            display: block;
            color: #ffca28;
            font-size: 11px;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: #ffc107;
        }

        .legend {
            margin: 15px 0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 6px 0;
            font-size: 11px;
            color: #aaa;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .info-text {
            font-size: 11px;
            color: #888;
            line-height: 1.5;
            margin-top: 15px;
        }

        #fps-display {
            position: fixed;
            bottom: 15px;
            right: 300px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 6px;
            color: #ffc107;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">← Back to Gallery</a>

    <div id="main-container">
        <canvas id="canvas"></canvas>
    </div>

    <div id="sidebar">
        <h2>Wireworld</h2>

        <div class="stat-row">
            <span class="stat-label">Generation</span>
            <span class="stat-value" id="generation">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Conductors</span>
            <span class="stat-value" id="conductors">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Electrons</span>
            <span class="stat-value" id="electrons">0</span>
        </div>

        <h3>Drawing Tool</h3>
        <div class="tool-grid">
            <button class="tool-btn active" data-tool="conductor">
                <span class="icon">━</span>
                Conductor
            </button>
            <button class="tool-btn" data-tool="head">
                <span class="icon">●</span>
                Electron Head
            </button>
            <button class="tool-btn" data-tool="tail">
                <span class="icon">○</span>
                Electron Tail
            </button>
            <button class="tool-btn" data-tool="erase">
                <span class="icon">✕</span>
                Erase
            </button>
        </div>

        <h3>Simulation</h3>
        <div class="control-row">
            <button id="play">▶ Play</button>
            <button id="step">Step</button>
        </div>
        <div class="control-group">
            <label>Speed: <span id="speed-val">10</span> gen/s</label>
            <input type="range" id="speed" min="1" max="30" value="10">
        </div>

        <h3>Presets</h3>
        <button class="preset-btn" data-preset="diode">Diode</button>
        <button class="preset-btn" data-preset="or">OR Gate</button>
        <button class="preset-btn" data-preset="and">AND Gate</button>
        <button class="preset-btn" data-preset="xor">XOR Gate</button>
        <button class="preset-btn" data-preset="clock">Clock Generator</button>
        <button class="preset-btn" data-preset="clear">Clear All</button>

        <h3>Cell States</h3>
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #1a1a2e;"></div>
                <span>Empty</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffc107;"></div>
                <span>Conductor (wire)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #2196f3;"></div>
                <span>Electron Head</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #f44336;"></div>
                <span>Electron Tail</span>
            </div>
        </div>

        <p class="info-text">
            <strong>Rules:</strong><br>
            • Empty → Empty<br>
            • Head → Tail<br>
            • Tail → Conductor<br>
            • Conductor → Head if 1 or 2 neighboring heads, else stays Conductor<br><br>
            Click and drag to draw. Wireworld can simulate logic gates and even complete computers!
        </p>
    </div>

    <div id="fps-display">FPS: <span id="fps">0</span></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Grid settings
        const cellSize = 10;
        let cols, rows;
        let grid = [];
        let nextGrid = [];

        // Cell states
        const EMPTY = 0;
        const CONDUCTOR = 1;
        const HEAD = 2;
        const TAIL = 3;

        // Colors
        const colors = {
            [EMPTY]: '#1a1a2e',
            [CONDUCTOR]: '#ffc107',
            [HEAD]: '#2196f3',
            [TAIL]: '#f44336'
        };

        // State
        let currentTool = 'conductor';
        let isPlaying = false;
        let speed = 10;
        let generation = 0;
        let lastUpdate = 0;
        let isDrawing = false;

        // UI elements
        const generationDisplay = document.getElementById('generation');
        const conductorsDisplay = document.getElementById('conductors');
        const electronsDisplay = document.getElementById('electrons');
        const fpsDisplay = document.getElementById('fps');
        const speedSlider = document.getElementById('speed');
        const speedVal = document.getElementById('speed-val');
        const playBtn = document.getElementById('play');

        // Initialize
        function init() {
            const containerWidth = window.innerWidth - 320;
            const containerHeight = window.innerHeight - 80;

            cols = Math.floor(containerWidth / cellSize);
            rows = Math.floor(containerHeight / cellSize);

            canvas.width = cols * cellSize;
            canvas.height = rows * cellSize;

            grid = Array(rows).fill(null).map(() => Array(cols).fill(EMPTY));
            nextGrid = Array(rows).fill(null).map(() => Array(cols).fill(EMPTY));
        }

        // Count neighbors of a specific state
        function countNeighbors(r, c, state) {
            let count = 0;
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const nr = r + dr;
                    const nc = c + dc;
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                        if (grid[nr][nc] === state) count++;
                    }
                }
            }
            return count;
        }

        // Update grid according to Wireworld rules
        function update() {
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = grid[r][c];

                    switch (cell) {
                        case EMPTY:
                            nextGrid[r][c] = EMPTY;
                            break;
                        case HEAD:
                            nextGrid[r][c] = TAIL;
                            break;
                        case TAIL:
                            nextGrid[r][c] = CONDUCTOR;
                            break;
                        case CONDUCTOR:
                            const headNeighbors = countNeighbors(r, c, HEAD);
                            nextGrid[r][c] = (headNeighbors === 1 || headNeighbors === 2) ? HEAD : CONDUCTOR;
                            break;
                    }
                }
            }

            // Swap grids
            [grid, nextGrid] = [nextGrid, grid];
            generation++;
        }

        // Draw the grid
        function draw() {
            ctx.fillStyle = colors[EMPTY];
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let conductorCount = 0;
            let electronCount = 0;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = grid[r][c];
                    if (cell !== EMPTY) {
                        ctx.fillStyle = colors[cell];
                        ctx.fillRect(c * cellSize, r * cellSize, cellSize - 1, cellSize - 1);

                        if (cell === CONDUCTOR) conductorCount++;
                        if (cell === HEAD || cell === TAIL) electronCount++;
                    }
                }
            }

            // Draw grid lines (subtle)
            ctx.strokeStyle = 'rgba(255, 193, 7, 0.1)';
            ctx.lineWidth = 0.5;
            for (let r = 0; r <= rows; r++) {
                ctx.beginPath();
                ctx.moveTo(0, r * cellSize);
                ctx.lineTo(canvas.width, r * cellSize);
                ctx.stroke();
            }
            for (let c = 0; c <= cols; c++) {
                ctx.beginPath();
                ctx.moveTo(c * cellSize, 0);
                ctx.lineTo(c * cellSize, canvas.height);
                ctx.stroke();
            }

            // Update stats
            generationDisplay.textContent = generation;
            conductorsDisplay.textContent = conductorCount;
            electronsDisplay.textContent = electronCount;
        }

        // Set cell at position
        function setCell(x, y) {
            const c = Math.floor(x / cellSize);
            const r = Math.floor(y / cellSize);

            if (r >= 0 && r < rows && c >= 0 && c < cols) {
                switch (currentTool) {
                    case 'conductor':
                        grid[r][c] = CONDUCTOR;
                        break;
                    case 'head':
                        grid[r][c] = HEAD;
                        break;
                    case 'tail':
                        grid[r][c] = TAIL;
                        break;
                    case 'erase':
                        grid[r][c] = EMPTY;
                        break;
                }
            }
        }

        // Load preset circuit
        function loadPreset(name) {
            grid = Array(rows).fill(null).map(() => Array(cols).fill(EMPTY));
            generation = 0;

            const centerR = Math.floor(rows / 2);
            const centerC = Math.floor(cols / 2);

            switch (name) {
                case 'diode':
                    // Simple diode - electrons can only flow one direction
                    for (let i = -10; i < 10; i++) {
                        grid[centerR][centerC + i] = CONDUCTOR;
                    }
                    // Diode structure
                    grid[centerR - 1][centerC] = CONDUCTOR;
                    grid[centerR + 1][centerC] = CONDUCTOR;
                    grid[centerR - 1][centerC + 1] = CONDUCTOR;
                    grid[centerR + 1][centerC + 1] = CONDUCTOR;
                    // Add electron
                    grid[centerR][centerC - 8] = HEAD;
                    grid[centerR][centerC - 9] = TAIL;
                    break;

                case 'or':
                    // OR gate
                    // Input wires
                    for (let i = -10; i < -2; i++) {
                        grid[centerR - 3][centerC + i] = CONDUCTOR;
                        grid[centerR + 3][centerC + i] = CONDUCTOR;
                    }
                    // Junction
                    for (let j = -3; j <= 3; j++) {
                        grid[centerR + j][centerC - 2] = CONDUCTOR;
                    }
                    // Output wire
                    for (let i = -2; i < 10; i++) {
                        grid[centerR][centerC + i] = CONDUCTOR;
                    }
                    // Add electrons
                    grid[centerR - 3][centerC - 8] = HEAD;
                    grid[centerR - 3][centerC - 9] = TAIL;
                    break;

                case 'and':
                    // AND gate using Wireworld logic
                    // Two input wires
                    for (let i = -12; i < -4; i++) {
                        grid[centerR - 2][centerC + i] = CONDUCTOR;
                        grid[centerR + 2][centerC + i] = CONDUCTOR;
                    }
                    // AND junction (requires both inputs)
                    grid[centerR - 1][centerC - 4] = CONDUCTOR;
                    grid[centerR][centerC - 4] = CONDUCTOR;
                    grid[centerR + 1][centerC - 4] = CONDUCTOR;
                    grid[centerR - 1][centerC - 3] = CONDUCTOR;
                    grid[centerR + 1][centerC - 3] = CONDUCTOR;
                    grid[centerR][centerC - 2] = CONDUCTOR;
                    // Output
                    for (let i = -2; i < 10; i++) {
                        grid[centerR][centerC + i] = CONDUCTOR;
                    }
                    // Add electrons on both inputs
                    grid[centerR - 2][centerC - 10] = HEAD;
                    grid[centerR - 2][centerC - 11] = TAIL;
                    grid[centerR + 2][centerC - 10] = HEAD;
                    grid[centerR + 2][centerC - 11] = TAIL;
                    break;

                case 'xor':
                    // XOR gate
                    // Input wires
                    for (let i = -15; i < -5; i++) {
                        grid[centerR - 3][centerC + i] = CONDUCTOR;
                        grid[centerR + 3][centerC + i] = CONDUCTOR;
                    }
                    // XOR structure
                    grid[centerR - 2][centerC - 5] = CONDUCTOR;
                    grid[centerR - 1][centerC - 5] = CONDUCTOR;
                    grid[centerR][centerC - 5] = CONDUCTOR;
                    grid[centerR + 1][centerC - 5] = CONDUCTOR;
                    grid[centerR + 2][centerC - 5] = CONDUCTOR;
                    grid[centerR - 1][centerC - 4] = CONDUCTOR;
                    grid[centerR + 1][centerC - 4] = CONDUCTOR;
                    grid[centerR][centerC - 3] = CONDUCTOR;
                    // Output
                    for (let i = -3; i < 10; i++) {
                        grid[centerR][centerC + i] = CONDUCTOR;
                    }
                    // Add one electron (XOR with one input = output)
                    grid[centerR - 3][centerC - 13] = HEAD;
                    grid[centerR - 3][centerC - 14] = TAIL;
                    break;

                case 'clock':
                    // Clock generator - produces periodic pulses
                    // Main loop
                    const loopSize = 6;
                    for (let i = 0; i < loopSize; i++) {
                        grid[centerR - 2][centerC - loopSize + i] = CONDUCTOR;
                        grid[centerR + 2][centerC - loopSize + i] = CONDUCTOR;
                    }
                    grid[centerR - 1][centerC - loopSize] = CONDUCTOR;
                    grid[centerR][centerC - loopSize] = CONDUCTOR;
                    grid[centerR + 1][centerC - loopSize] = CONDUCTOR;
                    grid[centerR - 1][centerC] = CONDUCTOR;
                    grid[centerR][centerC] = CONDUCTOR;
                    grid[centerR + 1][centerC] = CONDUCTOR;
                    // Output wire
                    for (let i = 1; i < 15; i++) {
                        grid[centerR][centerC + i] = CONDUCTOR;
                    }
                    // Initial electron in loop
                    grid[centerR - 2][centerC - 3] = HEAD;
                    grid[centerR - 2][centerC - 4] = TAIL;
                    break;

                case 'clear':
                    // Already cleared above
                    break;
            }
        }

        // Animation loop
        let frameCount = 0;
        let lastFpsTime = 0;
        let fps = 0;

        function animate(currentTime) {
            requestAnimationFrame(animate);

            // FPS calculation
            frameCount++;
            if (currentTime - lastFpsTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFpsTime = currentTime;
                fpsDisplay.textContent = fps;
            }

            // Update simulation
            if (isPlaying) {
                const interval = 1000 / speed;
                if (currentTime - lastUpdate >= interval) {
                    update();
                    lastUpdate = currentTime;
                }
            }

            draw();
        }

        // Event listeners
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            setCell(e.clientX - rect.left, e.clientY - rect.top);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                const rect = canvas.getBoundingClientRect();
                setCell(e.clientX - rect.left, e.clientY - rect.top);
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });

        // Tool selection
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTool = btn.dataset.tool;
            });
        });

        // Presets
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                loadPreset(btn.dataset.preset);
            });
        });

        // Controls
        playBtn.addEventListener('click', () => {
            isPlaying = !isPlaying;
            playBtn.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
        });

        document.getElementById('step').addEventListener('click', () => {
            update();
        });

        speedSlider.addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            speedVal.textContent = speed;
        });

        // Initialize
        init();
        loadPreset('clock');
        requestAnimationFrame(animate);
    </script>
</body>
</html>
