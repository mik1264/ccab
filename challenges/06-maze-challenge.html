<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pathfinding Challenge - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Nunito', sans-serif;
            background: #1a1a2e;
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: #8A9A5B;
            text-decoration: none;
            font-weight: 500;
            padding: 8px 16px;
            background: rgba(0,0,0,0.5);
            border-radius: 20px;
        }
        h1 {
            font-family: 'Lora', serif;
            color: #8A9A5B;
            margin: 20px 0;
        }
        .game-container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        canvas {
            border: 2px solid #333;
            border-radius: 10px;
            cursor: crosshair;
        }
        .controls {
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 15px;
            width: 300px;
        }
        .controls h3 {
            font-family: 'Lora', serif;
            color: #8A9A5B;
            margin-bottom: 15px;
        }
        .btn-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        .btn {
            background: linear-gradient(135deg, #606C38, #8A9A5B);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            flex: 1;
            min-width: 80px;
        }
        .btn:hover { transform: scale(1.02); }
        .btn.secondary {
            background: linear-gradient(135deg, #BC6C25, #DDA15E);
        }
        .btn.active {
            box-shadow: 0 0 10px #8A9A5B;
        }
        .mode-selector {
            margin-bottom: 15px;
        }
        .mode-selector h4 {
            color: #8A9A5B;
            margin-bottom: 8px;
        }
        .mode-btn {
            background: rgba(138, 154, 91, 0.2);
            border: 1px solid #8A9A5B;
            color: #8A9A5B;
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.8rem;
            margin: 3px;
        }
        .mode-btn.active {
            background: #8A9A5B;
            color: white;
        }
        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #444;
        }
        .stats div {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }
        .stats .label { color: #888; }
        .stats .value { color: #8A9A5B; font-weight: bold; }
        .challenge-status {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #444;
        }
        .challenge-item {
            margin-bottom: 8px;
            font-size: 0.8rem;
        }
        .challenge-item.completed { color: #4CAF50; }
        .challenge-item.pending { color: #888; }
        .info-box {
            background: rgba(138, 154, 91, 0.2);
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 15px;
            font-size: 0.85rem;
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            font-size: 0.8rem;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Challenges</a>

    <h1>Pathfinding Challenge</h1>

    <div class="game-container">
        <canvas id="canvas" width="500" height="500"></canvas>

        <div class="controls">
            <h3>üó∫Ô∏è Maze & Pathfinding</h3>

            <div class="info-box">
                Draw walls, set start (green) & goal (red), then find the path!
            </div>

            <div class="mode-selector">
                <h4>Draw Mode:</h4>
                <button class="mode-btn active" onclick="setMode('wall')">Wall</button>
                <button class="mode-btn" onclick="setMode('start')">Start</button>
                <button class="mode-btn" onclick="setMode('goal')">Goal</button>
                <button class="mode-btn" onclick="setMode('erase')">Erase</button>
            </div>

            <div class="mode-selector">
                <h4>Algorithm:</h4>
                <button class="mode-btn active" onclick="setAlgorithm('astar')">A*</button>
                <button class="mode-btn" onclick="setAlgorithm('dijkstra')">Dijkstra</button>
                <button class="mode-btn" onclick="setAlgorithm('greedy')">Greedy</button>
                <button class="mode-btn" onclick="setAlgorithm('bfs')">BFS</button>
            </div>

            <div class="btn-group">
                <button class="btn" onclick="findPath()">Find Path</button>
                <button class="btn secondary" onclick="clearPath()">Clear Path</button>
            </div>

            <div class="btn-group">
                <button class="btn" onclick="generateMaze()">Generate Maze</button>
                <button class="btn secondary" onclick="clearAll()">Clear All</button>
            </div>

            <div class="stats">
                <div><span class="label">Walls:</span> <span class="value" id="wallCount">0</span></div>
                <div><span class="label">Explored:</span> <span class="value" id="explored">0</span></div>
                <div><span class="label">Path Length:</span> <span class="value" id="pathLen">0</span></div>
                <div><span class="label">Algorithm:</span> <span class="value" id="algoName">A*</span></div>
            </div>

            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background: #4CAF50;"></div>Start</div>
                <div class="legend-item"><div class="legend-color" style="background: #f44336;"></div>Goal</div>
                <div class="legend-item"><div class="legend-color" style="background: #333;"></div>Wall</div>
                <div class="legend-item"><div class="legend-color" style="background: #64B5F6;"></div>Explored</div>
                <div class="legend-item"><div class="legend-color" style="background: #FFEB3B;"></div>Path</div>
            </div>

            <div class="challenge-status">
                <div class="challenge-item pending" id="ch1">‚≠ï Create maze with 30+ walls</div>
                <div class="challenge-item pending" id="ch2">‚≠ï Find a path (any algorithm)</div>
                <div class="challenge-item pending" id="ch3">‚≠ï Compare A* vs Dijkstra (A* explores less)</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const COLS = 25;
        const ROWS = 25;
        const CELL = canvas.width / COLS;

        let grid = [];
        let start = { x: 1, y: 1 };
        let goal = { x: COLS - 2, y: ROWS - 2 };
        let drawMode = 'wall';
        let algorithm = 'astar';
        let explored = [];
        let path = [];
        let isDrawing = false;
        let completedChallenges = new Set();
        let lastAStarExplored = 0;
        let lastDijkstraExplored = 0;

        // Expose for challenge system
        window.pathFound = () => path.length > 0;
        window.wallCount = () => grid.flat().filter(c => c === 1).length;

        function initGrid() {
            grid = [];
            for (let y = 0; y < ROWS; y++) {
                grid[y] = [];
                for (let x = 0; x < COLS; x++) {
                    grid[y][x] = 0;
                }
            }
        }

        function setMode(mode) {
            drawMode = mode;
            document.querySelectorAll('.mode-selector:first-of-type .mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent.toLowerCase() === mode);
            });
        }

        function setAlgorithm(algo) {
            algorithm = algo;
            document.getElementById('algoName').textContent = {
                astar: 'A*',
                dijkstra: 'Dijkstra',
                greedy: 'Greedy',
                bfs: 'BFS'
            }[algo];
            document.querySelectorAll('.mode-selector:nth-of-type(2) .mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent.toLowerCase() === algo ||
                    (algo === 'astar' && btn.textContent === 'A*'));
            });
        }

        function clearPath() {
            explored = [];
            path = [];
            draw();
        }

        function clearAll() {
            initGrid();
            explored = [];
            path = [];
            start = { x: 1, y: 1 };
            goal = { x: COLS - 2, y: ROWS - 2 };
            draw();
        }

        function generateMaze() {
            initGrid();
            explored = [];
            path = [];

            // Fill with walls
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    grid[y][x] = 1;
                }
            }

            // Recursive backtracker maze generation
            const stack = [];
            const visited = new Set();
            const startX = 1, startY = 1;

            grid[startY][startX] = 0;
            visited.add(`${startX},${startY}`);
            stack.push({ x: startX, y: startY });

            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = [];

                const dirs = [
                    { dx: 0, dy: -2 },
                    { dx: 2, dy: 0 },
                    { dx: 0, dy: 2 },
                    { dx: -2, dy: 0 }
                ];

                for (const dir of dirs) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    if (nx > 0 && nx < COLS - 1 && ny > 0 && ny < ROWS - 1 && !visited.has(`${nx},${ny}`)) {
                        neighbors.push({ x: nx, y: ny, mx: current.x + dir.dx / 2, my: current.y + dir.dy / 2 });
                    }
                }

                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    grid[next.my][next.mx] = 0;
                    grid[next.y][next.x] = 0;
                    visited.add(`${next.x},${next.y}`);
                    stack.push({ x: next.x, y: next.y });
                } else {
                    stack.pop();
                }
            }

            start = { x: 1, y: 1 };
            goal = { x: COLS - 2, y: ROWS - 2 };
            grid[start.y][start.x] = 0;
            grid[goal.y][goal.x] = 0;

            draw();
            updateStats();
        }

        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        function findPath() {
            clearPath();

            const openSet = [];
            const closedSet = new Set();
            const cameFrom = {};
            const gScore = {};
            const fScore = {};

            const startKey = `${start.x},${start.y}`;
            const goalKey = `${goal.x},${goal.y}`;

            gScore[startKey] = 0;
            fScore[startKey] = heuristic(start, goal);
            openSet.push({ ...start, f: fScore[startKey] });

            while (openSet.length > 0) {
                // Sort by f-score (or just g for Dijkstra, or h for greedy)
                openSet.sort((a, b) => a.f - b.f);
                const current = openSet.shift();
                const currentKey = `${current.x},${current.y}`;

                if (current.x === goal.x && current.y === goal.y) {
                    // Reconstruct path
                    let curr = currentKey;
                    while (cameFrom[curr]) {
                        const [x, y] = curr.split(',').map(Number);
                        path.unshift({ x, y });
                        curr = cameFrom[curr];
                    }
                    path.unshift(start);

                    // Store explored count for comparison
                    if (algorithm === 'astar') lastAStarExplored = explored.length;
                    if (algorithm === 'dijkstra') lastDijkstraExplored = explored.length;

                    draw();
                    updateStats();
                    checkChallenges();
                    return;
                }

                closedSet.add(currentKey);
                explored.push({ x: current.x, y: current.y });

                const neighbors = [
                    { x: current.x + 1, y: current.y },
                    { x: current.x - 1, y: current.y },
                    { x: current.x, y: current.y + 1 },
                    { x: current.x, y: current.y - 1 }
                ];

                for (const neighbor of neighbors) {
                    if (neighbor.x < 0 || neighbor.x >= COLS || neighbor.y < 0 || neighbor.y >= ROWS) continue;
                    if (grid[neighbor.y][neighbor.x] === 1) continue;

                    const neighborKey = `${neighbor.x},${neighbor.y}`;
                    if (closedSet.has(neighborKey)) continue;

                    const tentativeG = (gScore[currentKey] || 0) + 1;

                    if (!gScore[neighborKey] || tentativeG < gScore[neighborKey]) {
                        cameFrom[neighborKey] = currentKey;
                        gScore[neighborKey] = tentativeG;

                        let f;
                        switch (algorithm) {
                            case 'astar':
                                f = tentativeG + heuristic(neighbor, goal);
                                break;
                            case 'dijkstra':
                                f = tentativeG;
                                break;
                            case 'greedy':
                                f = heuristic(neighbor, goal);
                                break;
                            case 'bfs':
                                f = explored.length; // FIFO order
                                break;
                        }
                        fScore[neighborKey] = f;

                        if (!openSet.find(n => n.x === neighbor.x && n.y === neighbor.y)) {
                            openSet.push({ ...neighbor, f });
                        }
                    }
                }

                // Visualize progress
                if (explored.length % 10 === 0) {
                    draw();
                }
            }

            // No path found
            draw();
            updateStats();
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw explored cells
            for (const cell of explored) {
                ctx.fillStyle = 'rgba(100, 181, 246, 0.3)';
                ctx.fillRect(cell.x * CELL + 1, cell.y * CELL + 1, CELL - 2, CELL - 2);
            }

            // Draw grid
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (grid[y][x] === 1) {
                        ctx.fillStyle = '#333';
                        ctx.fillRect(x * CELL, y * CELL, CELL, CELL);
                    }
                }
            }

            // Draw path
            if (path.length > 0) {
                ctx.strokeStyle = '#FFEB3B';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(path[0].x * CELL + CELL / 2, path[0].y * CELL + CELL / 2);
                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x * CELL + CELL / 2, path[i].y * CELL + CELL / 2);
                }
                ctx.stroke();
            }

            // Draw start
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.arc(start.x * CELL + CELL / 2, start.y * CELL + CELL / 2, CELL / 3, 0, Math.PI * 2);
            ctx.fill();

            // Draw goal
            ctx.fillStyle = '#f44336';
            ctx.beginPath();
            ctx.arc(goal.x * CELL + CELL / 2, goal.y * CELL + CELL / 2, CELL / 3, 0, Math.PI * 2);
            ctx.fill();

            // Grid lines
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL, 0);
                ctx.lineTo(i * CELL, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * CELL);
                ctx.lineTo(canvas.width, i * CELL);
                ctx.stroke();
            }
        }

        function updateStats() {
            const walls = grid.flat().filter(c => c === 1).length;
            document.getElementById('wallCount').textContent = walls;
            document.getElementById('explored').textContent = explored.length;
            document.getElementById('pathLen').textContent = path.length > 0 ? path.length - 1 : 0;
        }

        function checkChallenges() {
            const walls = grid.flat().filter(c => c === 1).length;

            // Challenge 1: 30+ walls
            if (!completedChallenges.has('ch1') && walls >= 30) {
                completedChallenges.add('ch1');
                markComplete('ch1', 25);
            }

            // Challenge 2: Find a path
            if (!completedChallenges.has('ch2') && path.length > 0) {
                completedChallenges.add('ch2');
                markComplete('ch2', 30);
            }

            // Challenge 3: A* explores less than Dijkstra
            if (!completedChallenges.has('ch3') && lastAStarExplored > 0 && lastDijkstraExplored > 0) {
                if (lastAStarExplored < lastDijkstraExplored) {
                    completedChallenges.add('ch3');
                    markComplete('ch3', 50);
                }
            }
        }

        function markComplete(id, xp) {
            const el = document.getElementById(id);
            el.className = 'challenge-item completed';
            el.textContent = '‚úÖ ' + el.textContent.substring(2);
            showNotification(xp);

            try {
                const data = JSON.parse(localStorage.getItem('ccab-challenges')) || { completed: [], xp: 0 };
                if (!data.completed.includes('maze-' + id)) {
                    data.completed.push('maze-' + id);
                    data.xp += xp;
                    localStorage.setItem('ccab-challenges', JSON.stringify(data));
                }
            } catch (e) {}
        }

        function showNotification(xp) {
            const notification = document.createElement('div');
            notification.innerHTML = `<div style="font-size: 2rem;">üèÜ</div><div>Challenge Complete!</div><div>+${xp} XP</div>`;
            notification.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #606C38, #8A9A5B); color: white;
                padding: 2rem 3rem; border-radius: 20px; text-align: center; z-index: 10000;
            `;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 2500);
        }

        function handleDraw(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / CELL);
            const y = Math.floor((e.clientY - rect.top) / CELL);

            if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return;

            switch (drawMode) {
                case 'wall':
                    if (!(x === start.x && y === start.y) && !(x === goal.x && y === goal.y)) {
                        grid[y][x] = 1;
                    }
                    break;
                case 'erase':
                    grid[y][x] = 0;
                    break;
                case 'start':
                    if (grid[y][x] !== 1) {
                        start = { x, y };
                    }
                    break;
                case 'goal':
                    if (grid[y][x] !== 1) {
                        goal = { x, y };
                    }
                    break;
            }

            draw();
            updateStats();
        }

        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            handleDraw(e);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) handleDraw(e);
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
            checkChallenges();
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });

        initGrid();
        draw();
    </script>
</body>
</html>
