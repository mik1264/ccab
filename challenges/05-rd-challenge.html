<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reaction-Diffusion Challenge - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Nunito', sans-serif;
            background: #1a1a2e;
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: #8A9A5B;
            text-decoration: none;
            font-weight: 500;
            padding: 8px 16px;
            background: rgba(0,0,0,0.5);
            border-radius: 20px;
        }
        h1 {
            font-family: 'Lora', serif;
            color: #8A9A5B;
            margin: 20px 0;
        }
        .game-container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        canvas {
            border: 2px solid #333;
            border-radius: 10px;
            cursor: crosshair;
        }
        .controls {
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 15px;
            width: 300px;
        }
        .controls h3 {
            font-family: 'Lora', serif;
            color: #8A9A5B;
            margin-bottom: 15px;
        }
        .control-group {
            margin-bottom: 12px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: #ccc;
        }
        .control-group input[type="range"] {
            width: 100%;
            accent-color: #BC6C25;
        }
        .value-display {
            text-align: right;
            font-size: 0.8rem;
            color: #8A9A5B;
        }
        .btn {
            background: linear-gradient(135deg, #606C38, #8A9A5B);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            margin: 5px 3px;
        }
        .btn:hover { transform: scale(1.02); }
        .btn.secondary {
            background: linear-gradient(135deg, #BC6C25, #DDA15E);
        }
        .presets {
            margin-top: 15px;
        }
        .presets h4 {
            color: #8A9A5B;
            margin-bottom: 10px;
        }
        .preset-btn {
            background: rgba(138, 154, 91, 0.2);
            border: 1px solid #8A9A5B;
            color: #8A9A5B;
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.8rem;
            margin: 3px;
        }
        .preset-btn:hover {
            background: rgba(138, 154, 91, 0.4);
        }
        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #444;
        }
        .stats div {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }
        .stats .label { color: #888; }
        .stats .value { color: #8A9A5B; font-weight: bold; }
        .challenge-status {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #444;
        }
        .challenge-item {
            margin-bottom: 8px;
            font-size: 0.8rem;
        }
        .challenge-item.completed { color: #4CAF50; }
        .challenge-item.pending { color: #888; }
        .info-box {
            background: rgba(138, 154, 91, 0.2);
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 15px;
            font-size: 0.85rem;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Challenges</a>

    <h1>Reaction-Diffusion Challenge</h1>

    <div class="game-container">
        <canvas id="canvas" width="400" height="400"></canvas>

        <div class="controls">
            <h3>üß™ Gray-Scott Model</h3>

            <div class="info-box">
                Click to add chemical B. Adjust feed/kill rates to create different patterns.
            </div>

            <div class="control-group">
                <label>Feed Rate <span class="value-display" id="feedVal">0.055</span></label>
                <input type="range" id="feed" min="0.01" max="0.1" step="0.001" value="0.055">
            </div>

            <div class="control-group">
                <label>Kill Rate <span class="value-display" id="killVal">0.062</span></label>
                <input type="range" id="kill" min="0.03" max="0.07" step="0.001" value="0.062">
            </div>

            <div class="control-group">
                <label>Diffusion A <span class="value-display" id="daVal">1.0</span></label>
                <input type="range" id="dA" min="0.5" max="1.5" step="0.1" value="1.0">
            </div>

            <div class="control-group">
                <label>Diffusion B <span class="value-display" id="dbVal">0.5</span></label>
                <input type="range" id="dB" min="0.2" max="0.8" step="0.05" value="0.5">
            </div>

            <div>
                <button class="btn" onclick="reset()">Reset</button>
                <button class="btn secondary" onclick="addRandomSeeds()">Add Seeds</button>
            </div>

            <div class="presets">
                <h4>Pattern Presets:</h4>
                <button class="preset-btn" onclick="setPreset('spots')">Spots</button>
                <button class="preset-btn" onclick="setPreset('stripes')">Stripes</button>
                <button class="preset-btn" onclick="setPreset('coral')">Coral</button>
                <button class="preset-btn" onclick="setPreset('mitosis')">Mitosis</button>
                <button class="preset-btn" onclick="setPreset('waves')">Waves</button>
            </div>

            <div class="stats">
                <div><span class="label">Iterations:</span> <span class="value" id="iterations">0</span></div>
                <div><span class="label">Pattern:</span> <span class="value" id="patternType">Unknown</span></div>
                <div><span class="label">Chemical B %:</span> <span class="value" id="chemB">0</span></div>
            </div>

            <div class="challenge-status">
                <div class="challenge-item pending" id="ch1">‚≠ï Create spotted pattern</div>
                <div class="challenge-item pending" id="ch2">‚≠ï Create striped pattern</div>
                <div class="challenge-item pending" id="ch3">‚≠ï Create coral growth</div>
                <div class="challenge-item pending" id="ch4">‚≠ï Mitosis (splitting cells)</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        let grid = [];
        let nextGrid = [];
        let params = {
            feed: 0.055,
            kill: 0.062,
            dA: 1.0,
            dB: 0.5
        };
        let iterations = 0;
        let completedChallenges = new Set();

        // Expose for challenge system
        window.rdParams = params;

        const PRESETS = {
            spots: { feed: 0.025, kill: 0.055 },
            stripes: { feed: 0.022, kill: 0.051 },
            coral: { feed: 0.055, kill: 0.062 },
            mitosis: { feed: 0.0367, kill: 0.0649 },
            waves: { feed: 0.014, kill: 0.045 }
        };

        function initGrid() {
            grid = [];
            nextGrid = [];
            for (let y = 0; y < H; y++) {
                grid[y] = [];
                nextGrid[y] = [];
                for (let x = 0; x < W; x++) {
                    grid[y][x] = { a: 1, b: 0 };
                    nextGrid[y][x] = { a: 1, b: 0 };
                }
            }
        }

        function addSeed(cx, cy, radius = 10) {
            for (let y = cy - radius; y < cy + radius; y++) {
                for (let x = cx - radius; x < cx + radius; x++) {
                    if (x >= 0 && x < W && y >= 0 && y < H) {
                        const d = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                        if (d < radius) {
                            grid[y][x].b = 1;
                        }
                    }
                }
            }
        }

        function addRandomSeeds() {
            for (let i = 0; i < 10; i++) {
                addSeed(
                    Math.floor(Math.random() * W),
                    Math.floor(Math.random() * H),
                    5 + Math.random() * 10
                );
            }
        }

        function reset() {
            initGrid();
            addSeed(W / 2, H / 2, 20);
            iterations = 0;
        }

        function setPreset(name) {
            const p = PRESETS[name];
            params.feed = p.feed;
            params.kill = p.kill;
            document.getElementById('feed').value = p.feed;
            document.getElementById('kill').value = p.kill;
            document.getElementById('feedVal').textContent = p.feed.toFixed(3);
            document.getElementById('killVal').textContent = p.kill.toFixed(3);
            reset();
        }

        function laplacian(x, y, key) {
            let sum = 0;
            sum += grid[y][x][key] * -1;
            sum += (grid[y][(x + 1) % W] || grid[y][0])[key] * 0.2;
            sum += (grid[y][(x - 1 + W) % W] || grid[y][W - 1])[key] * 0.2;
            sum += (grid[(y + 1) % H] || grid[0])[x][key] * 0.2;
            sum += (grid[(y - 1 + H) % H] || grid[H - 1])[x][key] * 0.2;
            sum += (grid[(y + 1) % H] || grid[0])[(x + 1) % W][key] * 0.05;
            sum += (grid[(y + 1) % H] || grid[0])[(x - 1 + W) % W][key] * 0.05;
            sum += (grid[(y - 1 + H) % H] || grid[H - 1])[(x + 1) % W][key] * 0.05;
            sum += (grid[(y - 1 + H) % H] || grid[H - 1])[(x - 1 + W) % W][key] * 0.05;
            return sum;
        }

        function update() {
            const { feed, kill, dA, dB } = params;

            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const a = grid[y][x].a;
                    const b = grid[y][x].b;

                    const lapA = laplacian(x, y, 'a');
                    const lapB = laplacian(x, y, 'b');

                    const reaction = a * b * b;

                    nextGrid[y][x].a = a + (dA * lapA - reaction + feed * (1 - a));
                    nextGrid[y][x].b = b + (dB * lapB + reaction - (kill + feed) * b);

                    nextGrid[y][x].a = Math.max(0, Math.min(1, nextGrid[y][x].a));
                    nextGrid[y][x].b = Math.max(0, Math.min(1, nextGrid[y][x].b));
                }
            }

            [grid, nextGrid] = [nextGrid, grid];
            iterations++;
        }

        function draw() {
            const imageData = ctx.createImageData(W, H);
            let totalB = 0;

            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const idx = (y * W + x) * 4;
                    const b = grid[y][x].b;
                    totalB += b;

                    // Color based on chemical B concentration
                    const hue = 120 - b * 120; // Green to red
                    const sat = 0.7;
                    const light = 0.2 + b * 0.5;

                    const c = hslToRgb(hue / 360, sat, light);
                    imageData.data[idx] = c.r;
                    imageData.data[idx + 1] = c.g;
                    imageData.data[idx + 2] = c.b;
                    imageData.data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Update stats
            const chemBPercent = (totalB / (W * H) * 100).toFixed(1);
            document.getElementById('iterations').textContent = iterations;
            document.getElementById('chemB').textContent = chemBPercent + '%';

            // Detect pattern type
            const patternType = detectPattern(totalB / (W * H));
            document.getElementById('patternType').textContent = patternType;

            return { totalB: totalB / (W * H), patternType };
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
        }

        function detectPattern(avgB) {
            const f = params.feed;
            const k = params.kill;

            // Simple pattern detection based on parameters
            if (f > 0.02 && f < 0.03 && k > 0.05 && k < 0.06) return 'Spots';
            if (f > 0.018 && f < 0.025 && k > 0.048 && k < 0.055) return 'Stripes';
            if (f > 0.05 && f < 0.06 && k > 0.06 && k < 0.065) return 'Coral';
            if (f > 0.035 && f < 0.04 && k > 0.063 && k < 0.067) return 'Mitosis';
            if (f > 0.01 && f < 0.02 && k > 0.04 && k < 0.05) return 'Waves';
            return 'Custom';
        }

        function checkChallenges(stats) {
            if (iterations < 500) return; // Need time for patterns to form

            const f = params.feed;
            const k = params.kill;

            // Challenge 1: Spots
            if (!completedChallenges.has('ch1')) {
                if (f > 0.02 && f < 0.03 && k > 0.05 && k < 0.06 && stats.totalB > 0.1) {
                    completedChallenges.add('ch1');
                    markComplete('ch1', 30);
                }
            }

            // Challenge 2: Stripes
            if (!completedChallenges.has('ch2')) {
                if (f > 0.018 && f < 0.025 && k > 0.048 && k < 0.055 && stats.totalB > 0.1) {
                    completedChallenges.add('ch2');
                    markComplete('ch2', 45);
                }
            }

            // Challenge 3: Coral
            if (!completedChallenges.has('ch3')) {
                if (f > 0.05 && f < 0.06 && k > 0.06 && k < 0.065 && stats.totalB > 0.05) {
                    completedChallenges.add('ch3');
                    markComplete('ch3', 40);
                }
            }

            // Challenge 4: Mitosis
            if (!completedChallenges.has('ch4')) {
                if (f > 0.035 && f < 0.04 && k > 0.063 && k < 0.067 && stats.totalB > 0.05) {
                    completedChallenges.add('ch4');
                    markComplete('ch4', 50);
                }
            }
        }

        function markComplete(id, xp) {
            const el = document.getElementById(id);
            el.className = 'challenge-item completed';
            el.textContent = '‚úÖ ' + el.textContent.substring(2);
            showNotification(xp);

            try {
                const data = JSON.parse(localStorage.getItem('ccab-challenges')) || { completed: [], xp: 0 };
                if (!data.completed.includes('rd-' + id)) {
                    data.completed.push('rd-' + id);
                    data.xp += xp;
                    localStorage.setItem('ccab-challenges', JSON.stringify(data));
                }
            } catch (e) {}
        }

        function showNotification(xp) {
            const notification = document.createElement('div');
            notification.innerHTML = `<div style="font-size: 2rem;">üèÜ</div><div>Challenge Complete!</div><div>+${xp} XP</div>`;
            notification.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #606C38, #8A9A5B); color: white;
                padding: 2rem 3rem; border-radius: 20px; text-align: center; z-index: 10000;
            `;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 2500);
        }

        function animate() {
            for (let i = 0; i < 5; i++) update(); // Multiple steps per frame
            const stats = draw();
            checkChallenges(stats);
            requestAnimationFrame(animate);
        }

        // Control bindings
        document.getElementById('feed').oninput = (e) => {
            params.feed = parseFloat(e.target.value);
            document.getElementById('feedVal').textContent = params.feed.toFixed(3);
        };
        document.getElementById('kill').oninput = (e) => {
            params.kill = parseFloat(e.target.value);
            document.getElementById('killVal').textContent = params.kill.toFixed(3);
        };
        document.getElementById('dA').oninput = (e) => {
            params.dA = parseFloat(e.target.value);
            document.getElementById('daVal').textContent = params.dA.toFixed(1);
        };
        document.getElementById('dB').oninput = (e) => {
            params.dB = parseFloat(e.target.value);
            document.getElementById('dbVal').textContent = params.dB.toFixed(2);
        };

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) * W / rect.width);
            const y = Math.floor((e.clientY - rect.top) * H / rect.height);
            addSeed(x, y, 15);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (e.buttons === 1) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) * W / rect.width);
                const y = Math.floor((e.clientY - rect.top) * H / rect.height);
                addSeed(x, y, 5);
            }
        });

        initGrid();
        addSeed(W / 2, H / 2, 20);
        animate();
    </script>
</body>
</html>
