<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game of Life Challenge - CCAB</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Nunito', sans-serif;
            background: #1a1a2e;
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: #8A9A5B;
            text-decoration: none;
            font-weight: 500;
            padding: 8px 16px;
            background: rgba(0,0,0,0.5);
            border-radius: 20px;
            transition: all 0.3s;
        }
        .back-link:hover {
            background: rgba(138, 154, 91, 0.3);
            transform: translateX(-3px);
        }
        h1 {
            font-family: 'Lora', serif;
            color: #8A9A5B;
            margin: 20px 0;
        }
        .game-container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        canvas {
            border: 2px solid #333;
            border-radius: 10px;
            cursor: crosshair;
        }
        .controls {
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 15px;
            width: 300px;
        }
        .controls h3 {
            font-family: 'Lora', serif;
            color: #8A9A5B;
            margin-bottom: 15px;
        }
        .btn-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .btn {
            background: linear-gradient(135deg, #606C38, #8A9A5B);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: transform 0.2s;
            flex: 1;
            min-width: 80px;
        }
        .btn:hover {
            transform: scale(1.02);
        }
        .btn.secondary {
            background: linear-gradient(135deg, #BC6C25, #DDA15E);
        }
        .patterns {
            margin-top: 15px;
        }
        .patterns h4 {
            color: #8A9A5B;
            margin-bottom: 10px;
        }
        .pattern-btn {
            background: rgba(138, 154, 91, 0.2);
            border: 1px solid #8A9A5B;
            color: #8A9A5B;
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.8rem;
            margin: 3px;
        }
        .pattern-btn:hover {
            background: rgba(138, 154, 91, 0.4);
        }
        .stats {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #444;
        }
        .stats div {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        .stats .label { color: #888; }
        .stats .value { color: #8A9A5B; font-weight: bold; }
        .challenge-status {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #444;
        }
        .challenge-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }
        .challenge-item.completed { color: #4CAF50; }
        .challenge-item.pending { color: #888; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Challenges</a>

    <h1>Game of Life Challenge</h1>

    <div class="game-container">
        <canvas id="canvas"></canvas>

        <div class="controls">
            <h3>Controls</h3>

            <div class="btn-group">
                <button class="btn" id="playBtn" onclick="togglePlay()">‚ñ∂ Play</button>
                <button class="btn" onclick="step()">Step</button>
                <button class="btn secondary" onclick="clearGrid()">Clear</button>
            </div>

            <div class="btn-group">
                <button class="btn" onclick="randomize()">Random</button>
            </div>

            <div class="patterns">
                <h4>Insert Pattern:</h4>
                <button class="pattern-btn" onclick="setPattern('glider')">Glider</button>
                <button class="pattern-btn" onclick="setPattern('blinker')">Blinker</button>
                <button class="pattern-btn" onclick="setPattern('block')">Block</button>
                <button class="pattern-btn" onclick="setPattern('beacon')">Beacon</button>
                <button class="pattern-btn" onclick="setPattern('pulsar')">Pulsar</button>
                <button class="pattern-btn" onclick="setPattern('lwss')">LWSS</button>
                <button class="pattern-btn" onclick="setPattern('gliderGun')">Glider Gun</button>
            </div>

            <div class="stats">
                <div><span class="label">Generation:</span> <span class="value" id="generation">0</span></div>
                <div><span class="label">Population:</span> <span class="value" id="population">0</span></div>
                <div><span class="label">Pattern Type:</span> <span class="value" id="patternType">Unknown</span></div>
            </div>

            <div class="challenge-status">
                <div class="challenge-item pending" id="ch1">‚≠ï Create a glider</div>
                <div class="challenge-item pending" id="ch2">‚≠ï Create a still life (stable 10 gens)</div>
                <div class="challenge-item pending" id="ch3">‚≠ï Create an oscillator</div>
                <div class="challenge-item pending" id="ch4">‚≠ï Create a spaceship (LWSS)</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const CELL_SIZE = 8;
        const COLS = 80;
        const ROWS = 60;

        canvas.width = COLS * CELL_SIZE;
        canvas.height = ROWS * CELL_SIZE;

        let grid = createGrid();
        let isPlaying = false;
        let generation = 0;
        let history = [];
        let completedChallenges = new Set();
        let selectedPattern = null;

        const PATTERNS = {
            glider: [[0,1,0],[0,0,1],[1,1,1]],
            blinker: [[1,1,1]],
            block: [[1,1],[1,1]],
            beacon: [[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]],
            pulsar: [
                [0,0,1,1,1,0,0,0,1,1,1,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [0,0,1,1,1,0,0,0,1,1,1,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,0,0,0,1,1,1,0,0],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,0,1,0,1,0,0,0,0,1],
                [0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,1,1,1,0,0,0,1,1,1,0,0]
            ],
            lwss: [[0,1,0,0,1],[1,0,0,0,0],[1,0,0,0,1],[1,1,1,1,0]],
            gliderGun: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                [1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ]
        };

        function createGrid() {
            return Array(ROWS).fill().map(() => Array(COLS).fill(0));
        }

        function clearGrid() {
            grid = createGrid();
            generation = 0;
            history = [];
            draw();
            updateStats();
        }

        function randomize() {
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    grid[y][x] = Math.random() < 0.3 ? 1 : 0;
                }
            }
            generation = 0;
            history = [];
            draw();
            updateStats();
        }

        function setPattern(name) {
            selectedPattern = name;
            alert(`Click on the grid to place ${name}. Click again to deselect.`);
        }

        function placePattern(cx, cy, pattern) {
            for (let y = 0; y < pattern.length; y++) {
                for (let x = 0; x < pattern[y].length; x++) {
                    let py = cy + y;
                    let px = cx + x;
                    if (py >= 0 && py < ROWS && px >= 0 && px < COLS) {
                        grid[py][px] = pattern[y][x];
                    }
                }
            }
        }

        function countNeighbors(x, y) {
            let count = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    let nx = (x + dx + COLS) % COLS;
                    let ny = (y + dy + ROWS) % ROWS;
                    count += grid[ny][nx];
                }
            }
            return count;
        }

        function step() {
            // Save history for pattern detection
            history.push(JSON.stringify(grid));
            if (history.length > 20) history.shift();

            const newGrid = createGrid();

            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const neighbors = countNeighbors(x, y);
                    if (grid[y][x] === 1) {
                        newGrid[y][x] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
                    } else {
                        newGrid[y][x] = (neighbors === 3) ? 1 : 0;
                    }
                }
            }

            grid = newGrid;
            generation++;
            draw();
            updateStats();
            checkChallenges();
        }

        function togglePlay() {
            isPlaying = !isPlaying;
            document.getElementById('playBtn').textContent = isPlaying ? '‚è∏ Pause' : '‚ñ∂ Play';
            if (isPlaying) gameLoop();
        }

        function gameLoop() {
            if (!isPlaying) return;
            step();
            setTimeout(gameLoop, 100);
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (grid[y][x] === 1) {
                        ctx.fillStyle = '#8A9A5B';
                        ctx.fillRect(x * CELL_SIZE + 1, y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                    }
                }
            }

            // Grid lines
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL_SIZE, 0);
                ctx.lineTo(i * CELL_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * CELL_SIZE);
                ctx.lineTo(canvas.width, i * CELL_SIZE);
                ctx.stroke();
            }
        }

        function updateStats() {
            let pop = 0;
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    pop += grid[y][x];
                }
            }
            document.getElementById('generation').textContent = generation;
            document.getElementById('population').textContent = pop;

            // Detect pattern type
            let patternType = 'Active';
            if (pop === 0) patternType = 'Dead';
            else if (history.length >= 2 && history[history.length - 1] === history[history.length - 2]) {
                patternType = 'Still Life';
            } else if (history.length >= 3) {
                for (let i = 1; i < Math.min(10, history.length); i++) {
                    if (history[history.length - 1] === history[history.length - 1 - i]) {
                        patternType = `Period-${i} Oscillator`;
                        break;
                    }
                }
            }
            document.getElementById('patternType').textContent = patternType;
        }

        function detectGlider() {
            // Simple glider detection - look for 5-cell moving pattern
            const gliderShapes = [
                [[0,1,0],[0,0,1],[1,1,1]],
                [[1,0,0],[1,0,1],[1,1,0]],
                [[1,1,1],[1,0,0],[0,1,0]],
                [[0,1,1],[1,0,1],[0,0,1]]
            ];

            for (let y = 0; y < ROWS - 3; y++) {
                for (let x = 0; x < COLS - 3; x++) {
                    for (let shape of gliderShapes) {
                        let match = true;
                        for (let dy = 0; dy < 3 && match; dy++) {
                            for (let dx = 0; dx < 3 && match; dx++) {
                                if (grid[y + dy][x + dx] !== shape[dy][dx]) match = false;
                            }
                        }
                        if (match) return true;
                    }
                }
            }
            return false;
        }

        function detectLWSS() {
            // Detect lightweight spaceship
            const lwssShapes = [
                [[0,1,0,0,1],[1,0,0,0,0],[1,0,0,0,1],[1,1,1,1,0]],
                [[1,0,0,1,0],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,1]]
            ];

            for (let y = 0; y < ROWS - 4; y++) {
                for (let x = 0; x < COLS - 5; x++) {
                    for (let shape of lwssShapes) {
                        let match = true;
                        for (let dy = 0; dy < shape.length && match; dy++) {
                            for (let dx = 0; dx < shape[0].length && match; dx++) {
                                if (grid[y + dy][x + dx] !== shape[dy][dx]) match = false;
                            }
                        }
                        if (match) return true;
                    }
                }
            }
            return false;
        }

        function checkChallenges() {
            // Challenge 1: Create a glider
            if (!completedChallenges.has('ch1') && detectGlider()) {
                completedChallenges.add('ch1');
                markComplete('ch1', 20);
            }

            // Challenge 2: Still life (stable for 10 generations)
            if (!completedChallenges.has('ch2') && history.length >= 10) {
                let isStill = true;
                for (let i = 1; i < 10; i++) {
                    if (history[history.length - 1] !== history[history.length - 1 - i]) {
                        isStill = false;
                        break;
                    }
                }
                if (isStill && JSON.parse(history[history.length - 1]).flat().some(c => c === 1)) {
                    completedChallenges.add('ch2');
                    markComplete('ch2', 25);
                }
            }

            // Challenge 3: Oscillator
            if (!completedChallenges.has('ch3') && history.length >= 5) {
                for (let period = 2; period <= 5; period++) {
                    if (history.length > period && history[history.length - 1] === history[history.length - 1 - period]) {
                        // Verify it's not still
                        if (history[history.length - 1] !== history[history.length - 2]) {
                            completedChallenges.add('ch3');
                            markComplete('ch3', 35);
                            break;
                        }
                    }
                }
            }

            // Challenge 4: LWSS
            if (!completedChallenges.has('ch4') && detectLWSS()) {
                completedChallenges.add('ch4');
                markComplete('ch4', 75);
            }
        }

        function markComplete(id, xp) {
            const el = document.getElementById(id);
            el.className = 'challenge-item completed';
            el.textContent = '‚úÖ ' + el.textContent.substring(2);
            showNotification(xp);

            try {
                const data = JSON.parse(localStorage.getItem('ccab-challenges')) || { completed: [], xp: 0 };
                if (!data.completed.includes('gol-' + id)) {
                    data.completed.push('gol-' + id);
                    data.xp += xp;
                    localStorage.setItem('ccab-challenges', JSON.stringify(data));
                }
            } catch (e) {}
        }

        function showNotification(xp) {
            const notification = document.createElement('div');
            notification.innerHTML = `<div style="font-size: 2rem;">üèÜ</div><div>Challenge Complete!</div><div>+${xp} XP</div>`;
            notification.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #606C38, #8A9A5B); color: white;
                padding: 2rem 3rem; border-radius: 20px; text-align: center; z-index: 10000;
                animation: popIn 0.5s ease-out;
            `;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 2500);
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / CELL_SIZE);
            const y = Math.floor((e.clientY - rect.top) / CELL_SIZE);

            if (selectedPattern && PATTERNS[selectedPattern]) {
                placePattern(x, y, PATTERNS[selectedPattern]);
                selectedPattern = null;
            } else {
                grid[y][x] = grid[y][x] ? 0 : 1;
            }
            draw();
            updateStats();
        });

        // Expose for enhance.js keyboard shortcuts
        window.reset = function() { randomize(); draw(); };
        window.init = window.reset;

        draw();

        // Add animation keyframes
        const style = document.createElement('style');
        style.textContent = `@keyframes popIn { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 50% { transform: translate(-50%, -50%) scale(1.1); } 100% { transform: translate(-50%, -50%) scale(1); } }`;
        document.head.appendChild(style);
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
