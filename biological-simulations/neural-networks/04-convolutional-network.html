<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convolutional Neural Network</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #000428 0%, #004e92 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="info">
        <h3>Convolutional Neural Network</h3>
        <p>Feature maps extracting patterns</p>
        <p>Convolution → Pooling → Dense</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1200;
        canvas.height = 800;

        const gridSize = 16;
        const cellSize = 20;
        const input = [];
        const filters = []; // Feature maps

        // Initialize input grid
        for (let y = 0; y < gridSize; y++) {
            input[y] = [];
            for (let x = 0; x < gridSize; x++) {
                input[y][x] = Math.random();
            }
        }

        // Create filters
        for (let i = 0; i < 4; i++) {
            const filter = [];
            for (let y = 0; y < gridSize - 2; y++) {
                filter[y] = [];
                for (let x = 0; x < gridSize - 2; x++) {
                    filter[y][x] = 0;
                }
            }
            filters.push(filter);
        }

        let time = 0;

        function convolve() {
            // Simple edge detection and pattern filters
            for (let f = 0; f < filters.length; f++) {
                for (let y = 0; y < gridSize - 2; y++) {
                    for (let x = 0; x < gridSize - 2; x++) {
                        let sum = 0;

                        // Different filter kernels
                        if (f === 0) { // Horizontal edge
                            sum = -input[y][x] + input[y + 2][x];
                        } else if (f === 1) { // Vertical edge
                            sum = -input[y][x] + input[y][x + 2];
                        } else if (f === 2) { // Diagonal
                            sum = input[y][x] + input[y + 2][x + 2] - input[y][x + 2] - input[y + 2][x];
                        } else { // Center detection
                            sum = input[y + 1][x + 1] * 4 - input[y][x] - input[y + 2][x] - input[y][x + 2] - input[y + 2][x + 2];
                        }

                        filters[f][y][x] = Math.max(0, Math.min(1, sum));
                    }
                }
            }
        }

        function animate() {
            ctx.fillStyle = 'rgba(0, 4, 40, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            time += 0.05;

            // Update input with moving pattern
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const val = Math.sin(x * 0.5 + time) * Math.cos(y * 0.5 + time * 0.7);
                    input[y][x] = (val + 1) / 2;
                }
            }

            convolve();

            const startX = 50;
            const startY = 100;

            // Draw input layer
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '14px Arial';
            ctx.fillText('Input Layer', startX, startY - 20);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const brightness = input[y][x];
                    ctx.fillStyle = `rgba(100, 200, 255, ${brightness})`;
                    ctx.fillRect(
                        startX + x * cellSize,
                        startY + y * cellSize,
                        cellSize - 1,
                        cellSize - 1
                    );
                }
            }

            // Draw feature maps
            const featureX = startX + gridSize * cellSize + 100;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillText('Feature Maps (Conv)', featureX, startY - 20);

            for (let f = 0; f < filters.length; f++) {
                const filterY = startY + f * (gridSize - 2) * (cellSize * 0.8) + f * 20;

                for (let y = 0; y < gridSize - 2; y++) {
                    for (let x = 0; x < gridSize - 2; x++) {
                        const brightness = filters[f][y][x];
                        const hue = f * 90;
                        ctx.fillStyle = `hsla(${hue}, 80%, 60%, ${brightness})`;
                        ctx.fillRect(
                            featureX + x * cellSize * 0.8,
                            filterY + y * cellSize * 0.8,
                            cellSize * 0.8 - 1,
                            cellSize * 0.8 - 1
                        );
                    }
                }

                // Filter label
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '10px Arial';
                const labels = ['H-Edge', 'V-Edge', 'Diagonal', 'Center'];
                ctx.fillText(labels[f], featureX - 45, filterY + 50);
            }

            // Draw pooling/dense representation
            const poolX = featureX + gridSize * cellSize + 80;
            const poolY = canvas.height / 2 - 100;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillText('Pooled Features', poolX, poolY - 20);

            for (let f = 0; f < filters.length; f++) {
                let maxActivation = 0;
                for (let y = 0; y < filters[f].length; y++) {
                    for (let x = 0; x < filters[f][y].length; x++) {
                        maxActivation = Math.max(maxActivation, filters[f][y][x]);
                    }
                }

                const hue = f * 90;
                ctx.shadowBlur = 15 * maxActivation;
                ctx.shadowColor = `hsl(${hue}, 80%, 60%)`;
                ctx.fillStyle = `hsla(${hue}, 80%, 60%, ${0.3 + maxActivation * 0.7})`;
                ctx.beginPath();
                ctx.arc(poolX + 30, poolY + f * 50, 20, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.shadowBlur = 0;

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
