<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feedforward Neural Network</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="info">
        <h3>Feedforward Neural Network</h3>
        <p>Signals propagate from input to output</p>
        <p>Click to send a pulse!</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1200;
        canvas.height = 800;

        const layers = [4, 6, 6, 3];
        const neurons = [];
        const connections = [];
        let pulses = [];

        const layerSpacing = canvas.width / (layers.length + 1);

        // Create neurons
        for (let l = 0; l < layers.length; l++) {
            const layerNeurons = [];
            const neuronCount = layers[l];
            const neuronSpacing = canvas.height / (neuronCount + 1);

            for (let n = 0; n < neuronCount; n++) {
                layerNeurons.push({
                    x: layerSpacing * (l + 1),
                    y: neuronSpacing * (n + 1),
                    activation: 0,
                    layer: l
                });
            }
            neurons.push(layerNeurons);
        }

        // Create connections
        for (let l = 0; l < layers.length - 1; l++) {
            for (let i = 0; i < neurons[l].length; i++) {
                for (let j = 0; j < neurons[l + 1].length; j++) {
                    connections.push({
                        from: neurons[l][i],
                        to: neurons[l + 1][j],
                        weight: Math.random() * 2 - 1,
                        signal: 0
                    });
                }
            }
        }

        canvas.addEventListener('click', () => {
            // Activate input neurons
            neurons[0].forEach(n => {
                n.activation = Math.random();
                pulses.push({
                    neuron: n,
                    time: 0,
                    maxTime: 30
                });
            });
        });

        function animate() {
            ctx.fillStyle = 'rgba(15, 12, 41, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update pulses
            for (let i = pulses.length - 1; i >= 0; i--) {
                pulses[i].time++;
                if (pulses[i].time >= pulses[i].maxTime) {
                    const layer = pulses[i].neuron.layer;
                    if (layer < layers.length - 1) {
                        // Propagate to next layer
                        neurons[layer + 1].forEach(nextNeuron => {
                            const activation = Math.random() * pulses[i].neuron.activation;
                            nextNeuron.activation = Math.max(nextNeuron.activation, activation);
                            pulses.push({
                                neuron: nextNeuron,
                                time: 0,
                                maxTime: 30
                            });
                        });
                    }
                    pulses.splice(i, 1);
                } else {
                    pulses[i].neuron.activation *= 0.95;
                }
            }

            // Draw connections
            for (let conn of connections) {
                const alpha = Math.abs(conn.weight) * 0.3;
                const color = conn.weight > 0 ? `rgba(0, 200, 255, ${alpha})` : `rgba(255, 100, 100, ${alpha})`;

                ctx.strokeStyle = color;
                ctx.lineWidth = Math.abs(conn.weight) * 2;
                ctx.beginPath();
                ctx.moveTo(conn.from.x, conn.from.y);
                ctx.lineTo(conn.to.x, conn.to.y);
                ctx.stroke();

                // Signal flow
                if (conn.from.activation > 0.1) {
                    const signalX = conn.from.x + (conn.to.x - conn.from.x) * 0.5;
                    const signalY = conn.from.y + (conn.to.y - conn.from.y) * 0.5;
                    ctx.fillStyle = 'rgba(255, 255, 100, 0.8)';
                    ctx.beginPath();
                    ctx.arc(signalX, signalY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw neurons
            for (let layer of neurons) {
                for (let neuron of layer) {
                    // Glow
                    if (neuron.activation > 0.1) {
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = `rgba(100, 200, 255, ${neuron.activation})`;
                    } else {
                        ctx.shadowBlur = 0;
                    }

                    ctx.fillStyle = `rgba(100, 200, 255, ${0.3 + neuron.activation * 0.7})`;
                    ctx.beginPath();
                    ctx.arc(neuron.x, neuron.y, 15, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    neuron.activation *= 0.98;
                }
            }

            ctx.shadowBlur = 0;

            requestAnimationFrame(animate);
        }

        // Initial pulse
        setTimeout(() => {
            canvas.click();
        }, 500);

        animate();
    </script>
</body>
</html>
