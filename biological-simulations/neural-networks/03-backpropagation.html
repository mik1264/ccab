<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backpropagation Visualization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="info">
        <h3>Backpropagation</h3>
        <p><span style="color: #4CAF50;">Green</span>: Forward pass</p>
        <p><span style="color: #FF5722;">Red</span>: Backward pass (gradient)</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1200;
        canvas.height = 800;

        const layers = [3, 5, 5, 2];
        const neurons = [];
        const connections = [];

        const layerSpacing = canvas.width / (layers.length + 1);

        // Create neurons
        for (let l = 0; l < layers.length; l++) {
            const layerNeurons = [];
            const neuronCount = layers[l];
            const neuronSpacing = canvas.height / (neuronCount + 1);

            for (let n = 0; n < neuronCount; n++) {
                layerNeurons.push({
                    x: layerSpacing * (l + 1),
                    y: neuronSpacing * (n + 1),
                    activation: 0,
                    gradient: 0,
                    layer: l
                });
            }
            neurons.push(layerNeurons);
        }

        // Create connections
        for (let l = 0; l < layers.length - 1; l++) {
            for (let i = 0; i < neurons[l].length; i++) {
                for (let j = 0; j < neurons[l + 1].length; j++) {
                    connections.push({
                        from: neurons[l][i],
                        to: neurons[l + 1][j],
                        weight: Math.random() * 2 - 1,
                        gradient: 0
                    });
                }
            }
        }

        let phase = 'forward'; // 'forward' or 'backward'
        let phaseTime = 0;

        function animate() {
            ctx.fillStyle = 'rgba(26, 26, 46, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            phaseTime++;

            if (phase === 'forward') {
                if (phaseTime === 1) {
                    // Activate input neurons
                    neurons[0].forEach(n => {
                        n.activation = Math.random();
                    });
                }

                // Propagate forward
                if (phaseTime % 20 === 0) {
                    for (let l = 0; l < layers.length - 1; l++) {
                        neurons[l + 1].forEach(neuron => {
                            let sum = 0;
                            connections.forEach(conn => {
                                if (conn.to === neuron) {
                                    sum += conn.from.activation * conn.weight;
                                }
                            });
                            neuron.activation = 1 / (1 + Math.exp(-sum)); // Sigmoid
                        });
                    }
                }

                if (phaseTime > 100) {
                    phase = 'backward';
                    phaseTime = 0;
                    // Compute output error
                    neurons[neurons.length - 1].forEach(n => {
                        n.gradient = Math.random();
                    });
                }
            } else {
                // Backpropagate gradients
                if (phaseTime % 20 === 0) {
                    for (let l = layers.length - 2; l >= 0; l--) {
                        neurons[l].forEach(neuron => {
                            let sum = 0;
                            connections.forEach(conn => {
                                if (conn.from === neuron) {
                                    sum += conn.to.gradient * conn.weight;
                                }
                            });
                            neuron.gradient = sum * neuron.activation * (1 - neuron.activation);
                        });
                    }
                }

                if (phaseTime > 100) {
                    phase = 'forward';
                    phaseTime = 0;
                    // Reset
                    neurons.forEach(layer => layer.forEach(n => {
                        n.activation = 0;
                        n.gradient = 0;
                    }));
                }
            }

            // Draw connections
            connections.forEach(conn => {
                if (phase === 'forward') {
                    const alpha = conn.from.activation * 0.5;
                    ctx.strokeStyle = `rgba(76, 175, 80, ${alpha})`;
                } else {
                    const alpha = Math.abs(conn.to.gradient) * 0.5;
                    ctx.strokeStyle = `rgba(255, 87, 34, ${alpha})`;
                }
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(conn.from.x, conn.from.y);
                ctx.lineTo(conn.to.x, conn.to.y);
                ctx.stroke();
            });

            // Draw neurons
            neurons.forEach(layer => {
                layer.forEach(neuron => {
                    const value = phase === 'forward' ? neuron.activation : Math.abs(neuron.gradient);
                    const color = phase === 'forward' ? '76, 175, 80' : '255, 87, 34';

                    ctx.shadowBlur = 15 * value;
                    ctx.shadowColor = `rgba(${color}, ${value})`;

                    ctx.fillStyle = `rgba(${color}, ${0.3 + value * 0.7})`;
                    ctx.beginPath();
                    ctx.arc(neuron.x, neuron.y, 18, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            });

            ctx.shadowBlur = 0;

            // Phase label
            ctx.fillStyle = phase === 'forward' ? '#4CAF50' : '#FF5722';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(phase.toUpperCase() + ' PASS', canvas.width / 2, 50);

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
