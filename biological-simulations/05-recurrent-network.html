<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recurrent Neural Network</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #2C3E50 0%, #4CA1AF 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="info">
        <h3>Recurrent Neural Network (RNN)</h3>
        <p>Neurons feed back into themselves</p>
        <p>Memory through time</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1200;
        canvas.height = 800;

        const timeSteps = 6;
        const hiddenSize = 5;
        const neurons = [];

        // Create unrolled RNN through time
        for (let t = 0; t < timeSteps; t++) {
            const stepNeurons = {
                input: {
                    x: 150 + t * 180,
                    y: 600,
                    activation: 0
                },
                hidden: [],
                output: {
                    x: 150 + t * 180,
                    y: 150,
                    activation: 0
                }
            };

            for (let h = 0; h < hiddenSize; h++) {
                stepNeurons.hidden.push({
                    x: 150 + t * 180,
                    y: 250 + h * 70,
                    activation: 0,
                    memory: 0
                });
            }

            neurons.push(stepNeurons);
        }

        let time = 0;
        const sequence = [];

        function animate() {
            ctx.fillStyle = 'rgba(44, 62, 80, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            time += 0.05;

            // Generate input sequence
            neurons.forEach((step, t) => {
                step.input.activation = Math.sin(time + t * 0.5) * 0.5 + 0.5;
            });

            // Update hidden states
            for (let t = 0; t < timeSteps; t++) {
                neurons[t].hidden.forEach((h, i) => {
                    let sum = neurons[t].input.activation * 0.5;

                    // Recurrent connection from previous timestep
                    if (t > 0) {
                        sum += neurons[t - 1].hidden[i].activation * 0.7;
                    }

                    // Connections from other hidden units
                    neurons[t].hidden.forEach((other, j) => {
                        if (i !== j && t > 0) {
                            sum += neurons[t - 1].hidden[j].activation * 0.2;
                        }
                    });

                    h.activation = 1 / (1 + Math.exp(-sum)); // Sigmoid
                });

                // Output
                let outSum = 0;
                neurons[t].hidden.forEach(h => {
                    outSum += h.activation;
                });
                neurons[t].output.activation = outSum / hiddenSize;
            }

            // Draw connections
            for (let t = 0; t < timeSteps; t++) {
                // Input to hidden
                neurons[t].hidden.forEach(h => {
                    ctx.strokeStyle = `rgba(100, 200, 100, ${neurons[t].input.activation * 0.5})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(neurons[t].input.x, neurons[t].input.y);
                    ctx.lineTo(h.x, h.y);
                    ctx.stroke();
                });

                // Hidden to output
                neurons[t].hidden.forEach(h => {
                    ctx.strokeStyle = `rgba(100, 100, 200, ${h.activation * 0.5})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(h.x, h.y);
                    ctx.lineTo(neurons[t].output.x, neurons[t].output.y);
                    ctx.stroke();
                });

                // Recurrent connections
                if (t < timeSteps - 1) {
                    neurons[t].hidden.forEach((h, i) => {
                        ctx.strokeStyle = `rgba(255, 150, 50, ${h.activation * 0.4})`;
                        ctx.lineWidth = 3;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(h.x, h.y);
                        ctx.lineTo(neurons[t + 1].hidden[i].x, neurons[t + 1].hidden[i].y);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    });
                }

                // Self-loops (memory)
                neurons[t].hidden.forEach(h => {
                    ctx.strokeStyle = `rgba(255, 100, 255, ${h.activation * 0.3})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(h.x + 25, h.y, 20, 0, Math.PI * 2);
                    ctx.stroke();

                    // Arrow
                    ctx.fillStyle = `rgba(255, 100, 255, ${h.activation})`;
                    ctx.beginPath();
                    ctx.moveTo(h.x + 25, h.y - 20);
                    ctx.lineTo(h.x + 30, h.y - 15);
                    ctx.lineTo(h.x + 20, h.y - 15);
                    ctx.fill();
                });
            }

            // Draw neurons
            for (let t = 0; t < timeSteps; t++) {
                // Input
                ctx.fillStyle = `rgba(100, 200, 100, ${0.3 + neurons[t].input.activation * 0.7})`;
                ctx.beginPath();
                ctx.arc(neurons[t].input.x, neurons[t].input.y, 15, 0, Math.PI * 2);
                ctx.fill();

                // Hidden
                neurons[t].hidden.forEach(h => {
                    ctx.shadowBlur = 15 * h.activation;
                    ctx.shadowColor = `rgba(255, 200, 100, ${h.activation})`;
                    ctx.fillStyle = `rgba(255, 200, 100, ${0.3 + h.activation * 0.7})`;
                    ctx.beginPath();
                    ctx.arc(h.x, h.y, 12, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Output
                ctx.shadowBlur = 15 * neurons[t].output.activation;
                ctx.shadowColor = `rgba(100, 100, 255, ${neurons[t].output.activation})`;
                ctx.fillStyle = `rgba(100, 100, 255, ${0.3 + neurons[t].output.activation * 0.7})`;
                ctx.beginPath();
                ctx.arc(neurons[t].output.x, neurons[t].output.y, 15, 0, Math.PI * 2);
                ctx.fill();

                // Timestep label
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`t=${t}`, neurons[t].input.x, neurons[t].input.y + 35);
            }

            ctx.shadowBlur = 0;

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
