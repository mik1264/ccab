<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red Queen Hypothesis - Coevolutionary Arms Race</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a0a0a 0%, #2d1515 100%);
            font-family: 'Segoe UI', Arial, sans-serif;
            color: white;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 20px;
        }
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
        }
        .controls {
            width: 380px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.6);
            overflow-y: auto;
        }
        h2 { margin: 0 0 10px 0; color: #ff4757; }
        h3 { margin: 15px 0 8px 0; color: #ffa502; font-size: 14px; }
        .quote {
            font-style: italic;
            color: #ff6b81;
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 12px;
        }
        .slider-group { margin: 10px 0; }
        .slider-group label { display: block; margin-bottom: 5px; font-size: 12px; }
        input[type="range"] { width: 100%; }
        .species-stats {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }
        .species-box {
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }
        .predator-box { background: rgba(255, 71, 87, 0.3); border: 2px solid #ff4757; }
        .prey-box { background: rgba(46, 213, 115, 0.3); border: 2px solid #2ed573; }
        .stat { margin: 5px 0; font-size: 13px; }
        .description {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.5;
            margin-top: 15px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: #ff4757;
            color: white;
            font-weight: bold;
        }
        button:hover { background: #ff6b81; }
    </style>
</head>
<body>
    <a href="../index.html" class="organic-back-link" style="position: fixed; top: 20px; right: 20px; z-index: 1000; display: flex; align-items: center; gap: 8px; padding: 10px 16px; background: rgba(255,255,255,0.9); backdrop-filter: blur(10px); border-radius: 30px; text-decoration: none; color: #606C38; font-family: 'Nunito', sans-serif; font-weight: 600; box-shadow: 0 2px 10px rgba(0,0,0,0.1); transition: all 0.3s ease;">
        <span class="back-arrow">‚Üê</span>
        <span class="back-text">Gallery</span>
    </a>
    <div class="container">
        <div class="canvas-area">
            <canvas id="arenaCanvas"></canvas>
            <canvas id="graphCanvas"></canvas>
        </div>
        <div class="controls">
            <h2>‚ôõ Red Queen Hypothesis</h2>
            <div class="quote">
                "It takes all the running you can do, to keep in the same place."<br>
                ‚Äî Lewis Carroll, Through the Looking-Glass
            </div>

            <h3>Simulation Parameters</h3>
            <div class="slider-group">
                <label>Mutation Rate: <span id="mutationVal">5%</span></label>
                <input type="range" id="mutationRate" min="1" max="20" step="1" value="5">
            </div>
            <div class="slider-group">
                <label>Evolution Speed: <span id="evolSpeedVal">1x</span></label>
                <input type="range" id="evolSpeed" min="1" max="5" step="1" value="1">
            </div>

            <div class="species-stats">
                <div class="species-box predator-box">
                    <strong>ü¶ä Predators</strong>
                    <div class="stat">Population: <span id="predatorPop">0</span></div>
                    <div class="stat">Speed: <span id="predatorSpeed">0</span></div>
                    <div class="stat">Catches: <span id="predatorCatches">0</span></div>
                </div>
                <div class="species-box prey-box">
                    <strong>üê∞ Prey</strong>
                    <div class="stat">Population: <span id="preyPop">0</span></div>
                    <div class="stat">Speed: <span id="preySpeed">0</span></div>
                    <div class="stat">Escapes: <span id="preyEscapes">0</span></div>
                </div>
            </div>

            <button onclick="resetSimulation()">Reset</button>
            <button onclick="togglePause()">Pause/Play</button>

            <h3>Coevolution Stats</h3>
            <div class="stat">Generation: <span id="generation">0</span></div>
            <div class="stat">Arms Race Level: <span id="armsRace">1</span></div>
            <div class="stat">Adaptation Cycles: <span id="cycles">0</span></div>

            <div class="description">
                <strong>Red Queen Hypothesis:</strong><br><br>
                Named after the Red Queen's race in "Through the Looking-Glass", this hypothesis explains why organisms must constantly evolve just to maintain their fitness relative to competing species.<br><br>
                <strong>Watch:</strong>
                <ul style="margin: 5px 0; padding-left: 20px;">
                    <li>Predators evolve faster speed to catch prey</li>
                    <li>Prey evolve faster speed to escape</li>
                    <li>Neither gains permanent advantage</li>
                    <li>Both keep evolving - "running to stay in place"</li>
                </ul>
                The arms race continues indefinitely!
            </div>
        </div>
    </div>

    <script>
        const arenaCanvas = document.getElementById('arenaCanvas');
        const arenaCtx = arenaCanvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');

        arenaCanvas.width = 700;
        arenaCanvas.height = 400;
        graphCanvas.width = 700;
        graphCanvas.height = 180;

        let predators = [];
        let prey = [];
        let generation = 0;
        let paused = false;
        let mutationRate = 0.05;
        let evolSpeed = 1;

        let stats = {
            predatorCatches: 0,
            preyEscapes: 0,
            cycles: 0
        };

        let history = {
            predatorSpeed: [],
            preySpeed: [],
            predatorPop: [],
            preyPop: []
        };

        class Agent {
            constructor(x, y, speed, isPredator) {
                this.x = x;
                this.y = y;
                this.speed = speed;
                this.isPredator = isPredator;
                this.angle = Math.random() * Math.PI * 2;
                this.energy = isPredator ? 100 : 50;
                this.age = 0;
            }

            update(targets) {
                this.age++;

                if (this.isPredator) {
                    // Predator: chase nearest prey
                    this.energy -= 0.3 + this.speed * 0.02; // Faster = more energy cost

                    if (targets.length > 0) {
                        let nearest = null;
                        let minDist = Infinity;

                        targets.forEach(t => {
                            const dist = Math.hypot(t.x - this.x, t.y - this.y);
                            if (dist < minDist) {
                                minDist = dist;
                                nearest = t;
                            }
                        });

                        if (nearest && minDist < 300) {
                            this.angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                        }
                    }
                } else {
                    // Prey: flee from nearest predator
                    this.energy += 0.1; // Prey gain energy by eating grass

                    if (targets.length > 0) {
                        let nearest = null;
                        let minDist = Infinity;

                        targets.forEach(t => {
                            const dist = Math.hypot(t.x - this.x, t.y - this.y);
                            if (dist < minDist) {
                                minDist = dist;
                                nearest = t;
                            }
                        });

                        if (nearest && minDist < 150) {
                            // Flee
                            this.angle = Math.atan2(this.y - nearest.y, this.x - nearest.x);
                            this.energy -= this.speed * 0.03; // Running costs energy
                        } else {
                            // Wander
                            this.angle += (Math.random() - 0.5) * 0.3;
                        }
                    }
                }

                // Move
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;

                // Bounce off walls
                if (this.x < 10 || this.x > arenaCanvas.width - 10) {
                    this.angle = Math.PI - this.angle;
                    this.x = Math.max(10, Math.min(arenaCanvas.width - 10, this.x));
                }
                if (this.y < 10 || this.y > arenaCanvas.height - 10) {
                    this.angle = -this.angle;
                    this.y = Math.max(10, Math.min(arenaCanvas.height - 10, this.y));
                }

                this.energy = Math.min(150, this.energy);
            }

            draw() {
                const size = this.isPredator ? 8 : 6;
                const color = this.isPredator ? '#ff4757' : '#2ed573';
                const speedIndicator = Math.min(1, this.speed / 5);

                arenaCtx.save();
                arenaCtx.translate(this.x, this.y);
                arenaCtx.rotate(this.angle);

                // Body
                arenaCtx.beginPath();
                arenaCtx.ellipse(0, 0, size, size * 0.6, 0, 0, Math.PI * 2);
                arenaCtx.fillStyle = color;
                arenaCtx.fill();

                // Speed indicator (tail length)
                arenaCtx.beginPath();
                arenaCtx.moveTo(-size, 0);
                arenaCtx.lineTo(-size - speedIndicator * 10, 0);
                arenaCtx.strokeStyle = color;
                arenaCtx.lineWidth = 2;
                arenaCtx.stroke();

                arenaCtx.restore();
            }

            reproduce(mutationRate) {
                const childSpeed = this.speed + (Math.random() - 0.5) * mutationRate * 2;
                return new Agent(
                    this.x + (Math.random() - 0.5) * 30,
                    this.y + (Math.random() - 0.5) * 30,
                    Math.max(0.5, Math.min(8, childSpeed)),
                    this.isPredator
                );
            }
        }

        function initSimulation() {
            predators = [];
            prey = [];

            // Create initial populations
            for (let i = 0; i < 15; i++) {
                predators.push(new Agent(
                    Math.random() * arenaCanvas.width,
                    Math.random() * arenaCanvas.height,
                    1.5 + Math.random() * 0.5,
                    true
                ));
            }

            for (let i = 0; i < 40; i++) {
                prey.push(new Agent(
                    Math.random() * arenaCanvas.width,
                    Math.random() * arenaCanvas.height,
                    1.5 + Math.random() * 0.5,
                    false
                ));
            }

            generation = 0;
            stats = { predatorCatches: 0, preyEscapes: 0, cycles: 0 };
            history = { predatorSpeed: [], preySpeed: [], predatorPop: [], preyPop: [] };
        }

        function simulateStep() {
            if (paused) return;

            for (let step = 0; step < evolSpeed; step++) {
                // Update all agents
                predators.forEach(p => p.update(prey));
                prey.forEach(p => p.update(predators));

                // Check for catches
                predators.forEach(pred => {
                    prey = prey.filter(p => {
                        const dist = Math.hypot(pred.x - p.x, pred.y - p.y);
                        if (dist < 12) {
                            pred.energy += 40;
                            stats.predatorCatches++;
                            return false;
                        }
                        if (dist < 30 && p.speed > pred.speed) {
                            stats.preyEscapes++;
                        }
                        return true;
                    });
                });

                // Remove dead agents
                predators = predators.filter(p => p.energy > 0);
                prey = prey.filter(p => p.energy > 0 && p.age < 500);

                // Reproduction
                const newPredators = [];
                predators.forEach(p => {
                    if (p.energy > 100 && predators.length < 30) {
                        p.energy -= 50;
                        newPredators.push(p.reproduce(mutationRate));
                    }
                });
                predators.push(...newPredators);

                const newPrey = [];
                prey.forEach(p => {
                    if (p.energy > 80 && prey.length < 60) {
                        p.energy -= 30;
                        newPrey.push(p.reproduce(mutationRate));
                    }
                });
                prey.push(...newPrey);

                // Maintain minimum populations
                while (prey.length < 20) {
                    const avgSpeed = prey.length > 0 ?
                        prey.reduce((s, p) => s + p.speed, 0) / prey.length : 2;
                    prey.push(new Agent(
                        Math.random() * arenaCanvas.width,
                        Math.random() * arenaCanvas.height,
                        avgSpeed + (Math.random() - 0.5) * 0.5,
                        false
                    ));
                }

                while (predators.length < 5) {
                    const avgSpeed = predators.length > 0 ?
                        predators.reduce((s, p) => s + p.speed, 0) / predators.length : 2;
                    predators.push(new Agent(
                        Math.random() * arenaCanvas.width,
                        Math.random() * arenaCanvas.height,
                        avgSpeed + (Math.random() - 0.5) * 0.5,
                        true
                    ));
                }
            }

            generation++;

            // Record history
            const avgPredSpeed = predators.reduce((s, p) => s + p.speed, 0) / predators.length;
            const avgPreySpeed = prey.reduce((s, p) => s + p.speed, 0) / prey.length;

            history.predatorSpeed.push(avgPredSpeed);
            history.preySpeed.push(avgPreySpeed);
            history.predatorPop.push(predators.length);
            history.preyPop.push(prey.length);

            // Detect cycles
            if (history.predatorSpeed.length > 100) {
                const recent = history.predatorSpeed.slice(-50);
                const earlier = history.predatorSpeed.slice(-100, -50);
                const recentAvg = recent.reduce((a, b) => a + b, 0) / 50;
                const earlierAvg = earlier.reduce((a, b) => a + b, 0) / 50;

                if (Math.abs(recentAvg - earlierAvg) > 0.3) {
                    stats.cycles++;
                }
            }

            updateStats();
        }

        function updateStats() {
            document.getElementById('generation').textContent = generation;
            document.getElementById('predatorPop').textContent = predators.length;
            document.getElementById('preyPop').textContent = prey.length;

            const avgPredSpeed = predators.length > 0 ?
                (predators.reduce((s, p) => s + p.speed, 0) / predators.length).toFixed(2) : 0;
            const avgPreySpeed = prey.length > 0 ?
                (prey.reduce((s, p) => s + p.speed, 0) / prey.length).toFixed(2) : 0;

            document.getElementById('predatorSpeed').textContent = avgPredSpeed;
            document.getElementById('preySpeed').textContent = avgPreySpeed;
            document.getElementById('predatorCatches').textContent = stats.predatorCatches;
            document.getElementById('preyEscapes').textContent = stats.preyEscapes;

            const armsRaceLevel = Math.max(avgPredSpeed, avgPreySpeed);
            document.getElementById('armsRace').textContent = armsRaceLevel.toFixed(1);
            document.getElementById('cycles').textContent = Math.floor(generation / 100);
        }

        function draw() {
            // Clear arena
            arenaCtx.fillStyle = 'rgba(26, 10, 10, 0.3)';
            arenaCtx.fillRect(0, 0, arenaCanvas.width, arenaCanvas.height);

            // Draw all agents
            prey.forEach(p => p.draw());
            predators.forEach(p => p.draw());

            // Draw graph
            graphCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            graphCtx.fillRect(0, 0, graphCanvas.width, graphCanvas.height);

            if (history.predatorSpeed.length < 2) return;

            const maxPoints = 500;
            const startIdx = Math.max(0, history.predatorSpeed.length - maxPoints);

            // Draw speed evolution
            [{ data: history.predatorSpeed, color: '#ff4757' },
             { data: history.preySpeed, color: '#2ed573' }].forEach(series => {
                graphCtx.strokeStyle = series.color;
                graphCtx.lineWidth = 2;
                graphCtx.beginPath();

                for (let i = startIdx; i < series.data.length; i++) {
                    const x = ((i - startIdx) / maxPoints) * graphCanvas.width;
                    const y = graphCanvas.height - (series.data[i] / 8) * graphCanvas.height;

                    if (i === startIdx) graphCtx.moveTo(x, y);
                    else graphCtx.lineTo(x, y);
                }
                graphCtx.stroke();
            });

            // Legend
            graphCtx.fillStyle = '#ff4757';
            graphCtx.fillText('Predator Speed', 10, 15);
            graphCtx.fillStyle = '#2ed573';
            graphCtx.fillText('Prey Speed', 120, 15);
        }

        function resetSimulation() {
            mutationRate = parseInt(document.getElementById('mutationRate').value) / 100;
            evolSpeed = parseInt(document.getElementById('evolSpeed').value);
            initSimulation();
        }

        function togglePause() {
            paused = !paused;
        }

        // Event listeners
        document.getElementById('mutationRate').oninput = function() {
            mutationRate = parseInt(this.value) / 100;
            document.getElementById('mutationVal').textContent = this.value + '%';
        };

        document.getElementById('evolSpeed').oninput = function() {
            evolSpeed = parseInt(this.value);
            document.getElementById('evolSpeedVal').textContent = this.value + 'x';
        };

        initSimulation();

        function animate() {
            draw();
            simulateStep();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
