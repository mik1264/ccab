<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Selkov Glycolysis Oscillator - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        header { text-align: center; padding: 20px; margin-bottom: 20px; }
        h1 {
            font-size: 2.2rem;
            background: linear-gradient(90deg, #e74c3c, #f39c12);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { color: #888; }
        .back-link { position: absolute; top: 20px; left: 20px; color: #e74c3c; text-decoration: none; }
        .main-content { display: grid; grid-template-columns: 1fr 1fr 350px; gap: 20px; }
        .canvas-container { background: rgba(255,255,255,0.05); border-radius: 16px; padding: 20px; }
        canvas { display: block; margin: 0 auto; background: #0a0a1a; border-radius: 8px; }
        .controls { display: flex; flex-direction: column; gap: 15px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 15px; }
        .panel h3 { color: #e74c3c; font-size: 1rem; margin-bottom: 10px; border-bottom: 1px solid rgba(231,76,60,0.3); padding-bottom: 5px; }
        button {
            padding: 10px 15px; background: rgba(231,76,60,0.2);
            border: 1px solid rgba(231,76,60,0.5); border-radius: 6px;
            color: #e74c3c; cursor: pointer; width: 100%; margin-bottom: 8px;
        }
        button:hover { background: rgba(231,76,60,0.3); }
        .control-group { margin-bottom: 12px; }
        .control-group label { display: block; color: #e74c3c; font-size: 0.85rem; margin-bottom: 5px; }
        input[type="range"] {
            width: 100%; height: 6px; -webkit-appearance: none;
            background: rgba(231,76,60,0.2); border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px;
            background: #e74c3c; border-radius: 50%; cursor: pointer;
        }
        .stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
        .stat { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px; text-align: center; }
        .stat-value { font-size: 1rem; color: #e74c3c; font-weight: bold; }
        .stat-label { font-size: 0.7rem; color: #888; }
        .info-text { font-size: 0.85rem; color: #aaa; line-height: 1.6; }
        .equation { font-family: 'Times New Roman', serif; font-size: 1rem; text-align: center; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 6px; margin: 10px 0; }
        .legend { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; }
        .legend-item { display: flex; align-items: center; gap: 5px; font-size: 0.8rem; }
        .legend-color { width: 12px; height: 12px; border-radius: 50%; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>Selkov Glycolysis Oscillator</h1>
            <p class="subtitle">Limit cycles from autocatalytic biochemical reactions</p>
        </header>
        <div class="main-content">
            <div class="canvas-container">
                <h4 style="text-align: center; color: #888; margin-bottom: 10px;">Phase Portrait</h4>
                <canvas id="phase-canvas" width="400" height="400"></canvas>
            </div>
            <div class="canvas-container">
                <h4 style="text-align: center; color: #888; margin-bottom: 10px;">Time Series</h4>
                <canvas id="time-canvas" width="400" height="400"></canvas>
            </div>
            <div class="controls">
                <div class="panel">
                    <h3>Parameters</h3>
                    <div class="control-group">
                        <label>a (substrate input): <span id="a-val">0.08</span></label>
                        <input type="range" id="param-a" min="0.01" max="0.2" step="0.005" value="0.08">
                    </div>
                    <div class="control-group">
                        <label>b (rate constant): <span id="b-val">0.6</span></label>
                        <input type="range" id="param-b" min="0.3" max="1.2" step="0.02" value="0.6">
                    </div>
                    <div class="equation">
                        dx/dt = -x + ay + x²y<br>
                        dy/dt = b - ay - x²y
                    </div>
                </div>
                <div class="panel">
                    <h3>Initial Conditions</h3>
                    <div class="control-group">
                        <label>x₀: <span id="x0-val">0.5</span></label>
                        <input type="range" id="x0" min="0.1" max="2" step="0.05" value="0.5">
                    </div>
                    <div class="control-group">
                        <label>y₀: <span id="y0-val">0.5</span></label>
                        <input type="range" id="y0" min="0.1" max="2" step="0.05" value="0.5">
                    </div>
                    <button onclick="simulate()">Restart Simulation</button>
                    <button onclick="toggleAnimation()">Play/Pause</button>
                </div>
                <div class="panel">
                    <h3>Visualization</h3>
                    <button onclick="clearTrajectory()">Clear Trajectory</button>
                    <button onclick="drawNullclines()">Show Nullclines</button>
                    <button onclick="bifurcationSweep()">Parameter Sweep</button>
                </div>
                <div class="panel">
                    <h3>Statistics</h3>
                    <div class="stats">
                        <div class="stat">
                            <div class="stat-value" id="current-x">0</div>
                            <div class="stat-label">x (ATP)</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="current-y">0</div>
                            <div class="stat-label">y (ADP)</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="period">-</div>
                            <div class="stat-label">Period (est.)</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="stability">-</div>
                            <div class="stat-label">Fixed Point</div>
                        </div>
                    </div>
                </div>
                <div class="panel">
                    <h3>Legend</h3>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-color" style="background: #e74c3c;"></div>x (Substrate)</div>
                        <div class="legend-item"><div class="legend-color" style="background: #3498db;"></div>y (Product)</div>
                        <div class="legend-item"><div class="legend-color" style="background: #2ecc71;"></div>x-Nullcline</div>
                        <div class="legend-item"><div class="legend-color" style="background: #f39c12;"></div>y-Nullcline</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        const phaseCanvas = document.getElementById('phase-canvas');
        const phaseCtx = phaseCanvas.getContext('2d');
        const timeCanvas = document.getElementById('time-canvas');
        const timeCtx = timeCanvas.getContext('2d');

        let a = 0.08;
        let b = 0.6;
        let x = 0.5, y = 0.5;
        let trajectory = [];
        let timeHistory = [];
        let time = 0;
        let animating = true;
        let animationId = null;
        let showNullclines = false;

        function dx(x, y) {
            return -x + a * y + x * x * y;
        }

        function dy(x, y) {
            return b - a * y - x * x * y;
        }

        function rk4Step(x, y, dt) {
            const k1x = dx(x, y);
            const k1y = dy(x, y);
            const k2x = dx(x + 0.5 * dt * k1x, y + 0.5 * dt * k1y);
            const k2y = dy(x + 0.5 * dt * k1x, y + 0.5 * dt * k1y);
            const k3x = dx(x + 0.5 * dt * k2x, y + 0.5 * dt * k2y);
            const k3y = dy(x + 0.5 * dt * k2x, y + 0.5 * dt * k2y);
            const k4x = dx(x + dt * k3x, y + dt * k3y);
            const k4y = dy(x + dt * k3x, y + dt * k3y);

            return {
                x: x + (dt / 6) * (k1x + 2 * k2x + 2 * k3x + k4x),
                y: y + (dt / 6) * (k1y + 2 * k2y + 2 * k3y + k4y)
            };
        }

        function simulate() {
            a = parseFloat(document.getElementById('param-a').value);
            b = parseFloat(document.getElementById('param-b').value);
            x = parseFloat(document.getElementById('x0').value);
            y = parseFloat(document.getElementById('y0').value);
            trajectory = [{ x, y }];
            timeHistory = [{ t: 0, x, y }];
            time = 0;
            updateStats();
            draw();
        }

        function toggleAnimation() {
            animating = !animating;
            if (animating) {
                animate();
            } else if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }

        function animate() {
            if (!animating) return;

            const dt = 0.05;
            for (let i = 0; i < 5; i++) {
                const next = rk4Step(x, y, dt);
                x = next.x;
                y = next.y;
                time += dt;

                trajectory.push({ x, y });
                timeHistory.push({ t: time, x, y });

                if (trajectory.length > 2000) trajectory.shift();
                if (timeHistory.length > 500) timeHistory.shift();
            }

            updateStats();
            draw();
            animationId = requestAnimationFrame(animate);
        }

        function clearTrajectory() {
            trajectory = [{ x, y }];
            draw();
        }

        function drawNullclines() {
            showNullclines = !showNullclines;
            draw();
        }

        function bifurcationSweep() {
            // Quick parameter sweep animation
            let sweepB = 0.3;
            const originalB = b;

            const sweep = () => {
                b = sweepB;
                document.getElementById('param-b').value = b;
                document.getElementById('b-val').textContent = b.toFixed(2);

                simulate();

                sweepB += 0.02;
                if (sweepB <= 1.2) {
                    setTimeout(sweep, 100);
                } else {
                    b = originalB;
                    document.getElementById('param-b').value = b;
                    document.getElementById('b-val').textContent = b.toFixed(2);
                    simulate();
                }
            };

            sweep();
        }

        function getFixedPoint() {
            // Fixed point: x* = b, y* = b / (a + b²)
            const xStar = b;
            const yStar = b / (a + b * b);

            // Jacobian at fixed point
            const J11 = -1 + 2 * xStar * yStar;
            const J12 = a + xStar * xStar;
            const J21 = -2 * xStar * yStar;
            const J22 = -a - xStar * xStar;

            const trace = J11 + J22;
            const det = J11 * J22 - J12 * J21;

            // Eigenvalues: trace ± sqrt(trace² - 4det) / 2
            const disc = trace * trace - 4 * det;

            let stability;
            if (det < 0) {
                stability = 'Saddle';
            } else if (trace > 0) {
                stability = disc < 0 ? 'Unstable spiral' : 'Unstable node';
            } else {
                stability = disc < 0 ? 'Stable spiral' : 'Stable node';
            }

            return { xStar, yStar, stability };
        }

        function updateStats() {
            document.getElementById('current-x').textContent = x.toFixed(3);
            document.getElementById('current-y').textContent = y.toFixed(3);

            const fp = getFixedPoint();
            document.getElementById('stability').textContent = fp.stability;

            // Estimate period from peaks in x
            if (timeHistory.length > 100) {
                const peaks = [];
                for (let i = 10; i < timeHistory.length - 10; i++) {
                    if (timeHistory[i].x > timeHistory[i - 1].x &&
                        timeHistory[i].x > timeHistory[i + 1].x &&
                        timeHistory[i].x > 0.5) {
                        peaks.push(timeHistory[i].t);
                    }
                }
                if (peaks.length >= 2) {
                    const period = peaks[peaks.length - 1] - peaks[peaks.length - 2];
                    document.getElementById('period').textContent = period.toFixed(1);
                }
            }
        }

        function draw() {
            drawPhase();
            drawTime();
        }

        function drawPhase() {
            phaseCtx.clearRect(0, 0, phaseCanvas.width, phaseCanvas.height);

            const padding = 40;
            const w = phaseCanvas.width - 2 * padding;
            const h = phaseCanvas.height - 2 * padding;
            const xMax = 2.5, yMax = 2.5;

            // Grid
            phaseCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            phaseCtx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const gx = padding + (i / 5) * w;
                const gy = padding + (i / 5) * h;
                phaseCtx.beginPath();
                phaseCtx.moveTo(gx, padding);
                phaseCtx.lineTo(gx, padding + h);
                phaseCtx.moveTo(padding, gy);
                phaseCtx.lineTo(padding + w, gy);
                phaseCtx.stroke();
            }

            // Nullclines
            if (showNullclines) {
                // x-nullcline: x = ay + x²y → y = x / (a + x²)
                phaseCtx.strokeStyle = '#2ecc71';
                phaseCtx.lineWidth = 2;
                phaseCtx.beginPath();
                for (let xn = 0.01; xn <= xMax; xn += 0.02) {
                    const yn = xn / (a + xn * xn);
                    const px = padding + (xn / xMax) * w;
                    const py = padding + h - (yn / yMax) * h;
                    if (xn === 0.01) phaseCtx.moveTo(px, py);
                    else phaseCtx.lineTo(px, py);
                }
                phaseCtx.stroke();

                // y-nullcline: ay + x²y = b → y = b / (a + x²)
                phaseCtx.strokeStyle = '#f39c12';
                phaseCtx.beginPath();
                for (let xn = 0; xn <= xMax; xn += 0.02) {
                    const yn = b / (a + xn * xn);
                    const px = padding + (xn / xMax) * w;
                    const py = padding + h - (yn / yMax) * h;
                    if (xn === 0) phaseCtx.moveTo(px, py);
                    else phaseCtx.lineTo(px, py);
                }
                phaseCtx.stroke();

                // Fixed point
                const fp = getFixedPoint();
                phaseCtx.fillStyle = '#fff';
                phaseCtx.beginPath();
                phaseCtx.arc(
                    padding + (fp.xStar / xMax) * w,
                    padding + h - (fp.yStar / yMax) * h,
                    6, 0, Math.PI * 2
                );
                phaseCtx.fill();
            }

            // Trajectory
            if (trajectory.length > 1) {
                phaseCtx.strokeStyle = 'rgba(231, 76, 60, 0.7)';
                phaseCtx.lineWidth = 1.5;
                phaseCtx.beginPath();
                for (let i = 0; i < trajectory.length; i++) {
                    const px = padding + (trajectory[i].x / xMax) * w;
                    const py = padding + h - (trajectory[i].y / yMax) * h;
                    if (i === 0) phaseCtx.moveTo(px, py);
                    else phaseCtx.lineTo(px, py);
                }
                phaseCtx.stroke();
            }

            // Current point
            phaseCtx.fillStyle = '#e74c3c';
            phaseCtx.beginPath();
            phaseCtx.arc(
                padding + (x / xMax) * w,
                padding + h - (y / yMax) * h,
                8, 0, Math.PI * 2
            );
            phaseCtx.fill();

            // Axes labels
            phaseCtx.fillStyle = '#888';
            phaseCtx.font = '12px sans-serif';
            phaseCtx.textAlign = 'center';
            phaseCtx.fillText('x (substrate)', padding + w / 2, phaseCanvas.height - 10);
            phaseCtx.save();
            phaseCtx.translate(12, padding + h / 2);
            phaseCtx.rotate(-Math.PI / 2);
            phaseCtx.fillText('y (product)', 0, 0);
            phaseCtx.restore();
        }

        function drawTime() {
            timeCtx.clearRect(0, 0, timeCanvas.width, timeCanvas.height);

            if (timeHistory.length < 2) return;

            const padding = 40;
            const w = timeCanvas.width - 2 * padding;
            const h = timeCanvas.height - 2 * padding;

            const tMin = timeHistory[0].t;
            const tMax = timeHistory[timeHistory.length - 1].t;
            const tRange = Math.max(tMax - tMin, 1);

            // Find y range
            let yMin = Infinity, yMax = -Infinity;
            for (const pt of timeHistory) {
                yMin = Math.min(yMin, pt.x, pt.y);
                yMax = Math.max(yMax, pt.x, pt.y);
            }
            yMin -= 0.1;
            yMax += 0.1;

            // Grid
            timeCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            timeCtx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const gy = padding + (i / 5) * h;
                timeCtx.beginPath();
                timeCtx.moveTo(padding, gy);
                timeCtx.lineTo(padding + w, gy);
                timeCtx.stroke();
            }

            // x time series
            timeCtx.strokeStyle = '#e74c3c';
            timeCtx.lineWidth = 2;
            timeCtx.beginPath();
            for (let i = 0; i < timeHistory.length; i++) {
                const px = padding + ((timeHistory[i].t - tMin) / tRange) * w;
                const py = padding + h - ((timeHistory[i].x - yMin) / (yMax - yMin)) * h;
                if (i === 0) timeCtx.moveTo(px, py);
                else timeCtx.lineTo(px, py);
            }
            timeCtx.stroke();

            // y time series
            timeCtx.strokeStyle = '#3498db';
            timeCtx.beginPath();
            for (let i = 0; i < timeHistory.length; i++) {
                const px = padding + ((timeHistory[i].t - tMin) / tRange) * w;
                const py = padding + h - ((timeHistory[i].y - yMin) / (yMax - yMin)) * h;
                if (i === 0) timeCtx.moveTo(px, py);
                else timeCtx.lineTo(px, py);
            }
            timeCtx.stroke();

            // Axes
            timeCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            timeCtx.lineWidth = 2;
            timeCtx.beginPath();
            timeCtx.moveTo(padding, padding);
            timeCtx.lineTo(padding, padding + h);
            timeCtx.lineTo(padding + w, padding + h);
            timeCtx.stroke();

            // Labels
            timeCtx.fillStyle = '#888';
            timeCtx.font = '12px sans-serif';
            timeCtx.textAlign = 'center';
            timeCtx.fillText('Time', padding + w / 2, timeCanvas.height - 10);
            timeCtx.save();
            timeCtx.translate(12, padding + h / 2);
            timeCtx.rotate(-Math.PI / 2);
            timeCtx.fillText('Concentration', 0, 0);
            timeCtx.restore();
        }

        // Event listeners
        ['param-a', 'param-b', 'x0', 'y0'].forEach(id => {
            document.getElementById(id).addEventListener('input', e => {
                const valId = id.replace('param-', '') + '-val';
                if (id === 'x0' || id === 'y0') {
                    document.getElementById(valId).textContent = e.target.value;
                } else {
                    document.getElementById(id.split('-')[1] + '-val').textContent = e.target.value;
                }
            });
        });

        // Expose for enhance.js keyboard shortcuts
        window.reset = function() { simulate(); };
        window.init = window.reset;

        simulate();
        animate();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
