<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deep Learning Layers</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="info">
        <h3>Deep Learning Architecture</h3>
        <p>Multiple layers of abstraction</p>
        <p>From raw input to high-level features</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1200;
        canvas.height = 800;

        const layerTypes = [
            { name: 'Input', count: 784, visualSize: 28, color: '#3498db' },
            { name: 'Conv1', count: 128, visualSize: 14, color: '#9b59b6' },
            { name: 'Pool1', count: 64, visualSize: 7, color: '#e74c3c' },
            { name: 'Conv2', count: 64, visualSize: 7, color: '#f39c12' },
            { name: 'Flatten', count: 256, visualSize: 16, color: '#1abc9c' },
            { name: 'Dense', count: 128, visualSize: 11, color: '#34495e' },
            { name: 'Output', count: 10, visualSize: 3, color: '#2ecc71' }
        ];

        const layers = [];
        const layerSpacing = canvas.width / (layerTypes.length + 1);

        layerTypes.forEach((type, i) => {
            const layer = {
                name: type.name,
                x: layerSpacing * (i + 1),
                y: canvas.height / 2,
                visualSize: type.visualSize,
                color: type.color,
                neurons: [],
                activation: []
            };

            // Create grid of neurons for visualization
            const gridSize = Math.ceil(Math.sqrt(type.count));
            for (let r = 0; r < type.visualSize; r++) {
                layer.activation[r] = [];
                for (let c = 0; c < type.visualSize; c++) {
                    layer.activation[r][c] = Math.random();
                }
            }

            layers.push(layer);
        });

        let time = 0;

        function animate() {
            ctx.fillStyle = 'rgba(102, 126, 234, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            time += 0.02;

            // Update activations with wave pattern
            layers.forEach((layer, layerIdx) => {
                for (let r = 0; r < layer.visualSize; r++) {
                    for (let c = 0; c < layer.visualSize; c++) {
                        const val = Math.sin(time + r * 0.3 + c * 0.3 + layerIdx * 0.5) * 0.5 + 0.5;
                        layer.activation[r][c] = layer.activation[r][c] * 0.9 + val * 0.1;
                    }
                }
            });

            // Draw connections between layers
            for (let i = 0; i < layers.length - 1; i++) {
                const from = layers[i];
                const to = layers[i + 1];

                // Sample connections
                for (let j = 0; j < 5; j++) {
                    const fromR = Math.floor(Math.random() * from.visualSize);
                    const fromC = Math.floor(Math.random() * from.visualSize);
                    const toR = Math.floor(Math.random() * to.visualSize);
                    const toC = Math.floor(Math.random() * to.visualSize);

                    const cellSize = 150 / from.visualSize;
                    const fromX = from.x - 75 + fromC * cellSize + cellSize / 2;
                    const fromY = from.y - 75 + fromR * cellSize + cellSize / 2;
                    const toCellSize = 150 / to.visualSize;
                    const toX = to.x - 75 + toC * toCellSize + toCellSize / 2;
                    const toY = to.y - 75 + toR * toCellSize + toCellSize / 2;

                    const alpha = from.activation[fromR][fromC] * 0.3;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(fromX, fromY);
                    ctx.lineTo(toX, toY);
                    ctx.stroke();
                }
            }

            // Draw layers
            layers.forEach((layer, layerIdx) => {
                const boxSize = 150;
                const cellSize = boxSize / layer.visualSize;

                // Layer label
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(layer.name, layer.x, layer.y - boxSize/2 - 20);

                // Draw feature map
                for (let r = 0; r < layer.visualSize; r++) {
                    for (let c = 0; c < layer.visualSize; c++) {
                        const x = layer.x - boxSize/2 + c * cellSize;
                        const y = layer.y - boxSize/2 + r * cellSize;
                        const activation = layer.activation[r][c];

                        const color = layer.color;
                        const rgb = hexToRgb(color);

                        ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${activation})`;
                        ctx.fillRect(x, y, cellSize - 1, cellSize - 1);

                        if (activation > 0.7) {
                            ctx.fillStyle = `rgba(255, 255, 255, ${(activation - 0.7) * 2})`;
                            ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
                        }
                    }
                }

                // Border
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.strokeRect(layer.x - boxSize/2, layer.y - boxSize/2, boxSize, boxSize);

                // Info
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '10px Arial';
                ctx.fillText(`${layer.visualSize}x${layer.visualSize}`, layer.x, layer.y + boxSize/2 + 15);
            });

            // Data flow indicator
            const flowX = 30 + (time * 100) % (canvas.width - 60);
            const flowLayer = Math.floor((flowX - 30) / layerSpacing);

            if (flowLayer < layers.length) {
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'rgba(255, 255, 100, 0.8)';
                ctx.fillStyle = 'rgba(255, 255, 100, 0.8)';
                ctx.beginPath();
                ctx.arc(flowX, canvas.height - 50, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Arrow
                ctx.strokeStyle = 'rgba(255, 255, 100, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(flowX + 10, canvas.height - 50);
                ctx.lineTo(flowX + 20, canvas.height - 50);
                ctx.stroke();

                ctx.fillStyle = 'rgba(255, 255, 100, 0.8)';
                ctx.beginPath();
                ctx.moveTo(flowX + 20, canvas.height - 50);
                ctx.lineTo(flowX + 15, canvas.height - 55);
                ctx.lineTo(flowX + 15, canvas.height - 45);
                ctx.fill();
            }

            requestAnimationFrame(animate);
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 100, g: 100, b: 100 };
        }

        animate();
    </script>
</body>
</html>
