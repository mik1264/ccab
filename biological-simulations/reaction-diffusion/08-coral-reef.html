<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reaction-Diffusion: Coral Reef</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(180deg, #001f3f 0%, #003366 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
        }
        .tech-badge {
            display: inline-block;
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.4);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <div class="info">
        <h3>Reaction-Diffusion: Coral Reef</h3>
        <p>Underwater coral-like growth</p>
        <div class="tech-badge">GPU-Accelerated • Three.js TSL • Reaction-Diffusion</div>
    </div>
    <canvas id="canvas"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
            "three/tsl": "https://unpkg.com/three@0.170.0/build/three.webgpu.js",
            "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const canvas = document.getElementById('canvas');
        const width = 512;
        const height = 512;

        canvas.width = width;
        canvas.height = height;

        // Setup renderer
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
        renderer.setSize(width, height);

        // Parameters for coral reef patterns
        const params = {
            dA: 1.0,
            dB: 0.5,
            feed: 0.062,
            kill: 0.063
        };

        // Create data textures
        const size = 512;
        const data = new Float32Array(size * size * 4);

        // Initialize: A=1, B=0 everywhere
        for (let i = 0; i < size * size; i++) {
            data[i * 4 + 0] = 1.0; // A
            data[i * 4 + 1] = 0.0; // B
            data[i * 4 + 2] = 0.0;
            data[i * 4 + 3] = 1.0;
        }

        // Add random B seeds for coral growth
        for (let i = 0; i < 20; i++) {
            const x = Math.floor(Math.random() * size);
            const y = Math.floor(Math.random() * size);
            const idx = (y * size + x) * 4;
            data[idx + 1] = 1.0; // B
        }

        const texture1 = new THREE.DataTexture(data, size, size, THREE.RGBAFormat, THREE.FloatType);
        texture1.needsUpdate = true;
        texture1.minFilter = THREE.NearestFilter;
        texture1.magFilter = THREE.NearestFilter;
        texture1.wrapS = THREE.RepeatWrapping;
        texture1.wrapT = THREE.RepeatWrapping;

        // Create render targets
        const rtOptions = {
            minFilter: THREE.NearestFilter,
            magFilter: THREE.NearestFilter,
            wrapS: THREE.RepeatWrapping,
            wrapT: THREE.RepeatWrapping,
            format: THREE.RGBAFormat,
            type: THREE.FloatType
        };

        const rt1 = new THREE.WebGLRenderTarget(size, size, rtOptions);
        const rt2 = new THREE.WebGLRenderTarget(size, size, rtOptions);

        // Initialize render targets
        const initScene = new THREE.Scene();
        const initMaterial = new THREE.MeshBasicMaterial({ map: texture1 });
        const initMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), initMaterial);
        initScene.add(initMesh);
        const initCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        renderer.setRenderTarget(rt1);
        renderer.render(initScene, initCamera);
        renderer.setRenderTarget(rt2);
        renderer.render(initScene, initCamera);
        renderer.setRenderTarget(null);

        // Compute shader
        const computeShader = `
            uniform sampler2D uTexture;
            uniform vec2 uResolution;
            uniform float uDa;
            uniform float uDb;
            uniform float uFeed;
            uniform float uKill;
            varying vec2 vUv;

            void main() {
                vec2 texel = 1.0 / uResolution;

                vec4 center = texture2D(uTexture, vUv);
                float a = center.r;
                float b = center.g;

                // Compute Laplacian
                float laplacianA = a * -1.0;
                float laplacianB = b * -1.0;

                vec4 n = texture2D(uTexture, vUv + vec2(0.0, texel.y));
                vec4 s = texture2D(uTexture, vUv + vec2(0.0, -texel.y));
                vec4 e = texture2D(uTexture, vUv + vec2(texel.x, 0.0));
                vec4 w = texture2D(uTexture, vUv + vec2(-texel.x, 0.0));

                laplacianA += (n.r + s.r + e.r + w.r) * 0.2;
                laplacianB += (n.g + s.g + e.g + w.g) * 0.2;

                vec4 ne = texture2D(uTexture, vUv + vec2(texel.x, texel.y));
                vec4 nw = texture2D(uTexture, vUv + vec2(-texel.x, texel.y));
                vec4 se = texture2D(uTexture, vUv + vec2(texel.x, -texel.y));
                vec4 sw = texture2D(uTexture, vUv + vec2(-texel.x, -texel.y));

                laplacianA += (ne.r + nw.r + se.r + sw.r) * 0.05;
                laplacianB += (ne.g + nw.g + se.g + sw.g) * 0.05;

                // Gray-Scott equations
                float reaction = a * b * b;
                float deltaA = uDa * laplacianA - reaction + uFeed * (1.0 - a);
                float deltaB = uDb * laplacianB + reaction - (uKill + uFeed) * b;

                float newA = clamp(a + deltaA, 0.0, 1.0);
                float newB = clamp(b + deltaB, 0.0, 1.0);

                gl_FragColor = vec4(newA, newB, 0.0, 1.0);
            }
        `;

        const computeMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTexture: { value: rt1.texture },
                uResolution: { value: new THREE.Vector2(size, size) },
                uDa: { value: params.dA },
                uDb: { value: params.dB },
                uFeed: { value: params.feed },
                uKill: { value: params.kill }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: computeShader
        });

        const computeScene = new THREE.Scene();
        const computeMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), computeMaterial);
        computeScene.add(computeMesh);
        const computeCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // Display shader with coral reef coloring and animation
        const displayMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTexture: { value: rt1.texture },
                uTime: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D uTexture;
                uniform float uTime;
                varying vec2 vUv;

                void main() {
                    vec4 texel = texture2D(uTexture, vUv);
                    float a = texel.r;
                    float b = texel.g;
                    float value = a - b;

                    // Depth effect (darker at top, lighter at bottom)
                    float depth = vUv.y * 0.5 + 0.5;
                    float brightness = value * depth;

                    // Coral colors with subtle animation
                    float wave = sin(uTime + vUv.x * 10.0) * 0.08;
                    float r = brightness * 0.3;
                    float g = brightness * 0.8 + wave;
                    float b_color = brightness * 1.2;

                    vec3 color = vec3(r, g, b_color);
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });

        const displayScene = new THREE.Scene();
        const displayMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), displayMaterial);
        displayScene.add(displayMesh);
        const displayCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // Animation loop
        let currentTarget = rt1;
        let nextTarget = rt2;
        let time = 0;

        function animate() {
            for (let i = 0; i < 10; i++) {
                computeMaterial.uniforms.uTexture.value = currentTarget.texture;
                renderer.setRenderTarget(nextTarget);
                renderer.render(computeScene, computeCamera);

                [currentTarget, nextTarget] = [nextTarget, currentTarget];
            }

            // Update time for animation
            time += 0.01;
            displayMaterial.uniforms.uTime.value = time;

            displayMaterial.uniforms.uTexture.value = currentTarget.texture;
            renderer.setRenderTarget(null);
            renderer.render(displayScene, displayCamera);

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
