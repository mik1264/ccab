<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Colorful Reaction-Diffusion</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
        }
        .tech-badge {
            display: inline-block;
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.4);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <div class="info">
        <h3>Colorful Reaction-Diffusion</h3>
        <p>Rainbow coral patterns</p>
        <div class="tech-badge">GPU-Accelerated • Three.js TSL • Reaction-Diffusion</div>
    </div>
    <canvas id="canvas"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
            "three/tsl": "https://unpkg.com/three@0.170.0/build/three.webgpu.js",
            "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/",
            "three/nodes": "https://unpkg.com/three@0.170.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { texture, uv, uniform, vec2, vec3, vec4, add, sub, mul, clamp, Fn, mod } from 'three/nodes';

        const canvas = document.getElementById('canvas');
        const width = 512;
        const height = 512;

        canvas.width = width;
        canvas.height = height;

        // Setup renderer
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
        renderer.setSize(width, height);

        // Parameters
        const params = {
            dA: 1.0,
            dB: 0.5,
            feed: 0.055,
            kill: 0.062
        };

        // Create data textures for chemicals A and B
        const size = 512;
        const data = new Float32Array(size * size * 4);

        // Initialize: A=1, B=0 everywhere
        for (let i = 0; i < size * size; i++) {
            data[i * 4 + 0] = 1.0; // A
            data[i * 4 + 1] = 0.0; // B
            data[i * 4 + 2] = 0.0;
            data[i * 4 + 3] = 1.0;
        }

        // Add initial B seeds randomly
        for (let i = 0; i < 15; i++) {
            const x = Math.floor(Math.random() * size);
            const y = Math.floor(Math.random() * size);
            const idx = (y * size + x) * 4;
            data[idx + 1] = 1.0; // B
        }

        const texture1 = new THREE.DataTexture(data, size, size, THREE.RGBAFormat, THREE.FloatType);
        texture1.needsUpdate = true;
        texture1.minFilter = THREE.NearestFilter;
        texture1.magFilter = THREE.NearestFilter;
        texture1.wrapS = THREE.RepeatWrapping;
        texture1.wrapT = THREE.RepeatWrapping;

        // Create render targets for ping-pong rendering
        const rtOptions = {
            minFilter: THREE.NearestFilter,
            magFilter: THREE.NearestFilter,
            wrapS: THREE.RepeatWrapping,
            wrapT: THREE.RepeatWrapping,
            format: THREE.RGBAFormat,
            type: THREE.FloatType
        };

        const rt1 = new THREE.WebGLRenderTarget(size, size, rtOptions);
        const rt2 = new THREE.WebGLRenderTarget(size, size, rtOptions);

        // Initialize render targets with initial data
        const initScene = new THREE.Scene();
        const initMaterial = new THREE.MeshBasicMaterial({ map: texture1 });
        const initMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), initMaterial);
        initScene.add(initMesh);
        const initCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        renderer.setRenderTarget(rt1);
        renderer.render(initScene, initCamera);
        renderer.setRenderTarget(rt2);
        renderer.render(initScene, initCamera);
        renderer.setRenderTarget(null);

        // TSL-based compute material for reaction-diffusion
        const uTexture = uniform(rt1.texture);
        const uResolution = uniform(vec2(size, size));
        const uDa = uniform(params.dA);
        const uDb = uniform(params.dB);
        const uFeed = uniform(params.feed);
        const uKill = uniform(params.kill);

        // Gray-Scott reaction-diffusion computation using TSL
        const grayScottCompute = Fn(() => {
            const uvCoord = uv();
            const texel = vec2(1.0).div(uResolution);

            // Sample current values
            const center = texture(uTexture, uvCoord);
            const a = center.r;
            const b = center.g;

            // Compute Laplacian using 9-point stencil
            let laplacianA = a.mul(-1.0);
            let laplacianB = b.mul(-1.0);

            // Cardinals
            const n = texture(uTexture, uvCoord.add(vec2(0.0, texel.y)));
            const s = texture(uTexture, uvCoord.add(vec2(0.0, texel.y.negate())));
            const e = texture(uTexture, uvCoord.add(vec2(texel.x, 0.0)));
            const w = texture(uTexture, uvCoord.add(vec2(texel.x.negate(), 0.0)));

            laplacianA = laplacianA.add(n.r.add(s.r).add(e.r).add(w.r).mul(0.2));
            laplacianB = laplacianB.add(n.g.add(s.g).add(e.g).add(w.g).mul(0.2));

            // Diagonals
            const ne = texture(uTexture, uvCoord.add(vec2(texel.x, texel.y)));
            const nw = texture(uTexture, uvCoord.add(vec2(texel.x.negate(), texel.y)));
            const se = texture(uTexture, uvCoord.add(vec2(texel.x, texel.y.negate())));
            const sw = texture(uTexture, uvCoord.add(vec2(texel.x.negate(), texel.y.negate())));

            laplacianA = laplacianA.add(ne.r.add(nw.r).add(se.r).add(sw.r).mul(0.05));
            laplacianB = laplacianB.add(ne.g.add(nw.g).add(se.g).add(sw.g).mul(0.05));

            // Gray-Scott reaction-diffusion equations
            const reaction = a.mul(b).mul(b);
            const deltaA = uDa.mul(laplacianA).sub(reaction).add(uFeed.mul(sub(1.0, a)));
            const deltaB = uDb.mul(laplacianB).add(reaction).sub(uKill.add(uFeed).mul(b));

            const newA = clamp(a.add(deltaA), 0.0, 1.0);
            const newB = clamp(b.add(deltaB), 0.0, 1.0);

            return vec4(newA, newB, 0.0, 1.0);
        })();

        const computeMaterial = new THREE.MeshBasicNodeMaterial();
        computeMaterial.colorNode = grayScottCompute;

        const computeScene = new THREE.Scene();
        const computeMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), computeMaterial);
        computeScene.add(computeMesh);
        const computeCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // TSL-based display material with HSL color cycling
        const uDisplayTexture = uniform(rt1.texture);
        const uTime = uniform(0.0);

        const displayShader = Fn(() => {
            const uvCoord = uv();
            const texel = texture(uDisplayTexture, uvCoord);
            const a = texel.r;
            const b = texel.g;
            const value = a.sub(b);

            // Cycling hue based on value and time
            const hue = mod(value.add(uTime), 1.0);
            const sat = 1.0;
            const light = value.mul(0.7);

            // HSL to RGB conversion (simplified for hue cycling)
            const c = sub(1.0, mul(2.0, light).sub(1.0).abs()).mul(sat);
            const x = c.mul(sub(1.0, mod(hue.mul(6.0), 2.0).sub(1.0).abs()));
            const m = light.sub(c.div(2.0));

            // Approximate HSL to RGB using smooth color wheel
            const r = hue.mul(6.0).cos().mul(0.5).add(0.5).mul(c).add(m);
            const g = hue.mul(6.0).add(2.094).cos().mul(0.5).add(0.5).mul(c).add(m);
            const b_color = hue.mul(6.0).add(4.189).cos().mul(0.5).add(0.5).mul(c).add(m);

            const color = vec3(r, g, b_color);
            return vec4(color, 1.0);
        })();

        const displayMaterial = new THREE.MeshBasicNodeMaterial();
        displayMaterial.colorNode = displayShader;

        const displayScene = new THREE.Scene();
        const displayMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), displayMaterial);
        displayScene.add(displayMesh);
        const displayCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // Animation loop
        let currentTarget = rt1;
        let nextTarget = rt2;
        let time = 0;

        function animate() {
            // Run multiple compute iterations per frame
            for (let i = 0; i < 10; i++) {
                uTexture.value = currentTarget.texture;
                renderer.setRenderTarget(nextTarget);
                renderer.render(computeScene, computeCamera);

                // Swap targets
                [currentTarget, nextTarget] = [nextTarget, currentTarget];
            }

            // Update time for color cycling
            time += 0.002;
            uTime.value = time;

            // Display result
            uDisplayTexture.value = currentTarget.texture;
            renderer.setRenderTarget(null);
            renderer.render(displayScene, displayCamera);

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
