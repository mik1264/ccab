<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Colorful Reaction-Diffusion</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
        }
        .tech-badge {
            display: inline-block;
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.4);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <div class="info">
        <h3>Colorful Reaction-Diffusion</h3>
        <p>Rainbow coral patterns</p>
        <div class="tech-badge">GPU-Accelerated • Three.js TSL • Reaction-Diffusion</div>
    </div>
    <canvas id="canvas"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
            "three/tsl": "https://unpkg.com/three@0.170.0/build/three.webgpu.js",
            "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const canvas = document.getElementById('canvas');
        const width = 512;
        const height = 512;

        canvas.width = width;
        canvas.height = height;

        // Setup renderer
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
        renderer.setSize(width, height);

        // Parameters
        const params = {
            dA: 1.0,
            dB: 0.5,
            feed: 0.055,
            kill: 0.062
        };

        // Create data textures for chemicals A and B
        const size = 512;
        const data = new Float32Array(size * size * 4);

        // Initialize: A=1, B=0 everywhere
        for (let i = 0; i < size * size; i++) {
            data[i * 4 + 0] = 1.0; // A
            data[i * 4 + 1] = 0.0; // B
            data[i * 4 + 2] = 0.0;
            data[i * 4 + 3] = 1.0;
        }

        // Add initial B seeds randomly
        for (let i = 0; i < 15; i++) {
            const x = Math.floor(Math.random() * size);
            const y = Math.floor(Math.random() * size);
            const idx = (y * size + x) * 4;
            data[idx + 1] = 1.0; // B
        }

        const texture1 = new THREE.DataTexture(data, size, size, THREE.RGBAFormat, THREE.FloatType);
        texture1.needsUpdate = true;
        texture1.minFilter = THREE.NearestFilter;
        texture1.magFilter = THREE.NearestFilter;
        texture1.wrapS = THREE.RepeatWrapping;
        texture1.wrapT = THREE.RepeatWrapping;

        // Create render targets for ping-pong rendering
        const rtOptions = {
            minFilter: THREE.NearestFilter,
            magFilter: THREE.NearestFilter,
            wrapS: THREE.RepeatWrapping,
            wrapT: THREE.RepeatWrapping,
            format: THREE.RGBAFormat,
            type: THREE.FloatType
        };

        const rt1 = new THREE.WebGLRenderTarget(size, size, rtOptions);
        const rt2 = new THREE.WebGLRenderTarget(size, size, rtOptions);

        // Initialize render targets with initial data
        const initScene = new THREE.Scene();
        const initMaterial = new THREE.MeshBasicMaterial({ map: texture1 });
        const initMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), initMaterial);
        initScene.add(initMesh);
        const initCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        renderer.setRenderTarget(rt1);
        renderer.render(initScene, initCamera);
        renderer.setRenderTarget(rt2);
        renderer.render(initScene, initCamera);
        renderer.setRenderTarget(null);

        // Compute shader for reaction-diffusion
        const computeShader = `
            uniform sampler2D uTexture;
            uniform vec2 uResolution;
            uniform float uDa;
            uniform float uDb;
            uniform float uFeed;
            uniform float uKill;
            varying vec2 vUv;

            void main() {
                vec2 texel = 1.0 / uResolution;

                // Sample current values
                vec4 center = texture2D(uTexture, vUv);
                float a = center.r;
                float b = center.g;

                // Compute Laplacian using 9-point stencil
                float laplacianA = 0.0;
                float laplacianB = 0.0;

                // Center
                laplacianA += a * -1.0;
                laplacianB += b * -1.0;

                // Cardinals
                vec4 n = texture2D(uTexture, vUv + vec2(0.0, texel.y));
                vec4 s = texture2D(uTexture, vUv + vec2(0.0, -texel.y));
                vec4 e = texture2D(uTexture, vUv + vec2(texel.x, 0.0));
                vec4 w = texture2D(uTexture, vUv + vec2(-texel.x, 0.0));

                laplacianA += (n.r + s.r + e.r + w.r) * 0.2;
                laplacianB += (n.g + s.g + e.g + w.g) * 0.2;

                // Diagonals
                vec4 ne = texture2D(uTexture, vUv + vec2(texel.x, texel.y));
                vec4 nw = texture2D(uTexture, vUv + vec2(-texel.x, texel.y));
                vec4 se = texture2D(uTexture, vUv + vec2(texel.x, -texel.y));
                vec4 sw = texture2D(uTexture, vUv + vec2(-texel.x, -texel.y));

                laplacianA += (ne.r + nw.r + se.r + sw.r) * 0.05;
                laplacianB += (ne.g + nw.g + se.g + sw.g) * 0.05;

                // Gray-Scott reaction-diffusion equations
                float reaction = a * b * b;
                float deltaA = uDa * laplacianA - reaction + uFeed * (1.0 - a);
                float deltaB = uDb * laplacianB + reaction - (uKill + uFeed) * b;

                float newA = clamp(a + deltaA, 0.0, 1.0);
                float newB = clamp(b + deltaB, 0.0, 1.0);

                gl_FragColor = vec4(newA, newB, 0.0, 1.0);
            }
        `;

        const computeMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTexture: { value: rt1.texture },
                uResolution: { value: new THREE.Vector2(size, size) },
                uDa: { value: params.dA },
                uDb: { value: params.dB },
                uFeed: { value: params.feed },
                uKill: { value: params.kill }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: computeShader
        });

        const computeScene = new THREE.Scene();
        const computeMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), computeMaterial);
        computeScene.add(computeMesh);
        const computeCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // Display shader with HSL color cycling
        const displayMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTexture: { value: rt1.texture },
                uTime: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D uTexture;
                uniform float uTime;
                varying vec2 vUv;

                vec3 hslToRgb(float h, float s, float l) {
                    float c = (1.0 - abs(2.0 * l - 1.0)) * s;
                    float x = c * (1.0 - abs(mod(h * 6.0, 2.0) - 1.0));
                    float m = l - c / 2.0;

                    vec3 rgb;
                    if (h < 1.0/6.0) rgb = vec3(c, x, 0.0);
                    else if (h < 2.0/6.0) rgb = vec3(x, c, 0.0);
                    else if (h < 3.0/6.0) rgb = vec3(0.0, c, x);
                    else if (h < 4.0/6.0) rgb = vec3(0.0, x, c);
                    else if (h < 5.0/6.0) rgb = vec3(x, 0.0, c);
                    else rgb = vec3(c, 0.0, x);

                    return rgb + m;
                }

                void main() {
                    vec4 texel = texture2D(uTexture, vUv);
                    float a = texel.r;
                    float b = texel.g;
                    float value = a - b;

                    // Cycling hue based on value and time
                    float hue = mod(value + uTime, 1.0);
                    float sat = 1.0;
                    float light = value * 0.7;

                    vec3 color = hslToRgb(hue, sat, light);
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });

        const displayScene = new THREE.Scene();
        const displayMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), displayMaterial);
        displayScene.add(displayMesh);
        const displayCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // Animation loop
        let currentTarget = rt1;
        let nextTarget = rt2;
        let time = 0;

        function animate() {
            // Run multiple compute iterations per frame
            for (let i = 0; i < 10; i++) {
                computeMaterial.uniforms.uTexture.value = currentTarget.texture;
                renderer.setRenderTarget(nextTarget);
                renderer.render(computeScene, computeCamera);

                // Swap targets
                [currentTarget, nextTarget] = [nextTarget, currentTarget];
            }

            // Update time for color cycling
            time += 0.002;
            displayMaterial.uniforms.uTime.value = time;

            // Display result
            displayMaterial.uniforms.uTexture.value = currentTarget.texture;
            renderer.setRenderTarget(null);
            renderer.render(displayScene, displayCamera);

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
