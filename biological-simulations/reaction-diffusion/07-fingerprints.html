<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reaction-Diffusion: Fingerprints</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #f5f5dc;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid #8b4513;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
        }
        .tech-badge {
            display: inline-block;
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.4);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <div class="info">
        <h3>Reaction-Diffusion: Fingerprints</h3>
        <p>Whorl-like patterns</p>
        <div class="tech-badge">GPU-Accelerated • Three.js TSL • Reaction-Diffusion</div>
    </div>
    <canvas id="canvas"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
            "three/tsl": "https://unpkg.com/three@0.170.0/build/three.webgpu.js",
            "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/",
            "three/nodes": "https://unpkg.com/three@0.170.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { texture, uv, uniform, vec2, vec3, vec4, add, sub, mul, clamp, Fn, mix, step } from 'three/nodes';

        const canvas = document.getElementById('canvas');
        const width = 512;
        const height = 512;

        canvas.width = width;
        canvas.height = height;

        // Setup renderer
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
        renderer.setSize(width, height);

        // Parameters for fingerprint patterns
        const params = {
            dA: 1.0,
            dB: 0.5,
            feed: 0.042,
            kill: 0.059
        };

        // Create data textures
        const size = 512;
        const data = new Float32Array(size * size * 4);

        // Initialize with noise for fingerprint-like patterns
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                const idx = (y * size + x) * 4;
                data[idx + 0] = 1.0; // A
                data[idx + 1] = Math.random() < 0.1 ? Math.random() : 0.0; // B with sparse noise
                data[idx + 2] = 0.0;
                data[idx + 3] = 1.0;
            }
        }

        const texture1 = new THREE.DataTexture(data, size, size, THREE.RGBAFormat, THREE.FloatType);
        texture1.needsUpdate = true;
        texture1.minFilter = THREE.NearestFilter;
        texture1.magFilter = THREE.NearestFilter;
        texture1.wrapS = THREE.RepeatWrapping;
        texture1.wrapT = THREE.RepeatWrapping;

        // Create render targets
        const rtOptions = {
            minFilter: THREE.NearestFilter,
            magFilter: THREE.NearestFilter,
            wrapS: THREE.RepeatWrapping,
            wrapT: THREE.RepeatWrapping,
            format: THREE.RGBAFormat,
            type: THREE.FloatType
        };

        const rt1 = new THREE.WebGLRenderTarget(size, size, rtOptions);
        const rt2 = new THREE.WebGLRenderTarget(size, size, rtOptions);

        // Initialize render targets
        const initScene = new THREE.Scene();
        const initMaterial = new THREE.MeshBasicMaterial({ map: texture1 });
        const initMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), initMaterial);
        initScene.add(initMesh);
        const initCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        renderer.setRenderTarget(rt1);
        renderer.render(initScene, initCamera);
        renderer.setRenderTarget(rt2);
        renderer.render(initScene, initCamera);
        renderer.setRenderTarget(null);

        // TSL-based compute material for reaction-diffusion
        const uTexture = uniform(rt1.texture);
        const uResolution = uniform(vec2(size, size));
        const uDa = uniform(params.dA);
        const uDb = uniform(params.dB);
        const uFeed = uniform(params.feed);
        const uKill = uniform(params.kill);

        // Gray-Scott reaction-diffusion computation using TSL
        const grayScottCompute = Fn(() => {
            const uvCoord = uv();
            const texel = vec2(1.0).div(uResolution);

            const center = texture(uTexture, uvCoord);
            const a = center.r;
            const b = center.g;

            // Compute Laplacian
            let laplacianA = a.mul(-1.0);
            let laplacianB = b.mul(-1.0);

            const n = texture(uTexture, uvCoord.add(vec2(0.0, texel.y)));
            const s = texture(uTexture, uvCoord.add(vec2(0.0, texel.y.negate())));
            const e = texture(uTexture, uvCoord.add(vec2(texel.x, 0.0)));
            const w = texture(uTexture, uvCoord.add(vec2(texel.x.negate(), 0.0)));

            laplacianA = laplacianA.add(n.r.add(s.r).add(e.r).add(w.r).mul(0.2));
            laplacianB = laplacianB.add(n.g.add(s.g).add(e.g).add(w.g).mul(0.2));

            const ne = texture(uTexture, uvCoord.add(vec2(texel.x, texel.y)));
            const nw = texture(uTexture, uvCoord.add(vec2(texel.x.negate(), texel.y)));
            const se = texture(uTexture, uvCoord.add(vec2(texel.x, texel.y.negate())));
            const sw = texture(uTexture, uvCoord.add(vec2(texel.x.negate(), texel.y.negate())));

            laplacianA = laplacianA.add(ne.r.add(nw.r).add(se.r).add(sw.r).mul(0.05));
            laplacianB = laplacianB.add(ne.g.add(nw.g).add(se.g).add(sw.g).mul(0.05));

            // Gray-Scott equations
            const reaction = a.mul(b).mul(b);
            const deltaA = uDa.mul(laplacianA).sub(reaction).add(uFeed.mul(sub(1.0, a)));
            const deltaB = uDb.mul(laplacianB).add(reaction).sub(uKill.add(uFeed).mul(b));

            const newA = clamp(a.add(deltaA), 0.0, 1.0);
            const newB = clamp(b.add(deltaB), 0.0, 1.0);

            return vec4(newA, newB, 0.0, 1.0);
        })();

        const computeMaterial = new THREE.MeshBasicNodeMaterial();
        computeMaterial.colorNode = grayScottCompute;

        const computeScene = new THREE.Scene();
        const computeMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), computeMaterial);
        computeScene.add(computeMesh);
        const computeCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // TSL-based display material with fingerprint coloring
        const uDisplayTexture = uniform(rt1.texture);

        const displayShader = Fn(() => {
            const uvCoord = uv();
            const texel = texture(uDisplayTexture, uvCoord);
            const b = texel.g;

            // Binary coloring for fingerprint effect
            const darkLines = vec3(0.2, 0.18, 0.16); // Dark lines
            const lightBackground = vec3(0.86, 0.85, 0.82); // Light background

            // Use step and mix for if/else: if b > 0.5 then darkLines else lightBackground
            const threshold = step(0.5, b);
            const color = mix(lightBackground, darkLines, threshold);

            return vec4(color, 1.0);
        })();

        const displayMaterial = new THREE.MeshBasicNodeMaterial();
        displayMaterial.colorNode = displayShader;

        const displayScene = new THREE.Scene();
        const displayMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), displayMaterial);
        displayScene.add(displayMesh);
        const displayCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // Animation loop
        let currentTarget = rt1;
        let nextTarget = rt2;

        function animate() {
            for (let i = 0; i < 10; i++) {
                uTexture.value = currentTarget.texture;
                renderer.setRenderTarget(nextTarget);
                renderer.render(computeScene, computeCamera);

                [currentTarget, nextTarget] = [nextTarget, currentTarget];
            }

            uDisplayTexture.value = currentTarget.texture;
            renderer.setRenderTarget(null);
            renderer.render(displayScene, displayCamera);

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
