<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spots Pattern</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
        }
        .tech-badge {
            display: inline-block;
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.4);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="organic-back-link" style="position: fixed; top: 20px; right: 20px; z-index: 1000; display: flex; align-items: center; gap: 8px; padding: 10px 16px; background: rgba(255,255,255,0.9); backdrop-filter: blur(10px); border-radius: 30px; text-decoration: none; color: #606C38; font-family: 'Nunito', sans-serif; font-weight: 600; box-shadow: 0 2px 10px rgba(0,0,0,0.1); transition: all 0.3s ease;">
        <span class="back-arrow">←</span>
        <span class="back-text">Gallery</span>
    </a>
    <div class="info">
        <h3>Reaction-Diffusion: Spots</h3>
        <p>Leopard/cheetah spot patterns</p>
        <div class="tech-badge">GPU-Accelerated • Three.js TSL • Reaction-Diffusion</div>
    </div>
    <canvas id="canvas"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
            "three/tsl": "https://unpkg.com/three@0.170.0/build/three.webgpu.js",
            "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
        }
    }
    </script>

    <script src="../../assets/js/demo-utils.js"></script>
    <script type="module">
        import * as THREE from 'three';

        // Initialize demo utilities
        const fps = new FPSCounter({ position: 'top-right' });
        const errorMgr = new ErrorManager();
        setupGlobalErrorHandler((msg, details) => errorMgr.show(msg, details));
        fps.start();

        const canvas = document.getElementById('canvas');
        const width = 512;
        const height = 512;

        canvas.width = width;
        canvas.height = height;

        // Setup renderer
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
        renderer.setSize(width, height);

        // Parameters for spot patterns
        const params = {
            dA: 1.0,
            dB: 0.5,
            feed: 0.054,
            kill: 0.063
        };

        // Create data textures for chemicals A and B
        const size = 512;
        const data = new Float32Array(size * size * 4);

        // Initialize: A=1, B=0 everywhere
        for (let i = 0; i < size * size; i++) {
            data[i * 4 + 0] = 1.0; // A
            data[i * 4 + 1] = 0.0; // B
            data[i * 4 + 2] = 0.0;
            data[i * 4 + 3] = 1.0;
        }

        // Add clustered B seeds for spot formation
        for (let i = 0; i < 50; i++) {
            const cx = Math.floor(Math.random() * size);
            const cy = Math.floor(Math.random() * size);

            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    const x = (cx + dx + size) % size;
                    const y = (cy + dy + size) % size;
                    const idx = (y * size + x) * 4;
                    data[idx + 1] = Math.random(); // B
                }
            }
        }

        const texture1 = new THREE.DataTexture(data, size, size, THREE.RGBAFormat, THREE.FloatType);
        texture1.needsUpdate = true;
        texture1.minFilter = THREE.NearestFilter;
        texture1.magFilter = THREE.NearestFilter;
        texture1.wrapS = THREE.RepeatWrapping;
        texture1.wrapT = THREE.RepeatWrapping;

        // Create render targets for ping-pong rendering
        const rtOptions = {
            minFilter: THREE.NearestFilter,
            magFilter: THREE.NearestFilter,
            wrapS: THREE.RepeatWrapping,
            wrapT: THREE.RepeatWrapping,
            format: THREE.RGBAFormat,
            type: THREE.FloatType
        };

        const rt1 = new THREE.WebGLRenderTarget(size, size, rtOptions);
        const rt2 = new THREE.WebGLRenderTarget(size, size, rtOptions);

        // Initialize render targets
        const initScene = new THREE.Scene();
        const initMaterial = new THREE.MeshBasicMaterial({ map: texture1 });
        const initMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), initMaterial);
        initScene.add(initMesh);
        const initCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        renderer.setRenderTarget(rt1);
        renderer.render(initScene, initCamera);
        renderer.setRenderTarget(rt2);
        renderer.render(initScene, initCamera);
        renderer.setRenderTarget(null);

        // Compute shader for reaction-diffusion
        const computeShader = `
            uniform sampler2D uTexture;
            uniform vec2 uResolution;
            uniform float uDa;
            uniform float uDb;
            uniform float uFeed;
            uniform float uKill;
            varying vec2 vUv;

            void main() {
                vec2 texel = 1.0 / uResolution;

                vec4 center = texture2D(uTexture, vUv);
                float a = center.r;
                float b = center.g;

                // Compute Laplacian
                float laplacianA = a * -1.0;
                float laplacianB = b * -1.0;

                // Cardinals
                vec4 n = texture2D(uTexture, vUv + vec2(0.0, texel.y));
                vec4 s = texture2D(uTexture, vUv + vec2(0.0, -texel.y));
                vec4 e = texture2D(uTexture, vUv + vec2(texel.x, 0.0));
                vec4 w = texture2D(uTexture, vUv + vec2(-texel.x, 0.0));

                laplacianA += (n.r + s.r + e.r + w.r) * 0.2;
                laplacianB += (n.g + s.g + e.g + w.g) * 0.2;

                // Diagonals
                vec4 ne = texture2D(uTexture, vUv + vec2(texel.x, texel.y));
                vec4 nw = texture2D(uTexture, vUv + vec2(-texel.x, texel.y));
                vec4 se = texture2D(uTexture, vUv + vec2(texel.x, -texel.y));
                vec4 sw = texture2D(uTexture, vUv + vec2(-texel.x, -texel.y));

                laplacianA += (ne.r + nw.r + se.r + sw.r) * 0.05;
                laplacianB += (ne.g + nw.g + se.g + sw.g) * 0.05;

                // Gray-Scott equations
                float reaction = a * b * b;
                float deltaA = uDa * laplacianA - reaction + uFeed * (1.0 - a);
                float deltaB = uDb * laplacianB + reaction - (uKill + uFeed) * b;

                float newA = clamp(a + deltaA, 0.0, 1.0);
                float newB = clamp(b + deltaB, 0.0, 1.0);

                gl_FragColor = vec4(newA, newB, 0.0, 1.0);
            }
        `;

        const computeMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTexture: { value: rt1.texture },
                uResolution: { value: new THREE.Vector2(size, size) },
                uDa: { value: params.dA },
                uDb: { value: params.dB },
                uFeed: { value: params.feed },
                uKill: { value: params.kill }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: computeShader
        });

        const computeScene = new THREE.Scene();
        const computeMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), computeMaterial);
        computeScene.add(computeMesh);
        const computeCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // Display shader with leopard spot coloring
        const displayMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTexture: { value: rt1.texture }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D uTexture;
                varying vec2 vUv;

                void main() {
                    vec4 texel = texture2D(uTexture, vUv);
                    float a = texel.r;
                    float b = texel.g;
                    float value = a - b;

                    // Leopard/cheetah color scheme
                    vec3 color = vec3(value * 1.1, value * 0.8, value * 0.4);
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });

        const displayScene = new THREE.Scene();
        const displayMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), displayMaterial);
        displayScene.add(displayMesh);
        const displayCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // Animation loop
        let currentTarget = rt1;
        let nextTarget = rt2;

        function animate() {
            fps.update();
            // Run multiple compute iterations per frame
            for (let i = 0; i < 8; i++) {
                computeMaterial.uniforms.uTexture.value = currentTarget.texture;
                renderer.setRenderTarget(nextTarget);
                renderer.render(computeScene, computeCamera);

                [currentTarget, nextTarget] = [nextTarget, currentTarget];
            }

            // Display result
            displayMaterial.uniforms.uTexture.value = currentTarget.texture;
            renderer.setRenderTarget(null);
            renderer.render(displayScene, displayCamera);

            requestAnimationFrame(animate);
        }

        // Expose for enhance.js
        window.reset = function() { gl.clear(gl.COLOR_BUFFER_BIT); };

        animate();
    </script>
    <script src="../../assets/js/enhance.js" defer></script>
</body>
</html>
