<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Colorful Boids with Trails - GPU Accelerated</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 10;
        }
        .info h3 {
            margin: 0 0 10px 0;
        }
        .info p {
            margin: 5px 0;
        }
        .tech-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }
        .stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="info">
        <h3>GPU-Accelerated Colorful Boids with Trails</h3>
        <p>Each boid has a unique color and leaves a glowing trail</p>
        <p style="font-size: 11px; opacity: 0.8;">1500+ boids • GPU instanced rendering • Trail effects</p>
    </div>
    <div class="tech-badge">GPU-Accelerated • Three.js TSL • Particle Systems • Trail Effects</div>
    <div class="stats">
        <div>Boids: <span id="boidCount">1536</span></div>
        <div>FPS: <span id="fps">60</span></div>
    </div>
    <div id="container">
        <canvas id="trailCanvas"></canvas>
        <canvas id="boidCanvas"></canvas>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
            "three/nodes": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { color, positionLocal, attribute, cos, sin, vec3 } from 'three/nodes';

        // Configuration
        const BOID_COUNT = 1536;
        const BOUNDS = { x: 1200, y: 800, z: 400 };
        const MAX_TRAIL_LENGTH = 30;

        // Boid parameters
        const params = {
            separationDistance: 40,
            perceptionRadius: 80,
            maxSpeed: 3.5,
            maxForce: 0.2,
            separationWeight: 1.5,
            alignmentWeight: 1.0,
            cohesionWeight: 1.0
        };

        // Setup canvases
        const container = document.getElementById('container');
        const trailCanvas = document.getElementById('trailCanvas');
        const boidCanvas = document.getElementById('boidCanvas');
        const trailCtx = trailCanvas.getContext('2d');

        trailCanvas.width = boidCanvas.width = window.innerWidth;
        trailCanvas.height = boidCanvas.height = window.innerHeight;

        // Initialize Three.js renderer for boids
        const renderer = new THREE.WebGLRenderer({
            canvas: boidCanvas,
            antialias: true,
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // Scene and camera
        const scene = new THREE.Scene();

        const camera = new THREE.OrthographicCamera(
            -BOUNDS.x / 2, BOUNDS.x / 2,
            BOUNDS.y / 2, -BOUNDS.y / 2,
            1, 1000
        );
        camera.position.set(0, 0, 500);
        camera.lookAt(0, 0, 0);

        // Create boid geometry
        const boidGeometry = new THREE.BufferGeometry();
        const vertices = new Float32Array([
            10, 0, 0,
            -8, 5, 0,
            -8, -5, 0
        ]);
        boidGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

        // Create TSL-based material
        const instancePositionAttr = attribute('instancePosition', 'vec3');
        const instanceAngleAttr = attribute('instanceAngle', 'float');
        const instanceColorAttr = attribute('instanceColor', 'vec3');

        const angle = instanceAngleAttr;
        const cosAngle = cos(angle);
        const sinAngle = sin(angle);

        const rotatedX = positionLocal.x.mul(cosAngle).sub(positionLocal.y.mul(sinAngle));
        const rotatedY = positionLocal.x.mul(sinAngle).add(positionLocal.y.mul(cosAngle));
        const rotatedPos = vec3(rotatedX, rotatedY, positionLocal.z);

        const finalPosition = rotatedPos.add(instancePositionAttr);

        const boidMaterial = new THREE.MeshBasicNodeMaterial({
            transparent: true,
            opacity: 0.9
        });
        boidMaterial.positionNode = finalPosition;
        boidMaterial.colorNode = color(instanceColorAttr);

        const instancedMesh = new THREE.InstancedMesh(boidGeometry, boidMaterial, BOID_COUNT);
        scene.add(instancedMesh);

        // Trail system
        class TrailRenderer {
            constructor(count) {
                this.trails = new Array(count);
                for (let i = 0; i < count; i++) {
                    this.trails[i] = [];
                }
            }

            addPosition(index, x, y, color) {
                this.trails[index].push({ x, y, color });
                if (this.trails[index].length > MAX_TRAIL_LENGTH) {
                    this.trails[index].shift();
                }
            }

            render() {
                // Fade effect
                trailCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                trailCtx.fillRect(0, 0, trailCanvas.width, trailCanvas.height);

                const centerX = trailCanvas.width / 2;
                const centerY = trailCanvas.height / 2;
                const scaleX = trailCanvas.width / BOUNDS.x;
                const scaleY = trailCanvas.height / BOUNDS.y;

                for (let i = 0; i < this.trails.length; i++) {
                    const trail = this.trails[i];
                    if (trail.length < 2) continue;

                    for (let j = 0; j < trail.length - 1; j++) {
                        const alpha = j / trail.length;
                        const p1 = trail[j];
                        const p2 = trail[j + 1];

                        const x1 = centerX + p1.x * scaleX;
                        const y1 = centerY - p1.y * scaleY;
                        const x2 = centerX + p2.x * scaleX;
                        const y2 = centerY - p2.y * scaleY;

                        trailCtx.strokeStyle = `rgba(${p1.color.r * 255}, ${p1.color.g * 255}, ${p1.color.b * 255}, ${alpha * 0.6})`;
                        trailCtx.lineWidth = 2;
                        trailCtx.beginPath();
                        trailCtx.moveTo(x1, y1);
                        trailCtx.lineTo(x2, y2);
                        trailCtx.stroke();

                        // Glow effect
                        trailCtx.shadowBlur = 10;
                        trailCtx.shadowColor = `rgba(${p1.color.r * 255}, ${p1.color.g * 255}, ${p1.color.b * 255}, ${alpha * 0.5})`;
                    }
                }

                trailCtx.shadowBlur = 0;
            }
        }

        // Boid system
        class BoidSystem {
            constructor(count) {
                this.count = count;
                this.positions = new Float32Array(count * 3);
                this.velocities = new Float32Array(count * 3);
                this.colors = new Float32Array(count * 3);

                this.instancePositions = new Float32Array(count * 3);
                this.instanceAngles = new Float32Array(count);
                this.instanceColors = new Float32Array(count * 3);

                // Initialize
                for (let i = 0; i < count; i++) {
                    this.positions[i * 3] = (Math.random() - 0.5) * BOUNDS.x;
                    this.positions[i * 3 + 1] = (Math.random() - 0.5) * BOUNDS.y;
                    this.positions[i * 3 + 2] = (Math.random() - 0.5) * BOUNDS.z;

                    this.velocities[i * 3] = (Math.random() - 0.5) * 4;
                    this.velocities[i * 3 + 1] = (Math.random() - 0.5) * 4;
                    this.velocities[i * 3 + 2] = (Math.random() - 0.5) * 2;

                    const hue = (i / count) * 360;
                    const color = new THREE.Color(`hsl(${hue}, 100%, 60%)`);
                    this.colors[i * 3] = color.r;
                    this.colors[i * 3 + 1] = color.g;
                    this.colors[i * 3 + 2] = color.b;
                }

                boidGeometry.setAttribute('instancePosition',
                    new THREE.InstancedBufferAttribute(this.instancePositions, 3));
                boidGeometry.setAttribute('instanceAngle',
                    new THREE.InstancedBufferAttribute(this.instanceAngles, 1));
                boidGeometry.setAttribute('instanceColor',
                    new THREE.InstancedBufferAttribute(this.instanceColors, 3));

                this.updateInstanceAttributes();
            }

            updateInstanceAttributes() {
                for (let i = 0; i < this.count; i++) {
                    this.instancePositions[i * 3] = this.positions[i * 3];
                    this.instancePositions[i * 3 + 1] = this.positions[i * 3 + 1];
                    this.instancePositions[i * 3 + 2] = this.positions[i * 3 + 2];

                    const vx = this.velocities[i * 3];
                    const vy = this.velocities[i * 3 + 1];
                    this.instanceAngles[i] = Math.atan2(vy, vx);

                    this.instanceColors[i * 3] = this.colors[i * 3];
                    this.instanceColors[i * 3 + 1] = this.colors[i * 3 + 1];
                    this.instanceColors[i * 3 + 2] = this.colors[i * 3 + 2];
                }

                boidGeometry.attributes.instancePosition.needsUpdate = true;
                boidGeometry.attributes.instanceAngle.needsUpdate = true;
                boidGeometry.attributes.instanceColor.needsUpdate = true;
            }

            getSpatialHash(x, y, z, cellSize) {
                const cx = Math.floor(x / cellSize);
                const cy = Math.floor(y / cellSize);
                const cz = Math.floor(z / cellSize);
                return `${cx},${cy},${cz}`;
            }

            buildSpatialHash(cellSize) {
                const hash = new Map();
                for (let i = 0; i < this.count; i++) {
                    const key = this.getSpatialHash(
                        this.positions[i * 3],
                        this.positions[i * 3 + 1],
                        this.positions[i * 3 + 2],
                        cellSize
                    );
                    if (!hash.has(key)) {
                        hash.set(key, []);
                    }
                    hash.get(key).push(i);
                }
                return hash;
            }

            getNeighborCells(x, y, z, cellSize) {
                const cells = [];
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            const cx = Math.floor(x / cellSize) + dx;
                            const cy = Math.floor(y / cellSize) + dy;
                            const cz = Math.floor(z / cellSize) + dz;
                            cells.push(`${cx},${cy},${cz}`);
                        }
                    }
                }
                return cells;
            }

            update() {
                const cellSize = params.perceptionRadius * 1.5;
                const spatialHash = this.buildSpatialHash(cellSize);
                const accelerations = new Float32Array(this.count * 3);

                for (let i = 0; i < this.count; i++) {
                    const px = this.positions[i * 3];
                    const py = this.positions[i * 3 + 1];
                    const pz = this.positions[i * 3 + 2];
                    const vx = this.velocities[i * 3];
                    const vy = this.velocities[i * 3 + 1];
                    const vz = this.velocities[i * 3 + 2];

                    let sepX = 0, sepY = 0, sepZ = 0, sepCount = 0;
                    let alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
                    let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;

                    const neighborCells = this.getNeighborCells(px, py, pz, cellSize);

                    for (const cellKey of neighborCells) {
                        const cellBoids = spatialHash.get(cellKey);
                        if (!cellBoids) continue;

                        for (const j of cellBoids) {
                            if (i === j) continue;

                            const ox = this.positions[j * 3];
                            const oy = this.positions[j * 3 + 1];
                            const oz = this.positions[j * 3 + 2];
                            const dx = px - ox;
                            const dy = py - oy;
                            const dz = pz - oz;
                            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                            if (dist < params.perceptionRadius && dist > 0) {
                                if (dist < params.separationDistance) {
                                    sepX += dx / dist;
                                    sepY += dy / dist;
                                    sepZ += dz / dist;
                                    sepCount++;
                                }

                                alignX += this.velocities[j * 3];
                                alignY += this.velocities[j * 3 + 1];
                                alignZ += this.velocities[j * 3 + 2];
                                alignCount++;

                                cohX += ox;
                                cohY += oy;
                                cohZ += oz;
                                cohCount++;
                            }
                        }
                    }

                    let ax = 0, ay = 0, az = 0;

                    if (sepCount > 0) {
                        sepX /= sepCount;
                        sepY /= sepCount;
                        sepZ /= sepCount;
                        const mag = Math.sqrt(sepX * sepX + sepY * sepY + sepZ * sepZ);
                        if (mag > 0) {
                            sepX = (sepX / mag) * params.maxSpeed - vx;
                            sepY = (sepY / mag) * params.maxSpeed - vy;
                            sepZ = (sepZ / mag) * params.maxSpeed - vz;
                            const steerMag = Math.sqrt(sepX * sepX + sepY * sepY + sepZ * sepZ);
                            if (steerMag > params.maxForce) {
                                sepX = (sepX / steerMag) * params.maxForce;
                                sepY = (sepY / steerMag) * params.maxForce;
                                sepZ = (sepZ / steerMag) * params.maxForce;
                            }
                            ax += sepX * params.separationWeight;
                            ay += sepY * params.separationWeight;
                            az += sepZ * params.separationWeight;
                        }
                    }

                    if (alignCount > 0) {
                        alignX /= alignCount;
                        alignY /= alignCount;
                        alignZ /= alignCount;
                        const mag = Math.sqrt(alignX * alignX + alignY * alignY + alignZ * alignZ);
                        if (mag > 0) {
                            alignX = (alignX / mag) * params.maxSpeed - vx;
                            alignY = (alignY / mag) * params.maxSpeed - vy;
                            alignZ = (alignZ / mag) * params.maxSpeed - vz;
                            const steerMag = Math.sqrt(alignX * alignX + alignY * alignY + alignZ * alignZ);
                            if (steerMag > params.maxForce) {
                                alignX = (alignX / steerMag) * params.maxForce;
                                alignY = (alignY / steerMag) * params.maxForce;
                                alignZ = (alignZ / steerMag) * params.maxForce;
                            }
                            ax += alignX * params.alignmentWeight;
                            ay += alignY * params.alignmentWeight;
                            az += alignZ * params.alignmentWeight;
                        }
                    }

                    if (cohCount > 0) {
                        cohX = cohX / cohCount - px;
                        cohY = cohY / cohCount - py;
                        cohZ = cohZ / cohCount - pz;
                        const mag = Math.sqrt(cohX * cohX + cohY * cohY + cohZ * cohZ);
                        if (mag > 0) {
                            cohX = (cohX / mag) * params.maxSpeed - vx;
                            cohY = (cohY / mag) * params.maxSpeed - vy;
                            cohZ = (cohZ / mag) * params.maxSpeed - vz;
                            const steerMag = Math.sqrt(cohX * cohX + cohY * cohY + cohZ * cohZ);
                            if (steerMag > params.maxForce) {
                                cohX = (cohX / steerMag) * params.maxForce;
                                cohY = (cohY / steerMag) * params.maxForce;
                                cohZ = (cohZ / steerMag) * params.maxForce;
                            }
                            ax += cohX * params.cohesionWeight;
                            ay += cohY * params.cohesionWeight;
                            az += cohZ * params.cohesionWeight;
                        }
                    }

                    accelerations[i * 3] = ax;
                    accelerations[i * 3 + 1] = ay;
                    accelerations[i * 3 + 2] = az;
                }

                for (let i = 0; i < this.count; i++) {
                    this.velocities[i * 3] += accelerations[i * 3];
                    this.velocities[i * 3 + 1] += accelerations[i * 3 + 1];
                    this.velocities[i * 3 + 2] += accelerations[i * 3 + 2];

                    const speed = Math.sqrt(
                        this.velocities[i * 3] ** 2 +
                        this.velocities[i * 3 + 1] ** 2 +
                        this.velocities[i * 3 + 2] ** 2
                    );
                    if (speed > params.maxSpeed) {
                        this.velocities[i * 3] = (this.velocities[i * 3] / speed) * params.maxSpeed;
                        this.velocities[i * 3 + 1] = (this.velocities[i * 3 + 1] / speed) * params.maxSpeed;
                        this.velocities[i * 3 + 2] = (this.velocities[i * 3 + 2] / speed) * params.maxSpeed;
                    }

                    this.positions[i * 3] += this.velocities[i * 3];
                    this.positions[i * 3 + 1] += this.velocities[i * 3 + 1];
                    this.positions[i * 3 + 2] += this.velocities[i * 3 + 2];

                    if (this.positions[i * 3] > BOUNDS.x / 2) this.positions[i * 3] = -BOUNDS.x / 2;
                    else if (this.positions[i * 3] < -BOUNDS.x / 2) this.positions[i * 3] = BOUNDS.x / 2;
                    if (this.positions[i * 3 + 1] > BOUNDS.y / 2) this.positions[i * 3 + 1] = -BOUNDS.y / 2;
                    else if (this.positions[i * 3 + 1] < -BOUNDS.y / 2) this.positions[i * 3 + 1] = BOUNDS.y / 2;
                    if (this.positions[i * 3 + 2] > BOUNDS.z / 2) this.positions[i * 3 + 2] = -BOUNDS.z / 2;
                    else if (this.positions[i * 3 + 2] < -BOUNDS.z / 2) this.positions[i * 3 + 2] = BOUNDS.z / 2;

                    // Add to trail
                    trailRenderer.addPosition(i,
                        this.positions[i * 3],
                        this.positions[i * 3 + 1],
                        {
                            r: this.colors[i * 3],
                            g: this.colors[i * 3 + 1],
                            b: this.colors[i * 3 + 2]
                        }
                    );
                }

                this.updateInstanceAttributes();
            }
        }

        const boidSystem = new BoidSystem(BOID_COUNT);
        const trailRenderer = new TrailRenderer(BOID_COUNT);

        // FPS counter
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 60;

        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            if (currentTime >= lastTime + 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            boidSystem.update();
            trailRenderer.render();
            updateFPS();

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            trailCanvas.width = boidCanvas.width = window.innerWidth;
            trailCanvas.height = boidCanvas.height = window.innerHeight;

            camera.left = -BOUNDS.x / 2;
            camera.right = BOUNDS.x / 2;
            camera.top = BOUNDS.y / 2;
            camera.bottom = -BOUNDS.y / 2;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
