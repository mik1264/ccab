<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Predator-Prey Boids - GPU Accelerated</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            font-family: Arial, sans-serif;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 10;
        }
        .info h3 {
            margin: 0 0 10px 0;
        }
        .info p {
            margin: 5px 0;
        }
        .tech-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }
        .stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="info">
        <h3>GPU-Accelerated Predator-Prey Boids</h3>
        <p><span style="color: #4fc3f7;">Prey</span> flock together and flee from <span style="color: #f44336;">Predators</span></p>
        <p><span style="color: #f44336;">Predators</span> hunt the nearest prey</p>
        <p style="font-size: 11px; opacity: 0.8;">1800+ boids • GPU instanced rendering • Two species simulation</p>
    </div>
    <div class="tech-badge">GPU-Accelerated • Three.js TSL • Particle Systems • Predator-Prey</div>
    <div class="stats">
        <div>Prey: <span id="preyCount">1536</span></div>
        <div>Predators: <span id="predCount">256</span></div>
        <div>FPS: <span id="fps">60</span></div>
    </div>
    <div id="container"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
            "three/nodes": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/nodes/Nodes.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { color, positionLocal, attribute, cos, sin, vec3 } from 'three/nodes';

        // Configuration
        const PREY_COUNT = 1536;
        const PREDATOR_COUNT = 256;
        const BOUNDS = { x: 1200, y: 800, z: 400 };

        // Parameters
        const preyParams = {
            separationDistance: 35,
            perceptionRadius: 100,
            fearRadius: 150,
            maxSpeed: 5,
            maxForce: 0.3,
            separationWeight: 1.5,
            alignmentWeight: 1.0,
            cohesionWeight: 1.0,
            fleeWeight: 3.0
        };

        const predatorParams = {
            huntRadius: 200,
            maxSpeed: 4,
            maxForce: 0.4
        };

        // Initialize renderer
        const container = document.getElementById('container');
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Scene and camera
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f2027);

        const camera = new THREE.OrthographicCamera(
            -BOUNDS.x / 2, BOUNDS.x / 2,
            BOUNDS.y / 2, -BOUNDS.y / 2,
            1, 1000
        );
        camera.position.set(0, 0, 500);
        camera.lookAt(0, 0, 0);

        // Create prey geometry (small triangle)
        const preyGeometry = new THREE.BufferGeometry();
        const preyVertices = new Float32Array([
            6, 0, 0,
            -6, 3, 0,
            -6, -3, 0
        ]);
        preyGeometry.setAttribute('position', new THREE.BufferAttribute(preyVertices, 3));

        // Create predator geometry (larger triangle)
        const predatorGeometry = new THREE.BufferGeometry();
        const predatorVertices = new Float32Array([
            10, 0, 0,
            -10, 6, 0,
            -5, 0, 0,
            -10, -6, 0
        ]);
        predatorGeometry.setAttribute('position', new THREE.BufferAttribute(predatorVertices, 3));
        predatorGeometry.setIndex([0, 1, 2, 0, 2, 3]);

        // TSL material setup for prey
        const preyInstancePositionAttr = attribute('instancePosition', 'vec3');
        const preyInstanceAngleAttr = attribute('instanceAngle', 'float');

        const preyAngle = preyInstanceAngleAttr;
        const preyCosAngle = cos(preyAngle);
        const preySinAngle = sin(preyAngle);

        const preyRotatedX = positionLocal.x.mul(preyCosAngle).sub(positionLocal.y.mul(preySinAngle));
        const preyRotatedY = positionLocal.x.mul(preySinAngle).add(positionLocal.y.mul(preyCosAngle));
        const preyRotatedPos = vec3(preyRotatedX, preyRotatedY, positionLocal.z);
        const preyFinalPosition = preyRotatedPos.add(preyInstancePositionAttr);

        const preyMaterial = new THREE.MeshBasicNodeMaterial({
            transparent: true,
            opacity: 0.9
        });
        preyMaterial.positionNode = preyFinalPosition;
        preyMaterial.colorNode = color(new THREE.Color(0x4fc3f7));

        const preyMesh = new THREE.InstancedMesh(preyGeometry, preyMaterial, PREY_COUNT);
        scene.add(preyMesh);

        // TSL material setup for predators
        const predInstancePositionAttr = attribute('instancePosition', 'vec3');
        const predInstanceAngleAttr = attribute('instanceAngle', 'float');

        const predAngle = predInstanceAngleAttr;
        const predCosAngle = cos(predAngle);
        const predSinAngle = sin(predAngle);

        const predRotatedX = positionLocal.x.mul(predCosAngle).sub(positionLocal.y.mul(predSinAngle));
        const predRotatedY = positionLocal.x.mul(predSinAngle).add(positionLocal.y.mul(predCosAngle));
        const predRotatedPos = vec3(predRotatedX, predRotatedY, positionLocal.z);
        const predFinalPosition = predRotatedPos.add(predInstancePositionAttr);

        const predatorMaterial = new THREE.MeshBasicNodeMaterial({
            transparent: true,
            opacity: 0.95
        });
        predatorMaterial.positionNode = predFinalPosition;
        predatorMaterial.colorNode = color(new THREE.Color(0xf44336));

        const predatorMesh = new THREE.InstancedMesh(predatorGeometry, predatorMaterial, PREDATOR_COUNT);
        scene.add(predatorMesh);

        // Prey system
        class PreySystem {
            constructor(count, predatorSystem) {
                this.count = count;
                this.predatorSystem = predatorSystem;
                this.positions = new Float32Array(count * 3);
                this.velocities = new Float32Array(count * 3);

                this.instancePositions = new Float32Array(count * 3);
                this.instanceAngles = new Float32Array(count);

                for (let i = 0; i < count; i++) {
                    this.positions[i * 3] = (Math.random() - 0.5) * BOUNDS.x;
                    this.positions[i * 3 + 1] = (Math.random() - 0.5) * BOUNDS.y;
                    this.positions[i * 3 + 2] = (Math.random() - 0.5) * BOUNDS.z;

                    this.velocities[i * 3] = (Math.random() - 0.5) * 4;
                    this.velocities[i * 3 + 1] = (Math.random() - 0.5) * 4;
                    this.velocities[i * 3 + 2] = (Math.random() - 0.5) * 2;
                }

                preyGeometry.setAttribute('instancePosition',
                    new THREE.InstancedBufferAttribute(this.instancePositions, 3));
                preyGeometry.setAttribute('instanceAngle',
                    new THREE.InstancedBufferAttribute(this.instanceAngles, 1));

                this.updateInstanceAttributes();
            }

            updateInstanceAttributes() {
                for (let i = 0; i < this.count; i++) {
                    this.instancePositions[i * 3] = this.positions[i * 3];
                    this.instancePositions[i * 3 + 1] = this.positions[i * 3 + 1];
                    this.instancePositions[i * 3 + 2] = this.positions[i * 3 + 2];

                    const vx = this.velocities[i * 3];
                    const vy = this.velocities[i * 3 + 1];
                    this.instanceAngles[i] = Math.atan2(vy, vx);
                }

                preyGeometry.attributes.instancePosition.needsUpdate = true;
                preyGeometry.attributes.instanceAngle.needsUpdate = true;
            }

            update() {
                const accelerations = new Float32Array(this.count * 3);

                for (let i = 0; i < this.count; i++) {
                    const px = this.positions[i * 3];
                    const py = this.positions[i * 3 + 1];
                    const pz = this.positions[i * 3 + 2];
                    const vx = this.velocities[i * 3];
                    const vy = this.velocities[i * 3 + 1];
                    const vz = this.velocities[i * 3 + 2];

                    let alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
                    let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;
                    let fleeX = 0, fleeY = 0, fleeZ = 0, fleeCount = 0;

                    // Flocking with other prey
                    for (let j = 0; j < this.count; j++) {
                        if (i === j) continue;

                        const ox = this.positions[j * 3];
                        const oy = this.positions[j * 3 + 1];
                        const oz = this.positions[j * 3 + 2];
                        const dx = px - ox;
                        const dy = py - oy;
                        const dz = pz - oz;
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                        if (dist < preyParams.perceptionRadius && dist > 0) {
                            alignX += this.velocities[j * 3];
                            alignY += this.velocities[j * 3 + 1];
                            alignZ += this.velocities[j * 3 + 2];
                            alignCount++;

                            cohX += ox;
                            cohY += oy;
                            cohZ += oz;
                            cohCount++;
                        }
                    }

                    // Flee from predators
                    for (let j = 0; j < this.predatorSystem.count; j++) {
                        const ox = this.predatorSystem.positions[j * 3];
                        const oy = this.predatorSystem.positions[j * 3 + 1];
                        const oz = this.predatorSystem.positions[j * 3 + 2];
                        const dx = px - ox;
                        const dy = py - oy;
                        const dz = pz - oz;
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                        if (dist < preyParams.fearRadius && dist > 0) {
                            fleeX += dx / (dist * dist);
                            fleeY += dy / (dist * dist);
                            fleeZ += dz / (dist * dist);
                            fleeCount++;
                        }
                    }

                    let ax = 0, ay = 0, az = 0;

                    // Alignment
                    if (alignCount > 0) {
                        alignX /= alignCount;
                        alignY /= alignCount;
                        alignZ /= alignCount;
                        const mag = Math.sqrt(alignX * alignX + alignY * alignY + alignZ * alignZ);
                        if (mag > 0) {
                            alignX = (alignX / mag) * preyParams.maxSpeed - vx;
                            alignY = (alignY / mag) * preyParams.maxSpeed - vy;
                            alignZ = (alignZ / mag) * preyParams.maxSpeed - vz;
                            const steerMag = Math.sqrt(alignX * alignX + alignY * alignY + alignZ * alignZ);
                            if (steerMag > preyParams.maxForce) {
                                alignX = (alignX / steerMag) * preyParams.maxForce;
                                alignY = (alignY / steerMag) * preyParams.maxForce;
                                alignZ = (alignZ / steerMag) * preyParams.maxForce;
                            }
                            ax += alignX * preyParams.alignmentWeight;
                            ay += alignY * preyParams.alignmentWeight;
                            az += alignZ * preyParams.alignmentWeight;
                        }
                    }

                    // Cohesion
                    if (cohCount > 0) {
                        cohX = cohX / cohCount - px;
                        cohY = cohY / cohCount - py;
                        cohZ = cohZ / cohCount - pz;
                        const mag = Math.sqrt(cohX * cohX + cohY * cohY + cohZ * cohZ);
                        if (mag > 0) {
                            cohX = (cohX / mag) * preyParams.maxSpeed - vx;
                            cohY = (cohY / mag) * preyParams.maxSpeed - vy;
                            cohZ = (cohZ / mag) * preyParams.maxSpeed - vz;
                            const steerMag = Math.sqrt(cohX * cohX + cohY * cohY + cohZ * cohZ);
                            if (steerMag > preyParams.maxForce) {
                                cohX = (cohX / steerMag) * preyParams.maxForce;
                                cohY = (cohY / steerMag) * preyParams.maxForce;
                                cohZ = (cohZ / steerMag) * preyParams.maxForce;
                            }
                            ax += cohX * preyParams.cohesionWeight;
                            ay += cohY * preyParams.cohesionWeight;
                            az += cohZ * preyParams.cohesionWeight;
                        }
                    }

                    // Flee
                    if (fleeCount > 0) {
                        fleeX /= fleeCount;
                        fleeY /= fleeCount;
                        fleeZ /= fleeCount;
                        const mag = Math.sqrt(fleeX * fleeX + fleeY * fleeY + fleeZ * fleeZ);
                        if (mag > 0) {
                            fleeX = (fleeX / mag) * preyParams.maxSpeed - vx;
                            fleeY = (fleeY / mag) * preyParams.maxSpeed - vy;
                            fleeZ = (fleeZ / mag) * preyParams.maxSpeed - vz;
                            const steerMag = Math.sqrt(fleeX * fleeX + fleeY * fleeY + fleeZ * fleeZ);
                            if (steerMag > preyParams.maxForce * 3) {
                                fleeX = (fleeX / steerMag) * preyParams.maxForce * 3;
                                fleeY = (fleeY / steerMag) * preyParams.maxForce * 3;
                                fleeZ = (fleeZ / steerMag) * preyParams.maxForce * 3;
                            }
                            ax += fleeX * preyParams.fleeWeight;
                            ay += fleeY * preyParams.fleeWeight;
                            az += fleeZ * preyParams.fleeWeight;
                        }
                    }

                    accelerations[i * 3] = ax;
                    accelerations[i * 3 + 1] = ay;
                    accelerations[i * 3 + 2] = az;
                }

                for (let i = 0; i < this.count; i++) {
                    this.velocities[i * 3] += accelerations[i * 3];
                    this.velocities[i * 3 + 1] += accelerations[i * 3 + 1];
                    this.velocities[i * 3 + 2] += accelerations[i * 3 + 2];

                    const speed = Math.sqrt(
                        this.velocities[i * 3] ** 2 +
                        this.velocities[i * 3 + 1] ** 2 +
                        this.velocities[i * 3 + 2] ** 2
                    );
                    if (speed > preyParams.maxSpeed) {
                        this.velocities[i * 3] = (this.velocities[i * 3] / speed) * preyParams.maxSpeed;
                        this.velocities[i * 3 + 1] = (this.velocities[i * 3 + 1] / speed) * preyParams.maxSpeed;
                        this.velocities[i * 3 + 2] = (this.velocities[i * 3 + 2] / speed) * preyParams.maxSpeed;
                    }

                    this.positions[i * 3] += this.velocities[i * 3];
                    this.positions[i * 3 + 1] += this.velocities[i * 3 + 1];
                    this.positions[i * 3 + 2] += this.velocities[i * 3 + 2];

                    if (this.positions[i * 3] > BOUNDS.x / 2) this.positions[i * 3] = -BOUNDS.x / 2;
                    else if (this.positions[i * 3] < -BOUNDS.x / 2) this.positions[i * 3] = BOUNDS.x / 2;
                    if (this.positions[i * 3 + 1] > BOUNDS.y / 2) this.positions[i * 3 + 1] = -BOUNDS.y / 2;
                    else if (this.positions[i * 3 + 1] < -BOUNDS.y / 2) this.positions[i * 3 + 1] = BOUNDS.y / 2;
                    if (this.positions[i * 3 + 2] > BOUNDS.z / 2) this.positions[i * 3 + 2] = -BOUNDS.z / 2;
                    else if (this.positions[i * 3 + 2] < -BOUNDS.z / 2) this.positions[i * 3 + 2] = BOUNDS.z / 2;
                }

                this.updateInstanceAttributes();
            }
        }

        // Predator system
        class PredatorSystem {
            constructor(count, preySystem) {
                this.count = count;
                this.preySystem = preySystem;
                this.positions = new Float32Array(count * 3);
                this.velocities = new Float32Array(count * 3);

                this.instancePositions = new Float32Array(count * 3);
                this.instanceAngles = new Float32Array(count);

                for (let i = 0; i < count; i++) {
                    this.positions[i * 3] = (Math.random() - 0.5) * BOUNDS.x;
                    this.positions[i * 3 + 1] = (Math.random() - 0.5) * BOUNDS.y;
                    this.positions[i * 3 + 2] = (Math.random() - 0.5) * BOUNDS.z;

                    this.velocities[i * 3] = (Math.random() - 0.5) * 3;
                    this.velocities[i * 3 + 1] = (Math.random() - 0.5) * 3;
                    this.velocities[i * 3 + 2] = (Math.random() - 0.5) * 2;
                }

                predatorGeometry.setAttribute('instancePosition',
                    new THREE.InstancedBufferAttribute(this.instancePositions, 3));
                predatorGeometry.setAttribute('instanceAngle',
                    new THREE.InstancedBufferAttribute(this.instanceAngles, 1));

                this.updateInstanceAttributes();
            }

            updateInstanceAttributes() {
                for (let i = 0; i < this.count; i++) {
                    this.instancePositions[i * 3] = this.positions[i * 3];
                    this.instancePositions[i * 3 + 1] = this.positions[i * 3 + 1];
                    this.instancePositions[i * 3 + 2] = this.positions[i * 3 + 2];

                    const vx = this.velocities[i * 3];
                    const vy = this.velocities[i * 3 + 1];
                    this.instanceAngles[i] = Math.atan2(vy, vx);
                }

                predatorGeometry.attributes.instancePosition.needsUpdate = true;
                predatorGeometry.attributes.instanceAngle.needsUpdate = true;
            }

            update() {
                const accelerations = new Float32Array(this.count * 3);

                for (let i = 0; i < this.count; i++) {
                    const px = this.positions[i * 3];
                    const py = this.positions[i * 3 + 1];
                    const pz = this.positions[i * 3 + 2];
                    const vx = this.velocities[i * 3];
                    const vy = this.velocities[i * 3 + 1];
                    const vz = this.velocities[i * 3 + 2];

                    // Hunt nearest prey
                    let closestDist = Infinity;
                    let targetX = 0, targetY = 0, targetZ = 0;

                    for (let j = 0; j < this.preySystem.count; j++) {
                        const ox = this.preySystem.positions[j * 3];
                        const oy = this.preySystem.positions[j * 3 + 1];
                        const oz = this.preySystem.positions[j * 3 + 2];
                        const dx = ox - px;
                        const dy = oy - py;
                        const dz = oz - pz;
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                        if (dist < closestDist && dist < predatorParams.huntRadius) {
                            closestDist = dist;
                            targetX = ox;
                            targetY = oy;
                            targetZ = oz;
                        }
                    }

                    let ax = 0, ay = 0, az = 0;

                    if (closestDist < predatorParams.huntRadius) {
                        let desiredX = targetX - px;
                        let desiredY = targetY - py;
                        let desiredZ = targetZ - pz;
                        const mag = Math.sqrt(desiredX * desiredX + desiredY * desiredY + desiredZ * desiredZ);

                        if (mag > 0) {
                            desiredX = (desiredX / mag) * predatorParams.maxSpeed;
                            desiredY = (desiredY / mag) * predatorParams.maxSpeed;
                            desiredZ = (desiredZ / mag) * predatorParams.maxSpeed;

                            let steerX = desiredX - vx;
                            let steerY = desiredY - vy;
                            let steerZ = desiredZ - vz;
                            const steerMag = Math.sqrt(steerX * steerX + steerY * steerY + steerZ * steerZ);

                            if (steerMag > predatorParams.maxForce) {
                                steerX = (steerX / steerMag) * predatorParams.maxForce;
                                steerY = (steerY / steerMag) * predatorParams.maxForce;
                                steerZ = (steerZ / steerMag) * predatorParams.maxForce;
                            }

                            ax += steerX;
                            ay += steerY;
                            az += steerZ;
                        }
                    }

                    accelerations[i * 3] = ax;
                    accelerations[i * 3 + 1] = ay;
                    accelerations[i * 3 + 2] = az;
                }

                for (let i = 0; i < this.count; i++) {
                    this.velocities[i * 3] += accelerations[i * 3];
                    this.velocities[i * 3 + 1] += accelerations[i * 3 + 1];
                    this.velocities[i * 3 + 2] += accelerations[i * 3 + 2];

                    const speed = Math.sqrt(
                        this.velocities[i * 3] ** 2 +
                        this.velocities[i * 3 + 1] ** 2 +
                        this.velocities[i * 3 + 2] ** 2
                    );
                    if (speed > predatorParams.maxSpeed) {
                        this.velocities[i * 3] = (this.velocities[i * 3] / speed) * predatorParams.maxSpeed;
                        this.velocities[i * 3 + 1] = (this.velocities[i * 3 + 1] / speed) * predatorParams.maxSpeed;
                        this.velocities[i * 3 + 2] = (this.velocities[i * 3 + 2] / speed) * predatorParams.maxSpeed;
                    }

                    this.positions[i * 3] += this.velocities[i * 3];
                    this.positions[i * 3 + 1] += this.velocities[i * 3 + 1];
                    this.positions[i * 3 + 2] += this.velocities[i * 3 + 2];

                    if (this.positions[i * 3] > BOUNDS.x / 2) this.positions[i * 3] = -BOUNDS.x / 2;
                    else if (this.positions[i * 3] < -BOUNDS.x / 2) this.positions[i * 3] = BOUNDS.x / 2;
                    if (this.positions[i * 3 + 1] > BOUNDS.y / 2) this.positions[i * 3 + 1] = -BOUNDS.y / 2;
                    else if (this.positions[i * 3 + 1] < -BOUNDS.y / 2) this.positions[i * 3 + 1] = BOUNDS.y / 2;
                    if (this.positions[i * 3 + 2] > BOUNDS.z / 2) this.positions[i * 3 + 2] = -BOUNDS.z / 2;
                    else if (this.positions[i * 3 + 2] < -BOUNDS.z / 2) this.positions[i * 3 + 2] = BOUNDS.z / 2;
                }

                this.updateInstanceAttributes();
            }
        }

        // Create systems with cross-references
        const predatorSystem = new PredatorSystem(PREDATOR_COUNT, null);
        const preySystem = new PreySystem(PREY_COUNT, predatorSystem);
        predatorSystem.preySystem = preySystem;

        // FPS counter
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 60;

        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            if (currentTime >= lastTime + 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            preySystem.update();
            predatorSystem.update();
            updateFPS();

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.left = -BOUNDS.x / 2;
            camera.right = BOUNDS.x / 2;
            camera.top = BOUNDS.y / 2;
            camera.bottom = -BOUNDS.y / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
