<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Body Segmentation - ML Visualizations - CCAB</title>
    <style>
        body { margin: 0; padding: 20px; background: #0f0f1a; color: #e8e6e1; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        .back-link { display: inline-block; padding: 8px 16px; background: rgba(124, 58, 237, 0.2); color: #a78bfa; text-decoration: none; border-radius: 6px; margin-bottom: 20px; }
        .back-link:hover { background: rgba(124, 58, 237, 0.4); }
        h1 { color: #a78bfa; margin-bottom: 10px; }
        .subtitle { color: #888; margin-bottom: 20px; }
        .container { display: flex; gap: 20px; flex-wrap: wrap; }
        .video-container { position: relative; }
        #video { border-radius: 8px; transform: scaleX(-1); display: none; }
        #output { border-radius: 8px; }
        button { background: #7C3AED; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; margin-top: 15px; margin-right: 10px; }
        button:hover { background: #6D28D9; }
        select { background: #1a1a2e; color: #e8e6e1; padding: 10px; border-radius: 6px; border: 1px solid #7C3AED; margin-top: 15px; margin-right: 10px; }
        #loading { text-align: center; padding: 50px; }
        .spinner { width: 50px; height: 50px; border: 4px solid rgba(255,255,255,0.1); border-top-color: #7C3AED; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .stats { margin-top: 15px; font-size: 14px; color: #888; }
        .effect-preview { display: inline-block; padding: 10px 15px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-top: 15px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to ML Gallery</a>
    <h1>Body Segmentation</h1>
    <p class="subtitle">Real-time person segmentation using BodyPix</p>

    <div id="loading">
        <div class="spinner"></div>
        <p>Loading BodyPix model...</p>
    </div>

    <div id="main" style="display: none;">
        <div class="video-container">
            <video id="video" width="640" height="480" autoplay playsinline></video>
            <canvas id="output" width="640" height="480"></canvas>
        </div>

        <div>
            <button onclick="startCamera()">Start Camera</button>
            <select id="effect" onchange="changeEffect()">
                <option value="mask">Person Mask</option>
                <option value="blur">Background Blur</option>
                <option value="bokeh">Bokeh Effect</option>
                <option value="colorMask">Color Overlay</option>
                <option value="pixelate">Pixelate Background</option>
                <option value="rainbow">Rainbow Person</option>
            </select>
        </div>

        <div class="effect-preview" id="effectDesc">
            Effect: Shows person silhouette with colored mask
        </div>

        <div class="stats">
            <p>FPS: <span id="fps">0</span></p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.2.0/dist/body-pix.min.js"></script>
    <script>
        let net;
        let video, outputCanvas, ctx;
        let running = false;
        let lastTime = 0;
        let currentEffect = 'mask';

        const EFFECTS = {
            mask: 'Shows person silhouette with colored mask',
            blur: 'Blurs the background, keeps person sharp',
            bokeh: 'Creates bokeh-style blur effect',
            colorMask: 'Overlays color on detected person',
            pixelate: 'Pixelates background only',
            rainbow: 'Applies rainbow gradient to person'
        };

        async function init() {
            net = await bodyPix.load({
                architecture: 'MobileNetV1',
                outputStride: 16,
                multiplier: 0.75,
                quantBytes: 2
            });

            video = document.getElementById('video');
            outputCanvas = document.getElementById('output');
            ctx = outputCanvas.getContext('2d');

            document.getElementById('loading').style.display = 'none';
            document.getElementById('main').style.display = 'block';
        }

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480 }
                });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    video.play();
                    running = true;
                    segment();
                };
            } catch (err) {
                alert('Camera access denied. Error: ' + err.message);
            }
        }

        function changeEffect() {
            currentEffect = document.getElementById('effect').value;
            document.getElementById('effectDesc').textContent = `Effect: ${EFFECTS[currentEffect]}`;
        }

        async function segment() {
            if (!running) return;

            const segmentation = await net.segmentPerson(video, {
                flipHorizontal: true,
                internalResolution: 'medium',
                segmentationThreshold: 0.7
            });

            // Clear canvas
            ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);

            switch (currentEffect) {
                case 'mask':
                    drawMask(segmentation);
                    break;
                case 'blur':
                    drawBlur(segmentation);
                    break;
                case 'bokeh':
                    drawBokeh(segmentation);
                    break;
                case 'colorMask':
                    drawColorMask(segmentation);
                    break;
                case 'pixelate':
                    drawPixelate(segmentation);
                    break;
                case 'rainbow':
                    drawRainbow(segmentation);
                    break;
            }

            // FPS
            const now = performance.now();
            document.getElementById('fps').textContent = Math.round(1000 / (now - lastTime));
            lastTime = now;

            requestAnimationFrame(segment);
        }

        function drawMask(segmentation) {
            const mask = bodyPix.toMask(segmentation, { r: 124, g: 58, b: 237, a: 200 }, { r: 0, g: 0, b: 0, a: 0 });

            // Draw video first (mirrored)
            ctx.save();
            ctx.scale(-1, 1);
            ctx.drawImage(video, -outputCanvas.width, 0);
            ctx.restore();

            // Overlay mask
            const maskData = new ImageData(mask.data, mask.width, mask.height);
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = mask.width;
            tempCanvas.height = mask.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(maskData, 0, 0);

            ctx.globalAlpha = 0.7;
            ctx.drawImage(tempCanvas, 0, 0, outputCanvas.width, outputCanvas.height);
            ctx.globalAlpha = 1;
        }

        function drawBlur(segmentation) {
            // Draw blurred background
            ctx.filter = 'blur(10px)';
            ctx.save();
            ctx.scale(-1, 1);
            ctx.drawImage(video, -outputCanvas.width, 0);
            ctx.restore();
            ctx.filter = 'none';

            // Draw sharp foreground using mask
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = outputCanvas.width;
            tempCanvas.height = outputCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            tempCtx.save();
            tempCtx.scale(-1, 1);
            tempCtx.drawImage(video, -outputCanvas.width, 0);
            tempCtx.restore();

            // Apply mask
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            for (let i = 0; i < segmentation.data.length; i++) {
                if (segmentation.data[i] === 0) {
                    imageData.data[i * 4 + 3] = 0;
                }
            }
            tempCtx.putImageData(imageData, 0, 0);
            ctx.drawImage(tempCanvas, 0, 0);
        }

        function drawBokeh(segmentation) {
            drawBlur(segmentation);

            // Add bokeh circles
            ctx.globalAlpha = 0.3;
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * outputCanvas.width;
                const y = Math.random() * outputCanvas.height;
                const r = Math.random() * 30 + 10;

                const idx = Math.floor(y) * outputCanvas.width + Math.floor(x);
                if (segmentation.data[idx] === 0) {
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${Math.random() * 60 + 200}, 80%, 70%, 0.5)`;
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;
        }

        function drawColorMask(segmentation) {
            ctx.save();
            ctx.scale(-1, 1);
            ctx.drawImage(video, -outputCanvas.width, 0);
            ctx.restore();

            ctx.globalCompositeOperation = 'source-atop';

            const imageData = ctx.getImageData(0, 0, outputCanvas.width, outputCanvas.height);
            for (let i = 0; i < segmentation.data.length; i++) {
                if (segmentation.data[i] === 1) {
                    imageData.data[i * 4] = Math.min(255, imageData.data[i * 4] + 50);
                    imageData.data[i * 4 + 2] = Math.min(255, imageData.data[i * 4 + 2] + 80);
                }
            }
            ctx.putImageData(imageData, 0, 0);
            ctx.globalCompositeOperation = 'source-over';
        }

        function drawPixelate(segmentation) {
            const blockSize = 12;

            // Draw pixelated version
            ctx.save();
            ctx.scale(-1, 1);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(video, 0, 0, outputCanvas.width / blockSize, outputCanvas.height / blockSize);
            ctx.drawImage(outputCanvas, 0, 0, outputCanvas.width / blockSize, outputCanvas.height / blockSize, -outputCanvas.width, 0, outputCanvas.width, outputCanvas.height);
            ctx.restore();

            // Overlay sharp person
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = outputCanvas.width;
            tempCanvas.height = outputCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            tempCtx.save();
            tempCtx.scale(-1, 1);
            tempCtx.drawImage(video, -outputCanvas.width, 0);
            tempCtx.restore();

            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            for (let i = 0; i < segmentation.data.length; i++) {
                if (segmentation.data[i] === 0) {
                    imageData.data[i * 4 + 3] = 0;
                }
            }
            tempCtx.putImageData(imageData, 0, 0);
            ctx.drawImage(tempCanvas, 0, 0);
        }

        function drawRainbow(segmentation) {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);

            ctx.save();
            ctx.scale(-1, 1);
            ctx.drawImage(video, -outputCanvas.width, 0);
            ctx.restore();

            const imageData = ctx.getImageData(0, 0, outputCanvas.width, outputCanvas.height);
            const time = Date.now() / 1000;

            for (let i = 0; i < segmentation.data.length; i++) {
                if (segmentation.data[i] === 1) {
                    const x = i % outputCanvas.width;
                    const y = Math.floor(i / outputCanvas.width);
                    const hue = (x + y + time * 100) % 360;

                    // Blend with rainbow
                    const r = imageData.data[i * 4];
                    const g = imageData.data[i * 4 + 1];
                    const b = imageData.data[i * 4 + 2];

                    const rainbow = hslToRgb(hue / 360, 0.8, 0.5);
                    imageData.data[i * 4] = r * 0.5 + rainbow.r * 0.5;
                    imageData.data[i * 4 + 1] = g * 0.5 + rainbow.g * 0.5;
                    imageData.data[i * 4 + 2] = b * 0.5 + rainbow.b * 0.5;
                } else {
                    imageData.data[i * 4 + 3] = 50;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
        }

        init();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
