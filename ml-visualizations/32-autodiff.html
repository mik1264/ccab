<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autodiff Graph Visualizer - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px;
            color: #c9a227; text-decoration: none; font-weight: 500;
            z-index: 1000; transition: all 0.3s ease;
        }
        .back-link:hover { color: #ffd700; transform: translateX(-4px); }
        .container { max-width: 1600px; margin: 0 auto; padding: 60px 20px 20px; }
        h1 { text-align: center; color: #c9a227; margin-bottom: 0.5rem; font-size: 2rem; }
        .subtitle { text-align: center; color: #888; margin-bottom: 1.5rem; }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }

        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .canvas-container {
            background: rgba(20, 20, 35, 0.9);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(201, 162, 39, 0.3);
        }

        .canvas-container h3 {
            color: #c9a227;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        canvas {
            width: 100%;
            background: #0a0a15;
            border-radius: 8px;
        }

        .controls {
            background: rgba(20, 20, 35, 0.9);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(201, 162, 39, 0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: #c9a227;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group select, .control-group input[type="text"] {
            width: 100%;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(201, 162, 39, 0.3);
            color: #e0e0e0;
            border-radius: 6px;
        }

        .control-group .value {
            color: #888;
            font-size: 0.85rem;
        }

        .btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #c9a227, #d4af37);
            color: #0a0a0f;
        }

        .btn-secondary {
            background: rgba(201, 162, 39, 0.2);
            color: #c9a227;
            border: 1px solid rgba(201, 162, 39, 0.4);
        }

        .btn:hover { transform: translateY(-2px); }

        .mode-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .mode-toggle button {
            flex: 1;
            padding: 10px;
            font-size: 0.85rem;
        }

        .mode-toggle button.active {
            background: linear-gradient(135deg, #c9a227, #d4af37);
            color: #0a0a0f;
        }

        .info-panel {
            background: rgba(30, 30, 50, 0.8);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .info-panel h4 {
            color: #c9a227;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 0.85rem;
        }

        .info-row:last-child { border-bottom: none; }
        .info-row .label { color: #888; }
        .info-row .value { color: #4ade80; font-family: monospace; }

        .equation {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.8rem;
            margin-top: 10px;
            line-height: 1.5;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 10px;
            font-size: 0.8rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
        }

        .preset-btns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .preset-btn {
            padding: 8px;
            font-size: 0.8rem;
            background: rgba(201, 162, 39, 0.15);
            border: 1px solid rgba(201, 162, 39, 0.3);
            color: #c9a227;
            border-radius: 6px;
            cursor: pointer;
        }

        .preset-btn:hover {
            background: rgba(201, 162, 39, 0.3);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to ML Visualizations</a>

    <div class="container">
        <h1>Autodiff Graph Visualizer</h1>
        <p class="subtitle">Visualize forward and reverse mode automatic differentiation</p>

        <div class="main-content">
            <div class="visualization-area">
                <div class="canvas-container">
                    <h3>Computation Graph</h3>
                    <canvas id="graphCanvas" width="900" height="450"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #60a5fa;"></div>
                            <span>Input Variables</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #a78bfa;"></div>
                            <span>Operations</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4ade80;"></div>
                            <span>Output</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #c9a227;"></div>
                            <span>Active Node</span>
                        </div>
                    </div>
                </div>

                <div class="canvas-container">
                    <h3>Derivative Propagation</h3>
                    <canvas id="derivCanvas" width="900" height="180"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="mode-toggle">
                    <button class="btn btn-secondary active" id="forwardBtn">Forward Mode</button>
                    <button class="btn btn-secondary" id="reverseBtn">Reverse Mode</button>
                </div>

                <div class="preset-btns">
                    <button class="preset-btn" data-expr="x*x + y*y">x² + y²</button>
                    <button class="preset-btn" data-expr="sin(x*y)">sin(x·y)</button>
                    <button class="preset-btn" data-expr="x*y + exp(x)">xy + eˣ</button>
                    <button class="preset-btn" data-expr="(x+y)*(x-y)">Diff of Squares</button>
                </div>

                <div class="control-group">
                    <label>Expression</label>
                    <input type="text" id="expression" value="x*x + y*y">
                </div>

                <div class="control-group">
                    <label>x value</label>
                    <input type="range" id="xVal" min="-3" max="3" step="0.1" value="2">
                    <div class="value">x = <span id="xValDisplay">2.0</span></div>
                </div>

                <div class="control-group">
                    <label>y value</label>
                    <input type="range" id="yVal" min="-3" max="3" step="0.1" value="1">
                    <div class="value">y = <span id="yValDisplay">1.0</span></div>
                </div>

                <button class="btn btn-primary" id="stepBtn">Step Forward</button>
                <button class="btn btn-secondary" id="resetBtn">Reset</button>
                <button class="btn btn-secondary" id="autoBtn">Auto Play</button>

                <div class="info-panel">
                    <h4>Results</h4>
                    <div class="info-row">
                        <span class="label">f(x,y) =</span>
                        <span class="value" id="fValue">-</span>
                    </div>
                    <div class="info-row">
                        <span class="label">∂f/∂x =</span>
                        <span class="value" id="dfdx">-</span>
                    </div>
                    <div class="info-row">
                        <span class="label">∂f/∂y =</span>
                        <span class="value" id="dfdy">-</span>
                    </div>
                    <div class="info-row">
                        <span class="label">Step:</span>
                        <span class="value" id="stepNum">0</span>
                    </div>
                </div>

                <div class="info-panel">
                    <h4>Forward vs Reverse</h4>
                    <div class="equation">
                        <b>Forward Mode:</b><br>
                        Propagate ∂x/∂x = 1 forward<br>
                        Compute ∂f/∂x directly<br>
                        O(n) for n inputs, 1 output<br><br>
                        <b>Reverse Mode:</b><br>
                        Forward pass: compute values<br>
                        Backward pass: ∂f/∂f = 1<br>
                        O(m) for n inputs, m outputs<br>
                        <span style="color: #4ade80;">Used in backprop!</span>
                    </div>
                </div>

                <div class="info-panel">
                    <h4>Chain Rule</h4>
                    <div class="equation">
                        ∂f/∂x = Σᵢ (∂f/∂vᵢ)(∂vᵢ/∂x)<br><br>
                        Each node applies the chain<br>
                        rule to combine gradients
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');
        const derivCanvas = document.getElementById('derivCanvas');
        const derivCtx = derivCanvas.getContext('2d');

        // Simple expression parser and graph builder
        class Node {
            constructor(op, children = [], value = null, name = null) {
                this.op = op;  // 'const', 'var', '+', '*', 'sin', 'cos', 'exp'
                this.children = children;
                this.value = value;
                this.name = name;
                this.grad = 0;
                this.forwardGrad = {};  // For forward mode: {varName: derivative}
                this.x = 0;
                this.y = 0;
                this.id = Node.nextId++;
            }
            static nextId = 0;
        }

        // State
        let state = {
            root: null,
            nodes: [],
            x: 2,
            y: 1,
            mode: 'forward',  // 'forward' or 'reverse'
            currentStep: 0,
            maxSteps: 0,
            executionOrder: [],
            playing: false
        };

        // Parse expression (simple tokenizer)
        function parseExpression(expr) {
            Node.nextId = 0;
            const tokens = tokenize(expr);
            let pos = 0;

            function tokenize(s) {
                const tokens = [];
                let i = 0;
                while (i < s.length) {
                    if (/\s/.test(s[i])) { i++; continue; }
                    if (/[+\-*\/()]/.test(s[i])) {
                        tokens.push(s[i]);
                        i++;
                    } else if (/[a-z]/.test(s[i])) {
                        let name = '';
                        while (i < s.length && /[a-z]/.test(s[i])) {
                            name += s[i++];
                        }
                        tokens.push(name);
                    } else if (/[0-9.]/.test(s[i])) {
                        let num = '';
                        while (i < s.length && /[0-9.]/.test(s[i])) {
                            num += s[i++];
                        }
                        tokens.push(parseFloat(num));
                    } else {
                        i++;
                    }
                }
                return tokens;
            }

            function parseAddSub() {
                let left = parseMulDiv();
                while (pos < tokens.length && (tokens[pos] === '+' || tokens[pos] === '-')) {
                    const op = tokens[pos++];
                    const right = parseMulDiv();
                    left = new Node(op, [left, right]);
                }
                return left;
            }

            function parseMulDiv() {
                let left = parseUnary();
                while (pos < tokens.length && (tokens[pos] === '*' || tokens[pos] === '/')) {
                    const op = tokens[pos++];
                    const right = parseUnary();
                    left = new Node(op, [left, right]);
                }
                return left;
            }

            function parseUnary() {
                if (tokens[pos] === '-') {
                    pos++;
                    const child = parseUnary();
                    return new Node('*', [new Node('const', [], -1), child]);
                }
                return parsePrimary();
            }

            function parsePrimary() {
                const token = tokens[pos];

                if (typeof token === 'number') {
                    pos++;
                    return new Node('const', [], token);
                }

                if (token === '(') {
                    pos++;
                    const node = parseAddSub();
                    if (tokens[pos] === ')') pos++;
                    return node;
                }

                if (typeof token === 'string') {
                    if (token === 'sin' || token === 'cos' || token === 'exp') {
                        pos++;
                        if (tokens[pos] === '(') pos++;
                        const arg = parseAddSub();
                        if (tokens[pos] === ')') pos++;
                        return new Node(token, [arg]);
                    }

                    // Variable
                    pos++;
                    return new Node('var', [], null, token);
                }

                return new Node('const', [], 0);
            }

            return parseAddSub();
        }

        // Collect all nodes
        function collectNodes(root) {
            const nodes = [];
            const visited = new Set();

            function traverse(node) {
                if (visited.has(node.id)) return;
                visited.add(node.id);

                for (const child of node.children) {
                    traverse(child);
                }
                nodes.push(node);
            }

            traverse(root);
            return nodes;
        }

        // Forward evaluation
        function evaluate(node, vars) {
            if (node.op === 'const') {
                node.value = node.value;
                return node.value;
            }
            if (node.op === 'var') {
                node.value = vars[node.name] || 0;
                return node.value;
            }

            const childVals = node.children.map(c => evaluate(c, vars));

            switch (node.op) {
                case '+': node.value = childVals[0] + childVals[1]; break;
                case '-': node.value = childVals[0] - childVals[1]; break;
                case '*': node.value = childVals[0] * childVals[1]; break;
                case '/': node.value = childVals[0] / childVals[1]; break;
                case 'sin': node.value = Math.sin(childVals[0]); break;
                case 'cos': node.value = Math.cos(childVals[0]); break;
                case 'exp': node.value = Math.exp(childVals[0]); break;
            }
            return node.value;
        }

        // Forward mode autodiff
        function forwardMode(nodes, wrt) {
            for (const node of nodes) {
                if (node.op === 'const') {
                    node.forwardGrad[wrt] = 0;
                } else if (node.op === 'var') {
                    node.forwardGrad[wrt] = node.name === wrt ? 1 : 0;
                } else {
                    const [c0, c1] = node.children;
                    const dv0 = c0 ? c0.forwardGrad[wrt] : 0;
                    const dv1 = c1 ? c1.forwardGrad[wrt] : 0;
                    const v0 = c0 ? c0.value : 0;
                    const v1 = c1 ? c1.value : 0;

                    switch (node.op) {
                        case '+': node.forwardGrad[wrt] = dv0 + dv1; break;
                        case '-': node.forwardGrad[wrt] = dv0 - dv1; break;
                        case '*': node.forwardGrad[wrt] = dv0 * v1 + v0 * dv1; break;
                        case '/': node.forwardGrad[wrt] = (dv0 * v1 - v0 * dv1) / (v1 * v1); break;
                        case 'sin': node.forwardGrad[wrt] = dv0 * Math.cos(v0); break;
                        case 'cos': node.forwardGrad[wrt] = -dv0 * Math.sin(v0); break;
                        case 'exp': node.forwardGrad[wrt] = dv0 * Math.exp(v0); break;
                    }
                }
            }
        }

        // Reverse mode autodiff
        function reverseMode(nodes) {
            // Reset gradients
            for (const node of nodes) {
                node.grad = 0;
            }

            // Output gradient = 1
            nodes[nodes.length - 1].grad = 1;

            // Backward pass
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                if (node.children.length === 0) continue;

                const [c0, c1] = node.children;
                const v0 = c0 ? c0.value : 0;
                const v1 = c1 ? c1.value : 0;

                switch (node.op) {
                    case '+':
                        c0.grad += node.grad;
                        c1.grad += node.grad;
                        break;
                    case '-':
                        c0.grad += node.grad;
                        c1.grad -= node.grad;
                        break;
                    case '*':
                        c0.grad += node.grad * v1;
                        c1.grad += node.grad * v0;
                        break;
                    case '/':
                        c0.grad += node.grad / v1;
                        c1.grad -= node.grad * v0 / (v1 * v1);
                        break;
                    case 'sin':
                        c0.grad += node.grad * Math.cos(v0);
                        break;
                    case 'cos':
                        c0.grad -= node.grad * Math.sin(v0);
                        break;
                    case 'exp':
                        c0.grad += node.grad * Math.exp(v0);
                        break;
                }
            }
        }

        // Build graph
        function buildGraph() {
            const expr = document.getElementById('expression').value;
            try {
                state.root = parseExpression(expr);
                state.nodes = collectNodes(state.root);
                state.currentStep = 0;

                // Layout nodes
                layoutNodes();

                // Evaluate
                evaluate(state.root, { x: state.x, y: state.y });

                // Compute derivatives
                if (state.mode === 'forward') {
                    forwardMode(state.nodes, 'x');
                    forwardMode(state.nodes, 'y');
                    state.maxSteps = state.nodes.length;
                    state.executionOrder = [...state.nodes];
                } else {
                    reverseMode(state.nodes);
                    state.maxSteps = state.nodes.length;
                    state.executionOrder = [...state.nodes].reverse();
                }

                updateDisplay();
            } catch (e) {
                console.error('Parse error:', e);
            }
        }

        // Layout nodes in layers
        function layoutNodes() {
            const layers = [];
            const nodeLayer = new Map();

            // Assign layers (topological)
            function assignLayer(node) {
                if (nodeLayer.has(node.id)) return nodeLayer.get(node.id);

                if (node.children.length === 0) {
                    nodeLayer.set(node.id, 0);
                    return 0;
                }

                let maxChildLayer = 0;
                for (const child of node.children) {
                    maxChildLayer = Math.max(maxChildLayer, assignLayer(child));
                }
                const layer = maxChildLayer + 1;
                nodeLayer.set(node.id, layer);
                return layer;
            }

            for (const node of state.nodes) {
                assignLayer(node);
            }

            // Group by layer
            const numLayers = Math.max(...nodeLayer.values()) + 1;
            for (let i = 0; i < numLayers; i++) {
                layers[i] = [];
            }
            for (const node of state.nodes) {
                layers[nodeLayer.get(node.id)].push(node);
            }

            // Position nodes
            const W = graphCanvas.width;
            const H = graphCanvas.height;
            const marginX = 80;
            const marginY = 60;

            const layerWidth = (W - 2 * marginX) / (numLayers || 1);

            for (let l = 0; l < layers.length; l++) {
                const layerNodes = layers[l];
                const layerHeight = (H - 2 * marginY) / (layerNodes.length || 1);

                for (let n = 0; n < layerNodes.length; n++) {
                    layerNodes[n].x = marginX + l * layerWidth + layerWidth / 2;
                    layerNodes[n].y = marginY + n * layerHeight + layerHeight / 2;
                }
            }
        }

        function updateDisplay() {
            drawGraph();
            drawDerivatives();
            updateStats();
        }

        function drawGraph() {
            const ctx = graphCtx;
            const W = graphCanvas.width;
            const H = graphCanvas.height;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, W, H);

            // Draw edges first
            ctx.lineWidth = 2;
            for (const node of state.nodes) {
                for (const child of node.children) {
                    const isActive = state.mode === 'forward' ?
                        (state.executionOrder.indexOf(node) <= state.currentStep) :
                        (state.executionOrder.indexOf(node) <= state.currentStep);

                    ctx.strokeStyle = isActive ? 'rgba(201, 162, 39, 0.6)' : 'rgba(100, 100, 100, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(child.x, child.y);
                    ctx.lineTo(node.x, node.y);
                    ctx.stroke();

                    // Arrow
                    const angle = Math.atan2(node.y - child.y, node.x - child.x);
                    const arrowLen = 10;
                    const midX = (child.x + node.x) / 2;
                    const midY = (child.y + node.y) / 2;

                    ctx.beginPath();
                    ctx.moveTo(midX, midY);
                    ctx.lineTo(midX - arrowLen * Math.cos(angle - 0.3), midY - arrowLen * Math.sin(angle - 0.3));
                    ctx.moveTo(midX, midY);
                    ctx.lineTo(midX - arrowLen * Math.cos(angle + 0.3), midY - arrowLen * Math.sin(angle + 0.3));
                    ctx.stroke();
                }
            }

            // Draw nodes
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let i = 0; i < state.nodes.length; i++) {
                const node = state.nodes[i];
                const execIdx = state.executionOrder.indexOf(node);
                const isActive = execIdx === state.currentStep;
                const isPast = execIdx < state.currentStep;

                // Node color
                let color;
                if (isActive) {
                    color = '#c9a227';
                } else if (node === state.root) {
                    color = '#4ade80';
                } else if (node.op === 'var') {
                    color = '#60a5fa';
                } else if (node.op === 'const') {
                    color = '#888';
                } else {
                    color = isPast ? '#a78bfa' : '#6b5b95';
                }

                // Draw node circle
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(node.x, node.y, 25, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = isActive ? '#ffd700' : 'rgba(255,255,255,0.3)';
                ctx.lineWidth = isActive ? 3 : 1;
                ctx.stroke();

                // Node label
                ctx.fillStyle = '#fff';
                let label;
                if (node.op === 'var') {
                    label = node.name;
                } else if (node.op === 'const') {
                    label = node.value.toFixed(1);
                } else {
                    label = node.op;
                }
                ctx.fillText(label, node.x, node.y - 5);

                // Value
                if (isPast || isActive) {
                    ctx.fillStyle = '#aaa';
                    ctx.font = '10px monospace';
                    ctx.fillText(node.value.toFixed(2), node.x, node.y + 10);
                    ctx.font = '12px monospace';
                }
            }

            // Direction indicator
            ctx.fillStyle = '#888';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'left';
            if (state.mode === 'forward') {
                ctx.fillText('Forward →', 20, 30);
            } else {
                ctx.fillText('← Reverse', 20, 30);
            }
        }

        function drawDerivatives() {
            const ctx = derivCtx;
            const W = derivCanvas.width;
            const H = derivCanvas.height;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, W, H);

            ctx.font = '12px monospace';
            ctx.textAlign = 'center';

            const nodeSpacing = W / (state.nodes.length + 1);

            for (let i = 0; i < state.nodes.length; i++) {
                const node = state.nodes[i];
                const execIdx = state.executionOrder.indexOf(node);
                const isActive = execIdx === state.currentStep;
                const isPast = execIdx < state.currentStep;

                const x = (i + 1) * nodeSpacing;

                // Node indicator
                ctx.fillStyle = isActive ? '#c9a227' : (isPast ? '#a78bfa' : '#444');
                ctx.beginPath();
                ctx.arc(x, 30, 12, 0, Math.PI * 2);
                ctx.fill();

                // Label
                ctx.fillStyle = '#fff';
                let label = node.op === 'var' ? node.name : (node.op === 'const' ? node.value.toFixed(0) : node.op);
                ctx.fillText(label.slice(0, 3), x, 33);

                // Derivatives
                if (isPast || isActive) {
                    ctx.fillStyle = '#4ade80';
                    ctx.font = '11px monospace';

                    if (state.mode === 'forward') {
                        const dx = node.forwardGrad['x'] || 0;
                        const dy = node.forwardGrad['y'] || 0;
                        ctx.fillText(`∂/∂x: ${dx.toFixed(2)}`, x, 70);
                        ctx.fillText(`∂/∂y: ${dy.toFixed(2)}`, x, 90);
                    } else {
                        ctx.fillText(`∂f/∂v: ${node.grad.toFixed(2)}`, x, 80);
                    }

                    ctx.font = '12px monospace';
                }
            }

            // Title
            ctx.fillStyle = '#888';
            ctx.textAlign = 'left';
            ctx.fillText(state.mode === 'forward' ? 'Forward derivatives:' : 'Reverse gradients:', 20, H - 20);
        }

        function updateStats() {
            const root = state.root;
            document.getElementById('fValue').textContent = root ? root.value.toFixed(4) : '-';

            if (state.mode === 'forward') {
                document.getElementById('dfdx').textContent = root ? (root.forwardGrad['x'] || 0).toFixed(4) : '-';
                document.getElementById('dfdy').textContent = root ? (root.forwardGrad['y'] || 0).toFixed(4) : '-';
            } else {
                // Find variable nodes
                const xNode = state.nodes.find(n => n.op === 'var' && n.name === 'x');
                const yNode = state.nodes.find(n => n.op === 'var' && n.name === 'y');
                document.getElementById('dfdx').textContent = xNode ? xNode.grad.toFixed(4) : '-';
                document.getElementById('dfdy').textContent = yNode ? yNode.grad.toFixed(4) : '-';
            }

            document.getElementById('stepNum').textContent = `${state.currentStep + 1}/${state.maxSteps}`;
        }

        // Event listeners
        document.getElementById('forwardBtn').addEventListener('click', () => {
            state.mode = 'forward';
            document.getElementById('forwardBtn').classList.add('active');
            document.getElementById('reverseBtn').classList.remove('active');
            buildGraph();
        });

        document.getElementById('reverseBtn').addEventListener('click', () => {
            state.mode = 'reverse';
            document.getElementById('reverseBtn').classList.add('active');
            document.getElementById('forwardBtn').classList.remove('active');
            buildGraph();
        });

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.getElementById('expression').value = btn.dataset.expr;
                buildGraph();
            });
        });

        document.getElementById('expression').addEventListener('change', buildGraph);

        document.getElementById('xVal').addEventListener('input', e => {
            state.x = parseFloat(e.target.value);
            document.getElementById('xValDisplay').textContent = state.x.toFixed(1);
            buildGraph();
        });

        document.getElementById('yVal').addEventListener('input', e => {
            state.y = parseFloat(e.target.value);
            document.getElementById('yValDisplay').textContent = state.y.toFixed(1);
            buildGraph();
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            state.currentStep = (state.currentStep + 1) % state.maxSteps;
            updateDisplay();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            state.currentStep = 0;
            state.playing = false;
            updateDisplay();
        });

        document.getElementById('autoBtn').addEventListener('click', () => {
            if (state.playing) {
                state.playing = false;
                return;
            }

            state.playing = true;
            state.currentStep = 0;

            function animate() {
                if (!state.playing) return;

                updateDisplay();
                state.currentStep++;

                if (state.currentStep >= state.maxSteps) {
                    state.playing = false;
                    state.currentStep = state.maxSteps - 1;
                    updateDisplay();
                    return;
                }

                setTimeout(animate, 500);
            }

            animate();
        });

        // Initialize
        buildGraph();
    </script>
</body>
</html>
