<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expectation-Maximization Algorithm - CCAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0;
        }

        h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, #00d4ff, #7c3aed);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #888;
            font-size: 1.1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
            margin-top: 20px;
        }

        .canvas-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .canvas-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(124, 58, 237, 0.3);
        }

        .canvas-container h3 {
            color: #7c3aed;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        canvas {
            display: block;
            background: #0a0a1a;
            border-radius: 10px;
            cursor: crosshair;
        }

        #mainCanvas {
            width: 100%;
            height: 450px;
        }

        #likelihoodCanvas {
            width: 100%;
            height: 150px;
        }

        .controls {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(124, 58, 237, 0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group h3 {
            color: #7c3aed;
            font-size: 0.9rem;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        label {
            display: block;
            margin: 10px 0 5px;
            color: #aaa;
            font-size: 0.85rem;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #7c3aed;
            cursor: pointer;
        }

        .value-display {
            text-align: right;
            font-size: 0.8rem;
            color: #7c3aed;
            font-family: monospace;
        }

        button {
            width: 100%;
            padding: 10px 15px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #7c3aed, #5b21b6);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(124, 58, 237, 0.4);
        }

        .btn-secondary {
            background: rgba(124, 58, 237, 0.2);
            color: #7c3aed;
            border: 1px solid rgba(124, 58, 237, 0.5);
        }

        .btn-secondary:hover {
            background: rgba(124, 58, 237, 0.3);
        }

        .btn-danger {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.5);
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.3);
        }

        .stats {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 0.85rem;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            font-family: monospace;
            color: #00d4ff;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8rem;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .step-indicator {
            background: linear-gradient(135deg, rgba(124, 58, 237, 0.2), rgba(0, 212, 255, 0.2));
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            text-align: center;
        }

        .step-indicator .step {
            font-size: 1.2rem;
            font-weight: bold;
            color: #00d4ff;
        }

        .step-indicator .description {
            font-size: 0.8rem;
            color: #aaa;
            margin-top: 5px;
        }

        select {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(124, 58, 237, 0.5);
            color: #e0e0e0;
            font-size: 0.9rem;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #7c3aed;
            text-decoration: none;
            font-weight: 600;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            border: 1px solid rgba(124, 58, 237, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .back-link:hover {
            background: rgba(124, 58, 237, 0.2);
            transform: translateX(-5px);
        }

        .cluster-info {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.8rem;
        }

        .cluster-info h4 {
            color: #7c3aed;
            margin-bottom: 8px;
        }

        .cluster-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
            padding: 5px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to ML Gallery</a>

    <div class="container">
        <header>
            <h1>Expectation-Maximization Algorithm</h1>
            <p class="subtitle">Interactive Gaussian Mixture Model Fitting</p>
        </header>

        <div class="main-content">
            <div class="canvas-section">
                <div class="canvas-container">
                    <h3>Data Space & Gaussian Clusters</h3>
                    <canvas id="mainCanvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-dot" style="background: #ef4444;"></div>
                            <span>Cluster 1</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: #22c55e;"></div>
                            <span>Cluster 2</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: #3b82f6;"></div>
                            <span>Cluster 3</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot" style="border: 2px dashed #888; background: transparent;"></div>
                            <span>1σ Ellipse</span>
                        </div>
                    </div>
                </div>

                <div class="canvas-container">
                    <h3>Log-Likelihood Over Iterations</h3>
                    <canvas id="likelihoodCanvas"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <h3>Algorithm Control</h3>

                    <div class="step-indicator">
                        <div class="step" id="stepDisplay">Ready</div>
                        <div class="description" id="stepDescription">Generate data or click to add points</div>
                    </div>

                    <button class="btn-primary" onclick="runEStep()">E-Step (Expectations)</button>
                    <button class="btn-primary" onclick="runMStep()">M-Step (Maximization)</button>
                    <button class="btn-secondary" onclick="runFullIteration()">Full EM Iteration</button>
                    <button class="btn-secondary" onclick="runUntilConverge()">Run Until Convergence</button>
                </div>

                <div class="control-group">
                    <h3>Data Generation</h3>
                    <label>Preset Dataset</label>
                    <select id="datasetSelect" onchange="generatePreset()">
                        <option value="three_clusters">Three Clusters</option>
                        <option value="two_overlapping">Two Overlapping</option>
                        <option value="elongated">Elongated Clusters</option>
                        <option value="unbalanced">Unbalanced Sizes</option>
                    </select>
                    <button class="btn-secondary" onclick="generatePreset()" style="margin-top: 10px;">Generate Data</button>
                </div>

                <div class="control-group">
                    <h3>Parameters</h3>

                    <label>Number of Clusters (K): <span id="kValue">3</span></label>
                    <input type="range" id="kSlider" min="2" max="5" value="3" onchange="updateK()">

                    <label>Points per Cluster: <span id="pointsValue">50</span></label>
                    <input type="range" id="pointsSlider" min="20" max="100" value="50" onchange="updatePointsDisplay()">

                    <label>Convergence Threshold: <span id="thresholdValue">0.001</span></label>
                    <input type="range" id="thresholdSlider" min="1" max="5" value="3" step="0.5" onchange="updateThreshold()">
                </div>

                <div class="control-group">
                    <button class="btn-secondary" onclick="randomizeGaussians()">Randomize Initial Gaussians</button>
                    <button class="btn-danger" onclick="clearAll()">Clear All</button>
                </div>

                <div class="stats">
                    <div class="stat-row">
                        <span class="stat-label">Iteration:</span>
                        <span class="stat-value" id="iterationStat">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Log-Likelihood:</span>
                        <span class="stat-value" id="loglikStat">—</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">ΔLog-Likelihood:</span>
                        <span class="stat-value" id="deltaStat">—</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Points:</span>
                        <span class="stat-value" id="pointsStat">0</span>
                    </div>
                </div>

                <div class="cluster-info" id="clusterInfo">
                    <h4>Cluster Parameters</h4>
                    <div id="clusterParams"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const mainCanvas = document.getElementById('mainCanvas');
        const mainCtx = mainCanvas.getContext('2d');
        const likelihoodCanvas = document.getElementById('likelihoodCanvas');
        const likelihoodCtx = likelihoodCanvas.getContext('2d');

        function resizeCanvases() {
            const rect1 = mainCanvas.getBoundingClientRect();
            mainCanvas.width = rect1.width * window.devicePixelRatio;
            mainCanvas.height = rect1.height * window.devicePixelRatio;
            mainCtx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const rect2 = likelihoodCanvas.getBoundingClientRect();
            likelihoodCanvas.width = rect2.width * window.devicePixelRatio;
            likelihoodCanvas.height = rect2.height * window.devicePixelRatio;
            likelihoodCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }

        resizeCanvases();

        // State
        let points = [];
        let K = 3;
        let gaussians = [];
        let responsibilities = [];
        let iteration = 0;
        let logLikelihoods = [];
        let convergenceThreshold = 0.001;
        let currentStep = 'ready';

        const colors = [
            { r: 239, g: 68, b: 68 },   // red
            { r: 34, g: 197, b: 94 },    // green
            { r: 59, g: 130, b: 246 },   // blue
            { r: 168, g: 85, b: 247 },   // purple
            { r: 234, g: 179, b: 8 }     // yellow
        ];

        // Initialize gaussians
        function initializeGaussians() {
            gaussians = [];
            const rect = mainCanvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;
            const padding = 80;

            for (let k = 0; k < K; k++) {
                gaussians.push({
                    mean: [
                        padding + Math.random() * (w - 2 * padding),
                        padding + Math.random() * (h - 2 * padding)
                    ],
                    cov: [
                        [1500 + Math.random() * 1000, (Math.random() - 0.5) * 500],
                        [(Math.random() - 0.5) * 500, 1500 + Math.random() * 1000]
                    ],
                    weight: 1 / K
                });
            }

            // Initialize responsibilities
            responsibilities = points.map(() => {
                const r = Array(K).fill(1 / K);
                return r;
            });
        }

        // Generate preset data
        function generatePreset() {
            const preset = document.getElementById('datasetSelect').value;
            const nPoints = parseInt(document.getElementById('pointsSlider').value);
            const rect = mainCanvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;

            points = [];

            if (preset === 'three_clusters') {
                // Three well-separated clusters
                const centers = [
                    [w * 0.25, h * 0.3],
                    [w * 0.75, h * 0.3],
                    [w * 0.5, h * 0.75]
                ];
                const stds = [40, 35, 45];

                for (let c = 0; c < 3; c++) {
                    for (let i = 0; i < nPoints; i++) {
                        points.push([
                            centers[c][0] + randn() * stds[c],
                            centers[c][1] + randn() * stds[c]
                        ]);
                    }
                }
                K = 3;
            } else if (preset === 'two_overlapping') {
                // Two overlapping clusters
                const centers = [
                    [w * 0.4, h * 0.5],
                    [w * 0.6, h * 0.5]
                ];

                for (let c = 0; c < 2; c++) {
                    for (let i = 0; i < nPoints * 1.5; i++) {
                        points.push([
                            centers[c][0] + randn() * 60,
                            centers[c][1] + randn() * 40
                        ]);
                    }
                }
                K = 2;
            } else if (preset === 'elongated') {
                // Elongated clusters with different orientations
                for (let i = 0; i < nPoints; i++) {
                    const x = randn() * 80;
                    const y = randn() * 20;
                    points.push([w * 0.3 + x, h * 0.3 + y + x * 0.3]);
                }
                for (let i = 0; i < nPoints; i++) {
                    const x = randn() * 20;
                    const y = randn() * 80;
                    points.push([w * 0.7 + x, h * 0.6 + y]);
                }
                K = 2;
            } else if (preset === 'unbalanced') {
                // Unbalanced cluster sizes
                for (let i = 0; i < nPoints * 2; i++) {
                    points.push([
                        w * 0.3 + randn() * 50,
                        h * 0.5 + randn() * 50
                    ]);
                }
                for (let i = 0; i < nPoints * 0.5; i++) {
                    points.push([
                        w * 0.75 + randn() * 25,
                        h * 0.4 + randn() * 25
                    ]);
                }
                K = 2;
            }

            document.getElementById('kSlider').value = K;
            document.getElementById('kValue').textContent = K;

            resetEM();
            draw();
        }

        // Random normal using Box-Muller
        function randn() {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        // Multivariate Gaussian PDF
        function mvnpdf(x, mean, cov) {
            const dx = [x[0] - mean[0], x[1] - mean[1]];
            const det = cov[0][0] * cov[1][1] - cov[0][1] * cov[1][0];

            if (det <= 0) return 1e-10;

            const invCov = [
                [cov[1][1] / det, -cov[0][1] / det],
                [-cov[1][0] / det, cov[0][0] / det]
            ];

            const exponent = -0.5 * (
                dx[0] * (invCov[0][0] * dx[0] + invCov[0][1] * dx[1]) +
                dx[1] * (invCov[1][0] * dx[0] + invCov[1][1] * dx[1])
            );

            const norm = 1 / (2 * Math.PI * Math.sqrt(det));
            return norm * Math.exp(exponent);
        }

        // E-Step: Compute responsibilities
        function runEStep() {
            if (points.length === 0) return;

            responsibilities = [];

            for (let n = 0; n < points.length; n++) {
                const resp = [];
                let sum = 0;

                for (let k = 0; k < K; k++) {
                    const prob = gaussians[k].weight * mvnpdf(points[n], gaussians[k].mean, gaussians[k].cov);
                    resp.push(prob);
                    sum += prob;
                }

                // Normalize
                for (let k = 0; k < K; k++) {
                    resp[k] = sum > 0 ? resp[k] / sum : 1 / K;
                }

                responsibilities.push(resp);
            }

            currentStep = 'e-step';
            updateStepDisplay('E-Step Complete', 'Responsibilities computed for each point');
            draw();
        }

        // M-Step: Update Gaussian parameters
        function runMStep() {
            if (points.length === 0 || responsibilities.length === 0) return;

            for (let k = 0; k < K; k++) {
                // Compute Nk (effective number of points)
                let Nk = 0;
                for (let n = 0; n < points.length; n++) {
                    Nk += responsibilities[n][k];
                }

                if (Nk < 1e-6) continue;

                // Update mean
                const newMean = [0, 0];
                for (let n = 0; n < points.length; n++) {
                    newMean[0] += responsibilities[n][k] * points[n][0];
                    newMean[1] += responsibilities[n][k] * points[n][1];
                }
                newMean[0] /= Nk;
                newMean[1] /= Nk;

                // Update covariance
                const newCov = [[0, 0], [0, 0]];
                for (let n = 0; n < points.length; n++) {
                    const dx = points[n][0] - newMean[0];
                    const dy = points[n][1] - newMean[1];
                    newCov[0][0] += responsibilities[n][k] * dx * dx;
                    newCov[0][1] += responsibilities[n][k] * dx * dy;
                    newCov[1][0] += responsibilities[n][k] * dy * dx;
                    newCov[1][1] += responsibilities[n][k] * dy * dy;
                }
                newCov[0][0] /= Nk;
                newCov[0][1] /= Nk;
                newCov[1][0] /= Nk;
                newCov[1][1] /= Nk;

                // Add small regularization
                newCov[0][0] += 10;
                newCov[1][1] += 10;

                // Update weight
                const newWeight = Nk / points.length;

                gaussians[k].mean = newMean;
                gaussians[k].cov = newCov;
                gaussians[k].weight = newWeight;
            }

            // Compute log-likelihood
            const ll = computeLogLikelihood();
            logLikelihoods.push(ll);
            iteration++;

            currentStep = 'm-step';
            updateStepDisplay('M-Step Complete', 'Parameters updated, iteration ' + iteration);
            updateStats();
            draw();
        }

        // Compute log-likelihood
        function computeLogLikelihood() {
            let ll = 0;
            for (let n = 0; n < points.length; n++) {
                let sum = 0;
                for (let k = 0; k < K; k++) {
                    sum += gaussians[k].weight * mvnpdf(points[n], gaussians[k].mean, gaussians[k].cov);
                }
                ll += Math.log(Math.max(sum, 1e-10));
            }
            return ll;
        }

        // Full iteration
        function runFullIteration() {
            runEStep();
            runMStep();
        }

        // Run until convergence
        function runUntilConverge() {
            if (points.length === 0) return;

            let maxIter = 100;
            let prevLL = -Infinity;

            for (let i = 0; i < maxIter; i++) {
                runEStep();
                runMStep();

                const currentLL = logLikelihoods[logLikelihoods.length - 1];
                const delta = Math.abs(currentLL - prevLL);

                if (delta < convergenceThreshold) {
                    updateStepDisplay('Converged!', `After ${iteration} iterations, ΔLL < ${convergenceThreshold}`);
                    break;
                }

                prevLL = currentLL;
            }
        }

        // Reset EM state
        function resetEM() {
            iteration = 0;
            logLikelihoods = [];
            currentStep = 'ready';
            initializeGaussians();
            updateStats();
            updateStepDisplay('Ready', 'Gaussians initialized randomly');
        }

        // Randomize gaussians
        function randomizeGaussians() {
            initializeGaussians();
            iteration = 0;
            logLikelihoods = [];
            currentStep = 'ready';
            updateStats();
            updateStepDisplay('Reset', 'New random initial Gaussians');
            draw();
        }

        // Clear all
        function clearAll() {
            points = [];
            resetEM();
            draw();
        }

        // Update K
        function updateK() {
            K = parseInt(document.getElementById('kSlider').value);
            document.getElementById('kValue').textContent = K;
            resetEM();
            draw();
        }

        // Update display values
        function updatePointsDisplay() {
            document.getElementById('pointsValue').textContent = document.getElementById('pointsSlider').value;
        }

        function updateThreshold() {
            const val = parseFloat(document.getElementById('thresholdSlider').value);
            convergenceThreshold = Math.pow(10, -val);
            document.getElementById('thresholdValue').textContent = convergenceThreshold.toExponential(0);
        }

        // Update step display
        function updateStepDisplay(step, description) {
            document.getElementById('stepDisplay').textContent = step;
            document.getElementById('stepDescription').textContent = description;
        }

        // Update stats
        function updateStats() {
            document.getElementById('iterationStat').textContent = iteration;
            document.getElementById('pointsStat').textContent = points.length;

            if (logLikelihoods.length > 0) {
                const ll = logLikelihoods[logLikelihoods.length - 1];
                document.getElementById('loglikStat').textContent = ll.toFixed(2);

                if (logLikelihoods.length > 1) {
                    const delta = ll - logLikelihoods[logLikelihoods.length - 2];
                    document.getElementById('deltaStat').textContent = delta.toFixed(4);
                }
            } else {
                document.getElementById('loglikStat').textContent = '—';
                document.getElementById('deltaStat').textContent = '—';
            }

            // Update cluster params
            let paramsHTML = '';
            for (let k = 0; k < K; k++) {
                const g = gaussians[k];
                const color = colors[k];
                paramsHTML += `
                    <div class="cluster-row">
                        <div style="width: 10px; height: 10px; border-radius: 50%; background: rgb(${color.r}, ${color.g}, ${color.b});"></div>
                        <span style="color: #aaa;">π=${g.weight.toFixed(2)}</span>
                    </div>
                `;
            }
            document.getElementById('clusterParams').innerHTML = paramsHTML;
        }

        // Draw everything
        function draw() {
            const rect = mainCanvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;

            // Clear
            mainCtx.fillStyle = '#0a0a1a';
            mainCtx.fillRect(0, 0, w, h);

            // Draw grid
            mainCtx.strokeStyle = 'rgba(124, 58, 237, 0.1)';
            mainCtx.lineWidth = 1;
            for (let x = 0; x < w; x += 50) {
                mainCtx.beginPath();
                mainCtx.moveTo(x, 0);
                mainCtx.lineTo(x, h);
                mainCtx.stroke();
            }
            for (let y = 0; y < h; y += 50) {
                mainCtx.beginPath();
                mainCtx.moveTo(0, y);
                mainCtx.lineTo(w, y);
                mainCtx.stroke();
            }

            // Draw Gaussian ellipses
            for (let k = 0; k < K; k++) {
                drawGaussianEllipse(gaussians[k], colors[k], k);
            }

            // Draw points
            for (let n = 0; n < points.length; n++) {
                const [x, y] = points[n];

                if (responsibilities.length > n) {
                    // Color by responsibility (soft assignment)
                    let r = 0, g = 0, b = 0;
                    for (let k = 0; k < K; k++) {
                        const resp = responsibilities[n][k];
                        r += colors[k].r * resp;
                        g += colors[k].g * resp;
                        b += colors[k].b * resp;
                    }
                    mainCtx.fillStyle = `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
                } else {
                    mainCtx.fillStyle = '#888';
                }

                mainCtx.beginPath();
                mainCtx.arc(x, y, 4, 0, Math.PI * 2);
                mainCtx.fill();
            }

            // Draw likelihood plot
            drawLikelihood();
        }

        // Draw Gaussian ellipse (1σ)
        function drawGaussianEllipse(g, color, index) {
            const cov = g.cov;
            const mean = g.mean;

            // Eigenvalue decomposition for ellipse
            const a = cov[0][0];
            const b = cov[0][1];
            const c = cov[1][1];

            const trace = a + c;
            const det = a * c - b * b;

            if (det <= 0) return;

            const lambda1 = trace / 2 + Math.sqrt(trace * trace / 4 - det);
            const lambda2 = trace / 2 - Math.sqrt(trace * trace / 4 - det);

            if (lambda1 <= 0 || lambda2 <= 0) return;

            // Semi-axes (1σ)
            const rx = Math.sqrt(lambda1);
            const ry = Math.sqrt(lambda2);

            // Rotation angle
            let angle = 0;
            if (b !== 0) {
                angle = Math.atan2(lambda1 - a, b);
            } else if (a < c) {
                angle = Math.PI / 2;
            }

            // Draw ellipse
            mainCtx.save();
            mainCtx.translate(mean[0], mean[1]);
            mainCtx.rotate(angle);

            // Fill
            mainCtx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.1)`;
            mainCtx.beginPath();
            mainCtx.ellipse(0, 0, rx * 2, ry * 2, 0, 0, Math.PI * 2);
            mainCtx.fill();

            // 1σ ellipse stroke
            mainCtx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.7)`;
            mainCtx.lineWidth = 2;
            mainCtx.setLineDash([5, 5]);
            mainCtx.beginPath();
            mainCtx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
            mainCtx.stroke();

            // 2σ ellipse
            mainCtx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.3)`;
            mainCtx.lineWidth = 1;
            mainCtx.beginPath();
            mainCtx.ellipse(0, 0, rx * 2, ry * 2, 0, 0, Math.PI * 2);
            mainCtx.stroke();

            mainCtx.restore();
            mainCtx.setLineDash([]);

            // Draw center (mean)
            mainCtx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
            mainCtx.beginPath();
            mainCtx.arc(mean[0], mean[1], 8, 0, Math.PI * 2);
            mainCtx.fill();

            mainCtx.fillStyle = '#0a0a1a';
            mainCtx.beginPath();
            mainCtx.arc(mean[0], mean[1], 4, 0, Math.PI * 2);
            mainCtx.fill();

            // Label
            mainCtx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
            mainCtx.font = 'bold 12px sans-serif';
            mainCtx.fillText(`K${index + 1}`, mean[0] + 12, mean[1] - 12);
        }

        // Draw log-likelihood plot
        function drawLikelihood() {
            const rect = likelihoodCanvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;
            const padding = 40;

            likelihoodCtx.fillStyle = '#0a0a1a';
            likelihoodCtx.fillRect(0, 0, w, h);

            if (logLikelihoods.length < 2) {
                likelihoodCtx.fillStyle = '#666';
                likelihoodCtx.font = '12px sans-serif';
                likelihoodCtx.textAlign = 'center';
                likelihoodCtx.fillText('Run EM iterations to see log-likelihood', w / 2, h / 2);
                return;
            }

            // Compute scale
            const minLL = Math.min(...logLikelihoods);
            const maxLL = Math.max(...logLikelihoods);
            const range = maxLL - minLL || 1;

            // Draw axes
            likelihoodCtx.strokeStyle = '#444';
            likelihoodCtx.lineWidth = 1;
            likelihoodCtx.beginPath();
            likelihoodCtx.moveTo(padding, padding);
            likelihoodCtx.lineTo(padding, h - padding);
            likelihoodCtx.lineTo(w - padding, h - padding);
            likelihoodCtx.stroke();

            // Labels
            likelihoodCtx.fillStyle = '#888';
            likelihoodCtx.font = '10px sans-serif';
            likelihoodCtx.textAlign = 'center';
            likelihoodCtx.fillText('Iteration', w / 2, h - 5);

            likelihoodCtx.save();
            likelihoodCtx.translate(12, h / 2);
            likelihoodCtx.rotate(-Math.PI / 2);
            likelihoodCtx.fillText('Log-L', 0, 0);
            likelihoodCtx.restore();

            // Draw line
            likelihoodCtx.strokeStyle = '#00d4ff';
            likelihoodCtx.lineWidth = 2;
            likelihoodCtx.beginPath();

            for (let i = 0; i < logLikelihoods.length; i++) {
                const x = padding + (i / (logLikelihoods.length - 1)) * (w - 2 * padding);
                const y = h - padding - ((logLikelihoods[i] - minLL) / range) * (h - 2 * padding);

                if (i === 0) {
                    likelihoodCtx.moveTo(x, y);
                } else {
                    likelihoodCtx.lineTo(x, y);
                }
            }
            likelihoodCtx.stroke();

            // Draw points
            for (let i = 0; i < logLikelihoods.length; i++) {
                const x = padding + (i / (logLikelihoods.length - 1)) * (w - 2 * padding);
                const y = h - padding - ((logLikelihoods[i] - minLL) / range) * (h - 2 * padding);

                likelihoodCtx.fillStyle = '#00d4ff';
                likelihoodCtx.beginPath();
                likelihoodCtx.arc(x, y, 4, 0, Math.PI * 2);
                likelihoodCtx.fill();
            }
        }

        // Mouse interaction
        mainCanvas.addEventListener('click', (e) => {
            const rect = mainCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            points.push([x, y]);

            // Extend responsibilities
            responsibilities.push(Array(K).fill(1 / K));

            document.getElementById('pointsStat').textContent = points.length;
            draw();
        });

        // Initialize
        window.addEventListener('resize', () => {
            resizeCanvases();
            draw();
        });

        updateThreshold();
        generatePreset();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
