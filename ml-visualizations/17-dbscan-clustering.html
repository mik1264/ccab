<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBSCAN Clustering Lab - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e8e6e1;
            min-height: 100vh;
            overflow: hidden;
        }
        .back-link {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            color: #10b981;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            z-index: 999;
        }
        .back-link:hover { background: rgba(16, 185, 129, 0.2); }

        #canvas {
            display: block;
            width: 100vw;
            height: calc(100vh - 120px);
            cursor: crosshair;
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
            z-index: 100;
        }
        .control-group { display: flex; align-items: center; gap: 8px; }
        label { font-size: 13px; color: #888; }
        input[type="range"] { width: 100px; accent-color: #10b981; }
        select {
            padding: 6px 12px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            color: white;
        }
        button {
            padding: 8px 16px;
            background: linear-gradient(135deg, #10b981, #059669);
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            cursor: pointer;
        }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(16, 185, 129, 0.4); }
        button.secondary { background: linear-gradient(135deg, #6366f1, #4f46e5); }

        .info-panel {
            position: fixed;
            top: 60px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 10px;
            font-size: 13px;
            max-width: 280px;
            z-index: 100;
        }
        .info-panel h3 { color: #10b981; margin-bottom: 10px; }
        .info-panel p { margin-bottom: 8px; color: #aaa; line-height: 1.5; }

        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .legend-item { display: flex; align-items: center; gap: 5px; font-size: 12px; }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; }
        .legend-dot.core { background: #10b981; }
        .legend-dot.border { background: #fbbf24; }
        .legend-dot.noise { background: #ef4444; }

        .stats-panel {
            position: fixed;
            top: 60px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 10px;
            font-size: 13px;
            z-index: 100;
        }
        .stats-panel h3 { color: #10b981; margin-bottom: 10px; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; color: #aaa; gap: 20px; }
        .stat-value { color: white; font-weight: 600; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to ML Visualizations</a>

    <canvas id="canvas"></canvas>

    <div class="info-panel">
        <h3>DBSCAN Clustering</h3>
        <p>Density-Based Spatial Clustering of Applications with Noise.</p>
        <p><strong>ε (epsilon):</strong> Maximum distance between neighbors</p>
        <p><strong>minPts:</strong> Minimum points to form a dense region</p>
        <p>Unlike k-means, DBSCAN finds clusters of arbitrary shape and identifies noise/outliers.</p>
        <div class="legend">
            <div class="legend-item"><div class="legend-dot core"></div>Core</div>
            <div class="legend-item"><div class="legend-dot border"></div>Border</div>
            <div class="legend-item"><div class="legend-dot noise"></div>Noise</div>
        </div>
    </div>

    <div class="stats-panel">
        <h3>Results</h3>
        <div class="stat-row">
            <span>Total Points:</span>
            <span class="stat-value" id="totalPoints">0</span>
        </div>
        <div class="stat-row">
            <span>Clusters:</span>
            <span class="stat-value" id="clusterCount">0</span>
        </div>
        <div class="stat-row">
            <span>Core Points:</span>
            <span class="stat-value" id="coreCount">0</span>
        </div>
        <div class="stat-row">
            <span>Border Points:</span>
            <span class="stat-value" id="borderCount">0</span>
        </div>
        <div class="stat-row">
            <span>Noise Points:</span>
            <span class="stat-value" id="noiseCount">0</span>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Dataset:</label>
            <select id="dataset">
                <option value="clusters">Gaussian Clusters</option>
                <option value="moons">Two Moons</option>
                <option value="circles">Concentric Circles</option>
                <option value="random">Random with Noise</option>
            </select>
        </div>
        <div class="control-group">
            <label>ε (epsilon):</label>
            <input type="range" id="epsilon" min="10" max="100" value="40">
            <span id="epsValue">40</span>
        </div>
        <div class="control-group">
            <label>minPts:</label>
            <input type="range" id="minPts" min="2" max="20" value="5">
            <span id="minPtsValue">5</span>
        </div>
        <button onclick="runDBSCAN()">Run DBSCAN</button>
        <button class="secondary" onclick="generateData()">New Data</button>
        <button onclick="clearData()">Clear</button>
        <span style="color:#666; font-size:12px;">Click canvas to add points</span>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        let points = [];
        let epsilon = 40;
        let minPts = 5;
        let showEpsilon = true;
        let hoveredPoint = null;

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
        }
        resizeCanvas();
        window.addEventListener('resize', () => { resizeCanvas(); draw(); });

        // Point class
        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.cluster = -1; // -1 = unvisited, 0 = noise, 1+ = cluster
                this.type = 'unvisited'; // 'core', 'border', 'noise', 'unvisited'
            }
        }

        // Generate sample datasets
        function generateData() {
            points = [];
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;
            const type = document.getElementById('dataset').value;

            if (type === 'clusters') {
                const centers = [
                    { x: width * 0.25, y: height * 0.3 },
                    { x: width * 0.7, y: height * 0.4 },
                    { x: width * 0.4, y: height * 0.7 },
                    { x: width * 0.8, y: height * 0.75 }
                ];
                centers.forEach(c => {
                    for (let i = 0; i < 40; i++) {
                        points.push(new Point(
                            c.x + (Math.random() - 0.5) * 100,
                            c.y + (Math.random() - 0.5) * 100
                        ));
                    }
                });
                // Add noise
                for (let i = 0; i < 20; i++) {
                    points.push(new Point(
                        Math.random() * width,
                        Math.random() * height
                    ));
                }
            } else if (type === 'moons') {
                const cx = width / 2, cy = height / 2;
                for (let i = 0; i < 100; i++) {
                    const t = (i / 100) * Math.PI;
                    points.push(new Point(
                        cx - 100 + Math.cos(t) * 120 + (Math.random() - 0.5) * 20,
                        cy - 50 + Math.sin(t) * 120 + (Math.random() - 0.5) * 20
                    ));
                }
                for (let i = 0; i < 100; i++) {
                    const t = (i / 100) * Math.PI;
                    points.push(new Point(
                        cx + 100 - Math.cos(t) * 120 + (Math.random() - 0.5) * 20,
                        cy + 50 - Math.sin(t) * 120 + (Math.random() - 0.5) * 20
                    ));
                }
                for (let i = 0; i < 15; i++) {
                    points.push(new Point(Math.random() * width, Math.random() * height));
                }
            } else if (type === 'circles') {
                const cx = width / 2, cy = height / 2;
                for (let i = 0; i < 80; i++) {
                    const angle = (i / 80) * Math.PI * 2;
                    points.push(new Point(
                        cx + Math.cos(angle) * 150 + (Math.random() - 0.5) * 20,
                        cy + Math.sin(angle) * 150 + (Math.random() - 0.5) * 20
                    ));
                }
                for (let i = 0; i < 60; i++) {
                    const angle = (i / 60) * Math.PI * 2;
                    points.push(new Point(
                        cx + Math.cos(angle) * 70 + (Math.random() - 0.5) * 15,
                        cy + Math.sin(angle) * 70 + (Math.random() - 0.5) * 15
                    ));
                }
                for (let i = 0; i < 15; i++) {
                    points.push(new Point(Math.random() * width, Math.random() * height));
                }
            } else {
                for (let i = 0; i < 150; i++) {
                    if (Math.random() < 0.7) {
                        // Cluster points
                        const cx = width * (0.2 + Math.random() * 0.6);
                        const cy = height * (0.2 + Math.random() * 0.6);
                        for (let j = 0; j < 5; j++) {
                            points.push(new Point(
                                cx + (Math.random() - 0.5) * 50,
                                cy + (Math.random() - 0.5) * 50
                            ));
                        }
                    } else {
                        // Random noise
                        points.push(new Point(Math.random() * width, Math.random() * height));
                    }
                }
            }

            resetClustering();
            draw();
        }

        function resetClustering() {
            points.forEach(p => {
                p.cluster = -1;
                p.type = 'unvisited';
            });
            updateStats();
        }

        // Distance function
        function distance(p1, p2) {
            return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
        }

        // Find neighbors within epsilon
        function getNeighbors(point) {
            return points.filter(p => p !== point && distance(point, p) <= epsilon);
        }

        // DBSCAN algorithm
        function runDBSCAN() {
            resetClustering();

            let clusterID = 0;

            for (const point of points) {
                if (point.cluster !== -1) continue; // Already processed

                const neighbors = getNeighbors(point);

                if (neighbors.length < minPts) {
                    point.cluster = 0; // Mark as noise initially
                    point.type = 'noise';
                } else {
                    clusterID++;
                    expandCluster(point, neighbors, clusterID);
                }
            }

            // Update types based on final clustering
            for (const point of points) {
                if (point.cluster > 0) {
                    const neighbors = getNeighbors(point);
                    if (neighbors.length >= minPts) {
                        point.type = 'core';
                    } else {
                        point.type = 'border';
                    }
                }
            }

            updateStats();
            draw();
        }

        function expandCluster(point, neighbors, clusterID) {
            point.cluster = clusterID;
            point.type = 'core';

            const queue = [...neighbors];

            while (queue.length > 0) {
                const current = queue.shift();

                if (current.cluster === 0) {
                    // Was marked as noise, now it's a border point
                    current.cluster = clusterID;
                    current.type = 'border';
                }

                if (current.cluster !== -1) continue; // Already in a cluster

                current.cluster = clusterID;

                const currentNeighbors = getNeighbors(current);

                if (currentNeighbors.length >= minPts) {
                    current.type = 'core';
                    for (const n of currentNeighbors) {
                        if (n.cluster === -1 || n.cluster === 0) {
                            queue.push(n);
                        }
                    }
                } else {
                    current.type = 'border';
                }
            }
        }

        function updateStats() {
            const clusters = new Set(points.filter(p => p.cluster > 0).map(p => p.cluster));
            document.getElementById('totalPoints').textContent = points.length;
            document.getElementById('clusterCount').textContent = clusters.size;
            document.getElementById('coreCount').textContent = points.filter(p => p.type === 'core').length;
            document.getElementById('borderCount').textContent = points.filter(p => p.type === 'border').length;
            document.getElementById('noiseCount').textContent = points.filter(p => p.type === 'noise' || p.cluster === 0).length;
        }

        // Cluster colors
        const clusterColors = [
            '#ef4444', // noise (cluster 0)
            '#10b981', '#6366f1', '#f59e0b', '#ec4899',
            '#14b8a6', '#8b5cf6', '#f97316', '#22d3ee',
            '#a855f7', '#84cc16'
        ];

        function draw() {
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);

            // Draw epsilon radius for hovered point
            if (hoveredPoint && showEpsilon) {
                ctx.beginPath();
                ctx.arc(hoveredPoint.x, hoveredPoint.y, epsilon, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(16, 185, 129, 0.1)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(16, 185, 129, 0.5)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw lines to neighbors
                const neighbors = getNeighbors(hoveredPoint);
                ctx.strokeStyle = 'rgba(16, 185, 129, 0.3)';
                for (const n of neighbors) {
                    ctx.beginPath();
                    ctx.moveTo(hoveredPoint.x, hoveredPoint.y);
                    ctx.lineTo(n.x, n.y);
                    ctx.stroke();
                }
            }

            // Draw points
            for (const point of points) {
                let color;
                let size = 6;

                if (point.cluster === -1 || point.cluster === 0) {
                    color = '#ef4444'; // Noise/unvisited
                    size = 5;
                } else {
                    color = clusterColors[point.cluster % clusterColors.length];
                }

                // Core points are larger
                if (point.type === 'core') {
                    size = 8;
                } else if (point.type === 'border') {
                    size = 6;
                }

                ctx.beginPath();
                ctx.fillStyle = color;
                ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                ctx.fill();

                // Border for core points
                if (point.type === 'core') {
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }

        // Mouse interaction
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            hoveredPoint = null;
            for (const p of points) {
                if (distance({ x: mx, y: my }, p) < 15) {
                    hoveredPoint = p;
                    break;
                }
            }
            draw();
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            points.push(new Point(mx, my));
            resetClustering();
            draw();
        });

        function clearData() {
            points = [];
            hoveredPoint = null;
            updateStats();
            draw();
        }

        // Event listeners
        document.getElementById('epsilon').addEventListener('input', (e) => {
            epsilon = parseInt(e.target.value);
            document.getElementById('epsValue').textContent = epsilon;
            draw();
        });

        document.getElementById('minPts').addEventListener('input', (e) => {
            minPts = parseInt(e.target.value);
            document.getElementById('minPtsValue').textContent = minPts;
        });

        document.getElementById('dataset').addEventListener('change', generateData);

        // Initialize
        generateData();
    </script>
</body>
</html>
