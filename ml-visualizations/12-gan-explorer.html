<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GAN Latent Space Explorer - ML Visualizations - CCAB</title>
    <style>
        body { margin: 0; padding: 20px; background: #0f0f1a; color: #e8e6e1; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        .back-link { display: inline-block; padding: 8px 16px; background: rgba(124, 58, 237, 0.2); color: #a78bfa; text-decoration: none; border-radius: 6px; margin-bottom: 20px; }
        .back-link:hover { background: rgba(124, 58, 237, 0.4); }
        h1 { color: #a78bfa; margin-bottom: 10px; }
        .subtitle { color: #888; margin-bottom: 20px; }
        .container { display: flex; gap: 30px; flex-wrap: wrap; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 20px; }
        canvas { border-radius: 8px; cursor: crosshair; }
        button { background: #7C3AED; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; margin: 5px; }
        button:hover { background: #6D28D9; }
        .slider-group { margin: 15px 0; }
        .slider-group label { display: block; margin-bottom: 5px; color: #a78bfa; }
        input[type="range"] { width: 100%; accent-color: #7C3AED; }
        .value { float: right; color: #888; }
        .note { font-size: 12px; color: #888; margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 6px; }
        .generated-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 20px; }
        .generated-grid canvas { width: 100%; border-radius: 4px; cursor: pointer; transition: transform 0.2s; }
        .generated-grid canvas:hover { transform: scale(1.05); }
        #latentSpace { background: #1a1a2e; }
        .interpolation { margin-top: 20px; }
        .interpolation-strip { display: flex; gap: 5px; margin-top: 10px; }
        .interpolation-strip canvas { border-radius: 4px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to ML Gallery</a>
    <h1>GAN Latent Space Explorer</h1>
    <p class="subtitle">Explore the latent space of a simple generative model (simulated demo)</p>

    <div class="container">
        <div class="panel">
            <h3>2D Latent Space</h3>
            <canvas id="latentSpace" width="300" height="300"></canvas>
            <p style="font-size: 12px; color: #888; margin-top: 10px;">Click to sample from latent space</p>

            <div class="slider-group">
                <label>Z1 <span class="value" id="z1Val">0.00</span></label>
                <input type="range" id="z1" min="-3" max="3" step="0.1" value="0" oninput="updateLatent()">
            </div>
            <div class="slider-group">
                <label>Z2 <span class="value" id="z2Val">0.00</span></label>
                <input type="range" id="z2" min="-3" max="3" step="0.1" value="0" oninput="updateLatent()">
            </div>
            <div class="slider-group">
                <label>Noise <span class="value" id="noiseVal">0.50</span></label>
                <input type="range" id="noise" min="0" max="1" step="0.05" value="0.5" oninput="updateLatent()">
            </div>

            <button onclick="randomize()">Random Sample</button>
            <button onclick="animate()">Animate</button>
        </div>

        <div class="panel">
            <h3>Generated Output</h3>
            <canvas id="output" width="256" height="256"></canvas>

            <div class="note">
                This demo simulates GAN output using procedural generation based on latent vectors.
                Real GANs (StyleGAN, DCGAN) require loading large pre-trained models.
            </div>

            <h4 style="margin-top: 20px;">Random Samples</h4>
            <div class="generated-grid" id="samples"></div>
        </div>

        <div class="panel" style="flex-basis: 100%;">
            <h3>Latent Space Interpolation</h3>
            <div>
                <button onclick="setInterpolationStart()">Set Start Point</button>
                <button onclick="setInterpolationEnd()">Set End Point</button>
                <button onclick="runInterpolation()">Interpolate</button>
            </div>
            <div class="interpolation-strip" id="interpolation"></div>
        </div>
    </div>

    <script>
        const latentCanvas = document.getElementById('latentSpace');
        const latentCtx = latentCanvas.getContext('2d');
        const outputCanvas = document.getElementById('output');
        const outputCtx = outputCanvas.getContext('2d');

        let z1 = 0, z2 = 0, noise = 0.5;
        let animating = false;
        let interpolateStart = { z1: -2, z2: -2 };
        let interpolateEnd = { z1: 2, z2: 2 };

        function init() {
            drawLatentSpace();
            generate(z1, z2);
            generateSamples();
        }

        function drawLatentSpace() {
            // Draw latent space visualization
            const imageData = latentCtx.createImageData(300, 300);

            for (let y = 0; y < 300; y++) {
                for (let x = 0; x < 300; x++) {
                    const lz1 = (x / 300) * 6 - 3;
                    const lz2 = (y / 300) * 6 - 3;

                    // Color based on latent position
                    const hue = (Math.atan2(lz2, lz1) + Math.PI) / (2 * Math.PI) * 360;
                    const sat = Math.min(1, Math.sqrt(lz1 * lz1 + lz2 * lz2) / 3);
                    const rgb = hslToRgb(hue, sat * 0.8, 0.3 + sat * 0.2);

                    const idx = (y * 300 + x) * 4;
                    imageData.data[idx] = rgb.r;
                    imageData.data[idx + 1] = rgb.g;
                    imageData.data[idx + 2] = rgb.b;
                    imageData.data[idx + 3] = 255;
                }
            }

            latentCtx.putImageData(imageData, 0, 0);

            // Draw current position
            const px = ((z1 + 3) / 6) * 300;
            const py = ((z2 + 3) / 6) * 300;

            latentCtx.beginPath();
            latentCtx.arc(px, py, 8, 0, Math.PI * 2);
            latentCtx.fillStyle = 'white';
            latentCtx.fill();
            latentCtx.strokeStyle = '#7C3AED';
            latentCtx.lineWidth = 3;
            latentCtx.stroke();
        }

        function generate(z1, z2, canvas = outputCanvas, ctx = outputCtx) {
            const width = canvas.width;
            const height = canvas.height;
            const imageData = ctx.createImageData(width, height);

            // Simulated GAN output - procedural generation based on latent vectors
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const nx = x / width - 0.5;
                    const ny = y / height - 0.5;

                    // Generate features based on latent vector
                    let value = 0;

                    // Circles influenced by z1
                    const circleX = z1 * 0.15;
                    const circleY = z2 * 0.15;
                    const dist = Math.sqrt((nx - circleX) ** 2 + (ny - circleY) ** 2);
                    value += Math.exp(-dist * (8 + z1 * 2));

                    // Waves influenced by z2
                    value += Math.sin(nx * (10 + z1 * 3) + z2) * Math.cos(ny * (10 + z2 * 3) + z1) * 0.3;

                    // Noise
                    value += (Math.random() - 0.5) * noise * 0.5;

                    // Spiral pattern
                    const angle = Math.atan2(ny, nx);
                    const spiral = Math.sin(angle * (3 + z1) + dist * (20 + z2 * 5));
                    value += spiral * 0.2 * Math.exp(-dist * 3);

                    // Color mapping based on z values
                    const hue = (z1 + 3) / 6 * 120 + (z2 + 3) / 6 * 120;
                    const sat = 0.7 + Math.sin(value * Math.PI) * 0.3;
                    const light = 0.3 + value * 0.4;

                    const rgb = hslToRgb(hue, sat, Math.max(0.1, Math.min(0.9, light)));

                    const idx = (y * width + x) * 4;
                    imageData.data[idx] = rgb.r;
                    imageData.data[idx + 1] = rgb.g;
                    imageData.data[idx + 2] = rgb.b;
                    imageData.data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function updateLatent() {
            z1 = parseFloat(document.getElementById('z1').value);
            z2 = parseFloat(document.getElementById('z2').value);
            noise = parseFloat(document.getElementById('noise').value);

            document.getElementById('z1Val').textContent = z1.toFixed(2);
            document.getElementById('z2Val').textContent = z2.toFixed(2);
            document.getElementById('noiseVal').textContent = noise.toFixed(2);

            drawLatentSpace();
            generate(z1, z2);
        }

        function randomize() {
            z1 = Math.random() * 6 - 3;
            z2 = Math.random() * 6 - 3;

            document.getElementById('z1').value = z1;
            document.getElementById('z2').value = z2;

            updateLatent();
        }

        function animate() {
            if (animating) {
                animating = false;
                return;
            }

            animating = true;
            const startTime = Date.now();

            function step() {
                if (!animating) return;

                const t = (Date.now() - startTime) / 1000;
                z1 = Math.sin(t * 0.5) * 2;
                z2 = Math.cos(t * 0.7) * 2;

                document.getElementById('z1').value = z1;
                document.getElementById('z2').value = z2;
                updateLatent();

                requestAnimationFrame(step);
            }

            step();
        }

        function generateSamples() {
            const container = document.getElementById('samples');
            container.innerHTML = '';

            for (let i = 0; i < 8; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');

                const sz1 = Math.random() * 6 - 3;
                const sz2 = Math.random() * 6 - 3;
                generate(sz1, sz2, canvas, ctx);

                canvas.onclick = () => {
                    z1 = sz1;
                    z2 = sz2;
                    document.getElementById('z1').value = z1;
                    document.getElementById('z2').value = z2;
                    updateLatent();
                };

                container.appendChild(canvas);
            }
        }

        function setInterpolationStart() {
            interpolateStart = { z1, z2 };
        }

        function setInterpolationEnd() {
            interpolateEnd = { z1, z2 };
        }

        function runInterpolation() {
            const container = document.getElementById('interpolation');
            container.innerHTML = '';

            const steps = 8;
            for (let i = 0; i < steps; i++) {
                const t = i / (steps - 1);
                const iz1 = interpolateStart.z1 + (interpolateEnd.z1 - interpolateStart.z1) * t;
                const iz2 = interpolateStart.z2 + (interpolateEnd.z2 - interpolateStart.z2) * t;

                const canvas = document.createElement('canvas');
                canvas.width = 80;
                canvas.height = 80;
                const ctx = canvas.getContext('2d');

                generate(iz1, iz2, canvas, ctx);
                container.appendChild(canvas);
            }
        }

        // Latent space click handler
        latentCanvas.addEventListener('click', (e) => {
            const rect = latentCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            z1 = (x / 300) * 6 - 3;
            z2 = (y / 300) * 6 - 3;

            document.getElementById('z1').value = z1;
            document.getElementById('z2').value = z2;
            updateLatent();
        });

        function hslToRgb(h, s, l) {
            h = h % 360;
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;

            let r, g, b;
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }

            return {
                r: Math.round((r + m) * 255),
                g: Math.round((g + m) * 255),
                b: Math.round((b + m) * 255)
            };
        }

        init();
    </script>
</body>
</html>
