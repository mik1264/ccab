<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Playground - ML Visualizations - CCAB</title>
    <style>
        body { margin: 0; padding: 20px; background: #0f0f1a; color: #e8e6e1; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        .back-link {
            display: inline-block; padding: 8px 16px; background: rgba(124, 58, 237, 0.2);
            color: #a78bfa; text-decoration: none; border-radius: 6px; margin-bottom: 20px;
        }
        .back-link:hover { background: rgba(124, 58, 237, 0.4); }
        h1 { color: #a78bfa; margin-bottom: 20px; }
        .container { display: flex; gap: 20px; flex-wrap: wrap; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 20px; }
        .data-panel { width: 400px; }
        .network-panel { flex: 1; min-width: 500px; }
        canvas { border-radius: 8px; cursor: crosshair; }
        .controls { margin-top: 15px; }
        .controls label { display: block; margin-bottom: 10px; }
        .controls input[type="range"] { width: 200px; }
        button { background: #7C3AED; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; margin: 5px; }
        button:hover { background: #6D28D9; }
        .stats { margin-top: 15px; font-size: 14px; }
        .legend { display: flex; gap: 20px; margin-top: 10px; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; }
        #loading { text-align: center; padding: 50px; }
        .spinner { width: 50px; height: 50px; border: 4px solid rgba(255,255,255,0.1); border-top-color: #7C3AED; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to ML Gallery</a>
    <h1>Neural Network Playground</h1>

    <div id="loading">
        <div class="spinner"></div>
        <p>Loading TensorFlow.js...</p>
    </div>

    <div class="container" id="main" style="display: none;">
        <div class="panel data-panel">
            <h3>Training Data</h3>
            <canvas id="dataCanvas" width="400" height="400"></canvas>
            <div class="legend">
                <div class="legend-item"><div class="legend-dot" style="background: #10B981;"></div> Class A</div>
                <div class="legend-item"><div class="legend-dot" style="background: #EF4444;"></div> Class B</div>
            </div>
            <div class="controls">
                <button onclick="clearData()">Clear Data</button>
                <button onclick="generateCircle()">Circle Pattern</button>
                <button onclick="generateSpiral()">Spiral Pattern</button>
            </div>
        </div>

        <div class="panel network-panel">
            <h3>Decision Boundary</h3>
            <canvas id="networkCanvas" width="400" height="400"></canvas>
            <div class="controls">
                <label>Hidden Layers: <input type="range" id="layers" min="1" max="4" value="2"> <span id="layersVal">2</span></label>
                <label>Neurons per Layer: <input type="range" id="neurons" min="2" max="16" value="8"> <span id="neuronsVal">8</span></label>
                <label>Learning Rate: <input type="range" id="lr" min="-3" max="0" step="0.1" value="-2"> <span id="lrVal">0.01</span></label>
                <button onclick="train()">Train Network</button>
                <button onclick="stopTraining()">Stop</button>
            </div>
            <div class="stats">
                <p>Epoch: <span id="epoch">0</span> | Loss: <span id="loss">-</span> | Accuracy: <span id="accuracy">-</span></p>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script>
        let dataPoints = [];
        let model = null;
        let training = false;
        let currentClass = 0;

        const dataCanvas = document.getElementById('dataCanvas');
        const dataCtx = dataCanvas.getContext('2d');
        const networkCanvas = document.getElementById('networkCanvas');
        const networkCtx = networkCanvas.getContext('2d');

        async function init() {
            await tf.ready();
            document.getElementById('loading').style.display = 'none';
            document.getElementById('main').style.display = 'flex';

            // Event listeners
            dataCanvas.addEventListener('click', addPoint);
            dataCanvas.addEventListener('contextmenu', (e) => { e.preventDefault(); currentClass = 1; addPoint(e); currentClass = 0; });

            document.getElementById('layers').addEventListener('input', (e) => {
                document.getElementById('layersVal').textContent = e.target.value;
            });
            document.getElementById('neurons').addEventListener('input', (e) => {
                document.getElementById('neuronsVal').textContent = e.target.value;
            });
            document.getElementById('lr').addEventListener('input', (e) => {
                document.getElementById('lrVal').textContent = Math.pow(10, e.target.value).toFixed(4);
            });

            generateCircle();
        }

        function addPoint(e) {
            const rect = dataCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / dataCanvas.width;
            const y = (e.clientY - rect.top) / dataCanvas.height;
            dataPoints.push({ x, y, label: currentClass });
            drawData();
        }

        function clearData() {
            dataPoints = [];
            drawData();
            clearBoundary();
        }

        function generateCircle() {
            clearData();
            for (let i = 0; i < 100; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * 0.25;
                dataPoints.push({ x: 0.5 + Math.cos(angle) * r, y: 0.5 + Math.sin(angle) * r, label: 0 });
            }
            for (let i = 0; i < 100; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = 0.3 + Math.random() * 0.15;
                dataPoints.push({ x: 0.5 + Math.cos(angle) * r, y: 0.5 + Math.sin(angle) * r, label: 1 });
            }
            drawData();
        }

        function generateSpiral() {
            clearData();
            for (let i = 0; i < 100; i++) {
                const t = i / 100 * 4 * Math.PI;
                const r = t / (4 * Math.PI) * 0.4;
                dataPoints.push({ x: 0.5 + Math.cos(t) * r + (Math.random() - 0.5) * 0.05, y: 0.5 + Math.sin(t) * r + (Math.random() - 0.5) * 0.05, label: 0 });
                dataPoints.push({ x: 0.5 - Math.cos(t) * r + (Math.random() - 0.5) * 0.05, y: 0.5 - Math.sin(t) * r + (Math.random() - 0.5) * 0.05, label: 1 });
            }
            drawData();
        }

        function drawData() {
            dataCtx.fillStyle = '#1a1a2e';
            dataCtx.fillRect(0, 0, dataCanvas.width, dataCanvas.height);

            for (let p of dataPoints) {
                dataCtx.beginPath();
                dataCtx.arc(p.x * dataCanvas.width, p.y * dataCanvas.height, 5, 0, Math.PI * 2);
                dataCtx.fillStyle = p.label === 0 ? '#10B981' : '#EF4444';
                dataCtx.fill();
            }
        }

        function clearBoundary() {
            networkCtx.fillStyle = '#1a1a2e';
            networkCtx.fillRect(0, 0, networkCanvas.width, networkCanvas.height);
        }

        function createModel() {
            const numLayers = parseInt(document.getElementById('layers').value);
            const numNeurons = parseInt(document.getElementById('neurons').value);
            const lr = Math.pow(10, parseFloat(document.getElementById('lr').value));

            model = tf.sequential();
            model.add(tf.layers.dense({ units: numNeurons, activation: 'relu', inputShape: [2] }));

            for (let i = 1; i < numLayers; i++) {
                model.add(tf.layers.dense({ units: numNeurons, activation: 'relu' }));
            }

            model.add(tf.layers.dense({ units: 1, activation: 'sigmoid' }));

            model.compile({
                optimizer: tf.train.adam(lr),
                loss: 'binaryCrossentropy',
                metrics: ['accuracy']
            });
        }

        async function train() {
            if (dataPoints.length < 10) {
                alert('Add more data points first!');
                return;
            }

            training = true;
            createModel();

            const xs = tf.tensor2d(dataPoints.map(p => [p.x, p.y]));
            const ys = tf.tensor2d(dataPoints.map(p => [p.label]));

            let epoch = 0;
            while (training) {
                const result = await model.fit(xs, ys, { epochs: 1, verbose: 0 });
                epoch++;

                document.getElementById('epoch').textContent = epoch;
                document.getElementById('loss').textContent = result.history.loss[0].toFixed(4);
                document.getElementById('accuracy').textContent = (result.history.acc[0] * 100).toFixed(1) + '%';

                if (epoch % 5 === 0) {
                    drawBoundary();
                }

                await tf.nextFrame();
            }

            xs.dispose();
            ys.dispose();
        }

        function stopTraining() {
            training = false;
        }

        async function drawBoundary() {
            const resolution = 50;
            const imageData = networkCtx.createImageData(networkCanvas.width, networkCanvas.height);

            const inputs = [];
            for (let y = 0; y < resolution; y++) {
                for (let x = 0; x < resolution; x++) {
                    inputs.push([x / resolution, y / resolution]);
                }
            }

            const predictions = await model.predict(tf.tensor2d(inputs)).data();

            for (let y = 0; y < resolution; y++) {
                for (let x = 0; x < resolution; x++) {
                    const pred = predictions[y * resolution + x];
                    const cellW = networkCanvas.width / resolution;
                    const cellH = networkCanvas.height / resolution;

                    for (let py = 0; py < cellH; py++) {
                        for (let px = 0; px < cellW; px++) {
                            const idx = 4 * ((Math.floor(y * cellH) + py) * networkCanvas.width + Math.floor(x * cellW) + px);

                            // Blend between green and red based on prediction
                            imageData.data[idx] = Math.floor(pred * 239 + (1 - pred) * 16);
                            imageData.data[idx + 1] = Math.floor((1 - pred) * 185 + pred * 68);
                            imageData.data[idx + 2] = Math.floor((1 - pred) * 129 + pred * 68);
                            imageData.data[idx + 3] = 255;
                        }
                    }
                }
            }

            networkCtx.putImageData(imageData, 0, 0);

            // Overlay data points
            for (let p of dataPoints) {
                networkCtx.beginPath();
                networkCtx.arc(p.x * networkCanvas.width, p.y * networkCanvas.height, 4, 0, Math.PI * 2);
                networkCtx.fillStyle = p.label === 0 ? '#10B981' : '#EF4444';
                networkCtx.strokeStyle = 'white';
                networkCtx.lineWidth = 2;
                networkCtx.fill();
                networkCtx.stroke();
            }
        }

        // Expose for enhance.js
        window.reset = init;

        init();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
