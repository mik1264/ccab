<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Doodle - ML Visualizations - CCAB</title>
    <style>
        body { margin: 0; padding: 20px; background: #0f0f1a; color: #e8e6e1; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        .back-link { display: inline-block; padding: 8px 16px; background: rgba(124, 58, 237, 0.2); color: #a78bfa; text-decoration: none; border-radius: 6px; margin-bottom: 20px; }
        .back-link:hover { background: rgba(124, 58, 237, 0.4); }
        h1 { color: #a78bfa; margin-bottom: 10px; }
        .subtitle { color: #888; margin-bottom: 20px; }
        .container { display: flex; gap: 30px; flex-wrap: wrap; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 20px; }
        canvas { border-radius: 8px; cursor: crosshair; }
        #drawCanvas { background: #fff; }
        #outputCanvas { background: #1a1a2e; }
        button { background: #7C3AED; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; margin: 5px; }
        button:hover { background: #6D28D9; }
        .tools { margin: 15px 0; display: flex; flex-wrap: wrap; gap: 10px; }
        .tool-btn { padding: 8px 12px; background: rgba(255,255,255,0.1); border: 2px solid transparent; }
        .tool-btn.active { border-color: #10B981; background: rgba(16, 185, 129, 0.2); }
        .color-palette { display: flex; gap: 5px; margin: 10px 0; }
        .color-swatch { width: 30px; height: 30px; border-radius: 50%; cursor: pointer; border: 2px solid transparent; }
        .color-swatch.active { border-color: white; }
        input[type="range"] { width: 150px; accent-color: #7C3AED; }
        .styles-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 15px; }
        .style-btn { padding: 10px; font-size: 12px; }
        .note { font-size: 12px; color: #888; margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 6px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to ML Gallery</a>
    <h1>Neural Doodle</h1>
    <p class="subtitle">Draw simple sketches and watch them transform (simulated Pix2Pix)</p>

    <div class="container">
        <div class="panel">
            <h3>Your Sketch</h3>
            <canvas id="drawCanvas" width="256" height="256"></canvas>

            <div class="tools">
                <button class="tool-btn active" id="penTool" onclick="setTool('pen')">‚úèÔ∏è Pen</button>
                <button class="tool-btn" id="eraserTool" onclick="setTool('eraser')">üßπ Eraser</button>
                <button class="tool-btn" id="fillTool" onclick="setTool('fill')">ü™£ Fill</button>
            </div>

            <div class="color-palette" id="palette"></div>

            <div style="margin: 10px 0;">
                <label>Brush Size: <span id="sizeVal">8</span></label>
                <input type="range" id="brushSize" min="2" max="30" value="8" oninput="updateBrushSize()">
            </div>

            <button onclick="clearCanvas()">Clear</button>
            <button onclick="transform()">Transform ‚Üí</button>
        </div>

        <div class="panel">
            <h3>Neural Output</h3>
            <canvas id="outputCanvas" width="256" height="256"></canvas>

            <h4>Transformation Style</h4>
            <div class="styles-grid">
                <button class="style-btn active" onclick="setStyle('landscape', this)">üèîÔ∏è Landscape</button>
                <button class="style-btn" onclick="setStyle('building', this)">üèõÔ∏è Building</button>
                <button class="style-btn" onclick="setStyle('abstract', this)">üé® Abstract</button>
                <button class="style-btn" onclick="setStyle('watercolor', this)">üíß Watercolor</button>
                <button class="style-btn" onclick="setStyle('neon', this)">‚ú® Neon</button>
                <button class="style-btn" onclick="setStyle('sketch', this)">‚úçÔ∏è Artistic</button>
            </div>

            <div class="note">
                This demo simulates neural image-to-image translation.
                Real Pix2Pix models require training on paired datasets.
            </div>
        </div>
    </div>

    <script>
        const drawCanvas = document.getElementById('drawCanvas');
        const drawCtx = drawCanvas.getContext('2d');
        const outputCanvas = document.getElementById('outputCanvas');
        const outputCtx = outputCanvas.getContext('2d');

        let isDrawing = false;
        let currentTool = 'pen';
        let currentColor = '#000000';
        let brushSize = 8;
        let currentStyle = 'landscape';

        const COLORS = [
            '#000000', '#FFFFFF', '#EF4444', '#F59E0B', '#10B981',
            '#3B82F6', '#8B5CF6', '#EC4899', '#6B7280', '#84CC16'
        ];

        function init() {
            // Create color palette
            const palette = document.getElementById('palette');
            COLORS.forEach((color, i) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch' + (i === 0 ? ' active' : '');
                swatch.style.background = color;
                swatch.onclick = () => selectColor(color, swatch);
                palette.appendChild(swatch);
            });

            // Clear canvas to white
            clearCanvas();

            // Drawing events
            drawCanvas.addEventListener('mousedown', startDraw);
            drawCanvas.addEventListener('mousemove', draw);
            drawCanvas.addEventListener('mouseup', stopDraw);
            drawCanvas.addEventListener('mouseout', stopDraw);

            drawCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDraw(e.touches[0]); });
            drawCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e.touches[0]); });
            drawCanvas.addEventListener('touchend', stopDraw);
        }

        function selectColor(color, swatch) {
            currentColor = color;
            document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
            swatch.classList.add('active');
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(tool + 'Tool').classList.add('active');
        }

        function updateBrushSize() {
            brushSize = parseInt(document.getElementById('brushSize').value);
            document.getElementById('sizeVal').textContent = brushSize;
        }

        function startDraw(e) {
            isDrawing = true;
            draw(e);
        }

        function draw(e) {
            if (!isDrawing) return;

            const rect = drawCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (currentTool === 'fill') {
                floodFill(Math.floor(x), Math.floor(y), currentColor);
                isDrawing = false;
                return;
            }

            drawCtx.beginPath();
            drawCtx.arc(x, y, brushSize / 2, 0, Math.PI * 2);

            if (currentTool === 'eraser') {
                drawCtx.fillStyle = '#FFFFFF';
            } else {
                drawCtx.fillStyle = currentColor;
            }

            drawCtx.fill();
        }

        function stopDraw() {
            isDrawing = false;
        }

        function floodFill(startX, startY, fillColor) {
            const imageData = drawCtx.getImageData(0, 0, drawCanvas.width, drawCanvas.height);
            const data = imageData.data;
            const width = drawCanvas.width;
            const height = drawCanvas.height;

            const startIdx = (startY * width + startX) * 4;
            const startR = data[startIdx];
            const startG = data[startIdx + 1];
            const startB = data[startIdx + 2];

            const fillRgb = hexToRgb(fillColor);
            if (startR === fillRgb.r && startG === fillRgb.g && startB === fillRgb.b) return;

            const stack = [[startX, startY]];
            const visited = new Set();

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;

                if (visited.has(key) || x < 0 || x >= width || y < 0 || y >= height) continue;
                visited.add(key);

                const idx = (y * width + x) * 4;
                if (Math.abs(data[idx] - startR) > 30 ||
                    Math.abs(data[idx + 1] - startG) > 30 ||
                    Math.abs(data[idx + 2] - startB) > 30) continue;

                data[idx] = fillRgb.r;
                data[idx + 1] = fillRgb.g;
                data[idx + 2] = fillRgb.b;

                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }

            drawCtx.putImageData(imageData, 0, 0);
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        function clearCanvas() {
            drawCtx.fillStyle = '#FFFFFF';
            drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
            outputCtx.fillStyle = '#1a1a2e';
            outputCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
        }

        function setStyle(style, btn) {
            currentStyle = style;
            document.querySelectorAll('.style-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }

        function transform() {
            const inputData = drawCtx.getImageData(0, 0, drawCanvas.width, drawCanvas.height);
            const outputData = outputCtx.createImageData(outputCanvas.width, outputCanvas.height);

            for (let y = 0; y < outputCanvas.height; y++) {
                for (let x = 0; x < outputCanvas.width; x++) {
                    const idx = (y * outputCanvas.width + x) * 4;
                    const inputR = inputData.data[idx];
                    const inputG = inputData.data[idx + 1];
                    const inputB = inputData.data[idx + 2];

                    const isEdge = detectEdge(inputData.data, x, y, outputCanvas.width, outputCanvas.height);
                    const brightness = (inputR + inputG + inputB) / 3 / 255;

                    let r, g, b;

                    switch (currentStyle) {
                        case 'landscape':
                            // Green for bright areas, brown for dark
                            if (brightness > 0.8) {
                                // Sky
                                r = 135 + Math.random() * 20;
                                g = 206 + Math.random() * 20;
                                b = 235 + Math.random() * 20;
                            } else if (brightness > 0.5) {
                                // Grass
                                r = 34 + Math.random() * 40;
                                g = 139 + Math.random() * 40;
                                b = 34 + Math.random() * 20;
                            } else {
                                // Earth
                                r = 139 + Math.random() * 20;
                                g = 90 + Math.random() * 20;
                                b = 43 + Math.random() * 20;
                            }
                            if (isEdge) {
                                r *= 0.7; g *= 0.7; b *= 0.7;
                            }
                            break;

                        case 'building':
                            // Concrete/stone texture
                            const noise = Math.random() * 30 - 15;
                            if (brightness > 0.8) {
                                r = 200 + noise; g = 220 + noise; b = 240 + noise;
                            } else {
                                r = 128 + brightness * 50 + noise;
                                g = 128 + brightness * 50 + noise;
                                b = 140 + brightness * 50 + noise;
                            }
                            if (isEdge) {
                                r = 60; g = 60; b = 70;
                            }
                            break;

                        case 'abstract':
                            // Colorful transformation based on input colors
                            const hue = (inputR - inputB + 255) / 510 * 360;
                            const sat = isEdge ? 1 : 0.7;
                            const light = 0.3 + brightness * 0.4;
                            const rgb = hslToRgb(hue, sat, light);
                            r = rgb.r; g = rgb.g; b = rgb.b;
                            break;

                        case 'watercolor':
                            // Soft, blended colors
                            const bleed = Math.random() * 40 - 20;
                            r = inputR * 0.7 + 100 + bleed;
                            g = inputG * 0.7 + 80 + bleed;
                            b = inputB * 0.8 + 120 + bleed;
                            // Watercolor edges
                            if (isEdge && Math.random() > 0.5) {
                                r *= 0.6; g *= 0.6; b *= 0.8;
                            }
                            break;

                        case 'neon':
                            // Neon glow effect
                            if (brightness < 0.95) {
                                const neonHue = (x + y) % 360;
                                const neonRgb = hslToRgb(neonHue, 1, 0.5 + isEdge * 0.3);
                                r = neonRgb.r;
                                g = neonRgb.g;
                                b = neonRgb.b;
                            } else {
                                r = 10; g = 10; b = 20;
                            }
                            break;

                        case 'sketch':
                            // Pencil sketch effect
                            const sketchVal = isEdge ? 30 : 200 + (1 - brightness) * 55;
                            const hatching = Math.sin((x + y) * 0.5) > 0.8 ? -30 : 0;
                            r = sketchVal + hatching;
                            g = sketchVal + hatching;
                            b = sketchVal + hatching + 10;
                            break;
                    }

                    outputData.data[idx] = Math.max(0, Math.min(255, r));
                    outputData.data[idx + 1] = Math.max(0, Math.min(255, g));
                    outputData.data[idx + 2] = Math.max(0, Math.min(255, b));
                    outputData.data[idx + 3] = 255;
                }
            }

            outputCtx.putImageData(outputData, 0, 0);
        }

        function detectEdge(data, x, y, width, height) {
            if (x < 1 || x >= width - 1 || y < 1 || y >= height - 1) return false;

            const getGray = (px, py) => {
                const idx = (py * width + px) * 4;
                return (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
            };

            const center = getGray(x, y);
            const left = getGray(x - 1, y);
            const right = getGray(x + 1, y);
            const top = getGray(x, y - 1);
            const bottom = getGray(x, y + 1);

            const diff = Math.abs(center - left) + Math.abs(center - right) +
                         Math.abs(center - top) + Math.abs(center - bottom);

            return diff > 100;
        }

        function hslToRgb(h, s, l) {
            h = h % 360;
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;

            let r, g, b;
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }

            return {
                r: Math.round((r + m) * 255),
                g: Math.round((g + m) * 255),
                b: Math.round((b + m) * 255)
            };
        }

        init();
    </script>
</body>
</html>
