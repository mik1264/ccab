<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ELBO Geometry - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px;
            color: #c9a227; text-decoration: none; font-weight: 500;
            z-index: 1000; transition: all 0.3s ease;
        }
        .back-link:hover { color: #ffd700; transform: translateX(-4px); }
        .container { max-width: 1600px; margin: 0 auto; padding: 60px 20px 20px; }
        h1 { text-align: center; color: #c9a227; margin-bottom: 0.5rem; font-size: 2rem; }
        .subtitle { text-align: center; color: #888; margin-bottom: 1.5rem; }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
        }

        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .canvas-container {
            background: rgba(20, 20, 35, 0.9);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(201, 162, 39, 0.3);
        }

        .canvas-container h3 {
            color: #c9a227;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        canvas {
            width: 100%;
            background: #0a0a15;
            border-radius: 8px;
        }

        .controls {
            background: rgba(20, 20, 35, 0.9);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(201, 162, 39, 0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: #c9a227;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group .value {
            color: #888;
            font-size: 0.85rem;
        }

        .btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #c9a227, #d4af37);
            color: #0a0a0f;
        }

        .btn-secondary {
            background: rgba(201, 162, 39, 0.2);
            color: #c9a227;
            border: 1px solid rgba(201, 162, 39, 0.4);
        }

        .btn:hover { transform: translateY(-2px); }

        .info-panel {
            background: rgba(30, 30, 50, 0.8);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .info-panel h4 {
            color: #c9a227;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .metric-row:last-child { border-bottom: none; }

        .metric-label { color: #888; font-size: 0.9rem; }
        .metric-value {
            font-family: monospace;
            font-size: 1rem;
            font-weight: bold;
        }

        .metric-value.evidence { color: #f87171; }
        .metric-value.elbo { color: #4ade80; }
        .metric-value.kl { color: #60a5fa; }
        .metric-value.entropy { color: #a78bfa; }
        .metric-value.fit { color: #fbbf24; }

        .equation {
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.85rem;
            margin-top: 10px;
            line-height: 1.6;
        }

        .equation .var {
            color: #4ade80;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 15px;
            font-size: 0.85rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .bar-chart {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }

        .bar-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bar-label {
            width: 80px;
            font-size: 0.8rem;
            color: #888;
        }

        .bar-container {
            flex: 1;
            height: 24px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .bar-value {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75rem;
            font-family: monospace;
            color: white;
            text-shadow: 0 0 4px rgba(0,0,0,0.8);
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .preset-btn {
            padding: 8px;
            font-size: 0.8rem;
            background: rgba(201, 162, 39, 0.15);
            border: 1px solid rgba(201, 162, 39, 0.3);
            color: #c9a227;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            background: rgba(201, 162, 39, 0.3);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to ML Visualizations</a>

    <div class="container">
        <h1>ELBO as a Geometry Problem</h1>
        <p class="subtitle">Visualizing the Evidence Lower Bound in Variational Inference</p>

        <div class="main-content">
            <div class="visualization-area">
                <div class="canvas-container">
                    <h3>Distributions: True Posterior p(z|x) vs Variational q(z)</h3>
                    <canvas id="distributionCanvas" width="900" height="280"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #f87171;"></div>
                            <span>True Posterior p(z|x)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4ade80;"></div>
                            <span>Variational q(z)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(96, 165, 250, 0.3);"></div>
                            <span>KL Divergence Area</span>
                        </div>
                    </div>
                </div>

                <div class="canvas-container">
                    <h3>ELBO Decomposition: Reconstruction − KL</h3>
                    <canvas id="decompositionCanvas" width="900" height="200"></canvas>
                </div>

                <div class="canvas-container">
                    <h3>Optimization Landscape: log p(x) ≥ ELBO</h3>
                    <canvas id="landscapeCanvas" width="900" height="220"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="preset-buttons">
                    <button class="preset-btn" data-preset="good">Good Fit</button>
                    <button class="preset-btn" data-preset="poor">Poor Fit</button>
                    <button class="preset-btn" data-preset="wide">Wide q</button>
                    <button class="preset-btn" data-preset="narrow">Narrow q</button>
                </div>

                <div class="control-group">
                    <label>q(z) Mean (μ_q)</label>
                    <input type="range" id="qMean" min="-3" max="3" step="0.1" value="0">
                    <div class="value">μ = <span id="qMeanValue">0.0</span></div>
                </div>

                <div class="control-group">
                    <label>q(z) Std Dev (σ_q)</label>
                    <input type="range" id="qStd" min="0.2" max="3" step="0.1" value="1">
                    <div class="value">σ = <span id="qStdValue">1.0</span></div>
                </div>

                <div class="control-group">
                    <label>True Posterior Mean (μ_p)</label>
                    <input type="range" id="pMean" min="-2" max="2" step="0.1" value="0.5">
                    <div class="value">μ = <span id="pMeanValue">0.5</span></div>
                </div>

                <div class="control-group">
                    <label>True Posterior Std (σ_p)</label>
                    <input type="range" id="pStd" min="0.3" max="2" step="0.1" value="0.8">
                    <div class="value">σ = <span id="pStdValue">0.8</span></div>
                </div>

                <button class="btn btn-primary" id="optimizeBtn">Optimize q → p</button>
                <button class="btn btn-secondary" id="resetBtn">Reset</button>

                <div class="info-panel">
                    <h4>ELBO Components</h4>
                    <div class="bar-chart">
                        <div class="bar-row">
                            <span class="bar-label">Evidence</span>
                            <div class="bar-container">
                                <div class="bar-fill" id="evidenceBar" style="background: #f87171; width: 50%;"></div>
                                <span class="bar-value" id="evidenceValue">0.00</span>
                            </div>
                        </div>
                        <div class="bar-row">
                            <span class="bar-label">ELBO</span>
                            <div class="bar-container">
                                <div class="bar-fill" id="elboBar" style="background: #4ade80; width: 40%;"></div>
                                <span class="bar-value" id="elboValue">0.00</span>
                            </div>
                        </div>
                        <div class="bar-row">
                            <span class="bar-label">KL Gap</span>
                            <div class="bar-container">
                                <div class="bar-fill" id="klBar" style="background: #60a5fa; width: 10%;"></div>
                                <span class="bar-value" id="klValue">0.00</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="info-panel">
                    <h4>Key Equation</h4>
                    <div class="equation">
                        log p(x) = <span class="var">ELBO</span> + KL(q||p)<br><br>
                        <span class="var">ELBO</span> = E_q[log p(x,z)] - E_q[log q(z)]<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= E_q[log p(x|z)] - KL(q||prior)<br><br>
                        <span style="color: #888;">Maximize ELBO ⟺ Minimize KL(q||p)</span>
                    </div>
                </div>

                <div class="info-panel">
                    <h4>Detailed Metrics</h4>
                    <div class="metric-row">
                        <span class="metric-label">log p(x) (Evidence):</span>
                        <span class="metric-value evidence" id="metricEvidence">-</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">ELBO:</span>
                        <span class="metric-value elbo" id="metricElbo">-</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">KL(q || p):</span>
                        <span class="metric-value kl" id="metricKL">-</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">H[q] (Entropy):</span>
                        <span class="metric-value entropy" id="metricEntropy">-</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">E_q[log p(x|z)]:</span>
                        <span class="metric-value fit" id="metricFit">-</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const distCanvas = document.getElementById('distributionCanvas');
        const distCtx = distCanvas.getContext('2d');
        const decompCanvas = document.getElementById('decompositionCanvas');
        const decompCtx = decompCanvas.getContext('2d');
        const landCanvas = document.getElementById('landscapeCanvas');
        const landCtx = landCanvas.getContext('2d');

        // State
        let state = {
            qMean: 0,
            qStd: 1,
            pMean: 0.5,
            pStd: 0.8,
            animating: false
        };

        // Gaussian PDF
        function gaussianPDF(x, mean, std) {
            const z = (x - mean) / std;
            return Math.exp(-0.5 * z * z) / (std * Math.sqrt(2 * Math.PI));
        }

        // KL divergence between two Gaussians
        function klDivergence(qMean, qStd, pMean, pStd) {
            const varQ = qStd * qStd;
            const varP = pStd * pStd;
            return Math.log(pStd / qStd) + (varQ + (qMean - pMean) ** 2) / (2 * varP) - 0.5;
        }

        // Entropy of Gaussian
        function gaussianEntropy(std) {
            return 0.5 * Math.log(2 * Math.PI * Math.E * std * std);
        }

        // Compute metrics
        function computeMetrics() {
            const { qMean, qStd, pMean, pStd } = state;

            // KL(q || p)
            const kl = klDivergence(qMean, qStd, pMean, pStd);

            // Evidence (fixed for visualization, based on prior)
            const evidence = -0.5 * Math.log(2 * Math.PI) - 0.5;  // Standard normal log-likelihood

            // ELBO = Evidence - KL
            const elbo = evidence - kl;

            // Entropy of q
            const entropy = gaussianEntropy(qStd);

            // Expected log-likelihood (reconstruction term approximation)
            const reconstruction = elbo + klDivergence(qMean, qStd, 0, 1);  // Vs prior N(0,1)

            return { evidence, elbo, kl, entropy, reconstruction };
        }

        function updateDisplay() {
            drawDistributions();
            drawDecomposition();
            drawLandscape();
            updateMetrics();
        }

        function drawDistributions() {
            const ctx = distCtx;
            const W = distCanvas.width;
            const H = distCanvas.height;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, W, H);

            const marginX = 50;
            const marginY = 30;
            const plotW = W - 2 * marginX;
            const plotH = H - 2 * marginY;

            // X range
            const xMin = -5, xMax = 5;
            const xScale = plotW / (xMax - xMin);

            // Find max density for scaling
            let maxDensity = 0;
            for (let x = xMin; x <= xMax; x += 0.1) {
                maxDensity = Math.max(maxDensity,
                    gaussianPDF(x, state.pMean, state.pStd),
                    gaussianPDF(x, state.qMean, state.qStd)
                );
            }
            const yScale = plotH / (maxDensity * 1.1);

            // Draw axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(marginX, H - marginY);
            ctx.lineTo(W - marginX, H - marginY);
            ctx.moveTo(marginX, H - marginY);
            ctx.lineTo(marginX, marginY);
            ctx.stroke();

            // Draw axis labels
            ctx.fillStyle = '#888';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'center';
            for (let x = -4; x <= 4; x += 2) {
                const px = marginX + (x - xMin) * xScale;
                ctx.fillText(x.toString(), px, H - marginY + 15);
            }

            // Draw KL divergence shaded area
            ctx.fillStyle = 'rgba(96, 165, 250, 0.2)';
            ctx.beginPath();
            for (let i = 0; i <= plotW; i++) {
                const x = xMin + i / xScale;
                const q = gaussianPDF(x, state.qMean, state.qStd);
                const p = gaussianPDF(x, state.pMean, state.pStd);

                if (q > 0.001) {
                    const px = marginX + i;
                    const py = H - marginY - Math.min(q, p) * yScale;
                    if (i === 0) {
                        ctx.moveTo(px, H - marginY);
                    }
                    ctx.lineTo(px, py);
                }
            }
            ctx.lineTo(marginX + plotW, H - marginY);
            ctx.closePath();
            ctx.fill();

            // Draw true posterior p(z|x)
            ctx.strokeStyle = '#f87171';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i <= plotW; i++) {
                const x = xMin + i / xScale;
                const y = gaussianPDF(x, state.pMean, state.pStd);
                const px = marginX + i;
                const py = H - marginY - y * yScale;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Draw variational q(z)
            ctx.strokeStyle = '#4ade80';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i <= plotW; i++) {
                const x = xMin + i / xScale;
                const y = gaussianPDF(x, state.qMean, state.qStd);
                const px = marginX + i;
                const py = H - marginY - y * yScale;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Draw means
            const qMeanPx = marginX + (state.qMean - xMin) * xScale;
            const pMeanPx = marginX + (state.pMean - xMin) * xScale;

            ctx.strokeStyle = '#4ade80';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(qMeanPx, H - marginY);
            ctx.lineTo(qMeanPx, marginY);
            ctx.stroke();

            ctx.strokeStyle = '#f87171';
            ctx.beginPath();
            ctx.moveTo(pMeanPx, H - marginY);
            ctx.lineTo(pMeanPx, marginY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Labels
            ctx.fillStyle = '#f87171';
            ctx.textAlign = 'left';
            ctx.fillText('p(z|x)', W - marginX - 50, marginY + 20);

            ctx.fillStyle = '#4ade80';
            ctx.fillText('q(z)', W - marginX - 50, marginY + 40);

            ctx.fillStyle = '#888';
            ctx.textAlign = 'center';
            ctx.fillText('z', W / 2, H - 5);
        }

        function drawDecomposition() {
            const ctx = decompCtx;
            const W = decompCanvas.width;
            const H = decompCanvas.height;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, W, H);

            const metrics = computeMetrics();
            const marginX = 60;
            const marginY = 40;

            // Bars showing ELBO decomposition
            const maxVal = Math.max(Math.abs(metrics.elbo), Math.abs(metrics.kl), Math.abs(metrics.entropy), Math.abs(metrics.reconstruction)) * 1.2;
            const barWidth = 60;
            const barGap = 120;
            const centerY = H / 2;

            const components = [
                { label: 'ELBO', value: metrics.elbo, color: '#4ade80' },
                { label: 'Reconstruction', value: metrics.reconstruction, color: '#fbbf24' },
                { label: '-KL(q||prior)', value: -klDivergence(state.qMean, state.qStd, 0, 1), color: '#60a5fa' },
                { label: 'H[q]', value: metrics.entropy, color: '#a78bfa' },
                { label: '-E_q[log p]', value: -metrics.reconstruction - metrics.entropy, color: '#f87171' }
            ];

            // Zero line
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(marginX, centerY);
            ctx.lineTo(W - marginX, centerY);
            ctx.stroke();

            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText('0', marginX - 5, centerY + 4);

            // Draw bars
            const scale = (H / 2 - marginY) / maxVal;

            components.forEach((comp, i) => {
                const x = marginX + 40 + i * barGap;
                const barH = Math.abs(comp.value) * scale;
                const y = comp.value >= 0 ? centerY - barH : centerY;

                ctx.fillStyle = comp.color;
                ctx.fillRect(x - barWidth / 2, y, barWidth, barH);

                // Label
                ctx.fillStyle = '#888';
                ctx.textAlign = 'center';
                ctx.font = '11px sans-serif';
                ctx.fillText(comp.label, x, H - 10);

                // Value
                ctx.fillStyle = comp.color;
                ctx.font = '12px monospace';
                const valueY = comp.value >= 0 ? y - 8 : y + barH + 15;
                ctx.fillText(comp.value.toFixed(2), x, valueY);
            });

            // Title
            ctx.fillStyle = '#c9a227';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('ELBO = E_q[log p(x|z)] − KL(q(z) || p(z))', marginX, 20);
        }

        function drawLandscape() {
            const ctx = landCtx;
            const W = landCanvas.width;
            const H = landCanvas.height;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, W, H);

            const marginX = 60;
            const marginY = 30;
            const plotW = W - 2 * marginX;
            const plotH = H - 2 * marginY;

            // Show ELBO vs Evidence relationship across σ_q values
            const sigmaRange = { min: 0.2, max: 3 };
            const numPoints = 100;

            // Compute ELBO for different sigma values (holding mean fixed at current qMean)
            const elbos = [];
            const kls = [];
            for (let i = 0; i < numPoints; i++) {
                const sigma = sigmaRange.min + (sigmaRange.max - sigmaRange.min) * i / (numPoints - 1);
                const kl = klDivergence(state.qMean, sigma, state.pMean, state.pStd);
                const evidence = -0.5 * Math.log(2 * Math.PI) - 0.5;
                elbos.push({ sigma, elbo: evidence - kl, kl });
                kls.push(kl);
            }

            // Find scales
            const minElbo = Math.min(...elbos.map(e => e.elbo));
            const maxElbo = Math.max(...elbos.map(e => e.elbo));
            const evidence = -0.5 * Math.log(2 * Math.PI) - 0.5;
            const yMin = Math.min(minElbo, evidence) - 0.5;
            const yMax = evidence + 0.5;
            const yScale = plotH / (yMax - yMin);
            const xScale = plotW / (sigmaRange.max - sigmaRange.min);

            // Draw axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(marginX, H - marginY);
            ctx.lineTo(W - marginX, H - marginY);
            ctx.moveTo(marginX, H - marginY);
            ctx.lineTo(marginX, marginY);
            ctx.stroke();

            // Draw evidence line (constant)
            ctx.strokeStyle = '#f87171';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            const evidenceY = H - marginY - (evidence - yMin) * yScale;
            ctx.beginPath();
            ctx.moveTo(marginX, evidenceY);
            ctx.lineTo(W - marginX, evidenceY);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#f87171';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('log p(x) = ' + evidence.toFixed(2), W - marginX - 100, evidenceY - 8);

            // Draw ELBO curve
            ctx.strokeStyle = '#4ade80';
            ctx.lineWidth = 2;
            ctx.beginPath();
            elbos.forEach((e, i) => {
                const x = marginX + (e.sigma - sigmaRange.min) * xScale;
                const y = H - marginY - (e.elbo - yMin) * yScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Fill gap (KL divergence area)
            ctx.fillStyle = 'rgba(96, 165, 250, 0.2)';
            ctx.beginPath();
            ctx.moveTo(marginX, evidenceY);
            elbos.forEach((e, i) => {
                const x = marginX + (e.sigma - sigmaRange.min) * xScale;
                const y = H - marginY - (e.elbo - yMin) * yScale;
                ctx.lineTo(x, y);
            });
            ctx.lineTo(W - marginX, evidenceY);
            ctx.closePath();
            ctx.fill();

            // Mark current position
            const currentX = marginX + (state.qStd - sigmaRange.min) * xScale;
            const currentMetrics = computeMetrics();
            const currentY = H - marginY - (currentMetrics.elbo - yMin) * yScale;

            ctx.fillStyle = '#c9a227';
            ctx.beginPath();
            ctx.arc(currentX, currentY, 8, 0, Math.PI * 2);
            ctx.fill();

            // Labels
            ctx.fillStyle = '#888';
            ctx.textAlign = 'center';
            ctx.fillText('σ_q (width of variational distribution)', W / 2, H - 5);

            ctx.save();
            ctx.translate(15, H / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('Value', 0, 0);
            ctx.restore();

            // Axis labels
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            for (let s = 0.5; s <= 3; s += 0.5) {
                const x = marginX + (s - sigmaRange.min) * xScale;
                ctx.fillText(s.toFixed(1), x, H - marginY + 15);
            }

            // Legend
            ctx.fillStyle = '#4ade80';
            ctx.textAlign = 'left';
            ctx.fillText('ELBO', marginX + 10, marginY + 15);

            ctx.fillStyle = '#60a5fa';
            ctx.fillText('KL gap', marginX + 10, marginY + 30);
        }

        function updateMetrics() {
            const metrics = computeMetrics();

            document.getElementById('metricEvidence').textContent = metrics.evidence.toFixed(3);
            document.getElementById('metricElbo').textContent = metrics.elbo.toFixed(3);
            document.getElementById('metricKL').textContent = metrics.kl.toFixed(3);
            document.getElementById('metricEntropy').textContent = metrics.entropy.toFixed(3);
            document.getElementById('metricFit').textContent = metrics.reconstruction.toFixed(3);

            // Update bars
            const maxVal = Math.abs(metrics.evidence) + 2;
            const evidencePct = (metrics.evidence + maxVal) / (2 * maxVal) * 100;
            const elboPct = (metrics.elbo + maxVal) / (2 * maxVal) * 100;
            const klPct = metrics.kl / maxVal * 100;

            document.getElementById('evidenceBar').style.width = Math.max(0, evidencePct) + '%';
            document.getElementById('elboBar').style.width = Math.max(0, elboPct) + '%';
            document.getElementById('klBar').style.width = Math.min(100, klPct) + '%';

            document.getElementById('evidenceValue').textContent = metrics.evidence.toFixed(2);
            document.getElementById('elboValue').textContent = metrics.elbo.toFixed(2);
            document.getElementById('klValue').textContent = metrics.kl.toFixed(2);
        }

        // Event listeners
        ['qMean', 'qStd', 'pMean', 'pStd'].forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener('input', e => {
                state[id] = parseFloat(e.target.value);
                document.getElementById(id + 'Value').textContent = state[id].toFixed(1);
                updateDisplay();
            });
        });

        // Presets
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                switch (preset) {
                    case 'good':
                        state.qMean = state.pMean;
                        state.qStd = state.pStd;
                        break;
                    case 'poor':
                        state.qMean = state.pMean + 2;
                        state.qStd = state.pStd * 2;
                        break;
                    case 'wide':
                        state.qMean = state.pMean;
                        state.qStd = state.pStd * 2.5;
                        break;
                    case 'narrow':
                        state.qMean = state.pMean;
                        state.qStd = state.pStd * 0.3;
                        break;
                }
                document.getElementById('qMean').value = state.qMean;
                document.getElementById('qStd').value = state.qStd;
                document.getElementById('qMeanValue').textContent = state.qMean.toFixed(1);
                document.getElementById('qStdValue').textContent = state.qStd.toFixed(1);
                updateDisplay();
            });
        });

        // Optimize button
        document.getElementById('optimizeBtn').addEventListener('click', () => {
            if (state.animating) return;
            state.animating = true;

            const targetMean = state.pMean;
            const targetStd = state.pStd;
            const startMean = state.qMean;
            const startStd = state.qStd;
            const duration = 1500;
            const startTime = Date.now();

            function animate() {
                const t = Math.min(1, (Date.now() - startTime) / duration);
                const ease = 1 - Math.pow(1 - t, 3);

                state.qMean = startMean + (targetMean - startMean) * ease;
                state.qStd = startStd + (targetStd - startStd) * ease;

                document.getElementById('qMean').value = state.qMean;
                document.getElementById('qStd').value = state.qStd;
                document.getElementById('qMeanValue').textContent = state.qMean.toFixed(1);
                document.getElementById('qStdValue').textContent = state.qStd.toFixed(1);

                updateDisplay();

                if (t < 1) {
                    requestAnimationFrame(animate);
                } else {
                    state.animating = false;
                }
            }

            animate();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            state.qMean = 0;
            state.qStd = 1;
            document.getElementById('qMean').value = 0;
            document.getElementById('qStd').value = 1;
            document.getElementById('qMeanValue').textContent = '0.0';
            document.getElementById('qStdValue').textContent = '1.0';
            updateDisplay();
        });

        // Initialize
        updateDisplay();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
