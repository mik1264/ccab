<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Tangent Kernel Intuition - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px;
            color: #7c3aed; text-decoration: none; font-weight: 500;
            z-index: 1000; transition: all 0.3s ease;
        }
        .back-link:hover { color: #a78bfa; transform: translateX(-4px); }
        .container { max-width: 1400px; margin: 0 auto; padding: 60px 20px 20px; }
        h1 { text-align: center; color: #7c3aed; margin-bottom: 0.5rem; font-size: 1.8rem; }
        .subtitle { text-align: center; color: #888; margin-bottom: 1.5rem; font-size: 0.95rem; }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
        }

        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .canvas-container {
            background: rgba(20, 20, 35, 0.9);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(124, 58, 237, 0.3);
        }

        .canvas-container h3 {
            color: #7c3aed;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        canvas {
            width: 100%;
            background: #0a0a15;
            border-radius: 8px;
        }

        .row { display: flex; gap: 15px; }
        .row > * { flex: 1; }

        .controls {
            background: rgba(20, 20, 35, 0.9);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(124, 58, 237, 0.3);
        }

        .control-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(124, 58, 237, 0.2);
        }
        .control-section:last-child { border-bottom: none; }

        .control-section h4 {
            color: #7c3aed;
            margin-bottom: 12px;
            font-size: 0.9rem;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            color: #aaa;
            margin-bottom: 5px;
            font-size: 0.85rem;
        }

        .control-group .value {
            color: #7c3aed;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #7c3aed;
            border-radius: 50%;
            cursor: pointer;
        }

        .btn {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #7c3aed, #6366f1);
            color: white;
        }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(124, 58, 237, 0.3); }

        .btn-secondary {
            background: rgba(124, 58, 237, 0.2);
            color: #a78bfa;
            border: 1px solid rgba(124, 58, 237, 0.3);
        }
        .btn-secondary:hover { background: rgba(124, 58, 237, 0.3); }

        .stats {
            background: rgba(124, 58, 237, 0.1);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.85rem;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }

        .stat-row:last-child { margin-bottom: 0; }

        .stat-value { color: #a78bfa; font-weight: 600; }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 10px;
            font-size: 0.8rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .info-panel {
            background: rgba(124, 58, 237, 0.1);
            border: 1px solid rgba(124, 58, 237, 0.2);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.8rem;
            line-height: 1.5;
            color: #aaa;
        }

        .info-panel strong { color: #a78bfa; }

        @media (max-width: 1100px) {
            .main-content { grid-template-columns: 1fr; }
            .row { flex-direction: column; }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to ML Visualizations</a>

    <div class="container">
        <h1>Neural Tangent Kernel Intuition</h1>
        <p class="subtitle">Wide networks behave like kernel regression with a fixed kernel</p>

        <div class="main-content">
            <div class="visualization-area">
                <div class="canvas-container">
                    <h3>Function Approximation: Neural Network vs Kernel Regression</h3>
                    <canvas id="mainCanvas" height="300"></canvas>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-color" style="background: #666;"></div>True function</div>
                        <div class="legend-item"><div class="legend-color" style="background: #f97316;"></div>Neural Network</div>
                        <div class="legend-item"><div class="legend-color" style="background: #22c55e;"></div>Kernel Regression (NTK)</div>
                        <div class="legend-item"><div class="legend-color" style="background: #fff;"></div>Training Points</div>
                    </div>
                </div>

                <div class="row">
                    <div class="canvas-container">
                        <h3>Kernel Matrix (NTK)</h3>
                        <canvas id="kernelCanvas" height="200"></canvas>
                    </div>
                    <div class="canvas-container">
                        <h3>Training Convergence</h3>
                        <canvas id="lossCanvas" height="200"></canvas>
                    </div>
                </div>

                <div class="info-panel">
                    <strong>Key Insight:</strong> The Neural Tangent Kernel (NTK) theory shows that infinitely wide neural networks
                    trained with gradient descent are equivalent to kernel regression with a deterministic kernel.
                    As network width increases, the NTK stays nearly constant during training, and the network's predictions
                    converge to those of kernel regression. This demo visualizes this correspondence.
                </div>
            </div>

            <div class="controls">
                <div class="control-section">
                    <h4>Network Architecture</h4>
                    <div class="control-group">
                        <label>Hidden Width <span class="value" id="widthVal">64</span></label>
                        <input type="range" id="width" min="4" max="512" step="4" value="64">
                    </div>
                    <div class="control-group">
                        <label>Depth (Layers) <span class="value" id="depthVal">2</span></label>
                        <input type="range" id="depth" min="1" max="5" step="1" value="2">
                    </div>
                </div>

                <div class="control-section">
                    <h4>Training</h4>
                    <div class="control-group">
                        <label>Learning Rate <span class="value" id="lrVal">0.01</span></label>
                        <input type="range" id="lr" min="0.001" max="0.1" step="0.001" value="0.01">
                    </div>
                    <div class="control-group">
                        <label>Train Steps <span class="value" id="stepsVal">500</span></label>
                        <input type="range" id="steps" min="100" max="2000" step="100" value="500">
                    </div>
                </div>

                <div class="control-section">
                    <h4>NTK Kernel</h4>
                    <div class="control-group">
                        <label>Length Scale <span class="value" id="lengthVal">0.3</span></label>
                        <input type="range" id="length" min="0.05" max="1" step="0.05" value="0.3">
                    </div>
                    <div class="control-group">
                        <label>Regularization (λ) <span class="value" id="regVal">0.001</span></label>
                        <input type="range" id="reg" min="0.0001" max="0.1" step="0.0001" value="0.001">
                    </div>
                </div>

                <div class="control-section">
                    <h4>Data</h4>
                    <div class="control-group">
                        <label>Training Points <span class="value" id="pointsVal">10</span></label>
                        <input type="range" id="points" min="5" max="30" step="1" value="10">
                    </div>
                    <div class="control-group">
                        <label>Noise Level <span class="value" id="noiseVal">0.1</span></label>
                        <input type="range" id="noise" min="0" max="0.5" step="0.05" value="0.1">
                    </div>
                </div>

                <button class="btn btn-primary" id="trainBtn">Train Network</button>
                <button class="btn btn-secondary" id="resetBtn">Reset & Regenerate Data</button>

                <div class="stats">
                    <div class="stat-row">
                        <span>NN Loss:</span>
                        <span class="stat-value" id="nnLoss">-</span>
                    </div>
                    <div class="stat-row">
                        <span>Kernel Loss:</span>
                        <span class="stat-value" id="kernelLoss">-</span>
                    </div>
                    <div class="stat-row">
                        <span>Prediction MSE:</span>
                        <span class="stat-value" id="predMSE">-</span>
                    </div>
                    <div class="stat-row">
                        <span>Epoch:</span>
                        <span class="stat-value" id="epoch">0</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const mainCanvas = document.getElementById('mainCanvas');
        const mainCtx = mainCanvas.getContext('2d');
        const kernelCanvas = document.getElementById('kernelCanvas');
        const kernelCtx = kernelCanvas.getContext('2d');
        const lossCanvas = document.getElementById('lossCanvas');
        const lossCtx = lossCanvas.getContext('2d');

        let hiddenWidth = 64;
        let depth = 2;
        let learningRate = 0.01;
        let trainSteps = 500;
        let lengthScale = 0.3;
        let regularization = 0.001;
        let numPoints = 10;
        let noiseLevel = 0.1;

        let trainX = [];
        let trainY = [];
        let lossHistory = [];
        let kernelLossHistory = [];

        let weights = [];
        let biases = [];

        function trueFunction(x) {
            return Math.sin(3 * Math.PI * x) * 0.5 + 0.3 * Math.cos(7 * x);
        }

        function generateData() {
            trainX = [];
            trainY = [];
            for (let i = 0; i < numPoints; i++) {
                const x = Math.random();
                const y = trueFunction(x) + (Math.random() - 0.5) * 2 * noiseLevel;
                trainX.push(x);
                trainY.push(y);
            }
            lossHistory = [];
            kernelLossHistory = [];
        }

        function initNetwork() {
            weights = [];
            biases = [];

            weights.push(randomMatrix(hiddenWidth, 1, 1 / Math.sqrt(1)));
            biases.push(new Array(hiddenWidth).fill(0));

            for (let i = 1; i < depth; i++) {
                weights.push(randomMatrix(hiddenWidth, hiddenWidth, 1 / Math.sqrt(hiddenWidth)));
                biases.push(new Array(hiddenWidth).fill(0));
            }

            weights.push(randomMatrix(1, hiddenWidth, 1 / Math.sqrt(hiddenWidth)));
            biases.push([0]);
        }

        function randomMatrix(rows, cols, scale) {
            const mat = [];
            for (let i = 0; i < rows; i++) {
                mat[i] = [];
                for (let j = 0; j < cols; j++) {
                    mat[i][j] = (Math.random() * 2 - 1) * scale;
                }
            }
            return mat;
        }

        function relu(x) { return Math.max(0, x); }
        function reluDeriv(x) { return x > 0 ? 1 : 0; }

        function forward(x) {
            let activations = [[x]];
            let preActivations = [];

            for (let l = 0; l < weights.length; l++) {
                const W = weights[l];
                const b = biases[l];
                const input = activations[activations.length - 1];
                const output = [];
                const pre = [];

                for (let i = 0; i < W.length; i++) {
                    let sum = b[i];
                    for (let j = 0; j < W[i].length; j++) {
                        sum += W[i][j] * input[j];
                    }
                    pre.push(sum);
                    output.push(l < weights.length - 1 ? relu(sum) : sum);
                }

                preActivations.push(pre);
                activations.push(output);
            }

            return { activations, preActivations, output: activations[activations.length - 1][0] };
        }

        function backward(x, y) {
            const { activations, preActivations, output } = forward(x);
            const error = output - y;

            let delta = [error];

            for (let l = weights.length - 1; l >= 0; l--) {
                const W = weights[l];
                const input = activations[l];

                for (let i = 0; i < W.length; i++) {
                    biases[l][i] -= learningRate * delta[i];
                    for (let j = 0; j < W[i].length; j++) {
                        weights[l][i][j] -= learningRate * delta[i] * input[j];
                    }
                }

                if (l > 0) {
                    const newDelta = [];
                    for (let j = 0; j < weights[l][0].length; j++) {
                        let sum = 0;
                        for (let i = 0; i < W.length; i++) {
                            sum += W[i][j] * delta[i];
                        }
                        sum *= reluDeriv(preActivations[l - 1][j]);
                        newDelta.push(sum);
                    }
                    delta = newDelta;
                }
            }

            return error * error;
        }

        function ntkKernel(x1, x2) {
            const diff = x1 - x2;
            return Math.exp(-diff * diff / (2 * lengthScale * lengthScale));
        }

        function kernelPredict(testX) {
            const n = trainX.length;

            const K = [];
            for (let i = 0; i < n; i++) {
                K[i] = [];
                for (let j = 0; j < n; j++) {
                    K[i][j] = ntkKernel(trainX[i], trainX[j]);
                    if (i === j) K[i][j] += regularization;
                }
            }

            const augmented = K.map((row, i) => [...row, trainY[i]]);
            const alpha = solveLinear(augmented, n);

            if (!alpha) return null;

            const predictions = [];
            for (const x of testX) {
                let pred = 0;
                for (let i = 0; i < n; i++) {
                    pred += alpha[i] * ntkKernel(x, trainX[i]);
                }
                predictions.push(pred);
            }

            return predictions;
        }

        function solveLinear(aug, n) {
            const A = aug.map(row => [...row]);

            for (let i = 0; i < n; i++) {
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;
                }
                [A[i], A[maxRow]] = [A[maxRow], A[i]];

                if (Math.abs(A[i][i]) < 1e-10) return null;

                for (let k = i + 1; k < n; k++) {
                    const factor = A[k][i] / A[i][i];
                    for (let j = i; j <= n; j++) {
                        A[k][j] -= factor * A[i][j];
                    }
                }
            }

            const x = new Array(n).fill(0);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = A[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= A[i][j] * x[j];
                }
                x[i] /= A[i][i];
            }

            return x;
        }

        let isTraining = false;
        let currentEpoch = 0;

        async function train() {
            if (isTraining) return;
            isTraining = true;

            initNetwork();
            lossHistory = [];
            kernelLossHistory = [];
            currentEpoch = 0;

            for (let epoch = 0; epoch < trainSteps; epoch++) {
                let totalLoss = 0;

                for (let i = 0; i < trainX.length; i++) {
                    totalLoss += backward(trainX[i], trainY[i]);
                }

                totalLoss /= trainX.length;
                lossHistory.push(totalLoss);

                const kernelPreds = kernelPredict(trainX);
                if (kernelPreds) {
                    let kLoss = 0;
                    for (let i = 0; i < trainX.length; i++) {
                        kLoss += (kernelPreds[i] - trainY[i]) ** 2;
                    }
                    kernelLossHistory.push(kLoss / trainX.length);
                }

                currentEpoch = epoch + 1;

                if (epoch % 10 === 0) {
                    draw();
                    await new Promise(r => setTimeout(r, 0));
                }
            }

            isTraining = false;
            draw();
        }

        function draw() {
            drawMainCanvas();
            drawKernelCanvas();
            drawLossCanvas();
            updateStats();
        }

        function drawMainCanvas() {
            const canvas = mainCanvas;
            const ctx = mainCtx;
            const dpr = window.devicePixelRatio || 1;

            canvas.width = canvas.clientWidth * dpr;
            canvas.height = canvas.clientHeight * dpr;
            ctx.scale(dpr, dpr);

            const w = canvas.clientWidth;
            const h = canvas.clientHeight;
            const padding = 40;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, w, h);

            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, h - padding);
            ctx.lineTo(w - padding, h - padding);
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, h - padding);
            ctx.stroke();

            const toCanvasX = x => padding + x * (w - 2 * padding);
            const toCanvasY = y => h - padding - (y + 1) * (h - 2 * padding) / 2;

            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            for (let i = 0; i <= 100; i++) {
                const x = i / 100;
                const y = trueFunction(x);
                const cx = toCanvasX(x);
                const cy = toCanvasY(y);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            const testX = Array.from({ length: 100 }, (_, i) => i / 99);
            const kernelPreds = kernelPredict(testX);

            if (kernelPreds) {
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < testX.length; i++) {
                    const cx = toCanvasX(testX[i]);
                    const cy = toCanvasY(kernelPreds[i]);
                    if (i === 0) ctx.moveTo(cx, cy);
                    else ctx.lineTo(cx, cy);
                }
                ctx.stroke();
            }

            ctx.strokeStyle = '#f97316';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < testX.length; i++) {
                const { output } = forward(testX[i]);
                const cx = toCanvasX(testX[i]);
                const cy = toCanvasY(output);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            }
            ctx.stroke();

            ctx.fillStyle = '#fff';
            for (let i = 0; i < trainX.length; i++) {
                const cx = toCanvasX(trainX[i]);
                const cy = toCanvasY(trainY[i]);
                ctx.beginPath();
                ctx.arc(cx, cy, 6, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawKernelCanvas() {
            const canvas = kernelCanvas;
            const ctx = kernelCtx;
            const dpr = window.devicePixelRatio || 1;

            canvas.width = canvas.clientWidth * dpr;
            canvas.height = canvas.clientHeight * dpr;
            ctx.scale(dpr, dpr);

            const w = canvas.clientWidth;
            const h = canvas.clientHeight;
            const n = trainX.length;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, w, h);

            if (n === 0) return;

            const cellW = (w - 40) / n;
            const cellH = (h - 40) / n;
            const offsetX = 20;
            const offsetY = 20;

            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const k = ntkKernel(trainX[i], trainX[j]);
                    const intensity = Math.floor(k * 255);
                    ctx.fillStyle = `rgb(${Math.floor(intensity * 0.5)}, ${Math.floor(intensity * 0.3)}, ${intensity})`;
                    ctx.fillRect(offsetX + j * cellW, offsetY + i * cellH, cellW - 1, cellH - 1);
                }
            }

            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            for (let i = 0; i < n; i++) {
                ctx.fillText(i + 1, offsetX + i * cellW + cellW / 2, h - 5);
                ctx.fillText(i + 1, 10, offsetY + i * cellH + cellH / 2 + 3);
            }
        }

        function drawLossCanvas() {
            const canvas = lossCanvas;
            const ctx = lossCtx;
            const dpr = window.devicePixelRatio || 1;

            canvas.width = canvas.clientWidth * dpr;
            canvas.height = canvas.clientHeight * dpr;
            ctx.scale(dpr, dpr);

            const w = canvas.clientWidth;
            const h = canvas.clientHeight;
            const padding = 40;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, w, h);

            if (lossHistory.length === 0) {
                ctx.fillStyle = '#666';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Train to see loss curve', w / 2, h / 2);
                return;
            }

            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, h - padding);
            ctx.lineTo(w - padding, h - padding);
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, h - padding);
            ctx.stroke();

            const maxLoss = Math.max(...lossHistory, ...kernelLossHistory) * 1.1;
            const toCanvasX = i => padding + (i / lossHistory.length) * (w - 2 * padding);
            const toCanvasY = l => h - padding - (l / maxLoss) * (h - 2 * padding);

            ctx.strokeStyle = '#f97316';
            ctx.lineWidth = 2;
            ctx.beginPath();
            lossHistory.forEach((l, i) => {
                const cx = toCanvasX(i);
                const cy = toCanvasY(l);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            });
            ctx.stroke();

            if (kernelLossHistory.length > 0) {
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                kernelLossHistory.forEach((l, i) => {
                    const cx = toCanvasX(i);
                    const cy = toCanvasY(l);
                    if (i === 0) ctx.moveTo(cx, cy);
                    else ctx.lineTo(cx, cy);
                });
                ctx.stroke();
                ctx.setLineDash([]);
            }

            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Epoch', w / 2, h - 5);
        }

        function updateStats() {
            document.getElementById('epoch').textContent = currentEpoch;

            if (lossHistory.length > 0) {
                document.getElementById('nnLoss').textContent = lossHistory[lossHistory.length - 1].toFixed(6);
            }

            if (kernelLossHistory.length > 0) {
                document.getElementById('kernelLoss').textContent = kernelLossHistory[kernelLossHistory.length - 1].toFixed(6);
            }

            const testX = Array.from({ length: 50 }, (_, i) => i / 49);
            const kernelPreds = kernelPredict(testX);
            if (kernelPreds) {
                let mse = 0;
                for (let i = 0; i < testX.length; i++) {
                    const { output } = forward(testX[i]);
                    mse += (output - kernelPreds[i]) ** 2;
                }
                mse /= testX.length;
                document.getElementById('predMSE').textContent = mse.toFixed(6);
            }
        }

        document.getElementById('width').addEventListener('input', e => {
            hiddenWidth = parseInt(e.target.value);
            document.getElementById('widthVal').textContent = hiddenWidth;
        });

        document.getElementById('depth').addEventListener('input', e => {
            depth = parseInt(e.target.value);
            document.getElementById('depthVal').textContent = depth;
        });

        document.getElementById('lr').addEventListener('input', e => {
            learningRate = parseFloat(e.target.value);
            document.getElementById('lrVal').textContent = learningRate.toFixed(3);
        });

        document.getElementById('steps').addEventListener('input', e => {
            trainSteps = parseInt(e.target.value);
            document.getElementById('stepsVal').textContent = trainSteps;
        });

        document.getElementById('length').addEventListener('input', e => {
            lengthScale = parseFloat(e.target.value);
            document.getElementById('lengthVal').textContent = lengthScale.toFixed(2);
            draw();
        });

        document.getElementById('reg').addEventListener('input', e => {
            regularization = parseFloat(e.target.value);
            document.getElementById('regVal').textContent = regularization.toFixed(4);
            draw();
        });

        document.getElementById('points').addEventListener('input', e => {
            numPoints = parseInt(e.target.value);
            document.getElementById('pointsVal').textContent = numPoints;
        });

        document.getElementById('noise').addEventListener('input', e => {
            noiseLevel = parseFloat(e.target.value);
            document.getElementById('noiseVal').textContent = noiseLevel.toFixed(2);
        });

        document.getElementById('trainBtn').addEventListener('click', train);

        document.getElementById('resetBtn').addEventListener('click', () => {
            generateData();
            initNetwork();
            lossHistory = [];
            kernelLossHistory = [];
            currentEpoch = 0;
            draw();
        });

        window.addEventListener('resize', draw);

        generateData();
        initNetwork();
        draw();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
