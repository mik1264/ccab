<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BCJR Soft-Decoder Demo - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px;
            color: #c9a227; text-decoration: none; font-weight: 500;
            z-index: 1000; transition: all 0.3s ease;
        }
        .back-link:hover { color: #ffd700; transform: translateX(-4px); }
        .container { max-width: 1600px; margin: 0 auto; padding: 60px 20px 20px; }
        h1 { text-align: center; color: #c9a227; margin-bottom: 0.5rem; font-size: 2rem; }
        .subtitle { text-align: center; color: #888; margin-bottom: 1.5rem; }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
        }

        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .canvas-container {
            background: rgba(20, 20, 35, 0.9);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(201, 162, 39, 0.3);
        }

        .canvas-container h3 {
            color: #c9a227;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        canvas {
            width: 100%;
            background: #0a0a15;
            border-radius: 8px;
        }

        .controls {
            background: rgba(20, 20, 35, 0.9);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(201, 162, 39, 0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: #c9a227;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group .value {
            color: #888;
            font-size: 0.85rem;
        }

        .btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #c9a227, #d4af37);
            color: #0a0a0f;
        }

        .btn-secondary {
            background: rgba(201, 162, 39, 0.2);
            color: #c9a227;
            border: 1px solid rgba(201, 162, 39, 0.4);
        }

        .btn:hover { transform: translateY(-2px); }

        .info-panel {
            background: rgba(30, 30, 50, 0.8);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .info-panel h4 {
            color: #c9a227;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 0.85rem;
        }

        .info-row:last-child { border-bottom: none; }

        .info-row .label { color: #888; }
        .info-row .value { color: #4ade80; font-family: monospace; }

        .sequence-display {
            font-family: monospace;
            font-size: 0.9rem;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            margin-top: 10px;
            word-break: break-all;
        }

        .sequence-display .bit-0 { color: #60a5fa; }
        .sequence-display .bit-1 { color: #f87171; }
        .sequence-display .error { color: #fbbf24; text-decoration: underline; }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            font-size: 0.85rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .comparison-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .comparison-box {
            background: rgba(30, 30, 50, 0.8);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .comparison-box h5 {
            color: #888;
            font-size: 0.8rem;
            margin-bottom: 8px;
        }

        .comparison-value {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .comparison-value.hard { color: #f87171; }
        .comparison-value.soft { color: #4ade80; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to ML Visualizations</a>

    <div class="container">
        <h1>BCJR Soft-Decoder Demo</h1>
        <p class="subtitle">Bahl-Cocke-Jelinek-Raviv algorithm for convolutional code decoding</p>

        <div class="main-content">
            <div class="visualization-area">
                <div class="canvas-container">
                    <h3>Trellis Diagram with Forward/Backward Metrics</h3>
                    <canvas id="trellisCanvas" width="900" height="350"></canvas>
                </div>

                <div class="canvas-container">
                    <h3>Log-Likelihood Ratios (LLR) per Bit</h3>
                    <canvas id="llrCanvas" width="900" height="200"></canvas>
                </div>

                <div class="canvas-container">
                    <h3>Decoded Sequence Comparison</h3>
                    <div class="sequence-display" id="sequenceDisplay"></div>

                    <div class="comparison-panel">
                        <div class="comparison-box">
                            <h5>Hard Decision Errors</h5>
                            <div class="comparison-value hard" id="hardErrors">0</div>
                        </div>
                        <div class="comparison-box">
                            <h5>Soft Decision (BCJR) Errors</h5>
                            <div class="comparison-value soft" id="softErrors">0</div>
                        </div>
                    </div>

                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #60a5fa;"></div>
                            <span>Bit 0</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #f87171;"></div>
                            <span>Bit 1</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #fbbf24;"></div>
                            <span>Error Position</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Message Length</label>
                    <input type="range" id="messageLength" min="4" max="12" value="8">
                    <div class="value"><span id="messageLengthValue">8</span> bits</div>
                </div>

                <div class="control-group">
                    <label>Channel SNR (Eb/N0)</label>
                    <input type="range" id="snr" min="0" max="10" step="0.5" value="3">
                    <div class="value"><span id="snrValue">3.0</span> dB</div>
                </div>

                <div class="control-group">
                    <label>Noise Realization</label>
                    <input type="range" id="seed" min="1" max="100" value="42">
                    <div class="value">Seed: <span id="seedValue">42</span></div>
                </div>

                <button class="btn btn-primary" id="runBtn">Run BCJR Decoder</button>
                <button class="btn btn-secondary" id="stepBtn">Step Through</button>
                <button class="btn btn-secondary" id="randomBtn">Random Message</button>

                <div class="info-panel">
                    <h4>Encoder: Rate 1/2 (7, 5)</h4>
                    <div class="info-row">
                        <span class="label">Generator 1:</span>
                        <span class="value">g1 = 111 (7)</span>
                    </div>
                    <div class="info-row">
                        <span class="label">Generator 2:</span>
                        <span class="value">g2 = 101 (5)</span>
                    </div>
                    <div class="info-row">
                        <span class="label">Constraint Length:</span>
                        <span class="value">K = 3</span>
                    </div>
                    <div class="info-row">
                        <span class="label">States:</span>
                        <span class="value">4 (00, 01, 10, 11)</span>
                    </div>
                </div>

                <div class="info-panel">
                    <h4>Current Metrics</h4>
                    <div class="info-row">
                        <span class="label">α (Forward):</span>
                        <span class="value" id="alphaMetric">-</span>
                    </div>
                    <div class="info-row">
                        <span class="label">β (Backward):</span>
                        <span class="value" id="betaMetric">-</span>
                    </div>
                    <div class="info-row">
                        <span class="label">γ (Branch):</span>
                        <span class="value" id="gammaMetric">-</span>
                    </div>
                </div>

                <div class="info-panel">
                    <h4>Algorithm Steps</h4>
                    <div style="font-size: 0.8rem; color: #aaa; line-height: 1.5;">
                        1. <b>Encode</b>: Message → Codeword<br>
                        2. <b>Transmit</b>: Add AWGN noise<br>
                        3. <b>γ (Branch)</b>: Channel LLRs<br>
                        4. <b>α (Forward)</b>: Left-to-right<br>
                        5. <b>β (Backward)</b>: Right-to-left<br>
                        6. <b>APP</b>: Combine α, β, γ<br>
                        7. <b>LLR</b>: Soft decisions
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const trellisCanvas = document.getElementById('trellisCanvas');
        const trellisCtx = trellisCanvas.getContext('2d');
        const llrCanvas = document.getElementById('llrCanvas');
        const llrCtx = llrCanvas.getContext('2d');

        // State
        let state = {
            message: [],
            encoded: [],
            received: [],
            receivedSymbols: [],
            alpha: [],
            beta: [],
            gamma: [],
            llr: [],
            decodedSoft: [],
            decodedHard: [],
            currentStep: 0,
            maxSteps: 0
        };

        // Rate 1/2 (7, 5) convolutional code
        const encoder = {
            K: 3,  // Constraint length
            g1: 0b111,  // Generator 1 (7)
            g2: 0b101,  // Generator 2 (5)
            numStates: 4,

            // State transition table: transitions[state][input] = {nextState, output}
            transitions: null,

            init() {
                this.transitions = {};
                for (let s = 0; s < this.numStates; s++) {
                    this.transitions[s] = {};
                    for (let input = 0; input <= 1; input++) {
                        const nextState = ((s << 1) | input) & 0b11;
                        const reg = (s << 1) | input;
                        const out1 = this.parity(reg & this.g1);
                        const out2 = this.parity(reg & this.g2);
                        this.transitions[s][input] = {
                            nextState,
                            output: [out1, out2]
                        };
                    }
                }
            },

            parity(x) {
                let p = 0;
                while (x) { p ^= (x & 1); x >>= 1; }
                return p;
            },

            encode(message) {
                let state = 0;
                const output = [];
                for (const bit of message) {
                    const t = this.transitions[state][bit];
                    output.push(...t.output);
                    state = t.nextState;
                }
                // Flush with zeros
                for (let i = 0; i < this.K - 1; i++) {
                    const t = this.transitions[state][0];
                    output.push(...t.output);
                    state = t.nextState;
                }
                return output;
            }
        };
        encoder.init();

        // PRNG for reproducibility
        function mulberry32(a) {
            return function() {
                let t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        // Box-Muller transform for Gaussian noise
        function gaussianNoise(rng) {
            const u1 = rng();
            const u2 = rng();
            return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        }

        // AWGN channel
        function awgnChannel(encoded, snrDb, seed) {
            const rng = mulberry32(seed);
            const snr = Math.pow(10, snrDb / 10);
            const sigma = 1 / Math.sqrt(2 * snr);

            const symbols = encoded.map(b => 2 * b - 1);  // BPSK: 0->-1, 1->+1
            const received = symbols.map(s => s + gaussianNoise(rng) * sigma);

            return { symbols, received, sigma };
        }

        // BCJR Algorithm
        function bcjrDecode(received, sigma, numMessage) {
            const numStates = encoder.numStates;
            const T = received.length / 2;  // Number of time steps

            // Initialize
            const alpha = Array(T + 1).fill(null).map(() => Array(numStates).fill(-Infinity));
            const beta = Array(T + 1).fill(null).map(() => Array(numStates).fill(-Infinity));
            const gamma = Array(T).fill(null).map(() => ({}));

            // Initial conditions
            alpha[0][0] = 0;  // Start in state 0
            beta[T][0] = 0;   // End in state 0 (after flushing)

            // Compute branch metrics (gamma)
            for (let t = 0; t < T; t++) {
                const r1 = received[2 * t];
                const r2 = received[2 * t + 1];

                for (let s = 0; s < numStates; s++) {
                    for (let input = 0; input <= 1; input++) {
                        const trans = encoder.transitions[s][input];
                        const c1 = 2 * trans.output[0] - 1;
                        const c2 = 2 * trans.output[1] - 1;

                        // Log-domain branch metric
                        const metric = (r1 * c1 + r2 * c2) / (sigma * sigma);

                        if (!gamma[t][s]) gamma[t][s] = {};
                        gamma[t][s][input] = {
                            nextState: trans.nextState,
                            metric
                        };
                    }
                }
            }

            // Forward recursion (alpha)
            for (let t = 0; t < T; t++) {
                for (let s = 0; s < numStates; s++) {
                    if (alpha[t][s] === -Infinity) continue;

                    for (let input = 0; input <= 1; input++) {
                        const g = gamma[t][s][input];
                        const newAlpha = alpha[t][s] + g.metric;
                        alpha[t + 1][g.nextState] = logAdd(alpha[t + 1][g.nextState], newAlpha);
                    }
                }
                // Normalize
                const maxAlpha = Math.max(...alpha[t + 1]);
                for (let s = 0; s < numStates; s++) {
                    alpha[t + 1][s] -= maxAlpha;
                }
            }

            // Backward recursion (beta)
            for (let t = T - 1; t >= 0; t--) {
                for (let s = 0; s < numStates; s++) {
                    for (let input = 0; input <= 1; input++) {
                        const g = gamma[t][s][input];
                        const newBeta = beta[t + 1][g.nextState] + g.metric;
                        beta[t][s] = logAdd(beta[t][s], newBeta);
                    }
                }
                // Normalize
                const maxBeta = Math.max(...beta[t]);
                for (let s = 0; s < numStates; s++) {
                    beta[t][s] -= maxBeta;
                }
            }

            // Compute LLRs (only for message bits, not flush bits)
            const llr = [];
            for (let t = 0; t < numMessage; t++) {
                let prob0 = -Infinity;
                let prob1 = -Infinity;

                for (let s = 0; s < numStates; s++) {
                    for (let input = 0; input <= 1; input++) {
                        const g = gamma[t][s][input];
                        const prob = alpha[t][s] + g.metric + beta[t + 1][g.nextState];

                        if (input === 0) {
                            prob0 = logAdd(prob0, prob);
                        } else {
                            prob1 = logAdd(prob1, prob);
                        }
                    }
                }

                llr.push(prob0 - prob1);  // LLR: positive favors 0, negative favors 1
            }

            return { alpha, beta, gamma, llr };
        }

        // Log-sum-exp for numerical stability
        function logAdd(a, b) {
            if (a === -Infinity) return b;
            if (b === -Infinity) return a;
            if (a > b) {
                return a + Math.log(1 + Math.exp(b - a));
            } else {
                return b + Math.log(1 + Math.exp(a - b));
            }
        }

        // Hard decision decoder (Viterbi-like, simplified)
        function hardDecode(received) {
            const hard = received.map(r => r > 0 ? 1 : 0);

            // Simple hard decision based on received bits
            const decoded = [];
            for (let i = 0; i < hard.length - 2; i += 2) {
                // Very simplified - just use majority of first bit pattern
                decoded.push(hard[i]);
            }
            return decoded;
        }

        function runDecoder() {
            const msgLen = parseInt(document.getElementById('messageLength').value);
            const snr = parseFloat(document.getElementById('snr').value);
            const seed = parseInt(document.getElementById('seed').value);

            // Generate message
            const rng = mulberry32(seed * 1000);
            state.message = Array(msgLen).fill(0).map(() => rng() > 0.5 ? 1 : 0);

            // Encode
            state.encoded = encoder.encode(state.message);

            // Transmit through AWGN channel
            const channel = awgnChannel(state.encoded, snr, seed);
            state.receivedSymbols = channel.symbols;
            state.received = channel.received;

            // BCJR decode
            const result = bcjrDecode(state.received, channel.sigma, msgLen);
            state.alpha = result.alpha;
            state.beta = result.beta;
            state.gamma = result.gamma;
            state.llr = result.llr;

            // Soft decision
            state.decodedSoft = state.llr.map(l => l > 0 ? 0 : 1);

            // Hard decision (for comparison)
            state.decodedHard = hardDecode(state.received).slice(0, msgLen);

            state.currentStep = state.alpha.length - 1;
            state.maxSteps = state.alpha.length - 1;

            updateDisplay();
        }

        function updateDisplay() {
            drawTrellis();
            drawLLR();
            updateSequenceDisplay();
            updateMetrics();
        }

        function drawTrellis() {
            const ctx = trellisCtx;
            const W = trellisCanvas.width;
            const H = trellisCanvas.height;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, W, H);

            const T = state.alpha.length;
            if (T === 0) return;

            const numStates = encoder.numStates;
            const marginX = 60;
            const marginY = 40;
            const stepX = (W - 2 * marginX) / (T - 1);
            const stepY = (H - 2 * marginY) / (numStates - 1);

            // Draw state labels
            ctx.fillStyle = '#888';
            ctx.font = '12px monospace';
            ctx.textAlign = 'right';
            for (let s = 0; s < numStates; s++) {
                const y = marginY + s * stepY;
                ctx.fillText(s.toString(2).padStart(2, '0'), marginX - 10, y + 4);
            }

            // Draw time labels
            ctx.textAlign = 'center';
            for (let t = 0; t < T; t++) {
                const x = marginX + t * stepX;
                ctx.fillText('t=' + t, x, H - 10);
            }

            // Draw transitions
            const maxStep = Math.min(state.currentStep, T - 2);

            for (let t = 0; t <= maxStep && t < T - 1; t++) {
                for (let s = 0; s < numStates; s++) {
                    if (state.alpha[t][s] === -Infinity) continue;

                    for (let input = 0; input <= 1; input++) {
                        const g = state.gamma[t][s][input];
                        const x1 = marginX + t * stepX;
                        const y1 = marginY + s * stepY;
                        const x2 = marginX + (t + 1) * stepX;
                        const y2 = marginY + g.nextState * stepY;

                        // Color by input bit
                        const alpha = Math.exp(state.alpha[t][s]) / 2;
                        if (input === 0) {
                            ctx.strokeStyle = `rgba(96, 165, 250, ${0.3 + alpha * 0.7})`;
                        } else {
                            ctx.strokeStyle = `rgba(248, 113, 113, ${0.3 + alpha * 0.7})`;
                        }
                        ctx.lineWidth = 1 + alpha * 2;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
            }

            // Draw state nodes
            for (let t = 0; t <= state.currentStep && t < T; t++) {
                for (let s = 0; s < numStates; s++) {
                    const x = marginX + t * stepX;
                    const y = marginY + s * stepY;

                    const alphaVal = state.alpha[t][s];
                    const betaVal = state.beta[t][s];

                    if (alphaVal === -Infinity && betaVal === -Infinity) {
                        ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
                    } else {
                        const prob = Math.exp(Math.max(alphaVal, -10));
                        ctx.fillStyle = `rgba(201, 162, 39, ${0.3 + prob * 0.7})`;
                    }

                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#c9a227';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            // Draw received symbols at bottom
            ctx.fillStyle = '#4ade80';
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            for (let t = 0; t < T - 1 && t * 2 + 1 < state.received.length; t++) {
                const x = marginX + t * stepX + stepX / 2;
                const r1 = state.received[t * 2].toFixed(2);
                const r2 = state.received[t * 2 + 1].toFixed(2);
                ctx.fillText(`(${r1}, ${r2})`, x, marginY - 15);
            }

            // Legend
            ctx.fillStyle = '#60a5fa';
            ctx.fillRect(W - 150, 10, 12, 12);
            ctx.fillStyle = '#888';
            ctx.textAlign = 'left';
            ctx.fillText('Input 0', W - 130, 20);

            ctx.fillStyle = '#f87171';
            ctx.fillRect(W - 150, 28, 12, 12);
            ctx.fillStyle = '#888';
            ctx.fillText('Input 1', W - 130, 38);
        }

        function drawLLR() {
            const ctx = llrCtx;
            const W = llrCanvas.width;
            const H = llrCanvas.height;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, W, H);

            if (state.llr.length === 0) return;

            const marginX = 60;
            const marginY = 30;
            const plotW = W - 2 * marginX;
            const plotH = H - 2 * marginY;

            // Find scale
            const maxLLR = Math.max(...state.llr.map(Math.abs), 5);

            // Draw axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;

            // Vertical axis
            ctx.beginPath();
            ctx.moveTo(marginX, marginY);
            ctx.lineTo(marginX, H - marginY);
            ctx.stroke();

            // Horizontal axis (at LLR = 0)
            const zeroY = marginY + plotH / 2;
            ctx.beginPath();
            ctx.moveTo(marginX, zeroY);
            ctx.lineTo(W - marginX, zeroY);
            ctx.stroke();

            // Draw decision threshold
            ctx.strokeStyle = 'rgba(251, 191, 36, 0.5)';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(marginX, zeroY);
            ctx.lineTo(W - marginX, zeroY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(`+${maxLLR.toFixed(1)}`, marginX - 5, marginY + 5);
            ctx.fillText('0', marginX - 5, zeroY + 4);
            ctx.fillText(`-${maxLLR.toFixed(1)}`, marginX - 5, H - marginY + 5);

            ctx.textAlign = 'center';
            ctx.fillText('LLR > 0: Decide 0', W / 2, marginY - 10);
            ctx.fillText('LLR < 0: Decide 1', W / 2, H - 5);

            // Draw LLR bars
            const barWidth = plotW / state.llr.length * 0.7;
            const barGap = plotW / state.llr.length;

            for (let i = 0; i < state.llr.length; i++) {
                const llr = state.llr[i];
                const x = marginX + i * barGap + barGap / 2 - barWidth / 2;
                const barH = (llr / maxLLR) * (plotH / 2);

                // Color based on decision
                if (llr > 0) {
                    ctx.fillStyle = '#60a5fa';
                    ctx.fillRect(x, zeroY - barH, barWidth, barH);
                } else {
                    ctx.fillStyle = '#f87171';
                    ctx.fillRect(x, zeroY, barWidth, -barH);
                }

                // Bit index
                ctx.fillStyle = '#888';
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(i.toString(), x + barWidth / 2, H - marginY + 15);

                // LLR value
                ctx.fillStyle = '#aaa';
                const labelY = llr > 0 ? zeroY - barH - 5 : zeroY - barH + 12;
                ctx.fillText(llr.toFixed(1), x + barWidth / 2, labelY);
            }
        }

        function updateSequenceDisplay() {
            const container = document.getElementById('sequenceDisplay');

            let html = '<div style="margin-bottom: 8px;"><b>Original:</b> ';
            html += state.message.map((b, i) =>
                `<span class="bit-${b}">${b}</span>`
            ).join('');
            html += '</div>';

            html += '<div style="margin-bottom: 8px;"><b>Hard Dec:</b> ';
            html += state.decodedHard.map((b, i) => {
                const isError = b !== state.message[i];
                return `<span class="${isError ? 'error' : 'bit-' + b}">${b}</span>`;
            }).join('');
            html += '</div>';

            html += '<div><b>Soft Dec:</b> ';
            html += state.decodedSoft.map((b, i) => {
                const isError = b !== state.message[i];
                return `<span class="${isError ? 'error' : 'bit-' + b}">${b}</span>`;
            }).join('');
            html += '</div>';

            container.innerHTML = html;

            // Count errors
            let hardErrors = 0, softErrors = 0;
            for (let i = 0; i < state.message.length; i++) {
                if (state.decodedHard[i] !== state.message[i]) hardErrors++;
                if (state.decodedSoft[i] !== state.message[i]) softErrors++;
            }

            document.getElementById('hardErrors').textContent = hardErrors;
            document.getElementById('softErrors').textContent = softErrors;
        }

        function updateMetrics() {
            const t = Math.min(state.currentStep, state.alpha.length - 1);
            if (t < 0) return;

            const alphaStr = state.alpha[t].map(a =>
                a === -Infinity ? '-∞' : a.toFixed(2)
            ).join(', ');
            const betaStr = state.beta[t].map(b =>
                b === -Infinity ? '-∞' : b.toFixed(2)
            ).join(', ');

            document.getElementById('alphaMetric').textContent = `[${alphaStr}]`;
            document.getElementById('betaMetric').textContent = `[${betaStr}]`;

            if (t < state.gamma.length) {
                const gammaStr = Object.entries(state.gamma[t])
                    .slice(0, 2)
                    .map(([s, inputs]) =>
                        `${inputs[0]?.metric?.toFixed(1) || '-'}`
                    ).join(', ');
                document.getElementById('gammaMetric').textContent = gammaStr + '...';
            }
        }

        // Event listeners
        document.getElementById('messageLength').addEventListener('input', e => {
            document.getElementById('messageLengthValue').textContent = e.target.value;
        });

        document.getElementById('snr').addEventListener('input', e => {
            document.getElementById('snrValue').textContent = parseFloat(e.target.value).toFixed(1);
        });

        document.getElementById('seed').addEventListener('input', e => {
            document.getElementById('seedValue').textContent = e.target.value;
        });

        document.getElementById('runBtn').addEventListener('click', runDecoder);

        document.getElementById('stepBtn').addEventListener('click', () => {
            if (state.alpha.length === 0) {
                runDecoder();
                state.currentStep = 0;
            } else {
                state.currentStep = (state.currentStep + 1) % (state.maxSteps + 1);
            }
            updateDisplay();
        });

        document.getElementById('randomBtn').addEventListener('click', () => {
            document.getElementById('seed').value = Math.floor(Math.random() * 100) + 1;
            document.getElementById('seedValue').textContent = document.getElementById('seed').value;
            runDecoder();
        });

        // Initialize
        runDecoder();
    </script>
</body>
</html>
