<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Tracking - ML Visualizations - CCAB</title>
    <style>
        body { margin: 0; padding: 20px; background: #0f0f1a; color: #e8e6e1; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        .back-link { display: inline-block; padding: 8px 16px; background: rgba(124, 58, 237, 0.2); color: #a78bfa; text-decoration: none; border-radius: 6px; margin-bottom: 20px; }
        .back-link:hover { background: rgba(124, 58, 237, 0.4); }
        h1 { color: #a78bfa; margin-bottom: 10px; }
        .subtitle { color: #888; margin-bottom: 20px; }
        .container { position: relative; display: inline-block; }
        #video { border-radius: 8px; transform: scaleX(-1); }
        #canvas { position: absolute; top: 0; left: 0; border-radius: 8px; transform: scaleX(-1); }
        button { background: #7C3AED; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; margin-top: 15px; margin-right: 10px; }
        button:hover { background: #6D28D9; }
        #loading { text-align: center; padding: 50px; }
        .spinner { width: 50px; height: 50px; border: 4px solid rgba(255,255,255,0.1); border-top-color: #7C3AED; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .stats { margin-top: 15px; font-size: 14px; color: #888; }
        .gesture { font-size: 24px; color: #10B981; margin-top: 10px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to ML Gallery</a>
    <h1>Hand Tracking</h1>
    <p class="subtitle">21 hand landmarks tracked in real-time using MediaPipe Hands</p>

    <div id="loading">
        <div class="spinner"></div>
        <p>Loading Hand Tracking model...</p>
    </div>

    <div id="main" style="display: none;">
        <div class="container">
            <video id="video" width="640" height="480" autoplay playsinline></video>
            <canvas id="canvas" width="640" height="480"></canvas>
        </div>

        <div>
            <button onclick="startCamera()">Start Camera</button>
        </div>

        <div class="stats">
            <p>FPS: <span id="fps">0</span> | Hands detected: <span id="hands">0</span></p>
        </div>
        <div class="gesture" id="gesture"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.0/dist/hand-pose-detection.min.js"></script>
    <script>
        let detector;
        let video, canvas, ctx;
        let running = false;
        let lastTime = 0;

        // Hand landmark connections
        const FINGERS = {
            thumb: [0, 1, 2, 3, 4],
            index: [0, 5, 6, 7, 8],
            middle: [0, 9, 10, 11, 12],
            ring: [0, 13, 14, 15, 16],
            pinky: [0, 17, 18, 19, 20]
        };

        const COLORS = {
            thumb: '#EF4444',
            index: '#F59E0B',
            middle: '#10B981',
            ring: '#3B82F6',
            pinky: '#8B5CF6'
        };

        async function init() {
            const model = handPoseDetection.SupportedModels.MediaPipeHands;
            detector = await handPoseDetection.createDetector(model, {
                runtime: 'tfjs',
                modelType: 'full',
                maxHands: 2
            });

            video = document.getElementById('video');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            document.getElementById('loading').style.display = 'none';
            document.getElementById('main').style.display = 'block';
        }

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480 }
                });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    video.play();
                    running = true;
                    detectHands();
                };
            } catch (err) {
                alert('Camera access denied. Error: ' + err.message);
            }
        }

        async function detectHands() {
            if (!running) return;

            const hands = await detector.estimateHands(video);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            document.getElementById('hands').textContent = hands.length;

            for (let hand of hands) {
                const keypoints = hand.keypoints;

                // Draw finger connections
                for (let [finger, indices] of Object.entries(FINGERS)) {
                    ctx.strokeStyle = COLORS[finger];
                    ctx.lineWidth = 3;
                    ctx.beginPath();

                    for (let i = 0; i < indices.length; i++) {
                        const kp = keypoints[indices[i]];
                        if (i === 0) {
                            ctx.moveTo(kp.x, kp.y);
                        } else {
                            ctx.lineTo(kp.x, kp.y);
                        }
                    }
                    ctx.stroke();
                }

                // Draw palm connections
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 2;
                const palmIndices = [0, 5, 9, 13, 17, 0];
                ctx.beginPath();
                for (let i = 0; i < palmIndices.length; i++) {
                    const kp = keypoints[palmIndices[i]];
                    if (i === 0) ctx.moveTo(kp.x, kp.y);
                    else ctx.lineTo(kp.x, kp.y);
                }
                ctx.stroke();

                // Draw keypoints
                for (let i = 0; i < keypoints.length; i++) {
                    const kp = keypoints[i];
                    ctx.beginPath();
                    ctx.arc(kp.x, kp.y, 5, 0, Math.PI * 2);

                    // Color by finger
                    if (i <= 4) ctx.fillStyle = COLORS.thumb;
                    else if (i <= 8) ctx.fillStyle = COLORS.index;
                    else if (i <= 12) ctx.fillStyle = COLORS.middle;
                    else if (i <= 16) ctx.fillStyle = COLORS.ring;
                    else ctx.fillStyle = COLORS.pinky;

                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Simple gesture detection
                detectGesture(keypoints, hand.handedness);
            }

            if (hands.length === 0) {
                document.getElementById('gesture').textContent = '';
            }

            // Calculate FPS
            const now = performance.now();
            const fps = 1000 / (now - lastTime);
            lastTime = now;
            document.getElementById('fps').textContent = Math.round(fps);

            requestAnimationFrame(detectHands);
        }

        function detectGesture(keypoints, handedness) {
            const fingersUp = countFingersUp(keypoints);
            let gesture = '';

            if (fingersUp === 0) gesture = '‚úä Fist';
            else if (fingersUp === 1 && isFingerUp(keypoints, 'index')) gesture = '‚òùÔ∏è Pointing';
            else if (fingersUp === 2 && isFingerUp(keypoints, 'index') && isFingerUp(keypoints, 'middle')) gesture = '‚úåÔ∏è Peace';
            else if (fingersUp === 3) gesture = 'ü§ü Rock on';
            else if (fingersUp === 4) gesture = 'üñêÔ∏è Four';
            else if (fingersUp === 5) gesture = 'üñêÔ∏è Open Hand';
            else if (isThumbsUp(keypoints)) gesture = 'üëç Thumbs Up';

            document.getElementById('gesture').textContent = `${handedness}: ${gesture}`;
        }

        function isFingerUp(keypoints, finger) {
            const indices = FINGERS[finger];
            const tip = keypoints[indices[4]];
            const pip = keypoints[indices[2]];
            return tip.y < pip.y;
        }

        function countFingersUp(keypoints) {
            let count = 0;
            // Check thumb (horizontal comparison)
            if (keypoints[4].x < keypoints[3].x) count++;
            // Check other fingers (vertical comparison)
            if (keypoints[8].y < keypoints[6].y) count++;
            if (keypoints[12].y < keypoints[10].y) count++;
            if (keypoints[16].y < keypoints[14].y) count++;
            if (keypoints[20].y < keypoints[18].y) count++;
            return count;
        }

        function isThumbsUp(keypoints) {
            const thumbUp = keypoints[4].y < keypoints[3].y;
            const fingersDown =
                keypoints[8].y > keypoints[6].y &&
                keypoints[12].y > keypoints[10].y &&
                keypoints[16].y > keypoints[14].y &&
                keypoints[20].y > keypoints[18].y;
            return thumbUp && fingersDown;
        }

        init();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
