<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word2Vec in 2D - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px;
            color: #c9a227; text-decoration: none; font-weight: 500;
            z-index: 1000; transition: all 0.3s ease;
        }
        .back-link:hover { color: #ffd700; transform: translateX(-4px); }
        .container { max-width: 1600px; margin: 0 auto; padding: 60px 20px 20px; }
        h1 { text-align: center; color: #c9a227; margin-bottom: 0.5rem; font-size: 2rem; }
        .subtitle { text-align: center; color: #888; margin-bottom: 1.5rem; }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
        }

        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .canvas-container {
            background: rgba(20, 20, 35, 0.9);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(201, 162, 39, 0.3);
        }

        .canvas-container h3 {
            color: #c9a227;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        canvas {
            width: 100%;
            background: #0a0a15;
            border-radius: 8px;
        }

        .controls {
            background: rgba(20, 20, 35, 0.9);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(201, 162, 39, 0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: #c9a227;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(201, 162, 39, 0.3);
            color: #e0e0e0;
            border-radius: 6px;
        }

        .control-group .value {
            color: #888;
            font-size: 0.85rem;
        }

        .btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #c9a227, #d4af37);
            color: #0a0a0f;
        }

        .btn-secondary {
            background: rgba(201, 162, 39, 0.2);
            color: #c9a227;
            border: 1px solid rgba(201, 162, 39, 0.4);
        }

        .btn:hover { transform: translateY(-2px); }

        .info-panel {
            background: rgba(30, 30, 50, 0.8);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .info-panel h4 {
            color: #c9a227;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 0.85rem;
        }

        .info-row:last-child { border-bottom: none; }
        .info-row .label { color: #888; }
        .info-row .value { color: #4ade80; font-family: monospace; }

        .analogy-input {
            display: grid;
            grid-template-columns: 1fr auto 1fr auto 1fr auto 1fr;
            gap: 5px;
            align-items: center;
            margin-top: 10px;
        }

        .analogy-input select {
            padding: 6px;
            font-size: 0.85rem;
        }

        .analogy-input span {
            color: #888;
            font-size: 1.2rem;
        }

        .analogy-result {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.9rem;
        }

        .neighbors-list {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .neighbor-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 8px;
            margin: 2px 0;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .neighbor-item .word { color: #4ade80; }
        .neighbor-item .score { color: #888; font-family: monospace; }

        .corpus-display {
            font-size: 0.8rem;
            color: #888;
            line-height: 1.4;
            max-height: 100px;
            overflow-y: auto;
            background: rgba(0,0,0,0.2);
            padding: 8px;
            border-radius: 6px;
            margin-top: 10px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            font-size: 0.8rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to ML Visualizations</a>

    <div class="container">
        <h1>Word2Vec in 2D</h1>
        <p class="subtitle">Train word embeddings on a toy corpus and explore semantic relationships</p>

        <div class="main-content">
            <div class="visualization-area">
                <div class="canvas-container">
                    <h3>Word Embedding Space (2D Projection)</h3>
                    <canvas id="embeddingCanvas" width="900" height="400"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #f87171;"></div>
                            <span>Royalty</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4ade80;"></div>
                            <span>Countries</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #60a5fa;"></div>
                            <span>Cities</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #a78bfa;"></div>
                            <span>Other</span>
                        </div>
                    </div>
                </div>

                <div class="canvas-container">
                    <h3>Training Loss Over Epochs</h3>
                    <canvas id="lossCanvas" width="900" height="150"></canvas>
                </div>

                <div class="canvas-container">
                    <h3>Analogy Vectors: A - B + C = ?</h3>
                    <canvas id="analogyCanvas" width="900" height="200"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Training Epochs</label>
                    <input type="range" id="epochs" min="10" max="200" value="100">
                    <div class="value"><span id="epochsValue">100</span> epochs</div>
                </div>

                <div class="control-group">
                    <label>Learning Rate</label>
                    <input type="range" id="lr" min="0.01" max="0.5" step="0.01" value="0.1">
                    <div class="value">η = <span id="lrValue">0.1</span></div>
                </div>

                <div class="control-group">
                    <label>Window Size</label>
                    <input type="range" id="window" min="1" max="4" value="2">
                    <div class="value"><span id="windowValue">2</span></div>
                </div>

                <div class="control-group">
                    <label>Model</label>
                    <select id="model">
                        <option value="skipgram">Skip-Gram</option>
                        <option value="cbow">CBOW</option>
                    </select>
                </div>

                <button class="btn btn-primary" id="trainBtn">Train Embeddings</button>
                <button class="btn btn-secondary" id="resetBtn">Reset</button>

                <div class="info-panel">
                    <h4>Corpus</h4>
                    <div class="corpus-display" id="corpusDisplay"></div>
                </div>

                <div class="info-panel">
                    <h4>Word Analogy</h4>
                    <div class="analogy-input">
                        <select id="wordA"></select>
                        <span>−</span>
                        <select id="wordB"></select>
                        <span>+</span>
                        <select id="wordC"></select>
                        <span>=</span>
                        <select id="wordD" disabled></select>
                    </div>
                    <div class="analogy-result" id="analogyResult">
                        Train embeddings first
                    </div>
                </div>

                <div class="info-panel">
                    <h4>Selected Word Neighbors</h4>
                    <div class="control-group" style="margin-bottom: 10px;">
                        <select id="selectedWord"></select>
                    </div>
                    <div class="neighbors-list" id="neighborsList"></div>
                </div>

                <div class="info-panel">
                    <h4>Training Stats</h4>
                    <div class="info-row">
                        <span class="label">Current Epoch:</span>
                        <span class="value" id="currentEpoch">0</span>
                    </div>
                    <div class="info-row">
                        <span class="label">Loss:</span>
                        <span class="value" id="currentLoss">-</span>
                    </div>
                    <div class="info-row">
                        <span class="label">Vocabulary:</span>
                        <span class="value" id="vocabSize">-</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const embCanvas = document.getElementById('embeddingCanvas');
        const embCtx = embCanvas.getContext('2d');
        const lossCanvas = document.getElementById('lossCanvas');
        const lossCtx = lossCanvas.getContext('2d');
        const analogyCanvas = document.getElementById('analogyCanvas');
        const analogyCtx = analogyCanvas.getContext('2d');

        // Toy corpus with semantic relationships
        const corpus = [
            "the king rules the kingdom",
            "the queen rules the kingdom",
            "the king and queen live in the palace",
            "the prince is the son of the king",
            "the princess is the daughter of the queen",
            "paris is the capital of france",
            "london is the capital of england",
            "berlin is the capital of germany",
            "rome is the capital of italy",
            "france is a country in europe",
            "england is a country in europe",
            "germany is a country in europe",
            "italy is a country in europe",
            "the man works in the city",
            "the woman works in the city",
            "the boy is young",
            "the girl is young",
            "the man is strong",
            "the woman is strong"
        ];

        // Word categories for coloring
        const categories = {
            royalty: ['king', 'queen', 'prince', 'princess', 'palace', 'kingdom'],
            countries: ['france', 'england', 'germany', 'italy', 'europe', 'country'],
            cities: ['paris', 'london', 'berlin', 'rome', 'capital', 'city'],
            people: ['man', 'woman', 'boy', 'girl', 'son', 'daughter']
        };

        // State
        let state = {
            vocab: {},
            word2idx: {},
            idx2word: {},
            embeddings: null,
            lossHistory: [],
            trained: false,
            epochs: 100,
            lr: 0.1,
            windowSize: 2,
            model: 'skipgram'
        };

        // Build vocabulary
        function buildVocab() {
            const words = new Set();
            corpus.forEach(sentence => {
                sentence.toLowerCase().split(/\s+/).forEach(w => words.add(w));
            });

            state.vocab = Array.from(words);
            state.word2idx = {};
            state.idx2word = {};

            state.vocab.forEach((word, idx) => {
                state.word2idx[word] = idx;
                state.idx2word[idx] = word;
            });

            document.getElementById('vocabSize').textContent = state.vocab.length;

            // Update dropdowns
            const dropdowns = ['wordA', 'wordB', 'wordC', 'selectedWord'];
            dropdowns.forEach(id => {
                const select = document.getElementById(id);
                select.innerHTML = '';
                state.vocab.forEach(word => {
                    const opt = document.createElement('option');
                    opt.value = word;
                    opt.textContent = word;
                    select.appendChild(opt);
                });
            });

            // Set default analogy
            document.getElementById('wordA').value = 'king';
            document.getElementById('wordB').value = 'man';
            document.getElementById('wordC').value = 'woman';
            document.getElementById('selectedWord').value = 'king';
        }

        // Initialize embeddings randomly
        function initEmbeddings() {
            const vocabSize = state.vocab.length;
            const dim = 2;  // 2D for visualization

            state.embeddings = [];
            for (let i = 0; i < vocabSize; i++) {
                state.embeddings.push([
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                ]);
            }
        }

        // Generate training pairs
        function generateTrainingPairs() {
            const pairs = [];
            const windowSize = state.windowSize;

            corpus.forEach(sentence => {
                const words = sentence.toLowerCase().split(/\s+/);

                for (let i = 0; i < words.length; i++) {
                    const centerWord = words[i];
                    const centerIdx = state.word2idx[centerWord];

                    for (let j = Math.max(0, i - windowSize); j <= Math.min(words.length - 1, i + windowSize); j++) {
                        if (i !== j) {
                            const contextWord = words[j];
                            const contextIdx = state.word2idx[contextWord];

                            if (state.model === 'skipgram') {
                                // Skip-gram: predict context from center
                                pairs.push([centerIdx, contextIdx]);
                            } else {
                                // CBOW: predict center from context
                                pairs.push([contextIdx, centerIdx]);
                            }
                        }
                    }
                }
            });

            return pairs;
        }

        // Softmax
        function softmax(scores) {
            const maxScore = Math.max(...scores);
            const exps = scores.map(s => Math.exp(s - maxScore));
            const sum = exps.reduce((a, b) => a + b, 0);
            return exps.map(e => e / sum);
        }

        // Dot product
        function dot(a, b) {
            return a[0] * b[0] + a[1] * b[1];
        }

        // Train one step (simplified negative sampling approach)
        function trainStep(pairs) {
            const lr = state.lr;
            let totalLoss = 0;

            // Shuffle pairs
            const shuffled = pairs.sort(() => Math.random() - 0.5);

            for (const [inputIdx, targetIdx] of shuffled.slice(0, 50)) {  // Mini-batch
                const inputVec = state.embeddings[inputIdx];

                // Compute scores for all words
                const scores = state.embeddings.map(emb => dot(inputVec, emb));
                const probs = softmax(scores);

                // Cross-entropy loss
                totalLoss -= Math.log(probs[targetIdx] + 1e-10);

                // Gradient update (simplified)
                for (let i = 0; i < state.vocab.length; i++) {
                    const grad = probs[i] - (i === targetIdx ? 1 : 0);

                    // Update embeddings
                    state.embeddings[i][0] -= lr * grad * inputVec[0] * 0.1;
                    state.embeddings[i][1] -= lr * grad * inputVec[1] * 0.1;

                    state.embeddings[inputIdx][0] -= lr * grad * state.embeddings[i][0] * 0.1;
                    state.embeddings[inputIdx][1] -= lr * grad * state.embeddings[i][1] * 0.1;
                }
            }

            return totalLoss / Math.min(50, shuffled.length);
        }

        // Train embeddings
        async function train() {
            state.epochs = parseInt(document.getElementById('epochs').value);
            state.lr = parseFloat(document.getElementById('lr').value);
            state.windowSize = parseInt(document.getElementById('window').value);
            state.model = document.getElementById('model').value;

            initEmbeddings();
            state.lossHistory = [];

            const pairs = generateTrainingPairs();

            for (let epoch = 0; epoch < state.epochs; epoch++) {
                const loss = trainStep(pairs);
                state.lossHistory.push(loss);

                document.getElementById('currentEpoch').textContent = epoch + 1;
                document.getElementById('currentLoss').textContent = loss.toFixed(4);

                if (epoch % 5 === 0) {
                    updateDisplay();
                    await new Promise(r => setTimeout(r, 10));
                }
            }

            state.trained = true;
            updateDisplay();
            updateNeighbors();
            computeAnalogy();
        }

        // Cosine similarity
        function cosineSimilarity(a, b) {
            const dotProd = dot(a, b);
            const normA = Math.sqrt(dot(a, a));
            const normB = Math.sqrt(dot(b, b));
            return dotProd / (normA * normB + 1e-10);
        }

        // Find nearest neighbors
        function findNeighbors(word, k = 5) {
            const idx = state.word2idx[word];
            if (idx === undefined) return [];

            const vec = state.embeddings[idx];
            const similarities = [];

            for (let i = 0; i < state.vocab.length; i++) {
                if (i !== idx) {
                    similarities.push({
                        word: state.idx2word[i],
                        score: cosineSimilarity(vec, state.embeddings[i])
                    });
                }
            }

            similarities.sort((a, b) => b.score - a.score);
            return similarities.slice(0, k);
        }

        // Vector arithmetic for analogy
        function computeAnalogy() {
            if (!state.trained) return;

            const wordA = document.getElementById('wordA').value;
            const wordB = document.getElementById('wordB').value;
            const wordC = document.getElementById('wordC').value;

            const idxA = state.word2idx[wordA];
            const idxB = state.word2idx[wordB];
            const idxC = state.word2idx[wordC];

            if (idxA === undefined || idxB === undefined || idxC === undefined) return;

            // result = A - B + C
            const result = [
                state.embeddings[idxA][0] - state.embeddings[idxB][0] + state.embeddings[idxC][0],
                state.embeddings[idxA][1] - state.embeddings[idxB][1] + state.embeddings[idxC][1]
            ];

            // Find closest word to result
            let bestWord = '';
            let bestScore = -Infinity;
            const exclude = new Set([idxA, idxB, idxC]);

            for (let i = 0; i < state.vocab.length; i++) {
                if (!exclude.has(i)) {
                    const sim = cosineSimilarity(result, state.embeddings[i]);
                    if (sim > bestScore) {
                        bestScore = sim;
                        bestWord = state.idx2word[i];
                    }
                }
            }

            document.getElementById('analogyResult').innerHTML =
                `<span style="color: #f87171;">${wordA}</span> - ` +
                `<span style="color: #60a5fa;">${wordB}</span> + ` +
                `<span style="color: #4ade80;">${wordC}</span> ≈ ` +
                `<span style="color: #c9a227;">${bestWord}</span> (${bestScore.toFixed(3)})`;

            drawAnalogy(wordA, wordB, wordC, bestWord, result);
        }

        function updateNeighbors() {
            if (!state.trained) return;

            const word = document.getElementById('selectedWord').value;
            const neighbors = findNeighbors(word);

            const list = document.getElementById('neighborsList');
            list.innerHTML = neighbors.map(n =>
                `<div class="neighbor-item">
                    <span class="word">${n.word}</span>
                    <span class="score">${n.score.toFixed(3)}</span>
                </div>`
            ).join('');
        }

        function updateDisplay() {
            drawEmbeddings();
            drawLoss();
        }

        function getWordColor(word) {
            if (categories.royalty.includes(word)) return '#f87171';
            if (categories.countries.includes(word)) return '#4ade80';
            if (categories.cities.includes(word)) return '#60a5fa';
            return '#a78bfa';
        }

        function drawEmbeddings() {
            const ctx = embCtx;
            const W = embCanvas.width;
            const H = embCanvas.height;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, W, H);

            if (!state.embeddings) return;

            // Find bounds
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            state.embeddings.forEach(([x, y]) => {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            });

            const margin = 60;
            const scaleX = (W - 2 * margin) / (maxX - minX || 1);
            const scaleY = (H - 2 * margin) / (maxY - minY || 1);
            const scale = Math.min(scaleX, scaleY);

            const cx = W / 2;
            const cy = H / 2;
            const midX = (minX + maxX) / 2;
            const midY = (minY + maxY) / 2;

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(margin, cy);
            ctx.lineTo(W - margin, cy);
            ctx.moveTo(cx, margin);
            ctx.lineTo(cx, H - margin);
            ctx.stroke();

            // Draw words
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'center';

            const selectedWord = document.getElementById('selectedWord').value;

            state.embeddings.forEach((emb, idx) => {
                const word = state.idx2word[idx];
                const px = cx + (emb[0] - midX) * scale;
                const py = cy - (emb[1] - midY) * scale;

                const color = getWordColor(word);
                const isSelected = word === selectedWord;

                // Draw point
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(px, py, isSelected ? 8 : 5, 0, Math.PI * 2);
                ctx.fill();

                if (isSelected) {
                    ctx.strokeStyle = '#c9a227';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Draw label
                ctx.fillStyle = isSelected ? '#fff' : '#aaa';
                ctx.fillText(word, px, py - 10);
            });
        }

        function drawLoss() {
            const ctx = lossCtx;
            const W = lossCanvas.width;
            const H = lossCanvas.height;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, W, H);

            if (state.lossHistory.length === 0) return;

            const margin = 50;
            const plotW = W - 2 * margin;
            const plotH = H - 2 * margin;

            // Draw axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(margin, H - margin);
            ctx.lineTo(W - margin, H - margin);
            ctx.moveTo(margin, H - margin);
            ctx.lineTo(margin, margin);
            ctx.stroke();

            // Find scale
            const maxLoss = Math.max(...state.lossHistory);
            const minLoss = Math.min(...state.lossHistory);

            // Draw loss curve
            ctx.strokeStyle = '#4ade80';
            ctx.lineWidth = 2;
            ctx.beginPath();

            state.lossHistory.forEach((loss, i) => {
                const x = margin + (i / (state.lossHistory.length - 1)) * plotW;
                const y = H - margin - ((loss - minLoss) / (maxLoss - minLoss || 1)) * plotH;

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });

            ctx.stroke();

            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Epoch', W / 2, H - 5);

            ctx.textAlign = 'right';
            ctx.fillText(maxLoss.toFixed(2), margin - 5, margin + 5);
            ctx.fillText(minLoss.toFixed(2), margin - 5, H - margin);
        }

        function drawAnalogy(wordA, wordB, wordC, wordD, resultVec) {
            const ctx = analogyCtx;
            const W = analogyCanvas.width;
            const H = analogyCanvas.height;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, W, H);

            if (!state.trained) return;

            const idxA = state.word2idx[wordA];
            const idxB = state.word2idx[wordB];
            const idxC = state.word2idx[wordC];
            const idxD = state.word2idx[wordD];

            const vecA = state.embeddings[idxA];
            const vecB = state.embeddings[idxB];
            const vecC = state.embeddings[idxC];
            const vecD = state.embeddings[idxD];

            // Find bounds
            const allVecs = [vecA, vecB, vecC, vecD, resultVec];
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            allVecs.forEach(([x, y]) => {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            });

            const margin = 80;
            const scale = Math.min(
                (W - 2 * margin) / (maxX - minX || 1),
                (H - 2 * margin) / (maxY - minY || 1)
            ) * 0.8;

            const cx = W / 2;
            const cy = H / 2;
            const midX = (minX + maxX) / 2;
            const midY = (minY + maxY) / 2;

            function toCanvas(vec) {
                return [
                    cx + (vec[0] - midX) * scale,
                    cy - (vec[1] - midY) * scale
                ];
            }

            const pA = toCanvas(vecA);
            const pB = toCanvas(vecB);
            const pC = toCanvas(vecC);
            const pD = toCanvas(vecD);
            const pR = toCanvas(resultVec);

            // Draw vectors
            // A - B (subtraction)
            ctx.strokeStyle = 'rgba(248, 113, 113, 0.6)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(pA[0], pA[1]);
            ctx.lineTo(pB[0], pB[1]);
            ctx.stroke();
            ctx.setLineDash([]);

            // B + offset to C
            ctx.strokeStyle = 'rgba(96, 165, 250, 0.6)';
            ctx.beginPath();
            ctx.moveTo(pB[0], pB[1]);
            ctx.lineTo(pC[0], pC[1]);
            ctx.stroke();

            // C to result
            ctx.strokeStyle = 'rgba(74, 222, 128, 0.6)';
            ctx.beginPath();
            ctx.moveTo(pC[0], pC[1]);
            ctx.lineTo(pR[0], pR[1]);
            ctx.stroke();

            // Result to D
            ctx.strokeStyle = 'rgba(201, 162, 39, 0.6)';
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(pR[0], pR[1]);
            ctx.lineTo(pD[0], pD[1]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw points
            const points = [
                { p: pA, word: wordA, color: '#f87171' },
                { p: pB, word: wordB, color: '#60a5fa' },
                { p: pC, word: wordC, color: '#4ade80' },
                { p: pR, word: '(result)', color: '#888' },
                { p: pD, word: wordD, color: '#c9a227' }
            ];

            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';

            points.forEach(({ p, word, color }) => {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(p[0], p[1], 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillText(word, p[0], p[1] - 12);
            });

            // Legend
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#888';
            ctx.fillText('A: ' + wordA, 10, 20);
            ctx.fillText('B: ' + wordB, 10, 35);
            ctx.fillText('C: ' + wordC, 10, 50);
            ctx.fillText('Result ≈ D: ' + wordD, 10, 65);
        }

        // Event listeners
        document.getElementById('epochs').addEventListener('input', e => {
            document.getElementById('epochsValue').textContent = e.target.value;
        });

        document.getElementById('lr').addEventListener('input', e => {
            document.getElementById('lrValue').textContent = e.target.value;
        });

        document.getElementById('window').addEventListener('input', e => {
            document.getElementById('windowValue').textContent = e.target.value;
        });

        document.getElementById('trainBtn').addEventListener('click', train);

        document.getElementById('resetBtn').addEventListener('click', () => {
            state.trained = false;
            state.lossHistory = [];
            initEmbeddings();
            updateDisplay();
            document.getElementById('currentEpoch').textContent = '0';
            document.getElementById('currentLoss').textContent = '-';
            document.getElementById('analogyResult').textContent = 'Train embeddings first';
            document.getElementById('neighborsList').innerHTML = '';
        });

        ['wordA', 'wordB', 'wordC'].forEach(id => {
            document.getElementById(id).addEventListener('change', computeAnalogy);
        });

        document.getElementById('selectedWord').addEventListener('change', () => {
            updateNeighbors();
            updateDisplay();
        });

        // Initialize
        buildVocab();
        initEmbeddings();

        // Display corpus
        document.getElementById('corpusDisplay').textContent = corpus.join(' | ');

        updateDisplay();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
