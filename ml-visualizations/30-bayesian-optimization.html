<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bayesian Optimization Playground - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px;
            color: #c9a227; text-decoration: none; font-weight: 500;
            z-index: 1000; transition: all 0.3s ease;
        }
        .back-link:hover { color: #ffd700; transform: translateX(-4px); }
        .container { max-width: 1600px; margin: 0 auto; padding: 60px 20px 20px; }
        h1 { text-align: center; color: #c9a227; margin-bottom: 0.5rem; font-size: 2rem; }
        .subtitle { text-align: center; color: #888; margin-bottom: 1.5rem; }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }

        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .canvas-container {
            background: rgba(20, 20, 35, 0.9);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(201, 162, 39, 0.3);
        }

        .canvas-container h3 {
            color: #c9a227;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        canvas {
            width: 100%;
            background: #0a0a15;
            border-radius: 8px;
            cursor: crosshair;
        }

        .controls {
            background: rgba(20, 20, 35, 0.9);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(201, 162, 39, 0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: #c9a227;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(201, 162, 39, 0.3);
            color: #e0e0e0;
            border-radius: 6px;
        }

        .control-group .value {
            color: #888;
            font-size: 0.85rem;
        }

        .btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #c9a227, #d4af37);
            color: #0a0a0f;
        }

        .btn-secondary {
            background: rgba(201, 162, 39, 0.2);
            color: #c9a227;
            border: 1px solid rgba(201, 162, 39, 0.4);
        }

        .btn:hover { transform: translateY(-2px); }

        .info-panel {
            background: rgba(30, 30, 50, 0.8);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .info-panel h4 {
            color: #c9a227;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 0.85rem;
        }

        .info-row:last-child { border-bottom: none; }
        .info-row .label { color: #888; }
        .info-row .value { color: #4ade80; font-family: monospace; }

        .equation {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.8rem;
            margin-top: 10px;
            line-height: 1.5;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 10px;
            font-size: 0.8rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to ML Visualizations</a>

    <div class="container">
        <h1>Bayesian Optimization Playground</h1>
        <p class="subtitle">Optimize black-box functions using Gaussian Process surrogate + Acquisition Functions</p>

        <div class="main-content">
            <div class="visualization-area">
                <div class="canvas-container">
                    <h3>Objective Function & GP Surrogate</h3>
                    <canvas id="mainCanvas" width="900" height="300"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(248, 113, 113, 0.5);"></div>
                            <span>True Function</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4ade80;"></div>
                            <span>GP Mean</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(74, 222, 128, 0.2);"></div>
                            <span>GP 95% CI</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #c9a227;"></div>
                            <span>Observations</span>
                        </div>
                    </div>
                </div>

                <div class="canvas-container">
                    <h3>Acquisition Function (Next Sample at Maximum)</h3>
                    <canvas id="acqCanvas" width="900" height="180"></canvas>
                </div>

                <div class="canvas-container">
                    <h3>Optimization Progress</h3>
                    <canvas id="progressCanvas" width="900" height="150"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Objective Function</label>
                    <select id="objective">
                        <option value="multimodal">Multimodal (hard)</option>
                        <option value="forrester">Forrester</option>
                        <option value="sincos">Sin + Cos</option>
                        <option value="branin1d">Branin 1D</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Acquisition Function</label>
                    <select id="acquisition">
                        <option value="ei">Expected Improvement (EI)</option>
                        <option value="ucb">Upper Confidence Bound (UCB)</option>
                        <option value="pi">Probability of Improvement (PI)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>UCB κ (exploration-exploitation)</label>
                    <input type="range" id="kappa" min="0.1" max="5" step="0.1" value="2">
                    <div class="value">κ = <span id="kappaValue">2.0</span></div>
                </div>

                <div class="control-group">
                    <label>GP Length Scale</label>
                    <input type="range" id="lengthScale" min="0.05" max="0.5" step="0.01" value="0.15">
                    <div class="value">ℓ = <span id="lengthScaleValue">0.15</span></div>
                </div>

                <div class="control-group">
                    <label>Observation Noise</label>
                    <input type="range" id="noise" min="0" max="0.2" step="0.01" value="0.01">
                    <div class="value">σₙ = <span id="noiseValue">0.01</span></div>
                </div>

                <button class="btn btn-primary" id="stepBtn">Take Next Sample</button>
                <button class="btn btn-secondary" id="autoBtn">Auto-Optimize (10 steps)</button>
                <button class="btn btn-secondary" id="resetBtn">Reset</button>

                <div class="info-panel">
                    <h4>Current State</h4>
                    <div class="info-row">
                        <span class="label">Samples:</span>
                        <span class="value" id="numSamples">0</span>
                    </div>
                    <div class="info-row">
                        <span class="label">Best Value:</span>
                        <span class="value" id="bestValue">-</span>
                    </div>
                    <div class="info-row">
                        <span class="label">Best x:</span>
                        <span class="value" id="bestX">-</span>
                    </div>
                    <div class="info-row">
                        <span class="label">True Max:</span>
                        <span class="value" id="trueMax">-</span>
                    </div>
                    <div class="info-row">
                        <span class="label">Next x:</span>
                        <span class="value" id="nextX">-</span>
                    </div>
                </div>

                <div class="info-panel">
                    <h4>Acquisition Functions</h4>
                    <div class="equation">
                        <b>EI:</b> E[max(f(x)-f*, 0)]<br>
                        <b>UCB:</b> μ(x) + κ·σ(x)<br>
                        <b>PI:</b> P(f(x) > f*)
                    </div>
                </div>

                <div class="info-panel">
                    <h4>Instructions</h4>
                    <div style="font-size: 0.8rem; color: #888; line-height: 1.5;">
                        1. Click on main canvas to add manual samples<br>
                        2. "Take Next Sample" adds at acquisition max<br>
                        3. Watch GP uncertainty shrink with more data<br>
                        4. Try different acquisition functions!
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const mainCanvas = document.getElementById('mainCanvas');
        const mainCtx = mainCanvas.getContext('2d');
        const acqCanvas = document.getElementById('acqCanvas');
        const acqCtx = acqCanvas.getContext('2d');
        const progressCanvas = document.getElementById('progressCanvas');
        const progressCtx = progressCanvas.getContext('2d');

        // State
        let state = {
            observations: [],  // {x, y}
            objective: 'multimodal',
            acquisition: 'ei',
            kappa: 2,
            lengthScale: 0.15,
            noise: 0.01,
            bestHistory: [],
            trueMax: 0,
            trueMaxX: 0
        };

        // Objective functions (domain [0, 1])
        const objectives = {
            multimodal: x => Math.sin(10 * Math.PI * x) * 0.5 + Math.sin(3 * Math.PI * x) * 0.3 + x * 0.2,
            forrester: x => Math.pow(6 * x - 2, 2) * Math.sin(12 * x - 4) * 0.2,
            sincos: x => Math.sin(4 * Math.PI * x) * Math.cos(2 * Math.PI * x),
            branin1d: x => -Math.pow(Math.sin(3 * Math.PI * x), 2) - Math.pow(x - 0.5, 2)
        };

        // Find true maximum
        function findTrueMax() {
            const f = objectives[state.objective];
            let maxY = -Infinity;
            let maxX = 0;
            for (let x = 0; x <= 1; x += 0.001) {
                const y = f(x);
                if (y > maxY) {
                    maxY = y;
                    maxX = x;
                }
            }
            state.trueMax = maxY;
            state.trueMaxX = maxX;
            document.getElementById('trueMax').textContent = maxY.toFixed(4);
        }

        // RBF kernel
        function kernel(x1, x2, lengthScale) {
            const diff = x1 - x2;
            return Math.exp(-0.5 * diff * diff / (lengthScale * lengthScale));
        }

        // Build kernel matrix
        function buildKernelMatrix(X, lengthScale, noise) {
            const n = X.length;
            const K = [];
            for (let i = 0; i < n; i++) {
                K[i] = [];
                for (let j = 0; j < n; j++) {
                    K[i][j] = kernel(X[i], X[j], lengthScale);
                    if (i === j) K[i][j] += noise * noise + 1e-6;
                }
            }
            return K;
        }

        // Simple matrix inversion (Cholesky not needed for small matrices)
        function invertMatrix(M) {
            const n = M.length;
            const A = M.map(row => [...row]);
            const I = Array(n).fill(null).map((_, i) =>
                Array(n).fill(0).map((_, j) => i === j ? 1 : 0)
            );

            for (let i = 0; i < n; i++) {
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;
                }
                [A[i], A[maxRow]] = [A[maxRow], A[i]];
                [I[i], I[maxRow]] = [I[maxRow], I[i]];

                const pivot = A[i][i];
                if (Math.abs(pivot) < 1e-10) continue;

                for (let j = 0; j < n; j++) {
                    A[i][j] /= pivot;
                    I[i][j] /= pivot;
                }

                for (let k = 0; k < n; k++) {
                    if (k !== i) {
                        const factor = A[k][i];
                        for (let j = 0; j < n; j++) {
                            A[k][j] -= factor * A[i][j];
                            I[k][j] -= factor * I[i][j];
                        }
                    }
                }
            }

            return I;
        }

        // GP prediction
        function gpPredict(xNew) {
            if (state.observations.length === 0) {
                return { mean: 0, std: 1 };
            }

            const X = state.observations.map(o => o.x);
            const Y = state.observations.map(o => o.y);
            const n = X.length;

            const K = buildKernelMatrix(X, state.lengthScale, state.noise);
            const Kinv = invertMatrix(K);

            // k(x*, X)
            const kStar = X.map(xi => kernel(xNew, xi, state.lengthScale));

            // Mean: k* K^-1 y
            let mean = 0;
            for (let i = 0; i < n; i++) {
                let sum = 0;
                for (let j = 0; j < n; j++) {
                    sum += Kinv[i][j] * Y[j];
                }
                mean += kStar[i] * sum;
            }

            // Variance: k(x*,x*) - k* K^-1 k*^T
            let variance = kernel(xNew, xNew, state.lengthScale);
            for (let i = 0; i < n; i++) {
                let sum = 0;
                for (let j = 0; j < n; j++) {
                    sum += Kinv[i][j] * kStar[j];
                }
                variance -= kStar[i] * sum;
            }

            return {
                mean,
                std: Math.sqrt(Math.max(variance, 1e-10))
            };
        }

        // Standard normal CDF approximation
        function normalCDF(x) {
            const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741;
            const a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911;
            const sign = x < 0 ? -1 : 1;
            x = Math.abs(x) / Math.sqrt(2);
            const t = 1 / (1 + p * x);
            const y = 1 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            return 0.5 * (1 + sign * y);
        }

        // Standard normal PDF
        function normalPDF(x) {
            return Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
        }

        // Acquisition functions
        function expectedImprovement(x) {
            const { mean, std } = gpPredict(x);
            if (std < 1e-10) return 0;

            const fBest = state.observations.length > 0 ?
                Math.max(...state.observations.map(o => o.y)) : 0;

            const z = (mean - fBest) / std;
            return (mean - fBest) * normalCDF(z) + std * normalPDF(z);
        }

        function upperConfidenceBound(x) {
            const { mean, std } = gpPredict(x);
            return mean + state.kappa * std;
        }

        function probabilityOfImprovement(x) {
            const { mean, std } = gpPredict(x);
            if (std < 1e-10) return 0;

            const fBest = state.observations.length > 0 ?
                Math.max(...state.observations.map(o => o.y)) : 0;

            const z = (mean - fBest) / std;
            return normalCDF(z);
        }

        function getAcquisition(x) {
            switch (state.acquisition) {
                case 'ei': return expectedImprovement(x);
                case 'ucb': return upperConfidenceBound(x);
                case 'pi': return probabilityOfImprovement(x);
                default: return expectedImprovement(x);
            }
        }

        // Find acquisition maximum
        function findAcquisitionMax() {
            let maxAcq = -Infinity;
            let maxX = 0.5;

            for (let x = 0; x <= 1; x += 0.005) {
                const acq = getAcquisition(x);
                if (acq > maxAcq) {
                    maxAcq = acq;
                    maxX = x;
                }
            }

            return maxX;
        }

        // Add observation
        function addObservation(x) {
            const f = objectives[state.objective];
            const y = f(x) + (Math.random() - 0.5) * state.noise * 2;
            state.observations.push({ x, y });

            const currentBest = Math.max(...state.observations.map(o => o.y));
            state.bestHistory.push(currentBest);

            updateDisplay();
        }

        // Take optimization step
        function takeStep() {
            const nextX = findAcquisitionMax();
            addObservation(nextX);
        }

        function updateDisplay() {
            drawMain();
            drawAcquisition();
            drawProgress();
            updateStats();
        }

        function drawMain() {
            const ctx = mainCtx;
            const W = mainCanvas.width;
            const H = mainCanvas.height;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, W, H);

            const margin = 50;
            const plotW = W - 2 * margin;
            const plotH = H - 2 * margin;

            const f = objectives[state.objective];

            // Find Y range
            let minY = Infinity, maxY = -Infinity;
            for (let x = 0; x <= 1; x += 0.01) {
                const y = f(x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }

            // Include GP predictions in range
            for (let x = 0; x <= 1; x += 0.02) {
                const pred = gpPredict(x);
                minY = Math.min(minY, pred.mean - 2 * pred.std);
                maxY = Math.max(maxY, pred.mean + 2 * pred.std);
            }

            const yRange = maxY - minY || 1;
            minY -= yRange * 0.1;
            maxY += yRange * 0.1;

            const scaleX = x => margin + x * plotW;
            const scaleY = y => margin + plotH - (y - minY) / (maxY - minY) * plotH;

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(margin, H - margin);
            ctx.lineTo(W - margin, H - margin);
            ctx.moveTo(margin, H - margin);
            ctx.lineTo(margin, margin);
            ctx.stroke();

            // Draw GP confidence interval
            ctx.fillStyle = 'rgba(74, 222, 128, 0.15)';
            ctx.beginPath();
            for (let i = 0; i <= 100; i++) {
                const x = i / 100;
                const pred = gpPredict(x);
                const px = scaleX(x);
                const py = scaleY(pred.mean + 2 * pred.std);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            for (let i = 100; i >= 0; i--) {
                const x = i / 100;
                const pred = gpPredict(x);
                const px = scaleX(x);
                const py = scaleY(pred.mean - 2 * pred.std);
                ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();

            // Draw true function (faded)
            ctx.strokeStyle = 'rgba(248, 113, 113, 0.4)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            for (let i = 0; i <= 200; i++) {
                const x = i / 200;
                const y = f(x);
                const px = scaleX(x);
                const py = scaleY(y);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw GP mean
            ctx.strokeStyle = '#4ade80';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i <= 200; i++) {
                const x = i / 200;
                const pred = gpPredict(x);
                const px = scaleX(x);
                const py = scaleY(pred.mean);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Draw observations
            state.observations.forEach((obs, idx) => {
                const px = scaleX(obs.x);
                const py = scaleY(obs.y);

                ctx.fillStyle = idx === state.observations.length - 1 ? '#f87171' : '#c9a227';
                ctx.beginPath();
                ctx.arc(px, py, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            // Draw next sample location
            const nextX = findAcquisitionMax();
            const nextPx = scaleX(nextX);
            ctx.strokeStyle = '#60a5fa';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(nextPx, margin);
            ctx.lineTo(nextPx, H - margin);
            ctx.stroke();
            ctx.setLineDash([]);

            document.getElementById('nextX').textContent = nextX.toFixed(4);
        }

        function drawAcquisition() {
            const ctx = acqCtx;
            const W = acqCanvas.width;
            const H = acqCanvas.height;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, W, H);

            const margin = 50;
            const plotW = W - 2 * margin;
            const plotH = H - 2 * margin;

            // Compute acquisition function
            const acqValues = [];
            let minAcq = Infinity, maxAcq = -Infinity;
            for (let i = 0; i <= 200; i++) {
                const x = i / 200;
                const acq = getAcquisition(x);
                acqValues.push({ x, acq });
                minAcq = Math.min(minAcq, acq);
                maxAcq = Math.max(maxAcq, acq);
            }

            const acqRange = maxAcq - minAcq || 1;
            minAcq -= acqRange * 0.1;
            maxAcq += acqRange * 0.1;

            const scaleX = x => margin + x * plotW;
            const scaleY = y => margin + plotH - (y - minAcq) / (maxAcq - minAcq) * plotH;

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(margin, H - margin);
            ctx.lineTo(W - margin, H - margin);
            ctx.moveTo(margin, H - margin);
            ctx.lineTo(margin, margin);
            ctx.stroke();

            // Fill under curve
            ctx.fillStyle = 'rgba(96, 165, 250, 0.2)';
            ctx.beginPath();
            ctx.moveTo(scaleX(0), scaleY(minAcq));
            acqValues.forEach(({ x, acq }) => {
                ctx.lineTo(scaleX(x), scaleY(acq));
            });
            ctx.lineTo(scaleX(1), scaleY(minAcq));
            ctx.closePath();
            ctx.fill();

            // Draw acquisition curve
            ctx.strokeStyle = '#60a5fa';
            ctx.lineWidth = 2;
            ctx.beginPath();
            acqValues.forEach(({ x, acq }, i) => {
                const px = scaleX(x);
                const py = scaleY(acq);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            });
            ctx.stroke();

            // Mark maximum
            const nextX = findAcquisitionMax();
            const nextAcq = getAcquisition(nextX);
            const nextPx = scaleX(nextX);
            const nextPy = scaleY(nextAcq);

            ctx.fillStyle = '#f87171';
            ctx.beginPath();
            ctx.arc(nextPx, nextPy, 8, 0, Math.PI * 2);
            ctx.fill();

            // Label
            ctx.fillStyle = '#888';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Acquisition: ' + state.acquisition.toUpperCase(), W / 2, margin - 5);
        }

        function drawProgress() {
            const ctx = progressCtx;
            const W = progressCanvas.width;
            const H = progressCanvas.height;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, W, H);

            if (state.bestHistory.length === 0) return;

            const margin = 50;
            const plotW = W - 2 * margin;
            const plotH = H - 2 * margin;

            const minY = Math.min(...state.bestHistory, state.trueMax) - 0.1;
            const maxY = state.trueMax + 0.1;

            const scaleX = i => margin + (i / Math.max(state.bestHistory.length - 1, 1)) * plotW;
            const scaleY = y => margin + plotH - (y - minY) / (maxY - minY) * plotH;

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(margin, H - margin);
            ctx.lineTo(W - margin, H - margin);
            ctx.moveTo(margin, H - margin);
            ctx.lineTo(margin, margin);
            ctx.stroke();

            // Draw true max line
            ctx.strokeStyle = 'rgba(248, 113, 113, 0.5)';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(margin, scaleY(state.trueMax));
            ctx.lineTo(W - margin, scaleY(state.trueMax));
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw progress
            ctx.strokeStyle = '#4ade80';
            ctx.lineWidth = 2;
            ctx.beginPath();
            state.bestHistory.forEach((best, i) => {
                const px = scaleX(i);
                const py = scaleY(best);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            });
            ctx.stroke();

            // Points
            ctx.fillStyle = '#4ade80';
            state.bestHistory.forEach((best, i) => {
                ctx.beginPath();
                ctx.arc(scaleX(i), scaleY(best), 4, 0, Math.PI * 2);
                ctx.fill();
            });

            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Iteration', W / 2, H - 5);

            ctx.fillStyle = '#f87171';
            ctx.textAlign = 'right';
            ctx.fillText('True max', W - margin - 5, scaleY(state.trueMax) - 5);
        }

        function updateStats() {
            document.getElementById('numSamples').textContent = state.observations.length;

            if (state.observations.length > 0) {
                const best = Math.max(...state.observations.map(o => o.y));
                const bestObs = state.observations.find(o => o.y === best);
                document.getElementById('bestValue').textContent = best.toFixed(4);
                document.getElementById('bestX').textContent = bestObs.x.toFixed(4);
            } else {
                document.getElementById('bestValue').textContent = '-';
                document.getElementById('bestX').textContent = '-';
            }
        }

        function reset() {
            state.observations = [];
            state.bestHistory = [];
            findTrueMax();

            // Add 2 random initial samples
            addObservation(Math.random());
            addObservation(Math.random());
        }

        // Event listeners
        document.getElementById('objective').addEventListener('change', e => {
            state.objective = e.target.value;
            reset();
        });

        document.getElementById('acquisition').addEventListener('change', e => {
            state.acquisition = e.target.value;
            updateDisplay();
        });

        document.getElementById('kappa').addEventListener('input', e => {
            state.kappa = parseFloat(e.target.value);
            document.getElementById('kappaValue').textContent = state.kappa.toFixed(1);
            updateDisplay();
        });

        document.getElementById('lengthScale').addEventListener('input', e => {
            state.lengthScale = parseFloat(e.target.value);
            document.getElementById('lengthScaleValue').textContent = state.lengthScale.toFixed(2);
            updateDisplay();
        });

        document.getElementById('noise').addEventListener('input', e => {
            state.noise = parseFloat(e.target.value);
            document.getElementById('noiseValue').textContent = state.noise.toFixed(2);
            updateDisplay();
        });

        document.getElementById('stepBtn').addEventListener('click', takeStep);

        document.getElementById('autoBtn').addEventListener('click', async () => {
            for (let i = 0; i < 10; i++) {
                takeStep();
                await new Promise(r => setTimeout(r, 200));
            }
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        // Click to add observation
        mainCanvas.addEventListener('click', e => {
            const rect = mainCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const margin = 50 / mainCanvas.width;

            if (x >= margin && x <= 1 - margin) {
                const normalizedX = (x - margin) / (1 - 2 * margin);
                addObservation(Math.max(0, Math.min(1, normalizedX)));
            }
        });

        // Initialize
        reset();
    </script>
</body>
</html>
