<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AdaBoost with Decision Stumps - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        header { text-align: center; padding: 20px; margin-bottom: 20px; }
        h1 {
            font-size: 2.2rem;
            background: linear-gradient(90deg, #f39c12, #e74c3c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { color: #888; }
        .back-link { position: absolute; top: 20px; left: 20px; color: #f39c12; text-decoration: none; }
        .main-content { display: grid; grid-template-columns: 1fr 350px; gap: 20px; }
        .canvas-container { background: rgba(255,255,255,0.05); border-radius: 16px; padding: 20px; }
        canvas { display: block; margin: 0 auto; background: #0a0a1a; border-radius: 8px; cursor: crosshair; }
        .controls { display: flex; flex-direction: column; gap: 15px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 15px; }
        .panel h3 { color: #f39c12; font-size: 1rem; margin-bottom: 10px; border-bottom: 1px solid rgba(243,156,18,0.3); padding-bottom: 5px; }
        button {
            padding: 10px 15px; background: rgba(243,156,18,0.2);
            border: 1px solid rgba(243,156,18,0.5); border-radius: 6px;
            color: #f39c12; cursor: pointer; width: 100%; margin-bottom: 8px;
        }
        button:hover { background: rgba(243,156,18,0.3); }
        button.active { background: rgba(243,156,18,0.5); }
        .control-group { margin-bottom: 12px; }
        .control-group label { display: block; color: #f39c12; font-size: 0.85rem; margin-bottom: 5px; }
        input[type="range"] {
            width: 100%; height: 6px; -webkit-appearance: none;
            background: rgba(243,156,18,0.2); border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px;
            background: #f39c12; border-radius: 50%; cursor: pointer;
        }
        .stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
        .stat { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px; text-align: center; }
        .stat-value { font-size: 1rem; color: #f39c12; font-weight: bold; }
        .stat-label { font-size: 0.7rem; color: #888; }
        .info-text { font-size: 0.85rem; color: #aaa; line-height: 1.6; }
        .class-buttons { display: flex; gap: 10px; margin-bottom: 10px; }
        .class-buttons button { flex: 1; }
        .class-a { background: rgba(52,152,219,0.3) !important; border-color: #3498db !important; color: #3498db !important; }
        .class-b { background: rgba(231,76,60,0.3) !important; border-color: #e74c3c !important; color: #e74c3c !important; }
        .stumps-list { max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.3); border-radius: 6px; padding: 10px; }
        .stump-item { padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.05); font-size: 0.8rem; }
        .stump-item .weight { color: #f39c12; font-weight: bold; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Gallery</a>
    <div class="container">
        <header>
            <h1>AdaBoost with Decision Stumps</h1>
            <p class="subtitle">Adaptive boosting with weight updates and margin visualization</p>
        </header>
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas" width="900" height="550"></canvas>
            </div>
            <div class="controls">
                <div class="panel">
                    <h3>Add Points</h3>
                    <div class="class-buttons">
                        <button id="class-a-btn" class="class-a active" onclick="setClass(-1)">Class - (Blue)</button>
                        <button id="class-b-btn" class="class-b" onclick="setClass(1)">Class + (Red)</button>
                    </div>
                    <p class="info-text">Click canvas to add points. Point size shows weight.</p>
                </div>
                <div class="panel">
                    <h3>Data</h3>
                    <button onclick="generateLinear()">Linear Separable</button>
                    <button onclick="generateOverlap()">Overlapping Classes</button>
                    <button onclick="generateMoons()">Two Moons</button>
                    <button onclick="clearAll()">Clear All</button>
                </div>
                <div class="panel">
                    <h3>Training</h3>
                    <div class="control-group">
                        <label>Boosting Rounds: <span id="rounds-val">10</span></label>
                        <input type="range" id="rounds" min="1" max="30" value="10">
                    </div>
                    <button onclick="trainAdaBoost()">Train AdaBoost</button>
                    <button onclick="stepTrain()">Step (Add One Stump)</button>
                    <button onclick="resetWeights()">Reset Weights</button>
                </div>
                <div class="panel">
                    <h3>Statistics</h3>
                    <div class="stats">
                        <div class="stat">
                            <div class="stat-value" id="num-stumps">0</div>
                            <div class="stat-label">Stumps</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="train-error">-</div>
                            <div class="stat-label">Train Error</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="exp-loss">-</div>
                            <div class="stat-label">Exp Loss</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="min-margin">-</div>
                            <div class="stat-label">Min Margin</div>
                        </div>
                    </div>
                </div>
                <div class="panel">
                    <h3>Weak Learners</h3>
                    <div class="stumps-list" id="stumps-list"></div>
                </div>
                <div class="panel">
                    <h3>About</h3>
                    <p class="info-text">
                        AdaBoost iteratively trains weak learners (decision stumps) and
                        increases weights on misclassified samples. The final classifier
                        is a weighted vote of all stumps.
                    </p>
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let points = [];
        let currentClass = -1;
        let weights = [];
        let stumps = [];

        function setClass(c) {
            currentClass = c;
            document.getElementById('class-a-btn').classList.toggle('active', c === -1);
            document.getElementById('class-b-btn').classList.toggle('active', c === 1);
        }

        canvas.addEventListener('click', e => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / canvas.width;
            const y = (e.clientY - rect.top) / canvas.height;
            points.push({ x, y, label: currentClass });
            resetWeights();
        });

        function generateLinear() {
            points = [];
            for (let i = 0; i < 20; i++) {
                points.push({
                    x: 0.1 + Math.random() * 0.35,
                    y: 0.2 + Math.random() * 0.6,
                    label: -1
                });
                points.push({
                    x: 0.55 + Math.random() * 0.35,
                    y: 0.2 + Math.random() * 0.6,
                    label: 1
                });
            }
            resetWeights();
        }

        function generateOverlap() {
            points = [];
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = 0.15 + Math.random() * 0.05;
                points.push({
                    x: 0.35 + r * Math.cos(angle),
                    y: 0.5 + r * Math.sin(angle),
                    label: -1
                });
            }
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = 0.15 + Math.random() * 0.05;
                points.push({
                    x: 0.65 + r * Math.cos(angle),
                    y: 0.5 + r * Math.sin(angle),
                    label: 1
                });
            }
            // Add some overlap
            for (let i = 0; i < 10; i++) {
                points.push({
                    x: 0.45 + Math.random() * 0.1,
                    y: 0.4 + Math.random() * 0.2,
                    label: Math.random() < 0.5 ? -1 : 1
                });
            }
            resetWeights();
        }

        function generateMoons() {
            points = [];
            for (let i = 0; i < 30; i++) {
                const angle = Math.PI * (i / 30);
                points.push({
                    x: 0.3 + 0.2 * Math.cos(angle) + (Math.random() - 0.5) * 0.05,
                    y: 0.4 + 0.2 * Math.sin(angle) + (Math.random() - 0.5) * 0.05,
                    label: -1
                });
            }
            for (let i = 0; i < 30; i++) {
                const angle = Math.PI + Math.PI * (i / 30);
                points.push({
                    x: 0.5 + 0.2 * Math.cos(angle) + (Math.random() - 0.5) * 0.05,
                    y: 0.5 + 0.2 * Math.sin(angle) + (Math.random() - 0.5) * 0.05,
                    label: 1
                });
            }
            resetWeights();
        }

        function clearAll() {
            points = [];
            stumps = [];
            weights = [];
            updateStats();
            draw();
        }

        function resetWeights() {
            const n = points.length;
            weights = new Array(n).fill(1 / n);
            stumps = [];
            updateStats();
            draw();
        }

        function findBestStump() {
            let bestStump = null;
            let bestError = Infinity;

            // Try horizontal and vertical splits
            for (const axis of ['x', 'y']) {
                // Get unique thresholds
                const values = points.map(p => p[axis]).sort((a, b) => a - b);
                const thresholds = [];
                for (let i = 0; i < values.length - 1; i++) {
                    thresholds.push((values[i] + values[i + 1]) / 2);
                }

                for (const threshold of thresholds) {
                    for (const polarity of [-1, 1]) {
                        let error = 0;
                        for (let i = 0; i < points.length; i++) {
                            const pred = points[i][axis] < threshold ? polarity : -polarity;
                            if (pred !== points[i].label) {
                                error += weights[i];
                            }
                        }

                        if (error < bestError) {
                            bestError = error;
                            bestStump = { axis, threshold, polarity };
                        }
                    }
                }
            }

            return { stump: bestStump, error: bestError };
        }

        function predictStump(stump, point) {
            return point[stump.axis] < stump.threshold ? stump.polarity : -stump.polarity;
        }

        function predictEnsemble(point) {
            if (stumps.length === 0) return 0;
            let score = 0;
            for (const { stump, alpha } of stumps) {
                score += alpha * predictStump(stump, point);
            }
            return score;
        }

        function stepTrain() {
            if (points.length < 2) return;

            const { stump, error } = findBestStump();
            if (!stump || error >= 0.5) return;

            // Calculate alpha
            const eps = 1e-10;
            const alpha = 0.5 * Math.log((1 - error + eps) / (error + eps));

            // Update weights
            let totalWeight = 0;
            for (let i = 0; i < points.length; i++) {
                const pred = predictStump(stump, points[i]);
                weights[i] *= Math.exp(-alpha * points[i].label * pred);
                totalWeight += weights[i];
            }
            // Normalize
            for (let i = 0; i < weights.length; i++) {
                weights[i] /= totalWeight;
            }

            stumps.push({ stump, alpha, error });
            updateStats();
            draw();
        }

        function trainAdaBoost() {
            resetWeights();
            const rounds = parseInt(document.getElementById('rounds').value);
            for (let r = 0; r < rounds; r++) {
                stepTrain();
            }
        }

        function updateStats() {
            document.getElementById('num-stumps').textContent = stumps.length;

            if (points.length === 0 || stumps.length === 0) {
                document.getElementById('train-error').textContent = '-';
                document.getElementById('exp-loss').textContent = '-';
                document.getElementById('min-margin').textContent = '-';
                document.getElementById('stumps-list').innerHTML = '';
                return;
            }

            // Training error
            let errors = 0;
            let expLoss = 0;
            let minMargin = Infinity;

            for (const p of points) {
                const score = predictEnsemble(p);
                if (Math.sign(score) !== p.label) errors++;
                expLoss += Math.exp(-p.label * score);
                const margin = p.label * score;
                minMargin = Math.min(minMargin, margin);
            }

            document.getElementById('train-error').textContent = (errors / points.length * 100).toFixed(1) + '%';
            document.getElementById('exp-loss').textContent = (expLoss / points.length).toFixed(3);
            document.getElementById('min-margin').textContent = minMargin.toFixed(2);

            // Update stumps list
            const list = document.getElementById('stumps-list');
            list.innerHTML = '';
            stumps.forEach((s, i) => {
                const div = document.createElement('div');
                div.className = 'stump-item';
                div.innerHTML = `#${i + 1}: ${s.stump.axis} ${s.stump.polarity > 0 ? '<' : '>'} ${s.stump.threshold.toFixed(2)} <span class="weight">α=${s.alpha.toFixed(2)}</span>`;
                list.appendChild(div);
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw decision boundary heatmap
            if (stumps.length > 0) {
                const resolution = 4;
                for (let px = 0; px < canvas.width; px += resolution) {
                    for (let py = 0; py < canvas.height; py += resolution) {
                        const x = px / canvas.width;
                        const y = py / canvas.height;
                        const score = predictEnsemble({ x, y });

                        let color;
                        const intensity = Math.min(1, Math.abs(score) * 0.5);
                        if (score > 0) {
                            color = `rgba(231, 76, 60, ${intensity * 0.3})`;
                        } else {
                            color = `rgba(52, 152, 219, ${intensity * 0.3})`;
                        }

                        ctx.fillStyle = color;
                        ctx.fillRect(px, py, resolution, resolution);
                    }
                }
            }

            // Draw decision boundary contour
            if (stumps.length > 0) {
                ctx.strokeStyle = '#f39c12';
                ctx.lineWidth = 2;
                for (let px = 0; px < canvas.width; px += 2) {
                    for (let py = 0; py < canvas.height; py += 2) {
                        const x = px / canvas.width;
                        const y = py / canvas.height;
                        const score = predictEnsemble({ x, y });
                        if (Math.abs(score) < 0.1) {
                            ctx.fillStyle = '#f39c12';
                            ctx.fillRect(px, py, 2, 2);
                        }
                    }
                }
            }

            // Draw stumps (decision boundaries)
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            stumps.forEach((s, i) => {
                const opacity = 0.2 + 0.3 * (s.alpha / Math.max(...stumps.map(st => st.alpha)));
                ctx.strokeStyle = `rgba(243, 156, 18, ${opacity})`;
                ctx.beginPath();
                if (s.stump.axis === 'x') {
                    const px = s.stump.threshold * canvas.width;
                    ctx.moveTo(px, 0);
                    ctx.lineTo(px, canvas.height);
                } else {
                    const py = s.stump.threshold * canvas.height;
                    ctx.moveTo(0, py);
                    ctx.lineTo(canvas.width, py);
                }
                ctx.stroke();
            });
            ctx.setLineDash([]);

            // Draw points with size based on weight
            const maxWeight = Math.max(...weights, 1 / points.length);
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const size = 5 + (weights[i] / maxWeight) * 15;

                ctx.fillStyle = p.label === -1 ? '#3498db' : '#e74c3c';
                ctx.beginPath();
                ctx.arc(p.x * canvas.width, p.y * canvas.height, size, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        document.getElementById('rounds').addEventListener('input', e => {
            document.getElementById('rounds-val').textContent = e.target.value;
        });

        generateLinear();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
