<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grad-CAM for Tiny CNNs - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px;
            color: #ef4444; text-decoration: none; font-weight: 500;
            z-index: 1000; transition: all 0.3s ease;
        }
        .back-link:hover { color: #f87171; transform: translateX(-4px); }
        .container { max-width: 1400px; margin: 0 auto; padding: 60px 20px 20px; }
        h1 { text-align: center; color: #ef4444; margin-bottom: 0.5rem; font-size: 1.8rem; }
        .subtitle { text-align: center; color: #888; margin-bottom: 1.5rem; font-size: 0.95rem; }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }

        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .canvas-container {
            background: rgba(20, 20, 35, 0.9);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .canvas-container h3 {
            color: #ef4444;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        .canvas-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
        }

        .canvas-box {
            text-align: center;
        }

        .canvas-box canvas {
            background: #0a0a15;
            border-radius: 8px;
            image-rendering: pixelated;
        }

        .canvas-box label {
            display: block;
            margin-top: 8px;
            font-size: 0.8rem;
            color: #888;
        }

        .controls {
            background: rgba(20, 20, 35, 0.9);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .control-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(239, 68, 68, 0.2);
        }
        .control-section:last-child { border-bottom: none; }

        .control-section h4 {
            color: #ef4444;
            margin-bottom: 12px;
            font-size: 0.9rem;
        }

        .btn {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3); }

        .btn-secondary {
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        .btn-secondary:hover { background: rgba(239, 68, 68, 0.3); }

        .shape-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .shape-btn {
            padding: 8px;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #f87171;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .shape-btn.active {
            background: #ef4444;
            color: white;
        }

        .stats {
            background: rgba(239, 68, 68, 0.1);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.85rem;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }

        .stat-value { color: #f87171; font-weight: 600; }

        .predictions {
            margin-top: 15px;
        }

        .prediction-bar {
            margin-bottom: 8px;
        }

        .prediction-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            margin-bottom: 4px;
        }

        .prediction-fill {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }

        .prediction-fill-inner {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }

        .info-panel {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.2);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.8rem;
            line-height: 1.5;
            color: #aaa;
        }

        .info-panel strong { color: #f87171; }

        .draw-canvas {
            cursor: crosshair;
            touch-action: none;
        }

        @media (max-width: 1100px) {
            .main-content { grid-template-columns: 1fr; }
            .canvas-row { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to ML Visualizations</a>

    <div class="container">
        <h1>Grad-CAM for Tiny CNNs</h1>
        <p class="subtitle">Visualize where the network looks when classifying shapes</p>

        <div class="main-content">
            <div class="visualization-area">
                <div class="canvas-container">
                    <h3>Draw a Shape or Load a Sample</h3>
                    <div class="canvas-row">
                        <div class="canvas-box">
                            <canvas id="inputCanvas" class="draw-canvas" width="112" height="112"></canvas>
                            <label>Input (28×28)</label>
                        </div>
                        <div class="canvas-box">
                            <canvas id="conv1Canvas" width="112" height="112"></canvas>
                            <label>Conv1 Activations</label>
                        </div>
                        <div class="canvas-box">
                            <canvas id="conv2Canvas" width="112" height="112"></canvas>
                            <label>Conv2 Activations</label>
                        </div>
                        <div class="canvas-box">
                            <canvas id="gradcamCanvas" width="112" height="112"></canvas>
                            <label>Grad-CAM Heatmap</label>
                        </div>
                    </div>
                </div>

                <div class="canvas-container">
                    <h3>Grad-CAM Overlay</h3>
                    <div style="display: flex; justify-content: center; gap: 20px;">
                        <div class="canvas-box">
                            <canvas id="overlayCanvas" width="224" height="224"></canvas>
                            <label>Input with Grad-CAM overlay - shows where CNN "looks"</label>
                        </div>
                    </div>
                </div>

                <div class="info-panel">
                    <strong>How Grad-CAM Works:</strong> Gradient-weighted Class Activation Mapping computes the gradient
                    of the predicted class score with respect to the final convolutional layer's feature maps.
                    These gradients are averaged to get importance weights, which are then used to create a weighted
                    combination of the feature maps, producing a heatmap showing which regions most influenced the prediction.
                </div>
            </div>

            <div class="controls">
                <div class="control-section">
                    <h4>Load Sample Shape</h4>
                    <div class="shape-buttons">
                        <button class="shape-btn" data-shape="circle">Circle</button>
                        <button class="shape-btn" data-shape="square">Square</button>
                        <button class="shape-btn" data-shape="triangle">Triangle</button>
                    </div>
                    <button class="btn btn-secondary" id="clearBtn">Clear Canvas</button>
                </div>

                <div class="control-section">
                    <h4>Training</h4>
                    <button class="btn btn-primary" id="trainBtn">Train Network</button>
                    <button class="btn btn-secondary" id="classifyBtn">Classify & Show Grad-CAM</button>
                </div>

                <div class="control-section">
                    <h4>Network Status</h4>
                    <div class="stats">
                        <div class="stat-row">
                            <span>Training Epoch:</span>
                            <span class="stat-value" id="epochVal">0</span>
                        </div>
                        <div class="stat-row">
                            <span>Training Loss:</span>
                            <span class="stat-value" id="lossVal">-</span>
                        </div>
                        <div class="stat-row">
                            <span>Accuracy:</span>
                            <span class="stat-value" id="accVal">-</span>
                        </div>
                    </div>
                </div>

                <div class="control-section">
                    <h4>Predictions</h4>
                    <div class="predictions">
                        <div class="prediction-bar">
                            <div class="prediction-label">
                                <span>Circle</span>
                                <span class="stat-value" id="circleProb">0%</span>
                            </div>
                            <div class="prediction-fill">
                                <div class="prediction-fill-inner" id="circleFill" style="width: 0%; background: #3b82f6;"></div>
                            </div>
                        </div>
                        <div class="prediction-bar">
                            <div class="prediction-label">
                                <span>Square</span>
                                <span class="stat-value" id="squareProb">0%</span>
                            </div>
                            <div class="prediction-fill">
                                <div class="prediction-fill-inner" id="squareFill" style="width: 0%; background: #22c55e;"></div>
                            </div>
                        </div>
                        <div class="prediction-bar">
                            <div class="prediction-label">
                                <span>Triangle</span>
                                <span class="stat-value" id="triangleProb">0%</span>
                            </div>
                            <div class="prediction-fill">
                                <div class="prediction-fill-inner" id="triangleFill" style="width: 0%; background: #f59e0b;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const inputCanvas = document.getElementById('inputCanvas');
        const inputCtx = inputCanvas.getContext('2d');
        const conv1Canvas = document.getElementById('conv1Canvas');
        const conv1Ctx = conv1Canvas.getContext('2d');
        const conv2Canvas = document.getElementById('conv2Canvas');
        const conv2Ctx = conv2Canvas.getContext('2d');
        const gradcamCanvas = document.getElementById('gradcamCanvas');
        const gradcamCtx = gradcamCanvas.getContext('2d');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const overlayCtx = overlayCanvas.getContext('2d');

        const SIZE = 28;
        const DISPLAY_SIZE = 112;

        // Network architecture: Conv(3x3, 8) -> ReLU -> Pool -> Conv(3x3, 16) -> ReLU -> Pool -> FC(3)
        let conv1Weights, conv1Bias;  // 8 filters, 3x3
        let conv2Weights, conv2Bias;  // 16 filters, 3x3, 8 channels
        let fcWeights, fcBias;        // 16*7*7 -> 3

        // Activations for Grad-CAM
        let conv1Out, conv2Out, pooled1, pooled2, fcOut;
        let conv2Gradients;

        function initNetwork() {
            // Conv1: 8 filters, 3x3, 1 channel
            conv1Weights = [];
            conv1Bias = [];
            for (let f = 0; f < 8; f++) {
                conv1Weights[f] = randomFilter(3, 3, 1);
                conv1Bias[f] = 0;
            }

            // Conv2: 16 filters, 3x3, 8 channels
            conv2Weights = [];
            conv2Bias = [];
            for (let f = 0; f < 16; f++) {
                conv2Weights[f] = randomFilter(3, 3, 8);
                conv2Bias[f] = 0;
            }

            // FC: 16 * 7 * 7 -> 3
            const fcInputSize = 16 * 7 * 7;
            fcWeights = [];
            fcBias = [0, 0, 0];
            for (let i = 0; i < 3; i++) {
                fcWeights[i] = [];
                for (let j = 0; j < fcInputSize; j++) {
                    fcWeights[i][j] = (Math.random() - 0.5) * 0.1;
                }
            }
        }

        function randomFilter(h, w, c) {
            const filter = [];
            const scale = Math.sqrt(2.0 / (h * w * c));
            for (let i = 0; i < h; i++) {
                filter[i] = [];
                for (let j = 0; j < w; j++) {
                    filter[i][j] = [];
                    for (let k = 0; k < c; k++) {
                        filter[i][j][k] = (Math.random() - 0.5) * 2 * scale;
                    }
                }
            }
            return filter;
        }

        function convolve(input, filters, biases, inputChannels) {
            const h = input.length;
            const w = input[0].length;
            const outH = h - 2;
            const outW = w - 2;
            const numFilters = filters.length;

            const output = [];
            for (let f = 0; f < numFilters; f++) {
                output[f] = [];
                for (let i = 0; i < outH; i++) {
                    output[f][i] = [];
                    for (let j = 0; j < outW; j++) {
                        let sum = biases[f];
                        for (let fi = 0; fi < 3; fi++) {
                            for (let fj = 0; fj < 3; fj++) {
                                for (let c = 0; c < inputChannels; c++) {
                                    const inputVal = inputChannels === 1 ? input[i + fi][j + fj] : input[c][i + fi][j + fj];
                                    sum += filters[f][fi][fj][c] * inputVal;
                                }
                            }
                        }
                        output[f][i][j] = sum;
                    }
                }
            }
            return output;
        }

        function relu(x) {
            if (Array.isArray(x[0][0])) {
                return x.map(channel => channel.map(row => row.map(v => Math.max(0, v))));
            }
            return x.map(channel => channel.map(row => row.map(v => Math.max(0, v))));
        }

        function maxPool2x2(input) {
            const numChannels = input.length;
            const h = input[0].length;
            const w = input[0][0].length;
            const outH = Math.floor(h / 2);
            const outW = Math.floor(w / 2);

            const output = [];
            for (let c = 0; c < numChannels; c++) {
                output[c] = [];
                for (let i = 0; i < outH; i++) {
                    output[c][i] = [];
                    for (let j = 0; j < outW; j++) {
                        const vals = [
                            input[c][i*2][j*2],
                            input[c][i*2][j*2+1],
                            input[c][i*2+1][j*2],
                            input[c][i*2+1][j*2+1]
                        ];
                        output[c][i][j] = Math.max(...vals);
                    }
                }
            }
            return output;
        }

        function flatten(input) {
            const flat = [];
            for (let c = 0; c < input.length; c++) {
                for (let i = 0; i < input[c].length; i++) {
                    for (let j = 0; j < input[c][i].length; j++) {
                        flat.push(input[c][i][j]);
                    }
                }
            }
            return flat;
        }

        function softmax(x) {
            const max = Math.max(...x);
            const exp = x.map(v => Math.exp(v - max));
            const sum = exp.reduce((a, b) => a + b, 0);
            return exp.map(v => v / sum);
        }

        function forward(input) {
            // Conv1 + ReLU
            conv1Out = convolve(input, conv1Weights, conv1Bias, 1);
            conv1Out = relu(conv1Out);

            // Pool1 (28-2=26 -> 13)
            pooled1 = maxPool2x2(conv1Out);

            // Conv2 + ReLU
            conv2Out = convolve(pooled1, conv2Weights, conv2Bias, 8);
            conv2Out = relu(conv2Out);

            // Pool2 (13-2=11 -> 5 or 7 depending)
            // Actually: 13-2=11, 11/2=5
            pooled2 = maxPool2x2(conv2Out);

            // Flatten and FC
            const flatInput = flatten(pooled2);
            fcOut = [0, 0, 0];
            for (let i = 0; i < 3; i++) {
                fcOut[i] = fcBias[i];
                for (let j = 0; j < flatInput.length; j++) {
                    fcOut[i] += fcWeights[i][j] * flatInput[j];
                }
            }

            return softmax(fcOut);
        }

        function computeGradCAM(targetClass) {
            // Compute gradients of target class score w.r.t. conv2 output
            // For simplicity, we compute d(score[targetClass]) / d(conv2Out)

            const numFilters = conv2Out.length;
            const h = conv2Out[0].length;
            const w = conv2Out[0][0].length;

            // Backprop through FC layer
            // d(score) / d(pooled2_flat) = fcWeights[targetClass]
            // Then backprop through pooling and get gradients for conv2Out

            // Simplified: compute importance weights as global average of gradients
            const weights = [];
            for (let f = 0; f < numFilters; f++) {
                let sum = 0;
                for (let i = 0; i < h; i++) {
                    for (let j = 0; j < w; j++) {
                        // Approximate gradient contribution
                        sum += conv2Out[f][i][j] > 0 ? 1 : 0;
                    }
                }
                // Use FC weights as proxy for gradient importance
                const fcIdx = f * (pooled2[0].length * pooled2[0][0].length);
                weights[f] = 0;
                for (let k = 0; k < pooled2[0].length * pooled2[0][0].length; k++) {
                    weights[f] += fcWeights[targetClass][fcIdx + k];
                }
                weights[f] /= (pooled2[0].length * pooled2[0][0].length);
            }

            // Create weighted combination of feature maps
            const heatmap = [];
            for (let i = 0; i < h; i++) {
                heatmap[i] = [];
                for (let j = 0; j < w; j++) {
                    let sum = 0;
                    for (let f = 0; f < numFilters; f++) {
                        sum += weights[f] * conv2Out[f][i][j];
                    }
                    heatmap[i][j] = Math.max(0, sum); // ReLU
                }
            }

            return heatmap;
        }

        function generateShape(type) {
            const img = new Array(SIZE).fill(0).map(() => new Array(SIZE).fill(0));

            const cx = SIZE / 2 + (Math.random() - 0.5) * 4;
            const cy = SIZE / 2 + (Math.random() - 0.5) * 4;
            const r = 8 + Math.random() * 3;

            if (type === 'circle') {
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                        if (dist < r) {
                            img[y][x] = 1;
                        }
                    }
                }
            } else if (type === 'square') {
                const half = r * 0.8;
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        if (Math.abs(x - cx) < half && Math.abs(y - cy) < half) {
                            img[y][x] = 1;
                        }
                    }
                }
            } else if (type === 'triangle') {
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        const relY = cy + r - y;
                        const relX = x - cx;
                        if (relY > 0 && relY < r * 1.5 && Math.abs(relX) < relY * 0.7) {
                            img[y][x] = 1;
                        }
                    }
                }
            }

            // Add noise
            for (let y = 0; y < SIZE; y++) {
                for (let x = 0; x < SIZE; x++) {
                    img[y][x] += (Math.random() - 0.5) * 0.1;
                    img[y][x] = Math.max(0, Math.min(1, img[y][x]));
                }
            }

            return img;
        }

        function getInputImage() {
            const imgData = inputCtx.getImageData(0, 0, DISPLAY_SIZE, DISPLAY_SIZE);
            const img = [];
            for (let y = 0; y < SIZE; y++) {
                img[y] = [];
                for (let x = 0; x < SIZE; x++) {
                    // Sample from display canvas
                    const sx = Math.floor(x * DISPLAY_SIZE / SIZE);
                    const sy = Math.floor(y * DISPLAY_SIZE / SIZE);
                    const idx = (sy * DISPLAY_SIZE + sx) * 4;
                    img[y][x] = imgData.data[idx] / 255;
                }
            }
            return img;
        }

        function drawImage(ctx, img, size) {
            const scale = size / img.length;
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, size, size);

            for (let y = 0; y < img.length; y++) {
                for (let x = 0; x < img[0].length; x++) {
                    const v = Math.floor(img[y][x] * 255);
                    ctx.fillStyle = `rgb(${v}, ${v}, ${v})`;
                    ctx.fillRect(x * scale, y * scale, scale, scale);
                }
            }
        }

        function drawActivations(ctx, activations, size) {
            const numFilters = activations.length;
            const gridSize = Math.ceil(Math.sqrt(numFilters));
            const cellSize = size / gridSize;
            const actH = activations[0].length;
            const actW = activations[0][0].length;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, size, size);

            // Find global min/max
            let min = Infinity, max = -Infinity;
            for (const act of activations) {
                for (const row of act) {
                    for (const v of row) {
                        min = Math.min(min, v);
                        max = Math.max(max, v);
                    }
                }
            }
            const range = max - min || 1;

            for (let f = 0; f < numFilters; f++) {
                const gx = f % gridSize;
                const gy = Math.floor(f / gridSize);
                const offsetX = gx * cellSize;
                const offsetY = gy * cellSize;
                const scale = cellSize / actW;

                for (let y = 0; y < actH; y++) {
                    for (let x = 0; x < actW; x++) {
                        const v = (activations[f][y][x] - min) / range;
                        const intensity = Math.floor(v * 255);
                        ctx.fillStyle = `rgb(${intensity}, ${Math.floor(intensity * 0.5)}, ${Math.floor(intensity * 0.3)})`;
                        ctx.fillRect(offsetX + x * scale, offsetY + y * scale, scale, scale);
                    }
                }
            }
        }

        function drawHeatmap(ctx, heatmap, size) {
            const h = heatmap.length;
            const w = heatmap[0].length;
            const scale = size / w;

            // Normalize
            let max = 0;
            for (const row of heatmap) {
                for (const v of row) {
                    max = Math.max(max, v);
                }
            }
            max = max || 1;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, size, size);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const v = heatmap[y][x] / max;
                    // Jet colormap
                    const r = Math.floor(255 * Math.min(1, Math.max(0, 1.5 - Math.abs(4 * v - 3))));
                    const g = Math.floor(255 * Math.min(1, Math.max(0, 1.5 - Math.abs(4 * v - 2))));
                    const b = Math.floor(255 * Math.min(1, Math.max(0, 1.5 - Math.abs(4 * v - 1))));
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(x * scale, y * scale, scale, scale);
                }
            }
        }

        function drawOverlay(input, heatmap) {
            const ctx = overlayCtx;
            const size = 224;
            const inputH = input.length;
            const inputW = input[0].length;
            const heatH = heatmap.length;
            const heatW = heatmap[0].length;

            // Normalize heatmap
            let max = 0;
            for (const row of heatmap) {
                for (const v of row) {
                    max = Math.max(max, v);
                }
            }
            max = max || 1;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, size, size);

            const scale = size / inputW;

            for (let y = 0; y < inputH; y++) {
                for (let x = 0; x < inputW; x++) {
                    // Get input pixel
                    const gray = input[y][x];

                    // Interpolate heatmap value
                    const hx = (x / inputW) * heatW;
                    const hy = (y / inputH) * heatH;
                    const hxi = Math.min(heatW - 1, Math.floor(hx));
                    const hyi = Math.min(heatH - 1, Math.floor(hy));
                    const heat = heatmap[hyi][hxi] / max;

                    // Blend: grayscale with red overlay
                    const r = Math.floor(gray * 200 + heat * 255 * 0.6);
                    const g = Math.floor(gray * 200 * (1 - heat * 0.5));
                    const b = Math.floor(gray * 200 * (1 - heat * 0.7));

                    ctx.fillStyle = `rgb(${Math.min(255, r)}, ${Math.min(255, g)}, ${Math.min(255, b)})`;
                    ctx.fillRect(x * scale, y * scale, scale, scale);
                }
            }
        }

        // Training
        let trainingData = [];

        function generateTrainingData(numSamples) {
            trainingData = [];
            const shapes = ['circle', 'square', 'triangle'];
            for (let i = 0; i < numSamples; i++) {
                const shapeIdx = i % 3;
                const img = generateShape(shapes[shapeIdx]);
                const label = [0, 0, 0];
                label[shapeIdx] = 1;
                trainingData.push({ img, label, shapeIdx });
            }
            // Shuffle
            for (let i = trainingData.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [trainingData[i], trainingData[j]] = [trainingData[j], trainingData[i]];
            }
        }

        async function train() {
            generateTrainingData(300);
            initNetwork();

            const epochs = 30;
            const lr = 0.01;

            for (let epoch = 0; epoch < epochs; epoch++) {
                let totalLoss = 0;
                let correct = 0;

                for (const sample of trainingData) {
                    const pred = forward(sample.img);

                    // Cross-entropy loss
                    const loss = -Math.log(pred[sample.shapeIdx] + 1e-10);
                    totalLoss += loss;

                    // Check accuracy
                    const predClass = pred.indexOf(Math.max(...pred));
                    if (predClass === sample.shapeIdx) correct++;

                    // Simple gradient descent on FC layer
                    const flatInput = flatten(pooled2);
                    for (let c = 0; c < 3; c++) {
                        const grad = pred[c] - sample.label[c];
                        fcBias[c] -= lr * grad;
                        for (let j = 0; j < flatInput.length; j++) {
                            fcWeights[c][j] -= lr * grad * flatInput[j];
                        }
                    }
                }

                document.getElementById('epochVal').textContent = epoch + 1;
                document.getElementById('lossVal').textContent = (totalLoss / trainingData.length).toFixed(4);
                document.getElementById('accVal').textContent = ((correct / trainingData.length) * 100).toFixed(1) + '%';

                await new Promise(r => setTimeout(r, 10));
            }
        }

        function classify() {
            const input = getInputImage();
            const pred = forward(input);

            // Update prediction bars
            document.getElementById('circleProb').textContent = (pred[0] * 100).toFixed(1) + '%';
            document.getElementById('squareProb').textContent = (pred[1] * 100).toFixed(1) + '%';
            document.getElementById('triangleProb').textContent = (pred[2] * 100).toFixed(1) + '%';

            document.getElementById('circleFill').style.width = (pred[0] * 100) + '%';
            document.getElementById('squareFill').style.width = (pred[1] * 100) + '%';
            document.getElementById('triangleFill').style.width = (pred[2] * 100) + '%';

            // Draw activations
            drawActivations(conv1Ctx, conv1Out, DISPLAY_SIZE);
            drawActivations(conv2Ctx, conv2Out, DISPLAY_SIZE);

            // Compute and draw Grad-CAM for predicted class
            const predClass = pred.indexOf(Math.max(...pred));
            const heatmap = computeGradCAM(predClass);
            drawHeatmap(gradcamCtx, heatmap, DISPLAY_SIZE);
            drawOverlay(input, heatmap);
        }

        // Drawing
        let isDrawing = false;

        function startDraw(e) {
            isDrawing = true;
            draw(e);
        }

        function draw(e) {
            if (!isDrawing) return;

            const rect = inputCanvas.getBoundingClientRect();
            const scaleX = DISPLAY_SIZE / rect.width;
            const scaleY = DISPLAY_SIZE / rect.height;

            let x, y;
            if (e.touches) {
                x = (e.touches[0].clientX - rect.left) * scaleX;
                y = (e.touches[0].clientY - rect.top) * scaleY;
            } else {
                x = (e.clientX - rect.left) * scaleX;
                y = (e.clientY - rect.top) * scaleY;
            }

            inputCtx.fillStyle = '#fff';
            inputCtx.beginPath();
            inputCtx.arc(x, y, 6, 0, Math.PI * 2);
            inputCtx.fill();
        }

        function stopDraw() {
            isDrawing = false;
        }

        inputCanvas.addEventListener('mousedown', startDraw);
        inputCanvas.addEventListener('mousemove', draw);
        inputCanvas.addEventListener('mouseup', stopDraw);
        inputCanvas.addEventListener('mouseleave', stopDraw);
        inputCanvas.addEventListener('touchstart', startDraw);
        inputCanvas.addEventListener('touchmove', draw);
        inputCanvas.addEventListener('touchend', stopDraw);

        // Buttons
        document.querySelectorAll('.shape-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const shape = btn.dataset.shape;
                const img = generateShape(shape);
                drawImage(inputCtx, img, DISPLAY_SIZE);
                classify();
            });
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            inputCtx.fillStyle = '#0a0a15';
            inputCtx.fillRect(0, 0, DISPLAY_SIZE, DISPLAY_SIZE);
        });

        document.getElementById('trainBtn').addEventListener('click', train);
        document.getElementById('classifyBtn').addEventListener('click', classify);

        // Initialize
        initNetwork();
        inputCtx.fillStyle = '#0a0a15';
        inputCtx.fillRect(0, 0, DISPLAY_SIZE, DISPLAY_SIZE);
    </script>
</body>
</html>
