<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVM Margin & Kernels - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        header { text-align: center; padding: 20px; margin-bottom: 20px; }
        h1 {
            font-size: 2.2rem;
            background: linear-gradient(90deg, #9b59b6, #8e44ad);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { color: #888; }
        .back-link { position: absolute; top: 20px; left: 20px; color: #9b59b6; text-decoration: none; }
        .main-content { display: grid; grid-template-columns: 1fr 350px; gap: 20px; }
        .canvas-container { background: rgba(255,255,255,0.05); border-radius: 16px; padding: 20px; }
        canvas { display: block; margin: 0 auto; background: #0a0a1a; border-radius: 8px; cursor: crosshair; }
        .controls { display: flex; flex-direction: column; gap: 15px; }
        .panel { background: rgba(255,255,255,0.05); border-radius: 12px; padding: 15px; }
        .panel h3 { color: #9b59b6; font-size: 1rem; margin-bottom: 10px; border-bottom: 1px solid rgba(155,89,182,0.3); padding-bottom: 5px; }
        button {
            padding: 10px 15px; background: rgba(155,89,182,0.2);
            border: 1px solid rgba(155,89,182,0.5); border-radius: 6px;
            color: #9b59b6; cursor: pointer; width: 100%; margin-bottom: 8px;
        }
        button:hover { background: rgba(155,89,182,0.3); }
        button.active { background: rgba(155,89,182,0.5); }
        .control-group { margin-bottom: 12px; }
        .control-group label { display: block; color: #9b59b6; font-size: 0.85rem; margin-bottom: 5px; }
        input[type="range"] {
            width: 100%; height: 6px; -webkit-appearance: none;
            background: rgba(155,89,182,0.2); border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px;
            background: #9b59b6; border-radius: 50%; cursor: pointer;
        }
        select {
            width: 100%; padding: 8px; background: rgba(0,0,0,0.3);
            border: 1px solid rgba(155,89,182,0.3); border-radius: 6px;
            color: #e8e8e8; font-size: 0.85rem;
        }
        .stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
        .stat { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px; text-align: center; }
        .stat-value { font-size: 1rem; color: #9b59b6; font-weight: bold; }
        .stat-label { font-size: 0.7rem; color: #888; }
        .info-text { font-size: 0.85rem; color: #aaa; line-height: 1.6; }
        .class-buttons { display: flex; gap: 10px; }
        .class-buttons button { flex: 1; }
        .class-a { background: rgba(231,76,60,0.3) !important; border-color: #e74c3c !important; color: #e74c3c !important; }
        .class-b { background: rgba(52,152,219,0.3) !important; border-color: #3498db !important; color: #3498db !important; }
        .legend { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; }
        .legend-item { display: flex; align-items: center; gap: 5px; font-size: 0.8rem; }
        .legend-color { width: 12px; height: 12px; border-radius: 50%; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Gallery</a>
    <div class="container">
        <header>
            <h1>SVM Margin & Kernels</h1>
            <p class="subtitle">Maximum margin classification with kernel tricks</p>
        </header>
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas" width="900" height="550"></canvas>
            </div>
            <div class="controls">
                <div class="panel">
                    <h3>Add Points</h3>
                    <div class="class-buttons">
                        <button id="class-a-btn" class="class-a active" onclick="setClass(0)">Class A (Red)</button>
                        <button id="class-b-btn" class="class-b" onclick="setClass(1)">Class B (Blue)</button>
                    </div>
                    <p class="info-text" style="margin-top: 8px;">Click on canvas to add points</p>
                </div>
                <div class="panel">
                    <h3>Kernel Type</h3>
                    <select id="kernel-type" onchange="trainSVM()">
                        <option value="linear">Linear</option>
                        <option value="rbf">RBF (Gaussian)</option>
                        <option value="poly">Polynomial</option>
                    </select>
                    <div class="control-group" style="margin-top: 12px;">
                        <label>C (Regularization): <span id="c-val">1.0</span></label>
                        <input type="range" id="c-param" min="-2" max="3" step="0.1" value="0" onchange="trainSVM()">
                    </div>
                    <div class="control-group" id="gamma-group">
                        <label>Gamma (RBF/Poly): <span id="gamma-val">1.0</span></label>
                        <input type="range" id="gamma-param" min="-2" max="2" step="0.1" value="0" onchange="trainSVM()">
                    </div>
                    <div class="control-group" id="degree-group" style="display: none;">
                        <label>Degree (Poly): <span id="degree-val">3</span></label>
                        <input type="range" id="degree-param" min="2" max="6" step="1" value="3" onchange="trainSVM()">
                    </div>
                </div>
                <div class="panel">
                    <h3>Data</h3>
                    <button onclick="generateLinearData()">Linear Separable</button>
                    <button onclick="generateCircleData()">Circle (Non-linear)</button>
                    <button onclick="generateXORData()">XOR Pattern</button>
                    <button onclick="clearPoints()">Clear All</button>
                </div>
                <div class="panel">
                    <h3>Statistics</h3>
                    <div class="stats">
                        <div class="stat">
                            <div class="stat-value" id="class-a-count">0</div>
                            <div class="stat-label">Class A</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="class-b-count">0</div>
                            <div class="stat-label">Class B</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="sv-count">0</div>
                            <div class="stat-label">Support Vectors</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="margin-val">-</div>
                            <div class="stat-label">Margin</div>
                        </div>
                    </div>
                </div>
                <div class="panel">
                    <h3>Legend</h3>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-color" style="background: #e74c3c;"></div>Class A</div>
                        <div class="legend-item"><div class="legend-color" style="background: #3498db;"></div>Class B</div>
                        <div class="legend-item"><div class="legend-color" style="background: #9b59b6; border: 2px solid white;"></div>Support Vector</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let points = [];
        let currentClass = 0;
        let weights = null;
        let bias = 0;
        let supportVectors = [];
        let alphas = [];

        function setClass(c) {
            currentClass = c;
            document.getElementById('class-a-btn').classList.toggle('active', c === 0);
            document.getElementById('class-b-btn').classList.toggle('active', c === 1);
        }

        canvas.addEventListener('click', e => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / canvas.width;
            const y = (e.clientY - rect.top) / canvas.height;
            points.push({ x, y, label: currentClass === 0 ? -1 : 1 });
            trainSVM();
        });

        document.getElementById('kernel-type').addEventListener('change', () => {
            const type = document.getElementById('kernel-type').value;
            document.getElementById('degree-group').style.display = type === 'poly' ? 'block' : 'none';
        });

        document.getElementById('c-param').addEventListener('input', e => {
            document.getElementById('c-val').textContent = Math.pow(10, parseFloat(e.target.value)).toFixed(2);
        });
        document.getElementById('gamma-param').addEventListener('input', e => {
            document.getElementById('gamma-val').textContent = Math.pow(10, parseFloat(e.target.value)).toFixed(2);
        });
        document.getElementById('degree-param').addEventListener('input', e => {
            document.getElementById('degree-val').textContent = e.target.value;
        });

        function kernel(x1, x2) {
            const type = document.getElementById('kernel-type').value;
            const gamma = Math.pow(10, parseFloat(document.getElementById('gamma-param').value));
            const degree = parseInt(document.getElementById('degree-param').value);

            if (type === 'linear') {
                return x1.x * x2.x + x1.y * x2.y;
            } else if (type === 'rbf') {
                const dist = (x1.x - x2.x) ** 2 + (x1.y - x2.y) ** 2;
                return Math.exp(-gamma * dist);
            } else { // poly
                return Math.pow(gamma * (x1.x * x2.x + x1.y * x2.y) + 1, degree);
            }
        }

        function trainSVM() {
            if (points.length < 2) {
                weights = null;
                supportVectors = [];
                alphas = [];
                updateStats();
                draw();
                return;
            }

            const C = Math.pow(10, parseFloat(document.getElementById('c-param').value));
            const n = points.length;

            // Simplified SMO-like training
            alphas = new Array(n).fill(0);
            bias = 0;
            const maxIter = 500;
            const tol = 0.001;

            for (let iter = 0; iter < maxIter; iter++) {
                let changed = 0;
                for (let i = 0; i < n; i++) {
                    const Ei = predictRaw(points[i]) - points[i].label;

                    if ((points[i].label * Ei < -tol && alphas[i] < C) ||
                        (points[i].label * Ei > tol && alphas[i] > 0)) {

                        // Pick random j != i
                        let j = Math.floor(Math.random() * (n - 1));
                        if (j >= i) j++;

                        const Ej = predictRaw(points[j]) - points[j].label;

                        const oldAi = alphas[i];
                        const oldAj = alphas[j];

                        // Compute bounds
                        let L, H;
                        if (points[i].label !== points[j].label) {
                            L = Math.max(0, alphas[j] - alphas[i]);
                            H = Math.min(C, C + alphas[j] - alphas[i]);
                        } else {
                            L = Math.max(0, alphas[i] + alphas[j] - C);
                            H = Math.min(C, alphas[i] + alphas[j]);
                        }

                        if (L >= H) continue;

                        const eta = 2 * kernel(points[i], points[j]) -
                                   kernel(points[i], points[i]) -
                                   kernel(points[j], points[j]);

                        if (eta >= 0) continue;

                        alphas[j] -= points[j].label * (Ei - Ej) / eta;
                        alphas[j] = Math.max(L, Math.min(H, alphas[j]));

                        if (Math.abs(alphas[j] - oldAj) < 1e-5) continue;

                        alphas[i] += points[i].label * points[j].label * (oldAj - alphas[j]);

                        // Update bias
                        const b1 = bias - Ei -
                                  points[i].label * (alphas[i] - oldAi) * kernel(points[i], points[i]) -
                                  points[j].label * (alphas[j] - oldAj) * kernel(points[i], points[j]);
                        const b2 = bias - Ej -
                                  points[i].label * (alphas[i] - oldAi) * kernel(points[i], points[j]) -
                                  points[j].label * (alphas[j] - oldAj) * kernel(points[j], points[j]);

                        if (alphas[i] > 0 && alphas[i] < C) {
                            bias = b1;
                        } else if (alphas[j] > 0 && alphas[j] < C) {
                            bias = b2;
                        } else {
                            bias = (b1 + b2) / 2;
                        }

                        changed++;
                    }
                }
                if (changed === 0) break;
            }

            // Identify support vectors
            supportVectors = [];
            for (let i = 0; i < n; i++) {
                if (alphas[i] > 1e-5) {
                    supportVectors.push(i);
                }
            }

            // For linear kernel, compute weights
            if (document.getElementById('kernel-type').value === 'linear') {
                weights = { x: 0, y: 0 };
                for (let i = 0; i < n; i++) {
                    weights.x += alphas[i] * points[i].label * points[i].x;
                    weights.y += alphas[i] * points[i].label * points[i].y;
                }
            } else {
                weights = null;
            }

            updateStats();
            draw();
        }

        function predictRaw(point) {
            let sum = bias;
            for (let i = 0; i < points.length; i++) {
                sum += alphas[i] * points[i].label * kernel(points[i], point);
            }
            return sum;
        }

        function generateLinearData() {
            points = [];
            const angle = Math.random() * Math.PI;
            const offset = 0.1;

            for (let i = 0; i < 15; i++) {
                const x = 0.2 + Math.random() * 0.6;
                const y = 0.2 + Math.random() * 0.6;
                const side = (Math.cos(angle) * (x - 0.5) + Math.sin(angle) * (y - 0.5));
                if (Math.abs(side) > offset) {
                    points.push({ x, y, label: side > 0 ? 1 : -1 });
                }
            }
            trainSVM();
        }

        function generateCircleData() {
            points = [];
            const cx = 0.5, cy = 0.5, r = 0.2;

            for (let i = 0; i < 30; i++) {
                const x = 0.15 + Math.random() * 0.7;
                const y = 0.15 + Math.random() * 0.7;
                const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                const label = dist < r ? -1 : 1;
                points.push({ x, y, label });
            }
            trainSVM();
        }

        function generateXORData() {
            points = [];

            for (let i = 0; i < 8; i++) {
                points.push({ x: 0.15 + Math.random() * 0.25, y: 0.15 + Math.random() * 0.25, label: 1 });
                points.push({ x: 0.6 + Math.random() * 0.25, y: 0.6 + Math.random() * 0.25, label: 1 });
                points.push({ x: 0.15 + Math.random() * 0.25, y: 0.6 + Math.random() * 0.25, label: -1 });
                points.push({ x: 0.6 + Math.random() * 0.25, y: 0.15 + Math.random() * 0.25, label: -1 });
            }
            trainSVM();
        }

        function clearPoints() {
            points = [];
            weights = null;
            supportVectors = [];
            alphas = [];
            updateStats();
            draw();
        }

        function updateStats() {
            const classA = points.filter(p => p.label === -1).length;
            const classB = points.filter(p => p.label === 1).length;
            document.getElementById('class-a-count').textContent = classA;
            document.getElementById('class-b-count').textContent = classB;
            document.getElementById('sv-count').textContent = supportVectors.length;

            // Margin for linear kernel
            if (weights && (weights.x !== 0 || weights.y !== 0)) {
                const norm = Math.sqrt(weights.x ** 2 + weights.y ** 2);
                const margin = (2 / norm).toFixed(3);
                document.getElementById('margin-val').textContent = margin;
            } else {
                document.getElementById('margin-val').textContent = '-';
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw decision boundary heatmap
            if (alphas.some(a => a > 1e-5)) {
                const resolution = 4;
                for (let px = 0; px < canvas.width; px += resolution) {
                    for (let py = 0; py < canvas.height; py += resolution) {
                        const x = px / canvas.width;
                        const y = py / canvas.height;
                        const val = predictRaw({ x, y });

                        let color;
                        if (val > 0) {
                            const intensity = Math.min(1, Math.abs(val) * 0.5);
                            color = `rgba(52, 152, 219, ${intensity * 0.3})`;
                        } else {
                            const intensity = Math.min(1, Math.abs(val) * 0.5);
                            color = `rgba(231, 76, 60, ${intensity * 0.3})`;
                        }

                        ctx.fillStyle = color;
                        ctx.fillRect(px, py, resolution, resolution);
                    }
                }

                // Draw decision boundary contour
                ctx.strokeStyle = '#9b59b6';
                ctx.lineWidth = 3;
                ctx.beginPath();

                for (let px = 0; px < canvas.width; px += 2) {
                    for (let py = 0; py < canvas.height; py += 2) {
                        const x = px / canvas.width;
                        const y = py / canvas.height;
                        const val = predictRaw({ x, y });

                        if (Math.abs(val) < 0.1) {
                            ctx.fillStyle = '#9b59b6';
                            ctx.fillRect(px, py, 2, 2);
                        }
                    }
                }
                ctx.stroke();

                // Draw margin lines (for linear kernel)
                if (weights) {
                    ctx.strokeStyle = 'rgba(155, 89, 182, 0.4)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);

                    for (let px = 0; px < canvas.width; px += 2) {
                        for (let py = 0; py < canvas.height; py += 2) {
                            const x = px / canvas.width;
                            const y = py / canvas.height;
                            const val = predictRaw({ x, y });

                            if (Math.abs(val - 1) < 0.05 || Math.abs(val + 1) < 0.05) {
                                ctx.fillStyle = 'rgba(155, 89, 182, 0.3)';
                                ctx.fillRect(px, py, 2, 2);
                            }
                        }
                    }
                    ctx.setLineDash([]);
                }
            }

            // Draw points
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const px = p.x * canvas.width;
                const py = p.y * canvas.height;
                const isSV = supportVectors.includes(i);

                ctx.fillStyle = p.label === -1 ? '#e74c3c' : '#3498db';
                ctx.beginPath();
                ctx.arc(px, py, isSV ? 10 : 7, 0, Math.PI * 2);
                ctx.fill();

                if (isSV) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }
        }

        generateLinearData();
    </script>
</body>
</html>
