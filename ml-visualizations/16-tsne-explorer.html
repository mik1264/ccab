<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>t-SNE Embedding Explorer - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e8e6e1;
            min-height: 100vh;
            overflow: hidden;
        }
        .back-link {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            color: #ec4899;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            z-index: 999;
        }
        .back-link:hover { background: rgba(236, 72, 153, 0.2); }

        #canvas {
            display: block;
            width: 100vw;
            height: calc(100vh - 120px);
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
            z-index: 100;
        }
        .control-group { display: flex; align-items: center; gap: 8px; }
        label { font-size: 13px; color: #888; }
        input[type="range"] { width: 100px; accent-color: #ec4899; }
        select {
            padding: 6px 12px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            color: white;
        }
        button {
            padding: 8px 16px;
            background: linear-gradient(135deg, #ec4899, #db2777);
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            cursor: pointer;
        }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(236, 72, 153, 0.4); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        .info-panel {
            position: fixed;
            top: 60px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 10px;
            font-size: 13px;
            max-width: 280px;
            z-index: 100;
        }
        .info-panel h3 { color: #ec4899; margin-bottom: 10px; }
        .info-panel p { margin-bottom: 8px; color: #aaa; line-height: 1.5; }
        .formula { font-family: monospace; color: #ec4899; font-size: 12px; margin: 8px 0; }

        .stats-panel {
            position: fixed;
            top: 60px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 10px;
            font-size: 13px;
            z-index: 100;
        }
        .stats-panel h3 { color: #ec4899; margin-bottom: 10px; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; color: #aaa; gap: 20px; }
        .stat-value { color: white; font-weight: 600; }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ec4899, #f472b6);
            transition: width 0.1s;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to ML Visualizations</a>

    <canvas id="canvas"></canvas>

    <div class="info-panel">
        <h3>t-SNE Visualization</h3>
        <p>t-Distributed Stochastic Neighbor Embedding reduces high-dimensional data to 2D while preserving local structure.</p>
        <p class="formula">Cost = KL(P || Q)</p>
        <p>Key parameter: <strong>Perplexity</strong> controls the effective number of neighbors considered.</p>
        <p>Watch as the algorithm iteratively minimizes the KL divergence to separate clusters.</p>
    </div>

    <div class="stats-panel">
        <h3>Optimization</h3>
        <div class="stat-row">
            <span>Iteration:</span>
            <span class="stat-value" id="iteration">0</span>
        </div>
        <div class="stat-row">
            <span>KL Divergence:</span>
            <span class="stat-value" id="klDiv">-</span>
        </div>
        <div class="stat-row">
            <span>Points:</span>
            <span class="stat-value" id="pointCount">0</span>
        </div>
        <div class="stat-row">
            <span>Clusters:</span>
            <span class="stat-value" id="clusterCount">0</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress" style="width: 0%"></div>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Dataset:</label>
            <select id="dataset">
                <option value="clusters">Gaussian Clusters</option>
                <option value="spiral">Spirals</option>
                <option value="moons">Two Moons</option>
                <option value="swiss">Swiss Roll</option>
            </select>
        </div>
        <div class="control-group">
            <label>Points:</label>
            <input type="range" id="pointSlider" min="50" max="500" value="200">
            <span id="pointValue">200</span>
        </div>
        <div class="control-group">
            <label>Perplexity:</label>
            <input type="range" id="perplexity" min="5" max="50" value="30">
            <span id="perpValue">30</span>
        </div>
        <div class="control-group">
            <label>Learning Rate:</label>
            <input type="range" id="learningRate" min="10" max="500" value="200">
            <span id="lrValue">200</span>
        </div>
        <button id="runBtn" onclick="runTSNE()">Run t-SNE</button>
        <button onclick="resetData()">New Data</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        let points = [];
        let highDimData = [];
        let lowDimData = [];
        let labels = [];
        let numClusters = 0;
        let running = false;
        let iteration = 0;
        let maxIterations = 500;
        let perplexity = 30;
        let learningRate = 200;

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
        }
        resizeCanvas();
        window.addEventListener('resize', () => { resizeCanvas(); draw(); });

        // Generate synthetic high-dimensional data
        function generateData(type, numPoints) {
            highDimData = [];
            labels = [];
            const dim = 10; // High dimensional space

            if (type === 'clusters') {
                numClusters = 5;
                const centersHigh = [];
                for (let c = 0; c < numClusters; c++) {
                    const center = [];
                    for (let d = 0; d < dim; d++) {
                        center.push((Math.random() - 0.5) * 10);
                    }
                    centersHigh.push(center);
                }

                for (let i = 0; i < numPoints; i++) {
                    const cluster = Math.floor(Math.random() * numClusters);
                    labels.push(cluster);
                    const point = [];
                    for (let d = 0; d < dim; d++) {
                        point.push(centersHigh[cluster][d] + (Math.random() - 0.5) * 2);
                    }
                    highDimData.push(point);
                }
            } else if (type === 'spiral') {
                numClusters = 3;
                for (let i = 0; i < numPoints; i++) {
                    const cluster = i % numClusters;
                    labels.push(cluster);
                    const t = (i / numPoints) * 4 * Math.PI + cluster * 2 * Math.PI / numClusters;
                    const r = t / 4;
                    const point = [];
                    point.push(r * Math.cos(t) + (Math.random() - 0.5) * 0.3);
                    point.push(r * Math.sin(t) + (Math.random() - 0.5) * 0.3);
                    // Add noise dimensions
                    for (let d = 2; d < dim; d++) {
                        point.push((Math.random() - 0.5) * 0.5);
                    }
                    highDimData.push(point);
                }
            } else if (type === 'moons') {
                numClusters = 2;
                for (let i = 0; i < numPoints; i++) {
                    const cluster = i < numPoints / 2 ? 0 : 1;
                    labels.push(cluster);
                    const t = (i / (numPoints / 2)) * Math.PI;
                    const point = [];
                    if (cluster === 0) {
                        point.push(Math.cos(t) + (Math.random() - 0.5) * 0.2);
                        point.push(Math.sin(t) + (Math.random() - 0.5) * 0.2);
                    } else {
                        point.push(1 - Math.cos(t) + (Math.random() - 0.5) * 0.2);
                        point.push(0.5 - Math.sin(t) + (Math.random() - 0.5) * 0.2);
                    }
                    for (let d = 2; d < dim; d++) {
                        point.push((Math.random() - 0.5) * 0.3);
                    }
                    highDimData.push(point);
                }
            } else if (type === 'swiss') {
                numClusters = 1;
                for (let i = 0; i < numPoints; i++) {
                    labels.push(Math.floor((i / numPoints) * 5));
                    const t = 1.5 * Math.PI * (1 + 2 * i / numPoints);
                    const point = [];
                    point.push(t * Math.cos(t) / 10);
                    point.push((Math.random() - 0.5) * 2);
                    point.push(t * Math.sin(t) / 10);
                    for (let d = 3; d < dim; d++) {
                        point.push((Math.random() - 0.5) * 0.2);
                    }
                    highDimData.push(point);
                }
                numClusters = 5;
            }

            // Initialize low-dim positions randomly
            lowDimData = highDimData.map(() => [
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2
            ]);

            document.getElementById('pointCount').textContent = numPoints;
            document.getElementById('clusterCount').textContent = numClusters;
        }

        // Euclidean distance
        function dist(a, b) {
            let sum = 0;
            for (let i = 0; i < a.length; i++) {
                sum += (a[i] - b[i]) ** 2;
            }
            return Math.sqrt(sum);
        }

        // Compute pairwise affinities P (high-dim)
        function computeP(data, perp) {
            const n = data.length;
            const P = Array(n).fill().map(() => Array(n).fill(0));
            const beta = Array(n).fill(1);

            // Binary search for sigma
            for (let i = 0; i < n; i++) {
                const Di = [];
                for (let j = 0; j < n; j++) {
                    Di.push(dist(data[i], data[j]));
                }

                let lo = 0, hi = 1000;
                for (let iter = 0; iter < 50; iter++) {
                    beta[i] = (lo + hi) / 2;
                    let sum = 0;
                    for (let j = 0; j < n; j++) {
                        if (i !== j) {
                            P[i][j] = Math.exp(-Di[j] * Di[j] * beta[i]);
                            sum += P[i][j];
                        }
                    }
                    for (let j = 0; j < n; j++) {
                        P[i][j] /= sum;
                    }

                    // Compute entropy
                    let H = 0;
                    for (let j = 0; j < n; j++) {
                        if (P[i][j] > 1e-10) {
                            H -= P[i][j] * Math.log2(P[i][j]);
                        }
                    }

                    const perpCurrent = Math.pow(2, H);
                    if (perpCurrent > perp) {
                        lo = beta[i];
                    } else {
                        hi = beta[i];
                    }
                }
            }

            // Symmetrize
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const pij = (P[i][j] + P[j][i]) / (2 * n);
                    P[i][j] = P[j][i] = Math.max(pij, 1e-12);
                }
            }

            return P;
        }

        // Compute Q (low-dim student-t)
        function computeQ(Y) {
            const n = Y.length;
            const Q = Array(n).fill().map(() => Array(n).fill(0));
            let Zsum = 0;

            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const d = dist(Y[i], Y[j]);
                    const q = 1 / (1 + d * d);
                    Q[i][j] = Q[j][i] = q;
                    Zsum += 2 * q;
                }
            }

            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    Q[i][j] /= Zsum;
                    Q[i][j] = Math.max(Q[i][j], 1e-12);
                }
            }

            return { Q, Zsum };
        }

        // Compute KL divergence
        function computeKL(P, Q) {
            let kl = 0;
            const n = P.length;
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (i !== j && P[i][j] > 1e-12) {
                        kl += P[i][j] * Math.log(P[i][j] / Q[i][j]);
                    }
                }
            }
            return kl;
        }

        // t-SNE gradient step
        let P_global = null;

        function tsneStep() {
            const n = lowDimData.length;
            const { Q, Zsum } = computeQ(lowDimData);

            // Compute gradients
            const grad = lowDimData.map(() => [0, 0]);

            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (i !== j) {
                        const d = dist(lowDimData[i], lowDimData[j]);
                        const qij = 1 / (1 + d * d);
                        const mult = 4 * (P_global[i][j] - Q[i][j]) * qij;

                        grad[i][0] += mult * (lowDimData[i][0] - lowDimData[j][0]);
                        grad[i][1] += mult * (lowDimData[i][1] - lowDimData[j][1]);
                    }
                }
            }

            // Update positions
            const lr = learningRate;
            for (let i = 0; i < n; i++) {
                lowDimData[i][0] -= lr * grad[i][0];
                lowDimData[i][1] -= lr * grad[i][1];
            }

            return computeKL(P_global, Q);
        }

        // Animation loop
        function runTSNE() {
            if (running) return;

            running = true;
            iteration = 0;
            document.getElementById('runBtn').disabled = true;

            // Compute P matrix once
            P_global = computeP(highDimData, perplexity);

            function step() {
                if (!running || iteration >= maxIterations) {
                    running = false;
                    document.getElementById('runBtn').disabled = false;
                    return;
                }

                const kl = tsneStep();
                iteration++;

                document.getElementById('iteration').textContent = iteration;
                document.getElementById('klDiv').textContent = kl.toFixed(4);
                document.getElementById('progress').style.width = (iteration / maxIterations * 100) + '%';

                draw();
                requestAnimationFrame(step);
            }

            step();
        }

        // Colors for clusters
        const clusterColors = [
            '#ec4899', '#8b5cf6', '#22d3ee', '#22c55e', '#f59e0b',
            '#ef4444', '#3b82f6', '#14b8a6', '#f97316', '#a855f7'
        ];

        // Draw visualization
        function draw() {
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);

            if (lowDimData.length === 0) return;

            // Find bounds
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            for (const p of lowDimData) {
                minX = Math.min(minX, p[0]);
                maxX = Math.max(maxX, p[0]);
                minY = Math.min(minY, p[1]);
                maxY = Math.max(maxY, p[1]);
            }

            const padding = 80;
            const scaleX = (width - 2 * padding) / (maxX - minX || 1);
            const scaleY = (height - 2 * padding) / (maxY - minY || 1);
            const scale = Math.min(scaleX, scaleY);

            const offsetX = (width - (maxX - minX) * scale) / 2;
            const offsetY = (height - (maxY - minY) * scale) / 2;

            // Draw points
            for (let i = 0; i < lowDimData.length; i++) {
                const x = offsetX + (lowDimData[i][0] - minX) * scale;
                const y = offsetY + (lowDimData[i][1] - minY) * scale;

                const color = clusterColors[labels[i] % clusterColors.length];

                ctx.beginPath();
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.8;
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            // Draw legend
            ctx.font = '12px Arial';
            for (let c = 0; c < numClusters; c++) {
                const y = 30 + c * 20;
                ctx.fillStyle = clusterColors[c % clusterColors.length];
                ctx.fillRect(width - 100, y, 12, 12);
                ctx.fillStyle = '#888';
                ctx.fillText(`Cluster ${c + 1}`, width - 80, y + 10);
            }
        }

        function resetData() {
            running = false;
            iteration = 0;
            const type = document.getElementById('dataset').value;
            const numPoints = parseInt(document.getElementById('pointSlider').value);
            generateData(type, numPoints);
            document.getElementById('iteration').textContent = '0';
            document.getElementById('klDiv').textContent = '-';
            document.getElementById('progress').style.width = '0%';
            document.getElementById('runBtn').disabled = false;
            draw();
        }

        // Event listeners
        document.getElementById('pointSlider').addEventListener('input', (e) => {
            document.getElementById('pointValue').textContent = e.target.value;
        });
        document.getElementById('perplexity').addEventListener('input', (e) => {
            perplexity = parseInt(e.target.value);
            document.getElementById('perpValue').textContent = e.target.value;
        });
        document.getElementById('learningRate').addEventListener('input', (e) => {
            learningRate = parseInt(e.target.value);
            document.getElementById('lrValue').textContent = e.target.value;
        });
        document.getElementById('dataset').addEventListener('change', resetData);
        document.getElementById('pointSlider').addEventListener('change', resetData);

        // Initialize
        resetData();
    </script>
</body>
</html>
