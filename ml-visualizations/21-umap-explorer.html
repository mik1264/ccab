<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UMAP Graph + Embedding Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #c9a227;
            text-decoration: none;
            font-size: 14px;
            opacity: 0.8;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .back-link:hover {
            opacity: 1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 60px 20px 20px;
        }

        h1 {
            text-align: center;
            font-size: 2rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #c9a227, #e0c068);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
            font-size: 0.95rem;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 1fr 280px;
            gap: 20px;
        }

        .panel {
            background: rgba(20, 20, 35, 0.8);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(201, 162, 39, 0.2);
        }

        .panel-title {
            font-size: 0.95rem;
            color: #c9a227;
            margin-bottom: 15px;
        }

        .controls-panel {
            height: fit-content;
        }

        .section-title {
            font-size: 0.85rem;
            color: #c9a227;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #c9a227, #b8941f);
            color: #0a0a0f;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(201, 162, 39, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        canvas {
            width: 100%;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
        }

        .info-box {
            background: rgba(201, 162, 39, 0.1);
            border: 1px solid rgba(201, 162, 39, 0.3);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.8rem;
            color: #ccc;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .slider-group {
            margin-bottom: 15px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.8rem;
        }

        .slider-label span:first-child {
            color: #aaa;
        }

        .slider-label span:last-child {
            color: #c9a227;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #c9a227;
            cursor: pointer;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #c9a227;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
        }

        .step-info {
            background: rgba(52, 152, 219, 0.1);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.8rem;
            color: #3498db;
            margin-bottom: 15px;
            min-height: 50px;
        }

        select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 0.85rem;
            margin-bottom: 15px;
        }

        select option {
            background: #1a1a2e;
        }

        @media (max-width: 1100px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>

    <div class="container">
        <h1>UMAP Graph + Embedding Explorer</h1>
        <p class="subtitle">Uniform Manifold Approximation and Projection: k-NN graph to fuzzy simplicial set</p>

        <div class="main-layout">
            <div class="panel">
                <div class="panel-title">k-NN Graph (High-Dimensional)</div>
                <canvas id="knnCanvas"></canvas>
            </div>

            <div class="panel">
                <div class="panel-title">UMAP Embedding (2D)</div>
                <canvas id="embeddingCanvas"></canvas>
            </div>

            <div class="panel controls-panel">
                <div class="info-box">
                    <strong>UMAP</strong><br>
                    Builds a fuzzy simplicial set from k-NN graph, then optimizes a low-dimensional embedding to preserve topological structure via cross-entropy minimization.
                </div>

                <div class="section-title">Dataset</div>
                <select id="datasetSelect" onchange="generateData()">
                    <option value="clusters">3 Gaussian Clusters</option>
                    <option value="moons">Two Moons</option>
                    <option value="circles">Concentric Circles</option>
                    <option value="swiss">Swiss Roll (projected)</option>
                </select>

                <div class="section-title">Parameters</div>
                <div class="slider-group">
                    <div class="slider-label">
                        <span>n_neighbors (k)</span>
                        <span id="kValue">15</span>
                    </div>
                    <input type="range" id="kSlider" min="5" max="50" value="15" onchange="updateK()">
                </div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>min_dist</span>
                        <span id="minDistValue">0.1</span>
                    </div>
                    <input type="range" id="minDistSlider" min="0" max="100" value="10" onchange="updateMinDist()">
                </div>

                <div class="section-title">Controls</div>
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="buildKNN()">Build k-NN Graph</button>
                    <button class="btn btn-secondary" onclick="computeFuzzySet()">Compute Fuzzy Set</button>
                    <button class="btn btn-secondary" onclick="startOptimization()">Optimize Embedding</button>
                    <button class="btn btn-secondary" onclick="resetAll()">Reset</button>
                </div>

                <div class="step-info" id="stepInfo">
                    Generate data and build k-NN graph to start
                </div>

                <div class="section-title">Statistics</div>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-value" id="numPoints">0</div>
                        <div class="stat-label">Points</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="numEdges">0</div>
                        <div class="stat-label">Edges</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="iteration">0</div>
                        <div class="stat-label">Iteration</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="loss">0</div>
                        <div class="stat-label">Loss</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const knnCanvas = document.getElementById('knnCanvas');
        const embeddingCanvas = document.getElementById('embeddingCanvas');
        const kctx = knnCanvas.getContext('2d');
        const ectx = embeddingCanvas.getContext('2d');

        let state = {
            data: [],           // Original high-dimensional data
            labels: [],         // Class labels for coloring
            k: 15,
            minDist: 0.1,
            knnGraph: [],       // k-NN adjacency
            fuzzyWeights: [],   // Fuzzy simplicial set edge weights
            embedding: [],      // Low-dimensional positions
            sigmas: [],         // Local scaling factors
            rhos: [],           // Distance to nearest neighbor
            optimizing: false,
            iteration: 0
        };

        const colors = ['#e74c3c', '#3498db', '#27ae60', '#f39c12', '#9b59b6'];

        function resizeCanvases() {
            [knnCanvas, embeddingCanvas].forEach(canvas => {
                const rect = canvas.parentElement.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                canvas.width = (rect.width - 40) * dpr;
                canvas.height = 400 * dpr;
                canvas.style.height = '400px';
                canvas.getContext('2d').scale(dpr, dpr);
            });
        }
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        function generateData() {
            const type = document.getElementById('datasetSelect').value;
            state.data = [];
            state.labels = [];
            state.knnGraph = [];
            state.fuzzyWeights = [];
            state.embedding = [];
            state.iteration = 0;
            state.optimizing = false;

            switch (type) {
                case 'clusters':
                    generateClusters();
                    break;
                case 'moons':
                    generateMoons();
                    break;
                case 'circles':
                    generateCircles();
                    break;
                case 'swiss':
                    generateSwissRoll();
                    break;
            }

            // Initialize embedding randomly
            state.embedding = state.data.map(() => ({
                x: Math.random() * 2 - 1,
                y: Math.random() * 2 - 1
            }));

            updateStats();
            draw();
            document.getElementById('stepInfo').textContent = 'Data generated. Click "Build k-NN Graph" to continue.';
        }

        function generateClusters() {
            const centers = [[0, 0], [3, 3], [-2, 3]];
            const n = 50;

            centers.forEach((center, clusterIdx) => {
                for (let i = 0; i < n; i++) {
                    state.data.push({
                        x: center[0] + randn() * 0.8,
                        y: center[1] + randn() * 0.8
                    });
                    state.labels.push(clusterIdx);
                }
            });
        }

        function generateMoons() {
            const n = 75;
            for (let i = 0; i < n; i++) {
                const angle = Math.PI * i / n;
                state.data.push({
                    x: Math.cos(angle) + randn() * 0.1,
                    y: Math.sin(angle) + randn() * 0.1
                });
                state.labels.push(0);
            }
            for (let i = 0; i < n; i++) {
                const angle = Math.PI * i / n;
                state.data.push({
                    x: 1 - Math.cos(angle) + randn() * 0.1,
                    y: 0.5 - Math.sin(angle) + randn() * 0.1
                });
                state.labels.push(1);
            }
        }

        function generateCircles() {
            const n = 60;
            for (let i = 0; i < n; i++) {
                const angle = 2 * Math.PI * i / n;
                state.data.push({
                    x: Math.cos(angle) + randn() * 0.05,
                    y: Math.sin(angle) + randn() * 0.05
                });
                state.labels.push(0);
            }
            for (let i = 0; i < n; i++) {
                const angle = 2 * Math.PI * i / n;
                state.data.push({
                    x: 2.5 * Math.cos(angle) + randn() * 0.1,
                    y: 2.5 * Math.sin(angle) + randn() * 0.1
                });
                state.labels.push(1);
            }
        }

        function generateSwissRoll() {
            const n = 150;
            for (let i = 0; i < n; i++) {
                const t = 1.5 * Math.PI * (1 + 2 * i / n);
                state.data.push({
                    x: t * Math.cos(t) / 5 + randn() * 0.1,
                    y: t * Math.sin(t) / 5 + randn() * 0.1
                });
                state.labels.push(Math.floor(i / (n / 3)));
            }
        }

        function randn() {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        function distance(a, b) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function buildKNN() {
            if (state.data.length === 0) {
                generateData();
            }

            state.knnGraph = [];
            state.rhos = [];
            state.sigmas = [];

            // For each point, find k nearest neighbors
            state.data.forEach((point, i) => {
                const distances = [];
                state.data.forEach((other, j) => {
                    if (i !== j) {
                        distances.push({ idx: j, dist: distance(point, other) });
                    }
                });

                distances.sort((a, b) => a.dist - b.dist);
                const neighbors = distances.slice(0, state.k);
                state.knnGraph.push(neighbors);

                // rho = distance to nearest neighbor
                state.rhos.push(neighbors[0].dist);
            });

            // Compute sigmas (local scaling) via binary search
            computeSigmas();

            updateStats();
            draw();
            document.getElementById('stepInfo').textContent =
                `Built k-NN graph with k=${state.k}. Click "Compute Fuzzy Set" to compute edge weights.`;
        }

        function computeSigmas() {
            const target = Math.log2(state.k);

            state.data.forEach((point, i) => {
                let lo = 0, hi = 1000, mid;

                for (let iter = 0; iter < 64; iter++) {
                    mid = (lo + hi) / 2;
                    let sum = 0;

                    state.knnGraph[i].forEach(neighbor => {
                        const d = Math.max(0, neighbor.dist - state.rhos[i]);
                        sum += Math.exp(-d / mid);
                    });

                    if (Math.abs(sum - Math.pow(2, target)) < 1e-5) break;
                    if (sum > Math.pow(2, target)) lo = mid;
                    else hi = mid;
                }

                state.sigmas.push(mid);
            });
        }

        function computeFuzzySet() {
            if (state.knnGraph.length === 0) {
                buildKNN();
            }

            // Compute membership strengths
            state.fuzzyWeights = new Map();

            state.data.forEach((point, i) => {
                state.knnGraph[i].forEach(neighbor => {
                    const d = Math.max(0, neighbor.dist - state.rhos[i]);
                    const strength = Math.exp(-d / state.sigmas[i]);

                    const key = i < neighbor.idx ? `${i}-${neighbor.idx}` : `${neighbor.idx}-${i}`;
                    const existing = state.fuzzyWeights.get(key) || { a: 0, b: 0, from: Math.min(i, neighbor.idx), to: Math.max(i, neighbor.idx) };

                    if (i < neighbor.idx) existing.a = strength;
                    else existing.b = strength;

                    state.fuzzyWeights.set(key, existing);
                });
            });

            // Fuzzy union: a + b - a*b
            state.fuzzyWeights.forEach((value, key) => {
                value.weight = value.a + value.b - value.a * value.b;
            });

            updateStats();
            draw();
            document.getElementById('stepInfo').textContent =
                'Computed fuzzy simplicial set. Click "Optimize Embedding" to start gradient descent.';
        }

        function startOptimization() {
            if (state.fuzzyWeights.size === 0) {
                computeFuzzySet();
            }

            state.optimizing = true;
            state.iteration = 0;
            optimize();
        }

        function optimize() {
            if (!state.optimizing) return;

            const learningRate = 1.0 / (1 + state.iteration * 0.01);
            const a = 1.0;
            const b = 1.0;

            // Compute gradients
            const gradients = state.embedding.map(() => ({ x: 0, y: 0 }));

            // Attractive forces (edges in fuzzy set)
            state.fuzzyWeights.forEach((edge) => {
                const i = edge.from;
                const j = edge.to;
                const w = edge.weight;

                const dx = state.embedding[j].x - state.embedding[i].x;
                const dy = state.embedding[j].y - state.embedding[i].y;
                const dist = Math.sqrt(dx * dx + dy * dy + 1e-4);

                // Attractive gradient
                const grad = -2 * a * b * Math.pow(dist, b - 1) /
                    (1 + a * Math.pow(dist, b));

                gradients[i].x += w * grad * dx / dist;
                gradients[i].y += w * grad * dy / dist;
                gradients[j].x -= w * grad * dx / dist;
                gradients[j].y -= w * grad * dy / dist;
            });

            // Repulsive forces (negative sampling)
            for (let iter = 0; iter < 5; iter++) {
                for (let i = 0; i < state.embedding.length; i++) {
                    const j = Math.floor(Math.random() * state.embedding.length);
                    if (i === j) continue;

                    const dx = state.embedding[j].x - state.embedding[i].x;
                    const dy = state.embedding[j].y - state.embedding[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy + 1e-4);

                    // Repulsive gradient
                    const grad = 2 * b / ((0.001 + dist) * (1 + a * Math.pow(dist, b)));

                    gradients[i].x -= grad * dx / dist * 0.1;
                    gradients[i].y -= grad * dy / dist * 0.1;
                }
            }

            // Update positions
            state.embedding.forEach((pos, i) => {
                pos.x += learningRate * gradients[i].x;
                pos.y += learningRate * gradients[i].y;

                // Clip to prevent explosion
                pos.x = Math.max(-10, Math.min(10, pos.x));
                pos.y = Math.max(-10, Math.min(10, pos.y));
            });

            state.iteration++;
            updateStats();
            draw();

            if (state.iteration < 200 && state.optimizing) {
                requestAnimationFrame(optimize);
            } else {
                state.optimizing = false;
                document.getElementById('stepInfo').textContent =
                    'Optimization complete! Embedding preserves topological structure.';
            }
        }

        function updateK() {
            state.k = parseInt(document.getElementById('kSlider').value);
            document.getElementById('kValue').textContent = state.k;
        }

        function updateMinDist() {
            state.minDist = document.getElementById('minDistSlider').value / 100;
            document.getElementById('minDistValue').textContent = state.minDist.toFixed(2);
        }

        function resetAll() {
            state.optimizing = false;
            generateData();
        }

        function updateStats() {
            document.getElementById('numPoints').textContent = state.data.length;
            document.getElementById('numEdges').textContent = state.fuzzyWeights.size || state.knnGraph.reduce((sum, n) => sum + n.length, 0);
            document.getElementById('iteration').textContent = state.iteration;

            // Approximate loss
            let loss = 0;
            state.fuzzyWeights.forEach(edge => {
                const dx = state.embedding[edge.from].x - state.embedding[edge.to].x;
                const dy = state.embedding[edge.from].y - state.embedding[edge.to].y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                loss += edge.weight * Math.log(1 + dist);
            });
            document.getElementById('loss').textContent = loss.toFixed(1);
        }

        function draw() {
            drawKNN();
            drawEmbedding();
        }

        function drawKNN() {
            const width = knnCanvas.width / (window.devicePixelRatio || 1);
            const height = knnCanvas.height / (window.devicePixelRatio || 1);

            kctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            kctx.fillRect(0, 0, width, height);

            if (state.data.length === 0) return;

            // Find bounds
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            state.data.forEach(p => {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            });

            const padding = 30;
            const scaleX = (width - 2 * padding) / (maxX - minX || 1);
            const scaleY = (height - 2 * padding) / (maxY - minY || 1);
            const scale = Math.min(scaleX, scaleY);

            const toScreen = p => ({
                x: padding + (p.x - minX) * scale + (width - 2 * padding - (maxX - minX) * scale) / 2,
                y: padding + (p.y - minY) * scale + (height - 2 * padding - (maxY - minY) * scale) / 2
            });

            // Draw edges
            if (state.fuzzyWeights.size > 0) {
                state.fuzzyWeights.forEach(edge => {
                    const from = toScreen(state.data[edge.from]);
                    const to = toScreen(state.data[edge.to]);

                    kctx.beginPath();
                    kctx.moveTo(from.x, from.y);
                    kctx.lineTo(to.x, to.y);
                    kctx.strokeStyle = `rgba(201, 162, 39, ${edge.weight * 0.5})`;
                    kctx.lineWidth = edge.weight * 2;
                    kctx.stroke();
                });
            } else if (state.knnGraph.length > 0) {
                state.knnGraph.forEach((neighbors, i) => {
                    const from = toScreen(state.data[i]);
                    neighbors.forEach(n => {
                        const to = toScreen(state.data[n.idx]);
                        kctx.beginPath();
                        kctx.moveTo(from.x, from.y);
                        kctx.lineTo(to.x, to.y);
                        kctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
                        kctx.lineWidth = 1;
                        kctx.stroke();
                    });
                });
            }

            // Draw points
            state.data.forEach((p, i) => {
                const pos = toScreen(p);
                kctx.beginPath();
                kctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
                kctx.fillStyle = colors[state.labels[i] % colors.length];
                kctx.fill();
            });

            // Label
            kctx.font = '12px Segoe UI';
            kctx.fillStyle = '#888';
            kctx.textAlign = 'center';
            kctx.fillText('Original Space + k-NN Graph', width / 2, height - 10);
        }

        function drawEmbedding() {
            const width = embeddingCanvas.width / (window.devicePixelRatio || 1);
            const height = embeddingCanvas.height / (window.devicePixelRatio || 1);

            ectx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ectx.fillRect(0, 0, width, height);

            if (state.embedding.length === 0) return;

            // Find bounds
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            state.embedding.forEach(p => {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            });

            const padding = 30;
            const scaleX = (width - 2 * padding) / (maxX - minX || 1);
            const scaleY = (height - 2 * padding) / (maxY - minY || 1);
            const scale = Math.min(scaleX, scaleY);

            const toScreen = p => ({
                x: padding + (p.x - minX) * scale + (width - 2 * padding - (maxX - minX) * scale) / 2,
                y: padding + (p.y - minY) * scale + (height - 2 * padding - (maxY - minY) * scale) / 2
            });

            // Draw fuzzy edges in embedding
            if (state.fuzzyWeights.size > 0) {
                state.fuzzyWeights.forEach(edge => {
                    const from = toScreen(state.embedding[edge.from]);
                    const to = toScreen(state.embedding[edge.to]);

                    ectx.beginPath();
                    ectx.moveTo(from.x, from.y);
                    ectx.lineTo(to.x, to.y);
                    ectx.strokeStyle = `rgba(201, 162, 39, ${edge.weight * 0.3})`;
                    ectx.lineWidth = 1;
                    ectx.stroke();
                });
            }

            // Draw points
            state.embedding.forEach((p, i) => {
                const pos = toScreen(p);
                ectx.beginPath();
                ectx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
                ectx.fillStyle = colors[state.labels[i] % colors.length];
                ectx.fill();
            });

            // Label
            ectx.font = '12px Segoe UI';
            ectx.fillStyle = '#888';
            ectx.textAlign = 'center';
            ectx.fillText('UMAP 2D Embedding', width / 2, height - 10);
        }

        // Initialize
        generateData();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
