<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RealNVP Normalizing Flow - CCAB</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }
        .back-link {
            position: fixed; top: 20px; left: 20px;
            color: #c9a227; text-decoration: none; font-weight: 500;
            z-index: 1000; transition: all 0.3s ease;
        }
        .back-link:hover { color: #ffd700; transform: translateX(-4px); }
        .container { max-width: 1600px; margin: 0 auto; padding: 60px 20px 20px; }
        h1 { text-align: center; color: #c9a227; margin-bottom: 0.5rem; font-size: 2rem; }
        .subtitle { text-align: center; color: #888; margin-bottom: 1.5rem; }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }

        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .canvas-container {
            background: rgba(20, 20, 35, 0.9);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(201, 162, 39, 0.3);
        }

        .canvas-container h3 {
            color: #c9a227;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        canvas {
            width: 100%;
            background: #0a0a15;
            border-radius: 8px;
        }

        .flow-stages {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
        }

        .flow-stages canvas {
            aspect-ratio: 1;
        }

        .stage-label {
            text-align: center;
            color: #888;
            font-size: 0.75rem;
            margin-top: 5px;
        }

        .controls {
            background: rgba(20, 20, 35, 0.9);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(201, 162, 39, 0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: #c9a227;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(201, 162, 39, 0.3);
            color: #e0e0e0;
            border-radius: 6px;
        }

        .control-group .value {
            color: #888;
            font-size: 0.85rem;
        }

        .btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #c9a227, #d4af37);
            color: #0a0a0f;
        }

        .btn-secondary {
            background: rgba(201, 162, 39, 0.2);
            color: #c9a227;
            border: 1px solid rgba(201, 162, 39, 0.4);
        }

        .btn:hover { transform: translateY(-2px); }

        .info-panel {
            background: rgba(30, 30, 50, 0.8);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .info-panel h4 {
            color: #c9a227;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 0.85rem;
        }

        .info-row:last-child { border-bottom: none; }
        .info-row .label { color: #888; }
        .info-row .value { color: #4ade80; font-family: monospace; }

        .equation {
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.8rem;
            margin-top: 10px;
            line-height: 1.6;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
            font-size: 0.85rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to ML Visualizations</a>

    <div class="container">
        <h1>RealNVP Normalizing Flow</h1>
        <p class="subtitle">Affine Coupling Layers Transform Gaussian → Complex Distribution</p>

        <div class="main-content">
            <div class="visualization-area">
                <div class="canvas-container">
                    <h3>Flow Transformation: z ~ N(0,I) → x ~ Target</h3>
                    <div class="flow-stages">
                        <div>
                            <canvas id="stage0" width="180" height="180"></canvas>
                            <div class="stage-label">z ~ N(0,I)</div>
                        </div>
                        <div>
                            <canvas id="stage1" width="180" height="180"></canvas>
                            <div class="stage-label">Layer 1</div>
                        </div>
                        <div>
                            <canvas id="stage2" width="180" height="180"></canvas>
                            <div class="stage-label">Layer 2</div>
                        </div>
                        <div>
                            <canvas id="stage3" width="180" height="180"></canvas>
                            <div class="stage-label">Layer 3</div>
                        </div>
                        <div>
                            <canvas id="stage4" width="180" height="180"></canvas>
                            <div class="stage-label">Layer 4 (Final)</div>
                        </div>
                    </div>
                </div>

                <div class="canvas-container">
                    <h3>Jacobian Log-Determinant per Layer</h3>
                    <canvas id="jacobianCanvas" width="900" height="150"></canvas>
                </div>

                <div class="canvas-container">
                    <h3>Inverse Flow: x → z (Sampling Backward)</h3>
                    <canvas id="inverseCanvas" width="900" height="200"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #f87171;"></div>
                            <span>Target Distribution</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4ade80;"></div>
                            <span>Transformed Samples</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #60a5fa;"></div>
                            <span>Base Gaussian</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Target Distribution</label>
                    <select id="targetDist">
                        <option value="moons">Two Moons</option>
                        <option value="rings">Concentric Rings</option>
                        <option value="checkerboard">Checkerboard</option>
                        <option value="spiral">Spiral</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Number of Coupling Layers</label>
                    <input type="range" id="numLayers" min="2" max="8" value="4">
                    <div class="value"><span id="numLayersValue">4</span> layers</div>
                </div>

                <div class="control-group">
                    <label>Scale Network Strength</label>
                    <input type="range" id="scaleStrength" min="0.1" max="2" step="0.1" value="1">
                    <div class="value">s = <span id="scaleStrengthValue">1.0</span></div>
                </div>

                <div class="control-group">
                    <label>Shift Network Strength</label>
                    <input type="range" id="shiftStrength" min="0.1" max="2" step="0.1" value="1">
                    <div class="value">t = <span id="shiftStrengthValue">1.0</span></div>
                </div>

                <div class="control-group">
                    <label>Animation Progress</label>
                    <input type="range" id="progress" min="0" max="100" value="100">
                    <div class="value"><span id="progressValue">100</span>%</div>
                </div>

                <button class="btn btn-primary" id="animateBtn">Animate Flow</button>
                <button class="btn btn-secondary" id="sampleBtn">Resample Points</button>
                <button class="btn btn-secondary" id="invertBtn">Show Inverse</button>

                <div class="info-panel">
                    <h4>Coupling Layer</h4>
                    <div class="equation">
                        y₁ = x₁<br>
                        y₂ = x₂ ⊙ exp(s(x₁)) + t(x₁)<br><br>
                        <span style="color: #4ade80;">Invertible!</span><br>
                        x₂ = (y₂ - t(x₁)) ⊙ exp(-s(x₁))
                    </div>
                </div>

                <div class="info-panel">
                    <h4>Jacobian</h4>
                    <div class="equation">
                        J = [I, 0; ∂y₂/∂x₁, diag(exp(s))]<br><br>
                        log|det(J)| = Σᵢ s(x₁)ᵢ<br><br>
                        <span style="color: #888;">Triangular → Easy determinant!</span>
                    </div>
                </div>

                <div class="info-panel">
                    <h4>Metrics</h4>
                    <div class="info-row">
                        <span class="label">Total log|det J|:</span>
                        <span class="value" id="metricLogDet">-</span>
                    </div>
                    <div class="info-row">
                        <span class="label">Base log-prob:</span>
                        <span class="value" id="metricBaseProb">-</span>
                    </div>
                    <div class="info-row">
                        <span class="label">Final log-prob:</span>
                        <span class="value" id="metricFinalProb">-</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas contexts
        const stageCanvases = [0, 1, 2, 3, 4].map(i => document.getElementById('stage' + i));
        const stageCtxs = stageCanvases.map(c => c.getContext('2d'));
        const jacobianCanvas = document.getElementById('jacobianCanvas');
        const jacobianCtx = jacobianCanvas.getContext('2d');
        const inverseCanvas = document.getElementById('inverseCanvas');
        const inverseCtx = inverseCanvas.getContext('2d');

        // State
        let state = {
            numLayers: 4,
            scaleStrength: 1,
            shiftStrength: 1,
            progress: 1,
            targetDist: 'moons',
            samples: [],
            layerOutputs: [],
            jacobians: [],
            animating: false
        };

        // Generate samples from base distribution (standard normal)
        function generateBaseSamples(n = 500) {
            const samples = [];
            for (let i = 0; i < n; i++) {
                // Box-Muller
                const u1 = Math.random();
                const u2 = Math.random();
                const r = Math.sqrt(-2 * Math.log(u1));
                const theta = 2 * Math.PI * u2;
                samples.push([r * Math.cos(theta), r * Math.sin(theta)]);
            }
            return samples;
        }

        // Target distributions for visualization
        function getTargetSamples(type, n = 500) {
            const samples = [];
            switch (type) {
                case 'moons':
                    for (let i = 0; i < n; i++) {
                        const moon = Math.random() > 0.5 ? 0 : 1;
                        const theta = Math.PI * Math.random();
                        const noise = 0.1;
                        if (moon === 0) {
                            samples.push([
                                Math.cos(theta) + (Math.random() - 0.5) * noise,
                                Math.sin(theta) + (Math.random() - 0.5) * noise
                            ]);
                        } else {
                            samples.push([
                                1 - Math.cos(theta) + (Math.random() - 0.5) * noise,
                                0.5 - Math.sin(theta) + (Math.random() - 0.5) * noise
                            ]);
                        }
                    }
                    break;

                case 'rings':
                    for (let i = 0; i < n; i++) {
                        const ring = Math.random() > 0.5 ? 0.5 : 1.5;
                        const theta = 2 * Math.PI * Math.random();
                        const noise = 0.1;
                        samples.push([
                            ring * Math.cos(theta) + (Math.random() - 0.5) * noise,
                            ring * Math.sin(theta) + (Math.random() - 0.5) * noise
                        ]);
                    }
                    break;

                case 'checkerboard':
                    for (let i = 0; i < n; i++) {
                        let x, y;
                        do {
                            x = Math.random() * 4 - 2;
                            y = Math.random() * 4 - 2;
                        } while ((Math.floor(x + 2) + Math.floor(y + 2)) % 2 === 0);
                        samples.push([x, y]);
                    }
                    break;

                case 'spiral':
                    for (let i = 0; i < n; i++) {
                        const arm = Math.random() > 0.5 ? 0 : 1;
                        const t = 3 * Math.random();
                        const noise = 0.1;
                        const r = 0.3 + 0.5 * t;
                        const theta = t * 2 * Math.PI + arm * Math.PI;
                        samples.push([
                            r * Math.cos(theta) + (Math.random() - 0.5) * noise,
                            r * Math.sin(theta) + (Math.random() - 0.5) * noise
                        ]);
                    }
                    break;
            }
            return samples;
        }

        // Coupling layer networks (simplified - use polynomials)
        function scaleNetwork(x, layer, strength) {
            // Simple polynomial scale function
            const angle = layer * Math.PI / 4;
            const rotX = x * Math.cos(angle);
            return strength * 0.5 * Math.tanh(rotX * 2);
        }

        function shiftNetwork(x, layer, strength) {
            // Simple polynomial shift function
            const angle = layer * Math.PI / 4;
            const rotX = x * Math.cos(angle) - Math.sin(angle);
            return strength * 0.8 * Math.sin(rotX * Math.PI);
        }

        // Apply coupling layer
        function applyCouplingLayer(samples, layer, forward = true) {
            const { scaleStrength, shiftStrength } = state;
            const outputs = [];
            const logDets = [];

            // Alternate which dimension is transformed
            const transformSecond = layer % 2 === 0;

            for (const [x1, x2] of samples) {
                let y1, y2, logDet;

                if (transformSecond) {
                    // Transform x2 based on x1
                    const s = scaleNetwork(x1, layer, scaleStrength);
                    const t = shiftNetwork(x1, layer, shiftStrength);

                    if (forward) {
                        y1 = x1;
                        y2 = x2 * Math.exp(s) + t;
                        logDet = s;
                    } else {
                        y1 = x1;
                        y2 = (x2 - t) * Math.exp(-s);
                        logDet = -s;
                    }
                } else {
                    // Transform x1 based on x2
                    const s = scaleNetwork(x2, layer, scaleStrength);
                    const t = shiftNetwork(x2, layer, shiftStrength);

                    if (forward) {
                        y1 = x1 * Math.exp(s) + t;
                        y2 = x2;
                        logDet = s;
                    } else {
                        y1 = (x1 - t) * Math.exp(-s);
                        y2 = x2;
                        logDet = -s;
                    }
                }

                outputs.push([y1, y2]);
                logDets.push(logDet);
            }

            return { outputs, logDets };
        }

        // Run full flow
        function runFlow() {
            state.samples = generateBaseSamples(500);
            state.layerOutputs = [state.samples];
            state.jacobians = [];

            let current = state.samples;

            for (let l = 0; l < state.numLayers; l++) {
                const { outputs, logDets } = applyCouplingLayer(current, l, true);
                state.layerOutputs.push(outputs);
                state.jacobians.push(logDets.reduce((a, b) => a + b, 0) / logDets.length);
                current = outputs;
            }

            updateDisplay();
        }

        function updateDisplay() {
            drawStages();
            drawJacobian();
            drawInverse();
            updateMetrics();
        }

        function drawStages() {
            const progress = state.progress;

            for (let i = 0; i < 5; i++) {
                const canvas = stageCanvases[i];
                const ctx = stageCtxs[i];
                const W = canvas.width;
                const H = canvas.height;

                ctx.fillStyle = '#0a0a15';
                ctx.fillRect(0, 0, W, H);

                // Determine which layer output to show
                const layerIdx = Math.min(i, state.layerOutputs.length - 1);
                if (layerIdx < 0 || !state.layerOutputs[layerIdx]) continue;

                const samples = state.layerOutputs[layerIdx];

                // Scale
                const scale = 40;
                const cx = W / 2;
                const cy = H / 2;

                // Draw samples
                ctx.fillStyle = i === 0 ? 'rgba(96, 165, 250, 0.6)' :
                               i === state.numLayers ? 'rgba(74, 222, 128, 0.6)' :
                               'rgba(201, 162, 39, 0.5)';

                for (const [x, y] of samples) {
                    const px = cx + x * scale;
                    const py = cy - y * scale;
                    ctx.beginPath();
                    ctx.arc(px, py, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw axes
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, cy);
                ctx.lineTo(W, cy);
                ctx.moveTo(cx, 0);
                ctx.lineTo(cx, H);
                ctx.stroke();

                // Layer indicator
                if (i > 0 && i <= state.numLayers) {
                    ctx.fillStyle = i % 2 === 0 ? '#f87171' : '#60a5fa';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    const dim = i % 2 === 0 ? 'x₂' : 'x₁';
                    ctx.fillText(`Transform ${dim}`, W / 2, H - 5);
                }
            }
        }

        function drawJacobian() {
            const ctx = jacobianCtx;
            const W = jacobianCanvas.width;
            const H = jacobianCanvas.height;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, W, H);

            if (state.jacobians.length === 0) return;

            const marginX = 60;
            const marginY = 30;
            const plotW = W - 2 * marginX;
            const plotH = H - 2 * marginY;

            // Find scale
            const maxJ = Math.max(...state.jacobians.map(Math.abs), 1);

            // Draw zero line
            const zeroY = marginY + plotH / 2;
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(marginX, zeroY);
            ctx.lineTo(W - marginX, zeroY);
            ctx.stroke();

            // Draw bars
            const barWidth = Math.min(60, plotW / state.jacobians.length * 0.6);
            const barGap = plotW / state.jacobians.length;

            state.jacobians.forEach((j, i) => {
                const x = marginX + i * barGap + barGap / 2 - barWidth / 2;
                const barH = Math.abs(j) / maxJ * (plotH / 2 - 10);
                const y = j >= 0 ? zeroY - barH : zeroY;

                ctx.fillStyle = j >= 0 ? '#4ade80' : '#f87171';
                ctx.fillRect(x, y, barWidth, barH);

                // Value
                ctx.fillStyle = '#888';
                ctx.font = '11px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(j.toFixed(2), x + barWidth / 2, j >= 0 ? y - 5 : y + barH + 12);

                // Layer label
                ctx.fillText('L' + (i + 1), x + barWidth / 2, H - 5);
            });

            // Y axis label
            ctx.fillStyle = '#888';
            ctx.textAlign = 'right';
            ctx.fillText('log|det J|', marginX - 10, H / 2);

            // Total
            const total = state.jacobians.reduce((a, b) => a + b, 0);
            ctx.fillStyle = '#c9a227';
            ctx.textAlign = 'right';
            ctx.fillText('Total: ' + total.toFixed(2), W - marginX, marginY);
        }

        function drawInverse() {
            const ctx = inverseCtx;
            const W = inverseCanvas.width;
            const H = inverseCanvas.height;

            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, W, H);

            const marginX = 50;
            const marginY = 20;
            const plotW = (W - 3 * marginX) / 2;
            const plotH = H - 2 * marginY;

            // Left: Final distribution
            ctx.strokeStyle = '#444';
            ctx.strokeRect(marginX, marginY, plotW, plotH);

            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Transformed Distribution', marginX + plotW / 2, H - 5);

            // Draw final samples
            const finalSamples = state.layerOutputs[state.layerOutputs.length - 1] || [];
            const scale = 35;
            const cx1 = marginX + plotW / 2;
            const cy1 = marginY + plotH / 2;

            ctx.fillStyle = 'rgba(74, 222, 128, 0.5)';
            for (const [x, y] of finalSamples) {
                const px = cx1 + x * scale;
                const py = cy1 - y * scale;
                if (px > marginX && px < marginX + plotW && py > marginY && py < marginY + plotH) {
                    ctx.beginPath();
                    ctx.arc(px, py, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Right: Base distribution after inverse
            const rightX = 2 * marginX + plotW;
            ctx.strokeStyle = '#444';
            ctx.strokeRect(rightX, marginY, plotW, plotH);

            ctx.fillStyle = '#888';
            ctx.fillText('Base Distribution (Inverse)', rightX + plotW / 2, H - 5);

            // Draw base samples
            const baseSamples = state.layerOutputs[0] || [];
            const cx2 = rightX + plotW / 2;
            const cy2 = marginY + plotH / 2;

            ctx.fillStyle = 'rgba(96, 165, 250, 0.5)';
            for (const [x, y] of baseSamples) {
                const px = cx2 + x * scale;
                const py = cy2 - y * scale;
                if (px > rightX && px < rightX + plotW && py > marginY && py < marginY + plotH) {
                    ctx.beginPath();
                    ctx.arc(px, py, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Arrow between them
            ctx.strokeStyle = '#c9a227';
            ctx.lineWidth = 2;
            const arrowX = marginX + plotW + marginX / 2;
            ctx.beginPath();
            ctx.moveTo(arrowX - 20, H / 2);
            ctx.lineTo(arrowX + 20, H / 2);
            ctx.moveTo(arrowX + 10, H / 2 - 8);
            ctx.lineTo(arrowX + 20, H / 2);
            ctx.lineTo(arrowX + 10, H / 2 + 8);
            ctx.stroke();

            ctx.fillStyle = '#c9a227';
            ctx.font = '11px sans-serif';
            ctx.fillText('f⁻¹', arrowX, H / 2 - 15);
        }

        function updateMetrics() {
            const totalLogDet = state.jacobians.reduce((a, b) => a + b, 0);
            document.getElementById('metricLogDet').textContent = totalLogDet.toFixed(3);

            // Average log prob in base distribution
            const baseSamples = state.layerOutputs[0] || [];
            let baseLogProb = 0;
            for (const [x, y] of baseSamples) {
                baseLogProb += -0.5 * (x * x + y * y) - Math.log(2 * Math.PI);
            }
            baseLogProb /= baseSamples.length;
            document.getElementById('metricBaseProb').textContent = baseLogProb.toFixed(3);

            // Final log prob = base log prob + log det
            document.getElementById('metricFinalProb').textContent = (baseLogProb + totalLogDet).toFixed(3);
        }

        // Event listeners
        document.getElementById('numLayers').addEventListener('input', e => {
            state.numLayers = parseInt(e.target.value);
            document.getElementById('numLayersValue').textContent = state.numLayers;
            runFlow();
        });

        document.getElementById('scaleStrength').addEventListener('input', e => {
            state.scaleStrength = parseFloat(e.target.value);
            document.getElementById('scaleStrengthValue').textContent = state.scaleStrength.toFixed(1);
            runFlow();
        });

        document.getElementById('shiftStrength').addEventListener('input', e => {
            state.shiftStrength = parseFloat(e.target.value);
            document.getElementById('shiftStrengthValue').textContent = state.shiftStrength.toFixed(1);
            runFlow();
        });

        document.getElementById('progress').addEventListener('input', e => {
            state.progress = parseInt(e.target.value) / 100;
            document.getElementById('progressValue').textContent = e.target.value;
            updateDisplay();
        });

        document.getElementById('targetDist').addEventListener('change', e => {
            state.targetDist = e.target.value;
            runFlow();
        });

        document.getElementById('sampleBtn').addEventListener('click', runFlow);

        document.getElementById('animateBtn').addEventListener('click', () => {
            if (state.animating) return;
            state.animating = true;

            const slider = document.getElementById('progress');
            let progress = 0;

            function animate() {
                progress += 2;
                if (progress > 100) {
                    state.animating = false;
                    return;
                }

                slider.value = progress;
                document.getElementById('progressValue').textContent = progress;
                state.progress = progress / 100;
                updateDisplay();

                requestAnimationFrame(animate);
            }

            slider.value = 0;
            state.progress = 0;
            animate();
        });

        document.getElementById('invertBtn').addEventListener('click', () => {
            // Run inverse flow from final to base
            if (state.layerOutputs.length < 2) return;

            let current = state.layerOutputs[state.layerOutputs.length - 1];
            const inverseOutputs = [current];

            for (let l = state.numLayers - 1; l >= 0; l--) {
                const { outputs } = applyCouplingLayer(current, l, false);
                inverseOutputs.push(outputs);
                current = outputs;
            }

            // Briefly show inverse flow
            state.layerOutputs = inverseOutputs.reverse();
            updateDisplay();

            // Restore after delay
            setTimeout(runFlow, 2000);
        });

        // Initialize
        runFlow();
    </script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
