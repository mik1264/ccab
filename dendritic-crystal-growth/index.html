<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dendritic Crystal Growth</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: sans-serif; }
canvas { display: block; }
#title {
    position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
    color: #93c5fd; font-size: 20px; font-weight: bold; z-index: 10;
    text-shadow: 0 0 20px rgba(147,197,253,0.5);
    pointer-events: none;
}
#controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 15px; align-items: center; z-index: 10;
    background: rgba(0,0,0,0.7); padding: 10px 20px; border-radius: 10px;
}
#controls label { color: #93c5fd; font-size: 13px; }
#controls input[type=range] { width: 100px; cursor: pointer; }
#controls button {
    background: rgba(147,197,253,0.2); color: #93c5fd; border: 1px solid #93c5fd;
    padding: 5px 12px; border-radius: 5px; cursor: pointer; font-size: 13px;
}
#controls button:hover { background: rgba(147,197,253,0.4); }
#info {
    position: fixed; top: 80px; right: 20px; color: #64748b; font-size: 12px;
    z-index: 10; text-align: right;
}
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">&#8592; Back to Gallery</a>
<div id="title">Dendritic Crystal Growth</div>
<div id="info">Particles: <span id="particleCount">0</span><br>Crystal size: <span id="crystalSize">0</span></div>
<div id="controls">
    <label>Anisotropy: <input type="range" id="anisotropy" min="1" max="10" value="6" step="1"></label>
    <label>Stickiness: <input type="range" id="stickiness" min="1" max="10" value="5" step="1"></label>
    <label>Speed: <input type="range" id="speed" min="1" max="20" value="10" step="1"></label>
    <button id="resetBtn">Reset</button>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H, cx, cy;
let grid, crystalPixels, particles;
let gridW, gridH;
const CELL = 2;
let anisotropy = 6;
let stickiness = 0.5;
let speed = 10;
let crystalCount = 0;
let running = true;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    cx = Math.floor(W / 2);
    cy = Math.floor(H / 2);
}

function init() {
    resize();
    gridW = Math.floor(W / CELL);
    gridH = Math.floor(H / CELL);
    grid = new Uint8Array(gridW * gridH);
    crystalPixels = new Float32Array(gridW * gridH);
    particles = [];
    crystalCount = 0;

    // Seed crystal at center
    const scx = Math.floor(gridW / 2);
    const scy = Math.floor(gridH / 2);
    for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
            const idx = (scy + dy) * gridW + (scx + dx);
            if (idx >= 0 && idx < grid.length) {
                grid[idx] = 1;
                crystalPixels[idx] = 1.0;
                crystalCount++;
            }
        }
    }

    // Spawn initial walkers
    for (let i = 0; i < 3000; i++) {
        spawnParticle();
    }
}

function spawnParticle() {
    // Spawn on a circle around the crystal
    const maxR = Math.min(gridW, gridH) * 0.45;
    const angle = Math.random() * Math.PI * 2;
    const r = maxR * (0.3 + Math.random() * 0.7);
    const px = Math.floor(gridW / 2 + Math.cos(angle) * r);
    const py = Math.floor(gridH / 2 + Math.sin(angle) * r);
    if (px > 0 && px < gridW - 1 && py > 0 && py < gridH - 1) {
        particles.push({ x: px, y: py });
    }
}

function getAnisotropyFactor(dx, dy) {
    const angle = Math.atan2(dy, dx);
    const fold = anisotropy;
    return 0.5 + 0.5 * Math.cos(fold * angle);
}

function hasNeighborCrystal(x, y) {
    const dirs = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[1,-1],[-1,1],[1,1]];
    for (const [dx, dy] of dirs) {
        const nx = x + dx, ny = y + dy;
        if (nx >= 0 && nx < gridW && ny >= 0 && ny < gridH) {
            if (grid[ny * gridW + nx] === 1) {
                return { dx, dy };
            }
        }
    }
    return null;
}

function step() {
    const centerX = gridW / 2;
    const centerY = gridH / 2;
    const maxR = Math.min(gridW, gridH) * 0.45;

    for (let s = 0; s < speed; s++) {
        const newParticles = [];
        for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            // Random walk
            p.x += Math.floor(Math.random() * 3) - 1;
            p.y += Math.floor(Math.random() * 3) - 1;

            // Boundary check
            const dist = Math.sqrt((p.x - centerX) ** 2 + (p.y - centerY) ** 2);
            if (p.x < 1 || p.x >= gridW - 1 || p.y < 1 || p.y >= gridH - 1 || dist > maxR) {
                spawnParticle();
                continue;
            }

            if (grid[p.y * gridW + p.x] === 1) {
                continue;
            }

            const neighbor = hasNeighborCrystal(p.x, p.y);
            if (neighbor) {
                const aFactor = getAnisotropyFactor(
                    p.x - centerX,
                    p.y - centerY
                );
                if (Math.random() < stickiness * aFactor) {
                    grid[p.y * gridW + p.x] = 1;
                    crystalPixels[p.y * gridW + p.x] = 0.5 + 0.5 * aFactor;
                    crystalCount++;
                    spawnParticle();
                    continue;
                }
            }
            newParticles.push(p);
        }
        particles.length = 0;
        for (let i = 0; i < newParticles.length; i++) {
            particles.push(newParticles[i]);
        }
    }

    // Maintain particle count
    while (particles.length < 3000) {
        spawnParticle();
    }
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    // Draw crystal
    const imageData = ctx.createImageData(W, H);
    const data = imageData.data;

    for (let gy = 0; gy < gridH; gy++) {
        for (let gx = 0; gx < gridW; gx++) {
            if (grid[gy * gridW + gx] === 1) {
                const brightness = crystalPixels[gy * gridW + gx];
                const dist = Math.sqrt(
                    (gx - gridW / 2) ** 2 + (gy - gridH / 2) ** 2
                );
                const maxDist = Math.min(gridW, gridH) * 0.4;
                const distFactor = 1 - Math.min(dist / maxDist, 1);

                const r = Math.floor(180 + 75 * brightness * distFactor);
                const g = Math.floor(200 + 55 * brightness);
                const b = 255;
                const a = 200 + Math.floor(55 * brightness);

                for (let py = gy * CELL; py < Math.min((gy + 1) * CELL, H); py++) {
                    for (let px = gx * CELL; px < Math.min((gx + 1) * CELL, W); px++) {
                        const idx = (py * W + px) * 4;
                        data[idx] = r;
                        data[idx + 1] = g;
                        data[idx + 2] = b;
                        data[idx + 3] = a;
                    }
                }
            }
        }
    }

    // Draw particles as faint dots
    for (const p of particles) {
        const px = p.x * CELL;
        const py = p.y * CELL;
        if (px >= 0 && px < W && py >= 0 && py < H) {
            const idx = (py * W + px) * 4;
            data[idx] = 100;
            data[idx + 1] = 120;
            data[idx + 2] = 180;
            data[idx + 3] = 40;
        }
    }

    ctx.putImageData(imageData, 0, 0);

    // Glow effect for crystal center
    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 100);
    gradient.addColorStop(0, 'rgba(147,197,253,0.15)');
    gradient.addColorStop(1, 'rgba(147,197,253,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(cx - 100, cy - 100, 200, 200);

    document.getElementById('particleCount').textContent = particles.length;
    document.getElementById('crystalSize').textContent = crystalCount;
}

function animate() {
    if (running) {
        step();
        draw();
    }
    requestAnimationFrame(animate);
}

document.getElementById('anisotropy').addEventListener('input', (e) => {
    anisotropy = parseInt(e.target.value);
});
document.getElementById('stickiness').addEventListener('input', (e) => {
    stickiness = parseInt(e.target.value) / 10;
});
document.getElementById('speed').addEventListener('input', (e) => {
    speed = parseInt(e.target.value);
});
document.getElementById('resetBtn').addEventListener('click', init);
window.addEventListener('resize', () => { resize(); init(); });

init();
animate();
</script>
</body>
</html>
