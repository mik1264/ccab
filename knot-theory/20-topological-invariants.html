<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Topological Invariants</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
#controls {
  position: fixed; top: 20px; right: 20px; background: rgba(10,14,26,0.85);
  backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(240,160,80,0.3); border-radius: 12px;
  padding: 18px; color: #e8c8a0; z-index: 100; min-width: 260px;
}
#controls h3 { margin-bottom: 12px; color: #f0b060; font-size: 1.1em; }
.ctrl-row { margin-bottom: 10px; }
.ctrl-row label { display: block; font-size: 0.85em; margin-bottom: 4px; opacity: 0.8; }
.ctrl-row input[type=range] { width: 100%; accent-color: #f0a040; }
.btn { background: rgba(240,160,80,0.2); border: 1px solid rgba(240,160,80,0.4); color: #f0b060;
  padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.85em; margin: 3px 2px; }
.btn:hover { background: rgba(240,160,80,0.4); }
.btn.active { background: rgba(240,160,80,0.5); }
#props { background: rgba(60,40,20,0.4); border-radius: 8px; padding: 10px; margin-top: 10px;
  font-size: 0.82em; line-height: 1.5; }
#props .pn { color: #c0a060; }
#props .pv { color: #f0e0c0; font-weight: bold; }
.morph-btns { display: flex; flex-wrap: wrap; gap: 4px; margin: 6px 0; }
#quizArea { display: none; margin-top: 10px; padding: 10px; background: rgba(60,40,20,0.3);
  border-radius: 8px; text-align: center; }
#quizArea .q { font-size: 0.9em; margin-bottom: 8px; }
#quizResult { margin-top: 6px; font-weight: bold; }
#info { margin-top: 10px; font-size: 0.75em; color: #b0a080; line-height: 1.4; padding: 8px;
  background: rgba(40,30,15,0.3); border-radius: 6px; }
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>
<div id="controls">
  <h3>Topological Invariants</h3>
  <div class="ctrl-row">
    <label>Morph Pair</label>
    <div class="morph-btns">
      <button class="btn active" id="bMugDonut" onclick="selectPair('mugDonut')">Mug / Donut</button>
      <button class="btn" id="bBallCube" onclick="selectPair('ballCube')">Ball / Cube</button>
      <button class="btn" id="bPretzel" onclick="selectPair('pretzel')">Pretzel / 2-Torus</button>
      <button class="btn" id="bMobius" onclick="selectPair('mobius')">Mobius / Cylinder</button>
    </div>
  </div>
  <div class="ctrl-row">
    <label>Morph: <span id="morphVal">0%</span></label>
    <input type="range" id="morphSlider" min="0" max="100" value="0">
  </div>
  <div class="ctrl-row">
    <label>Speed: <span id="speedVal">1.0</span></label>
    <input type="range" id="speedSlider" min="1" max="30" value="10">
  </div>
  <div class="ctrl-row">
    <button class="btn" id="autoBtn" onclick="toggleAuto()">Auto Morph</button>
    <button class="btn" onclick="toggleQuiz()">Quiz Mode</button>
  </div>
  <div id="props">
    <span class="pn">Object A:</span> <span class="pv" id="objA">Coffee Mug</span><br>
    <span class="pn">Object B:</span> <span class="pv" id="objB">Donut (Torus)</span><br>
    <span class="pn">Genus:</span> <span class="pv" id="pGenus">1</span> |
    <span class="pn">Euler:</span> <span class="pv" id="pEuler">0</span><br>
    <span class="pn">Orientable:</span> <span class="pv" id="pOrient">Yes</span> |
    <span class="pn">Betti:</span> <span class="pv" id="pBetti">(1,2,1)</span><br>
    <span class="pn">Equivalent:</span> <span class="pv" id="pEquiv">Yes!</span>
  </div>
  <div id="quizArea">
    <div class="q" id="quizQ">Are these topologically equivalent?</div>
    <button class="btn" onclick="quizAnswer(true)">Yes, equivalent</button>
    <button class="btn" onclick="quizAnswer(false)">No, different</button>
    <div id="quizResult"></div>
  </div>
  <div id="info">
    Topology is "rubber sheet geometry" - properties that survive stretching and bending but not cutting or gluing.
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

let currentPair = 'mugDonut';
let morphT = 0;
let autoMorph = false;
let morphDir = 1;
let morphSpeed = 1.0;
let rotY = 0, rotX = 0.35;
let autoRotate = true;
let time = 0;
let quizMode = false;
let quizPair = null;

const pairs = {
  mugDonut: { a: 'Coffee Mug', b: 'Donut (Torus)', genus: 1, euler: 0, orient: true, betti: '(1,2,1)', equiv: true },
  ballCube: { a: 'Ball', b: 'Cube', genus: 0, euler: 2, orient: true, betti: '(1,0,1)', equiv: true },
  pretzel: { a: 'Pretzel', b: 'Double Torus', genus: 2, euler: -2, orient: true, betti: '(1,4,1)', equiv: true },
  mobius: { a: 'Mobius Strip', b: 'Cylinder', genus: '-', euler: '0 vs 0', orient: 'No vs Yes', betti: '-', equiv: false }
};

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}

function selectPair(pair) {
  currentPair = pair;
  morphT = 0;
  document.getElementById('morphSlider').value = 0;
  document.getElementById('morphVal').textContent = '0%';
  document.querySelectorAll('.morph-btns .btn').forEach(b => b.classList.remove('active'));
  const btn = document.getElementById('b' + pair.charAt(0).toUpperCase() + pair.slice(1));
  if (btn) btn.classList.add('active');
  updateProps();
}

function updateProps() {
  const p = pairs[currentPair];
  document.getElementById('objA').textContent = p.a;
  document.getElementById('objB').textContent = p.b;
  document.getElementById('pGenus').textContent = p.genus;
  document.getElementById('pEuler').textContent = p.euler;
  document.getElementById('pOrient').textContent = typeof p.orient === 'boolean' ? (p.orient ? 'Yes' : 'No') : p.orient;
  document.getElementById('pBetti').textContent = p.betti;
  document.getElementById('pEquiv').textContent = p.equiv ? 'Yes!' : 'No - different topology';
  document.getElementById('pEquiv').style.color = p.equiv ? '#80f080' : '#f08080';
}

function toggleAuto() {
  autoMorph = !autoMorph;
  document.getElementById('autoBtn').classList.toggle('active', autoMorph);
}

function toggleQuiz() {
  quizMode = !quizMode;
  document.getElementById('quizArea').style.display = quizMode ? 'block' : 'none';
  if (quizMode) nextQuiz();
}

function nextQuiz() {
  const pairKeys = Object.keys(pairs);
  quizPair = pairKeys[Math.floor(Math.random() * pairKeys.length)];
  const p = pairs[quizPair];
  document.getElementById('quizQ').textContent = `Is "${p.a}" topologically equivalent to "${p.b}"?`;
  document.getElementById('quizResult').textContent = '';
  currentPair = quizPair;
  morphT = 0;
  updateProps();
  // Hide equivalence during quiz
  document.getElementById('pEquiv').textContent = '???';
  document.getElementById('pEquiv').style.color = '#f0c060';
}

function quizAnswer(yes) {
  const p = pairs[quizPair];
  const correct = yes === p.equiv;
  const res = document.getElementById('quizResult');
  if (correct) {
    res.textContent = 'Correct!';
    res.style.color = '#80f080';
  } else {
    res.textContent = 'Wrong! ' + (p.equiv ? 'They ARE equivalent.' : 'They are NOT equivalent.');
    res.style.color = '#f08080';
  }
  document.getElementById('pEquiv').textContent = p.equiv ? 'Yes!' : 'No - different topology';
  document.getElementById('pEquiv').style.color = p.equiv ? '#80f080' : '#f08080';
  setTimeout(nextQuiz, 2500);
}

// 3D projection
function project(x, y, z) {
  const cosA = Math.cos(rotY);
  const sinA = Math.sin(rotY);
  const cosB = Math.cos(rotX);
  const sinB = Math.sin(rotX);
  const x1 = x * cosA - z * sinA;
  const z1 = x * sinA + z * cosA;
  const y1 = y * cosB - z1 * sinB;
  const z2 = y * sinB + z1 * cosB;
  const fov = 500;
  const p = fov / (fov + z2 + 250);
  return { x: W/2 + x1 * p * 1.8, y: H/2 + y1 * p * 1.8, z: z2, s: p };
}

// Generate mesh for mug
function generateMug(t) {
  // t=0: mug, t=1: torus
  const res = 36;
  const faces = [];

  for (let i = 0; i < res; i++) {
    for (let j = 0; j < res; j++) {
      const u0 = (i / res) * Math.PI * 2;
      const u1 = ((i+1) / res) * Math.PI * 2;
      const v0 = (j / res) * Math.PI * 2;
      const v1 = ((j+1) / res) * Math.PI * 2;

      const pts = [
        mugPoint(u0, v0, t),
        mugPoint(u1, v0, t),
        mugPoint(u1, v1, t),
        mugPoint(u0, v1, t)
      ].map(p => project(p.x, p.y, p.z));

      const avgZ = (pts[0].z + pts[1].z + pts[2].z + pts[3].z) / 4;

      // Face normal for shading
      const nx = (pts[1].x - pts[0].x) * (pts[3].y - pts[0].y) - (pts[1].y - pts[0].y) * (pts[3].x - pts[0].x);

      faces.push({ pts, z: avgZ, nx, u: i/res, v: j/res });
    }
  }

  return faces;
}

function mugPoint(u, v, t) {
  // Interpolate between mug and torus
  // Torus
  const R = 55, r = 22;
  const tx = (R + r * Math.cos(v)) * Math.cos(u);
  const ty = (R + r * Math.cos(v)) * Math.sin(u);
  const tz = r * Math.sin(v);

  // Mug: body is a cylinder, handle is a torus section
  const bodyR = 35;
  const bodyH = 70;
  const handleR = 30;
  const handleR2 = 8;

  let mx, my, mz;

  // Blend between body and handle based on u
  const handleRegion = (u > Math.PI * 0.8 && u < Math.PI * 1.5);

  if (!handleRegion) {
    // Body: cylinder
    const bodyAngle = u;
    const heightT = v / (Math.PI * 2);
    mx = bodyR * Math.cos(bodyAngle);
    mz = bodyR * Math.sin(bodyAngle);
    my = (heightT - 0.5) * bodyH;

    // Add bottom
    if (v < 0.3 || v > Math.PI * 2 - 0.3) {
      const innerR = bodyR * (1 - Math.abs(Math.sin(v * 5)));
      mx = innerR * Math.cos(bodyAngle);
      mz = innerR * Math.sin(bodyAngle);
    }
  } else {
    // Handle: arc on the side
    const handleAngle = ((u - Math.PI * 0.8) / (Math.PI * 0.7)) * Math.PI; // 0 to PI
    const hx = bodyR + handleR * Math.sin(handleAngle);
    const hy = handleR * Math.cos(handleAngle);
    mx = hx * Math.cos(Math.PI * 1.15) + handleR2 * Math.cos(v) * Math.cos(Math.PI * 1.15);
    mz = hx * Math.sin(Math.PI * 1.15) + handleR2 * Math.cos(v) * Math.sin(Math.PI * 1.15);
    my = hy + handleR2 * Math.sin(v);
  }

  // Smooth interpolation
  const s = smoothstep(t);
  return {
    x: mx * (1 - s) + tx * s,
    y: my * (1 - s) + ty * s,
    z: mz * (1 - s) + tz * s
  };
}

function smoothstep(t) {
  t = Math.max(0, Math.min(1, t));
  return t * t * (3 - 2 * t);
}

// Generate mesh for ball/cube morph
function generateBallCube(t) {
  const res = 30;
  const faces = [];

  for (let i = 0; i < res; i++) {
    for (let j = 0; j < res; j++) {
      const pts = [];
      for (let di = 0; di <= 1; di++) {
        for (let dj = 0; dj <= 1; dj++) {
          const u = ((i + di) / res) * Math.PI * 2;
          const phi = ((j + dj) / res) * Math.PI;

          // Sphere
          const sx = 70 * Math.sin(phi) * Math.cos(u);
          const sy = 70 * Math.sin(phi) * Math.sin(u);
          const sz = 70 * Math.cos(phi);

          // Cube (inflated cube)
          const len = Math.sqrt(sx*sx + sy*sy + sz*sz) || 1;
          const maxAbs = Math.max(Math.abs(sx), Math.abs(sy), Math.abs(sz));
          const cubeScale = 60 / maxAbs;
          const cx = sx * cubeScale;
          const cy = sy * cubeScale;
          const cz = sz * cubeScale;

          const s = smoothstep(t);
          const p = project(
            sx * (1-s) + cx * s,
            sy * (1-s) + cy * s,
            sz * (1-s) + cz * s
          );
          pts.push(p);
        }
      }

      const avgZ = (pts[0].z + pts[1].z + pts[2].z + pts[3].z) / 4;
      const nx = (pts[1].x - pts[0].x) * (pts[2].y - pts[0].y) - (pts[1].y - pts[0].y) * (pts[2].x - pts[0].x);
      faces.push({ pts: [pts[0], pts[1], pts[3], pts[2]], z: avgZ, nx, u: i/res, v: j/res });
    }
  }

  return faces;
}

// Generate pretzel / double torus
function generatePretzel(t) {
  const res = 32;
  const faces = [];

  for (let i = 0; i < res; i++) {
    for (let j = 0; j < res; j++) {
      const pts = [];
      for (let di = 0; di <= 1; di++) {
        for (let dj = 0; dj <= 1; dj++) {
          const u = ((i + di) / res) * Math.PI * 2;
          const v = ((j + dj) / res) * Math.PI * 2;

          // Double torus
          const R2 = 50, r2 = 18;
          const wobble = 20 * Math.cos(2 * u);
          const dtx = (R2 + (r2 + wobble * (1-t)) * Math.cos(v)) * Math.cos(u);
          const dty = (R2 + (r2 + wobble * (1-t)) * Math.cos(v)) * Math.sin(u);
          const dtz = (r2 + wobble * (1-t)) * Math.sin(v);

          // Pretzel shape (similar but more twisted)
          const px = (R2 + (r2 + wobble) * Math.cos(v)) * Math.cos(u);
          const py = (R2 + (r2 + wobble) * Math.cos(v)) * Math.sin(u) + 10 * Math.sin(3*u) * (1-t);
          const pz = (r2 + wobble) * Math.sin(v);

          const s = smoothstep(t);
          const p = project(
            px * (1-s) + dtx * s,
            py * (1-s) + dty * s,
            pz * (1-s) + dtz * s
          );
          pts.push(p);
        }
      }

      const avgZ = (pts[0].z + pts[1].z + pts[2].z + pts[3].z) / 4;
      const nx = (pts[1].x - pts[0].x) * (pts[2].y - pts[0].y) - (pts[1].y - pts[0].y) * (pts[2].x - pts[0].x);
      faces.push({ pts: [pts[0], pts[1], pts[3], pts[2]], z: avgZ, nx, u: i/res, v: j/res });
    }
  }

  return faces;
}

// Generate Mobius strip / cylinder
function generateMobius(t) {
  const res = 40;
  const halfW = 20;
  const R = 60;
  const faces = [];

  for (let i = 0; i < res; i++) {
    for (let j = 0; j < res / 2; j++) {
      const pts = [];
      for (let di = 0; di <= 1; di++) {
        for (let dj = 0; dj <= 1; dj++) {
          const u = ((i + di) / res) * Math.PI * 2;
          const s = ((j + dj) / (res/2) - 0.5) * halfW;

          // Mobius strip: half-twist
          const mobiusTwist = u / 2 * (1 - t); // t=0: Mobius, t=1: no twist (cylinder)

          const x = (R + s * Math.cos(mobiusTwist)) * Math.cos(u);
          const y = (R + s * Math.cos(mobiusTwist)) * Math.sin(u);
          const z = s * Math.sin(mobiusTwist);

          pts.push(project(x, y, z));
        }
      }

      const avgZ = (pts[0].z + pts[1].z + pts[2].z + pts[3].z) / 4;
      const nx = (pts[1].x - pts[0].x) * (pts[2].y - pts[0].y) - (pts[1].y - pts[0].y) * (pts[2].x - pts[0].x);
      faces.push({ pts: [pts[0], pts[1], pts[3], pts[2]], z: avgZ, nx, u: i/res, v: j/(res/2) });
    }
  }

  return faces;
}

function drawFaces(faces, hueBase) {
  faces.sort((a, b) => a.z - b.z);

  for (const f of faces) {
    const brightness = Math.max(15, Math.min(70, 40 + f.nx * 0.003));
    const hue = hueBase + f.u * 60;

    ctx.beginPath();
    ctx.moveTo(f.pts[0].x, f.pts[0].y);
    for (let k = 1; k < f.pts.length; k++) {
      ctx.lineTo(f.pts[k].x, f.pts[k].y);
    }
    ctx.closePath();
    ctx.fillStyle = `hsla(${hue}, 55%, ${brightness}%, 0.9)`;
    ctx.fill();
    ctx.strokeStyle = `hsla(${hue}, 40%, ${brightness + 15}%, 0.12)`;
    ctx.lineWidth = 0.5;
    ctx.stroke();
  }
}

function draw() {
  ctx.fillStyle = '#0a0e1a';
  ctx.fillRect(0, 0, W, H);

  // Background
  const grad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, H * 0.45);
  grad.addColorStop(0, 'rgba(60,40,20,0.1)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  let faces;
  let hue;

  switch(currentPair) {
    case 'mugDonut':
      faces = generateMug(morphT);
      hue = 25;
      break;
    case 'ballCube':
      faces = generateBallCube(morphT);
      hue = 200;
      break;
    case 'pretzel':
      faces = generatePretzel(morphT);
      hue = 40;
      break;
    case 'mobius':
      faces = generateMobius(morphT);
      hue = 280;
      break;
  }

  drawFaces(faces, hue);

  // Draw morph percentage text
  const pct = Math.round(morphT * 100);
  const p = pairs[currentPair];
  const label = pct < 50 ? p.a : p.b;
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.font = '16px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(label, W/2, H - 40);

  // Morph indicator bar
  const barW = 200;
  const barH = 4;
  const barX = W/2 - barW/2;
  const barY = H - 25;
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.fillRect(barX, barY, barW, barH);
  ctx.fillStyle = 'rgba(240,160,80,0.6)';
  ctx.fillRect(barX, barY, barW * morphT, barH);

  // Label endpoints
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.font = '11px sans-serif';
  ctx.textAlign = 'right';
  ctx.fillText(p.a, barX - 8, barY + 4);
  ctx.textAlign = 'left';
  ctx.fillText(p.b, barX + barW + 8, barY + 4);

  // Non-equivalent warning
  if (!p.equiv) {
    ctx.fillStyle = 'rgba(255,100,100,0.5)';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('These shapes are NOT topologically equivalent!', W/2, 60);
    ctx.fillStyle = 'rgba(255,100,100,0.2)';
    ctx.font = '12px sans-serif';
    ctx.fillText('No continuous deformation can transform one into the other', W/2, 80);
  }
}

// Controls
document.getElementById('morphSlider').addEventListener('input', function() {
  morphT = parseInt(this.value) / 100;
  document.getElementById('morphVal').textContent = Math.round(morphT * 100) + '%';
});

document.getElementById('speedSlider').addEventListener('input', function() {
  morphSpeed = parseInt(this.value) / 10;
  document.getElementById('speedVal').textContent = morphSpeed.toFixed(1);
});

// Mouse drag
let dragging = false;
let lastMX = 0, lastMY = 0;
canvas.addEventListener('mousedown', e => { dragging = true; lastMX = e.clientX; lastMY = e.clientY; autoRotate = false; });
canvas.addEventListener('mousemove', e => {
  if (dragging) {
    rotY += (e.clientX - lastMX) * 0.005;
    rotX += (e.clientY - lastMY) * 0.005;
    lastMX = e.clientX; lastMY = e.clientY;
  }
});
canvas.addEventListener('mouseup', () => { dragging = false; autoRotate = true; });
canvas.addEventListener('mouseleave', () => { dragging = false; });
canvas.addEventListener('touchstart', e => { dragging = true; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; autoRotate = false; });
canvas.addEventListener('touchmove', e => {
  if (dragging) {
    rotY += (e.touches[0].clientX - lastMX) * 0.005;
    rotX += (e.touches[0].clientY - lastMY) * 0.005;
    lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY;
  }
});
canvas.addEventListener('touchend', () => { dragging = false; autoRotate = true; });

window.addEventListener('resize', resize);

window.reset = function() {
  currentPair = 'mugDonut';
  morphT = 0; autoMorph = false; morphDir = 1; morphSpeed = 1.0;
  rotY = 0; rotX = 0.35; autoRotate = true; quizMode = false;
  document.getElementById('morphSlider').value = 0;
  document.getElementById('morphVal').textContent = '0%';
  document.getElementById('speedSlider').value = 10;
  document.getElementById('speedVal').textContent = '1.0';
  document.getElementById('autoBtn').classList.remove('active');
  document.getElementById('quizArea').style.display = 'none';
  document.querySelectorAll('.morph-btns .btn').forEach(b => b.classList.remove('active'));
  document.getElementById('bMugDonut').classList.add('active');
  updateProps();
};

function animate() {
  time += 0.016;
  if (autoRotate && !dragging) rotY += 0.008;

  if (autoMorph) {
    morphT += morphDir * 0.005 * morphSpeed;
    if (morphT >= 1) { morphT = 1; morphDir = -1; }
    if (morphT <= 0) { morphT = 0; morphDir = 1; }
    document.getElementById('morphSlider').value = Math.round(morphT * 100);
    document.getElementById('morphVal').textContent = Math.round(morphT * 100) + '%';
  }

  draw();
  requestAnimationFrame(animate);
}

resize();
updateProps();
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>