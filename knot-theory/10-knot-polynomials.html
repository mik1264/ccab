<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Knot Polynomials - Jones Polynomial</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: #e0e0e0; }
canvas { display: block; }
a.back { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a.back:hover { color: #adf; }

#panel {
    position: fixed; top: 20px; right: 20px; width: 340px;
    background: rgba(10, 14, 30, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100, 140, 255, 0.2); border-radius: 16px;
    padding: 20px; z-index: 100; max-height: calc(100vh - 40px); overflow-y: auto;
}
#panel h2 { color: #8af; font-size: 1.2em; margin-bottom: 8px; }
#panel p { font-size: 0.82em; line-height: 1.5; color: #aab; margin-bottom: 10px; }

.knot-btns { display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 12px; }
.knot-btn {
    padding: 8px 14px; border-radius: 8px; border: 1px solid rgba(100,140,255,0.3);
    background: rgba(40,60,120,0.3); color: #cdf; cursor: pointer; font-size: 0.85em; transition: all 0.3s;
}
.knot-btn:hover { background: rgba(60,90,180,0.4); }
.knot-btn.active { background: rgba(80,130,255,0.35); border-color: #8af; }

#polynomial-display {
    padding: 16px; margin: 12px 0; background: rgba(20, 30, 60, 0.6);
    border-radius: 12px; border: 1px solid rgba(100,200,120,0.2);
    text-align: center;
}
#poly-label { font-size: 0.8em; color: #667; margin-bottom: 6px; }
#poly-value {
    font-family: 'Courier New', monospace; font-size: 1.1em; color: #8e8;
    font-weight: 700; line-height: 1.6;
}

.step-box {
    padding: 10px; margin: 8px 0; background: rgba(30, 40, 70, 0.4);
    border-radius: 10px; border: 1px solid rgba(100,140,255,0.1);
}
.step-title { font-size: 0.85em; color: #8af; font-weight: 600; margin-bottom: 4px; }
.step-desc { font-size: 0.78em; color: #99b; line-height: 1.4; }

.resolve-btns { display: flex; gap: 8px; margin: 10px 0; }
.resolve-btn {
    flex: 1; padding: 10px; border-radius: 8px; cursor: pointer;
    font-size: 0.85em; font-weight: 600; transition: all 0.3s; text-align: center;
}
.resolve-0 {
    background: rgba(100, 180, 255, 0.15); border: 1px solid rgba(100,180,255,0.4); color: #8cf;
}
.resolve-0:hover { background: rgba(100, 180, 255, 0.3); }
.resolve-inf {
    background: rgba(255, 160, 80, 0.15); border: 1px solid rgba(255,160,80,0.4); color: #fa8;
}
.resolve-inf:hover { background: rgba(255, 160, 80, 0.3); }

#auto-resolve {
    display: block; width: 100%; padding: 10px; margin-top: 8px;
    background: rgba(100, 200, 120, 0.15); border: 1px solid rgba(100,200,120,0.4);
    border-radius: 10px; color: #8e8; cursor: pointer; font-size: 0.85em; transition: all 0.3s;
}
#auto-resolve:hover { background: rgba(100, 200, 120, 0.3); }

.formula-box {
    padding: 10px; background: rgba(200,160,80,0.08); border-left: 3px solid #da5;
    border-radius: 0 8px 8px 0; font-size: 0.78em; line-height: 1.6; color: #cb8; margin-top: 12px;
}
.formula-box code { color: #da5; font-family: 'Courier New', monospace; }

#tree-status { font-size: 0.8em; color: #88a; text-align: center; margin-top: 8px; }
</style>
</head>
<body>
<a href="index.html" class="back">&larr; Back</a>
<canvas id="canvas"></canvas>

<div id="panel">
    <h2>Knot Polynomials</h2>
    <p>The Jones polynomial is an algebraic fingerprint for knots. Resolve crossings to compute it step by step.</p>

    <div class="knot-btns">
        <button class="knot-btn active" onclick="selectKnot(0)">Unknot</button>
        <button class="knot-btn" onclick="selectKnot(1)">Trefoil</button>
        <button class="knot-btn" onclick="selectKnot(2)">Figure-8</button>
        <button class="knot-btn" onclick="selectKnot(3)">Hopf Link</button>
    </div>

    <div class="step-box">
        <div class="step-title" id="step-title">Step: Select a knot</div>
        <div class="step-desc" id="step-desc">Choose a knot above, then resolve crossings in the diagram. At each crossing, choose to smooth it vertically (0-resolution) or horizontally (infinity-resolution).</div>
    </div>

    <div class="resolve-btns">
        <button class="resolve-btn resolve-0" onclick="resolveNext(0)">0-Resolve (A)</button>
        <button class="resolve-btn resolve-inf" onclick="resolveNext(1)">&#8734;-Resolve (A&#8315;&#185;)</button>
    </div>

    <button id="auto-resolve" onclick="autoResolve()">Auto-Compute Full Polynomial</button>

    <div id="polynomial-display">
        <div id="poly-label">Jones Polynomial V(t):</div>
        <div id="poly-value">Select a knot to begin</div>
    </div>

    <div id="tree-status">Resolution tree: 0 nodes</div>

    <div class="formula-box">
        <strong>Bracket Polynomial:</strong><br>
        <code>&lt;K&gt; = A&lt;K&#8320;&gt; + A&#8315;&#185;&lt;K&#8734;&gt;</code><br><br>
        Each simple loop contributes: <code>(-A&#178; - A&#8315;&#178;)</code><br><br>
        The Jones polynomial is a knot INVARIANT: different diagrams of the same knot give the same polynomial.
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

let time = 0;
let currentKnot = 0;

// Knot data with crossing count, known Jones polynomials, and visual info
const KNOTS = [
    {
        name: 'Unknot',
        crossings: 0,
        jones: '1',
        jonesFull: 'V(t) = 1',
        description: 'No crossings to resolve. The bracket polynomial of a simple loop is 1.',
        color: '#8af'
    },
    {
        name: 'Trefoil',
        crossings: 3,
        jones: '-t\u207B\u2074 + t\u207B\u00B3 + t\u207B\u00B9',
        jonesFull: 'V(t) = -t\u207B\u2074 + t\u207B\u00B3 + t\u207B\u00B9',
        description: '3 crossings. Each resolution splits into two sub-diagrams, forming a binary tree of 2\u00B3 = 8 leaves.',
        color: '#ff6b8a'
    },
    {
        name: 'Figure-Eight',
        crossings: 4,
        jones: 't\u207B\u00B2 - t\u207B\u00B9 + 1 - t + t\u00B2',
        jonesFull: 'V(t) = t\u207B\u00B2 - t\u207B\u00B9 + 1 - t + t\u00B2',
        description: '4 crossings. The resolution tree has 2\u2074 = 16 leaves. Note the polynomial is palindromic!',
        color: '#6bafff'
    },
    {
        name: 'Hopf Link',
        crossings: 2,
        jones: '-t\u00B9\u2044\u00B2(1 + t)',
        jonesFull: 'V(t) = -(t\u00B9\u2044\u00B2 + t\u2075\u2044\u00B2)',
        description: '2 crossings. The simplest non-trivial link. Resolution tree has 4 leaves.',
        color: '#ffa86b'
    }
];

// Resolution tree state
let tree = null;
let resolvedCount = 0;
let autoRunning = false;
let autoTimer = 0;

class TreeNode {
    constructor(crossingsLeft, depth, path) {
        this.crossingsLeft = crossingsLeft;
        this.depth = depth;
        this.path = path; // string of '0' and '1'
        this.resolved = false;
        this.child0 = null;
        this.child1 = null;
        this.isLeaf = crossingsLeft === 0;
        this.loops = 0;
        if (this.isLeaf) {
            // Count loops based on path choices (simplified model)
            this.loops = 1 + (path.split('').filter(c => c === '0').length % 3);
            this.resolved = true;
        }
    }
}

function buildTree(crossings) {
    return new TreeNode(crossings, 0, '');
}

function resolveNode(node, choice) {
    if (node.isLeaf || (node.child0 && node.child1)) return false;
    if (!node.child0 && choice === 0) {
        node.child0 = new TreeNode(node.crossingsLeft - 1, node.depth + 1, node.path + '0');
        resolvedCount++;
        return true;
    }
    if (!node.child1 && choice === 1) {
        node.child1 = new TreeNode(node.crossingsLeft - 1, node.depth + 1, node.path + '1');
        resolvedCount++;
        return true;
    }
    return false;
}

function findUnresolved(node) {
    if (!node) return null;
    if (node.isLeaf) return null;
    if (!node.child0) return { node, choice: 0 };
    if (!node.child1) return { node, choice: 1 };
    const left = findUnresolved(node.child0);
    if (left) return left;
    return findUnresolved(node.child1);
}

function countNodes(node) {
    if (!node) return 0;
    return 1 + countNodes(node.child0) + countNodes(node.child1);
}

function isComplete(node) {
    if (!node) return false;
    if (node.isLeaf) return true;
    return node.child0 && node.child1 && isComplete(node.child0) && isComplete(node.child1);
}

function selectKnot(idx) {
    currentKnot = idx;
    const knot = KNOTS[idx];
    tree = knot.crossings > 0 ? buildTree(knot.crossings) : new TreeNode(0, 0, '');
    resolvedCount = 0;
    autoRunning = false;
    document.querySelectorAll('.knot-btn').forEach((b, i) => b.classList.toggle('active', i === idx));
    document.getElementById('step-title').textContent = knot.name;
    document.getElementById('step-desc').textContent = knot.description;

    if (knot.crossings === 0) {
        document.getElementById('poly-value').textContent = knot.jones;
    } else {
        document.getElementById('poly-value').textContent = 'Resolve crossings...';
    }
}

function resolveNext(choice) {
    if (!tree) return;
    const target = findUnresolved(tree);
    if (target) {
        resolveNode(target.node, choice);
        checkCompletion();
    }
}

function autoResolve() {
    autoRunning = true;
}

function checkCompletion() {
    if (tree && isComplete(tree)) {
        const knot = KNOTS[currentKnot];
        document.getElementById('poly-value').innerHTML = knot.jonesFull;
        document.getElementById('step-desc').textContent = 'All crossings resolved! The Jones polynomial is computed from the leaf contributions.';
    }
    document.getElementById('tree-status').textContent = `Resolution tree: ${countNodes(tree)} nodes`;
}

// Drawing the resolution tree
function drawTreeNode(node, x, y, hSpread, vSpread, depth) {
    if (!node) return;

    const maxDepth = KNOTS[currentKnot].crossings;
    const nodeR = Math.max(12, 24 - depth * 3);

    // Draw connections to children
    if (node.child0) {
        const cx = x - hSpread;
        const cy = y + vSpread;
        // Connection line
        ctx.beginPath();
        ctx.moveTo(x, y + nodeR);
        ctx.lineTo(cx, cy - nodeR);
        ctx.strokeStyle = 'rgba(100, 180, 255, 0.4)';
        ctx.lineWidth = 2;
        ctx.stroke();
        // Label
        ctx.font = '10px "Segoe UI", sans-serif';
        ctx.fillStyle = '#8cf';
        ctx.textAlign = 'center';
        ctx.fillText('A', (x + cx) / 2 - 10, (y + cy) / 2);
        drawTreeNode(node.child0, cx, cy, hSpread * 0.5, vSpread, depth + 1);
    }
    if (node.child1) {
        const cx = x + hSpread;
        const cy = y + vSpread;
        ctx.beginPath();
        ctx.moveTo(x, y + nodeR);
        ctx.lineTo(cx, cy - nodeR);
        ctx.strokeStyle = 'rgba(255, 160, 80, 0.4)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.font = '10px "Segoe UI", sans-serif';
        ctx.fillStyle = '#fa8';
        ctx.textAlign = 'center';
        ctx.fillText('A\u207B\u00B9', (x + cx) / 2 + 10, (y + cy) / 2);
        drawTreeNode(node.child1, cx, cy, hSpread * 0.5, vSpread, depth + 1);
    }

    // Draw node
    const pulse = 1 + 0.08 * Math.sin(time * 3 + depth);
    const isActive = !node.isLeaf && (!node.child0 || !node.child1);

    // Glow for active nodes
    if (isActive) {
        const glow = ctx.createRadialGradient(x, y, 0, x, y, nodeR * 2.5);
        glow.addColorStop(0, `rgba(100, 140, 255, ${0.15 + 0.1 * Math.sin(time * 4)})`);
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(x, y, nodeR * 2.5, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.beginPath();
    ctx.arc(x, y, nodeR * pulse, 0, Math.PI * 2);

    if (node.isLeaf) {
        // Leaf: show loop count
        ctx.fillStyle = 'rgba(80, 200, 120, 0.3)';
        ctx.fill();
        ctx.strokeStyle = '#6c6';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Loop symbol
        ctx.font = `bold ${nodeR}px "Segoe UI", sans-serif`;
        ctx.fillStyle = '#8e8';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(node.loops.toString(), x, y);

        // Loop label
        ctx.font = '9px "Segoe UI", sans-serif';
        ctx.fillStyle = '#6a6';
        ctx.fillText(node.loops === 1 ? '1 loop' : node.loops + ' loops', x, y + nodeR + 10);
    } else if (isActive) {
        ctx.fillStyle = 'rgba(80, 120, 200, 0.4)';
        ctx.fill();
        ctx.strokeStyle = '#8af';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Crossing symbol
        ctx.font = `bold ${nodeR * 0.8}px "Segoe UI", sans-serif`;
        ctx.fillStyle = '#cdf';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('X', x, y);
    } else {
        ctx.fillStyle = 'rgba(60, 80, 120, 0.3)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(100, 140, 255, 0.3)';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        ctx.font = `${nodeR * 0.7}px "Segoe UI", sans-serif`;
        ctx.fillStyle = '#88a';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(node.crossingsLeft.toString(), x, y);
    }
}

// Draw a mini knot diagram
function drawMiniKnot(cx, cy, r, knotIdx) {
    const knot = KNOTS[knotIdx];
    const color = knot.color;
    const pts = [];

    if (knotIdx === 0) {
        // Unknot: simple circle
        for (let i = 0; i <= 60; i++) {
            const a = (i / 60) * Math.PI * 2;
            pts.push([cx + Math.cos(a) * r, cy + Math.sin(a) * r]);
        }
    } else if (knotIdx === 1) {
        // Trefoil
        for (let i = 0; i <= 100; i++) {
            const a = (i / 100) * Math.PI * 2;
            const rr = r * (1 + 0.4 * Math.cos(3 * a + time * 0.5));
            pts.push([cx + Math.cos(a) * rr, cy + Math.sin(a) * rr * 0.8]);
        }
    } else if (knotIdx === 2) {
        // Figure-eight
        for (let i = 0; i <= 100; i++) {
            const a = (i / 100) * Math.PI * 2;
            const rr = r * (1 + 0.35 * Math.cos(2 * a + time * 0.3));
            pts.push([cx + Math.cos(a) * rr + Math.sin(2 * a) * r * 0.2, cy + Math.sin(a) * rr]);
        }
    } else {
        // Hopf link - two interlinked curves
        for (let i = 0; i <= 60; i++) {
            const a = (i / 60) * Math.PI * 2;
            pts.push([cx + Math.cos(a) * r * 0.8, cy + Math.sin(a) * r * 0.4]);
        }
        // Draw first component
        drawStrandPath(pts, '#ff6b8a', '#4a0020', 5);
        // Second component
        const pts2 = [];
        for (let i = 0; i <= 60; i++) {
            const a = (i / 60) * Math.PI * 2;
            pts2.push([cx + Math.cos(a) * r * 0.4, cy + Math.sin(a) * r * 0.8]);
        }
        drawStrandPath(pts2, '#6bafff', '#001a4a', 5);
        return;
    }

    drawStrandPath(pts, color, 'rgba(0,0,0,0.5)', 5);
}

function drawStrandPath(points, color, border, lw) {
    if (points.length < 2) return;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(points[0][0], points[0][1]);
    for (let i = 1; i < points.length; i++) ctx.lineTo(points[i][0], points[i][1]);
    ctx.strokeStyle = border;
    ctx.lineWidth = lw + 3;
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(points[0][0], points[0][1]);
    for (let i = 1; i < points.length; i++) ctx.lineTo(points[i][0], points[i][1]);
    ctx.strokeStyle = color;
    ctx.lineWidth = lw;
    ctx.stroke();
}

function drawGrid() {
    ctx.strokeStyle = 'rgba(60, 80, 140, 0.06)';
    ctx.lineWidth = 1;
    for (let x = 0; x < W; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
    for (let y = 0; y < H; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }
}

function animate() {
    ctx.clearRect(0, 0, W, H);
    drawGrid();
    time += 0.015;

    const panelW = 360;
    const drawW = W - panelW - 40;
    const cx = drawW * 0.5 + 20;

    // Background glow
    const gr = ctx.createRadialGradient(cx, H * 0.5, 0, cx, H * 0.5, 400);
    gr.addColorStop(0, 'rgba(60,100,220,0.03)');
    gr.addColorStop(1, 'transparent');
    ctx.fillStyle = gr;
    ctx.beginPath();
    ctx.arc(cx, H * 0.5, 400, 0, Math.PI * 2);
    ctx.fill();

    // Title
    ctx.font = 'bold 26px "Segoe UI", sans-serif';
    ctx.fillStyle = '#8af';
    ctx.textAlign = 'center';
    ctx.fillText('Knot Polynomials', cx, 40);

    ctx.font = '14px "Segoe UI", sans-serif';
    ctx.fillStyle = '#88a';
    ctx.fillText(KNOTS[currentKnot].name + ' - Jones Polynomial via Bracket Expansion', cx, 65);

    // Draw mini knot in top-left area
    const miniX = cx - drawW * 0.3;
    const miniY = 130;
    const miniR = 50;
    drawMiniKnot(miniX, miniY, miniR, currentKnot);

    ctx.font = '13px "Segoe UI", sans-serif';
    ctx.fillStyle = '#aab';
    ctx.textAlign = 'center';
    ctx.fillText(KNOTS[currentKnot].crossings + ' crossings', miniX, miniY + miniR + 20);

    // Draw resolution tree
    if (tree) {
        const treeX = cx;
        const treeY = 110;
        const maxCrossings = KNOTS[currentKnot].crossings;
        const hSpread = Math.min(200, drawW * 0.35);
        const vSpread = Math.min(100, (H - 180) / (maxCrossings + 1));

        drawTreeNode(tree, treeX, treeY, hSpread, vSpread, 0);
    }

    // Skein relation illustration at bottom
    const boty = H - 60;
    ctx.font = '13px "Segoe UI", sans-serif';
    ctx.fillStyle = 'rgba(200,180,120,0.5)';
    ctx.textAlign = 'center';
    ctx.fillText('Skein relation: <K> = A <K\u2080> + A\u207B\u00B9 <K\u221E>    |    Loop value: d = -A\u00B2 - A\u207B\u00B2', cx, boty);

    // Auto-resolve logic
    if (autoRunning && tree) {
        autoTimer++;
        if (autoTimer >= 15) {
            autoTimer = 0;
            const target = findUnresolved(tree);
            if (target) {
                resolveNode(target.node, Math.random() < 0.5 ? 0 : 1);
                checkCompletion();
            } else {
                autoRunning = false;
            }
        }
    }

    requestAnimationFrame(animate);
}

window.reset = function() {
    currentKnot = 0;
    autoRunning = false;
    selectKnot(0);
};

selectKnot(0);
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
