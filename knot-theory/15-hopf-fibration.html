<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hopf Fibration</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; bottom: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.75); backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 170, 255, 0.2); border-radius: 12px;
    padding: 18px 22px; color: #c8d8ff; min-width: 240px;
}
#controls h3 { margin-bottom: 12px; color: #8af; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
.ctrl-row label { flex: 1; }
.ctrl-row input[type=range] { width: 110px; accent-color: #8af; }
.ctrl-row button {
    background: rgba(138,170,255,0.15); color: #8af; border: 1px solid rgba(138,170,255,0.3);
    border-radius: 6px; padding: 4px 12px; cursor: pointer; font-size: 0.85em;
}
.ctrl-row button:hover { background: rgba(138,170,255,0.3); }
.ctrl-row button.active { background: rgba(138,170,255,0.35); }
#info {
    position: fixed; top: 70px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.75); backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 170, 255, 0.2); border-radius: 12px;
    padding: 16px 20px; color: #c8d8ff; max-width: 280px;
}
#info h2 { color: #8af; font-size: 1.1em; margin-bottom: 6px; }
#info p { font-size: 0.82em; line-height: 1.5; opacity: 0.85; margin-bottom: 6px; }
.stat { color: #ffda6e; font-weight: bold; }
#baseSphere {
    position: fixed; bottom: 20px; left: 20px; z-index: 100;
    width: 160px; height: 160px; border-radius: 12px;
    background: rgba(10, 14, 30, 0.75); backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(138,170,255,0.2);
    display: none;
}
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="c"></canvas>
<canvas id="baseSphere" width="160" height="160"></canvas>

<div id="info">
    <h2>Hopf Fibration</h2>
    <p>The <span class="stat">most beautiful map</span> in mathematics. It maps the 3-sphere S3 to the 2-sphere S2.</p>
    <p>Each point on S2 corresponds to a <span class="stat">circle (fiber)</span> in S3. Nearby points give <span class="stat">linked circles</span> forming nested tori.</p>
    <p>Colored by latitude on S2: poles are red/blue, equator is green/yellow.</p>
</div>

<div id="controls">
    <h3>Controls</h3>
    <div class="ctrl-row"><label>Fibers</label><input type="range" id="fiberCount" min="5" max="60" value="30"></div>
    <div class="ctrl-row"><label>Latitude Range</label><input type="range" id="latRange" min="5" max="100" value="80"></div>
    <div class="ctrl-row"><label>Rotation</label><input type="range" id="rotSpeed" min="0" max="100" value="20"></div>
    <div class="ctrl-row"><label>Animation</label><input type="range" id="animSpeed" min="0" max="100" value="30"></div>
    <div class="ctrl-row">
        <button id="btnSphere" class="">Show Base S2</button>
    </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const sphereCanvas = document.getElementById('baseSphere');
const sctx = sphereCanvas.getContext('2d');

let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

let rotX = 0.3, rotY = 0, rotZ = 0;
let dragging = false, lastMX = 0, lastMY = 0;
let showBaseSphere = false;
let animPhase = 0;

canvas.addEventListener('mousedown', e => { dragging = true; lastMX = e.clientX; lastMY = e.clientY; });
canvas.addEventListener('mousemove', e => {
    if (!dragging) return;
    rotY += (e.clientX - lastMX) * 0.005;
    rotX += (e.clientY - lastMY) * 0.005;
    lastMX = e.clientX; lastMY = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('touchstart', e => { e.preventDefault(); dragging = true; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; });
canvas.addEventListener('touchmove', e => { e.preventDefault(); if (!dragging) return; rotY += (e.touches[0].clientX - lastMX) * 0.005; rotX += (e.touches[0].clientY - lastMY) * 0.005; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; });
canvas.addEventListener('touchend', () => dragging = false);

document.getElementById('btnSphere').addEventListener('click', function() {
    showBaseSphere = !showBaseSphere;
    sphereCanvas.style.display = showBaseSphere ? 'block' : 'none';
    this.classList.toggle('active');
});

function rotateXM(x, y, z, a) { const c = Math.cos(a), s = Math.sin(a); return { x, y: y*c - z*s, z: y*s + z*c }; }
function rotateYM(x, y, z, a) { const c = Math.cos(a), s = Math.sin(a); return { x: x*c + z*s, y, z: -x*s + z*c }; }

function project(x, y, z) {
    let p = rotateYM(x, y, z, rotY);
    p = rotateXM(p.x, p.y, p.z, rotX);
    const fov = 6;
    const scale = fov / (fov + p.z) * Math.min(W, H) * 0.18;
    return { x: W/2 + p.x * scale, y: H/2 + p.y * scale, depth: p.z };
}

// Hopf fiber: for a point (theta, phi) on S2, compute the fiber as a curve in R3
// via stereographic projection from S3
function hopfFiber(theta, phi, numPts) {
    const points = [];
    const cosHalf = Math.cos(theta / 2);
    const sinHalf = Math.sin(theta / 2);

    for (let i = 0; i <= numPts; i++) {
        const t = (i / numPts) * Math.PI * 2 + animPhase;

        // Point on S3: (cos(theta/2) * e^{i(t+phi/2)}, sin(theta/2) * e^{i(t-phi/2)})
        // = (cos(theta/2)*cos(t+phi/2), cos(theta/2)*sin(t+phi/2),
        //    sin(theta/2)*cos(t-phi/2), sin(theta/2)*sin(t-phi/2))
        const a = cosHalf * Math.cos(t + phi / 2);
        const b = cosHalf * Math.sin(t + phi / 2);
        const c = sinHalf * Math.cos(t - phi / 2);
        const d = sinHalf * Math.sin(t - phi / 2);

        // Stereographic projection from S3 to R3
        // Project from (0,0,0,-1): (x,y,z) = (a,b,c)/(1+d)
        const denom = 1 + d;
        if (Math.abs(denom) < 0.01) continue; // Skip near-singularity

        const x = a / denom;
        const y = b / denom;
        const z = c / denom;

        // Clamp to reasonable range
        const r = Math.sqrt(x*x + y*y + z*z);
        if (r > 8) continue;

        points.push({ x, y, z });
    }
    return points;
}

function hslToRgb(h, s, l) {
    h /= 360; s /= 100; l /= 100;
    let r, g, b;
    if (s === 0) { r = g = b = l; }
    else {
        const hue2rgb = (p, q, t) => { if (t < 0) t += 1; if (t > 1) t -= 1; if (t < 1/6) return p + (q-p)*6*t; if (t < 1/2) return q; if (t < 2/3) return p + (q-p)*(2/3-t)*6; return p; };
        const q = l < 0.5 ? l*(1+s) : l+s-l*s;
        const p = 2*l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }
    return { r: Math.round(r*255), g: Math.round(g*255), b: Math.round(b*255) };
}

function fiberColor(theta, phi) {
    // Color by latitude on S2 (theta): poles are red/blue, equator is green
    const lat = theta / Math.PI; // 0 to 1
    const hue = lat * 270; // red(0) -> green(120) -> blue(270)
    const sat = 80 + Math.sin(phi * 2) * 15;
    const light = 55 + Math.cos(theta) * 15;
    return hslToRgb(hue, sat, light);
}

function drawBaseSphere(fiberPoints) {
    sctx.fillStyle = '#0a0e1a';
    sctx.fillRect(0, 0, 160, 160);

    const cx = 80, cy = 80, r = 60;

    // Draw sphere outline
    sctx.beginPath();
    sctx.arc(cx, cy, r, 0, Math.PI * 2);
    sctx.strokeStyle = 'rgba(138,170,255,0.3)';
    sctx.lineWidth = 1;
    sctx.stroke();

    // Draw latitude/longitude lines
    for (let i = 1; i < 6; i++) {
        const lat = (i / 6) * Math.PI;
        const y = cy - r * Math.cos(lat);
        const rx = r * Math.sin(lat);
        sctx.beginPath();
        sctx.ellipse(cx, y, rx, rx * 0.3, 0, 0, Math.PI * 2);
        sctx.strokeStyle = 'rgba(138,170,255,0.1)';
        sctx.stroke();
    }

    // Draw points corresponding to fibers
    for (const fp of fiberPoints) {
        const col = fiberColor(fp.theta, fp.phi);
        // Project sphere point to 2D
        const sx = cx + r * Math.sin(fp.theta) * Math.cos(fp.phi + rotY * 0.5) * 0.9;
        const sy = cy - r * Math.cos(fp.theta) * 0.9;
        const sz = Math.sin(fp.theta) * Math.sin(fp.phi + rotY * 0.5);

        if (sz > -0.3) {
            sctx.beginPath();
            sctx.arc(sx, sy, 3, 0, Math.PI * 2);
            sctx.fillStyle = `rgba(${col.r},${col.g},${col.b},${0.5 + sz * 0.5})`;
            sctx.fill();
        }
    }

    // Label
    sctx.fillStyle = '#8af';
    sctx.font = '10px Segoe UI, sans-serif';
    sctx.fillText('Base S2', 55, 155);
}

function animate(time) {
    requestAnimationFrame(animate);

    const rSpeed = document.getElementById('rotSpeed').value / 100;
    const aSpeed = document.getElementById('animSpeed').value / 100;
    const numFibers = parseInt(document.getElementById('fiberCount').value);
    const latRange = document.getElementById('latRange').value / 100;

    if (!dragging) rotY += 0.003 * rSpeed;
    animPhase += 0.01 * aSpeed;

    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    // Generate fiber points on S2
    const fiberDefs = [];
    const rings = Math.ceil(Math.sqrt(numFibers));
    const perRing = Math.ceil(numFibers / rings);

    for (let i = 0; i < rings; i++) {
        const theta = 0.1 + (i / (rings - 1)) * (Math.PI - 0.2) * latRange;
        const nPhi = Math.max(3, Math.round(perRing * Math.sin(theta)));
        for (let j = 0; j < nPhi; j++) {
            if (fiberDefs.length >= numFibers) break;
            const phi = (j / nPhi) * Math.PI * 2;
            fiberDefs.push({ theta, phi });
        }
    }

    // Compute all fibers
    const allFibers = [];
    for (const fd of fiberDefs) {
        const pts = hopfFiber(fd.theta, fd.phi, 100);
        if (pts.length < 10) continue;

        // Average depth for sorting
        let totalDepth = 0;
        const projected = pts.map(p => {
            const s = project(p.x, p.y, p.z);
            totalDepth += s.depth;
            return s;
        });

        allFibers.push({
            projected,
            avgDepth: totalDepth / projected.length,
            theta: fd.theta,
            phi: fd.phi,
            color: fiberColor(fd.theta, fd.phi)
        });
    }

    // Sort fibers back-to-front
    allFibers.sort((a, b) => b.avgDepth - a.avgDepth);

    // Draw fibers
    for (const fiber of allFibers) {
        const { projected, color } = fiber;
        if (projected.length < 2) continue;

        // Glow pass
        ctx.beginPath();
        ctx.moveTo(projected[0].x, projected[0].y);
        for (let i = 1; i < projected.length; i++) {
            const dx = projected[i].x - projected[i-1].x;
            const dy = projected[i].y - projected[i-1].y;
            if (dx*dx + dy*dy > 10000) {
                ctx.moveTo(projected[i].x, projected[i].y);
            } else {
                ctx.lineTo(projected[i].x, projected[i].y);
            }
        }
        const depthFade = Math.max(0.15, Math.min(1, 1 - fiber.avgDepth * 0.15));
        ctx.strokeStyle = `rgba(${color.r},${color.g},${color.b},${depthFade * 0.2})`;
        ctx.lineWidth = 5;
        ctx.stroke();

        // Core pass
        ctx.beginPath();
        ctx.moveTo(projected[0].x, projected[0].y);
        for (let i = 1; i < projected.length; i++) {
            const dx = projected[i].x - projected[i-1].x;
            const dy = projected[i].y - projected[i-1].y;
            if (dx*dx + dy*dy > 10000) {
                ctx.moveTo(projected[i].x, projected[i].y);
            } else {
                ctx.lineTo(projected[i].x, projected[i].y);
            }
        }
        ctx.strokeStyle = `rgba(${color.r},${color.g},${color.b},${depthFade * 0.7})`;
        ctx.lineWidth = 1.5;
        ctx.stroke();
    }

    // Draw base sphere inset
    if (showBaseSphere) {
        drawBaseSphere(fiberDefs);
    }

    // Title
    ctx.fillStyle = '#8af';
    ctx.font = 'bold 16px Segoe UI, sans-serif';
    ctx.fillText('Hopf Fibration - S3 to S2', W/2 - 120, 40);

    // Fiber count label
    ctx.font = '12px Segoe UI, sans-serif';
    ctx.fillStyle = '#c8d8ff88';
    ctx.fillText(allFibers.length + ' fibers', W/2 - 25, 58);
}

window.reset = function() {
    rotX = 0.3; rotY = 0; rotZ = 0;
    animPhase = 0;
    showBaseSphere = false;
    sphereCanvas.style.display = 'none';
    document.getElementById('btnSphere').classList.remove('active');
    document.getElementById('fiberCount').value = 30;
    document.getElementById('latRange').value = 80;
    document.getElementById('rotSpeed').value = 20;
    document.getElementById('animSpeed').value = 30;
};

requestAnimationFrame(animate);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
