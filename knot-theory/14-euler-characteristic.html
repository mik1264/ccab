<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Euler Characteristic</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; bottom: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.75); backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 170, 255, 0.2); border-radius: 12px;
    padding: 18px 22px; color: #c8d8ff; min-width: 240px;
}
#controls h3 { margin-bottom: 12px; color: #8af; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
.ctrl-row label { flex: 1; }
.ctrl-row select { background: rgba(20,30,60,0.8); color: #c8d8ff; border: 1px solid rgba(138,170,255,0.3); border-radius: 4px; padding: 4px 8px; width: 140px; }
.ctrl-row input[type=range] { width: 110px; accent-color: #8af; }
#info {
    position: fixed; top: 70px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.75); backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 170, 255, 0.2); border-radius: 12px;
    padding: 16px 20px; color: #c8d8ff; max-width: 300px;
}
#info h2 { color: #8af; font-size: 1.1em; margin-bottom: 6px; }
#info p { font-size: 0.82em; line-height: 1.5; opacity: 0.85; margin-bottom: 6px; }
.stat { color: #ffda6e; font-weight: bold; }
#formula {
    margin-top: 10px; padding: 12px; background: rgba(138,170,255,0.1); border-radius: 8px;
    text-align: center; font-size: 1.1em;
}
#formula .v { color: #4f8; }
#formula .e { color: #f84; }
#formula .f { color: #48f; }
#formula .chi { color: #ffda6e; font-weight: bold; font-size: 1.3em; }
#surfaceInfo { margin-top: 10px; padding: 8px; background: rgba(138,170,255,0.08); border-radius: 6px; font-size: 0.8em; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="c"></canvas>

<div id="info">
    <h2>Euler Characteristic</h2>
    <p>For any convex polyhedron: <span class="stat">V - E + F = 2</span>. This quantity is a <span class="stat">topological invariant</span>.</p>
    <div id="formula">
        <span class="v" id="vCount">V = 4</span> &minus;
        <span class="e" id="eCount">E = 6</span> +
        <span class="f" id="fCount">F = 4</span> =
        <span class="chi" id="chiVal">2</span>
    </div>
    <div id="surfaceInfo">
        <p>Sphere (genus 0): X = 2</p>
        <p>Torus (genus 1): X = 0</p>
        <p>Double torus (genus 2): X = -2</p>
        <p>Formula: X = 2 - 2g</p>
    </div>
</div>

<div id="controls">
    <h3>Controls</h3>
    <div class="ctrl-row">
        <label>Shape</label>
        <select id="shapeSelect">
            <option value="tetrahedron">Tetrahedron</option>
            <option value="cube">Cube</option>
            <option value="octahedron">Octahedron</option>
            <option value="dodecahedron">Dodecahedron</option>
            <option value="icosahedron">Icosahedron</option>
            <option value="torus">Torus (X=0)</option>
        </select>
    </div>
    <div class="ctrl-row"><label>Rotation</label><input type="range" id="rotSpeed" min="0" max="100" value="30"></div>
    <div class="ctrl-row"><label>Scale</label><input type="range" id="scaleSlider" min="30" max="100" value="60"></div>
    <div class="ctrl-row"><label>Explode</label><input type="range" id="explode" min="0" max="100" value="0"></div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

let rotX = 0.4, rotY = 0, rotZ = 0;
let dragging = false, lastMX = 0, lastMY = 0;
let currentShape = 'tetrahedron';

canvas.addEventListener('mousedown', e => { dragging = true; lastMX = e.clientX; lastMY = e.clientY; });
canvas.addEventListener('mousemove', e => {
    if (!dragging) return;
    rotY += (e.clientX - lastMX) * 0.005;
    rotX += (e.clientY - lastMY) * 0.005;
    lastMX = e.clientX; lastMY = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('touchstart', e => { e.preventDefault(); dragging = true; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; });
canvas.addEventListener('touchmove', e => { e.preventDefault(); if (!dragging) return; rotY += (e.touches[0].clientX - lastMX) * 0.005; rotX += (e.touches[0].clientY - lastMY) * 0.005; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; });
canvas.addEventListener('touchend', () => dragging = false);

document.getElementById('shapeSelect').addEventListener('change', e => {
    currentShape = e.target.value;
    updateStats();
});

function rotateXM(x, y, z, a) { const c = Math.cos(a), s = Math.sin(a); return [x, y*c - z*s, y*s + z*c]; }
function rotateYM(x, y, z, a) { const c = Math.cos(a), s = Math.sin(a); return [x*c + z*s, y, -x*s + z*c]; }

function project(x, y, z, scl) {
    let p = rotateYM(x, y, z, rotY);
    p = rotateXM(p[0], p[1], p[2], rotX);
    const fov = 5;
    const scale = fov / (fov + p[2]) * scl;
    return { x: W/2 + p[0] * scale, y: H/2 + p[1] * scale, depth: p[2] };
}

// Polyhedra definitions
const PHI = (1 + Math.sqrt(5)) / 2;

const polyhedra = {
    tetrahedron: {
        vertices: [[1,1,1],[-1,-1,1],[-1,1,-1],[1,-1,-1]],
        faces: [[0,1,2],[0,1,3],[0,2,3],[1,2,3]],
        V: 4, E: 6, F: 4
    },
    cube: {
        vertices: [[-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],[-1,-1,1],[1,-1,1],[1,1,1],[-1,1,1]],
        faces: [[0,1,2,3],[4,5,6,7],[0,1,5,4],[2,3,7,6],[0,3,7,4],[1,2,6,5]],
        V: 8, E: 12, F: 6
    },
    octahedron: {
        vertices: [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]],
        faces: [[0,2,4],[0,4,3],[0,3,5],[0,5,2],[1,2,4],[1,4,3],[1,3,5],[1,5,2]],
        V: 6, E: 12, F: 8
    },
    dodecahedron: (() => {
        const a = 1, b = 1/PHI, c = PHI;
        const verts = [
            [1,1,1],[1,1,-1],[1,-1,1],[1,-1,-1],
            [-1,1,1],[-1,1,-1],[-1,-1,1],[-1,-1,-1],
            [0,b,c],[0,b,-c],[0,-b,c],[0,-b,-c],
            [b,c,0],[b,-c,0],[-b,c,0],[-b,-c,0],
            [c,0,b],[c,0,-b],[-c,0,b],[-c,0,-b]
        ];
        const faces = [
            [0,8,10,2,16],[0,16,17,1,12],[0,12,14,4,8],
            [1,17,3,11,9],[1,9,5,14,12],[2,10,6,15,13],
            [2,13,3,17,16],[3,13,15,7,11],[4,14,5,19,18],
            [4,18,6,10,8],[5,9,11,7,19],[6,18,19,7,15]
        ];
        return { vertices: verts, faces, V: 20, E: 30, F: 12 };
    })(),
    icosahedron: (() => {
        const t = PHI;
        const verts = [
            [-1,t,0],[1,t,0],[-1,-t,0],[1,-t,0],
            [0,-1,t],[0,1,t],[0,-1,-t],[0,1,-t],
            [t,0,-1],[t,0,1],[-t,0,-1],[-t,0,1]
        ];
        const faces = [
            [0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],
            [1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],
            [3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],
            [4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]
        ];
        return { vertices: verts, faces, V: 12, E: 30, F: 20 };
    })()
};

// Torus mesh
function generateTorus(n) {
    const R = 1.2, r = 0.5;
    const verts = [];
    const faces = [];
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            const u = (i / n) * Math.PI * 2;
            const v = (j / n) * Math.PI * 2;
            verts.push([
                (R + r * Math.cos(v)) * Math.cos(u),
                (R + r * Math.cos(v)) * Math.sin(u),
                r * Math.sin(v)
            ]);
        }
    }
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            const a = i * n + j;
            const b = i * n + (j + 1) % n;
            const c = ((i + 1) % n) * n + (j + 1) % n;
            const d = ((i + 1) % n) * n + j;
            faces.push([a, b, c, d]);
        }
    }
    return { vertices: verts, faces, V: n * n, E: 2 * n * n, F: n * n };
}

function getShape() {
    if (currentShape === 'torus') return generateTorus(10);
    return polyhedra[currentShape];
}

function updateStats() {
    const shape = getShape();
    const chi = shape.V - shape.E + shape.F;
    document.getElementById('vCount').textContent = 'V = ' + shape.V;
    document.getElementById('eCount').textContent = 'E = ' + shape.E;
    document.getElementById('fCount').textContent = 'F = ' + shape.F;
    document.getElementById('chiVal').textContent = chi;
}
updateStats();

function normalize(v) {
    const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]) || 1;
    return [v[0]/len, v[1]/len, v[2]/len];
}

function cross(a, b) {
    return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
}

function sub(a, b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }

function animate(time) {
    requestAnimationFrame(animate);

    const rSpeed = document.getElementById('rotSpeed').value / 100;
    const scl = document.getElementById('scaleSlider').value / 100 * Math.min(W, H) * 0.3;
    const explode = document.getElementById('explode').value / 100;

    if (!dragging) rotY += 0.004 * rSpeed;

    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    const shape = getShape();
    const verts = shape.vertices;

    // Normalize vertices
    let maxR = 0;
    for (const v of verts) {
        const r = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
        if (r > maxR) maxR = r;
    }
    const normScale = 1.5 / (maxR || 1);

    // Build and sort faces
    const drawFaces = [];
    for (let fi = 0; fi < shape.faces.length; fi++) {
        const face = shape.faces[fi];
        const pts3d = face.map(i => [
            verts[i][0] * normScale,
            verts[i][1] * normScale,
            verts[i][2] * normScale
        ]);

        // Face center for explode
        let cx = 0, cy = 0, cz = 0;
        for (const p of pts3d) { cx += p[0]; cy += p[1]; cz += p[2]; }
        cx /= pts3d.length; cy /= pts3d.length; cz /= pts3d.length;
        const cLen = Math.sqrt(cx*cx + cy*cy + cz*cz) || 1;

        const exploded = pts3d.map(p => [
            p[0] + cx/cLen * explode * 0.8,
            p[1] + cy/cLen * explode * 0.8,
            p[2] + cz/cLen * explode * 0.8
        ]);

        const projected = exploded.map(p => project(p[0], p[1], p[2], scl));
        const avgDepth = projected.reduce((s, p) => s + p.depth, 0) / projected.length;

        // Normal for lighting
        if (pts3d.length >= 3) {
            const n = normalize(cross(sub(pts3d[1], pts3d[0]), sub(pts3d[2], pts3d[0])));
            let rn = rotateYM(n[0], n[1], n[2], rotY);
            rn = rotateXM(rn[0], rn[1], rn[2], rotX);
            const facing = rn[2];

            drawFaces.push({ projected, avgDepth, facing, faceIdx: fi });
        }
    }

    drawFaces.sort((a, b) => b.avgDepth - a.avgDepth);

    // Draw faces
    for (const df of drawFaces) {
        const { projected, facing, faceIdx } = df;
        ctx.beginPath();
        ctx.moveTo(projected[0].x, projected[0].y);
        for (let i = 1; i < projected.length; i++) ctx.lineTo(projected[i].x, projected[i].y);
        ctx.closePath();

        const brightness = 0.2 + Math.abs(facing) * 0.6;
        const hue = (faceIdx * 37 + 200) % 360;
        ctx.fillStyle = `hsla(${hue}, 50%, ${brightness * 50}%, 0.85)`;
        ctx.fill();
        ctx.strokeStyle = `hsla(${hue}, 60%, ${brightness * 80}%, 0.6)`;
        ctx.lineWidth = 1.2;
        ctx.stroke();
    }

    // Draw vertices as dots
    const projVerts = verts.map((v, i) => {
        const nv = [v[0] * normScale, v[1] * normScale, v[2] * normScale];
        return project(nv[0], nv[1], nv[2], scl);
    });

    if (explode < 0.01) {
        for (const pv of projVerts) {
            ctx.beginPath();
            ctx.arc(pv.x, pv.y, 3, 0, Math.PI * 2);
            ctx.fillStyle = '#4f8';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }
    }

    // Draw edges (wireframe overlay)
    if (explode < 0.01) {
        const edgeSet = new Set();
        for (const face of shape.faces) {
            for (let i = 0; i < face.length; i++) {
                const a = face[i], b = face[(i + 1) % face.length];
                const key = Math.min(a, b) + ',' + Math.max(a, b);
                if (!edgeSet.has(key)) {
                    edgeSet.add(key);
                    ctx.beginPath();
                    ctx.moveTo(projVerts[a].x, projVerts[a].y);
                    ctx.lineTo(projVerts[b].x, projVerts[b].y);
                    ctx.strokeStyle = 'rgba(255,136,68,0.25)';
                    ctx.lineWidth = 0.8;
                    ctx.stroke();
                }
            }
        }
    }

    // Title
    ctx.fillStyle = '#8af';
    ctx.font = 'bold 16px Segoe UI, sans-serif';
    ctx.fillText('Euler Characteristic: V - E + F = Topology', W/2 - 190, 40);
}

window.reset = function() {
    rotX = 0.4; rotY = 0; rotZ = 0;
    currentShape = 'tetrahedron';
    document.getElementById('shapeSelect').value = 'tetrahedron';
    document.getElementById('rotSpeed').value = 30;
    document.getElementById('scaleSlider').value = 60;
    document.getElementById('explode').value = 0;
    updateStats();
};

requestAnimationFrame(animate);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
