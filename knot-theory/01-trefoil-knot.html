<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Trefoil Knot</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; bottom: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.75); backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 170, 255, 0.2); border-radius: 12px;
    padding: 18px 22px; color: #c8d8ff; min-width: 240px;
}
#controls h3 { margin-bottom: 12px; color: #8af; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
.ctrl-row label { flex: 1; }
.ctrl-row input[type=range] { width: 110px; accent-color: #8af; }
.ctrl-row select { background: rgba(20,30,60,0.8); color: #c8d8ff; border: 1px solid rgba(138,170,255,0.3); border-radius: 4px; padding: 2px 6px; }
.ctrl-row button {
    background: rgba(138,170,255,0.15); color: #8af; border: 1px solid rgba(138,170,255,0.3);
    border-radius: 6px; padding: 4px 12px; cursor: pointer; font-size: 0.85em;
}
.ctrl-row button:hover { background: rgba(138,170,255,0.3); }
#info {
    position: fixed; top: 70px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.75); backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 170, 255, 0.2); border-radius: 12px;
    padding: 16px 20px; color: #c8d8ff; max-width: 260px;
}
#info h2 { color: #8af; font-size: 1.1em; margin-bottom: 6px; }
#info p { font-size: 0.82em; line-height: 1.5; opacity: 0.85; }
.stat { color: #ffda6e; font-weight: bold; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="c"></canvas>

<div id="info">
    <h2>Trefoil Knot (3&#8321;)</h2>
    <p>The simplest non-trivial knot. It cannot be untangled into a simple circle without cutting.</p>
    <p>Crossing number: <span class="stat">3</span></p>
    <p>Discovered in antiquity. It is a <span class="stat">(2,3)-torus knot</span>.</p>
</div>

<div id="controls">
    <h3>Controls</h3>
    <div class="ctrl-row"><label>Rotation Speed</label><input type="range" id="speed" min="0" max="100" value="30"></div>
    <div class="ctrl-row"><label>Tube Thickness</label><input type="range" id="thickness" min="3" max="30" value="12"></div>
    <div class="ctrl-row"><label>Glow Intensity</label><input type="range" id="glow" min="0" max="100" value="60"></div>
    <div class="ctrl-row">
        <label>Color Scheme</label>
        <select id="colorScheme">
            <option value="rainbow">Rainbow</option>
            <option value="solid">Solid Blue</option>
            <option value="depth">Depth Shaded</option>
            <option value="fire">Fire</option>
        </select>
    </div>
    <div class="ctrl-row">
        <label>Wireframe</label>
        <input type="checkbox" id="wireframe">
    </div>
    <div class="ctrl-row"><button onclick="window.reset()">Reset View</button></div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// Camera state
let rotY = 0, rotX = 0.3;
let autoRotY = 0;
let dragging = false, lastMX = 0, lastMY = 0;
let userRotY = 0, userRotX = 0.3;
const FOV = 500;

// Controls
const speedSlider = document.getElementById('speed');
const thicknessSlider = document.getElementById('thickness');
const glowSlider = document.getElementById('glow');
const colorSelect = document.getElementById('colorScheme');
const wireframeCheck = document.getElementById('wireframe');

// Mouse drag
canvas.addEventListener('mousedown', e => { dragging = true; lastMX = e.clientX; lastMY = e.clientY; });
canvas.addEventListener('mousemove', e => {
    if (!dragging) return;
    userRotY += (e.clientX - lastMX) * 0.005;
    userRotX += (e.clientY - lastMY) * 0.005;
    userRotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, userRotX));
    lastMX = e.clientX; lastMY = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);

// Touch drag
canvas.addEventListener('touchstart', e => {
    if (e.target !== canvas) return;
    dragging = true; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY;
}, { passive: true });
canvas.addEventListener('touchmove', e => {
    if (!dragging) return;
    userRotY += (e.touches[0].clientX - lastMX) * 0.005;
    userRotX += (e.touches[0].clientY - lastMY) * 0.005;
    userRotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, userRotX));
    lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY;
}, { passive: true });
canvas.addEventListener('touchend', () => dragging = false);

// 3D math
function rotateYAxis(x, y, z, a) {
    return { x: x * Math.cos(a) + z * Math.sin(a), y: y, z: -x * Math.sin(a) + z * Math.cos(a) };
}
function rotateXAxis(x, y, z, a) {
    return { x: x, y: y * Math.cos(a) - z * Math.sin(a), z: y * Math.sin(a) + z * Math.cos(a) };
}
function project(x, y, z) {
    const scale = FOV / (FOV + z);
    return { sx: W / 2 + x * scale, sy: H / 2 + y * scale, depth: z, scale: scale };
}

// Trefoil parametric
function trefoil(t) {
    const s = 80;
    return {
        x: (Math.sin(t) + 2 * Math.sin(2 * t)) * s,
        y: (Math.cos(t) - 2 * Math.cos(2 * t)) * s,
        z: -Math.sin(3 * t) * s
    };
}

// Star background
const stars = [];
for (let i = 0; i < 200; i++) {
    stars.push({ x: Math.random() * 2 - 1, y: Math.random() * 2 - 1, s: Math.random() * 1.5 + 0.5, b: Math.random() });
}

function drawStars() {
    for (const star of stars) {
        const bri = 0.3 + 0.2 * Math.sin(performance.now() * 0.001 + star.b * 10);
        ctx.fillStyle = `rgba(180,200,255,${bri})`;
        ctx.fillRect(star.x * W * 0.5 + W * 0.5, star.y * H * 0.5 + H * 0.5, star.s, star.s);
    }
}

function getColor(t, z, scheme) {
    const norm = t / (Math.PI * 2);
    const depthFactor = 0.5 + 0.5 * ((z + 100) / 200);
    switch (scheme) {
        case 'rainbow':
            return `hsl(${norm * 360}, 80%, ${40 + depthFactor * 25}%)`;
        case 'solid':
            return `hsl(220, 70%, ${35 + depthFactor * 30}%)`;
        case 'depth':
            return `hsl(${200 + depthFactor * 40}, 60%, ${30 + depthFactor * 40}%)`;
        case 'fire':
            return `hsl(${norm * 60}, 90%, ${35 + depthFactor * 30}%)`;
        default:
            return `hsl(${norm * 360}, 80%, ${40 + depthFactor * 25}%)`;
    }
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);
    drawStars();

    const rotSpeed = speedSlider.value / 3000;
    autoRotY += rotSpeed;
    rotY = autoRotY + userRotY;
    rotX = userRotX;

    const N = 400;
    const segments = [];
    const tubeW = parseFloat(thicknessSlider.value);
    const scheme = colorSelect.value;
    const isWire = wireframeCheck.checked;
    const glowIntensity = glowSlider.value / 100;

    for (let i = 0; i < N; i++) {
        const t0 = (i / N) * Math.PI * 2;
        const t1 = ((i + 1) / N) * Math.PI * 2;
        const p0 = trefoil(t0);
        const p1 = trefoil(t1);

        let r0 = rotateYAxis(p0.x, p0.y, p0.z, rotY);
        r0 = rotateXAxis(r0.x, r0.y, r0.z, rotX);
        let r1 = rotateYAxis(p1.x, p1.y, p1.z, rotY);
        r1 = rotateXAxis(r1.x, r1.y, r1.z, rotX);

        const s0 = project(r0.x, r0.y, r0.z);
        const s1 = project(r1.x, r1.y, r1.z);

        const avgZ = (r0.z + r1.z) / 2;
        segments.push({ s0, s1, avgZ, t: t0, z: avgZ });
    }

    // Sort by depth (painter's algorithm)
    segments.sort((a, b) => b.avgZ - a.avgZ);

    for (const seg of segments) {
        const { s0, s1, t, z } = seg;
        const color = getColor(t, z, scheme);
        const w = tubeW * ((s0.scale + s1.scale) / 2);

        if (glowIntensity > 0) {
            ctx.save();
            ctx.shadowBlur = 20 * glowIntensity;
            ctx.shadowColor = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = w + 4;
            ctx.globalAlpha = 0.3 * glowIntensity;
            ctx.beginPath();
            ctx.moveTo(s0.sx, s0.sy);
            ctx.lineTo(s1.sx, s1.sy);
            ctx.stroke();
            ctx.restore();
        }

        // Dark outline for tube effect
        if (!isWire) {
            ctx.strokeStyle = '#050810';
            ctx.lineWidth = w + 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(s0.sx, s0.sy);
            ctx.lineTo(s1.sx, s1.sy);
            ctx.stroke();
        }

        // Main color
        ctx.strokeStyle = color;
        ctx.lineWidth = isWire ? 1.5 : w;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(s0.sx, s0.sy);
        ctx.lineTo(s1.sx, s1.sy);
        ctx.stroke();

        // Highlight for tube roundness
        if (!isWire) {
            ctx.strokeStyle = `rgba(255,255,255,0.15)`;
            ctx.lineWidth = w * 0.3;
            ctx.beginPath();
            ctx.moveTo(s0.sx - w * 0.15, s0.sy - w * 0.15);
            ctx.lineTo(s1.sx - w * 0.15, s1.sy - w * 0.15);
            ctx.stroke();
        }
    }

    requestAnimationFrame(draw);
}

window.reset = function() {
    autoRotY = 0;
    userRotY = 0;
    userRotX = 0.3;
    speedSlider.value = 30;
    thicknessSlider.value = 12;
    glowSlider.value = 60;
    colorSelect.value = 'rainbow';
    wireframeCheck.checked = false;
};

requestAnimationFrame(draw);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
