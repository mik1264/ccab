<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Braid Groups - Knot Theory</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: #e0e0e0; }
canvas { display: block; }
a.back { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a.back:hover { color: #adf; }

#panel {
    position: fixed; top: 20px; right: 20px; width: 330px;
    background: rgba(10, 14, 30, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100, 140, 255, 0.2); border-radius: 16px;
    padding: 20px; z-index: 100; max-height: calc(100vh - 40px); overflow-y: auto;
}
#panel h2 { color: #8af; font-size: 1.2em; margin-bottom: 8px; }
#panel p { font-size: 0.82em; line-height: 1.5; color: #aab; margin-bottom: 10px; }

.controls-row { display: flex; gap: 6px; margin-bottom: 8px; flex-wrap: wrap; }
.ctrl-btn {
    padding: 8px 14px; border-radius: 8px; border: 1px solid rgba(100,140,255,0.3);
    background: rgba(40,60,120,0.3); color: #cdf; cursor: pointer; font-size: 0.9em;
    transition: all 0.3s; font-weight: 600;
}
.ctrl-btn:hover { background: rgba(60,90,180,0.4); border-color: rgba(130,170,255,0.5); }
.ctrl-btn.inv { color: #faa; border-color: rgba(255,120,100,0.3); background: rgba(120,40,40,0.3); }
.ctrl-btn.inv:hover { background: rgba(160,50,50,0.4); }
.ctrl-btn.action { color: #afa; border-color: rgba(100,255,140,0.3); background: rgba(40,120,60,0.3); }
.ctrl-btn.action:hover { background: rgba(50,160,70,0.4); }

#word-display {
    padding: 12px; margin: 10px 0; background: rgba(20, 30, 60, 0.6);
    border-radius: 10px; border: 1px solid rgba(100,140,255,0.15);
    font-family: 'Courier New', monospace; font-size: 1em; color: #8af;
    min-height: 40px; word-wrap: break-word;
}
#word-label { font-size: 0.8em; color: #667; margin-bottom: 4px; }

.slider-row { display: flex; align-items: center; gap: 10px; margin: 10px 0; }
.slider-row label { font-size: 0.85em; color: #aab; white-space: nowrap; }
.slider-row input[type="range"] { flex: 1; accent-color: #8af; }
.slider-row .val { color: #8af; font-weight: 700; min-width: 20px; text-align: center; }

.preset-btns { display: flex; gap: 6px; margin: 10px 0; flex-wrap: wrap; }
.preset-btn {
    padding: 7px 12px; border-radius: 8px; border: 1px solid rgba(200,160,80,0.3);
    background: rgba(100,80,30,0.2); color: #da5; cursor: pointer; font-size: 0.82em;
    transition: all 0.3s;
}
.preset-btn:hover { background: rgba(140,110,40,0.3); }

.relation-box {
    padding: 10px; background: rgba(200,160,80,0.08); border-left: 3px solid #da5;
    border-radius: 0 8px 8px 0; font-size: 0.78em; line-height: 1.6; color: #cb8; margin-top: 10px;
}
.relation-box code { color: #da5; font-family: 'Courier New', monospace; }

#closure-toggle {
    display: block; width: 100%; padding: 10px; margin-top: 10px;
    background: rgba(100, 140, 255, 0.15); border: 1px solid rgba(100,140,255,0.3);
    border-radius: 10px; color: #8af; cursor: pointer; font-size: 0.85em; transition: all 0.3s;
}
#closure-toggle:hover { background: rgba(100,140,255,0.25); }
#closure-toggle.active { background: rgba(100,140,255,0.3); border-color: #8af; }
</style>
</head>
<body>
<a href="index.html" class="back">&larr; Back</a>
<canvas id="canvas"></canvas>

<div id="panel">
    <h2>Braid Groups</h2>
    <p>Build braids by adding crossing operations. Each sigma_i means strand i crosses over strand i+1.</p>

    <div class="slider-row">
        <label>Strands:</label>
        <input type="range" id="strand-slider" min="2" max="6" value="3" oninput="setStrands(+this.value)">
        <span class="val" id="strand-val">3</span>
    </div>

    <div id="sigma-btns"></div>

    <div class="controls-row">
        <button class="ctrl-btn action" onclick="undoOp()">Undo</button>
        <button class="ctrl-btn action" onclick="clearBraid()">Clear</button>
    </div>

    <div id="word-label">Braid word:</div>
    <div id="word-display">(empty)</div>

    <div class="preset-btns">
        <button class="preset-btn" onclick="loadPreset('trefoil')">Trefoil</button>
        <button class="preset-btn" onclick="loadPreset('figure8')">Figure-8</button>
        <button class="preset-btn" onclick="loadPreset('cinquefoil')">Cinquefoil</button>
        <button class="preset-btn" onclick="loadPreset('twist3')">Full Twist</button>
    </div>

    <button id="closure-toggle" onclick="toggleClosure()">Show Closure (form knot/link)</button>

    <div class="relation-box">
        <strong>Braid Group Relations:</strong><br>
        <code>sigma_i sigma_{i+1} sigma_i = sigma_{i+1} sigma_i sigma_{i+1}</code><br>
        (Yang-Baxter equation)<br><br>
        <code>sigma_i sigma_j = sigma_j sigma_i</code> when |i-j| &ge; 2
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

let numStrands = 3;
let operations = []; // {i: strand index, inv: boolean}
let showClosure = false;
let time = 0;
let animProgress = 1;

const STRAND_COLORS = [
    '#ff6b8a', '#6bafff', '#6bffa8', '#ffa86b', '#c86bff', '#ffff6b'
];
const STRAND_BORDERS = [
    '#aa2040', '#2060aa', '#20aa60', '#aa6020', '#7020aa', '#aaaa20'
];

function setStrands(n) {
    numStrands = n;
    document.getElementById('strand-val').textContent = n;
    operations = [];
    updateWordDisplay();
    buildSigmaButtons();
}

function buildSigmaButtons() {
    const container = document.getElementById('sigma-btns');
    let html = '<div class="controls-row">';
    for (let i = 1; i < numStrands; i++) {
        html += `<button class="ctrl-btn" onclick="addOp(${i},false)">\u03C3<sub>${i}</sub></button>`;
    }
    html += '</div><div class="controls-row">';
    for (let i = 1; i < numStrands; i++) {
        html += `<button class="ctrl-btn inv" onclick="addOp(${i},true)">\u03C3<sub>${i}</sub><sup>-1</sup></button>`;
    }
    html += '</div>';
    container.innerHTML = html;
}

function addOp(i, inv) {
    operations.push({ i: i, inv: inv });
    animProgress = 0;
    updateWordDisplay();
}

function undoOp() {
    operations.pop();
    updateWordDisplay();
}

function clearBraid() {
    operations = [];
    updateWordDisplay();
}

function updateWordDisplay() {
    const el = document.getElementById('word-display');
    if (operations.length === 0) {
        el.textContent = '(empty)';
        return;
    }
    el.innerHTML = operations.map(op => {
        const sub = `<sub>${op.i}</sub>`;
        const sup = op.inv ? '<sup>-1</sup>' : '';
        return `\u03C3${sub}${sup}`;
    }).join(' ');
}

function loadPreset(name) {
    operations = [];
    if (name === 'trefoil') {
        numStrands = 3;
        operations = [{i:1,inv:false},{i:1,inv:false},{i:1,inv:false}];
    } else if (name === 'figure8') {
        numStrands = 3;
        operations = [{i:1,inv:false},{i:2,inv:true},{i:1,inv:false},{i:2,inv:true}];
    } else if (name === 'cinquefoil') {
        numStrands = 3;
        for (let k = 0; k < 5; k++) operations.push({i:1,inv:false});
    } else if (name === 'twist3') {
        numStrands = 3;
        operations = [{i:1,inv:false},{i:2,inv:false},{i:1,inv:false},{i:2,inv:false},{i:1,inv:false},{i:2,inv:false}];
    }
    document.getElementById('strand-slider').value = numStrands;
    document.getElementById('strand-val').textContent = numStrands;
    buildSigmaButtons();
    updateWordDisplay();
}

function toggleClosure() {
    showClosure = !showClosure;
    const btn = document.getElementById('closure-toggle');
    btn.classList.toggle('active', showClosure);
    btn.textContent = showClosure ? 'Hide Closure' : 'Show Closure (form knot/link)';
}

function drawGrid() {
    ctx.strokeStyle = 'rgba(60, 80, 140, 0.06)';
    ctx.lineWidth = 1;
    for (let x = 0; x < W; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
    for (let y = 0; y < H; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }
}

function drawStrandSegment(x1, y1, x2, y2, color, border, lw, dashed) {
    ctx.lineCap = 'round';
    if (dashed) ctx.setLineDash([8, 6]);
    else ctx.setLineDash([]);

    ctx.beginPath();
    ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
    ctx.strokeStyle = border;
    ctx.lineWidth = lw + 3;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
    ctx.strokeStyle = color;
    ctx.lineWidth = lw;
    ctx.stroke();

    ctx.setLineDash([]);
}

function drawCurvedStrand(x1, y1, x2, y2, cx1, cy1, color, border, lw) {
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.quadraticCurveTo(cx1, cy1, x2, y2);
    ctx.strokeStyle = border;
    ctx.lineWidth = lw + 3;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.quadraticCurveTo(cx1, cy1, x2, y2);
    ctx.strokeStyle = color;
    ctx.lineWidth = lw;
    ctx.stroke();
}

function animate() {
    ctx.clearRect(0, 0, W, H);
    drawGrid();
    time += 0.015;
    if (animProgress < 1) animProgress = Math.min(1, animProgress + 0.04);

    const panelWidth = 350;
    const drawW = W - panelWidth - 40;
    const drawH = H - 100;
    const cx = drawW * 0.5 + 20;
    const topY = 60;
    const rowH = Math.min(80, drawH / (operations.length + 2));
    const strandSpacing = Math.min(80, drawW / (numStrands + 1));
    const lw = 6;

    // Title
    ctx.font = 'bold 28px "Segoe UI", sans-serif';
    ctx.fillStyle = '#8af';
    ctx.textAlign = 'center';
    ctx.fillText('Braid Groups', cx, 40);

    // Background glow
    const gr = ctx.createRadialGradient(cx, H * 0.5, 0, cx, H * 0.5, 400);
    gr.addColorStop(0, 'rgba(60,100,220,0.03)');
    gr.addColorStop(1, 'transparent');
    ctx.fillStyle = gr;
    ctx.beginPath();
    ctx.arc(cx, H * 0.5, 400, 0, Math.PI * 2);
    ctx.fill();

    // Track strand positions (permutation)
    let strandPos = [];
    for (let s = 0; s < numStrands; s++) strandPos.push(s);

    function getX(idx) {
        return cx - (numStrands - 1) * strandSpacing / 2 + idx * strandSpacing;
    }

    // Draw top connection points
    for (let s = 0; s < numStrands; s++) {
        const x = getX(s);
        ctx.beginPath();
        ctx.arc(x, topY, 6, 0, Math.PI * 2);
        ctx.fillStyle = STRAND_COLORS[s];
        ctx.fill();
        ctx.font = 'bold 12px "Segoe UI", sans-serif';
        ctx.fillStyle = '#aab';
        ctx.textAlign = 'center';
        ctx.fillText((s + 1).toString(), x, topY - 14);
    }

    // Draw each operation row
    for (let op = 0; op < operations.length; op++) {
        const { i, inv } = operations[op];
        const y1 = topY + op * rowH + 10;
        const y2 = y1 + rowH;

        // Determine which strand colors are at which positions
        const leftIdx = i - 1; // 0-indexed position for sigma_i
        const rightIdx = i;

        const leftStrand = strandPos[leftIdx];
        const rightStrand = strandPos[rightIdx];

        const x1 = getX(leftIdx);
        const x2 = getX(rightIdx);

        // Determine visual progress for last operation
        let prog = 1;
        if (op === operations.length - 1) prog = animProgress;

        const midY = (y1 + y2) / 2;
        const crossX1 = x1 + (x2 - x1) * prog;
        const crossX2 = x2 + (x1 - x2) * prog;

        // Draw non-crossing strands
        for (let s = 0; s < numStrands; s++) {
            if (s !== leftIdx && s !== rightIdx) {
                const x = getX(s);
                drawStrandSegment(x, y1, x, y2, STRAND_COLORS[strandPos[s]], STRAND_BORDERS[strandPos[s]], lw);
            }
        }

        // Draw crossing strands
        if (!inv) {
            // sigma_i: left goes over right
            // Under strand (right goes to left): draw with gap
            drawCurvedStrand(x2, y1, crossX2, y2, (x1 + x2) / 2, midY + 5, STRAND_COLORS[rightStrand], STRAND_BORDERS[rightStrand], lw);
            // Over strand (left goes to right): draw on top
            drawCurvedStrand(x1, y1, crossX1, y2, (x1 + x2) / 2, midY - 5, STRAND_COLORS[leftStrand], STRAND_BORDERS[leftStrand], lw);

            // Over/under indicator
            ctx.font = 'bold 10px "Segoe UI", sans-serif';
            ctx.fillStyle = 'rgba(150,180,255,0.4)';
            ctx.textAlign = 'center';
            ctx.fillText('over', (x1 + x2) / 2, midY - 12);
        } else {
            // sigma_i^-1: right goes over left
            drawCurvedStrand(x1, y1, crossX2, y2, (x1 + x2) / 2, midY + 5, STRAND_COLORS[leftStrand], STRAND_BORDERS[leftStrand], lw);
            drawCurvedStrand(x2, y1, crossX1, y2, (x1 + x2) / 2, midY - 5, STRAND_COLORS[rightStrand], STRAND_BORDERS[rightStrand], lw);

            ctx.font = 'bold 10px "Segoe UI", sans-serif';
            ctx.fillStyle = 'rgba(255,150,150,0.4)';
            ctx.textAlign = 'center';
            ctx.fillText('over', (x1 + x2) / 2, midY - 12);
        }

        // Operation label
        ctx.font = '12px "Segoe UI", sans-serif';
        ctx.fillStyle = inv ? '#faa' : '#aaf';
        ctx.textAlign = 'left';
        ctx.fillText(`\u03C3${i}${inv ? '\u207B\u00B9' : ''}`, getX(numStrands - 1) + 30, midY + 4);

        // Update permutation
        if (prog >= 1) {
            const tmp = strandPos[leftIdx];
            strandPos[leftIdx] = strandPos[rightIdx];
            strandPos[rightIdx] = tmp;
        }
    }

    // Draw trailing strands below last operation
    const bottomY = topY + operations.length * rowH + 10;
    const trailY = bottomY + 40;
    for (let s = 0; s < numStrands; s++) {
        const x = getX(s);
        drawStrandSegment(x, bottomY, x, trailY, STRAND_COLORS[strandPos[s]], STRAND_BORDERS[strandPos[s]], lw, !showClosure);
    }

    // Draw bottom dots
    for (let s = 0; s < numStrands; s++) {
        const x = getX(s);
        ctx.beginPath();
        ctx.arc(x, trailY, 6, 0, Math.PI * 2);
        ctx.fillStyle = STRAND_COLORS[strandPos[s]];
        ctx.fill();
    }

    // Draw closure arcs if enabled
    if (showClosure && operations.length > 0) {
        ctx.globalAlpha = 0.5 + 0.2 * Math.sin(time * 2);
        for (let s = 0; s < numStrands; s++) {
            const topX = getX(s);
            const botX = getX(strandPos.indexOf(s));
            // Draw arc connecting bottom to top on the left side
            const arcX = getX(0) - 60 - s * 20;
            ctx.setLineDash([6, 4]);
            ctx.beginPath();
            ctx.moveTo(botX, trailY);
            ctx.quadraticCurveTo(arcX, (topY + trailY) / 2, topX, topY);
            ctx.strokeStyle = STRAND_COLORS[s];
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.setLineDash([]);
        }
        ctx.globalAlpha = 1;

        // Closure label
        ctx.font = '14px "Segoe UI", sans-serif';
        ctx.fillStyle = '#da5';
        ctx.textAlign = 'center';
        ctx.fillText('Closure forms a knot/link', cx, trailY + 30);
    }

    // Show strand count info
    if (operations.length === 0) {
        ctx.font = '16px "Segoe UI", sans-serif';
        ctx.fillStyle = 'rgba(150,170,200,0.4)';
        ctx.textAlign = 'center';
        ctx.fillText('Add crossing operations to build a braid', cx, H * 0.6);
    }

    requestAnimationFrame(animate);
}

window.reset = function() {
    numStrands = 3;
    operations = [];
    showClosure = false;
    document.getElementById('strand-slider').value = 3;
    document.getElementById('strand-val').textContent = '3';
    document.getElementById('closure-toggle').classList.remove('active');
    document.getElementById('closure-toggle').textContent = 'Show Closure (form knot/link)';
    buildSigmaButtons();
    updateWordDisplay();
};

buildSigmaButtons();
updateWordDisplay();
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
