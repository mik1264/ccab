<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mobius Strip</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; bottom: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.75); backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 170, 255, 0.2); border-radius: 12px;
    padding: 18px 22px; color: #c8d8ff; min-width: 240px;
}
#controls h3 { margin-bottom: 12px; color: #8af; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
.ctrl-row label { flex: 1; }
.ctrl-row input[type=range] { width: 110px; accent-color: #8af; }
.ctrl-row button {
    background: rgba(138,170,255,0.15); color: #8af; border: 1px solid rgba(138,170,255,0.3);
    border-radius: 6px; padding: 4px 12px; cursor: pointer; font-size: 0.85em;
}
.ctrl-row button:hover { background: rgba(138,170,255,0.3); }
.ctrl-row button.active { background: rgba(138,170,255,0.4); }
#info {
    position: fixed; top: 70px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.75); backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 170, 255, 0.2); border-radius: 12px;
    padding: 16px 20px; color: #c8d8ff; max-width: 280px;
}
#info h2 { color: #8af; font-size: 1.1em; margin-bottom: 6px; }
#info p { font-size: 0.82em; line-height: 1.5; opacity: 0.85; margin-bottom: 6px; }
.stat { color: #ffda6e; font-weight: bold; }
#antStatus { margin-top: 8px; padding: 8px; background: rgba(138,170,255,0.1); border-radius: 6px; font-size: 0.8em; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="c"></canvas>

<div id="info">
    <h2>Mobius Strip</h2>
    <p>A surface with <span class="stat">only one side</span> and <span class="stat">one edge</span>. Walk along it and you return to start on the "other side" without crossing an edge.</p>
    <p>The ant proves it: after <span class="stat">one loop</span> it's on the "opposite" face. After <span class="stat">two loops</span> it returns to the start.</p>
    <div id="antStatus">Ant loops: <span class="stat" id="loopCount">0</span></div>
</div>

<div id="controls">
    <h3>Controls</h3>
    <div class="ctrl-row"><label>Strip Width</label><input type="range" id="widthSlider" min="10" max="80" value="40"></div>
    <div class="ctrl-row"><label>Ant Speed</label><input type="range" id="antSpeed" min="5" max="80" value="30"></div>
    <div class="ctrl-row"><label>Rotation</label><input type="range" id="rotSpeed" min="0" max="100" value="25"></div>
    <div class="ctrl-row">
        <button id="btnWire">Wireframe</button>
        <button id="btnFill" class="active">Filled</button>
    </div>
    <div class="ctrl-row">
        <button id="btnCut">Cut Down Middle</button>
        <button id="btnRestore">Restore</button>
    </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// State
let rotX = 0.3, rotY = 0, rotZ = 0;
let autoRotate = true;
let wireframe = false;
let stripWidth = 0.4;
let antParam = 0; // u parameter for ant, goes 0 to 4pi (two loops)
let antLoops = 0;
let cutting = false;
let cutProgress = 0;
let cutComplete = false;

// Mouse drag
let dragging = false, lastMX = 0, lastMY = 0;
canvas.addEventListener('mousedown', e => { dragging = true; lastMX = e.clientX; lastMY = e.clientY; });
canvas.addEventListener('mousemove', e => {
    if (!dragging) return;
    rotY += (e.clientX - lastMX) * 0.005;
    rotX += (e.clientY - lastMY) * 0.005;
    lastMX = e.clientX; lastMY = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);

// Touch support
canvas.addEventListener('touchstart', e => { e.preventDefault(); dragging = true; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; });
canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (!dragging) return;
    rotY += (e.touches[0].clientX - lastMX) * 0.005;
    rotX += (e.touches[0].clientY - lastMY) * 0.005;
    lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY;
});
canvas.addEventListener('touchend', () => dragging = false);

// Controls
document.getElementById('widthSlider').addEventListener('input', e => { stripWidth = e.target.value / 100; });
document.getElementById('btnWire').addEventListener('click', () => {
    wireframe = true;
    document.getElementById('btnWire').classList.add('active');
    document.getElementById('btnFill').classList.remove('active');
});
document.getElementById('btnFill').addEventListener('click', () => {
    wireframe = false;
    document.getElementById('btnFill').classList.add('active');
    document.getElementById('btnWire').classList.remove('active');
});
document.getElementById('btnCut').addEventListener('click', () => {
    if (!cutting && !cutComplete) { cutting = true; cutProgress = 0; }
});
document.getElementById('btnRestore').addEventListener('click', () => {
    cutting = false; cutProgress = 0; cutComplete = false;
});

function rotateX(x, y, z, a) {
    const c = Math.cos(a), s = Math.sin(a);
    return { x, y: y * c - z * s, z: y * s + z * c };
}
function rotateY(x, y, z, a) {
    const c = Math.cos(a), s = Math.sin(a);
    return { x: x * c + z * s, y, z: -x * s + z * c };
}
function rotateZ(x, y, z, a) {
    const c = Math.cos(a), s = Math.sin(a);
    return { x: x * c - y * s, y: x * s + y * c, z };
}

function mobiusPoint(u, v, w) {
    // w is the width parameter
    const x = (1 + (v * w) * Math.cos(u / 2)) * Math.cos(u);
    const y = (1 + (v * w) * Math.cos(u / 2)) * Math.sin(u);
    const z = (v * w) * Math.sin(u / 2);
    return { x, y, z };
}

function project(x, y, z) {
    let p = rotateY(x, y, z, rotY);
    p = rotateX(p.x, p.y, p.z, rotX);
    p = rotateZ(p.x, p.y, p.z, rotZ);
    const fov = 4;
    const scale = fov / (fov + p.z) * Math.min(W, H) * 0.28;
    return { x: W / 2 + p.x * scale, y: H / 2 + p.y * scale, depth: p.z };
}

function mobiusNormal(u, v, w) {
    const eps = 0.001;
    const p = mobiusPoint(u, v, w);
    const pu = mobiusPoint(u + eps, v, w);
    const pv = mobiusPoint(u, v + eps, w);
    const du = { x: (pu.x - p.x) / eps, y: (pu.y - p.y) / eps, z: (pu.z - p.z) / eps };
    const dv = { x: (pv.x - p.x) / eps, y: (pv.y - p.y) / eps, z: (pv.z - p.z) / eps };
    // Cross product
    const nx = du.y * dv.z - du.z * dv.y;
    const ny = du.z * dv.x - du.x * dv.z;
    const nz = du.x * dv.y - du.y * dv.x;
    const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
    return { x: nx / len, y: ny / len, z: nz / len };
}

function animate(time) {
    requestAnimationFrame(animate);
    const t = time * 0.001;

    const rSpeed = document.getElementById('rotSpeed').value / 100;
    const aSpeed = document.getElementById('antSpeed').value / 100;

    if (!dragging) {
        rotY += 0.003 * rSpeed;
    }

    // Update ant
    antParam += 0.008 * aSpeed;
    if (antParam >= Math.PI * 4) {
        antParam -= Math.PI * 4;
        antLoops++;
        document.getElementById('loopCount').textContent = antLoops;
    }

    // Update cut
    if (cutting && !cutComplete) {
        cutProgress += 0.003;
        if (cutProgress >= 1) { cutProgress = 1; cutComplete = true; }
    }

    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    const uSteps = 80;
    const vSteps = 12;
    const w = stripWidth;

    // Build faces
    const faces = [];
    for (let i = 0; i < uSteps; i++) {
        for (let j = 0; j < vSteps; j++) {
            const u0 = (i / uSteps) * Math.PI * 2;
            const u1 = ((i + 1) / uSteps) * Math.PI * 2;
            const v0 = -1 + (j / vSteps) * 2;
            const v1 = -1 + ((j + 1) / vSteps) * 2;

            // Skip center strip if cutting
            if (cutting || cutComplete) {
                const vMid = (v0 + v1) / 2;
                if (Math.abs(vMid) < 0.08 && cutProgress > i / uSteps) continue;
            }

            const p00 = mobiusPoint(u0, v0, w);
            const p10 = mobiusPoint(u1, v0, w);
            const p11 = mobiusPoint(u1, v1, w);
            const p01 = mobiusPoint(u0, v1, w);

            const s00 = project(p00.x, p00.y, p00.z);
            const s10 = project(p10.x, p10.y, p10.z);
            const s11 = project(p11.x, p11.y, p11.z);
            const s01 = project(p01.x, p01.y, p01.z);

            const avgDepth = (s00.depth + s10.depth + s11.depth + s01.depth) / 4;

            // Normal for coloring (side detection)
            const n = mobiusNormal((u0 + u1) / 2, (v0 + v1) / 2, w);
            // Rotate normal same as geometry
            let rn = rotateY(n.x, n.y, n.z, rotY);
            rn = rotateX(rn.x, rn.y, rn.z, rotX);
            rn = rotateZ(rn.x, rn.y, rn.z, rotZ);
            const facing = rn.z; // dot with view direction

            faces.push({
                pts: [s00, s10, s11, s01],
                depth: avgDepth,
                facing,
                u: (u0 + u1) / 2,
                v: (v0 + v1) / 2
            });
        }
    }

    // Painter's algorithm
    faces.sort((a, b) => b.depth - a.depth);

    for (const face of faces) {
        ctx.beginPath();
        ctx.moveTo(face.pts[0].x, face.pts[0].y);
        for (let k = 1; k < 4; k++) ctx.lineTo(face.pts[k].x, face.pts[k].y);
        ctx.closePath();

        if (wireframe) {
            const hue = face.facing > 0 ? 220 : 0;
            const light = 40 + Math.abs(face.facing) * 30;
            ctx.strokeStyle = `hsla(${hue}, 80%, ${light}%, 0.7)`;
            ctx.lineWidth = 0.5;
            ctx.stroke();
        } else {
            // Two-tone: blue front, red back (demonstrates one-sidedness)
            const brightness = 0.35 + Math.abs(face.facing) * 0.55;
            let r, g, b;
            if (face.facing > 0) {
                // Blue side
                r = Math.floor(40 * brightness);
                g = Math.floor(100 * brightness);
                b = Math.floor(255 * brightness);
            } else {
                // Red side
                r = Math.floor(255 * brightness);
                g = Math.floor(60 * brightness);
                b = Math.floor(60 * brightness);
            }
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fill();
            ctx.strokeStyle = `rgba(${r + 40},${g + 40},${b + 40},0.3)`;
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }
    }

    // Draw ant on surface
    const antU = antParam % (Math.PI * 4);
    // The ant's v position depends on which loop: first loop v=0 front, second loop v=0 back
    const antV = 0; // center of strip
    const antPos = mobiusPoint(antU, antV, w);
    const antScreen = project(antPos.x, antPos.y, antPos.z);

    // Ant glow
    const grad = ctx.createRadialGradient(antScreen.x, antScreen.y, 0, antScreen.x, antScreen.y, 20);
    const antOnSecondLoop = antParam % (Math.PI * 4) > Math.PI * 2;
    const antColor = antOnSecondLoop ? '#ff6' : '#6ff';
    grad.addColorStop(0, antColor);
    grad.addColorStop(0.3, antColor + '88');
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.fillRect(antScreen.x - 20, antScreen.y - 20, 40, 40);

    // Ant dot
    ctx.beginPath();
    ctx.arc(antScreen.x, antScreen.y, 5, 0, Math.PI * 2);
    ctx.fillStyle = antColor;
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Ant trail
    ctx.beginPath();
    ctx.strokeStyle = antColor + '44';
    ctx.lineWidth = 2;
    for (let i = 0; i < 60; i++) {
        const trailU = antParam - i * 0.02;
        if (trailU < 0) break;
        const tp = mobiusPoint(trailU % (Math.PI * 4), 0, w);
        const ts = project(tp.x, tp.y, tp.z);
        if (i === 0) ctx.moveTo(ts.x, ts.y);
        else ctx.lineTo(ts.x, ts.y);
    }
    ctx.stroke();

    // Cut line visualization
    if (cutting && cutProgress > 0) {
        ctx.beginPath();
        ctx.strokeStyle = '#ff4';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);
        for (let i = 0; i <= uSteps * cutProgress; i++) {
            const u = (i / uSteps) * Math.PI * 2;
            const cp = mobiusPoint(u, 0, w);
            const cs = project(cp.x, cp.y, cp.z);
            if (i === 0) ctx.moveTo(cs.x, cs.y);
            else ctx.lineTo(cs.x, cs.y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // Title
    ctx.fillStyle = '#8af';
    ctx.font = 'bold 16px Segoe UI, sans-serif';
    ctx.fillText('Mobius Strip - The One-Sided Surface', W / 2 - 160, 40);
}

window.reset = function() {
    rotX = 0.3; rotY = 0; rotZ = 0;
    antParam = 0; antLoops = 0;
    cutting = false; cutProgress = 0; cutComplete = false;
    wireframe = false;
    document.getElementById('loopCount').textContent = '0';
    document.getElementById('widthSlider').value = 40;
    document.getElementById('antSpeed').value = 30;
    document.getElementById('rotSpeed').value = 25;
    stripWidth = 0.4;
    document.getElementById('btnFill').classList.add('active');
    document.getElementById('btnWire').classList.remove('active');
};

requestAnimationFrame(animate);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
