<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Surface Classification</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
#controls {
  position: fixed; top: 20px; right: 20px; background: rgba(10,14,26,0.85);
  backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(80,200,160,0.3); border-radius: 12px;
  padding: 18px; color: #a0e0c8; z-index: 100; min-width: 250px;
}
#controls h3 { margin-bottom: 12px; color: #70e0b0; font-size: 1.1em; }
.ctrl-row { margin-bottom: 10px; }
.ctrl-row label { display: block; font-size: 0.85em; margin-bottom: 4px; opacity: 0.8; }
.btn { background: rgba(80,200,160,0.2); border: 1px solid rgba(80,200,160,0.4); color: #70e0b0;
  padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.85em; margin: 3px 2px; }
.btn:hover { background: rgba(80,200,160,0.4); }
.btn.active { background: rgba(80,200,160,0.5); }
#props { background: rgba(30,60,50,0.4); border-radius: 8px; padding: 10px; margin-top: 10px; font-size: 0.85em; line-height: 1.6; }
#props .prop-name { color: #90d0b0; }
#props .prop-val { color: #e0f0e8; font-weight: bold; }
#polyModel { border: 1px solid rgba(80,200,160,0.2); border-radius: 6px; margin-top: 8px; background: rgba(10,14,26,0.5); }
.surf-btns { display: flex; flex-wrap: wrap; gap: 4px; margin: 4px 0; }
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>
<div id="controls">
  <h3>Surface Classification</h3>
  <div class="ctrl-row">
    <label>Surface Type</label>
    <div class="surf-btns">
      <button class="btn active" id="bSphere" onclick="setSurface('sphere')">Sphere</button>
      <button class="btn" id="bTorus" onclick="setSurface('torus')">Torus</button>
      <button class="btn" id="bDouble" onclick="setSurface('double')">Double Torus</button>
      <button class="btn" id="bKlein" onclick="setSurface('klein')">Klein Bottle</button>
      <button class="btn" id="bRP2" onclick="setSurface('rp2')">Proj. Plane</button>
    </div>
  </div>
  <div class="ctrl-row">
    <button class="btn" onclick="addHandle()">+ Handle (genus)</button>
    <button class="btn" onclick="addCrosscap()">+ Crosscap</button>
  </div>
  <div id="props">
    <span class="prop-name">Name:</span> <span class="prop-val" id="pName">Sphere</span><br>
    <span class="prop-name">Genus / Crosscaps:</span> <span class="prop-val" id="pGenus">g=0</span><br>
    <span class="prop-name">Euler char:</span> <span class="prop-val" id="pEuler">X = 2</span><br>
    <span class="prop-name">Orientable:</span> <span class="prop-val" id="pOrient">Yes</span><br>
    <span class="prop-name">One-sided:</span> <span class="prop-val" id="pSided">No</span>
  </div>
  <div style="margin-top:8px;font-size:0.8em;opacity:0.7">Polygon model:</div>
  <canvas id="polyModel" width="200" height="150"></canvas>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const polyCanvas = document.getElementById('polyModel');
const pctx = polyCanvas.getContext('2d');
let W, H;

let currentSurface = 'sphere';
let genus = 0;
let crosscaps = 0;
let orientable = true;
let rotY = 0, rotX = 0.4;
let autoRotate = true;
let morphT = 0;
let morphFrom = null;
let morphTo = null;
let morphing = false;
let time = 0;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}

function setSurface(type) {
  document.querySelectorAll('.surf-btns .btn').forEach(b => b.classList.remove('active'));
  const btn = document.getElementById('b' + type.charAt(0).toUpperCase() + type.slice(1));
  if (btn) btn.classList.add('active');

  morphFrom = currentSurface;
  morphTo = type;
  morphT = 0;
  morphing = true;

  currentSurface = type;
  switch(type) {
    case 'sphere': genus = 0; crosscaps = 0; orientable = true; break;
    case 'torus': genus = 1; crosscaps = 0; orientable = true; break;
    case 'double': genus = 2; crosscaps = 0; orientable = true; break;
    case 'klein': genus = 0; crosscaps = 2; orientable = false; break;
    case 'rp2': genus = 0; crosscaps = 1; orientable = false; break;
  }
  updateProps();
  drawPolygonModel();
}

function addHandle() {
  genus++;
  crosscaps = 0;
  orientable = true;
  if (genus === 0) currentSurface = 'sphere';
  else if (genus === 1) currentSurface = 'torus';
  else if (genus === 2) currentSurface = 'double';
  else currentSurface = 'genus' + genus;
  updateProps();
  drawPolygonModel();
}

function addCrosscap() {
  crosscaps++;
  orientable = false;
  genus = 0;
  if (crosscaps === 1) currentSurface = 'rp2';
  else if (crosscaps === 2) currentSurface = 'klein';
  else currentSurface = 'crosscap' + crosscaps;
  updateProps();
  drawPolygonModel();
}

function updateProps() {
  let name, eulerChar;
  if (orientable) {
    const names = ['Sphere', 'Torus', 'Double Torus', 'Triple Torus'];
    name = genus < 4 ? names[genus] : `Genus-${genus} Surface`;
    eulerChar = 2 - 2 * genus;
    document.getElementById('pGenus').textContent = `g = ${genus}`;
  } else {
    const names = {1: 'Projective Plane', 2: 'Klein Bottle'};
    name = names[crosscaps] || `${crosscaps}-Crosscap Surface`;
    eulerChar = 2 - crosscaps;
    document.getElementById('pGenus').textContent = `k = ${crosscaps}`;
  }
  document.getElementById('pName').textContent = name;
  document.getElementById('pEuler').textContent = `X = ${eulerChar}`;
  document.getElementById('pOrient').textContent = orientable ? 'Yes' : 'No';
  document.getElementById('pSided').textContent = orientable ? 'No (two-sided)' : 'Yes (one-sided)';
}

function drawPolygonModel() {
  const pw = polyCanvas.width;
  const ph = polyCanvas.height;
  pctx.fillStyle = '#0a0e1a';
  pctx.fillRect(0, 0, pw, ph);

  const cx = pw / 2;
  const cy = ph / 2;
  const r = 50;

  if (orientable && genus <= 2) {
    if (genus === 0) {
      // Sphere: single vertex, no identifications
      pctx.beginPath();
      pctx.arc(cx, cy, r * 0.5, 0, Math.PI * 2);
      pctx.strokeStyle = '#70e0b0';
      pctx.lineWidth = 2;
      pctx.stroke();
      pctx.fillStyle = 'rgba(80,200,160,0.1)';
      pctx.fill();
      pctx.fillStyle = '#a0e0c8';
      pctx.font = '11px sans-serif';
      pctx.textAlign = 'center';
      pctx.fillText('(no identifications)', cx, cy + r * 0.7);
    } else if (genus === 1) {
      // Torus: square with opposite edges identified same direction
      drawSquareModel(cx, cy, r, [
        {dir: 'right', color: '#f06060', label: 'a'},
        {dir: 'up', color: '#6060f0', label: 'b'},
        {dir: 'right', color: '#f06060', label: 'a'},
        {dir: 'up', color: '#6060f0', label: 'b'}
      ], 'aba\u207B\u00B9b\u207B\u00B9');
    } else {
      // Double torus: octagon
      drawOctagonModel(cx, cy, r);
    }
  } else if (!orientable) {
    if (crosscaps === 1) {
      // RP2: disk with antipodal identification
      pctx.beginPath();
      pctx.arc(cx, cy, r, 0, Math.PI * 2);
      pctx.strokeStyle = '#70e0b0';
      pctx.lineWidth = 2;
      pctx.stroke();
      pctx.fillStyle = 'rgba(80,200,160,0.1)';
      pctx.fill();
      // Draw arrows on boundary indicating antipodal identification
      for (let a = 0; a < Math.PI * 2; a += Math.PI / 3) {
        const ax = cx + r * Math.cos(a);
        const ay = cy + r * Math.sin(a);
        pctx.beginPath();
        pctx.arc(ax, ay, 3, 0, Math.PI * 2);
        pctx.fillStyle = '#f06060';
        pctx.fill();
        // Antipodal point
        const bx = cx + r * Math.cos(a + Math.PI);
        const by = cy + r * Math.sin(a + Math.PI);
        pctx.beginPath();
        pctx.arc(bx, by, 3, 0, Math.PI * 2);
        pctx.fillStyle = '#f06060';
        pctx.fill();
      }
      pctx.fillStyle = '#a0e0c8';
      pctx.font = '10px sans-serif';
      pctx.textAlign = 'center';
      pctx.fillText('antipodal identification', cx, cy + r + 15);
    } else if (crosscaps === 2) {
      // Klein bottle: square with one pair reversed
      drawSquareModel(cx, cy, r, [
        {dir: 'right', color: '#f06060', label: 'a'},
        {dir: 'up', color: '#6060f0', label: 'b'},
        {dir: 'right', color: '#f06060', label: 'a'},
        {dir: 'down', color: '#6060f0', label: 'b'}
      ], 'aba\u207B\u00B9b');
    }
  }
}

function drawSquareModel(cx, cy, r, edges, word) {
  const hw = r * 0.85;
  pctx.strokeStyle = 'rgba(80,200,160,0.3)';
  pctx.lineWidth = 1;
  pctx.strokeRect(cx - hw, cy - hw, hw * 2, hw * 2);
  pctx.fillStyle = 'rgba(80,200,160,0.05)';
  pctx.fillRect(cx - hw, cy - hw, hw * 2, hw * 2);

  // Draw edges with arrows
  const edgeCoords = [
    [[cx - hw, cy + hw], [cx + hw, cy + hw]], // bottom (a)
    [[cx - hw, cy + hw], [cx - hw, cy - hw]], // left (b)
    [[cx - hw, cy - hw], [cx + hw, cy - hw]], // top (a)
    [[cx + hw, cy + hw], [cx + hw, cy - hw]]  // right (b)
  ];

  const colors = ['#f06060', '#6060f0', '#f06060', '#6060f0'];
  const labels = ['a', 'b', 'a', 'b'];

  for (let i = 0; i < 4; i++) {
    const [p1, p2] = edgeCoords[i];
    pctx.beginPath();
    pctx.moveTo(p1[0], p1[1]);
    pctx.lineTo(p2[0], p2[1]);
    pctx.strokeStyle = colors[i];
    pctx.lineWidth = 2.5;
    pctx.stroke();

    // Arrow at midpoint
    const mx = (p1[0] + p2[0]) / 2;
    const my = (p1[1] + p2[1]) / 2;
    const dx = p2[0] - p1[0];
    const dy = p2[1] - p1[1];
    const len = Math.sqrt(dx*dx + dy*dy);
    const reverse = (i === 3 && edges[3].dir === 'down');
    const sign = reverse ? -1 : 1;
    const ax = dx / len * 6 * sign;
    const ay = dy / len * 6 * sign;

    pctx.beginPath();
    pctx.moveTo(mx + ax, my + ay);
    pctx.lineTo(mx - ay * 0.5 - ax * 0.3, my + ax * 0.5 - ay * 0.3);
    pctx.lineTo(mx + ay * 0.5 - ax * 0.3, my - ax * 0.5 - ay * 0.3);
    pctx.fillStyle = colors[i];
    pctx.fill();
  }

  if (word) {
    pctx.fillStyle = '#a0e0c8';
    pctx.font = '10px sans-serif';
    pctx.textAlign = 'center';
    pctx.fillText(word, cx, cy + hw + 18);
  }
}

function drawOctagonModel(cx, cy, r) {
  const sides = 8;
  const colors = ['#f06060','#60f060','#f06060','#60f060','#6060f0','#f0f060','#6060f0','#f0f060'];
  const labels = ['a','b','a\u207B\u00B9','b\u207B\u00B9','c','d','c\u207B\u00B9','d\u207B\u00B9'];

  pctx.beginPath();
  for (let i = 0; i <= sides; i++) {
    const a = (i / sides) * Math.PI * 2 - Math.PI / 2;
    const x = cx + r * Math.cos(a);
    const y = cy + r * Math.sin(a);
    if (i === 0) pctx.moveTo(x, y);
    else pctx.lineTo(x, y);
  }
  pctx.fillStyle = 'rgba(80,200,160,0.05)';
  pctx.fill();

  for (let i = 0; i < sides; i++) {
    const a1 = (i / sides) * Math.PI * 2 - Math.PI / 2;
    const a2 = ((i+1) / sides) * Math.PI * 2 - Math.PI / 2;
    const x1 = cx + r * Math.cos(a1);
    const y1 = cy + r * Math.sin(a1);
    const x2 = cx + r * Math.cos(a2);
    const y2 = cy + r * Math.sin(a2);

    pctx.beginPath();
    pctx.moveTo(x1, y1);
    pctx.lineTo(x2, y2);
    pctx.strokeStyle = colors[i];
    pctx.lineWidth = 2.5;
    pctx.stroke();
  }

  pctx.fillStyle = '#a0e0c8';
  pctx.font = '9px sans-serif';
  pctx.textAlign = 'center';
  pctx.fillText('genus 2: aba\u207B\u00B9b\u207B\u00B9cdc\u207B\u00B9d\u207B\u00B9', cx, cy + r + 15);
}

// 3D surface generation
function generateSurfaceMesh(type, morphFactor) {
  const res = 40;
  const points = [];

  for (let i = 0; i <= res; i++) {
    for (let j = 0; j <= res; j++) {
      const u = (i / res) * Math.PI * 2;
      const v = (j / res) * Math.PI * 2;
      let x, y, z;

      switch(type) {
        case 'sphere':
          const phi = (j / res) * Math.PI;
          x = 80 * Math.sin(phi) * Math.cos(u);
          y = 80 * Math.sin(phi) * Math.sin(u);
          z = 80 * Math.cos(phi);
          break;

        case 'torus':
          const R = 60, r = 25;
          x = (R + r * Math.cos(v)) * Math.cos(u);
          y = (R + r * Math.cos(v)) * Math.sin(u);
          z = r * Math.sin(v);
          break;

        case 'double': {
          // Double torus: figure-8 cross section
          const a2 = 30;
          const c2 = 50;
          const vn = v;
          const profile = a2 * (1 + 0.5 * Math.cos(2 * u));
          x = (c2 + profile * Math.cos(vn)) * Math.cos(u);
          y = (c2 + profile * Math.cos(vn)) * Math.sin(u);
          z = profile * Math.sin(vn);
          break;
        }

        case 'klein': {
          // Klein bottle parametric equations
          const uu = u;
          const vv = v;
          if (uu < Math.PI) {
            x = 3 * Math.cos(uu) * (1 + Math.sin(uu)) + 2 * (1 - Math.cos(uu) / 2) * Math.cos(uu) * Math.cos(vv);
            y = 8 * Math.sin(uu) + 2 * (1 - Math.cos(uu) / 2) * Math.sin(uu) * Math.cos(vv);
          } else {
            x = 3 * Math.cos(uu) * (1 + Math.sin(uu)) + 2 * (1 - Math.cos(uu) / 2) * Math.cos(vv + Math.PI);
            y = 8 * Math.sin(uu);
          }
          z = 2 * (1 - Math.cos(uu) / 2) * Math.sin(vv);
          x *= 8; y *= 8; z *= 8;
          break;
        }

        case 'rp2': {
          // Boy's surface (immersion of RP2 in R3)
          const uu2 = (i / res) * Math.PI / 2;
          const vv2 = (j / res) * Math.PI * 2;
          const sq2 = Math.sqrt(2);
          const denom = 2 - sq2 * Math.sin(3 * vv2) * Math.sin(2 * uu2);
          x = (sq2 * Math.cos(2 * uu2) * Math.cos(vv2) * Math.cos(vv2) + Math.cos(uu2) * Math.sin(2 * vv2)) / denom;
          y = (sq2 * Math.cos(2 * uu2) * Math.sin(vv2) * Math.cos(vv2) - Math.cos(uu2) * Math.cos(2 * vv2)) / denom;
          z = (3 * Math.cos(uu2) * Math.cos(uu2) - 1) / (2 * denom);
          x *= 100; y *= 100; z *= 100;
          break;
        }

        default: {
          // High genus: use torus with extra wobble
          const Rg = 60, rg = 20;
          const wobble = genus > 2 ? 15 * Math.sin(genus * u) : 0;
          x = (Rg + (rg + wobble) * Math.cos(v)) * Math.cos(u);
          y = (Rg + (rg + wobble) * Math.cos(v)) * Math.sin(u);
          z = (rg + wobble) * Math.sin(v);
          break;
        }
      }

      points.push({ x, y, z, u: i, v: j });
    }
  }

  return { points, res };
}

function project(x, y, z) {
  const cosA = Math.cos(rotY);
  const sinA = Math.sin(rotY);
  const cosB = Math.cos(rotX);
  const sinB = Math.sin(rotX);

  const x1 = x * cosA - z * sinA;
  const z1 = x * sinA + z * cosA;
  const y1 = y * cosB - z1 * sinB;
  const z2 = y * sinB + z1 * cosB;

  const fov = 500;
  const p = fov / (fov + z2 + 250);
  return { x: W/2 + x1 * p * 1.5, y: H/2 + y1 * p * 1.5, z: z2, s: p };
}

function drawSurface() {
  const mesh = generateSurfaceMesh(currentSurface, morphing ? morphT : 1);
  const { points, res } = mesh;

  // Build and sort faces
  const faces = [];
  for (let i = 0; i < res; i++) {
    for (let j = 0; j < res; j++) {
      const idx00 = i * (res + 1) + j;
      const idx10 = (i + 1) * (res + 1) + j;
      const idx01 = i * (res + 1) + j + 1;
      const idx11 = (i + 1) * (res + 1) + j + 1;

      const p00 = project(points[idx00].x, points[idx00].y, points[idx00].z);
      const p10 = project(points[idx10].x, points[idx10].y, points[idx10].z);
      const p01 = project(points[idx01].x, points[idx01].y, points[idx01].z);
      const p11 = project(points[idx11].x, points[idx11].y, points[idx11].z);

      const avgZ = (p00.z + p10.z + p01.z + p11.z) / 4;

      faces.push({ p00, p10, p01, p11, z: avgZ, i, j, res });
    }
  }

  faces.sort((a, b) => a.z - b.z);

  for (const f of faces) {
    const { p00, p10, p01, p11, i, j } = f;

    // Normal-based shading
    const nx = (p10.x - p00.x) * (p01.y - p00.y) - (p10.y - p00.y) * (p01.x - p00.x);
    const brightness = Math.max(0.15, Math.min(1, 0.4 + nx * 0.003));

    // Color based on surface position
    const hue = orientable ? 150 + i * 2 : 280 + i * 2;
    const sat = 50;
    const light = Math.floor(brightness * 55 + 15);

    ctx.beginPath();
    ctx.moveTo(p00.x, p00.y);
    ctx.lineTo(p10.x, p10.y);
    ctx.lineTo(p11.x, p11.y);
    ctx.lineTo(p01.x, p01.y);
    ctx.closePath();
    ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, 0.85)`;
    ctx.fill();
    ctx.strokeStyle = `hsla(${hue}, ${sat}%, ${light + 10}%, 0.15)`;
    ctx.lineWidth = 0.5;
    ctx.stroke();
  }
}

function draw() {
  ctx.fillStyle = '#0a0e1a';
  ctx.fillRect(0, 0, W, H);

  // Background glow
  const grad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, H * 0.45);
  grad.addColorStop(0, orientable ? 'rgba(30,80,60,0.12)' : 'rgba(60,30,80,0.12)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  drawSurface();

  if (morphing) {
    morphT += 0.02;
    if (morphT >= 1) morphing = false;
  }
}

// Mouse interaction
let dragging = false;
let lastMX = 0, lastMY = 0;
canvas.addEventListener('mousedown', e => { dragging = true; lastMX = e.clientX; lastMY = e.clientY; autoRotate = false; });
canvas.addEventListener('mousemove', e => {
  if (dragging) {
    rotY += (e.clientX - lastMX) * 0.005;
    rotX += (e.clientY - lastMY) * 0.005;
    lastMX = e.clientX; lastMY = e.clientY;
  }
});
canvas.addEventListener('mouseup', () => { dragging = false; autoRotate = true; });
canvas.addEventListener('mouseleave', () => { dragging = false; });
canvas.addEventListener('touchstart', e => { dragging = true; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; autoRotate = false; });
canvas.addEventListener('touchmove', e => {
  if (dragging) {
    rotY += (e.touches[0].clientX - lastMX) * 0.005;
    rotX += (e.touches[0].clientY - lastMY) * 0.005;
    lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY;
  }
});
canvas.addEventListener('touchend', () => { dragging = false; autoRotate = true; });

window.addEventListener('resize', resize);

window.reset = function() {
  currentSurface = 'sphere';
  genus = 0; crosscaps = 0; orientable = true;
  rotY = 0; rotX = 0.4; autoRotate = true;
  morphing = false;
  document.querySelectorAll('.surf-btns .btn').forEach(b => b.classList.remove('active'));
  document.getElementById('bSphere').classList.add('active');
  updateProps();
  drawPolygonModel();
};

function animate() {
  time += 0.016;
  if (autoRotate && !dragging) rotY += 0.008;
  draw();
  requestAnimationFrame(animate);
}

resize();
updateProps();
drawPolygonModel();
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>