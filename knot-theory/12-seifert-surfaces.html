<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Seifert Surfaces</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
#controls {
    position: fixed; bottom: 20px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.75); backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 170, 255, 0.2); border-radius: 12px;
    padding: 18px 22px; color: #c8d8ff; min-width: 240px;
}
#controls h3 { margin-bottom: 12px; color: #8af; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
.ctrl-row label { flex: 1; }
.ctrl-row input[type=range] { width: 110px; accent-color: #8af; }
.ctrl-row select { background: rgba(20,30,60,0.8); color: #c8d8ff; border: 1px solid rgba(138,170,255,0.3); border-radius: 4px; padding: 2px 6px; }
.ctrl-row button {
    background: rgba(138,170,255,0.15); color: #8af; border: 1px solid rgba(138,170,255,0.3);
    border-radius: 6px; padding: 4px 12px; cursor: pointer; font-size: 0.85em;
}
.ctrl-row button:hover { background: rgba(138,170,255,0.3); }
#info {
    position: fixed; top: 70px; right: 20px; z-index: 100;
    background: rgba(10, 14, 30, 0.75); backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 170, 255, 0.2); border-radius: 12px;
    padding: 16px 20px; color: #c8d8ff; max-width: 280px;
}
#info h2 { color: #8af; font-size: 1.1em; margin-bottom: 6px; }
#info p { font-size: 0.82em; line-height: 1.5; opacity: 0.85; margin-bottom: 6px; }
.stat { color: #ffda6e; font-weight: bold; }
</style>
</head>
<body>
<a href="index.html" style="position:fixed;top:20px;left:20px;color:#8af;text-decoration:none;z-index:100;font-size:1.2em">&#8592; Back</a>
<canvas id="c"></canvas>

<div id="info">
    <h2>Seifert Surfaces</h2>
    <p>Every knot bounds an orientable surface. The <span class="stat">Seifert surface</span> is like a soap film stretched across the knot.</p>
    <p>The <span class="stat">genus</span> of the surface is a knot invariant: trefoil and figure-eight both have genus <span class="stat">1</span>, while the unknot has genus <span class="stat">0</span>.</p>
    <p id="knotInfo">Current: Trefoil (genus 1)</p>
</div>

<div id="controls">
    <h3>Controls</h3>
    <div class="ctrl-row">
        <label>Knot Type</label>
        <select id="knotSelect">
            <option value="trefoil">Trefoil</option>
            <option value="figure8">Figure-Eight</option>
            <option value="unknot">Unknot</option>
        </select>
    </div>
    <div class="ctrl-row"><label>Surface Opacity</label><input type="range" id="opacity" min="10" max="90" value="50"></div>
    <div class="ctrl-row"><label>Rotation</label><input type="range" id="rotSpeed" min="0" max="100" value="30"></div>
    <div class="ctrl-row"><label>Morph</label><input type="range" id="morph" min="0" max="100" value="100"></div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

let rotX = 0.4, rotY = 0, rotZ = 0;
let dragging = false, lastMX = 0, lastMY = 0;
let currentKnot = 'trefoil';

canvas.addEventListener('mousedown', e => { dragging = true; lastMX = e.clientX; lastMY = e.clientY; });
canvas.addEventListener('mousemove', e => {
    if (!dragging) return;
    rotY += (e.clientX - lastMX) * 0.005;
    rotX += (e.clientY - lastMY) * 0.005;
    lastMX = e.clientX; lastMY = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('touchstart', e => { e.preventDefault(); dragging = true; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; });
canvas.addEventListener('touchmove', e => { e.preventDefault(); if (!dragging) return; rotY += (e.touches[0].clientX - lastMX) * 0.005; rotX += (e.touches[0].clientY - lastMY) * 0.005; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; });
canvas.addEventListener('touchend', () => dragging = false);

document.getElementById('knotSelect').addEventListener('change', e => {
    currentKnot = e.target.value;
    const info = { trefoil: 'Trefoil (genus 1)', figure8: 'Figure-Eight (genus 1)', unknot: 'Unknot (genus 0)' };
    document.getElementById('knotInfo').textContent = 'Current: ' + info[currentKnot];
});

function rotateXM(x, y, z, a) { const c = Math.cos(a), s = Math.sin(a); return { x, y: y*c - z*s, z: y*s + z*c }; }
function rotateYM(x, y, z, a) { const c = Math.cos(a), s = Math.sin(a); return { x: x*c + z*s, y, z: -x*s + z*c }; }
function rotateZM(x, y, z, a) { const c = Math.cos(a), s = Math.sin(a); return { x: x*c - y*s, y: x*s + y*c, z }; }

function project(x, y, z) {
    let p = rotateYM(x, y, z, rotY);
    p = rotateXM(p.x, p.y, p.z, rotX);
    p = rotateZM(p.x, p.y, p.z, rotZ);
    const fov = 5;
    const scale = fov / (fov + p.z) * Math.min(W, H) * 0.22;
    return { x: W/2 + p.x * scale, y: H/2 + p.y * scale, depth: p.z };
}

// Knot parametric curves
function trefoilKnot(t) {
    const x = Math.sin(t) + 2 * Math.sin(2*t);
    const y = Math.cos(t) - 2 * Math.cos(2*t);
    const z = -Math.sin(3*t);
    return { x: x * 0.4, y: y * 0.4, z: z * 0.4 };
}

function figure8Knot(t) {
    const x = (2 + Math.cos(2*t)) * Math.cos(3*t);
    const y = (2 + Math.cos(2*t)) * Math.sin(3*t);
    const z = Math.sin(4*t);
    return { x: x * 0.3, y: y * 0.3, z: z * 0.3 };
}

function unknotKnot(t) {
    return { x: Math.cos(t) * 0.8, y: Math.sin(t) * 0.8, z: 0 };
}

function getKnotPoint(t) {
    if (currentKnot === 'trefoil') return trefoilKnot(t);
    if (currentKnot === 'figure8') return figure8Knot(t);
    return unknotKnot(t);
}

// Generate Seifert surface as a mesh from knot to center
function generateSeifertFaces(morphAmount) {
    const faces = [];
    const uSteps = 80;
    const vSteps = 12;

    for (let i = 0; i < uSteps; i++) {
        const t0 = (i / uSteps) * Math.PI * 2;
        const t1 = ((i + 1) / uSteps) * Math.PI * 2;

        for (let j = 0; j < vSteps; j++) {
            const v0 = j / vSteps;
            const v1 = (j + 1) / vSteps;

            // Knot boundary points
            const k0 = getKnotPoint(t0);
            const k1 = getKnotPoint(t1);

            // Center point with some z-displacement based on genus
            let cx, cy, cz;
            if (currentKnot === 'unknot') {
                cx = 0; cy = 0; cz = 0;
            } else {
                // Seifert surface with a "bump" for genus
                const midT = (t0 + t1) / 2;
                const genusWave = Math.sin(midT * (currentKnot === 'trefoil' ? 1.5 : 2)) * 0.3;
                cx = 0;
                cy = 0;
                cz = genusWave * morphAmount;
            }

            // Interpolate from boundary to center
            const p00 = {
                x: k0.x * (1 - v0) + cx * v0 * morphAmount,
                y: k0.y * (1 - v0) + cy * v0 * morphAmount,
                z: k0.z * (1 - v0) + cz * v0 * morphAmount + Math.sin(v0 * Math.PI) * Math.sin(t0 * 3) * 0.2 * morphAmount
            };
            const p10 = {
                x: k1.x * (1 - v0) + cx * v0 * morphAmount,
                y: k1.y * (1 - v0) + cy * v0 * morphAmount,
                z: k1.z * (1 - v0) + cz * v0 * morphAmount + Math.sin(v0 * Math.PI) * Math.sin(t1 * 3) * 0.2 * morphAmount
            };
            const p11 = {
                x: k1.x * (1 - v1) + cx * v1 * morphAmount,
                y: k1.y * (1 - v1) + cy * v1 * morphAmount,
                z: k1.z * (1 - v1) + cz * v1 * morphAmount + Math.sin(v1 * Math.PI) * Math.sin(t1 * 3) * 0.2 * morphAmount
            };
            const p01 = {
                x: k0.x * (1 - v1) + cx * v1 * morphAmount,
                y: k0.y * (1 - v1) + cy * v1 * morphAmount,
                z: k0.z * (1 - v1) + cz * v1 * morphAmount + Math.sin(v1 * Math.PI) * Math.sin(t0 * 3) * 0.2 * morphAmount
            };

            const s00 = project(p00.x, p00.y, p00.z);
            const s10 = project(p10.x, p10.y, p10.z);
            const s11 = project(p11.x, p11.y, p11.z);
            const s01 = project(p01.x, p01.y, p01.z);

            // Compute face normal for orientation coloring
            const ux = p10.x - p00.x, uy = p10.y - p00.y, uz = p10.z - p00.z;
            const vx = p01.x - p00.x, vy = p01.y - p00.y, vz = p01.z - p00.z;
            const nx = uy * vz - uz * vy;
            const ny = uz * vx - ux * vz;
            const nz = ux * vy - uy * vx;
            let rn = rotateYM(nx, ny, nz, rotY);
            rn = rotateXM(rn.x, rn.y, rn.z, rotX);

            faces.push({
                pts: [s00, s10, s11, s01],
                depth: (s00.depth + s10.depth + s11.depth + s01.depth) / 4,
                facing: rn.z,
                v: (v0 + v1) / 2
            });
        }
    }
    return faces;
}

function drawKnotCurve() {
    const steps = 200;
    ctx.beginPath();
    for (let i = 0; i <= steps; i++) {
        const t = (i / steps) * Math.PI * 2;
        const p = getKnotPoint(t);
        const s = project(p.x, p.y, p.z);
        if (i === 0) ctx.moveTo(s.x, s.y);
        else ctx.lineTo(s.x, s.y);
    }
    ctx.closePath();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    ctx.shadowColor = '#8af';
    ctx.shadowBlur = 15;
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Second pass for glow
    ctx.strokeStyle = '#8af';
    ctx.lineWidth = 1.5;
    ctx.stroke();
}

function animate(time) {
    requestAnimationFrame(animate);
    const t = time * 0.001;

    const rSpeed = document.getElementById('rotSpeed').value / 100;
    const opacity = document.getElementById('opacity').value / 100;
    const morphAmount = document.getElementById('morph').value / 100;

    if (!dragging) rotY += 0.004 * rSpeed;

    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, W, H);

    // Generate and draw surface
    const faces = generateSeifertFaces(morphAmount);
    faces.sort((a, b) => b.depth - a.depth);

    for (const face of faces) {
        ctx.beginPath();
        ctx.moveTo(face.pts[0].x, face.pts[0].y);
        for (let k = 1; k < 4; k++) ctx.lineTo(face.pts[k].x, face.pts[k].y);
        ctx.closePath();

        const brightness = 0.3 + Math.abs(face.facing) * 0.5;
        const hue = face.facing > 0 ? 200 : 330;
        const sat = 60 + face.v * 30;
        ctx.fillStyle = `hsla(${hue}, ${sat}%, ${brightness * 70}%, ${opacity * 0.8})`;
        ctx.fill();
        ctx.strokeStyle = `hsla(${hue}, ${sat}%, ${brightness * 90}%, ${opacity * 0.3})`;
        ctx.lineWidth = 0.5;
        ctx.stroke();
    }

    // Draw knot boundary curve on top
    drawKnotCurve();

    // Title
    ctx.fillStyle = '#8af';
    ctx.font = 'bold 16px Segoe UI, sans-serif';
    ctx.fillText('Seifert Surfaces - Orientable Surfaces Bounded by Knots', W/2 - 220, 40);
}

window.reset = function() {
    rotX = 0.4; rotY = 0; rotZ = 0;
    currentKnot = 'trefoil';
    document.getElementById('knotSelect').value = 'trefoil';
    document.getElementById('opacity').value = 50;
    document.getElementById('rotSpeed').value = 30;
    document.getElementById('morph').value = 100;
    document.getElementById('knotInfo').textContent = 'Current: Trefoil (genus 1)';
};

requestAnimationFrame(animate);
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
