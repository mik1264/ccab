<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Linking Number - Knot Theory</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: #e0e0e0; }
canvas { display: block; cursor: grab; }
canvas:active { cursor: grabbing; }
a.back { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a.back:hover { color: #adf; }

#panel {
    position: fixed; top: 20px; right: 20px; width: 320px;
    background: rgba(10, 14, 30, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100, 140, 255, 0.2); border-radius: 16px;
    padding: 20px; z-index: 100; max-height: calc(100vh - 40px); overflow-y: auto;
}
#panel h2 { color: #8af; font-size: 1.2em; margin-bottom: 8px; }
#panel p { font-size: 0.82em; line-height: 1.5; color: #aab; margin-bottom: 10px; }

.link-btns { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 12px; }
.link-btn {
    padding: 8px 12px; border-radius: 8px; border: 1px solid rgba(100,140,255,0.3);
    background: rgba(40,60,120,0.3); color: #cdf; cursor: pointer; font-size: 0.82em; transition: all 0.3s;
}
.link-btn:hover { background: rgba(60,90,180,0.4); }
.link-btn.active { background: rgba(80,130,255,0.35); border-color: #8af; }

#lk-display {
    text-align: center; padding: 16px; margin: 12px 0;
    background: rgba(30, 40, 80, 0.5); border-radius: 12px;
    border: 1px solid rgba(100,140,255,0.15);
}
#lk-display .lk-value { font-size: 2.2em; font-weight: 700; color: #8af; }
#lk-display .lk-label { font-size: 0.85em; color: #88a; margin-top: 4px; }

.crossing-list {
    max-height: 120px; overflow-y: auto; margin: 10px 0;
    font-size: 0.8em; color: #aab;
}
.crossing-item {
    display: flex; justify-content: space-between; padding: 4px 8px;
    border-bottom: 1px solid rgba(100,140,255,0.1);
}
.crossing-item .pos { color: #6f6; font-weight: 700; }
.crossing-item .neg { color: #f66; font-weight: 700; }

.warn-box {
    padding: 10px; background: rgba(220,100,60,0.1); border-left: 3px solid #e84;
    border-radius: 0 8px 8px 0; font-size: 0.78em; line-height: 1.5; color: #ea8; margin-top: 10px;
}
.info-box {
    padding: 10px; background: rgba(60,120,200,0.1); border-left: 3px solid #48f;
    border-radius: 0 8px 8px 0; font-size: 0.78em; line-height: 1.5; color: #8af; margin-top: 10px;
}
#drag-msg { font-size: 0.75em; color: #667; text-align: center; margin-top: 8px; }
</style>
</head>
<body>
<a href="index.html" class="back">&larr; Back</a>
<canvas id="canvas"></canvas>

<div id="panel">
    <h2>Linking Number</h2>
    <p>The linking number counts how many times one curve winds around another. At each crossing between the two curves, assign +1 or -1 based on orientation.</p>

    <div class="link-btns">
        <button class="link-btn active" onclick="selectLink(0)">Unlinked</button>
        <button class="link-btn" onclick="selectLink(1)">Hopf Link</button>
        <button class="link-btn" onclick="selectLink(2)">Solomon's</button>
        <button class="link-btn" onclick="selectLink(3)">Whitehead</button>
    </div>

    <div id="lk-display">
        <div class="lk-value" id="lk-val">0</div>
        <div class="lk-label">Linking Number</div>
    </div>

    <div class="crossing-list" id="crossing-list"></div>

    <div id="special-msg"></div>

    <div class="info-box">
        <strong>Formula:</strong> Linking number = (sum of crossing signs) / 2, where we only count crossings between the two different components.
    </div>

    <div id="drag-msg">Drag curves to try to separate them</div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

let currentLink = 0;
let time = 0;
let dragOffset = [0, 0];
let isDragging = false;
let dragStart = [0, 0];

const LINK_DATA = [
    {
        name: 'Unlinked Circles',
        linkingNumber: 0,
        linked: false,
        crossingSigns: [],
        desc: 'Two separate circles that do not interlock. They can be pulled apart.'
    },
    {
        name: 'Hopf Link',
        linkingNumber: 1,
        linked: true,
        crossingSigns: [+1, +1],
        desc: 'The simplest non-trivial link. Two circles linked once.'
    },
    {
        name: "Solomon's Link",
        linkingNumber: 2,
        linked: true,
        crossingSigns: [+1, +1, +1, +1],
        desc: 'Two circles linked twice. Found in ancient decorative patterns.'
    },
    {
        name: 'Whitehead Link',
        linkingNumber: 0,
        linked: true,
        crossingSigns: [+1, -1, +1, -1, +1, -1],
        desc: 'Linking number 0 yet STILL LINKED! Shows linking number has limits.'
    }
];

function selectLink(idx) {
    currentLink = idx;
    dragOffset = [0, 0];
    document.querySelectorAll('.link-btn').forEach((b, i) => b.classList.toggle('active', i === idx));
    updateDisplay();
}

function updateDisplay() {
    const data = LINK_DATA[currentLink];
    document.getElementById('lk-val').textContent = data.linkingNumber;

    const list = document.getElementById('crossing-list');
    let html = '';
    for (let i = 0; i < data.crossingSigns.length; i++) {
        const sign = data.crossingSigns[i];
        html += `<div class="crossing-item"><span>Crossing ${i + 1}</span><span class="${sign > 0 ? 'pos' : 'neg'}">${sign > 0 ? '+1' : '-1'}</span></div>`;
    }
    list.innerHTML = html;

    const special = document.getElementById('special-msg');
    if (currentLink === 3) {
        special.innerHTML = '<div class="warn-box"><strong>Surprise!</strong> The Whitehead link has linking number 0, yet the two curves are genuinely linked and cannot be separated! This demonstrates that the linking number is not a complete invariant for links.</div>';
    } else if (currentLink === 0) {
        special.innerHTML = '<div class="info-box">These circles are unlinked. Drag to pull them apart!</div>';
    } else {
        special.innerHTML = '';
    }
}

// Generate link curves
function getUnlinkedCircles(cx, cy, r, t) {
    const off = dragOffset[0];
    const c1 = [], c2 = [];
    for (let i = 0; i <= 80; i++) {
        const a = (i / 80) * Math.PI * 2;
        c1.push([cx - r * 1.2 + off + Math.cos(a) * r * 0.7, cy + Math.sin(a) * r * 0.7]);
        c2.push([cx + r * 1.2 - off + Math.cos(a) * r * 0.7, cy + Math.sin(a) * r * 0.7]);
    }
    return [c1, c2];
}

function getHopfLink(cx, cy, r, t) {
    const c1 = [], c2 = [];
    const wobble = Math.sin(t * 0.5) * 0.1;
    for (let i = 0; i <= 80; i++) {
        const a = (i / 80) * Math.PI * 2;
        // Circle 1 in XY plane
        c1.push([cx + Math.cos(a) * r, cy + Math.sin(a) * r * 0.5]);
        // Circle 2 tilted and offset
        const x2 = Math.cos(a) * r * 0.5;
        const y2 = Math.sin(a) * r;
        c2.push([cx + x2 + wobble * r, cy + y2 * 0.5 + Math.cos(a) * r * 0.3]);
    }
    return [c1, c2];
}

function getSolomonsLink(cx, cy, r, t) {
    const c1 = [], c2 = [];
    for (let i = 0; i <= 100; i++) {
        const a = (i / 100) * Math.PI * 2;
        // Two circles linked twice - torus knot style
        const phase = Math.sin(t * 0.3) * 0.05;
        c1.push([
            cx + Math.cos(a) * r * (1 + 0.3 * Math.cos(2 * a + phase)),
            cy + Math.sin(a) * r * 0.6 * (1 + 0.2 * Math.sin(2 * a))
        ]);
        c2.push([
            cx + Math.cos(a + Math.PI) * r * 0.6 * (1 + 0.2 * Math.cos(2 * a)),
            cy + Math.sin(a) * r * (1 + 0.3 * Math.sin(2 * a + phase))
        ]);
    }
    return [c1, c2];
}

function getWhiteheadLink(cx, cy, r, t) {
    const c1 = [], c2 = [];
    for (let i = 0; i <= 100; i++) {
        const a = (i / 100) * Math.PI * 2;
        const phase = Math.sin(t * 0.4) * 0.05;
        // Whitehead link: more complex intertwining
        c1.push([
            cx + Math.cos(a) * r + Math.sin(2 * a) * r * 0.3,
            cy + Math.sin(a) * r * 0.5
        ]);
        c2.push([
            cx + Math.cos(a) * r * 0.4 + phase * r,
            cy + Math.sin(a) * r + Math.cos(2 * a) * r * 0.2
        ]);
    }
    return [c1, c2];
}

const linkGenerators = [getUnlinkedCircles, getHopfLink, getSolomonsLink, getWhiteheadLink];

// Crossing sign markers
function drawCrossingSigns(curves, signs) {
    if (signs.length === 0) return;
    const c1 = curves[0], c2 = curves[1];

    // Find approximate crossing points
    const crossings = [];
    const step = 3;
    for (let i = 0; i < c1.length - step; i += step) {
        for (let j = 0; j < c2.length - step; j += step) {
            const dx = c1[i][0] - c2[j][0];
            const dy = c1[i][1] - c2[j][1];
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 30) {
                // Check we haven't already found a nearby crossing
                let tooClose = false;
                for (const cr of crossings) {
                    const cdx = cr[0] - c1[i][0];
                    const cdy = cr[1] - c1[i][1];
                    if (cdx * cdx + cdy * cdy < 2500) { tooClose = true; break; }
                }
                if (!tooClose) {
                    crossings.push([(c1[i][0] + c2[j][0]) / 2, (c1[i][1] + c2[j][1]) / 2]);
                }
            }
        }
    }

    // Draw sign labels at crossing locations
    for (let k = 0; k < Math.min(crossings.length, signs.length); k++) {
        const [px, py] = crossings[k];
        const sign = signs[k];

        // Circle background
        ctx.beginPath();
        ctx.arc(px, py - 20, 14, 0, Math.PI * 2);
        ctx.fillStyle = sign > 0 ? 'rgba(60,200,100,0.25)' : 'rgba(220,60,60,0.25)';
        ctx.fill();
        ctx.strokeStyle = sign > 0 ? '#4c8' : '#c44';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        ctx.font = 'bold 14px "Segoe UI", sans-serif';
        ctx.fillStyle = sign > 0 ? '#6e6' : '#f66';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(sign > 0 ? '+1' : '-1', px, py - 20);
    }
}

function drawStrand(points, color, borderColor, lw) {
    if (points.length < 2) return;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(points[0][0], points[0][1]);
    for (let i = 1; i < points.length; i++) ctx.lineTo(points[i][0], points[i][1]);
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = lw + 4;
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(points[0][0], points[0][1]);
    for (let i = 1; i < points.length; i++) ctx.lineTo(points[i][0], points[i][1]);
    ctx.strokeStyle = color;
    ctx.lineWidth = lw;
    ctx.stroke();
}

function drawGrid() {
    ctx.strokeStyle = 'rgba(60, 80, 140, 0.06)';
    ctx.lineWidth = 1;
    for (let x = 0; x < W; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
    for (let y = 0; y < H; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }
}

// Drag interaction
canvas.addEventListener('mousedown', (e) => {
    isDragging = true;
    dragStart = [e.clientX, e.clientY];
});
canvas.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    dragOffset[0] += (e.clientX - dragStart[0]) * 0.3;
    dragStart = [e.clientX, e.clientY];
});
canvas.addEventListener('mouseup', () => { isDragging = false; });
canvas.addEventListener('mouseleave', () => { isDragging = false; });

// Touch support
canvas.addEventListener('touchstart', (e) => {
    isDragging = true;
    dragStart = [e.touches[0].clientX, e.touches[0].clientY];
    e.preventDefault();
});
canvas.addEventListener('touchmove', (e) => {
    if (!isDragging) return;
    dragOffset[0] += (e.touches[0].clientX - dragStart[0]) * 0.3;
    dragStart = [e.touches[0].clientX, e.touches[0].clientY];
    e.preventDefault();
});
canvas.addEventListener('touchend', () => { isDragging = false; });

function animate() {
    ctx.clearRect(0, 0, W, H);
    drawGrid();
    time += 0.02;

    const cx = W * 0.38, cy = H * 0.5;
    const r = Math.min(W, H) * 0.2;
    const data = LINK_DATA[currentLink];

    // Background glow
    const gr = ctx.createRadialGradient(cx, cy, 0, cx, cy, r * 2);
    gr.addColorStop(0, `rgba(60,100,220,${0.04 + 0.01 * Math.sin(time)})`);
    gr.addColorStop(1, 'transparent');
    ctx.fillStyle = gr;
    ctx.beginPath();
    ctx.arc(cx, cy, r * 2, 0, Math.PI * 2);
    ctx.fill();

    // Title
    ctx.font = 'bold 28px "Segoe UI", sans-serif';
    ctx.fillStyle = '#8af';
    ctx.textAlign = 'center';
    ctx.fillText(data.name, cx, 45);

    ctx.font = '14px "Segoe UI", sans-serif';
    ctx.fillStyle = '#88a';
    ctx.fillText(data.desc, cx, 72);

    // Generate curves
    const curves = linkGenerators[currentLink](cx, cy, r, time);

    // Draw curves
    drawStrand(curves[0], '#ff6b8a', '#4a0020', 7);
    drawStrand(curves[1], '#6bafff', '#001a4a', 7);

    // Draw crossing signs
    drawCrossingSigns(curves, data.crossingSigns);

    // Linking number formula display
    if (data.crossingSigns.length > 0) {
        const sum = data.crossingSigns.reduce((a, b) => a + b, 0);
        ctx.font = '16px "Segoe UI", sans-serif';
        ctx.fillStyle = '#aab';
        ctx.textAlign = 'center';
        ctx.fillText(`Sum of signs: ${sum}  /  2  =  ${sum / 2}`, cx, H - 35);
    }

    // Labels for curves
    const lbl1 = curves[0][0];
    const lbl2 = curves[1][0];
    ctx.font = 'bold 13px "Segoe UI", sans-serif';
    ctx.fillStyle = '#ff6b8a';
    ctx.textAlign = 'center';
    ctx.fillText('Component 1', lbl1[0], lbl1[1] - 18);
    ctx.fillStyle = '#6bafff';
    ctx.fillText('Component 2', lbl2[0], lbl2[1] - 18);

    // Separation animation for unlinked
    if (currentLink === 0 && Math.abs(dragOffset[0]) > 100) {
        ctx.font = 'bold 20px "Segoe UI", sans-serif';
        ctx.fillStyle = '#6e6';
        ctx.textAlign = 'center';
        ctx.fillText('Separated! These circles are unlinked.', cx, H * 0.85);
    }

    // Can't separate message for linked ones
    if (currentLink > 0 && Math.abs(dragOffset[0]) > 50) {
        dragOffset[0] *= 0.95; // Spring back
        if (Math.abs(dragOffset[0]) > 60) {
            ctx.font = '16px "Segoe UI", sans-serif';
            ctx.fillStyle = '#f88';
            ctx.textAlign = 'center';
            ctx.fillText('Cannot separate - these curves are linked!', cx, H * 0.88);
        }
    }

    requestAnimationFrame(animate);
}

window.reset = function() {
    currentLink = 0;
    dragOffset = [0, 0];
    selectLink(0);
};

selectLink(0);
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
