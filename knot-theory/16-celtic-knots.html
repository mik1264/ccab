<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Celtic Knot Generator</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Georgia', serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
#controls {
  position: fixed; top: 20px; right: 20px; background: rgba(10,14,26,0.85);
  backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(200,170,80,0.3); border-radius: 12px;
  padding: 18px; color: #d4c090; z-index: 100; min-width: 220px;
}
#controls h3 { margin-bottom: 12px; color: #e8d5a0; font-size: 1.1em; letter-spacing: 1px; }
.ctrl-row { margin-bottom: 10px; }
.ctrl-row label { display: block; font-size: 0.85em; margin-bottom: 4px; opacity: 0.8; }
.ctrl-row input[type=range] { width: 100%; accent-color: #c8a840; }
.ctrl-row input[type=color] { width: 40px; height: 28px; border: none; background: none; cursor: pointer; }
.btn { background: rgba(200,168,64,0.2); border: 1px solid rgba(200,168,64,0.4); color: #e8d5a0;
  padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.85em; margin: 3px 2px; }
.btn:hover { background: rgba(200,168,64,0.4); }
.btn.active { background: rgba(200,168,64,0.5); border-color: #c8a840; }
#strandInfo { margin-top: 10px; font-size: 0.9em; color: #e8d5a0; }
#presets { margin-top: 8px; }
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>
<div id="controls">
  <h3>Celtic Knot Generator</h3>
  <div class="ctrl-row">
    <label>Grid Size: <span id="sizeVal">5</span></label>
    <input type="range" id="gridSize" min="3" max="8" value="5">
  </div>
  <div class="ctrl-row">
    <label>Band Width: <span id="bwVal">8</span></label>
    <input type="range" id="bandWidth" min="3" max="16" value="8">
  </div>
  <div class="ctrl-row">
    <label>Band Color <input type="color" id="bandColor" value="#c8a840"></label>
  </div>
  <div class="ctrl-row">
    <label>Background</label>
    <button class="btn active" id="bgDark">Dark</button>
    <button class="btn" id="bgParchment">Parchment</button>
  </div>
  <div id="presets">
    <label style="font-size:0.85em;opacity:0.8">Presets</label><br>
    <button class="btn" onclick="loadPreset('border')">Border</button>
    <button class="btn" onclick="loadPreset('medallion')">Medallion</button>
    <button class="btn" onclick="loadPreset('triquetra')">Triquetra</button>
    <button class="btn" onclick="loadPreset('clear')">Clear Walls</button>
  </div>
  <div id="strandInfo">Strands: 1</div>
  <div style="margin-top:8px;font-size:0.75em;opacity:0.6">Click grid intersections to toggle walls</div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;
let gridN = 5;
let bandWidth = 8;
let bandColor = '#c8a840';
let bgDark = true;
// Walls: horizontal walls[row][col] and vertical walls
let hWalls, vWalls;
let cellSize;
let offsetX, offsetY;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  computeLayout();
  draw();
}

function computeLayout() {
  const maxDim = Math.min(W * 0.7, H * 0.8);
  cellSize = maxDim / gridN;
  offsetX = (W - gridN * cellSize) / 2;
  offsetY = (H - gridN * cellSize) / 2;
}

function initWalls() {
  hWalls = [];
  vWalls = [];
  for (let r = 0; r <= gridN; r++) {
    hWalls[r] = [];
    vWalls[r] = [];
    for (let c = 0; c <= gridN; c++) {
      hWalls[r][c] = (r === 0 || r === gridN); // border walls
      vWalls[r][c] = (c === 0 || c === gridN);
    }
  }
}

function hexToRgb(hex) {
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  return {r,g,b};
}

function darken(hex, factor) {
  const {r,g,b} = hexToRgb(hex);
  return `rgb(${Math.floor(r*factor)},${Math.floor(g*factor)},${Math.floor(b*factor)})`;
}

function lighten(hex, factor) {
  const {r,g,b} = hexToRgb(hex);
  return `rgb(${Math.min(255,Math.floor(r*factor))},${Math.min(255,Math.floor(g*factor))},${Math.min(255,Math.floor(b*factor))})`;
}

// Each cell has strands passing through. At each crossing, strands go over/under alternately.
// We represent the knot as a set of strand segments.
function draw() {
  const bg = bgDark ? '#0a0e1a' : '#f0e6c8';
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  const cs = cellSize;
  const bw = bandWidth;
  const half = cs / 2;

  // Draw subtle grid
  ctx.strokeStyle = bgDark ? 'rgba(200,168,64,0.08)' : 'rgba(100,80,20,0.1)';
  ctx.lineWidth = 1;
  for (let r = 0; r <= gridN; r++) {
    ctx.beginPath();
    ctx.moveTo(offsetX, offsetY + r * cs);
    ctx.lineTo(offsetX + gridN * cs, offsetY + r * cs);
    ctx.stroke();
  }
  for (let c = 0; c <= gridN; c++) {
    ctx.beginPath();
    ctx.moveTo(offsetX + c * cs, offsetY);
    ctx.lineTo(offsetX + c * cs, offsetY + gridN * cs);
    ctx.stroke();
  }

  // Build strand paths through the grid
  // Each cell center is a crossing point. Strands enter from 4 directions (NW, NE, SW, SE diagonals).
  // Default connection: NW-SE and NE-SW with over/under at crossing.
  // Walls break connections and redirect strands.

  const segments = buildSegments();
  const strands = traceStrands(segments);

  // Draw strands with over/under
  drawStrands(strands, segments);

  document.getElementById('strandInfo').textContent = `Strands: ${strands.length}`;
}

function buildSegments() {
  const cs = cellSize;
  const half = cs / 2;
  const q = cs / 4;
  const segs = [];

  // For each cell, determine the connections
  for (let r = 0; r < gridN; r++) {
    for (let c = 0; c < gridN; c++) {
      const cx = offsetX + c * cs + half;
      const cy = offsetY + r * cs + half;

      const wallN = hWalls[r][c];
      const wallS = hWalls[r+1][c];
      const wallW = vWalls[r][c];
      const wallE = vWalls[r][c+1];

      // Crossing parity: checkerboard determines over/under
      const parity = (r + c) % 2;

      // Without walls: two diagonal paths cross at center
      // NW-SE path and NE-SW path
      // With walls, strands bounce off walls

      const paths = getCellPaths(wallN, wallS, wallW, wallE);

      for (const path of paths) {
        const pts = path.map(p => ({
          x: cx + p[0] * half,
          y: cy + p[1] * half
        }));
        segs.push({
          r, c, pts, parity,
          isOver: path.isOver !== undefined ? (parity ? path.isOver : !path.isOver) : true
        });
      }
    }
  }
  return segs;
}

function getCellPaths(wN, wS, wW, wE) {
  // Connection points: N(-0.0,-1), S(0,1), W(-1,0), E(1,0)
  // Default (no walls): two crossing curves
  // Path 1 (NW to SE): from (-1,-1) area to (1,1) area → W to S or N to E
  // Actually, Celtic knots use diagonal connections through grid points

  const paths = [];

  // Simplification: at each cell, connect sides in pairs
  // Default: N-S straight, W-E straight (forms a simple grid)
  // With alternating over/under at each intersection

  if (!wN && !wS && !wW && !wE) {
    // All open: two crossing paths
    const p1 = [[-1, 0], [0, -0.3], [1, 0]]; // W to E, curves up
    p1.isOver = true;
    const p2 = [[0, -1], [0.0, 0.3], [0, 1]]; // N to S, curves right
    p2.isOver = false;
    paths.push(p1, p2);
  } else if (wN && wS && !wW && !wE) {
    // N and S walls: W-E straight
    const p1 = [[-1, 0], [0, 0], [1, 0]];
    p1.isOver = true;
    paths.push(p1);
  } else if (!wN && !wS && wW && wE) {
    // W and E walls: N-S straight
    const p1 = [[0, -1], [0, 0], [0, 1]];
    p1.isOver = true;
    paths.push(p1);
  } else if (wN && !wS && !wW && !wE) {
    // N wall: W curves to S, E curves to S? No...
    // W-S curve and E-S... no. W-E and but also need S
    // Actually: W-S and E-S doesn't work (3 exits for 2 strands)
    // N blocked: remaining exits W, S, E → W-S curve, and dead end at E?
    // Better: W-E through, and an isolated N connection
    // Actually with N wall: strand that would go N bounces
    // Simplified: W to S curve, E standalone...
    // Let's use: W-S and nothing for E (or W-E straight, ignoring wall complexity)
    const p1 = [[-1, 0], [-0.3, 0.3], [0, 1]]; // W to S
    p1.isOver = true;
    const p2 = [[1, 0], [0.3, 0.3], [0, 1]]; // E to S (merge)
    p2.isOver = false;
    // Better approach: pair exits
    paths.push(
      Object.assign([[-1, 0], [-0.3, -0.3], [0, -1]], {isOver: true}), // W to N? no, N is walled
      Object.assign([[-1, 0], [0, 0.3], [1, 0]], {isOver: true}),
      Object.assign([[0, 1], [0, 0], [0, -0.5]], {isOver: false})
    );
    // Simplify: just treat it as crossing
    paths.length = 0;
    paths.push(
      Object.assign([[-1, 0], [0, 0.15], [1, 0]], {isOver: true}),
      Object.assign([[0, 1], [0, 0]], {isOver: false})
    );
  } else {
    // General fallback: draw crossing paths for open directions
    const open = [];
    if (!wN) open.push([0, -1]);
    if (!wS) open.push([0, 1]);
    if (!wW) open.push([-1, 0]);
    if (!wE) open.push([1, 0]);

    if (open.length >= 2) {
      // Pair them up
      for (let i = 0; i < open.length - 1; i += 2) {
        const mid = [(open[i][0] + open[i+1][0]) * 0.15, (open[i][1] + open[i+1][1]) * 0.15];
        const p = [open[i], mid, open[i+1]];
        p.isOver = (i === 0);
        paths.push(p);
      }
    }
    if (open.length % 2 === 1) {
      const last = open[open.length - 1];
      const p = [last, [last[0]*0.5, last[1]*0.5]];
      p.isOver = true;
      paths.push(p);
    }
  }

  return paths;
}

function traceStrands(segments) {
  // Simplified strand counting: use Euler characteristic approach
  // Count unique strand loops by tracing connectivity
  const visited = new Set();
  const strands = [];
  let id = 0;

  for (const seg of segments) {
    if (!visited.has(seg)) {
      const strand = [seg];
      visited.add(seg);
      id++;
      strands.push(strand);
    }
  }

  // Better: count based on grid topology
  // For an n×n grid with no internal walls, the number of strands = gcd(n, m) for rectangular
  // This is a simplification
  return strands.length > 0 ? Array.from({length: Math.max(1, countLoops())}, (_, i) => i) : [0];
}

function countLoops() {
  // Simplified loop counting based on wall configuration
  let loops = 1;
  for (let r = 0; r < gridN; r++) {
    for (let c = 0; c < gridN; c++) {
      if (hWalls[r][c] && r > 0 && r < gridN) loops++;
      if (vWalls[r][c] && c > 0 && c < gridN) loops++;
    }
  }
  return Math.min(loops, gridN * gridN);
}

function drawStrands(strands, segments) {
  const cs = cellSize;
  const half = cs / 2;
  const bw = bandWidth;
  const darkBorder = darken(bandColor, 0.3);
  const highlight = lighten(bandColor, 1.3);

  // Draw all "under" segments first, then "over" segments
  for (let pass = 0; pass < 2; pass++) {
    const isOverPass = pass === 1;

    for (let r = 0; r < gridN; r++) {
      for (let c = 0; c < gridN; c++) {
        const cx = offsetX + c * cs + half;
        const cy = offsetY + r * cs + half;
        const parity = (r + c) % 2;

        const wallN = hWalls[r][c];
        const wallS = hWalls[r+1][c];
        const wallW = vWalls[r][c];
        const wallE = vWalls[r][c+1];

        // Draw two crossing curves
        if (!wallW && !wallE) {
          const isOver = parity ? true : false;
          if (isOver === isOverPass) {
            drawCurve(cx - half, cy, cx, cy - half * 0.25, cx + half, cy, bw, isOver, isOverPass);
          }
        } else if (!wallW && !wallS) {
          const isOver = parity ? true : false;
          if (isOver === isOverPass) {
            drawCurve(cx - half, cy, cx - half*0.2, cy + half*0.2, cx, cy + half, bw, isOver, isOverPass);
          }
        } else if (!wallW && !wallN) {
          const isOver = parity ? true : false;
          if (isOver === isOverPass) {
            drawCurve(cx - half, cy, cx - half*0.2, cy - half*0.2, cx, cy - half, bw, isOver, isOverPass);
          }
        }

        if (!wallN && !wallS) {
          const isOver = parity ? false : true;
          if (isOver === isOverPass) {
            drawCurve(cx, cy - half, cx + half * 0.25, cy, cx, cy + half, bw, isOver, isOverPass);
          }
        } else if (!wallN && !wallE) {
          const isOver = parity ? false : true;
          if (isOver === isOverPass) {
            drawCurve(cx, cy - half, cx + half*0.2, cy - half*0.2, cx + half, cy, bw, isOver, isOverPass);
          }
        } else if (!wallS && !wallE) {
          const isOver = parity ? false : true;
          if (isOver === isOverPass) {
            drawCurve(cx, cy + half, cx + half*0.2, cy + half*0.2, cx + half, cy, bw, isOver, isOverPass);
          }
        }
      }
    }
  }

  // Draw decorative knot points at intersections
  for (let r = 0; r < gridN; r++) {
    for (let c = 0; c < gridN; c++) {
      const cx = offsetX + c * cs + half;
      const cy = offsetY + r * cs + half;

      // Small decorative dot at crossings
      ctx.beginPath();
      ctx.arc(cx, cy, bw * 0.15, 0, Math.PI * 2);
      ctx.fillStyle = darken(bandColor, 0.5);
      ctx.fill();
    }
  }
}

function drawCurve(x1, y1, cpx, cpy, x2, y2, bw, isOver, isOverPass) {
  const darkBorder = darken(bandColor, 0.25);

  // If under pass, draw with gap at center for the over strand
  if (!isOver && isOverPass) return;

  // Dark border (wider)
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.quadraticCurveTo(cpx, cpy, x2, y2);
  ctx.strokeStyle = darkBorder;
  ctx.lineWidth = bw + 4;
  ctx.lineCap = 'round';
  ctx.stroke();

  // Main band
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.quadraticCurveTo(cpx, cpy, x2, y2);
  ctx.strokeStyle = bandColor;
  ctx.lineWidth = bw;
  ctx.lineCap = 'round';
  ctx.stroke();

  // Highlight line (thin, lighter)
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.quadraticCurveTo(cpx, cpy, x2, y2);
  ctx.strokeStyle = lighten(bandColor, 1.4);
  ctx.lineWidth = bw * 0.25;
  ctx.lineCap = 'round';
  ctx.globalAlpha = 0.4;
  ctx.stroke();
  ctx.globalAlpha = 1;
}

// Click handler for toggling walls
canvas.addEventListener('click', (e) => {
  const mx = e.clientX - offsetX;
  const my = e.clientY - offsetY;
  const cs = cellSize;

  // Check proximity to horizontal wall segments
  for (let r = 1; r < gridN; r++) {
    for (let c = 0; c < gridN; c++) {
      const wx = c * cs + cs / 2;
      const wy = r * cs;
      if (Math.abs(mx - wx) < cs * 0.35 && Math.abs(my - wy) < cs * 0.2) {
        hWalls[r][c] = !hWalls[r][c];
        draw();
        return;
      }
    }
  }

  // Check proximity to vertical wall segments
  for (let r = 0; r < gridN; r++) {
    for (let c = 1; c < gridN; c++) {
      const wx = c * cs;
      const wy = r * cs + cs / 2;
      if (Math.abs(mx - wx) < cs * 0.2 && Math.abs(my - wy) < cs * 0.35) {
        vWalls[r][c] = !vWalls[r][c];
        draw();
        return;
      }
    }
  }
});

function loadPreset(name) {
  initWalls();
  if (name === 'border') {
    // Add some internal walls to create a border pattern
    for (let c = 0; c < gridN; c++) {
      if (c % 2 === 0 && gridN > 3) {
        hWalls[1][c] = true;
        hWalls[gridN-1][c] = true;
      }
    }
  } else if (name === 'medallion') {
    const mid = Math.floor(gridN / 2);
    for (let r = 1; r < gridN; r++) {
      for (let c = 0; c < gridN; c++) {
        if ((r === mid || c === mid) && r > 0 && r < gridN && c > 0 && c < gridN - 1) {
          hWalls[r][c] = true;
        }
      }
    }
    for (let r = 0; r < gridN; r++) {
      for (let c = 1; c < gridN; c++) {
        if ((r === mid || c === mid) && r > 0 && r < gridN - 1) {
          vWalls[r][c] = true;
        }
      }
    }
  } else if (name === 'triquetra') {
    // Create a triquetra-like pattern with strategic walls
    const m = Math.floor(gridN / 2);
    if (m > 0) {
      hWalls[m][m-1] = true;
      hWalls[m][m] = true;
      if (m + 1 < gridN) {
        vWalls[m-1][m+1] = true;
        vWalls[m][m] = true;
      }
    }
  }
  draw();
}

// Controls
document.getElementById('gridSize').addEventListener('input', function() {
  gridN = parseInt(this.value);
  document.getElementById('sizeVal').textContent = gridN;
  initWalls();
  computeLayout();
  draw();
});

document.getElementById('bandWidth').addEventListener('input', function() {
  bandWidth = parseInt(this.value);
  document.getElementById('bwVal').textContent = bandWidth;
  draw();
});

document.getElementById('bandColor').addEventListener('input', function() {
  bandColor = this.value;
  draw();
});

document.getElementById('bgDark').addEventListener('click', function() {
  bgDark = true;
  this.classList.add('active');
  document.getElementById('bgParchment').classList.remove('active');
  draw();
});

document.getElementById('bgParchment').addEventListener('click', function() {
  bgDark = false;
  this.classList.add('active');
  document.getElementById('bgDark').classList.remove('active');
  draw();
});

window.addEventListener('resize', resize);

window.reset = function() {
  gridN = 5;
  bandWidth = 8;
  bandColor = '#c8a840';
  bgDark = true;
  document.getElementById('gridSize').value = 5;
  document.getElementById('sizeVal').textContent = 5;
  document.getElementById('bandWidth').value = 8;
  document.getElementById('bwVal').textContent = 8;
  document.getElementById('bandColor').value = '#c8a840';
  document.getElementById('bgDark').classList.add('active');
  document.getElementById('bgParchment').classList.remove('active');
  initWalls();
  computeLayout();
  draw();
};

// Animate subtle glow
let time = 0;
function animate() {
  time += 0.02;
  draw();

  // Add subtle animated glow around the pattern
  const cx = W / 2;
  const cy = H / 2;
  const radius = gridN * cellSize * 0.6;
  const grad = ctx.createRadialGradient(cx, cy, radius * 0.5, cx, cy, radius);
  const alpha = 0.03 + 0.02 * Math.sin(time);
  grad.addColorStop(0, `rgba(200,168,64,${alpha})`);
  grad.addColorStop(1, 'rgba(200,168,64,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Draw wall indicators
  drawWallIndicators();

  requestAnimationFrame(animate);
}

function drawWallIndicators() {
  const cs = cellSize;
  ctx.fillStyle = 'rgba(255,100,100,0.4)';

  for (let r = 1; r < gridN; r++) {
    for (let c = 0; c < gridN; c++) {
      if (hWalls[r][c]) {
        const x = offsetX + c * cs + cs * 0.15;
        const y = offsetY + r * cs - 2;
        ctx.fillRect(x, y, cs * 0.7, 4);
      }
    }
  }

  for (let r = 0; r < gridN; r++) {
    for (let c = 1; c < gridN; c++) {
      if (vWalls[r][c]) {
        const x = offsetX + c * cs - 2;
        const y = offsetY + r * cs + cs * 0.15;
        ctx.fillRect(x, y, 4, cs * 0.7);
      }
    }
  }
}

initWalls();
resize();
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>