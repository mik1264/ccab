<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Knot Energy Minimization</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
#controls {
  position: fixed; top: 20px; right: 20px; background: rgba(10,14,26,0.85);
  backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(160,120,255,0.3); border-radius: 12px;
  padding: 18px; color: #c0b0e8; z-index: 100; min-width: 230px;
}
#controls h3 { margin-bottom: 12px; color: #b8a0f0; font-size: 1.1em; }
.ctrl-row { margin-bottom: 10px; }
.ctrl-row label { display: block; font-size: 0.85em; margin-bottom: 4px; opacity: 0.8; }
.ctrl-row input[type=range] { width: 100%; accent-color: #8a6ef0; }
.btn { background: rgba(138,110,240,0.2); border: 1px solid rgba(138,110,240,0.4); color: #b8a0f0;
  padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.85em; margin: 3px 2px; }
.btn:hover { background: rgba(138,110,240,0.4); }
.btn.active { background: rgba(138,110,240,0.5); }
#energyGraph { border: 1px solid rgba(138,110,240,0.2); border-radius: 6px; margin-top: 8px; }
#energyVal { color: #e0c0ff; font-weight: bold; }
.knot-btns { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px; }
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>
<div id="controls">
  <h3>Knot Energy Minimization</h3>
  <div class="ctrl-row">
    <label>Initial Knot</label>
    <div class="knot-btns">
      <button class="btn active" id="kTrefoil" onclick="selectKnot('trefoil')">Trefoil</button>
      <button class="btn" id="kFigure8" onclick="selectKnot('figure8')">Figure-8</button>
      <button class="btn" id="kUnknot" onclick="selectKnot('unknot')">Unknot</button>
      <button class="btn" id="kRandom" onclick="selectKnot('random')">Random</button>
    </div>
  </div>
  <div class="ctrl-row">
    <label>Step Size: <span id="stepVal">0.5</span></label>
    <input type="range" id="stepSize" min="1" max="20" value="10">
  </div>
  <div class="ctrl-row">
    <button class="btn" id="minimizeBtn" onclick="toggleMinimize()">Start Minimizing</button>
    <button class="btn" onclick="randomize()">Randomize</button>
  </div>
  <div>Energy: <span id="energyVal">0.00</span></div>
  <canvas id="energyGraph" width="200" height="80"></canvas>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const graphCanvas = document.getElementById('energyGraph');
const gctx = graphCanvas.getContext('2d');
let W, H;

const N = 80; // number of vertices
let vertices = [];
let minimizing = false;
let stepSize = 0.5;
let energy = 0;
let energyHistory = [];
let rotAngleX = 0.3;
let rotAngleY = 0;
let autoRotate = true;
let time = 0;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}

function generateTrefoil(perturb) {
  vertices = [];
  for (let i = 0; i < N; i++) {
    const t = (i / N) * Math.PI * 2;
    let x = Math.sin(t) + 2 * Math.sin(2 * t);
    let y = Math.cos(t) - 2 * Math.cos(2 * t);
    let z = -Math.sin(3 * t);
    if (perturb) {
      x += (Math.random() - 0.5) * 0.5;
      y += (Math.random() - 0.5) * 0.5;
      z += (Math.random() - 0.5) * 0.5;
    }
    vertices.push([x * 40, y * 40, z * 40]);
  }
  energyHistory = [];
}

function generateFigure8(perturb) {
  vertices = [];
  for (let i = 0; i < N; i++) {
    const t = (i / N) * Math.PI * 2;
    let x = (2 + Math.cos(2 * t)) * Math.cos(3 * t);
    let y = (2 + Math.cos(2 * t)) * Math.sin(3 * t);
    let z = Math.sin(4 * t);
    if (perturb) {
      x += (Math.random() - 0.5) * 0.3;
      y += (Math.random() - 0.5) * 0.3;
      z += (Math.random() - 0.5) * 0.3;
    }
    vertices.push([x * 25, y * 25, z * 25]);
  }
  energyHistory = [];
}

function generateUnknot(perturb) {
  vertices = [];
  for (let i = 0; i < N; i++) {
    const t = (i / N) * Math.PI * 2;
    let x = 80 * Math.cos(t);
    let y = 80 * Math.sin(t);
    let z = 0;
    if (perturb) {
      x += (Math.random() - 0.5) * 30;
      y += (Math.random() - 0.5) * 30;
      z += (Math.random() - 0.5) * 30;
    }
    vertices.push([x, y, z]);
  }
  energyHistory = [];
}

function generateRandom() {
  // Start with a trefoil then heavily perturb
  generateTrefoil(false);
  for (let i = 0; i < N; i++) {
    vertices[i][0] += (Math.random() - 0.5) * 60;
    vertices[i][1] += (Math.random() - 0.5) * 60;
    vertices[i][2] += (Math.random() - 0.5) * 60;
  }
  energyHistory = [];
}

function selectKnot(type) {
  document.querySelectorAll('.knot-btns .btn').forEach(b => b.classList.remove('active'));
  if (type === 'trefoil') { generateTrefoil(true); document.getElementById('kTrefoil').classList.add('active'); }
  else if (type === 'figure8') { generateFigure8(true); document.getElementById('kFigure8').classList.add('active'); }
  else if (type === 'unknot') { generateUnknot(true); document.getElementById('kUnknot').classList.add('active'); }
  else { generateRandom(); document.getElementById('kRandom').classList.add('active'); }
}

function randomize() {
  for (let i = 0; i < N; i++) {
    vertices[i][0] += (Math.random() - 0.5) * 20;
    vertices[i][1] += (Math.random() - 0.5) * 20;
    vertices[i][2] += (Math.random() - 0.5) * 20;
  }
}

function toggleMinimize() {
  minimizing = !minimizing;
  const btn = document.getElementById('minimizeBtn');
  btn.textContent = minimizing ? 'Stop Minimizing' : 'Start Minimizing';
  btn.classList.toggle('active', minimizing);
  if (minimizing) autoRotate = true;
}

function computeEnergy() {
  let E = 0;
  for (let i = 0; i < N; i++) {
    for (let j = i + 2; j < N; j++) {
      if (j === (i + N - 1) % N) continue; // skip adjacent
      const dx = vertices[i][0] - vertices[j][0];
      const dy = vertices[i][1] - vertices[j][1];
      const dz = vertices[i][2] - vertices[j][2];
      const dist2 = dx*dx + dy*dy + dz*dz;
      if (dist2 > 0.01) E += 1.0 / dist2;
    }
  }
  return E;
}

function minimizeStep() {
  const forces = vertices.map(() => [0, 0, 0]);
  const dt = stepSize * 0.001;

  // Repulsion between non-adjacent vertices
  for (let i = 0; i < N; i++) {
    for (let j = i + 2; j < N; j++) {
      if (j === (i + N - 1) % N) continue;
      const dx = vertices[i][0] - vertices[j][0];
      const dy = vertices[i][1] - vertices[j][1];
      const dz = vertices[i][2] - vertices[j][2];
      const dist2 = dx*dx + dy*dy + dz*dz;
      if (dist2 < 1) continue;
      const dist = Math.sqrt(dist2);
      const force = 2.0 / (dist2 * dist); // gradient of 1/r^2
      const fx = force * dx / dist;
      const fy = force * dy / dist;
      const fz = force * dz / dist;
      forces[i][0] += fx; forces[i][1] += fy; forces[i][2] += fz;
      forces[j][0] -= fx; forces[j][1] -= fy; forces[j][2] -= fz;
    }
  }

  // Spring forces to maintain uniform spacing
  const targetLen = getTotalLength() / N;
  for (let i = 0; i < N; i++) {
    const j = (i + 1) % N;
    const dx = vertices[j][0] - vertices[i][0];
    const dy = vertices[j][1] - vertices[i][1];
    const dz = vertices[j][2] - vertices[i][2];
    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
    if (dist < 0.01) continue;
    const springF = 0.5 * (dist - targetLen);
    const fx = springF * dx / dist;
    const fy = springF * dy / dist;
    const fz = springF * dz / dist;
    forces[i][0] += fx; forces[i][1] += fy; forces[i][2] += fz;
    forces[j][0] -= fx; forces[j][1] -= fy; forces[j][2] -= fz;
  }

  // Bending resistance (smoothness)
  for (let i = 0; i < N; i++) {
    const prev = (i - 1 + N) % N;
    const next = (i + 1) % N;
    const mx = (vertices[prev][0] + vertices[next][0]) / 2;
    const my = (vertices[prev][1] + vertices[next][1]) / 2;
    const mz = (vertices[prev][2] + vertices[next][2]) / 2;
    forces[i][0] += 0.1 * (mx - vertices[i][0]);
    forces[i][1] += 0.1 * (my - vertices[i][1]);
    forces[i][2] += 0.1 * (mz - vertices[i][2]);
  }

  // Apply forces
  for (let i = 0; i < N; i++) {
    const mag = Math.sqrt(forces[i][0]**2 + forces[i][1]**2 + forces[i][2]**2);
    const maxF = 5;
    const scale = mag > maxF ? maxF / mag : 1;
    vertices[i][0] += forces[i][0] * dt * scale;
    vertices[i][1] += forces[i][1] * dt * scale;
    vertices[i][2] += forces[i][2] * dt * scale;
  }

  // Center
  let cx = 0, cy = 0, cz = 0;
  for (const v of vertices) { cx += v[0]; cy += v[1]; cz += v[2]; }
  cx /= N; cy /= N; cz /= N;
  for (const v of vertices) { v[0] -= cx; v[1] -= cy; v[2] -= cz; }
}

function getTotalLength() {
  let len = 0;
  for (let i = 0; i < N; i++) {
    const j = (i + 1) % N;
    const dx = vertices[j][0] - vertices[i][0];
    const dy = vertices[j][1] - vertices[i][1];
    const dz = vertices[j][2] - vertices[i][2];
    len += Math.sqrt(dx*dx + dy*dy + dz*dz);
  }
  return len;
}

function project(x, y, z) {
  const cosA = Math.cos(rotAngleY);
  const sinA = Math.sin(rotAngleY);
  const cosB = Math.cos(rotAngleX);
  const sinB = Math.sin(rotAngleX);

  const x1 = x * cosA - z * sinA;
  const z1 = x * sinA + z * cosA;
  const y1 = y * cosB - z1 * sinB;
  const z2 = y * sinB + z1 * cosB;

  const fov = 600;
  const p = fov / (fov + z2 + 200);
  return { x: W/2 + x1 * p * 2, y: H/2 + y1 * p * 2, z: z2, s: p };
}

function draw() {
  ctx.fillStyle = '#0a0e1a';
  ctx.fillRect(0, 0, W, H);

  // Background glow
  const grad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, H * 0.4);
  grad.addColorStop(0, 'rgba(60,40,100,0.1)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Project all vertices
  const projected = vertices.map(v => project(v[0], v[1], v[2]));

  // Build segments with depth info for proper z-ordering
  const segments = [];
  for (let i = 0; i < N; i++) {
    const j = (i + 1) % N;
    segments.push({
      i, j,
      p1: projected[i],
      p2: projected[j],
      z: (projected[i].z + projected[j].z) / 2
    });
  }

  // Sort by depth (far to near)
  segments.sort((a, b) => a.z - b.z);

  // Draw segments
  for (const seg of segments) {
    const { p1, p2 } = seg;
    const t = seg.i / N;

    // Color varies along the knot
    const hue = t * 360;
    const brightness = Math.max(30, Math.min(80, 55 + seg.z * 0.2));
    const saturation = 70;

    // Tube effect: draw wider dark, then thinner light
    const width = 4 * ((p1.s + p2.s) / 2);

    // Shadow/tube border
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.strokeStyle = `hsl(${hue}, ${saturation}%, ${brightness * 0.3}%)`;
    ctx.lineWidth = width + 3;
    ctx.lineCap = 'round';
    ctx.stroke();

    // Main color
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.strokeStyle = `hsl(${hue}, ${saturation}%, ${brightness}%)`;
    ctx.lineWidth = width;
    ctx.lineCap = 'round';
    ctx.stroke();

    // Highlight
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.strokeStyle = `hsla(${hue}, 40%, 90%, 0.25)`;
    ctx.lineWidth = width * 0.3;
    ctx.lineCap = 'round';
    ctx.stroke();
  }

  // Draw vertices as small dots
  for (const p of projected) {
    ctx.beginPath();
    ctx.arc(p.x, p.y, 1.5 * p.s, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.fill();
  }
}

function drawEnergyGraph() {
  const gw = graphCanvas.width;
  const gh = graphCanvas.height;
  gctx.fillStyle = 'rgba(10,14,26,0.9)';
  gctx.fillRect(0, 0, gw, gh);

  if (energyHistory.length < 2) return;

  const maxE = Math.max(...energyHistory);
  const minE = Math.min(...energyHistory);
  const range = maxE - minE || 1;

  gctx.beginPath();
  const start = Math.max(0, energyHistory.length - gw);
  for (let i = start; i < energyHistory.length; i++) {
    const x = ((i - start) / Math.max(1, energyHistory.length - start - 1)) * gw;
    const y = gh - ((energyHistory[i] - minE) / range) * (gh - 10) - 5;
    if (i === start) gctx.moveTo(x, y);
    else gctx.lineTo(x, y);
  }
  gctx.strokeStyle = '#8a6ef0';
  gctx.lineWidth = 1.5;
  gctx.stroke();

  // Gradient fill
  const grad = gctx.createLinearGradient(0, 0, 0, gh);
  grad.addColorStop(0, 'rgba(138,110,240,0.3)');
  grad.addColorStop(1, 'rgba(138,110,240,0)');
  gctx.lineTo(gw, gh);
  gctx.lineTo(0, gh);
  gctx.fillStyle = grad;
  gctx.fill();
}

// Mouse drag
let dragging = false;
let lastMX = 0, lastMY = 0;
canvas.addEventListener('mousedown', e => { dragging = true; lastMX = e.clientX; lastMY = e.clientY; autoRotate = false; });
canvas.addEventListener('mousemove', e => {
  if (dragging) {
    rotAngleY += (e.clientX - lastMX) * 0.005;
    rotAngleX += (e.clientY - lastMY) * 0.005;
    lastMX = e.clientX; lastMY = e.clientY;
  }
});
canvas.addEventListener('mouseup', () => { dragging = false; autoRotate = true; });
canvas.addEventListener('mouseleave', () => { dragging = false; });

canvas.addEventListener('touchstart', e => { dragging = true; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; autoRotate = false; });
canvas.addEventListener('touchmove', e => {
  if (dragging) {
    rotAngleY += (e.touches[0].clientX - lastMX) * 0.005;
    rotAngleX += (e.touches[0].clientY - lastMY) * 0.005;
    lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY;
  }
});
canvas.addEventListener('touchend', () => { dragging = false; autoRotate = true; });

document.getElementById('stepSize').addEventListener('input', function() {
  stepSize = parseInt(this.value) / 20;
  document.getElementById('stepVal').textContent = stepSize.toFixed(2);
});

window.addEventListener('resize', resize);

window.reset = function() {
  minimizing = false;
  document.getElementById('minimizeBtn').textContent = 'Start Minimizing';
  document.getElementById('minimizeBtn').classList.remove('active');
  stepSize = 0.5;
  document.getElementById('stepSize').value = 10;
  document.getElementById('stepVal').textContent = '0.50';
  rotAngleX = 0.3; rotAngleY = 0; autoRotate = true;
  selectKnot('trefoil');
};

function animate() {
  time += 0.016;
  if (autoRotate && !dragging) rotAngleY += 0.008;

  if (minimizing) {
    for (let i = 0; i < 5; i++) minimizeStep();
    energy = computeEnergy();
    energyHistory.push(energy);
    if (energyHistory.length > 500) energyHistory.shift();
    document.getElementById('energyVal').textContent = energy.toFixed(2);
    drawEnergyGraph();
  }

  draw();
  requestAnimationFrame(animate);
}

generateTrefoil(true);
resize();
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>