<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Reidemeister Moves - Knot Theory</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: #e0e0e0; }
canvas { display: block; }
a.back { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
a.back:hover { color: #adf; }

#panel {
    position: fixed; top: 20px; right: 20px; width: 320px;
    background: rgba(10, 14, 30, 0.85); backdrop-filter: blur(10px);
    border: 1px solid rgba(100, 140, 255, 0.2); border-radius: 16px;
    padding: 20px; z-index: 100; max-height: calc(100vh - 40px); overflow-y: auto;
}
#panel h2 { color: #8af; font-size: 1.2em; margin-bottom: 8px; }
#panel p { font-size: 0.85em; line-height: 1.5; color: #aab; margin-bottom: 12px; }
.move-btn {
    display: block; width: 100%; padding: 12px 16px; margin-bottom: 8px;
    background: rgba(60, 80, 140, 0.3); border: 1px solid rgba(100, 140, 255, 0.3);
    border-radius: 10px; color: #cdf; cursor: pointer; text-align: left;
    font-size: 0.9em; transition: all 0.3s;
}
.move-btn:hover { background: rgba(80, 110, 200, 0.4); border-color: rgba(130, 170, 255, 0.5); }
.move-btn.active { background: rgba(80, 130, 255, 0.35); border-color: #8af; box-shadow: 0 0 15px rgba(100, 140, 255, 0.2); }
.move-btn .label { font-weight: 700; color: #8af; }
.move-btn .desc { font-size: 0.8em; color: #99b; margin-top: 4px; }

#auto-btn {
    display: block; width: 100%; padding: 10px; margin-top: 8px;
    background: rgba(100, 200, 120, 0.2); border: 1px solid rgba(100, 200, 120, 0.4);
    border-radius: 10px; color: #8e8; cursor: pointer; font-size: 0.85em; transition: all 0.3s;
}
#auto-btn:hover { background: rgba(100, 200, 120, 0.35); }
#auto-btn.active { background: rgba(100, 200, 120, 0.35); border-color: #8e8; }

.insight {
    margin-top: 12px; padding: 10px; background: rgba(200, 160, 80, 0.1);
    border-left: 3px solid #da5; border-radius: 0 8px 8px 0;
    font-size: 0.78em; line-height: 1.5; color: #cb8;
}
#status { margin-top: 10px; text-align: center; font-size: 0.85em; color: #8af; min-height: 20px; }
</style>
</head>
<body>
<a href="index.html" class="back">&larr; Back</a>
<canvas id="canvas"></canvas>

<div id="panel">
    <h2>Reidemeister Moves</h2>
    <p>The three fundamental transformations that generate ALL knot equivalences. Click to see each move animated.</p>

    <button class="move-btn active" data-move="R1" onclick="selectMove(0)">
        <div class="label">R1 &mdash; Twist</div>
        <div class="desc">Add or remove a simple twist/loop. Changes crossing count by &plusmn;1.</div>
    </button>
    <button class="move-btn" data-move="R2" onclick="selectMove(1)">
        <div class="label">R2 &mdash; Poke</div>
        <div class="desc">Push one strand over another. Creates or removes 2 crossings.</div>
    </button>
    <button class="move-btn" data-move="R3" onclick="selectMove(2)">
        <div class="label">R3 &mdash; Slide</div>
        <div class="desc">Slide a strand past a crossing. Crossing count stays the same.</div>
    </button>

    <button id="auto-btn" onclick="toggleAuto()">Auto-Cycle Demo</button>

    <div class="insight">
        "Kurt Reidemeister proved in 1927: if two diagrams represent the same knot, one can be transformed into the other using only these three moves."
    </div>
    <div id="status"></div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

let currentMove = 0;
let animT = 0;
let animDir = 1;
let animSpeed = 0.008;
let autoMode = false;
let autoCycleTimer = 0;
const moveNames = ['R1 - Twist', 'R2 - Poke', 'R3 - Slide'];
const moveColors = [
    ['#ff6b8a', '#ff8fa8'],
    ['#6bafff', '#8fc8ff'],
    ['#6bffa8', '#8fffc8']
];

function selectMove(idx) {
    currentMove = idx;
    animT = 0;
    animDir = 1;
    document.querySelectorAll('.move-btn').forEach((b, i) => {
        b.classList.toggle('active', i === idx);
    });
    document.getElementById('status').textContent = moveNames[idx] + ' selected';
}

function toggleAuto() {
    autoMode = !autoMode;
    document.getElementById('auto-btn').classList.toggle('active', autoMode);
    document.getElementById('auto-btn').textContent = autoMode ? 'Stop Auto-Cycle' : 'Auto-Cycle Demo';
    if (autoMode) { autoCycleTimer = 0; animT = 0; animDir = 1; }
}

// Smooth easing
function ease(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

// Draw a thick rope-like strand
function drawStrand(points, color, borderColor, lineWidth) {
    if (points.length < 2) return;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    // Shadow / border
    ctx.beginPath();
    ctx.moveTo(points[0][0], points[0][1]);
    for (let i = 1; i < points.length; i++) ctx.lineTo(points[i][0], points[i][1]);
    ctx.strokeStyle = borderColor || 'rgba(0,0,0,0.6)';
    ctx.lineWidth = (lineWidth || 8) + 4;
    ctx.stroke();
    // Main strand
    ctx.beginPath();
    ctx.moveTo(points[0][0], points[0][1]);
    for (let i = 1; i < points.length; i++) ctx.lineTo(points[i][0], points[i][1]);
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth || 8;
    ctx.stroke();
}

// Draw smooth curve through points (catmull-rom)
function catmullRom(pts, segments) {
    const result = [];
    for (let i = 0; i < pts.length - 1; i++) {
        const p0 = pts[Math.max(0, i - 1)];
        const p1 = pts[i];
        const p2 = pts[Math.min(pts.length - 1, i + 1)];
        const p3 = pts[Math.min(pts.length - 1, i + 2)];
        for (let s = 0; s < segments; s++) {
            const t = s / segments;
            const t2 = t * t, t3 = t2 * t;
            const x = 0.5 * ((2 * p1[0]) + (-p0[0] + p2[0]) * t + (2 * p0[0] - 5 * p1[0] + 4 * p2[0] - p3[0]) * t2 + (-p0[0] + 3 * p1[0] - 3 * p2[0] + p3[0]) * t3);
            const y = 0.5 * ((2 * p1[1]) + (-p0[1] + p2[1]) * t + (2 * p0[1] - 5 * p1[1] + 4 * p2[1] - p3[1]) * t2 + (-p0[1] + 3 * p1[1] - 3 * p2[1] + p3[1]) * t3);
            result.push([x, y]);
        }
    }
    result.push(pts[pts.length - 1]);
    return result;
}

function lerp(a, b, t) { return a + (b - a) * t; }
function lerpPt(a, b, t) { return [lerp(a[0], b[0], t), lerp(a[1], b[1], t)]; }
function lerpPts(arr1, arr2, t) { return arr1.map((p, i) => lerpPt(p, arr2[i] || p, t)); }

// ---- R1: Twist Move ----
function getR1Before(cx, cy, s) {
    return [
        [cx - 2 * s, cy],
        [cx - s, cy],
        [cx, cy],
        [cx + s, cy],
        [cx + 2 * s, cy]
    ];
}
function getR1After(cx, cy, s) {
    return [
        [cx - 2 * s, cy],
        [cx - 0.8 * s, cy],
        [cx - 0.2 * s, cy - 1.2 * s],
        [cx + 0.4 * s, cy + 0.3 * s],
        [cx + 2 * s, cy]
    ];
}

// ---- R2: Poke Move ----
function getR2BeforeTop(cx, cy, s) {
    return [[cx - 2 * s, cy - 0.5 * s], [cx - s, cy - 0.5 * s], [cx, cy - 0.5 * s], [cx + s, cy - 0.5 * s], [cx + 2 * s, cy - 0.5 * s]];
}
function getR2BeforeBot(cx, cy, s) {
    return [[cx - 2 * s, cy + 0.5 * s], [cx - s, cy + 0.5 * s], [cx, cy + 0.5 * s], [cx + s, cy + 0.5 * s], [cx + 2 * s, cy + 0.5 * s]];
}
function getR2AfterTop(cx, cy, s) {
    return [[cx - 2 * s, cy - 0.5 * s], [cx - 0.6 * s, cy - 0.5 * s], [cx, cy + 0.8 * s], [cx + 0.6 * s, cy - 0.5 * s], [cx + 2 * s, cy - 0.5 * s]];
}
function getR2AfterBot(cx, cy, s) {
    return [[cx - 2 * s, cy + 0.5 * s], [cx - 0.6 * s, cy + 0.5 * s], [cx, cy - 0.8 * s], [cx + 0.6 * s, cy + 0.5 * s], [cx + 2 * s, cy + 0.5 * s]];
}

// ---- R3: Slide Move ----
function getR3Strands(cx, cy, s, t) {
    const shift = t * 1.2 * s;
    return {
        s1: [[cx - 2 * s, cy - s + shift], [cx - 0.5 * s, cy - 0.3 * s + shift * 0.3], [cx + 0.5 * s, cy + 0.3 * s - shift * 0.3], [cx + 2 * s, cy + s - shift]],
        s2: [[cx - 2 * s, cy + s - shift], [cx - 0.5 * s, cy + 0.3 * s - shift * 0.3], [cx + 0.5 * s, cy - 0.3 * s + shift * 0.3], [cx + 2 * s, cy - s + shift]],
        s3: [[cx + shift * 0.4, cy - 1.5 * s], [cx + shift * 0.4, cy - 0.5 * s], [cx + shift * 0.4, cy + 0.5 * s], [cx + shift * 0.4, cy + 1.5 * s]]
    };
}

function drawCrossingGap(over, under, gapSize, overColor, underColor, borderColor, lw) {
    // Draw under strand with gap at intersection
    const overSmooth = catmullRom(over, 20);
    const underSmooth = catmullRom(under, 20);

    // Find approximate intersection
    let minDist = Infinity, minIdx = 0;
    for (let i = 0; i < underSmooth.length; i++) {
        for (let j = 0; j < overSmooth.length; j++) {
            const dx = underSmooth[i][0] - overSmooth[j][0];
            const dy = underSmooth[i][1] - overSmooth[j][1];
            const d = dx * dx + dy * dy;
            if (d < minDist) { minDist = d; minIdx = i; }
        }
    }

    // Split under strand at gap
    const gap = gapSize || 8;
    const before = underSmooth.slice(0, Math.max(0, minIdx - gap));
    const after = underSmooth.slice(Math.min(underSmooth.length, minIdx + gap));

    if (before.length > 1) drawStrand(before, underColor, borderColor, lw);
    if (after.length > 1) drawStrand(after, underColor, borderColor, lw);

    // Draw over strand on top
    drawStrand(overSmooth, overColor, borderColor, lw);
}

// Draw arrow
function drawArrow(x1, y1, x2, y2, color) {
    const dx = x2 - x1, dy = y2 - y1;
    const len = Math.sqrt(dx * dx + dy * dy);
    const nx = dx / len, ny = dy / len;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.stroke();
    // Arrowhead
    const ax = x2 - nx * 15 - ny * 8;
    const ay = y2 - ny * 15 + nx * 8;
    const bx = x2 - nx * 15 + ny * 8;
    const by = y2 - ny * 15 - nx * 8;
    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(ax, ay);
    ctx.lineTo(bx, by);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
}

// Draw label
function drawLabel(text, x, y, color, size) {
    ctx.font = `bold ${size || 24}px 'Segoe UI', sans-serif`;
    ctx.fillStyle = color || '#fff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, x, y);
}

// Background grid
function drawGrid() {
    ctx.strokeStyle = 'rgba(60, 80, 140, 0.08)';
    ctx.lineWidth = 1;
    const gridSize = 40;
    for (let x = 0; x < W; x += gridSize) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
    }
    for (let y = 0; y < H; y += gridSize) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
    }
}

// Draw glow circle
function drawGlow(x, y, r, color) {
    const g = ctx.createRadialGradient(x, y, 0, x, y, r);
    g.addColorStop(0, color);
    g.addColorStop(1, 'transparent');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
}

function drawR1(t) {
    const cx = W * 0.4, cy = H * 0.5;
    const s = Math.min(W, H) * 0.12;
    const et = ease(t);

    // Before state (left side)
    const bx = cx - s * 2.5;
    const before = catmullRom(getR1Before(bx, cy, s), 20);
    drawStrand(before, moveColors[0][0], '#2a0020', 7);
    drawLabel('Before', bx, cy - s * 1.8, '#ff6b8a', 18);

    // Arrow
    drawArrow(bx + s * 2.5, cy, bx + s * 3.5, cy, 'rgba(255,107,138,0.5)');

    // After state (right side) - animated
    const ax = cx + s * 2.5;
    const pts = lerpPts(getR1Before(ax, cy, s), getR1After(ax, cy, s), et);
    const after = catmullRom(pts, 20);

    // The loop creates a crossing - draw with gap for under strand
    if (et > 0.3) {
        // Draw the self-crossing loop
        const mid = Math.floor(after.length * 0.45);
        const part1 = after.slice(0, mid);
        const part2 = after.slice(mid);
        drawStrand(part1, moveColors[0][0], '#2a0020', 7);
        drawStrand(part2, moveColors[0][1], '#2a0020', 7);
    } else {
        drawStrand(after, moveColors[0][0], '#2a0020', 7);
    }
    drawLabel('After', ax, cy - s * 1.8, '#ff8fa8', 18);

    // Highlight region
    if (et > 0.1) {
        drawGlow(ax - 0.1 * s, cy - 0.5 * s * et, s * 1.5, `rgba(255,107,138,${0.05 * et})`);
    }
}

function drawR2(t) {
    const cx = W * 0.4, cy = H * 0.5;
    const s = Math.min(W, H) * 0.12;
    const et = ease(t);

    // Before (left)
    const bx = cx - s * 2.5;
    const bt = catmullRom(getR2BeforeTop(bx, cy, s), 20);
    const bb = catmullRom(getR2BeforeBot(bx, cy, s), 20);
    drawStrand(bt, moveColors[1][0], '#001a2a', 7);
    drawStrand(bb, moveColors[1][1], '#001a2a', 7);
    drawLabel('Before', bx, cy - s * 2, '#6bafff', 18);

    // Arrow
    drawArrow(bx + s * 2.5, cy, bx + s * 3.5, cy, 'rgba(107,175,255,0.5)');

    // After (right) - animated
    const ax = cx + s * 2.5;
    const topPts = lerpPts(getR2BeforeTop(ax, cy, s), getR2AfterTop(ax, cy, s), et);
    const botPts = lerpPts(getR2BeforeBot(ax, cy, s), getR2AfterBot(ax, cy, s), et);

    if (et > 0.4) {
        drawCrossingGap(catmullRom(topPts, 20).map(p => p), botPts, 6, moveColors[1][0], moveColors[1][1], '#001a2a', 7);
        const topSmooth = catmullRom(topPts, 20);
        // Find second crossing for double gap effect
        drawStrand(topSmooth, moveColors[1][0], '#001a2a', 7);
        // Re-draw bottom with gaps
        const botSmooth = catmullRom(botPts, 20);
        // Simple approach: draw bottom under top
        drawCrossingGap(topPts, botPts, 5, moveColors[1][0], moveColors[1][1], '#001a2a', 7);
    } else {
        drawStrand(catmullRom(topPts, 20), moveColors[1][0], '#001a2a', 7);
        drawStrand(catmullRom(botPts, 20), moveColors[1][1], '#001a2a', 7);
    }
    drawLabel('After', ax, cy - s * 2, '#8fc8ff', 18);
}

function drawR3(t) {
    const cx = W * 0.4, cy = H * 0.5;
    const s = Math.min(W, H) * 0.12;
    const et = ease(t);

    // Animate the vertical strand sliding through
    const slideT = et * 2 - 1; // -1 to 1

    // Before (left)
    const bx = cx - s * 2.5;
    const bStrands = getR3Strands(bx, cy, s, 0);
    drawStrand(catmullRom(bStrands.s1, 20), '#6bffa8', '#002a10', 6);
    drawStrand(catmullRom(bStrands.s2, 20), '#a8ff6b', '#002a10', 6);
    drawStrand(catmullRom(bStrands.s3, 20), '#ffa86b', '#2a1000', 6);
    drawLabel('Before', bx, cy - s * 2.2, '#6bffa8', 18);

    // Arrow
    drawArrow(bx + s * 2.5, cy, bx + s * 3.5, cy, 'rgba(107,255,168,0.5)');

    // After (right) - animated
    const ax = cx + s * 2.5;
    const aStrands = getR3Strands(ax, cy, s, slideT);
    drawStrand(catmullRom(aStrands.s1, 20), '#6bffa8', '#002a10', 6);
    drawStrand(catmullRom(aStrands.s2, 20), '#a8ff6b', '#002a10', 6);
    drawStrand(catmullRom(aStrands.s3, 20), '#ffa86b', '#2a1000', 6);
    drawLabel('After', ax, cy - s * 2.2, '#8fffc8', 18);
}

const drawFuncs = [drawR1, drawR2, drawR3];

function animate() {
    ctx.clearRect(0, 0, W, H);
    drawGrid();

    // Title glow
    drawGlow(W * 0.4, H * 0.1, 200, `rgba(${currentMove === 0 ? '255,107,138' : currentMove === 1 ? '107,175,255' : '107,255,168'},0.03)`);

    // Draw title
    drawLabel(moveNames[currentMove], W * 0.4, H * 0.08, moveColors[currentMove][0], 32);

    // Animate current move
    drawFuncs[currentMove](animT);

    // Update animation
    animT += animSpeed * animDir;
    if (animT >= 1) { animT = 1; animDir = -1; }
    if (animT <= 0) { animT = 0; animDir = 1; }

    // Auto-cycle
    if (autoMode) {
        autoCycleTimer++;
        if (autoCycleTimer > 300) {
            autoCycleTimer = 0;
            selectMove((currentMove + 1) % 3);
        }
    }

    requestAnimationFrame(animate);
}

window.reset = function() {
    currentMove = 0;
    animT = 0;
    animDir = 1;
    autoMode = false;
    selectMove(0);
    document.getElementById('auto-btn').classList.remove('active');
    document.getElementById('auto-btn').textContent = 'Auto-Cycle Demo';
};

animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>
