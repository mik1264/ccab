<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DNA Topology</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
a { position: fixed; top: 20px; left: 20px; color: #8af; text-decoration: none; z-index: 100; font-size: 1.2em; }
#controls {
  position: fixed; top: 20px; right: 20px; background: rgba(10,14,26,0.85);
  backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(80,140,255,0.3); border-radius: 12px;
  padding: 18px; color: #a0c4e8; z-index: 100; min-width: 240px;
}
#controls h3 { margin-bottom: 12px; color: #7eb8ff; font-size: 1.1em; }
.ctrl-row { margin-bottom: 10px; }
.ctrl-row label { display: block; font-size: 0.85em; margin-bottom: 4px; opacity: 0.8; }
.ctrl-row input[type=range] { width: 100%; accent-color: #4a8ef7; }
.btn { background: rgba(74,142,247,0.2); border: 1px solid rgba(74,142,247,0.4); color: #7eb8ff;
  padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.85em; margin: 3px 2px; }
.btn:hover { background: rgba(74,142,247,0.4); }
.btn.active { background: rgba(74,142,247,0.5); }
#info { margin-top: 12px; font-size: 0.78em; color: #8ab; line-height: 1.4; padding: 8px;
  background: rgba(40,60,100,0.3); border-radius: 6px; }
.mode-btns { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 6px; }
#lkNum { color: #7ef; font-weight: bold; }
</style>
</head>
<body>
<a href="index.html">&#8592; Back</a>
<canvas id="c"></canvas>
<div id="controls">
  <h3>DNA Topology</h3>
  <div class="ctrl-row">
    <label>Mode</label>
    <div class="mode-btns">
      <button class="btn active" id="mSupercoil" onclick="setMode('supercoil')">Supercoiling</button>
      <button class="btn" id="mKnot" onclick="setMode('knot')">Knotting</button>
      <button class="btn" id="mCatenane" onclick="setMode('catenane')">Catenation</button>
    </div>
  </div>
  <div class="ctrl-row">
    <label>Supercoiling: <span id="scVal">0</span></label>
    <input type="range" id="supercoil" min="-50" max="50" value="0">
  </div>
  <div class="ctrl-row">
    <label>Rotation Speed</label>
    <input type="range" id="rotSpeed" min="0" max="100" value="30">
  </div>
  <div class="ctrl-row">
    <input type="checkbox" id="showBP" checked> <label style="display:inline;font-size:0.85em">Show Base Pairs</label>
  </div>
  <div class="ctrl-row">
    <button class="btn" onclick="addKnot()">Add Crossing</button>
    <button class="btn" onclick="topoisomerase()">Topoisomerase</button>
  </div>
  <div>Linking Number: <span id="lkNum">0</span></div>
  <div id="info">
    Topoisomerase inhibitors are used as cancer drugs - they prevent DNA from unknotting, killing rapidly dividing cells.
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

let mode = 'supercoil';
let supercoilVal = 0;
let rotAngle = 0;
let rotSpeed = 0.3;
let showBasePairs = true;
let linkingNumber = 0;
let knots = 0;
let topoAnim = 0;
let topoActive = false;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}

function setMode(m) {
  mode = m;
  document.querySelectorAll('.mode-btns .btn').forEach(b => b.classList.remove('active'));
  document.getElementById('m' + m.charAt(0).toUpperCase() + m.slice(1)).classList.add('active');
}

function addKnot() {
  knots++;
  linkingNumber += 1;
  document.getElementById('lkNum').textContent = linkingNumber;
}

function topoisomerase() {
  if (linkingNumber !== 0) {
    topoActive = true;
    topoAnim = 0;
  }
}

function project3D(x, y, z, cx, cy, scale) {
  const fov = 600;
  const cosR = Math.cos(rotAngle);
  const sinR = Math.sin(rotAngle);
  const rx = x * cosR - z * sinR;
  const rz = x * sinR + z * cosR;
  const tilt = 0.3;
  const cosT = Math.cos(tilt);
  const sinT = Math.sin(tilt);
  const ry2 = y * cosT - rz * sinT;
  const rz2 = y * sinT + rz * cosT;
  const perspective = fov / (fov + rz2 + 300);
  return {
    x: cx + rx * perspective * scale,
    y: cy + ry2 * perspective * scale,
    z: rz2,
    s: perspective
  };
}

function drawDNA(time) {
  const cx = W / 2;
  const cy = H / 2;
  const sc = supercoilVal / 10;
  const helixRadius = 40;
  const pitch = 15;
  const numPoints = 300;
  const length = 20;
  const scale = Math.min(W, H) / 500 * 8;

  const strand1 = [];
  const strand2 = [];
  const basePairs = [];

  if (mode === 'supercoil') {
    for (let i = 0; i < numPoints; i++) {
      const t = (i / numPoints) * length - length / 2;
      const helixT = t * 0.8;

      // Supercoiled helix: helix of a helix
      const superR = 20 * Math.abs(sc);
      const superFreq = sc * 0.3;

      const baseX = superR * Math.sin(superFreq * t);
      const baseZ = superR * Math.cos(superFreq * t);

      const x1 = baseX + helixRadius * Math.cos(helixT) * 0.3;
      const y1 = t * pitch;
      const z1 = baseZ + helixRadius * Math.sin(helixT) * 0.3;

      const x2 = baseX + helixRadius * Math.cos(helixT + Math.PI) * 0.3;
      const y2 = t * pitch;
      const z2 = baseZ + helixRadius * Math.sin(helixT + Math.PI) * 0.3;

      const p1 = project3D(x1, y1, z1, cx, cy, scale);
      const p2 = project3D(x2, y2, z2, cx, cy, scale);

      strand1.push(p1);
      strand2.push(p2);

      if (i % 5 === 0) {
        basePairs.push({ a: p1, b: p2 });
      }
    }
  } else if (mode === 'knot') {
    // Circular DNA (plasmid) that can be knotted
    const R = 100;
    const knotFactor = knots * 0.5;

    for (let i = 0; i < numPoints; i++) {
      const t = (i / numPoints) * Math.PI * 2;

      // Trefoil-like parametric curve for knotted plasmid
      let x, y, z;
      if (knots > 0) {
        const r2 = R * 0.4;
        x = (R + r2 * Math.cos(1.5 * t * Math.min(knots, 3))) * Math.cos(t);
        y = (R + r2 * Math.cos(1.5 * t * Math.min(knots, 3))) * Math.sin(t);
        z = r2 * Math.sin(1.5 * t * Math.min(knots, 3));
      } else {
        x = R * Math.cos(t);
        y = R * Math.sin(t);
        z = 0;
      }

      const helixOff = 6;
      const helixFreq = t * 15;

      const nx = -Math.sin(t);
      const ny = Math.cos(t);

      const x1 = x + helixOff * nx * Math.cos(helixFreq);
      const y1 = y + helixOff * ny * Math.cos(helixFreq);
      const z1 = z + helixOff * Math.sin(helixFreq);

      const x2 = x + helixOff * nx * Math.cos(helixFreq + Math.PI);
      const y2 = y + helixOff * ny * Math.cos(helixFreq + Math.PI);
      const z2 = z + helixOff * Math.sin(helixFreq + Math.PI);

      const p1 = project3D(x1, y1, z1, cx, cy, scale);
      const p2 = project3D(x2, y2, z2, cx, cy, scale);

      strand1.push(p1);
      strand2.push(p2);

      if (i % 8 === 0) basePairs.push({ a: p1, b: p2 });
    }
  } else if (mode === 'catenane') {
    // Two linked rings
    const R = 80;
    const sep = 50;

    for (let ring = 0; ring < 2; ring++) {
      const pts1 = [];
      const pts2 = [];
      for (let i = 0; i < numPoints / 2; i++) {
        const t = (i / (numPoints / 2)) * Math.PI * 2;
        let x, y, z;
        if (ring === 0) {
          x = R * Math.cos(t);
          y = R * Math.sin(t);
          z = 0;
        } else {
          x = sep + R * Math.cos(t);
          y = 0;
          z = R * Math.sin(t);
        }

        const helixOff = 5;
        const helixFreq = t * 12;
        const tx = ring === 0 ? -Math.sin(t) : -Math.sin(t);
        const ty = ring === 0 ? Math.cos(t) : 0;
        const tz = ring === 0 ? 0 : Math.cos(t);

        const p1 = project3D(x + helixOff * Math.cos(helixFreq) * tx, y + helixOff * Math.cos(helixFreq) * ty, z + helixOff * Math.cos(helixFreq) * tz, cx, cy, scale);
        const p2 = project3D(x - helixOff * Math.cos(helixFreq) * tx, y - helixOff * Math.cos(helixFreq) * ty, z - helixOff * Math.cos(helixFreq) * tz, cx, cy, scale);

        pts1.push(p1);
        pts2.push(p2);

        if (i % 8 === 0) basePairs.push({ a: p1, b: p2 });
      }
      if (ring === 0) {
        strand1.push(...pts1);
        strand2.push(...pts2);
      } else {
        strand1.push(null); // separator
        strand1.push(...pts1);
        strand2.push(null);
        strand2.push(...pts2);
      }
    }
  }

  // Sort and draw by depth
  // Draw base pairs first (behind strands)
  if (showBasePairs) {
    for (const bp of basePairs) {
      const alpha = Math.max(0.1, Math.min(0.6, 0.4 + bp.a.z * 0.002));
      ctx.beginPath();
      ctx.moveTo(bp.a.x, bp.a.y);
      ctx.lineTo(bp.b.x, bp.b.y);
      ctx.strokeStyle = `rgba(80,200,120,${alpha})`;
      ctx.lineWidth = 1.5 * ((bp.a.s + bp.b.s) / 2);
      ctx.stroke();
    }
  }

  // Draw strands
  drawStrand(strand1, '#4a8ef7', '#2060cc');
  drawStrand(strand2, '#f74a4a', '#cc2020');

  // Topoisomerase animation
  if (topoActive) {
    topoAnim += 0.02;
    if (topoAnim >= 1) {
      topoActive = false;
      linkingNumber += linkingNumber > 0 ? -2 : 2;
      if (Math.abs(linkingNumber) < 2) linkingNumber = 0;
      knots = Math.max(0, knots - 1);
      document.getElementById('lkNum').textContent = linkingNumber;
    }

    // Draw enzyme
    const enzymeIdx = Math.floor(topoAnim * strand1.length * 0.3);
    if (enzymeIdx < strand1.length && strand1[enzymeIdx]) {
      const ep = strand1[Math.min(enzymeIdx, strand1.length - 1)];
      if (ep) {
        ctx.beginPath();
        ctx.arc(ep.x, ep.y, 15 * ep.s, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,220,50,${0.5 + 0.3 * Math.sin(time * 5)})`;
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,220,50,0.8)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Glow
        const grad = ctx.createRadialGradient(ep.x, ep.y, 0, ep.x, ep.y, 30 * ep.s);
        grad.addColorStop(0, 'rgba(255,220,50,0.3)');
        grad.addColorStop(1, 'rgba(255,220,50,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(ep.x, ep.y, 30 * ep.s, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }
}

function drawStrand(points, color, darkColor) {
  ctx.beginPath();
  let started = false;
  for (let i = 0; i < points.length; i++) {
    if (!points[i]) {
      if (started) ctx.stroke();
      started = false;
      continue;
    }
    const alpha = Math.max(0.3, Math.min(1.0, 0.7 + points[i].z * 0.003));
    if (!started) {
      ctx.beginPath();
      ctx.moveTo(points[i].x, points[i].y);
      started = true;
    } else {
      ctx.lineTo(points[i].x, points[i].y);
    }
  }
  // Dark border
  ctx.strokeStyle = darkColor;
  ctx.lineWidth = 5;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.stroke();

  // Main strand
  ctx.beginPath();
  started = false;
  for (let i = 0; i < points.length; i++) {
    if (!points[i]) {
      if (started) ctx.stroke();
      started = false;
      continue;
    }
    if (!started) {
      ctx.beginPath();
      ctx.moveTo(points[i].x, points[i].y);
      started = true;
    } else {
      ctx.lineTo(points[i].x, points[i].y);
    }
  }
  ctx.strokeStyle = color;
  ctx.lineWidth = 3;
  ctx.stroke();

  // Highlight
  ctx.beginPath();
  started = false;
  for (let i = 0; i < points.length; i++) {
    if (!points[i]) {
      if (started) ctx.stroke();
      started = false;
      continue;
    }
    if (!started) {
      ctx.beginPath();
      ctx.moveTo(points[i].x, points[i].y);
      started = true;
    } else {
      ctx.lineTo(points[i].x, points[i].y);
    }
  }
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  ctx.stroke();
}

// Controls
document.getElementById('supercoil').addEventListener('input', function() {
  supercoilVal = parseInt(this.value);
  document.getElementById('scVal').textContent = (supercoilVal / 10).toFixed(1);
  linkingNumber = Math.round(supercoilVal / 5);
  document.getElementById('lkNum').textContent = linkingNumber;
});

document.getElementById('rotSpeed').addEventListener('input', function() {
  rotSpeed = parseInt(this.value) / 100;
});

document.getElementById('showBP').addEventListener('change', function() {
  showBasePairs = this.checked;
});

window.addEventListener('resize', resize);

// Mouse drag rotation
let dragging = false;
let lastX = 0;
canvas.addEventListener('mousedown', e => { dragging = true; lastX = e.clientX; });
canvas.addEventListener('mousemove', e => {
  if (dragging) {
    rotAngle += (e.clientX - lastX) * 0.005;
    lastX = e.clientX;
  }
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);

// Touch support
canvas.addEventListener('touchstart', e => { dragging = true; lastX = e.touches[0].clientX; });
canvas.addEventListener('touchmove', e => {
  if (dragging) {
    rotAngle += (e.touches[0].clientX - lastX) * 0.005;
    lastX = e.touches[0].clientX;
  }
});
canvas.addEventListener('touchend', () => dragging = false);

let time = 0;
function animate() {
  time += 0.016;
  if (!dragging) rotAngle += rotSpeed * 0.02;

  ctx.fillStyle = '#0a0e1a';
  ctx.fillRect(0, 0, W, H);

  // Ambient glow
  const grad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, H * 0.4);
  grad.addColorStop(0, 'rgba(30,50,100,0.15)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  drawDNA(time);
  requestAnimationFrame(animate);
}

window.reset = function() {
  mode = 'supercoil';
  supercoilVal = 0;
  rotAngle = 0;
  rotSpeed = 0.3;
  showBasePairs = true;
  linkingNumber = 0;
  knots = 0;
  topoActive = false;
  document.getElementById('supercoil').value = 0;
  document.getElementById('scVal').textContent = '0';
  document.getElementById('rotSpeed').value = 30;
  document.getElementById('showBP').checked = true;
  document.getElementById('lkNum').textContent = 0;
  setMode('supercoil');
};

resize();
animate();
</script>
<script src="../assets/js/enhance.js"></script>
</body>
</html>