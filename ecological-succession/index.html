<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ecological Succession</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0e1a; overflow: hidden; font-family: sans-serif; }
canvas { display: block; }
#title {
    position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
    color: #fbbf24; font-size: 22px; font-weight: bold; text-align: center;
    text-shadow: 0 0 20px rgba(251,191,36,0.3); z-index: 10; pointer-events: none;
}
#controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 20px; z-index: 10; background: rgba(0,0,0,0.7);
    padding: 12px 20px; border-radius: 10px; align-items: center;
}
.ctrl { display: flex; flex-direction: column; align-items: center; }
.ctrl label { color: #ccc; font-size: 11px; margin-bottom: 4px; }
.ctrl input[type=range] { width: 100px; accent-color: #fbbf24; }
.ctrl span { color: #fbbf24; font-size: 11px; margin-top: 2px; }
button {
    background: rgba(251,191,36,0.2); color: #fbbf24; border: 1px solid #fbbf24;
    padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 12px;
}
button:hover { background: rgba(251,191,36,0.4); }
#legend {
    position: fixed; top: 50px; right: 20px; color: #ccc; font-size: 12px;
    background: rgba(0,0,0,0.7); padding: 12px 16px; border-radius: 8px; z-index: 10;
    line-height: 2;
}
.leg-item { display: flex; align-items: center; gap: 8px; }
.leg-dot { width: 12px; height: 12px; border-radius: 3px; display: inline-block; }
#info {
    position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
    margin-top: 35px; color: #ccc; font-size: 12px;
    background: rgba(0,0,0,0.5); padding: 6px 14px; border-radius: 6px; z-index: 10;
    pointer-events: none;
}
</style>
</head>
<body>
<a href="../index.html" style="position:fixed;top:10px;left:10px;padding:8px 16px;background:rgba(0,0,0,0.7);color:#fbbf24;text-decoration:none;border-radius:6px;font-size:14px;z-index:999;font-family:sans-serif;">‚Üê Back to Gallery</a>
<div id="title">Ecological Succession</div>
<div id="info">Year: <span id="year">0</span> | Stage: <span id="stage">Bare Rock</span></div>
<div id="legend">
    <div class="leg-item"><span class="leg-dot" style="background:#6b7280;"></span> Bare Rock</div>
    <div class="leg-item"><span class="leg-dot" style="background:#84cc16;"></span> Lichens</div>
    <div class="leg-item"><span class="leg-dot" style="background:#a3e635;"></span> Mosses</div>
    <div class="leg-item"><span class="leg-dot" style="background:#65a30d;"></span> Grasses</div>
    <div class="leg-item"><span class="leg-dot" style="background:#16a34a;"></span> Shrubs</div>
    <div class="leg-item"><span class="leg-dot" style="background:#15803d;"></span> Young Trees</div>
    <div class="leg-item"><span class="leg-dot" style="background:#166534;"></span> Climax Forest</div>
</div>
<div id="controls">
    <div class="ctrl">
        <label>Succession Speed</label>
        <input type="range" id="speed" min="1" max="10" step="1" value="4">
        <span id="speedVal">4</span>
    </div>
    <div class="ctrl">
        <label>Disturbance</label>
        <input type="range" id="disturb" min="0" max="0.01" step="0.001" value="0.002">
        <span id="disturbVal">0.002</span>
    </div>
    <button id="resetBtn">Reset (Clear)</button>
    <button id="fireBtn">Wildfire!</button>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const STAGES = {
    BARE: 0, LICHEN: 1, MOSS: 2, GRASS: 3, SHRUB: 4, YOUNG_TREE: 5, CLIMAX: 6
};

const STAGE_COLORS = [
    [107, 114, 128],  // bare rock - gray
    [132, 204, 22],   // lichen - yellow-green
    [163, 230, 53],   // moss - bright green
    [101, 163, 13],   // grass - green
    [22, 163, 74],    // shrub - dark green
    [21, 128, 61],    // young tree - forest green
    [22, 101, 52],    // climax - deep green
];

const STAGE_NAMES = ['Bare Rock', 'Lichens', 'Mosses', 'Grasses', 'Shrubs', 'Young Trees', 'Climax Forest'];

let cellSize;
let cols, rows;
let grid;
let year = 0;
let speed = 4;
let disturbance = 0.002;
let stageHistory = [];
const MAX_HISTORY = 300;

document.getElementById('speed').oninput = function() {
    speed = parseInt(this.value);
    document.getElementById('speedVal').textContent = this.value;
};
document.getElementById('disturb').oninput = function() {
    disturbance = parseFloat(this.value);
    document.getElementById('disturbVal').textContent = this.value;
};

function init() {
    cellSize = Math.max(4, Math.min(8, Math.floor(Math.min(canvas.width, canvas.height) / 120)));
    cols = Math.floor(canvas.width / cellSize);
    rows = Math.floor((canvas.height - 60) / cellSize);
    grid = new Uint8Array(cols * rows);
    year = 0;
    stageHistory = [];

    // Start with mostly bare, a few lichens scattered
    for (let i = 0; i < cols * rows; i++) {
        grid[i] = STAGES.BARE;
    }
    // Seed a few lichens
    for (let i = 0; i < 20; i++) {
        let x = Math.floor(Math.random() * cols);
        let y = Math.floor(Math.random() * rows);
        grid[y * cols + x] = STAGES.LICHEN;
    }
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    init();
}
resize();
window.addEventListener('resize', resize);

document.getElementById('resetBtn').onclick = init;
document.getElementById('fireBtn').onclick = function() {
    // Wildfire - reset most cells to bare or lichen
    for (let i = 0; i < cols * rows; i++) {
        if (grid[i] >= STAGES.GRASS) {
            if (Math.random() < 0.8) {
                grid[i] = STAGES.BARE;
            } else {
                grid[i] = STAGES.LICHEN;
            }
        }
    }
};

let frameCount = 0;

function getNeighborStages(x, y) {
    let stages = new Array(7).fill(0);
    for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            let nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                stages[grid[ny * cols + nx]]++;
            }
        }
    }
    return stages;
}

function updateGrid() {
    let newGrid = new Uint8Array(grid);

    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            let idx = y * cols + x;
            let current = grid[idx];
            let neighbors = getNeighborStages(x, y);

            // Disturbance - random setback
            if (current > STAGES.BARE && Math.random() < disturbance) {
                newGrid[idx] = Math.max(STAGES.BARE, current - 1 - Math.floor(Math.random() * 2));
                continue;
            }

            // Succession logic
            let successionProb = 0;
            let nextStage = current;

            switch (current) {
                case STAGES.BARE:
                    // Lichen colonization
                    if (neighbors[STAGES.LICHEN] > 0) successionProb = 0.03;
                    else successionProb = 0.002; // spontaneous
                    nextStage = STAGES.LICHEN;
                    break;
                case STAGES.LICHEN:
                    if (neighbors[STAGES.MOSS] > 0) successionProb = 0.025;
                    else if (neighbors[STAGES.LICHEN] > 3) successionProb = 0.008;
                    nextStage = STAGES.MOSS;
                    break;
                case STAGES.MOSS:
                    if (neighbors[STAGES.GRASS] > 0) successionProb = 0.02;
                    else if (neighbors[STAGES.MOSS] > 3) successionProb = 0.006;
                    nextStage = STAGES.GRASS;
                    break;
                case STAGES.GRASS:
                    if (neighbors[STAGES.SHRUB] > 0) successionProb = 0.015;
                    else if (neighbors[STAGES.GRASS] > 4) successionProb = 0.004;
                    nextStage = STAGES.SHRUB;
                    break;
                case STAGES.SHRUB:
                    if (neighbors[STAGES.YOUNG_TREE] > 0) successionProb = 0.01;
                    else if (neighbors[STAGES.SHRUB] > 3) successionProb = 0.003;
                    nextStage = STAGES.YOUNG_TREE;
                    break;
                case STAGES.YOUNG_TREE:
                    if (neighbors[STAGES.CLIMAX] > 0) successionProb = 0.008;
                    else if (neighbors[STAGES.YOUNG_TREE] > 3) successionProb = 0.002;
                    nextStage = STAGES.CLIMAX;
                    break;
            }

            if (Math.random() < successionProb) {
                newGrid[idx] = nextStage;
            }
        }
    }
    grid = newGrid;
}

function update() {
    frameCount++;

    for (let s = 0; s < speed; s++) {
        updateGrid();
    }

    year += speed;
    document.getElementById('year').textContent = year;

    // Determine dominant stage
    let counts = new Array(7).fill(0);
    for (let i = 0; i < cols * rows; i++) {
        counts[grid[i]]++;
    }
    let dominant = 0;
    for (let i = 1; i < 7; i++) {
        if (counts[i] > counts[dominant]) dominant = i;
    }
    document.getElementById('stage').textContent = STAGE_NAMES[dominant];

    if (frameCount % 3 === 0) {
        let total = cols * rows;
        stageHistory.push(counts.map(c => c / total));
        if (stageHistory.length > MAX_HISTORY) stageHistory.shift();
    }
}

function drawGrid(ctx) {
    let offsetY = 50;
    let imgData = ctx.createImageData(cols, rows);
    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            let idx = y * cols + x;
            let stage = grid[idx];
            let c = STAGE_COLORS[stage];
            // Add slight variation
            let v = (Math.sin(x * 0.5 + y * 0.3) * 10) | 0;
            let pi = (y * cols + x) * 4;
            imgData.data[pi] = Math.min(255, Math.max(0, c[0] + v));
            imgData.data[pi + 1] = Math.min(255, Math.max(0, c[1] + v));
            imgData.data[pi + 2] = Math.min(255, Math.max(0, c[2] + v));
            imgData.data[pi + 3] = 255;
        }
    }

    // Scale up
    let tempCanvas = document.createElement('canvas');
    tempCanvas.width = cols;
    tempCanvas.height = rows;
    tempCanvas.getContext('2d').putImageData(imgData, 0, 0);

    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(tempCanvas, 0, offsetY, cols * cellSize, rows * cellSize);
    ctx.imageSmoothingEnabled = true;
}

function drawGraph(ctx) {
    let gw = 280, gh = 100;
    let gx = 20, gy = canvas.height - gh - 80;

    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.strokeStyle = 'rgba(251,191,36,0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(gx - 10, gy - 25, gw + 20, gh + 40, 8);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = '#fbbf24';
    ctx.font = '11px sans-serif';
    ctx.fillText('Stage Distribution Over Time', gx + 5, gy - 10);

    if (stageHistory.length < 2) return;

    // Stacked area chart
    for (let s = 6; s >= 0; s--) {
        ctx.beginPath();
        for (let i = 0; i < stageHistory.length; i++) {
            let x = gx + (i / MAX_HISTORY) * gw;
            let cumulative = 0;
            for (let j = 0; j <= s; j++) {
                cumulative += stageHistory[i][j];
            }
            let y = gy + gh - cumulative * gh;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        // Close bottom
        for (let i = stageHistory.length - 1; i >= 0; i--) {
            let x = gx + (i / MAX_HISTORY) * gw;
            let cumulative = 0;
            for (let j = 0; j < s; j++) {
                cumulative += stageHistory[i][j];
            }
            let y = gy + gh - cumulative * gh;
            ctx.lineTo(x, y);
        }
        ctx.closePath();
        let c = STAGE_COLORS[s];
        ctx.fillStyle = `rgba(${c[0]}, ${c[1]}, ${c[2]}, 0.7)`;
        ctx.fill();
    }
}

function draw() {
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawGrid(ctx);
    drawGraph(ctx);
}

function animate() {
    update();
    draw();
    requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
