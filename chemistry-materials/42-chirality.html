<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chirality Explorer - CCAB</title>
    <link rel="stylesheet" href="../assets/css/gallery-standard.css">
    <style>
        body {
            background: #f0fdfa;
            color: #333;
            font-family: system-ui;
            padding: 2rem;
            text-align: center;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        
        .viewports {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        
        canvas {
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            cursor: move;
        }
        
        .mirror-line {
            width: 4px;
            background: #cbd5e1;
            margin: 0 10px;
        }
        
        .controls {
            margin: 20px;
        }
        
        button {
            padding: 10px 20px;
            background: #0d9488;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover { background: #0f766e; }
        
    </style>
</head>
<body>

<div class="container">
    <a href="../index.html" class="gallery-back">‚Üê Back to Gallery</a>
    <h1>Molecular Chirality</h1>
    <p>Enantiomers are mirror images that cannot be superimposed.</p>
    
    <div class="viewports">
        <canvas id="c1" width="400" height="400"></canvas>
        <div class="mirror-line"></div>
        <canvas id="c2" width="400" height="400"></canvas>
    </div>
    
    <div class="controls">
        <button onclick="trySuperimpose()">Attempt Superposition</button>
        <button onclick="reset()">Reset</button>
    </div>
    
    <p id="status">Drag to rotate molecules.</p>
</div>

<script>
    // Simple 3D Engine
    function project(x, y, z, w, h) {
        const scale = 300 / (4 + z);
        return {
            x: w/2 + x * scale * 100,
            y: h/2 - y * scale * 100,
            r: scale * 10
        };
    }
    
    // Molecule Definition (Tetrahedral Center)
    // Center: C (0,0,0)
    // 4 Groups: H, F, Cl, Br (Different colors)
    // Pos: tetra vertices
    
    const baseAtoms = [
        { x: 0, y: 0, z: 0, color: '#333', r: 1.2 }, // Carbon
        { x: 0, y: 1, z: 0, color: '#ef4444', r: 1 }, // Top (Red)
        { x: 0.94, y: -0.33, z: 0, color: '#3b82f6', r: 1 }, // Right (Blue)
        { x: -0.47, y: -0.33, z: 0.81, color: '#10b981', r: 1 }, // Front Left (Green)
        { x: -0.47, y: -0.33, z: -0.81, color: '#fcd34d', r: 1 } // Back Left (Yellow)
    ];
    
    // Bonds: 0 to 1, 0 to 2, 0 to 3, 0 to 4
    
    let mol1 = { atoms: JSON.parse(JSON.stringify(baseAtoms)), rotX: 0, rotY: 0 };
    let mol2 = { atoms: JSON.parse(JSON.stringify(baseAtoms)), rotX: 0, rotY: 0 };
    
    // Mirror Mol2: Flip X coords
    mol2.atoms.forEach(a => a.x *= -1);
    
    // Interaction
    let dragging = false;
    let lastX, lastY;
    let activeMol = null;
    
    [document.getElementById('c1'), document.getElementById('c2')].forEach((c, idx) => {
        c.addEventListener('mousedown', e => {
            dragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            activeMol = idx === 0 ? mol1 : mol2;
        });
    });
    
    window.addEventListener('mouseup', () => dragging = false);
    window.addEventListener('mousemove', e => {
        if (dragging && activeMol) {
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            activeMol.rotY += dx * 0.01;
            activeMol.rotX += dy * 0.01;
            lastX = e.clientX;
            lastY = e.clientY;
        }
    });
    
    function reset() {
        mol1.rotX = 0; mol1.rotY = 0;
        mol2.rotX = 0; mol2.rotY = 0;
        
        mol1.atoms = JSON.parse(JSON.stringify(baseAtoms));
        mol2.atoms = JSON.parse(JSON.stringify(baseAtoms));
        mol2.atoms.forEach(a => a.x *= -1);
        
        mol2.offsetX = 0; // reset superposition
        
        document.getElementById('status').textContent = "Drag to rotate molecules.";
    }
    
    let superimposing = false;
    
    function trySuperimpose() {
        if (superimposing) return;
        superimposing = true;
        document.getElementById('status').textContent = "Attempting to align...";
        
        // Animate Mol2 sliding onto Mol1
        // Actually physically impossible to align all 4 if chiral.
        // We will align C and Red/Blue, showing Green/Yellow mismatch.
        
        // Reset rotations to match visually first
        mol1.rotX = 0; mol1.rotY = 0;
        mol2.rotX = 0; mol2.rotY = 0;
        
        // Slide animation? Or just snap logic?
        // Let's just visually show them overlapping
        // We'll render Mol2 in Canvas 1?
    }
    
    function loop() {
        drawMol(document.getElementById('c1'), mol1);
        
        if (superimposing) {
            // Draw Mol2 phantom on C1
            drawMol(document.getElementById('c1'), mol2, true);
            // Also draw normal on C2
            drawMol(document.getElementById('c2'), mol2);
        } else {
            drawMol(document.getElementById('c2'), mol2);
        }
        
        requestAnimationFrame(loop);
    }
    
    function drawMol(canvas, mol, ghost = false) {
        const ctx = canvas.getContext('2d');
        if (!ghost) ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Sort atoms by Z for Painter's algo
        // Need to apply rotation to get Z
        const renderList = [];
        
        mol.atoms.forEach((a, i) => {
            // Rotate Y
            let x = a.x * Math.cos(mol.rotY) - a.z * Math.sin(mol.rotY);
            let z = a.x * Math.sin(mol.rotY) + a.z * Math.cos(mol.rotY);
            // Rotate X
            let y = a.y * Math.cos(mol.rotX) - z * Math.sin(mol.rotX);
            z = a.y * Math.sin(mol.rotX) + z * Math.cos(mol.rotX);
            
            renderList.push({ x, y, z, color: a.color, r: a.r, isAtom: true, idx: i });
            
            // Bonds (Center to Atom)
            if (i > 0) {
                // Add bond segment (approx)
                // Center is 0,0,0 (rotated)
                // We actually need 0,0,0 relative to C
                // C is index 0.
                // Just use line to (0,0,0) after rot?
                // C is at 0,0,0 pre-rotation.
                // So rotated C is at (0,0,0) if we rotate around center.
                // Yes.
                renderList.push({
                    isBond: true,
                    x1: 0, y1: 0, z1: 0, // C is center
                    x2: x, y2: y, z2: z,
                    z: z // use midpoint z for sorting?
                });
            }
        });
        
        renderList.sort((a,b) => (a.z || a.z2) - (b.z || b.z2));
        
        renderList.forEach(item => {
            if (item.isBond) {
                const p1 = project(0,0,0, canvas.width, canvas.height);
                const p2 = project(item.x2, item.y2, item.z2, canvas.width, canvas.height);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.strokeStyle = ghost ? 'rgba(0,0,0,0.2)' : '#555';
                ctx.lineWidth = 5;
                ctx.stroke();
            } else {
                const p = project(item.x, item.y, item.z, canvas.width, canvas.height);
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * 15, 0, Math.PI*2);
                ctx.fillStyle = ghost ? item.color + '44' : item.color; // Transparent if ghost
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        });
    }
    
    // Expose for enhance.js keyboard shortcuts
    window.reset = reset;
    window.init = reset;

    requestAnimationFrame(loop);

</script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
