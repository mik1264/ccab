<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lennard-Jones Potential - CCAB</title>
    <link rel="stylesheet" href="../assets/css/gallery-standard.css">
    <style>
        body {
            background: #111;
            color: #ddd;
            font-family: system-ui;
            padding: 2rem;
            text-align: center;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        
        .simulation {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        canvas {
            background: #222;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        .controls {
            background: #333;
            padding: 20px;
            border-radius: 8px;
            display: inline-block;
        }
        
        button {
            padding: 8px 16px;
            background: #0ea5e9;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
    </style>
</head>
<body>

<div class="container">
    <a href="../index.html" class="gallery-back">‚Üê Back to Gallery</a>
    <h1>Lennard-Jones Potential</h1>
    <p>Interatomic potential \( V(r) = 4\epsilon \left[ \left( \frac{\sigma}{r} \right)^{12} - \left( \frac{\sigma}{r} \right)^6 \right] \)</p>
    
    <div class="simulation">
        <div>
            <h3>Particle Simulation</h3>
            <canvas id="sim-canvas" width="400" height="400"></canvas>
        </div>
        <div>
            <h3>Potential Energy Graph</h3>
            <canvas id="graph-canvas" width="400" height="400"></canvas>
        </div>
    </div>
    
    <div class="controls">
        <button onclick="reset()">Reset Positions</button>
        <button onclick="toggleHeat()">Toggle Heat</button>
    </div>
</div>

<script>
    const simCanvas = document.getElementById('sim-canvas');
    const ctxSim = simCanvas.getContext('2d');
    const graphCanvas = document.getElementById('graph-canvas');
    const ctxGraph = graphCanvas.getContext('2d');
    
    // Constants
    const epsilon = 1.0;
    const sigma = 40; // pixels
    const rCutoff = 3 * sigma;
    
    // State
    let particles = [];
    const N = 2; // Two particles for clarity, or more? Let's do 2 interactively first.
    
    // Let's do 2 particles: One fixed at center, one mouse-controlled or free moving?
    // Let's do free moving 2 particle system to show oscillation.
    
    function reset() {
        particles = [
            { x: 150, y: 200, vx: 0, vy: 0, r: 15, color: '#ef4444' }, // Fixed? No let them move
            { x: 250, y: 200, vx: 0, vy: 0, r: 15, color: '#3b82f6' }
        ];
    }
    
    let dragging = false;
    let dragIdx = -1;
    
    simCanvas.addEventListener('mousedown', e => {
        const rect = simCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        particles.forEach((p, i) => {
            if (Math.hypot(p.x - x, p.y - y) < p.r * 2) {
                dragging = true;
                dragIdx = i;
            }
        });
    });
    
    simCanvas.addEventListener('mousemove', e => {
        if (dragging && dragIdx !== -1) {
            const rect = simCanvas.getBoundingClientRect();
            particles[dragIdx].x = e.clientX - rect.left;
            particles[dragIdx].y = e.clientY - rect.top;
            particles[dragIdx].vx = 0;
            particles[dragIdx].vy = 0;
        }
    });
    
    window.addEventListener('mouseup', () => { dragging = false; dragIdx = -1; });
    
    function toggleHeat() {
        particles.forEach(p => {
            p.vx += (Math.random()-0.5) * 2;
            p.vy += (Math.random()-0.5) * 2;
        });
    }
    
    function loop() {
        // Physics
        if (!dragging) {
            // Apply Forces
            const p1 = particles[0];
            const p2 = particles[1];
            
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const r = Math.hypot(dx, dy);
            
            if (r > 0) {
                // Force F = -dV/dr
                // V = 4eps [ (sig/r)^12 - (sig/r)^6 ]
                // F = 24eps/r [ 2(sig/r)^12 - (sig/r)^6 ]
                // Force positive = repulsive? 
                // Careful with signs.
                // dV/dr = 4eps [ 12(sig/r)^11 * (-sig/r^2) - 6(sig/r)^5 * (-sig/r^2) ]
                // = -24eps/r [ 2(sig/r)^12 - (sig/r)^6 ]
                // F = -dV/dr = 24eps/r [ 2(sig/r)^12 - (sig/r)^6 ]
                // If r < sigma, terms are > 1. (sig/r)^12 dominates. F is large positive (Repulsive).
                // If r > sigma, (sig/r)^6 dominates. F is negative (Attractive).
                
                // Scale factor for simulation stability
                const forceMag = (24 * epsilon / r) * (2 * Math.pow(sigma/r, 12) - Math.pow(sigma/r, 6));
                
                // Clamp force to avoid explosion at r -> 0
                const maxF = 2.0;
                const F = Math.max(-maxF, Math.min(maxF, forceMag));
                
                const fx = (dx / r) * F;
                const fy = (dy / r) * F;
                
                // Apply to p1 (Newton 3rd: Equal and opposite)
                // Force is repulsive if F > 0.
                // p1 is pushed away from p2 (-dx direction)
                p1.vx -= fx;
                p1.vy -= fy;
                
                p2.vx += fx;
                p2.vy += fy;
            }
            
            // Integrate
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                
                // Damping
                p.vx *= 0.98;
                p.vy *= 0.98;
                
                // Walls
                if (p.x < 0 || p.x > 400) p.vx *= -1;
                if (p.y < 0 || p.y > 400) p.vy *= -1;
            });
        }
        
        drawSim();
        drawGraph();
        requestAnimationFrame(loop);
    }
    
    function drawSim() {
        ctxSim.clearRect(0, 0, 400, 400);
        
        // Draw interaction line
        const p1 = particles[0];
        const p2 = particles[1];
        ctxSim.strokeStyle = '#555';
        ctxSim.setLineDash([5, 5]);
        ctxSim.beginPath();
        ctxSim.moveTo(p1.x, p1.y);
        ctxSim.lineTo(p2.x, p2.y);
        ctxSim.stroke();
        ctxSim.setLineDash([]);
        
        particles.forEach(p => {
            ctxSim.fillStyle = p.color;
            ctxSim.beginPath();
            ctxSim.arc(p.x, p.y, p.r, 0, Math.PI*2);
            ctxSim.fill();
            
            // Halo
            ctxSim.fillStyle = 'rgba(255,255,255,0.1)';
            ctxSim.beginPath();
            ctxSim.arc(p.x, p.y, sigma/2, 0, Math.PI*2); // approx vdw radius
            ctxSim.fill();
        });
    }
    
    function drawGraph() {
        ctxGraph.clearRect(0, 0, 400, 400);
        
        // Axes
        // Origin at (50, 200)
        const ox = 50;
        const oy = 200;
        const scaleX = 2; // pixels per unit r
        const scaleY = 50; // pixels per unit V
        
        ctxGraph.strokeStyle = '#888';
        ctxGraph.lineWidth = 1;
        ctxGraph.beginPath();
        ctxGraph.moveTo(ox, 0); ctxGraph.lineTo(ox, 400); // Y
        ctxGraph.moveTo(0, oy); ctxGraph.lineTo(400, oy); // X
        ctxGraph.stroke();
        
        // Plot V(r)
        ctxGraph.strokeStyle = '#fcd34d';
        ctxGraph.lineWidth = 2;
        ctxGraph.beginPath();
        
        for (let px = 0; px < 350; px++) {
            const r = (px / scaleX) + 1; // start from r=1 to avoid div0
            // r corresponds to distance in simulation pixels?
            // In sim, r is distance between particles.
            // sigma is 40.
            
            // Actually let's just plot generic LJ curve scaled to canvas
            // x-axis is r.
            // Let's say r_sim = r_graph.
            
            if (r < 10) continue; // Skip singularity
            
            const term1 = Math.pow(sigma/r, 12);
            const term2 = Math.pow(sigma/r, 6);
            const V = 4 * epsilon * (term1 - term2);
            
            // Clamp V for display
            if (V > 5) continue;
            
            const py = oy - V * scaleY * 20; // scale up V for visibility
            
            if (px === 0) ctxGraph.moveTo(ox + px, py);
            else ctxGraph.lineTo(ox + px, py);
        }
        ctxGraph.stroke();
        
        // Current State Dot
        const dx = particles[1].x - particles[0].x;
        const dy = particles[1].y - particles[0].y;
        const dist = Math.hypot(dx, dy);
        
        // Calculate V at this dist
        const term1 = Math.pow(sigma/dist, 12);
        const term2 = Math.pow(sigma/dist, 6);
        const Vcurr = 4 * epsilon * (term1 - term2);
        
        const dotX = ox + dist; // Using same scale? wait
        // In loop I used px directly as r.
        // So graph X pixel = r - 1? 
        // Need to match scales.
        // Let's say Graph X pixel = r * 1.
        // So dist fits on 400px wide graph.
        
        const dotY = oy - Vcurr * scaleY * 20;
        
        ctxGraph.fillStyle = '#fff';
        ctxGraph.beginPath();
        ctxGraph.arc(ox + dist * scaleX, dotY, 5, 0, Math.PI*2); // Wait, scaleX was used implicitly?
        // In loop: px goes 0 to 350. r = px/2 + 1. So r goes 1 to 176.
        // Sim distance goes up to 400.
        // So we need to map sim distance to graph.
        // Let's just use: Graph X = Sim Distance.
        
        // Re-draw graph matching sim distance
        ctxGraph.clearRect(0, 0, 400, 400); // clear again
        ctxGraph.strokeStyle = '#888';
        ctxGraph.beginPath();
        ctxGraph.moveTo(ox, 0); ctxGraph.lineTo(ox, 400); 
        ctxGraph.moveTo(0, oy); ctxGraph.lineTo(400, oy);
        ctxGraph.stroke();
        
        ctxGraph.beginPath();
        ctxGraph.strokeStyle = '#fcd34d';
        for(let r=10; r<350; r++) {
            const t1 = Math.pow(sigma/r, 12);
            const t2 = Math.pow(sigma/r, 6);
            const V = 4 * epsilon * (t1 - t2);
            const py = oy - V * 50; // Simple scale
            if (py < -50 || py > 450) continue;
            
            if (r===10) ctxGraph.moveTo(ox + r, py);
            else ctxGraph.lineTo(ox + r, py);
        }
        ctxGraph.stroke();
        
        // Dot
        const py = oy - Vcurr * 50;
        ctxGraph.fillStyle = '#fff';
        ctxGraph.beginPath();
        ctxGraph.arc(ox + dist, py, 5, 0, Math.PI*2);
        ctxGraph.fill();
        
        // Force Text
        ctxGraph.fillStyle = '#fff';
        ctxGraph.fillText(`r = ${dist.toFixed(1)}`, 250, 50);
        ctxGraph.fillText(`V = ${Vcurr.toFixed(2)}`, 250, 70);
    }
    
    reset();
    requestAnimationFrame(loop);

</script>
</body>
</html>
