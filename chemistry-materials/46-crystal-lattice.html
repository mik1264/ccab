<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crystal Lattice Builder - CCAB</title>
    <link rel="stylesheet" href="../assets/css/gallery-standard.css">
    <style>
        body {
            background: #111;
            color: #ddd;
            font-family: system-ui;
            padding: 2rem;
            text-align: center;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        
        canvas {
            background: #000;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            cursor: move;
        }
        
        .controls {
            margin: 20px;
            display: inline-flex;
            gap: 10px;
        }
        
        button {
            padding: 10px 20px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
        }
        button.active { background: #0ea5e9; border-color: #0ea5e9; }
        
        .info {
            margin-top: 10px;
            font-size: 1.1rem;
            color: #0ea5e9;
        }
        
    </style>
</head>
<body>

<div class="container">
    <a href="../index.html" class="gallery-back">‚Üê Back to Gallery</a>
    <h1>Crystal Lattice Builder</h1>
    <p>Bravais Lattices: Simple Cubic (SC), Body-Centered Cubic (BCC), Face-Centered Cubic (FCC).</p>
    
    <canvas id="canvas" width="600" height="600"></canvas>
    
    <div class="controls">
        <button onclick="setMode('SC')" id="btn-sc" class="active">Simple Cubic</button>
        <button onclick="setMode('BCC')" id="btn-bcc">Body-Centered</button>
        <button onclick="setMode('FCC')" id="btn-fcc">Face-Centered</button>
    </div>
    
    <div id="info" class="info">Packing Efficiency: 52%</div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let mode = 'SC';
    let rotX = 0.5;
    let rotY = 0.5;
    let atoms = [];
    
    // Config
    const SIZE = 200;
    
    function setMode(m) {
        mode = m;
        document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        document.getElementById(`btn-${m.toLowerCase()}`).classList.add('active');
        
        let eff = "52%";
        if (m === 'BCC') eff = "68%";
        if (m === 'FCC') eff = "74%";
        document.getElementById('info').textContent = `Packing Efficiency: ${eff}`;
        
        buildLattice();
        draw();
    }
    
    function buildLattice() {
        atoms = [];
        const r = 20;
        
        // Corners (All modes have this)
        // Normalized coords -1 to 1
        for(let x=-1; x<=1; x+=2) {
            for(let y=-1; y<=1; y+=2) {
                for(let z=-1; z<=1; z+=2) {
                    atoms.push({ x, y, z, color: '#ef4444', type: 'corner' });
                }
            }
        }
        
        if (mode === 'BCC') {
            // Center atom
            atoms.push({ x: 0, y: 0, z: 0, color: '#3b82f6', type: 'center' });
        }
        
        if (mode === 'FCC') {
            // Face centers
            // Faces at x=+-1, y=+-1, z=+-1
            // x faces (0, y, z) -> NO, faces are at x=1 and x=-1
            // Center of face x=1 is (1, 0, 0)
            
            atoms.push({ x: 1, y: 0, z: 0, color: '#10b981', type: 'face' });
            atoms.push({ x: -1, y: 0, z: 0, color: '#10b981', type: 'face' });
            atoms.push({ x: 0, y: 1, z: 0, color: '#10b981', type: 'face' });
            atoms.push({ x: 0, y: -1, z: 0, color: '#10b981', type: 'face' });
            atoms.push({ x: 0, y: 0, z: 1, color: '#10b981', type: 'face' });
            atoms.push({ x: 0, y: 0, z: -1, color: '#10b981', type: 'face' });
        }
    }
    
    // Projection
    function project(x, y, z) {
        // Rotate Y
        let x1 = x * Math.cos(rotY) - z * Math.sin(rotY);
        let z1 = x * Math.sin(rotY) + z * Math.cos(rotY);
        // Rotate X
        let y2 = y * Math.cos(rotX) - z1 * Math.sin(rotX);
        let z2 = y * Math.sin(rotX) + z1 * Math.cos(rotX);
        
        const scale = 400 / (4 + z2);
        return {
            x: 300 + x1 * scale * 100,
            y: 300 + y2 * scale * 100, // +y is down
            z: z2,
            r: scale * 25
        };
    }
    
    function draw() {
        ctx.clearRect(0, 0, 600, 600);
        
        // Draw Edges (Cube Frame)
        // Project all corners first
        const corners = [];
        // Helper to get proj of corner
        // Corners are first 8 atoms
        // But let's recalculate frame to be sure
        const framePoints = [];
        for(let x=-1; x<=1; x+=2)
            for(let y=-1; y<=1; y+=2)
                for(let z=-1; z<=1; z+=2)
                    framePoints.push({x,y,z});
                    
        // Sort atoms for Painter's algo
        const renderList = atoms.map(a => {
            const p = project(a.x, a.y, a.z);
            return { ...p, color: a.color };
        });
        
        renderList.sort((a,b) => a.z - b.z); // Draw far first (low z? wait z is depth)
        // In my proj: z2. Perspective: 400 / (4+z2).
        // Larger z2 = further away?
        // z2 = y*sin + z*cos.
        // Actually typically +Z is out of screen or into screen.
        // If z2 increases, scale decreases (4+z2). So z2 is depth into screen.
        // So larger z2 is further away.
        // Sort descending Z.
        renderList.sort((a,b) => b.z - a.z);
        
        // Draw Frame (Behind atoms? Or mixed? Wireframe usually behind)
        // Simple: Just draw lines between adjacent corners.
        // Only draw lines if they are "back" lines? 
        // Just draw all lines first.
        
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 2;
        
        const edges = [
            [-1,-1,-1, 1,-1,-1], [-1,-1,-1, -1,1,-1], [-1,-1,-1, -1,-1,1],
            [1,1,1, -1,1,1], [1,1,1, 1,-1,1], [1,1,1, 1,1,-1],
            [1,-1,-1, 1,1,-1], [1,-1,-1, 1,-1,1],
            [-1,1,-1, 1,1,-1], [-1,1,-1, -1,1,1],
            [-1,-1,1, 1,-1,1], [-1,-1,1, -1,1,1]
        ];
        
        edges.forEach(e => {
            const p1 = project(e[0], e[1], e[2]);
            const p2 = project(e[3], e[4], e[5]);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        });
        
        // Draw Atoms
        renderList.forEach(a => {
            ctx.fillStyle = a.color;
            ctx.beginPath();
            ctx.arc(a.x, a.y, a.r, 0, Math.PI*2);
            ctx.fill();
            
            // Shininess
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.arc(a.x - a.r*0.3, a.y - a.r*0.3, a.r*0.2, 0, Math.PI*2);
            ctx.fill();
            
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.stroke();
        });
    }
    
    // Interaction
    let dragging = false;
    let lastX, lastY;
    
    canvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    
    window.addEventListener('mouseup', () => dragging = false);
    
    canvas.addEventListener('mousemove', e => {
        if (dragging) {
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            rotY += dx * 0.01;
            rotX += dy * 0.01;
            lastX = e.clientX;
            lastY = e.clientY;
            draw();
        }
    });
    
    buildLattice();
    draw();

    // Expose for enhance.js keyboard shortcuts
    window.reset = function() { buildLattice(); draw(); };
    window.init = window.reset;

</script>
    <script src="../assets/js/enhance.js" defer></script>
</body>
</html>
